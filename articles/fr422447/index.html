<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ…ğŸ¼ ğŸ˜Š ğŸ« bytes.Buffer in Go: optimisations qui ne fonctionnent pas ğŸ•µğŸ¿ ğŸ’†ğŸ½ ğŸ§˜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nombreux programmeurs Go connaissent les octets.Buffer . L'un de ses avantages est qu'il vous permet d'Ã©viter d'allouer de la mÃ©moire sur le tas de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>bytes.Buffer in Go: optimisations qui ne fonctionnent pas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/422447/"><p>  De nombreux programmeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Go</a> connaissent les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octets.Buffer</a> .  L'un de ses avantages est qu'il vous permet d'Ã©viter d'allouer de la mÃ©moire sur le tas de la mÃªme maniÃ¨re que " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petite mÃ©moire tampon / optimisation de la taille</a> ": </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [<span class="hljs-number"><span class="hljs-number">64</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-comment"><span class="hljs-comment">//        // ...   }</span></span></code> </pre> <br><p>  Il n'y a qu'un seul problÃ¨me.  Cette optimisation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne fonctionne pas</a> . </p><br><p>  Ã€ la fin de cet article, vous dÃ©couvrirez pourquoi cette optimisation ne fonctionne pas et ce que nous pouvons y faire. </p><a name="habracut"></a><br><h1 id="kak-bylo-po-zadumke-small-buffer-optimization">  Comme prÃ©vu, "petite optimisation du tampon" </h1><br><p>  Introduisons une dÃ©finition lÃ©gÃ¨rement simplifiÃ©e des <code>bytes.Buffer</code> . </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smallBufSize <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Buffer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bootstrap [smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> buf []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> }</code> </pre> <br><p>  Lorsque nous effectuons des actions sur le <code>Buffer</code> , par exemple, appelons la mÃ©thode <code>Buffer.Write</code> , l'enregistrement est toujours effectuÃ© dans <code>buf</code> , cependant, avant cet enregistrement, <code>Buffer.grow(n)</code> lancÃ© Ã  l'intÃ©rieur de chaque mÃ©thode similaire, ce qui garantit qu'il y a suffisamment d'espace dans cette tranche pour <code>n</code> octets suivants. </p><br><p>  Grow peut ressembler Ã  ceci: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//         bytes.Buffer. l := len(b.buf) //   Buffer need := n + l have := cap(b.buf) - l if have &gt;= need { b.buf = b.buf[:need] return } if need &lt;= smallBufSize { //     , //   . b.buf = b.bootstrap[:] } else { // growFactor -     . //     need  need*2. newBuf := make([]byte, need, growFactor(need)) copy(newBuf, b.buf) b.buf = newBuf } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">HypothÃ¨ses utilisÃ©es dans notre implÃ©mentation de Buffer.grow</b> <div class="spoiler_text"><hr><br><p>  Nous <code>len(b.buf)</code> que <code>len(b.buf)</code> est la longueur rÃ©elle des donnÃ©es dans Buffer, ce qui nÃ©cessiterait que <code>Write</code> utilise des mÃ©thodes d'ajout pour ajouter de nouveaux octets Ã  la tranche.  Ce n'est pas le cas dans <code>bytes.Buffer</code> de la bibliothÃ¨que standard, mais par exemple, c'est un dÃ©tail d'implÃ©mentation sans importance. </p><br><hr></div></div><br><p>  Si <code>b</code> allouÃ© sur la pile, le <code>bootstrap</code> intÃ©rieur est allouÃ© sur la pile, ce qui signifie que la tranche <code>b.buf</code> rÃ©utilisera la mÃ©moire Ã  l'intÃ©rieur de <code>b</code> sans nÃ©cessiter d'allocation supplÃ©mentaire. </p><br><p>  Lorsque <code>grow</code> rÃ©vÃ¨le que le tableau d' <code>bootstrap</code> est dÃ©jÃ  insuffisant, une nouvelle tranche Â«rÃ©elleÂ» sera crÃ©Ã©e, oÃ¹ les Ã©lÃ©ments du stockage prÃ©cÃ©dent (du Â«petit tamponÂ») seront ensuite copiÃ©s.  AprÃ¨s cela, <code>Buffer.bootstrap</code> perdra sa pertinence.  Si <code>Buffer.Reset</code> est <code>Buffer.Reset</code> , <code>cap(b.buf)</code> restera le mÃªme et il n'y aura plus besoin d'un tableau d' <code>bootstrap</code> . </p><br><h1 id="pamyat-ubegayuschaya-v-heap">  La mÃ©moire s'enfuit en tas </h1><br><p>  Il est en outre prÃ©vu que le lecteur soit au moins superficiellement familier avec ce qu'est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyse d'Ã©chappement</a> dans Go. </p><br><p>  ConsidÃ©rez la situation suivante: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer <span class="hljs-comment"><span class="hljs-comment">// leak.go:11:6: moved to heap: b return &amp;b // leak.go:12:9: &amp;b escapes to heap }</span></span></code> </pre> <br><p>  Ici <code>b</code> sera allouÃ© sur le tas.  La raison en est le pointeur qui fuit vers <code>b</code> : </p><br><pre> <code class="bash hljs">$ go tool compile -m leak.go leak.go:12:9: &amp;b escapes to heap leak.go:11:6: moved to heap: b</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Terminologie</b> <div class="spoiler_text"><hr><br><p>  Dans cet article, Â«fuiteÂ» et Â«Ã©vasionsÂ» sont utilisÃ©s de maniÃ¨re presque synonyme. </p><br><p>  Il y a une certaine diffÃ©rence dans le compilateur lui-mÃªme, par exemple, la valeur Â«Ã©chappe au tasÂ», mais les paramÃ¨tres de la fonction sont Â«fuite x paramÂ». </p><br><p>  Un paramÃ¨tre qui fuit signifie que l'argument passÃ© pour ce paramÃ¨tre sera allouÃ© sur le tas.  En d'autres termes, le paramÃ¨tre de fuite provoque l'Ã©chappement des arguments dans un tas. </p><br><hr></div></div><br><p>  Ce qui prÃ©cÃ¨de Ã©tait un cas Ã©vident, mais qu'en est-il: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() }</code> </pre> <br><p>  Ici, nous n'avons besoin que d'un octet, tout tient dans le <code>bootstrap</code> , le tampon lui-mÃªme est local et ne "s'Ã©chappe" pas de la fonction.  Vous serez peut-Ãªtre surpris, mais le rÃ©sultat sera le mÃªme, l'allocation <code>b</code> sur le tas. </p><br><img src="https://habrastorage.org/webt/_d/3w/jr/_d3wjrildbyauunsvvv5oq7zqpo.jpeg"><br><p>  Pour Ãªtre sÃ»r, vous pouvez vÃ©rifier cela en utilisant le benchmark: </p><br><pre> <code class="hljs powershell">BenchmarkLength<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">90.1</span></span> ns/op <span class="hljs-number"><span class="hljs-number">112</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Liste de rÃ©fÃ©rence</b> <div class="spoiler_text"><hr><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Len() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { _ = length() } }</code> </pre> <br><hr></div></div><br><div class="spoiler">  <b class="spoiler_title">Explication 112 B / op</b> <div class="spoiler_text"><hr><br><p>  Lorsque le runtime demande Ã  l'allocateur <code>N</code> octets, il n'est pas nÃ©cessaire que exactement <code>N</code> octets soient allouÃ©s. </p><br><blockquote>  Tous les rÃ©sultats ci-dessous concernent la combinaison de <code>GOOS=linux</code> et <code>GOARCH=AMD64</code> . </blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> benchmark <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:noinline func alloc9() []byte { return make([]byte, 9) } func BenchmarkAlloc9(b *testing.B) { for i := 0; i &lt; bN; i++ { _ = alloc9() } }</span></span></code> </pre> <br><p>  Si vous exÃ©cutez <code>go test -bench=. -benchmem</code>  <code>go test -bench=. -benchmem</code> avec ce test: </p><br><pre> <code class="hljs powershell">BenchmarkAlloc9<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">50000000</span></span> <span class="hljs-number"><span class="hljs-number">33.5</span></span> ns/op <span class="hljs-number"><span class="hljs-number">16</span></span> B/op <span class="hljs-number"><span class="hljs-number">1</span></span> allocs/op</code> </pre> <br><p>  9 octets demandÃ©s, 16 allouÃ©s. Revenons maintenant aux <code>bytes.Buffer</code> : </p><br><pre> <code class="go hljs">fmt.Println(unsafe.Sizeof(bytes.Buffer{})) =&gt; <span class="hljs-number"><span class="hljs-number">104</span></span></code> </pre> <br><p>  Regardons <a href="">$ GOROOT / src / runtime / sizeclasses.go</a> : </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ class bytes/obj</span></span> bytes/span objects tail waste max waste /<span class="hljs-regexp"><span class="hljs-regexp">/ 1 8 8192 1024 0 87.50% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 16 8192 512 0 43.75% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3 32 8192 256 0 46.88% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 4 48 8192 170 32 31.52% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 5 64 8192 128 0 23.44% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 6 80 8192 102 32 19.07% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 7 96 8192 85 32 15.95% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 8 112 8192 73 16 13.56% /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... </span></span></code> </pre> <br><p>  Il ne tient pas dans 96 octets, 112 est sÃ©lectionnÃ©. </p><br><hr></div></div><br><p>  Mais pourquoi cela se produit-il? </p><br><h1 id="chto-proishodit-i-pochemu">  Que se passe-t-il et pourquoi </h1><br><p>  Une analyse de la situation peut Ãªtre trouvÃ©e dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">numÃ©ro</a> mentionnÃ© au tout dÃ©but. <br>  Il y a aussi un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simple reproducteur</a> . </p><br><p>  La place du problÃ¨me se trouve juste dans l'affectation <code>b.buf = b.bootstrap[:]</code> .  Ce code fait que l'analyse d'Ã©chappement suppose que <code>b.bootstrap</code> "s'enfuit", et puisqu'il s'agit d'un tableau, il est stockÃ© Ã  l'intÃ©rieur de l'objet lui-mÃªme, ce qui signifie que tous les <code>b</code> doivent Ãªtre allouÃ©s sur le tas. </p><br><p>  Si le bootstrap Ã©tait une tranche, pas un tableau, cela ne se produirait pas, car il existe une optimisation ad hoc pour attribuer des tranches de l'objet Ã  l'objet lui-mÃªme: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     , // object      . object.buf1 = object.buf2[a:b]</span></span></code> </pre> <br><p>  La rÃ©ponse pour laquelle cette optimisation ne fonctionne pas pour les tableaux a dÃ©jÃ  Ã©tÃ© formulÃ©e ci-dessus, mais voici un extrait de <a href="">esc.go # L835-L866 lui-mÃªme</a> (tout le code d'optimisation est mis en Ã©vidence par rÃ©fÃ©rence): </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Note, this optimization does not apply to OSLICEARR, // because it does introduce a new pointer into b that was not already there // (pointer to b itself). After such assignment, if b contents escape, // b escapes as well. If we ignore such OSLICEARR, we will conclude // that b does not escape when b contents do.</span></span></code> </pre> <br><p>  Il convient d'ajouter ici que pour l'analyseur de pointeur, il existe plusieurs niveaux de "fuites", les principaux d'entre eux: </p><br><ol><li>  L'objet lui-mÃªme s'Ã©chappe (b s'Ã©chappe).  Dans ce cas, l'objet lui-mÃªme doit Ãªtre allouÃ© sur le tas. </li><li>  Les Ã©lÃ©ments de l'objet (b contenu s'Ã©chappent) s'Ã©chappent.  Dans ce cas, les pointeurs de l'objet sont considÃ©rÃ©s comme s'Ã©chappant. </li></ol><br><p>  Le cas avec le tableau est spÃ©cial en ce que si le tableau fuit, l'objet qui le contient doit Ã©galement fuir. </p><br><p>  L'analyse d'Ã©chappement dÃ©cide s'il est possible ou non de placer un objet sur la pile, en se basant uniquement sur les informations disponibles dans le corps de la fonction analysÃ©e.  La mÃ©thode <code>Buffer.grow</code> prend <code>b</code> par pointeur, elle doit donc calculer un emplacement appropriÃ© Ã  placer.  Ã‰tant donnÃ© que dans le cas d'un tableau, nous ne pouvons pas distinguer <code>"b escape"</code> de <code>"b contents escape"</code> , nous devons Ãªtre plus pessimistes et arriver Ã  la conclusion que <code>b</code> pas sÃ»r Ã  placer sur la pile. </p><br><p>  Supposons le contraire, que le modÃ¨le d' <code>self-assignment</code> rÃ©sout la mÃªme chose pour les tableaux que pour les tranches: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> bad <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { array [<span class="hljs-number"><span class="hljs-number">10</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> slice []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *bad)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b.slice = b.array[:] <span class="hljs-comment"><span class="hljs-comment">// ignoring self-assignment to b.slice sink = b.array // b.array escapes to heap // b does not escape }</span></span></code> </pre> <br><p>  La dÃ©cision de placer <code>b</code> sur la pile dans cette situation entraÃ®nera un dÃ©sastre: aprÃ¨s avoir quittÃ© la fonction Ã  l'intÃ©rieur de laquelle <code>b</code> Ã©tÃ© crÃ©Ã©, la mÃ©moire Ã  laquelle se rÃ©fÃ¨rera le rÃ©cepteur ne sera rien de plus que des ordures. </p><br><h1 id="ukazateli-na-massivy">  Pointeurs de tableau </h1><br><p>  Imaginez que notre <code>Buffer</code> Ã©tÃ© dÃ©clarÃ© un peu diffÃ©remment: </p><br><pre> <code class="diff hljs">const smallBufSize int = 64 type Buffer struct { - bootstrap [smallBufSize]byte + bootstrap *[smallBufSize]byte buf []byte }</code> </pre> <br><p>  Contrairement Ã  un tableau normal, un pointeur sur un tableau ne stockera pas tous les Ã©lÃ©ments Ã  l'intÃ©rieur du <code>Buffer</code> lui-mÃªme.  Cela signifie que si l'allocation d' <code>bootstrap</code> sur le tas n'entraÃ®ne pas <code>Buffer</code> allocation de <code>Buffer</code> sur le tas.  Ã‰tant donnÃ© que l'analyse d'Ã©chappement peut allouer des champs de pointeur sur la pile lorsque cela est possible, nous pouvons supposer qu'une telle dÃ©finition de <code>Buffer</code> est plus efficace. </p><br><p>  Mais c'est en thÃ©orie.  En pratique, un pointeur vers un tableau n'a pas beaucoup de traitement et tombe dans la mÃªme catÃ©gorie qu'une tranche d'un tableau normal, ce qui n'est pas tout Ã  fait correct.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CL133375: cmd / compile / internal / gc: gÃ©rer la tranche de tableau auto-affectÃ©e dans esc.go</a> vise Ã  corriger cette situation. </p><br><p>  Supposons que cette modification ait Ã©tÃ© acceptÃ©e dans le compilateur Go. </p><br><h1 id="zero-value-kotoryy-my-poteryali">  ZÃ©ro valeur que nous avons perdue </h1><br><p>  Malheureusement, la transition de <code>[64]byte</code> Ã  <code>*[64]byte</code> a un problÃ¨me: maintenant nous ne pouvons pas utiliser le <code>bootstrap</code> sans l'initialiser explicitement, une valeur nulle de <code>Buffer</code> cesse d'Ãªtre utile, nous avons besoin d'un constructeur. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Buffer</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer{bootstrap: <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(*[smallBufSize]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)} }</code> </pre> <br><p>  Nous <code>Buffer</code> , pas <code>*Buffer</code> , pour Ã©viter des problÃ¨mes avec l'analyse des pointeurs (c'est trÃ¨s conservateur dans Go), et compte tenu du fait que <code>NewBuffer</code> toujours intÃ©grÃ© Ã  l'endroit d'un appel, il n'y aura pas de copie inutile. </p><br><p>  AprÃ¨s avoir <code>NewBuffer</code> corps <code>NewBuffer</code> Ã  la place de l'appel d'Ã©chappement, l'analyse peut essayer de prouver que le <code>new(*[smallBufSize]byte)</code> ne dÃ©passe pas la durÃ©e de vie de la trame de la fonction dans laquelle il est appelÃ©.  Si c'est le cas, alors l'allocation sera sur la pile. </p><br><h1 id="intel-bytebuf">  Intel bytebuf </h1><br><p>  L'optimisation dÃ©crite ci-dessus est appliquÃ©e dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package intel-go / bytebuf</a> . </p><br><p>  Cette bibliothÃ¨que exporte le type <code>bytebuf.Buffer</code> , qui duplique 99,9% <code>bytes.Buffer</code> .  Toutes les modifications sont rÃ©duites Ã  l'introduction d'un constructeur ( <code>bytebuf.New</code> ) et d'un pointeur vers un tableau au lieu d'un tableau normal: </p><br><pre> <code class="diff hljs">type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at &amp;buf[off], write at &amp;buf[len(buf)] - bootstrap [64]byte // helps small buffers avoid allocation. + bootstrap *[64]byte // helps small buffers avoid allocation. lastRead readOp // last read operation (for Unread*). }</code> </pre> <br><p>  Voici une comparaison des performances avec les <code>bytes.Buffer</code> : </p><br><pre> <code class="hljs powershell">name old time/op new time/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">138</span></span>ns Â±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-number"><span class="hljs-number">24</span></span>ns Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-82</span></span>.<span class="hljs-number"><span class="hljs-number">94</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">186</span></span>ns Â±<span class="hljs-number"><span class="hljs-number">11</span></span>% <span class="hljs-number"><span class="hljs-number">60</span></span>ns Â± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-literal"><span class="hljs-literal">-67</span></span>.<span class="hljs-number"><span class="hljs-number">82</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">225</span></span>ns Â±<span class="hljs-number"><span class="hljs-number">10</span></span>% <span class="hljs-number"><span class="hljs-number">108</span></span>ns Â± <span class="hljs-number"><span class="hljs-number">6</span></span>% <span class="hljs-literal"><span class="hljs-literal">-52</span></span>.<span class="hljs-number"><span class="hljs-number">26</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">474</span></span>ns Â±<span class="hljs-number"><span class="hljs-number">17</span></span>% <span class="hljs-number"><span class="hljs-number">338</span></span>ns Â±<span class="hljs-number"><span class="hljs-number">13</span></span>% <span class="hljs-literal"><span class="hljs-literal">-28</span></span>.<span class="hljs-number"><span class="hljs-number">57</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">889</span></span>ns Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">740</span></span>ns Â± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-literal"><span class="hljs-literal">-16</span></span>.<span class="hljs-number"><span class="hljs-number">78</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old alloc/op new alloc/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">112</span></span>B Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0</span></span>B <span class="hljs-literal"><span class="hljs-literal">-100</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">117</span></span>B Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">5</span></span>B Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-95</span></span>.<span class="hljs-number"><span class="hljs-number">73</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">176</span></span>B Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">64</span></span>B Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-63</span></span>.<span class="hljs-number"><span class="hljs-number">64</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">368</span></span>B Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">256</span></span>B Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-30</span></span>.<span class="hljs-number"><span class="hljs-number">43</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.16</span></span>kB Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.05</span></span>kB Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-5</span></span>.<span class="hljs-number"><span class="hljs-number">19</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) name old allocs/op new allocs/op delta String/empty<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">1.00</span></span> Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">0.00</span></span> <span class="hljs-literal"><span class="hljs-literal">-100</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-50</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">64</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">2.00</span></span> Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">1.00</span></span> Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-50</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">128</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-33</span></span>.<span class="hljs-number"><span class="hljs-number">33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) String/<span class="hljs-number"><span class="hljs-number">1024</span></span><span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">3.00</span></span> Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-number"><span class="hljs-number">2.00</span></span> Â± <span class="hljs-number"><span class="hljs-number">0</span></span>% <span class="hljs-literal"><span class="hljs-literal">-33</span></span>.<span class="hljs-number"><span class="hljs-number">33</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><p>  Toutes les autres informations sont disponibles dans <a href="">README</a> . </p><br><p>  En raison de l'impossibilitÃ© d'utiliser la valeur zÃ©ro et la liaison Ã  la fonction de construction <code>New</code> , il n'est pas possible d'appliquer cette optimisation Ã  <code>bytes.Buffer</code> . </p><br><p>  Est-ce la seule faÃ§on de faire des <code>bytes.Buffer</code> plus <code>bytes.Buffer</code> ?  La rÃ©ponse est non.  Mais c'est certainement une mÃ©thode qui nÃ©cessite des changements minimes dans la mise en Å“uvre. </p><br><h1 id="plany-na-escape-analysis">  Plans d'analyse d'Ã©chappement </h1><br><p>  Dans sa forme actuelle, l'analyse d'Ã©chappement dans Go est assez faible.  Presque toute opÃ©ration avec des valeurs de pointeur conduit Ã  des allocations sur le tas, mÃªme si ce n'est pas une dÃ©cision raisonnable. </p><br><p>  Je vais essayer de diriger la plupart du temps que je consacre au projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">golang / go</a> pour rÃ©soudre ces problÃ¨mes, donc certaines amÃ©liorations sont possibles dans la prochaine version (1.12). </p><br><p>  Vous pouvez lire les rÃ©sultats et les dÃ©tails de la structure interne de cette partie du compilateur dans l'un de mes prochains articles.  J'essaierai de fournir un ensemble de recommandations qui aideront dans certains cas Ã  structurer le code afin qu'il ait moins d'allocations de mÃ©moire indÃ©sirables. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422447/">https://habr.com/ru/post/fr422447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422437/index.html">Jeux d'expÃ©rience utilisateur et vitesse du site Web et des applications</a></li>
<li><a href="../fr422439/index.html">Le combat avec Yandex: comment j'ai passÃ© plus d'un an pour amener le site au top</a></li>
<li><a href="../fr422441/index.html">TrouvÃ© une formule pour une transition indolore vers .Net Core</a></li>
<li><a href="../fr422443/index.html">Corona SDK Precise Timer</a></li>
<li><a href="../fr422445/index.html">ImplÃ©mentation de BottomAppBar. Partie 3: Comportement pour Android</a></li>
<li><a href="../fr422449/index.html">SÃ©nateurs contre Amazon: ce qu'a fait une boutique en ligne</a></li>
<li><a href="../fr422451/index.html">Pour Ã©couter le marketing de jeu et la place d'un scÃ©nariste dans l'industrie du jeu le 26 septembre chez VShBI</a></li>
<li><a href="../fr422453/index.html">SmartData 2018: premiÃ¨re confÃ©rence du groupe JUG.ru annulÃ©e</a></li>
<li><a href="../fr422455/index.html">EPAM + universitÃ©s: comment nous travaillons avec les universitÃ©s ukrainiennes</a></li>
<li><a href="../fr422457/index.html">Â«Cela n'a aucun sens pour nous d'utiliser RetrofitÂ»: Ã  propos du dÃ©veloppement Android sur Sberbank Online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>