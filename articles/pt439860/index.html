<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôæ üëµüèΩ üéã Raiz do Ubuntu 18.04 no ZFS üçó ‚õ™Ô∏è üëéüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No ano passado, eu precisava criar instru√ß√µes para instalar o sistema operacional Ubuntu 18.04. A prop√≥sito, n√£o h√° nada complicado na instala√ß√£o do U...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Raiz do Ubuntu 18.04 no ZFS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439860/"><p>  No ano passado, eu precisava criar instru√ß√µes para instalar o sistema operacional Ubuntu 18.04.  A prop√≥sito, n√£o h√° nada complicado na instala√ß√£o do Ubuntu, mas h√° uma nuance: eu queria usar o sistema de arquivos ZFS como base.  Por um lado, o Ubuntu suporta ZFS no n√≠vel do kernel, mas ainda n√£o existe um instalador para ele, mas h√° uma instru√ß√£o, sim: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/zfsonlinux/zfs/wiki/Ubuntu-18.04-Root-on-ZFS</a> </p><br><p>  A sequ√™ncia de a√ß√µes neste manual geralmente est√° correta, mas alguns pontos exigem ajustes.  Portanto, o que se segue n√£o √© uma tradu√ß√£o direta das instru√ß√µes, mas √© gratuita, levando em considera√ß√£o as corre√ß√µes, minha experi√™ncia com o ZFS e outras coisas.  Tamb√©m n√£o considero problemas de criptografia de disco e uso o gerenciador de inicializa√ß√£o MBR.  Minhas instru√ß√µes de instala√ß√£o podem ser obtidas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui.</a> </p><br><a name="habracut"></a><br><h2><blockquote>  0. Prepara√ß√£o do servidor </blockquote></h2><br><p> A primeira coisa que falta nas instru√ß√µes e n√£o √© considerada de forma alguma √© que o ZFS n√£o funciona muito bem com matrizes RAID de hardware, em particular, est√° conectado ao cache de grava√ß√£o, o que √© compreens√≠vel: o sistema de arquivos ZFS √© registrado em di√°rio e requer controle completo sobre as opera√ß√µes de grava√ß√£o.  Al√©m disso, ao usar uma matriz RAID de hardware pronta, os recursos do ZFS s√£o perdidos em termos de cache, de reposi√ß√£o e muito mais.  Portanto, todos os discos devem ser transferidos para o modo HBA e, se isso n√£o for poss√≠vel - criar um RAID separado para cada disco e desativar o controlador de cache de grava√ß√£o. </p><br><p>  Al√©m disso, ao usar a agrega√ß√£o de portas de rede, voc√™ pode desativ√°-las no est√°gio de instala√ß√£o, para n√£o complicar (executarei todas as opera√ß√µes adicionais sem liga√ß√£o). </p><br><h2>  1. Preparando o ambiente de instala√ß√£o </h2><br><h3>  1.1  Livecd </h3><br><p>  Como mencionado anteriormente, infelizmente, n√£o existe um instalador pronto do Ubuntu usando raiz no ZFS, portanto a instala√ß√£o √© realizada usando um disco do LiveCD: </p><br><p>  Baixe aqui: <a href="">http://releases.ubuntu.com/18.04/ubuntu-18.04.1-desktop-amd64.iso</a> </p><br><blockquote>  Ao mesmo tempo, tentei com os colegas usar v√°rias imagens de disco, pois realmente n√£o queria usar o shell gr√°fico, mas isso n√£o levou a nada de bom. </blockquote><br><p>  Inicializamos a partir do LiveCD, selecione Experimente o Ubuntu e abra o terminal (Ctrl + Alt + T). </p><br><h3>  1.2  Atualizando e Instalando Reposit√≥rios </h3>  '' <br><pre><code class="bash hljs">sudo apt-add-repository universe sudo apt update</code> </pre> <br><blockquote>  Aqui estamos aguardando a primeira chatice se as configura√ß√µes de rede do servidor n√£o forem determinadas pelo DHCP.  A atualiza√ß√£o de reposit√≥rios n√£o funcionar√°, ent√£o vamos configurar a rede. </blockquote><br><p>  Examinamos as interfaces de rede e encontramos aquela atrav√©s da qual nos conectaremos: </p><br><pre> <code class="bash hljs">sudo ip a</code> </pre> <br><p>  Configure a interface de rede: </p><br><pre> <code class="bash hljs">sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"auto {{ NAME }}"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"iface {{ NAME }} inet static"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" address {{ IP }}"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" netmask {{ NETMASK }}"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" gateway {{ GATEWAY }}"</span></span> &gt;&gt; /etc/network/interfaces sudo service networking restart</code> </pre><br><p>  E resolvedor de DNS: </p><br><pre> <code class="bash hljs">sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'nameserver 8.8.8.8'</span></span> &gt;&gt; /etc/resolv.conf</code> </pre> <br><p>  Atualizando reposit√≥rios: </p><br><pre> <code class="bash hljs">sudo apt update</code> </pre> <br><h3>  1.3  Servidor SSH (opcional) </h3><br><p>  Para facilitar a instala√ß√£o, voc√™ pode aumentar o servidor OpenSSH e executar todas as opera√ß√µes adicionais atrav√©s do cliente SSH </p><br><p>  Defina a senha para o usu√°rio do ubuntu: </p><br><pre> <code class="bash hljs">passwd</code> </pre> <br><blockquote>  Isso √© importante!  Caso contr√°rio, o acesso via ssh ser√° realizado sem uma senha com direitos sudo.  No entanto, voc√™ n√£o pode definir uma senha simples. </blockquote><br><p>  Instale e execute o OpenSSH: </p><br><pre> <code class="bash hljs">sudo apt install openssh-server sudo service ssh start</code> </pre> <br><p>  E no terminal da esta√ß√£o de trabalho: </p><br><pre> <code class="bash hljs">ssh ubuntu@{{ ip server }}</code> </pre> <br><h3>  1.4  Torne-se root </h3><br><pre> <code class="bash hljs">sudo -s</code> </pre> <br><h3>  1.5  Instalando o suporte do ZFS em um ambiente LiveCD </h3><br><pre> <code class="bash hljs">apt install --yes debootstrap gdisk zfs-initramfs</code> </pre> <br><h2>  2. Particionando e formatando discos r√≠gidos </h2><br><h3><blockquote>  2.0  Definindo matrizes de disco </blockquote></h3><br><p>  A instru√ß√£o principal n√£o cont√©m um ponto importante sobre como determinar matrizes de disco. </p><br><p>  Normalmente, o n√∫mero de discos nos servidores √©: </p><br><ul><li>  2 discos; </li><li>  4 discos; </li><li>  muitos discos; </li></ul><br><p>  N√£o consideramos 1 disco, porque geralmente √© uma anomalia. </p><br><h4>  2.0.1  2 discos </h4><br><p>  Tudo √© simples aqui, uma matriz MIRROR (RAID1).  Se houver outra terceira unidade, voc√™ poder√° coloc√°-la em um hot spare (SPARE) ou montar uma matriz RAIDZ (RAID5).  Mas tr√™s discos no servidor s√£o muito raros. </p><br><h4>  2.0.2  4 discos </h4><br><p>  Se todas as unidades forem iguais, existem apenas tr√™s op√ß√µes (a quarta RAID0 eu basicamente n√£o considero): </p><br><ul><li>  O MIRROR + MIRROR √© um an√°logo do RAID10, mais precisamente o RAID01, pois no ZFS √© espelho + espelho.  50% de espa√ßo em disco dispon√≠vel; </li><li>  RAIDZ √© um an√°logo do RAID5.  75% do espa√ßo em disco dispon√≠vel; </li><li>  RAIDZ2 √© um an√°logo do RAID6.  50% de espa√ßo em disco dispon√≠vel; </li></ul><br><p>  Na pr√°tica, eu uso a matriz MIRROR + MIRROR, embora seja √≥bvio que a matriz RAIDZ √© mais lucrativa, pois fornece mais espa√ßo em disco, mas h√° nuances </p><br><p>  Em termos de toler√¢ncia a falhas, as matrizes s√£o organizadas nesta ordem (da melhor para a pior): </p><br><ul><li>  RAIDZ2 - dois discos podem ser perdidos sem perda de dados; </li><li>  MIRROR + MIRROR - um disco pode ser perdido sem perda de dados e com uma probabilidade de 66% de um segundo disco pode ser perdido sem perda de dados; </li><li>  RAIDZ - apenas um disco pode ser perdido sem perda de dados; </li></ul><br><p>  Em termos de velocidade, as matrizes s√£o organizadas nesta ordem: </p><br><ul><li>  ESPELHO + ESPELHO - ambos em termos de escrita e leitura; </li><li>  RAIDZ - em termos de grava√ß√£o √© mais lento, pois al√©m da grava√ß√£o, √© necess√°rio calcular a soma de verifica√ß√£o; </li><li>  RAIDZ2 - em termos de escrita √© ainda mais lento, pois requer o c√°lculo de somas de verifica√ß√£o mais complexas; </li></ul><br><p>  Em termos de velocidade da matriz durante a degrada√ß√£o de um disco: </p><br><ul><li>  ESPELHO + ESPELHO - quando uma unidade cai, essencialmente apenas a leitura paralela de um espelho √© perdida, o segundo espelho funciona sem degrada√ß√£o do desempenho; </li><li>  RAIDZ2 - a degrada√ß√£o do desempenho √© maior, pois exige uma aloca√ß√£o reversa do bloco da soma de verifica√ß√£o para 1/4 da pesquisa de dados + bloco; </li><li>  RAIDZ - a degrada√ß√£o √© muito maior, pois requer um rec√°lculo do bloco da soma de verifica√ß√£o para 1/3 da pesquisa de dados + bloco; </li></ul><br><p>  A compara√ß√£o de caracter√≠sticas √© subjetiva, mas reflete suficientemente minha escolha como meio termo. </p><br><p>  Ao mesmo tempo, voc√™ precisa entender que "mais lento" e "ainda mais lento" √†s vezes n√£o √©, mas apenas 10 a 20% no pior caso; portanto, se seu banco de dados ou aplicativo para trabalhar com discos n√£o for otimizado, voc√™ diminuir√° a velocidade em princ√≠pio, n√£o perceba.  O fator de velocidade de grava√ß√£o deve ser considerado apenas quando voc√™ realmente precisar. </p><br><h4>  2.0.2  Muitos discos </h4><br><p>  O principal problema √© que, se tivermos muitos discos e desejarmos criar uma matriz comum para tudo, precisaremos marcar cada disco com o setor de inicializa√ß√£o ou fazer uma pequena simula√ß√£o com nossos ouvidos.  Na pr√°tica, para plataformas multi-disco, tento criar esta configura√ß√£o: </p><br><ul><li>  2 discos SSD - fazemos um espelho e, como matriz principal de inicializa√ß√£o, com o sistema operacional e cache ZFS para a segunda matriz de disco; </li><li>  O restante est√° entupido com discos SATA ou SAS e, sem marca√ß√£o, coletamos uma matriz de discos ZFS; </li></ul><br><p>  O mesmo se aplica aos servidores de 4 discos, se queremos obter uma plataforma bastante universal; </p><br><p>  Se os discos forem todos iguais e n√£o fizer sentido alocar dois discos para uma matriz separada (por exemplo, 6 discos de 8 TB cada), voc√™ poder√° inicializar os discos do primeiro grupo da matriz.  Ou seja, se voc√™ criar uma matriz como: MIRROR + MIRROR + MIRROR ou RAIDZ + RAIDZ, marcaremos o setor de inicializa√ß√£o apenas para o primeiro grupo.  Em princ√≠pio, √© poss√≠vel particionar apenas uma unidade, mesmo para MIRROR e RAIDZ, e substituir o restante na forma bruta, o ZFS criar√° a matriz pelo pr√≥prio elemento menor, mas nesse caso, se a primeira unidade falhar, voc√™ perder√° o √∫nico disco de inicializa√ß√£o. vale a pena fazer isso. </p><br><p>  √â importante entender que, no sistema de arquivos do ZFS - tarja, isso n√£o √© exatamente RAID0 e funciona de maneira um pouco diferente e n√£o requer os mesmos tamanhos de disco; portanto, alocar um pequeno espa√ßo para o setor de inicializa√ß√£o do tempo n√£o far√° muito, o principal √© indicar no BIOS o disco correto a partir do qual o boot ser√° iniciado. . </p><br><h3>  2.1  Particionamento e limpeza de disco </h3><br><p>  O pacote mdadm √© usado para marcar o disco, coloque-o: </p><br><pre> <code class="bash hljs">apt install --yes mdadm</code> </pre> <br><p>  Examinamos quais discos temos dispon√≠veis: </p><br><pre> <code class="bash hljs">lsblk</code> </pre> <br><p>  E limpe-os: </p><br><pre> <code class="bash hljs">sgdisk --zap-all /dev/{{ disk name }}</code> </pre> <br><h3>  2.2  Layout do disco </h3><br><p>  Na verdade, a parti√ß√£o de inicializa√ß√£o: </p><br><pre> <code class="bash hljs">sgdisk -a1 -n1:34:2047 -t1:EF02 /dev/{{ disk name }}</code> </pre> <br><p>  A se√ß√£o principal. </p><br><blockquote>  Aqui pode haver varia√ß√µes: se voc√™ precisar alocar uma parti√ß√£o adicional de discos SSD, por exemplo, para ZFS Cache ou Aerospike, fa√ßa a parti√ß√£o principal de volume limitado: </blockquote><br><pre> <code class="bash hljs">sgdisk -n2:0:+100GB -t2:BF01 /dev/{{ disk name }} sgdisk -n3:0:0 -t2:BF01 /dev/{{ disk name }}</code> </pre><br><p>  Se usarmos todo o espa√ßo, basta criar uma se√ß√£o para o espa√ßo restante: </p><br><pre> <code class="bash hljs">sgdisk -n2:0:0 -t2:BF01 /dev/{{ disk name }}</code> </pre> <br><p>  N√£o se esque√ßa de verificar como ficou: </p><br><pre> <code class="bash hljs">lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 1.8T 0 disk ‚îú‚îÄsda1 8:1 0 1007K 0 part ‚îî‚îÄsda2 8:2 0 1.8T 0 part sdb 8:16 0 1.8T 0 disk ‚îú‚îÄsdb1 8:17 0 1007K 0 part ‚îî‚îÄsdb2 8:18 0 1.8T 0 part ...</code> </pre><br><h3>  2.3  Criando uma matriz ZFS </h3><br><pre> <code class="bash hljs">zpool create \ -o ashift=12 \ -O atime=off \ -O canmount=off \ -O compression=lz4 \ -O checksum=fletcher4 \ -O normalization=formD \ -m legacy \ -R /mnt \ -f \ tank \ mirror \ /dev/{{ disk a part 2}} \ /dev/{{ disk b part 2}}</code> </pre> <br><blockquote>  O primeiro rake em que um dos meus administradores familiares entrou imediatamente em a√ß√£o, √© que, ao criar uma matriz ZFS, √© necess√°rio especificar n√£o um disco, mas uma parti√ß√£o no disco, se ele for criado especialmente para isso. </blockquote><br><p>  Em seguida, em ordem: </p><br><ul><li>  ashift = 12 - use o tamanho do bloco em 4K; em princ√≠pio, ainda n√£o entendo por que, em sistemas operacionais, o tamanho padr√£o do bloco √© de 512 bytes quando praticamente n√£o existem discos desse tipo; </li><li>  atime = off - desativa a atualiza√ß√£o da data de acesso aos arquivos, sempre a desativo, pois nunca precisei dessas informa√ß√µes e n√£o √© necess√°rio carregar o kernel novamente; </li><li>  canmount = off - desativa a capacidade de montar a parti√ß√£o raiz; </li><li>  compress√£o = lz4 - ativa a compacta√ß√£o de dados com o algoritmo LZ4.  Recomenda-se que este par√¢metro seja inclu√≠do n√£o apenas para economizar espa√ßo em disco, mas tamb√©m para reduzir o n√∫mero de opera√ß√µes de E / S.  Ao mesmo tempo, para esse ritmo de compacta√ß√£o, utiliza√ß√£o extremamente baixa da CPU; </li><li>  checksum = fletcher4 - o algoritmo de soma de verifica√ß√£o padr√£o e, portanto, vale a pena verificar novamente o fletcher4; </li><li>  normaliza√ß√£o = formD - usada para melhorar o trabalho com UTF-8, limitando de fato a possibilidade de usar nomes de arquivos n√£o UTF-8.  Aqui todo mundo decide por si mesmo, em nosso trabalho sempre usamos apenas a codifica√ß√£o UTF-8; </li><li>  xattr = sa - Acelerando o trabalho com atributos estendidos.  Eu n√£o uso essa op√ß√£o devido ao fato de que, quando essa op√ß√£o √© usada, a compatibilidade com outras implementa√ß√µes do OpenZFS fica desabilitada (por exemplo: FreeBSD).  E compatibilidade com o Windows e, a prop√≥sito, eu preciso.  Al√©m disso, esta op√ß√£o pode ser ativada na se√ß√£o final; </li><li>  -m legado - ponto de montagem para lugar nenhum, e n√£o √© necess√°rio montar a parti√ß√£o raiz; </li><li>  -R / mnt - prefixo de montagem de parti√ß√£o tempor√°rio para instalar o kernel; </li><li>  -f - for√ßa a cria√ß√£o da matriz.  Se a matriz do ZFS tiver sido coletada em discos antes, o comando create n√£o funcionar√°, voc√™ nunca sabe, talvez tenha cometido um erro e queira apagar dados importantes; </li></ul><br><blockquote><p>  Normalmente, indico o nome da matriz de discos do sistema raiz como tanque, embora atualmente eles prefiram usar o nome rpool (pool raiz) no ambiente Linux.  Na minha pr√°tica, geralmente uso esta nomea√ß√£o de matrizes: </p><br><ul><li>  tanque - a matriz principal do sistema; </li><li>  armazenar - uma matriz adicional com discos grandes para armazenamento de dados; </li><li>  cache - uma matriz adicional de discos SSD, se a parti√ß√£o principal n√£o estiver neles; </li></ul><br><p>  Em geral, eu recomendo desenvolver imediatamente uma pr√°tica de nomear algo que n√£o seria confuso. </p></blockquote><br><h2>  3. Instala√ß√£o do Sistema </h2><br><h3>  3.1  e 3.2.  Criando um sistema de arquivos raiz </h3><br><blockquote>  Combinei especificamente os par√°grafos 3.1.  e 3.2.  pois acredito que especificar a parti√ß√£o raiz no terceiro n√≠vel √© absolutamente redundante.  √â verdade que, durante v√°rios anos trabalhando com o ZFS, nunca precisei fazer manipula√ß√µes com a parti√ß√£o raiz.  Al√©m disso, existem fotos com as quais voc√™ pode fazer pontos de controle.  Portanto, minha se√ß√£o raiz √© tank / root: </blockquote><br><pre> <code class="bash hljs">zfs create -o mountpoint=/ tank/root</code> </pre> <br><blockquote>  Ao mesmo tempo, o primeiro erro fatal √© detectado na instru√ß√£o original, a saber, a falta de uma parti√ß√£o de inicializa√ß√£o para a matriz de discos: </blockquote><br><pre> <code class="bash hljs">zpool <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> bootfs=tank/root tank</code> </pre> <br><h3>  3.3  Crie parti√ß√µes adicionais </h3><br><blockquote><p>  Nesta parte das instru√ß√µes b√°sicas, voc√™ pode jogar tudo e esquecer.  Os caras obviamente exageraram com esmagamento e op√ß√µes, por causa dos quais, ao longo do caminho, eu tive que consertar algo.  √â verdade que n√£o ajudou muito.  Como os problemas posteriores aparecem novamente e, no final, verifica-se que tudo isso n√£o funciona, portanto, no par√°grafo 4.11.  isso √© corrigido novamente. </p><br><p>  Separar uma se√ß√£o separada para / var / games parece bastante √©pico.  Eu n√£o me importo, mas isso √© claramente demais. </p><br><p>  O fato de que as parti√ß√µes s√£o criadas no ZFS simplesmente e suportam uma hierarquia n√£o significa que os diret√≥rios cl√°ssicos devem ser abandonados.  Um exemplo simples: uma vez eu tive mais de parti√ß√µes ZFS 4K em um grupo de servidores, era necess√°rio, mas a reinicializa√ß√£o do servidor ficou mais lenta por v√°rios minutos devido √† montagem dessas parti√ß√µes. </p></blockquote><br><p>  Vamos come√ßar com uma lousa limpa. </p><br><p>  Existem parti√ß√µes de arquivo est√°ticas e din√¢micas. </p><br><p>  As se√ß√µes de arquivo est√°tico incluem se√ß√µes com programas e suas configura√ß√µes, s√£o preenchidas uma vez e n√£o s√£o alteradas durante a opera√ß√£o.  Ao mesmo tempo, as parti√ß√µes est√°ticas anteriores foram divididas em parti√ß√µes de sistema e de usu√°rio (/ usr), mas no momento elas s√£o misturadas nos sistemas operacionais Linux e n√£o h√° sentido em separ√°-las, e isso n√£o funcionar√°. </p><br><p>  As se√ß√µes din√¢micas de arquivo incluem se√ß√µes nas quais est√£o armazenadas: </p><br><ul><li>  Dados tempor√°rios - eq.: Tmp, swap; </li><li>  Logs de trabalho - eq.: Var / log; </li><li>  Dados do usu√°rio - eq.: Home; </li><li>  Dados - eq.: Var / db e que sorte; </li><li>  Outros resultados do programa na forma de arquivos; </li></ul><br><p>  Nas fam√≠lias Linux, as parti√ß√µes din√¢micas incluem / tmp e / var, mas isso n√£o √© exato, pois elas podem entrar em / var / lib, programas e bibliotecas; em geral, tudo est√° misturado, mas mesmo assim ... </p><br><p>  Primeiro, voc√™ precisa decidir se deseja criar a parti√ß√£o / tmp no disco ou na mem√≥ria como tmpfs.  Se criarmos no disco, crie uma parti√ß√£o separada para ele: </p><br><pre> <code class="bash hljs">zfs create -o mountpoint=legacy tank/tmp</code> </pre> <br><blockquote>  Op√ß√µes com.sun: auto-snapshot = false setuid = off bem, n√£o importa como est√° o tempo, n√£o complique.  Mas com o SWAP, faremos mais adiante na etapa 7. </blockquote><br><p>  Separe a se√ß√£o var separadamente: </p><br><pre> <code class="bash hljs">zfs create -o mountpoint=legacy tank/var</code> </pre> <br><p>  E se√ß√µes do usu√°rio: </p><br><pre> <code class="bash hljs">zfs create -o mountpoint=/home tank/home zfs create -o mountpoint=legacy tank/home/root</code> </pre> <br><blockquote>  Faz sentido alocar parti√ß√µes de usu√°rio, pois, na pr√°tica, elas est√£o periodicamente entupidas com diferentes artefatos e para facilitar o monitoramento, √© melhor criar parti√ß√µes separadas para elas, bem como o diret√≥rio inicial do usu√°rio raiz (especialmente para quem gosta de trabalhar como raiz).  O uso de cotas nos diret√≥rios do usu√°rio n√£o s√≥ n√£o ajuda a obstruir o espa√ßo em disco, como tamb√©m interfere, pois nesses casos, os usu√°rios come√ßam a deixar artefatos em qualquer lugar e pode ser bastante dif√≠cil encontr√°-los posteriormente.  Isso n√£o √© tratado, ent√£o voc√™ s√≥ precisa controlar e vencer as m√£os. </blockquote><br><p>  O ponto de montagem tank / home / root est√° listado como legado, n√£o como / root.  Isso est√° correto, pois a montagem desta se√ß√£o √© realizada na se√ß√£o 4.11 </p><br><p>  Agora precisamos montar temporariamente nossas parti√ß√µes din√¢micas em / mnt: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /mnt/ mkdir var tmp root mount -t zfs tank/var /mnt/var/ mount -t zfs tank/tmp /mnt/tmp/ mount -t zfs tank/home/root /mnt/root/</code> </pre> <br><h3>  3.4 Instalando o kernel </h3><br><blockquote>  Na instru√ß√£o principal, existem mais alguns comandos desnecess√°rios, n√£o prestamos aten√ß√£o, aparentemente artefatos de experimentos: </blockquote><br><pre> <code class="bash hljs">debootstrap bionic /mnt</code> </pre> <br><p>  Como resultado, voc√™ deve obter algo parecido com isto: </p><br><pre> <code class="bash hljs">zfs list NAME USED AVAIL REFER MOUNTPOINT tank 213M 1.76T 96K legacy tank/home 208K 1.76T 96K /mnt/home tank/home/root 112K 1.76T 112K legacy tank/root 147M 1.76T 147M /mnt tank/tmp 96K 1.76T 96K legacy tank/var 64.6M 1.76T 64.6M legacy</code> </pre><br><p>  O tamanho da parti√ß√£o 96K vazia, respectivamente, apenas tank / tmp permaneceu vazio e o restante foi registrado durante a instala√ß√£o do kernel, o que significa que as parti√ß√µes foram montadas corretamente. </p><br><h2>  4. Configura√ß√£o do sistema </h2><br><h3>  4.1  Configurar hosts e nome do host </h3><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> HOSTNAME &gt; /mnt/etc/hostname <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äú127.0.0.1 localhost‚Äù &gt; /mnt/etc/hosts <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> ‚Äú127.0.0.1 HOSTNAME‚Äù &gt;&gt; /mnt/etc/hosts</code> </pre> <br><h3>  4.2  Configure a interface de rede </h3><br><blockquote>  Ent√£o, sim, j√° temos netplan aqui: </blockquote><br><pre> <code class="bash hljs">nano /mnt/etc/netplan/setup.yaml network: version: 2 renderer: networkd ethernets: eno2: dhcp4: no dhcp6: no addresses: [ {{ IP }}/{{ netmask }}, ] gateway4: {{ gateway IP }} nameservers: addresses: [8.8.8.8]</code> </pre> <br><h3>  4.3  Configurar reposit√≥rios apt </h3><br><pre> <code class="bash hljs">nano /mnt/etc/apt/sources.list deb http://archive.ubuntu.com/ubuntu/ bionic main restricted universe deb http://security.ubuntu.com/ubuntu/ bionic-security main restricted universe deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted universe</code> </pre> <br><blockquote>  src - n√£o √© necess√°rio principalmente </blockquote><br><h3>  4.4  Montamos se√ß√µes de arquivos virtuais LiveCD e "vamos" para o novo sistema </h3><br><pre> <code class="bash hljs">mount --rbind /dev /mnt/dev mount --rbind /proc /mnt/proc mount --rbind /sys /mnt/sys chroot /mnt /bin/bash --login</code> </pre><br><blockquote>  √© necess√°rio usar - rbind, mas n√£o - bind </blockquote><br><p>  J√° estamos no novo sistema ... </p><br><h3>  4.5  Configure o ambiente base </h3><br><pre> <code class="bash hljs">ln -s /proc/self/mounts /etc/mtab chmod 1777 /tmp apt update</code> </pre> <br><p>  Local e hora: </p><br><pre> <code class="bash hljs">dpkg-reconfigure locales * en_US.UTF-8 * ru_RU.UTF-8 dpkg-reconfigure tzdata</code> </pre> <br><p>  E editores adicionais que gostam do que: </p><br><pre> <code class="bash hljs">apt install --yes vim nano</code> </pre> <br><h3>  4.6  Instalando o suporte do ZFS </h3><br><pre> <code class="bash hljs">apt install --yes --no-install-recommends linux-image-generic apt install --yes zfs-initramfs</code> </pre> <br><h3>  4.8  Instale o carregador de inicializa√ß√£o </h3><br><p>  Como dito anteriormente, estou usando um MBR desatualizado: </p><br><pre> <code class="bash hljs">apt install --yes grub-pc</code> </pre> <br><blockquote>  Durante a instala√ß√£o do carregador de inicializa√ß√£o, √© necess√°rio selecionar todos os discos que identificamos como inicializ√°veis, enquanto o instalador jura em todos os outros discos, exceto o primeiro, concordamos e executamos a etapa 5 (n√£o est√° claro por que o restante foi deixado para mais tarde): </blockquote><br><h4>  4.8.1  (5.1) Verifique se o sistema de arquivos raiz √© reconhecido: </h4><br><pre> <code class="bash hljs">grub-probe / zfs</code> </pre> <br><h4>  4.8.2  (5.2) Atualizando o initrd </h4><br><pre> <code class="bash hljs">update-initramfs -u -k al</code> </pre> <br><h4>  4.8.3  (5.3) Simplifique a depura√ß√£o do GRUB </h4><br><pre> <code class="bash hljs">vi /etc/default/grub ... GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string"><span class="hljs-string">""</span></span> GRUB_CMDLINE_LINUX=<span class="hljs-string"><span class="hljs-string">"console"</span></span> ...</code> </pre><br><h4>  4.8.4  (5.4.) Atualizando a configura√ß√£o do gerenciador de inicializa√ß√£o </h4><br><pre> <code class="bash hljs">update-grub</code> </pre> <br><h4>  4.8.5  (5.5.) Instale o carregador de inicializa√ß√£o em cada disco marcado como inicializ√°vel </h4><br><pre> <code class="bash hljs">grub-install /dev/sda grub-install /dev/sdb ...</code> </pre><br><blockquote>  √â importante que esses comandos funcionem corretamente.  Para ser sincero, n√£o consegui fazer o oposto pelo menos uma vez, por isso n√£o sei o que fazer, mas provavelmente, se voc√™ tiver um erro, provavelmente fez algo errado ao marcar o disco (Se√ß√£o 2.2.). </blockquote><br><h4>  4.8.6  (5.6.) Verifique se o m√≥dulo ZFS est√° instalado </h4><br><pre> <code class="bash hljs">ls /boot/grub/*/zfs.mod /boot/grub/i386-pc/zfs.mod</code> </pre> <br><h3>  4.10  Defina a senha do root (dif√≠cil!) </h3><br><pre> <code class="bash hljs">passwd</code> </pre> <br><blockquote>  E sim, instalaremos o openssh imediatamente, caso contr√°rio, teremos uma surpresa ap√≥s a reinicializa√ß√£o se trabalharmos remotamente: </blockquote><br><pre> <code class="bash hljs">apt install --yes openssh-server</code> </pre> <br><p>  N√£o esque√ßa de corrigir a configura√ß√£o do sshd: </p><br><pre> <code class="bash hljs">vi /etc/ssh/sshd_config ... PermitRootLogin yes ... PasswordAuthentication yes ...</code> </pre> <br><h3>  4.11  Corrigir sistemas de arquivos de montagem </h3><br><blockquote>  Aqui chegamos ao mais interessante.  O fato √© que as parti√ß√µes do ZFS s√£o montadas ap√≥s o in√≠cio de alguns daemons (tamb√©m alteramos o ZFS_INITRD_ADDITIONAL_DATASETS no / etc / default / zfs), que, por sua vez, criam alguma estrutura por conta pr√≥pria no / var come√ßam a preencher os logs do sistema.  Quando chega a hora de montar parti√ß√µes ZFS, verifica-se que os pontos de montagem n√£o est√£o vazios e nada √© montado, os dados est√£o dispersos, tudo est√° ruim.  Portanto, voc√™ precisa especificar pontos de montagem no / etc / fstab, pois o systemd se concentra principalmente neles ao acessar a pasta: </blockquote><br><pre> <code class="bash hljs">vi /etc/fstab tank/var /var zfs noatime,nodev 0 0 tank/tmp /tmp zfs noatime,nodev 0 0 tank/home/root /root zfs noatime,nodev 0 0</code> </pre> <br><blockquote>  O restante est√° sujeito √† cl√°usula 6.  j√° feito </blockquote><br><h2>  6. Primeira reinicializa√ß√£o </h2><br><h3>  6.1  Tire uma foto da parti√ß√£o raiz </h3><br><pre> <code class="bash hljs">zfs snapshot tank/root@setup</code> </pre> <br><blockquote>  N√£o faz sentido dele, na pr√°tica nunca abalei a parti√ß√£o raiz do sistema e nunca usei instant√¢neos desta parti√ß√£o, mas, no entanto, deixe-a repousar, pode ser √∫til </blockquote><br><h3>  6.2  Chroot de sa√≠da </h3><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> <br><h3>  6.3  Desmonte parti√ß√µes do LiveCD e exporte a matriz ZFS </h3><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> mount | grep -v zfs | tac | awk <span class="hljs-string"><span class="hljs-string">'/\/mnt/ {print $3}'</span></span> | xargs -i{} umount -lf {} umount /mnt/root umount /mnt/var umount /mnt/tmp zpool <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> tank</code> </pre> <br><blockquote>  Exporta√ß√£o de matriz de disco necess√°ria para limpar o cache zfs </blockquote><br><h3>  6.4 Reinicializa√ß√£o </h3><br><blockquote>  A melhor reinicializa√ß√£o √© feita no terminal do LiveCD, pois se voc√™ trabalha com um cliente ssh, a reinicializa√ß√£o pode levar ao congelamento do servidor. </blockquote><br><pre> <code class="bash hljs">reboot</code> </pre> <br><blockquote>  Se, afinal, algo deu errado e o servidor n√£o foi reinicializado, voc√™ pode reinicializar de qualquer forma, pois a matriz ZFS √© exportada e √© dif√≠cil danific√°-la. </blockquote><br><h3>  6.5  Estamos aguardando uma reinicializa√ß√£o e vamos como root </h3><br><h3>  6.6  Crie sua conta de usu√°rio </h3><br><pre> <code class="bash hljs">zfs create tank/home/{{ LOGIN }} useradd -u {{ UID }} -G adm,sudo -d /home/{{ LOGIN }}/ -s /bin/bash {{ LOGIN }} cp -a /etc/skel/.[!.]* /home/{{ LOGIN }} chown -R {{ LOGIN }}:{{ LOGIN }} /home/{{ LOGIN }}</code> </pre> <br><p>  Adicione a chave p√∫blica ssh ao usu√°rio e defina a senha para ele: </p><br><pre> <code class="bash hljs">su - {{ LOGIN }} mkdir .ssh chmod 0700 .ssh vi .ssh/authorized_keys <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> passwd {{ LOGIN }}</code> </pre> <br><blockquote>  No OpenSSH, removemos a capacidade de efetuar login como autentica√ß√£o root e senha: </blockquote><br><pre> <code class="bash hljs">vi /etc/ssh/sshd_config ... PermitRootLogin no ... PubkeyAuthentication yes ... PasswordAuthentication no ... service ssh restart</code> </pre> <br><h3>  6.7  6.8  N√£o √© mais necess√°rio </h3><br><h2>  7. Configurando Troca </h2><br><h3>  7.1  Crie uma parti√ß√£o ZFS </h3><br><pre> <code class="bash hljs">zfs create \ -V 32G \ -b $(getconf PAGESIZE) \ -o compression=<span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> \ -o logbias=throughput \ -o sync=always \ -o primarycache=metadata \ -o secondarycache=none \ tank/swap</code> </pre> <br><ul><li>  -V 32G - O tamanho do nosso SWAP, voc√™ pode determinar o que √© realmente necess√°rio; </li><li>  -b $ (getconf PAGESIZE) - tamanho do bloco (4K com ashift = 12); </li><li>  compress√£o = zle - escolha o algoritmo de compacta√ß√£o que √© m√≠nimo em termos de consumo de recursos, uma vez que, na verdade, o tamanho do bloco √© 4K, a compacta√ß√£o n√£o permitir√° a utiliza√ß√£o da entrada-sa√≠da, mas ser√° poss√≠vel economizar em zero blocos; </li><li>  logbias = throughput - configurando largura de banda para otimizar opera√ß√µes s√≠ncronas; </li><li>  sync = always - sempre sincroniza o registro.  Isso reduz um pouco o desempenho, mas garante totalmente a confiabilidade dos dados; </li><li>  primarycache = metadados - armazena apenas metadados, pois o swap n√£o ser√° usado para ler o mesmo bloco v√°rias vezes; </li><li>  primarycache = none - desative completamente o cache secund√°rio pelos motivos mencionados acima; </li></ul><br><h3>  7.2  Configure a parti√ß√£o de troca </h3><br><pre> <code class="bash hljs">mkswap -f /dev/zvol/tank/swap <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> /dev/zvol/tank/swap none swap defaults 0 0 &gt;&gt; /etc/fstab <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> RESUME=none &gt; /etc/initramfs-tools/conf.d/resume</code> </pre><br><h3>  7.3  Ativar troca </h3><br><pre> <code class="bash hljs">swapon -av</code> </pre> <br><blockquote><p>  Seguindo as instru√ß√µes, n√£o h√° muito que seja interessante, pois depende muito das prefer√™ncias de administradores espec√≠ficos e das tarefas do servidor como um todo, exceto por um ponto, a saber: "Inicializa√ß√£o de emerg√™ncia" </p><p>  E n√£o se esque√ßa de colocar o Firewall </p></blockquote><br><h2>  R. Inicializa√ß√£o de emerg√™ncia </h2><br><p>  Preparamos o ambiente de instala√ß√£o (item 1.) </p><br><p>  Durante a prepara√ß√£o, a matriz do ZFS √© importada; portanto, √© necess√°rio reimport√°-la, mas com o ponto de montagem correto: </p><br><pre> <code class="bash hljs">zpool <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> -a zpool import -N -R /mnt tank zfs mount -a</code> </pre> <br><blockquote> , ,      ,        fstab,    : </blockquote><br><pre> <code class="bash hljs">mount -t zfs tank/var /mnt/var/ mount -t zfs tank/tmp /mnt/tmp/ mount -t zfs tank/home/root /mnt/root/</code> </pre> <br><p> ,   ,   chroot   .4.4.,          . 6.3. </p><br><h2> D.   </h2><br><p>   3.3.             .      ,        : ,       /spool,      /data.       ZFS     . </p><br><h2>  Sum√°rio </h2><br><ul><li>       ZFS  ,     ,     ; </li><li>        ZFS,                 ,     .    ZFS ‚Äî       ,   ; </li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">.</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439860/">https://habr.com/ru/post/pt439860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439850/index.html">Detec√ß√£o de emo√ß√£o contextual em conversas textuais usando redes neurais</a></li>
<li><a href="../pt439852/index.html">Vers√£o do aplicativo de controle remoto: Aspia 1.1.0</a></li>
<li><a href="../pt439854/index.html">Ah, mais uma vez: o que fazer com um cliente no CRM depois que ele comprou</a></li>
<li><a href="../pt439856/index.html">Yandex! Obrigado por Uber</a></li>
<li><a href="../pt439858/index.html">Prometheus + Grafana + Exportador de n√≥s + Docker no Azure com notifica√ß√µes no Telegram</a></li>
<li><a href="../pt439862/index.html">Eventos digitais em Moscou, de 11 a 17 de fevereiro</a></li>
<li><a href="../pt439864/index.html">Gest√£o do conhecimento, por que e como fizemos</a></li>
<li><a href="../pt439866/index.html">Os princ√≠pios de cria√ß√£o de diret√≥rios de nomenclatura no 1C Enterprise Management 2 (ERP 2.4.6)</a></li>
<li><a href="../pt439868/index.html">Vida sem Facebook: visualiza√ß√µes menos radicais, bom humor, mais tempo para os entes queridos. Agora comprovado pela ci√™ncia</a></li>
<li><a href="../pt439870/index.html">O v√≠deo como motor do progresso: a evolu√ß√£o dos sistemas de vigil√¢ncia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>