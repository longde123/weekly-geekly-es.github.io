<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏾 🛰️ 🔮 Hal paling menarik di PHP 8 🆔 ♒️ 👨🏿‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP 7.4 baru saja dinyatakan stabil, dan kami telah mengirimkan lebih banyak perbaikan. Dan yang terpenting, apa yang ditunggu-tunggu PHP dapat member...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hal paling menarik di PHP 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/481092/">  PHP 7.4 baru saja dinyatakan stabil, dan kami telah mengirimkan lebih banyak perbaikan.  Dan yang terpenting, apa yang ditunggu-tunggu PHP dapat memberi tahu Dmitry Stogov - salah satu pengembang terkemuka Open Source PHP dan, mungkin, kontributor aktif tertua. <br><br>  Semua laporan Dmitry hanya tentang teknologi dan solusi yang ia kerjakan secara pribadi.  Dalam tradisi terbaik Ontiko, di bawah potongan, versi teks <a href="https://youtu.be/7UOWus-5yxg">cerita</a> tentang inovasi PHP 8 paling menarik dari sudut pandang Dmitry yang dapat membuka kasus penggunaan baru.  Pertama-tama, JIT dan FFI - bukan kunci “prospek luar biasa”, tetapi dengan detail implementasi dan jebakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/o1/xd/h9o1xdb-wntc2xl0eipeb4bd7du.png" width="500"></div><br>  <i>Untuk referensi:</i> Dmitry Stogov berkenalan dengan pemrograman pada tahun 1984, ketika tidak semua pembaca lahir, dan berhasil memberikan kontribusi yang signifikan terhadap pengembangan alat pengembangan, dan PHP khususnya (meskipun Dmitry meningkatkan kinerja PHP tidak khusus untuk pengembang Rusia, mereka <a href="https://habr.com/ru/company/oleg-bunin/blog/477426/">menyatakan</a> terima kasih saya dalam bentuk Penghargaan HighLoad ++).  Dmitry adalah penulis Turck MMCache untuk PHP (eAccelerator), pengelola Zend OPcache, pemimpin proyek PHPNG, yang membentuk dasar dari PHP 7, dan pemimpin dalam pengembangan JIT untuk PHP. <br><a name="habracut"></a><br><h2>  Pengembangan kinerja PHP </h2><br>  Saya mulai bekerja pada kinerja PHP 15 tahun yang lalu ketika saya bergabung dengan Zend.  Lalu kami merilis versi 5.0 - yang pertama di mana bahasa menjadi benar-benar berorientasi objek.  Sejak itu, kami telah mampu meningkatkan kinerja pada tes sintetik sebanyak 40 kali, dan pada aplikasi nyata sebanyak 6 kali. <br><br><img src="https://habrastorage.org/webt/xp/gc/xe/xpgcxedjqqy7_ay7vzrocx2cl3y.jpeg"><br><br>  Selama waktu ini, ada dua momen terobosan: <br><br><ul><li>  Versi 5.1, di mana kami dapat secara signifikan meningkatkan kecepatan interpretasi.  Kami menerapkan juru bahasa khusus, dan ini terutama mempengaruhi tes sintetik. </li><li> Versi 7.0, di mana semua struktur data utama diproses dan dengan demikian mengoptimalkan pekerjaan dengan memori dan cache prosesor (baca lebih lanjut tentang optimasi ini di <a href="https://habr.com/ru/company/oleg-bunin/blog/444508/">sini</a> ).  Hal ini menyebabkan percepatan lebih dari dua kali lipat baik dalam tes sintetik dan aplikasi nyata. </li></ul><br>  Semua versi lain secara bertahap meningkatkan produktivitas dengan menerapkan banyak ide yang kurang efektif.  Dalam versi 7.1, misalnya, banyak perhatian diberikan untuk mengoptimalkan bytecode ( <a href="https://habr.com/ru/company/oleg-bunin/blog/445512/">sebuah artikel</a> tentang solusi ini). <br><br>  Diagram menunjukkan bahwa baik pada akhir pengembangan versi 5 dan pada akhir siklus pengembangan versi 7, kita pergi ke dataran tinggi dan melambat.  Jadi selama tahun terakhir bekerja pada v7.4, hanya peningkatan 2% dalam produktivitas yang telah dicapai.  Dan ini tidak buruk, karena fitur-fitur baru seperti properti yang diketik dan tipe kovarian telah muncul yang memperlambat PHP (Nikita Popov <a href="https://youtu.be/teKnckg5x7I">berbicara</a> tentang produk-produk baru ini di PHP Rusia). <br><br>  Dan sekarang semua orang bertanya-tanya apa yang diharapkan dari versi ke-8, dapatkah ia mengulang kesuksesan v7? <br><br><h3>  Ke JIT atau tidak ke JIT </h3><br>  Gagasan untuk meningkatkan penerjemah belum habis, tetapi semuanya membutuhkan penelitian yang sangat substansial.  Banyak dari mereka harus ditolak pada tahap pembuktian konsep, karena perolehan yang dapat diperoleh ternyata tidak dapat dibandingkan dengan kerumitan atau batasan teknis yang dipaksakan. <br><br>  Tetapi masih ada harapan untuk teknologi terobosan baru - tentu saja, saya ingat JIT dan kisah sukses mesin JavaScript. <br><br>  Bahkan, bekerja pada JIT untuk PHP telah berlangsung sejak 2012.  Ada 3 atau 4 implementasi, kami bekerja dengan kolega Intel, peretas JavaScript, tetapi entah bagaimana itu tidak mungkin untuk memasukkan JIT di cabang utama.  Pada akhirnya, di PHP 8, kami memasukkan JIT dalam kompiler dan melihat akselerasi ganda, tetapi hanya pada tes sintetik, tetapi pada aplikasi nyata, sebaliknya, perlambatan. <br><br><img src="https://habrastorage.org/webt/no/ly/58/noly58x1blcmkwv80nd8n60yu3q.jpeg"><br><br>  Tentu saja, ini bukan yang kita perjuangkan. <br><br>  Ada apa?  Mungkin kita melakukan sesuatu yang salah, mungkin WordPress sangat buruk, dan tidak ada JIT yang akan membantunya (ya, sebenarnya itu).  Mungkin kita sudah membuat penerjemah terlalu bagus, tetapi dalam JavaScript itu lebih buruk.  Dalam tes komputasi, ini benar: <strong>penerjemah PHP adalah salah satu yang terbaik</strong> . <br><br><img src="https://habrastorage.org/webt/fi/ya/lc/fiyalccpg18n2aieqgj7bmy-nho.jpeg"><br><br>  Pada tes Mandelbrot, ia bahkan menyalip permata seperti LuaJIT, seorang penerjemah yang ditulis dalam bahasa assembly.  Dalam tes ini, kita hanya 4 kali di belakang kompiler GCC-5.3 yang mengoptimalkan.  Dengan JIT, kami bisa mendapatkan hasil yang lebih baik dalam tes Mandelbrot.  Sebenarnya, kami sudah melakukan ini, yaitu, kami dapat menghasilkan kode yang bersaing dengan kompiler C. <br><br>  Lalu mengapa kita tidak dapat mempercepat aplikasi nyata?  Untuk memahami, saya akan memberi tahu Anda bagaimana kami melakukan JIT.  Mari kita mulai dengan dasar-dasarnya. <br><br><h3>  Bagaimana cara kerja PHP </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r3/u7/zz/r3u7zzdgmpo37fihs44l6jl29wq.jpeg" width="300"></div><br>  Server menerima permintaan, mengkompilasinya menjadi bytecode, yang pada gilirannya dikirim ke mesin virtual untuk dieksekusi.  Dengan menjalankan bytecode, mesin virtual juga dapat memanggil file PHP lainnya, yang sekali lagi dikompilasi ulang menjadi bytecode dan dieksekusi lagi. <br><br>  Setelah menyelesaikan kueri, semua informasi yang berkaitan dengannya, termasuk kode byte, dihapus dari memori.  Artinya, setiap skrip PHP harus dikompilasi pada setiap permintaan lagi.  Tentu saja, tidak mungkin untuk menanamkan kompilasi JIT ke dalam skema seperti itu, karena kompiler harus sangat cepat. <br><br>  Tetapi kemungkinan besar tidak ada yang menggunakan PHP dalam bentuk aslinya, semua orang menggunakannya dengan OPcache. <br><br><h3>  PHP + OPcache </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/cg/wr/w4cgwrta9e7mdka4mzsylnfzbqa.jpeg" width="484"></div><br>  Tujuan utama OPcache adalah untuk menyingkirkan kompilasi ulang skrip pada setiap permintaan.  Itu tertanam di titik yang dirancang khusus untuk itu, mencegat semua permintaan kompilasi dan cache bytecode yang dikompilasi dalam memori bersama. <br><br>  Pada saat yang sama, tidak hanya waktu kompilasi yang disimpan, tetapi juga memori, karena memori bytecode sebelumnya dialokasikan di ruang alamat setiap proses, dan sekarang ada dalam satu salinan. <br><br>  Anda sudah dapat menanamkan JIT di sirkuit ini, yang akan kami lakukan.  Tapi pertama-tama, saya akan menunjukkan kepada Anda bagaimana penerjemah bekerja. <br><br><img src="https://habrastorage.org/webt/jt/d5/50/jtd550mfh4al9klurcdde6yfzce.jpeg"><br><br>  Seorang juru bahasa pertama-tama adalah sebuah loop yang memanggil penangannya sendiri untuk setiap instruksi. <br><br>  Kami menggunakan dua register: <br><br><ul><li>  execute_data - penunjuk ke bingkai aktivasi saat ini; </li><li>  opline - penunjuk ke instruksi virtual yang dapat dieksekusi saat ini. </li></ul><br>  Menggunakan ekstensi gcc, kedua jenis register ini memetakan ke register perangkat keras yang sebenarnya, dan karena itu mereka bekerja dengan sangat cepat. <br><br>  Dalam loop, kita cukup memanggil pawang untuk setiap instruksi, setelah itu pada akhir setiap pawang kita memindahkan pointer ke instruksi berikutnya. <br><br>  Penting untuk dicatat bahwa alamat pawang ditulis langsung ke bytecode.  Mungkin ada beberapa penangan yang berbeda untuk satu instruksi.  Ini awalnya diciptakan untuk spesialisasi sehingga penangan dapat berspesialisasi dalam jenis operan.  Teknologi yang sama digunakan untuk JIT, karena jika Anda menulis alamat ke kode baru yang dihasilkan sebagai penangan, maka penangan-JIT akan diluncurkan tanpa perubahan apa pun pada juru bahasa. <br><br>  Pada contoh di atas, pawang yang ditulis untuk instruksi tambahan disajikan di sebelah kanan.  Dibutuhkan operan (di sini yang pertama dan kedua dapat berupa variabel konstan, sementara atau lokal), membaca operan, memeriksa jenis, menghasilkan logika langsung - tambahan - dan kemudian kembali ke loop, yang mentransfer kontrol ke pengendali berikutnya. <br><br>  Fungsi khusus dihasilkan dari deskripsi ini.  Karena ada tiga kemungkinan operan pertama, tiga kemungkinan kedua, kami mendapatkan 9 fungsi yang berbeda. <br><br><img src="https://habrastorage.org/webt/sx/ac/ud/sxacudlzwpaetj0jdqlj-n-udqm.jpeg"><br><br>  Dalam fungsi-fungsi ini, alih-alih metode universal untuk mendapatkan operan, yang spesifik digunakan yang tidak melakukan pemeriksaan. <br><br><h3>  Mesin Virtual Hibrid </h3><br>  Komplikasi lain yang kami buat dalam versi 7.2 adalah apa yang disebut mesin virtual hybrid. <br><br>  Jika sebelumnya kita selalu memanggil pawang menggunakan panggilan tidak langsung langsung di loop juru bahasa, sekarang untuk masing-masing pawang kita juga memasukkan label di tubuh loop, yang kita lompat untuk menggunakan lompatan tidak langsung dan di mana kita memanggil handler itu sendiri, tetapi secara langsung. <br><br><img src="https://habrastorage.org/webt/ym/ve/1r/ymve1rgaxks_48lgcgt_m2zf3xm.jpeg"><br><br>  Tampaknya sebelumnya mereka membuat satu panggilan tidak langsung, sekarang dua: transisi tidak langsung dan panggilan langsung, dan sistem seperti itu seharusnya bekerja lebih lambat.  Tetapi sebenarnya ini bekerja lebih cepat, karena kami membantu prosesor untuk memprediksi transisi.  Sebelumnya, ada satu titik dari mana transisi ke tempat yang berbeda dilakukan.  Prosesornya sering keliru, karena ia tidak dapat mengingat bahwa ia perlu melompat terlebih dahulu pada satu instruksi, kemudian pada instruksi lainnya.  Sekarang, setelah setiap panggilan langsung, ada transisi tidak langsung ke label berikutnya.  Akibatnya, ketika loop PHP dieksekusi, instruksi PHP virtual diatur dalam urutan stabil, yang kemudian dieksekusi hampir secara linear. <br><br>  Mesin virtual hybrid memungkinkan untuk meningkatkan produktivitas sebesar 5-10%. <br><br><h3>  PHP + OPcache + JIT </h3><br>  JIT diimplementasikan sebagai bagian dari OPcache. <br><br><img src="https://habrastorage.org/webt/ye/ad/ad/yeadadf8b-tvejykkpdgpf3pacq.jpeg"><br><br>  Setelah bytecode dikompilasi dan dioptimalkan, kompiler JIT diluncurkan untuknya, yang tidak lagi berfungsi dengan kode sumber.  Dari bytecode PHP, kompiler JIT menghasilkan kode asli, setelah itu alamat instruksi pertama (sebenarnya fungsi) diubah dalam bytecode. <br><br>  Setelah itu, kode asli yang sudah dibuat mulai dipanggil dari interpreter yang ada tanpa perubahan apa pun.  Saya akan menunjukkan kepada Anda contoh sederhana. <br><br><img src="https://habrastorage.org/webt/y8/zs/jz/y8zsjz7rzbiuvct-l146whbcotw.jpeg"><br><br>  Di sebelah kiri, fungsi tertentu ditulis dalam PHP yang menghitung jumlah angka dari 0 hingga 100. Di sebelah kanan, bytecode yang dihasilkan.  Instruksi pertama memberikan 0 ke jumlah, yang kedua melakukan hal yang sama untuk i, kemudian lompatan tanpa syarat ke label.  Pada label L1, kondisi untuk keluar dari siklus diperiksa: jika sudah terpenuhi, kemudian keluar, jika tidak, kemudian pergi ke siklus.  Selanjutnya, tambahkan ke jumlah i, tulis hasilnya dalam jumlah, tambah i dengan 1. <br><br>  Langsung dari sini kita menghasilkan kode assembler, yang ternyata cukup bagus. <br><br><img src="https://habrastorage.org/webt/_g/q2/8b/_gq28bxpchqg3bc5duu7tysvpsq.jpeg"><br><br>  Instruksi <code>QM_ASSIGN</code> pertama dikompilasi menjadi hanya dua instruksi mesin (2-3 baris).  Register <code>%esi</code> berisi pointer ke bingkai aktivasi saat ini.  Pada offset 30 terletak jumlah variabel.  Instruksi pertama menulis nilai 0, yang kedua menulis 4 - ini adalah pengidentifikasi tipe integer ( <code>IS_LONG</code> ).  Untuk variabel <code>i</code> kompiler menyadari bahwa ia selalu panjang, dan untuk itu tidak perlu menyimpan jenisnya.  Selain itu, dapat disimpan dalam register mesin.  Oleh karena itu, di sini hanya XOR dari register itu sendiri adalah instruksi paling sederhana dan termurah untuk mengatur ulang. <br><br>  Kemudian, dengan cara yang sama, transisi tanpa syarat, kami memeriksa apakah beberapa peristiwa eksternal telah terjadi, kami memeriksa kondisi siklus, kami masuk ke siklus.  Pengulangan memeriksa apakah jumlah adalah bilangan bulat: jika ya, kemudian baca nilai bilangan bulat, tambahkan nilai i ke dalamnya, periksa apakah terjadi overflow, tulis kembali hasilnya ke jumlah tersebut dan tambahkan 1 ke <code>%edx</code> . <br><br>  Dapat dilihat bahwa kodenya mendekati optimal.  Akan lebih mungkin untuk mengoptimalkannya, menyingkirkan memeriksa jumlah untuk jenis di setiap iterasi dari loop.  Tapi ini sudah optimasi yang cukup rumit, kami belum melakukannya.  <strong>Kami sedang mengembangkan JIT sebagai teknologi yang cukup sederhana</strong> , kami tidak mencoba melakukan apa yang Java HotSpot coba lakukan, V8 - kami memiliki daya yang lebih kecil. <br><br><h2>  Apa yang salah dengan jit </h2><br>  Mengapa, dengan kode assembler yang begitu bagus, tidak bisakah kita mempercepat aplikasi nyata? <br><br>  Sebenarnya, haruskah mereka? <br><br><ul><li>  Jika bottleneck tidak ada dalam CPU, maka JIT tidak akan membantu. </li><li>  Terlalu banyak kode yang dihasilkan (kode mengasapi). </li><li>  Inferensi tipe statis tidak selalu berhasil. </li><li>  Kode jujur ​​(untuk kasus yang tidak pernah dieksekusi). </li><li>  Dukungan untuk kondisi konsisten mesin virtual (dan tiba-tiba pengecualian). </li><li>  Kelas hidup hanya untuk satu permintaan. </li></ul><br>  Jika aplikasi menunggu 80% dari waktu untuk tanggapan dari database, maka JIT tidak akan membantu.  Jika kita memanggil fungsi intensif sumber daya eksternal, misalnya, cocok dengan ekspresi reguler, maka JIT juga akan memanggil fungsi yang sama dengan cara yang sama.  Selain itu, jika suatu aplikasi membangun struktur data besar - pohon, grafik, dan kemudian membacanya, maka menggunakan JIT kita menghasilkan kode yang akan membaca dalam instruksi yang lebih sedikit, tetapi untuk memuat data itu sendiri, itu akan memakan waktu yang sama, tetapi Anda juga perlu memuat kode. <br><br>  Seperti yang telah Anda lihat, JIT bahkan dapat memperlambat aplikasi nyata, karena menghasilkan banyak kode dan membacanya menjadi masalah - ketika membaca kode dalam jumlah besar, data lain dipaksa keluar dari cache, yang mengarah ke perlambatan. <br><br><h2>  Paket sederhana untuk PHP 8 </h2><br>  Salah satu perbaikan yang ingin kami capai dalam PHP 8 adalah <strong>menghasilkan lebih sedikit kode</strong> .  Sekarang, seperti yang saya katakan, kami membuat kode asli untuk seluruh skrip, yang kami muat pada tahap pemuatan.  Tetapi setengah dari fungsi tentu tidak akan dipanggil.  Jadi kami melangkah lebih jauh dan memperkenalkan pemicu yang memungkinkan kami untuk mengonfigurasi saat kami ingin menjalankan JIT.  Itu bisa dijalankan: <br><br><ul><li>  untuk semua fungsi; </li><li>  hanya untuk fungsi saat pertama kali dipanggil; </li><li>  Anda dapat menggantung penghitung di setiap fungsi dan mengkompilasi hanya fungsi-fungsi yang benar-benar panas. </li></ul><br>  Skema seperti itu mungkin bekerja sedikit lebih baik, tetapi masih belum optimal, karena sekali lagi di setiap fungsi ada jalur yang dieksekusi, dan jalur yang tidak pernah dieksekusi.  Karena PHP adalah bahasa pemrograman yang dinamis, yaitu, setiap variabel dapat memiliki jenis yang berbeda, ternyata Anda perlu mendukung semua jenis yang diprediksi oleh penganalisa statis.  Dan dia sering melakukan ini dengan hati-hati ketika dia tidak dapat membuktikan bahwa tipe yang lain tidak bisa melakukannya. <br><br>  <strong>Dalam kondisi ini, kita akan menjauh dari kompilasi yang jujur ​​dan mulai melakukannya secara spekulatif.</strong> <br><br><img src="https://habrastorage.org/webt/cf/fu/2z/cffu2zfla_l00cqpouzm-ldteoi.jpeg"><br><br>  Di masa depan, kami berencana untuk pertama kali selama beberapa waktu selama pekerjaan aplikasi menganalisis fungsi "terpanas", melihat jalur apa yang dilalui program, jenis variabel apa, bahkan mungkin mengingat kondisi batas, dan hanya kemudian menghasilkan kode fungsi yang optimal untuk saat ini cara eksekusi - hanya untuk bagian-bagian yang benar-benar dieksekusi. <br><br>  Untuk yang lainnya, kami akan meletakkan bertopik.  Semua sama, akan ada pemeriksaan dan kemungkinan keluaran di mana proses deoptimisasi akan dimulai, yaitu, kami akan mengembalikan keadaan mesin virtual yang diperlukan untuk interpretasi dan memberikannya kepada penerjemah untuk dieksekusi. <br><br>  Skema serupa digunakan di HotSpot Java VM dan V8.  Tetapi mengadaptasi teknologi ke PHP memiliki sejumlah kesulitan.  Pertama-tama, ini adalah kami telah membagikan bytecode dan membagikan kode asli yang digunakan dari berbagai proses.  Kami tidak dapat mengubahnya secara langsung dalam memori bersama, pertama-tama kami harus menyalin di suatu tempat, mengubah, dan kemudian melakukan kembali ke memori bersama. <br><br><h2>  Preloading.  Masalah pengikatan kelas </h2><br>  Bahkan, banyak ide untuk peningkatan PHP yang telah lama disertakan dalam PHP 7 dan bahkan PHP 5 berasal dari pekerjaan yang berhubungan dengan JIT.  Hari ini saya akan berbicara tentang teknologi lain seperti ini - ini preloading.  Teknologi ini sudah termasuk dalam PHP 7.4 dan memungkinkan untuk menentukan satu set file, memuatnya saat server mulai, dan menjadikan semua fungsi file-file ini permanen. <br><br>  Salah satu masalah yang memecahkan teknologi preloading adalah masalah pengikatan kelas.  Faktanya adalah ketika kita hanya mengkompilasi file dalam PHP, setiap file dikompilasi secara terpisah dari yang lain.  Ini dilakukan karena masing-masing dapat diubah secara terpisah.  Anda tidak dapat mengaitkan kelas dari satu skrip dengan kelas dari skrip lain, karena pada permintaan berikutnya salah satu dari mereka dapat berubah, dan ada sesuatu yang salah.  Selain itu, dalam beberapa file mungkin ada kelas dengan nama yang sama, dan dengan satu permintaan salah satunya digunakan sebagai orangtua, dan dengan yang lain, kelas lain dari file lain digunakan (dengan nama yang sama, tetapi sama sekali berbeda).  Ternyata ketika membuat kode yang akan dieksekusi pada beberapa permintaan, Anda tidak dapat merujuk ke kelas atau metode, karena mereka dibuat ulang setiap kali (masa hidup kode melebihi masa hidup kelas). <br><br>  Preloading memungkinkan Anda untuk mengikat kelas pada awalnya dan, karenanya, menghasilkan kode lebih optimal.  Minimal, untuk kerangka kerja yang akan dimuat menggunakan preloading. <br><br>  Teknologi ini membantu tidak hanya untuk pengikatan kelas.  Hal serupa diterapkan di Jawa sebagai Berbagi Data Kelas.  Di sana, teknologi ini terutama ditujukan untuk mempercepat peluncuran aplikasi dan mengurangi jumlah total memori yang dikonsumsi.  Plus yang sama diperoleh dalam PHP, karena sekarang pengikatan kelas tidak dilakukan dalam runtime, tetapi dilakukan hanya sekali.  Selain itu, kelas terkait sekarang disimpan bukan di ruang alamat setiap proses, tetapi di memori bersama, dan oleh karena itu total konsumsi memori turun. <br><br>  Menggunakan preloading juga membantu optimasi global semua skrip PHP, sepenuhnya menghapus overhead OPcache dan memungkinkan Anda untuk menghasilkan kode JIT yang lebih efisien. <br><br>  Namun ada juga kekurangannya.  <strong>Script yang dimuat saat startup tidak dapat diganti tanpa me-restart PHP.</strong>  Jika kami mengunduh sesuatu dan membuatnya permanen, maka kami tidak dapat lagi menurunkannya.  Oleh karena itu, teknologi ini dapat digunakan dengan kerangka kerja yang stabil, tetapi jika Anda menggunakan aplikasi beberapa kali sehari, kemungkinan besar itu tidak akan bekerja untuk Anda. <br><br>  Teknologi ini dianggap transparan, yaitu memungkinkan memuat aplikasi yang ada (atau bagiannya) tanpa perubahan.  Tetapi setelah implementasi, ternyata ini tidak sepenuhnya benar.Tidak <strong>semua aplikasi berfungsi seperti yang dimaksudkan jika mereka dimuat menggunakan preload</strong> .  Misalnya, jika kode dipanggil dalam aplikasi berdasarkan hasil pemeriksaan <code>function_exists</code> atau <code>class_exists</code> , dan fungsi menjadi konstan, masing-masing, <code>function_exists</code> selalu mengembalikan <code>true</code> , dan kode yang sebelumnya dipanggil seharusnya dipanggil. <br><br>  Secara teknis, preloading diaktifkan dengan bantuan hanya satu konfigurasi directive opcache.preload, ke input yang Anda berikan file skrip - file PHP biasa yang akan diluncurkan pada tahap startup aplikasi (tidak hanya dimuat, tetapi dieksekusi). <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_preload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $preload, string $pattern = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/\.php$/"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_file($path) &amp;&amp; preg_match($pattern, $path)) { opcache_compile_file($path) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"Preloading failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_dir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($dh = opendir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (($file = readdir($dh)) !== <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($file !== <span class="hljs-string"><span class="hljs-string">"."</span></span> &amp;&amp; $file !== <span class="hljs-string"><span class="hljs-string">".."</span></span>) { _preload($path . <span class="hljs-string"><span class="hljs-string">"/"</span></span> . $file, $pattern); } } closedir($dh); } } } _preload(<span class="hljs-string"><span class="hljs-string">"/usr/local/lib/ZendFramework"</span></span>);</code> </pre> <br>  Ini adalah salah satu skenario yang mungkin yang secara rekursif membaca semua file di beberapa direktori (dalam hal ini, ZendFramework).  Anda dapat menerapkan sepenuhnya skrip apa pun dalam PHP: baca dengan daftar, tambahkan pengecualian, atau bahkan silang dengan komposer sehingga dapat podsoval file yang diperlukan untuk preloading.  Ini semua masalah teknologi, dan yang lebih menarik bukanlah cara mengirim, tetapi apa yang harus dikirim. <br><br><h3>  Apa yang dimuat di preloading </h3><br>  Saya mencoba teknologi ini di WordPress.  Jika Anda hanya mengunggah semua file * .php, maka WordPress akan berhenti bekerja karena fitur yang disebutkan sebelumnya: ia memiliki pemeriksaan function_exists, yang selalu menjadi kenyataan.  Oleh karena itu, saya harus sedikit memodifikasi skrip dari contoh sebelumnya (tambahkan pengecualian), dan kemudian, tanpa perubahan di WordPress itu sendiri, itu berhasil. <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  Kecepatan [req / seq] </td><td>  Memori [MB] </td><td>  Jumlah skrip </td><td>  Jumlah fungsi </td><td>  Jumlah kelas </td></tr><tr><td>  Tidak ada </td><td>  378 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  Semua (hampir *) </td><td>  395 </td><td>  7.5 </td><td>  254 </td><td>  1770 </td><td>  148 </td></tr><tr><td>  Hanya skrip yang digunakan </td><td>  396 </td><td>  4,5 </td><td>  84 </td><td>  1532 </td><td>  51 </td></tr></tbody></table></div><br>  Akibatnya, <strong>karena preloading kami mendapat akselerasi ~ 5%</strong> , yang sudah tidak buruk. <br><br>  Saya mengunduh hampir semua file, tetapi setengahnya tidak digunakan.  Anda dapat melakukan yang lebih baik - menggerakkan aplikasi, melihat file mana yang telah diunduh.  Anda dapat melakukan ini menggunakan fungsi <code>opcache_get_status()</code> , yang akan mengembalikan semua file yang di-cache OPcache dan membuat daftar untuk mereka untuk preloading.  Dengan demikian, Anda dapat menghemat 3 MB dan mendapatkan sedikit lebih banyak akselerasi.  Faktanya adalah semakin banyak memori yang dibutuhkan, semakin banyak cache prosesor menjadi kotor, dan semakin tidak efisien.  <strong>Semakin sedikit memori yang digunakan, semakin tinggi kecepatannya.</strong> <br><br><h2>  FFI - Antarmuka Fungsi Asing </h2><br>  Teknologi lain yang terkait dengan JIT yang dikembangkan untuk PHP adalah FFI (Foreign Function Interface) atau, dalam bahasa Rusia, kemampuan untuk memanggil fungsi yang ditulis dalam bahasa pemrograman terkompilasi lain tanpa kompilasi.  Implementasi teknologi semacam itu di Python membuat bos saya terkesan (Zeev Surazki), dan saya sangat terkesan ketika saya mulai menyesuaikannya dengan PHP. <br><br>  Sudah ada beberapa upaya di PHP untuk membuat ekstensi untuk FFI, tetapi mereka semua menggunakan bahasa mereka sendiri atau API untuk menggambarkan antarmuka.  Saya melihat ide di LuaJIT, di mana bahasa C (subset) digunakan untuk menggambarkan antarmuka, dan hasilnya adalah mainan yang sangat keren.  Sekarang, ketika saya perlu memeriksa bagaimana sesuatu bekerja di C, saya menulisnya di PHP - itu terjadi, tepat di baris perintah. <br><br>  FFI memungkinkan Anda untuk bekerja dengan struktur data yang didefinisikan dalam C dan dapat diintegrasikan dengan JIT untuk menghasilkan kode yang lebih efisien.  Implementasi berbasis libffi sudah termasuk dalam PHP 7.4. <br><br>  Tapi: <br><br><ul><li>  Ini adalah 1000 cara baru untuk menembak diri sendiri di kaki. </li><li>  Membutuhkan pengetahuan C dan terkadang manajemen memori manual. </li><li>  Tidak mendukung C-preprocessor (#include, #define, ...) dan C ++. </li><li>  Performa tanpa JIT cukup rendah. </li></ul><br>  Meskipun, mungkin untuk beberapa itu akan nyaman, karena kompiler tidak diperlukan.  Bahkan di bawah Windows, ini akan berfungsi tanpa Visual-C dari PHP. <br><br>  Saya akan menunjukkan cara menggunakan FFI untuk mengimplementasikan aplikasi GUI nyata untuk Linux. <br><br>  Jangan khawatir dengan kode C, saya sendiri menulis GUI di C 20 tahun yang lalu, tetapi saya menemukan contoh ini di Internet. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; static void activate(GtkApplication* app, gpointer user_data) { GtkWidget *window = gtk_application_window_new(app); gtk_window_set_title(GTK_WINDOW(window), "Hello from C"); gtk_window_set_default_size(GTK_WINDOW(window), 200, 200); gtk_widget_show_all(window); } int main() { int status; GtkApplication *app; app = gtk_application_new("org.gtk.example", G_APPLICATION_FLAGS_NONE); g_signal_connect(app, "activate", G_CALLBACK(activate), NULL); status = g_application_run(G_APPLICATION(app), 0, NULL); g_object_unref(app); return status; }</span></span></span></span></code> </pre> <br>  Program membuat aplikasi, tergantung pada acara aktifkan panggilan balik, meluncurkan aplikasi.  Dalam panggilan balik, buat jendela, tetapkan ukuran judul untuk itu dan perlihatkan. <br><br>  Dan sekarang, hal yang sama ditulis ulang dalam PHP: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" … // #include &lt;gtk/gtk.h&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $ffi; $window = $ffi-&gt;gtk_application_window_new($app); $ffi-&gt;gtk_window_set_title($window, <span class="hljs-string"><span class="hljs-string">"Hello from PHP"</span></span>); $ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); $ffi-&gt;gtk_widget_show_all($window); } $app = $ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); $ffi-&gt;g_object_unref($app);</code> </pre> <br>  Di sini, objek FFI dibuat terlebih dahulu.  Deskripsi antarmuka dikirim kepadanya sebagai input - intinya, file-h - dan perpustakaan yang ingin Anda unduh.  Setelah itu, semua fungsi yang dijelaskan dalam antarmuka menjadi tersedia sebagai metode objek ffi, dan semua parameter yang ditransfer secara otomatis dan benar-benar transparan diterjemahkan ke dalam representasi mesin yang diperlukan. <br><br>  Dapat dilihat bahwa semuanya persis sama seperti pada contoh sebelumnya.  Satu-satunya perbedaan adalah bahwa dalam C kami mengirim panggilan balik sebagai alamat, dan dalam PHP, koneksi terjadi oleh nama yang diberikan oleh string. <br><br>  Sekarang mari kita lihat seperti apa antarmuka itu.  Di bagian pertama, kami menentukan tipe dan fungsi di C, dan di baris terakhir kami memuat pustaka bersama: <br><br><pre> <code class="cpp hljs">&lt;?php $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" typedef struct _GtkApplication GtkApplication; typedef struct _GtkWidget GtkWidget; typedef void (*GCallback)(void*,void*); int g_application_run (GtkApplication *app, int argc, char **argv); unsigned long * g_signal_connect_data (void *ptr, const char *signal, GCallback handler, void *data, GCallback *destroy, int flags); void g_object_unref (void *ptr); GtkApplication * gtk_application_new (const char *app_id, int flags); GtkWidget * gtk_application_window_new (GtkApplication *app); void gtk_window_set_title (GtkWidget *win, const char *title); void gtk_window_set_default_size (GtkWidget *win, int width, int height); void gtk_widget_show_all (GtkWidget *win); "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); ...</code> </pre> <br>  Dalam hal ini, definisi-C ini disalin dari file-h dari perpustakaan GTK, hampir tidak berubah. <br><br>  Agar tidak mengganggu C dan PHP dalam file yang sama, Anda dapat meletakkan seluruh kode-C ke dalam file yang terpisah, misalnya, dengan nama gtk-ffi.h dan menambahkan ke awal beberapa define'ov khusus yang menentukan nama antarmuka dan pustaka untuk memuat: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_SCOPE </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GTK"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_LIB </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"libgtk-3.so.0"</span></span></span></span></code> </pre> <br>  Jadi, kami memilih seluruh deskripsi antarmuka C dalam satu file.  Gtk-ffi.h ini hampir nyata, tetapi sayangnya, kami belum mengimplementasikan preprocessor C, yang berarti makro dan menyertakan tidak akan berfungsi. <br><br>  Sekarang mari kita muat antarmuka ini dalam PHP: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br>  Karena FFI adalah teknologi yang agak berbahaya, kami tidak ingin memberikannya kepada siapa pun.  Mari kita setidaknya menyembunyikan objek FFI, yaitu menjadikannya pribadi di dalam kelas.  Dan kita akan membuat objek FFI tidak menggunakan <code>FFI::cdef</code> , tetapi menggunakan <code>FFI::load</code> , yang hanya membaca file-h kita dari contoh sebelumnya. <br><br>  Sisa kode tidak banyak berubah, hanya sebagai pengendali acara kami mulai menggunakan fungsi yang tidak disebutkan namanya dan melewati judul menggunakan pengikatan leksikal.  Yaitu, kami menggunakan C dan kekuatan PHP, yang tidak tersedia dalam C. <br><br>  Perpustakaan yang dibuat dengan cara ini sudah bisa digunakan dalam aplikasi Anda.  Tapi itu bagus jika <strong>hanya</strong> bekerja <strong>pada baris perintah</strong> , dan jika Anda memasukkannya ke dalam server web, file gtk_ffi.h akan dibaca pada setiap permintaan, perpustakaan akan dibuat dan dimuat, mengikat akan dilakukan ... Dan semua pekerjaan berulang ini akan memuat server Anda. <br><br>  Untuk menghindari hal ini dan, pada kenyataannya, mengizinkan penulisan ekstensi PHP dalam PHP itu sendiri, kami memutuskan untuk melewati FFI dengan preloading. <br><br><h3>  FFI + preloading </h3><br>  Kode tidak banyak berubah, hanya sekarang kita memberikan h-file ke preloading, dan kita mengeksekusi <code>FFI::load</code> langsung pada saat preloading, dan bukan ketika kita membuat objek.  Yaitu, memuat perpustakaan, semua parsing dan binding dilakukan sekali (pada startup server), dan dengan bantuan <code>FFI::scope("GTK")</code> kami mendapatkan akses ke antarmuka yang dimuat sebelumnya dengan nama dalam skrip kami. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::scope(<span class="hljs-string"><span class="hljs-string">"GTK"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br>  Dalam perwujudan ini, FFI dapat digunakan dari server web.  Tentu saja, ini bukan untuk GUI, tetapi dengan cara ini Anda dapat menulis, misalnya, mengikat ke database. <br><br>  Ekstensi yang dibuat dengan cara ini dapat digunakan langsung dari baris perintah: <br><pre> <code class="xml hljs">$ php -d opcache.preload=gtk.php -r 'GTK::create_window(" !");'</code> </pre> <br>  Kelebihan lain dari perkawinan silang dan preloading FFI adalah kemampuan untuk melarang penggunaan FFI untuk semua skrip tingkat pengguna.  Anda dapat menentukan ffi.enable = preload, yang berarti bahwa kami mempercayai file yang dimuat sebelumnya, tetapi memanggil FFI dari skrip PHP biasa dilarang. <br><br><h3>  Bekerja dengan struktur data C </h3><br>  Fitur lain yang menarik dari FFI adalah dapat bekerja dengan struktur data asli.  Anda dapat kapan saja membuat di memori setiap struktur data yang dijelaskan dalam C. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $points = FFI::new(<span class="hljs-string"><span class="hljs-string">"struct {int x,y;} [100]"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($x = <span class="hljs-number"><span class="hljs-number">0</span></span>; $x &lt; count($points); $x++) { $points[$x]-&gt;x = $x; $points[$x]-&gt;y = $x * $x; } var_dump($points[<span class="hljs-number"><span class="hljs-number">25</span></span>]-&gt;y); <span class="hljs-comment"><span class="hljs-comment">// 625 var_dump(FFI::sizeof($points)); // 800  foreach ($points as &amp;$p) { $p-&gt;x += 10; } var_dump($points[25]-&gt;x); // 35</span></span></code> </pre> <br>    100  (  FFI::new != new FFI),     integer.       ,    C.             PHP,     .     count, /        foreach  .      800 ,      PHP      PHP'   ,       10 . <br><br>   FFI: <br><br><ul><li> <a href="https://github.com/dstogov/php-tensorflow"> </a>  PHP. </li><li> <a href="https://github.com/ircmaxell/libgccffi"></a>  PHP. </li></ul><br> Python/CFFI    :  (Cario, JpegTran),  (ffmpeg),  (LibreOfficeKit),   (SDL)    (TensorFlow). <br><br> <strong> ,   FFI    .</strong> <br><br>   -   PHP.    ,      ,      callback'        ,      .         FFI.  ,   .    FFI c JIT, ,   LuaJIT,    .      ,    ,     . <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($k=<span class="hljs-number"><span class="hljs-number">0</span></span>; $k&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; $k++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=$n<span class="hljs-number"><span class="hljs-number">-1</span></span>; $i&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i--) { $Y[$i] += $X[$i]; } }</code> </pre> <br>      FFI   . <br><div class="scrollable-table"><table><tbody><tr><td></td><td> Native Arrays </td><td> FFI Arrays </td></tr><tr><td> PyPy </td><td> 0,010 </td><td> 0,081 </td></tr><tr><td> Python </td><td> 0,212 </td><td> 0,343 </td></tr><tr><td> LuaJIt -joff </td><td> 0,037 </td><td> 0,412 </td></tr><tr><td> LuaJit -jon </td><td> 0,003 </td><td> 0,002 </td></tr><tr><td>  Php </td><td> 0,040 </td><td> 0,093 </td></tr><tr><td> PHP + JIT </td><td> 0,016 </td><td> 0,087 </td></tr></tbody></table></div><br> <em>  : Zeev Surasky (Zend), Andi Gutmans (ex-Zend, Amazon), Xinchen Hui (ex-Weibo, ex-Zend, Lianjia), Nikita Popov (JetBrains), Anatol Belsky (Microsoft), Anthony Ferrara (ex-Google, Lingo Live), Joe Watkins, Mohammad Reza Haghighat (Intel)   Intel, Andy Wingo (JS hacker, Igalia), Mike Pall ( LuaJIT).</em> <br><br>        ,       ,    <a href="https://www.youtube.com/watch%3Fv%3D7UOWus-5yxg%26amp%3Bfeature%3Dyoutu.be%26amp%3Bt%3D1804"></a> . <br><br><blockquote> <a href="https://phprussia.ru/moscow/2020">PHP Russia 2020</a> !     <a href="http://eepurl.com/VYVaf"></a>  <a href="https://t.me/PHPRussiaConfChannel">telegram-</a> ,    2019     <a href="https://www.youtube.com/channel/UCxLQ9eT6YHnc6dMLRFzEc7Q">youtube-</a>  ,       , — <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dpc2020"> </a>  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481092/">https://habr.com/ru/post/id481092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481074/index.html">Kalkulator python</a></li>
<li><a href="../id481078/index.html">Jumlah pemilih gagal: kami membawa AgentTesla ke air bersih. Bagian 3</a></li>
<li><a href="../id481082/index.html">Mohnatiki menangkap pasar untuk industri game! Peregrine Labs Mengumumkan Kolaborasi Dengan Epic Games</a></li>
<li><a href="../id481084/index.html">Python, pengantar database</a></li>
<li><a href="../id481086/index.html">Vivaldi 2.10 - Agen Penyamaran</a></li>
<li><a href="../id481094/index.html">Tentang headphone nirkabel JBL dengan tenaga surya dan apa yang salah dengannya</a></li>
<li><a href="../id481100/index.html">Sudut 9, apa yang baru?</a></li>
<li><a href="../id481102/index.html">Cross-platform .NET UI toolkit merilis AvaloniaUI 0.9</a></li>
<li><a href="../id481104/index.html">Memadukan OpenJDK dan NodeJS: Interaksi Lintas Bahasa dan Arsitektur Vertikal</a></li>
<li><a href="../id481106/index.html">Bagaimana LANIT menembak DIY-sitcom di kantornya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>