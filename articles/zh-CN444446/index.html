<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏯 🤶 🎢 从头开始制作现代Web应用程序 🍜 🧘🏽 😐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="因此，您决定创建一个新项目。 这个项目是一个Web应用程序。 创建基本原型需要多少时间？ 有多难？ 现代网站从一开始就应该做什么？ 

 在本文中，我们将尝试概述具有以下体系结构的简单Web应用程序的样板： 

  
 我们将介绍的内容： 



- 在docker-compose中设置开发环境。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从头开始制作现代Web应用程序</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444446/">因此，您决定创建一个新项目。 这个项目是一个Web应用程序。 创建基本原型需要多少时间？ 有多难？ 现代网站从一开始就应该做什么？ <br><br> 在本文中，我们将尝试概述具有以下体系结构的简单Web应用程序的样板： <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ul/ne/9v/ulne9vljujdrtxnf-qeqrrux7da.png"></a> </div><br> 我们将介绍的内容： <br><br><ul><li> 在docker-compose中设置开发环境。 </li><li>  Flask上的后端创建。 </li><li> 在Express上创建前端。 </li><li> 使用Webpack构建JS。 </li><li>  React，Redux和服务器端渲染。 </li><li> 具有RQ的任务队列。 </li></ul><a name="habracut"></a><br><h2> 引言 </h2><br> 当然，在开发之前，您首先需要确定我们在开发什么！ 作为本文的模型应用程序，我决定制作一个原始的Wiki引擎。 我们将在Markdown发行卡； 可以观看它们，并（在将来的某个时候）进行编辑。 我们将所有这些安排为具有服务器端呈现的一页应用程序（这对于索引我们未来的TB级内容绝对必要）。 <br><br> 让我们更详细地了解为此所需的组件： <br><br><ul><li>  <b>顾客</b> 让我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redux</a>包中创建一个单页应用程序（即使用AJAX进行页面转换），这在前端世界中很常见。 </li><li>  <b>前端</b> 。 让我们创建一个简单的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Express</a>服务器，该服务器将呈现我们的React应用程序（异步请求后端中的所有必要数据）并将其发布给用户。 </li><li>  <b>后端</b> 。 掌握业务逻辑，我们的后端将是一个小的Flask应用程序。 我们将数据（我们的卡）存储在流行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MongoDB</a>文档存储库中，并且对于任务队列以及将来可能的缓存，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redis</a> 。 </li><li>  <b>工作人员</b> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RQ</a>库将启动一个单独的容器来处理繁重的任务。 </li></ul><br><h2> 基础设施：git </h2><br> 可能我们不会谈论这件事，但是，当然，我们将在git存储库中进行开发。 <br><br><pre><code class="bash hljs">git init git remote add origin git@github.com:Saluev/habr-app-demo.git git commit --allow-empty -m <span class="hljs-string"><span class="hljs-string">"Initial commit"</span></span> git push</code> </pre> <br>  （在这里，您应该立即填写<code>.gitignore</code> 。） <br><br> 最终草案可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Github</a>上查看。 本文的每一节都对应一个提交（为实现这一目标，我大功告成！）。 <br><br><h2> 基础架构：docker-compose </h2><br> 让我们从设置环境开始。 有了我们拥有的大量组件，非常合乎逻辑的开发解决方案是使用docker-compose。 <br><br> 将<code>docker-compose.yml</code>文件添加到<code>docker-compose.yml</code>以下内容的存储库中： <br><br><pre> <code class="plaintext hljs">version: '3' services: mongo: image: "mongo:latest" redis: image: "redis:alpine" backend: build: context: . dockerfile: ./docker/backend/Dockerfile environment: - APP_ENV=dev depends_on: - mongo - redis ports: - "40001:40001" volumes: - .:/code frontend: build: context: . dockerfile: ./docker/frontend/Dockerfile environment: - APP_ENV=dev - APP_BACKEND_URL=backend:40001 - APP_FRONTEND_PORT=40002 depends_on: - backend ports: - "40002:40002" volumes: - ./frontend:/app/src worker: build: context: . dockerfile: ./docker/worker/Dockerfile environment: - APP_ENV=dev depends_on: - mongo - redis volumes: - .:/code</code> </pre><br> 让我们快速看一下这里发生的事情。 <br><br><ul><li> 将创建一个MongoDB容器和一个Redis容器。 </li><li> 创建了一个用于后端的容器（我们将在下面描述）。 将环境变量APP_ENV = dev传递给它（我们将查看它以了解要加载的Flask设置），并且其端口40001将在外部打开（通过它，我们的浏览器客户端将转到API）。 </li><li> 创建了我们前端的容器。 各种各样的环境变量也被扔进去，以后对我们有用，端口40002打开，这是Web应用程序的主要端口：在浏览器中，我们将转到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http：// localhost：40002</a> 。 </li><li> 我们工人的容器已创建。 他不需要外部端口，在MongoDB和Redis中仅需要访问。 </li></ul><br> 现在让我们创建dockerfile。 目前，Habré即将提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一系列</a>有关Docker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优秀</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">翻译</a> -您可以放心前往所有细节。 <br><br> 让我们从后端开始。 <br><br><pre> <code class="plaintext hljs"># docker/backend/Dockerfile FROM python:stretch COPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt ADD . /code WORKDIR /code CMD gunicorn -w 1 -b 0.0.0.0:40001 --worker-class gevent backend.server:app</code> </pre><br> 可以理解，我们遍历了gunicorn Flask应用程序，该应用程序隐藏在<code>backend.server</code>模块中的名称<code>app</code>下。 <br><br> 同样重要的<code>docker/backend/.dockerignore</code> ： <br><br><pre> <code class="plaintext hljs">.git .idea .logs .pytest_cache frontend tests venv *.pyc *.pyo</code> </pre><br>  worker通常与后端相似，只是我们通常会启动pit模块而不是gunicorn： <br><br><pre> <code class="plaintext hljs"># docker/worker/Dockerfile FROM python:stretch COPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt ADD . /code WORKDIR /code CMD python -m worker</code> </pre><br> 我们将在<code>worker/__main__.py</code>完成所有工作。 <br><br>  <code>.dockerignore</code>工作程序与<code>.dockerignore</code>后端完全相似。 <br><br> 最后，前端。 在Habré上有关于他的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">整篇文章</a> ，但根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对StackOverflow</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">广泛讨论</a>和本着“你们已经是2018年了，仍然没有正常解决方案吗？”精神的评论来判断。 那里的一切都不那么简单。 我选择了此版本的docker文件。 <br><br><pre> <code class="plaintext hljs"># docker/frontend/Dockerfile FROM node:carbon WORKDIR /app #  package.json  package-lock.json   npm install,   . COPY frontend/package*.json ./ RUN npm install #       , #     PATH. ENV PATH /app/node_modules/.bin:$PATH #      . ADD frontend /app/src WORKDIR /app/src RUN npm run build CMD npm run start</code> </pre><br> 优点： <br><br><ul><li> 一切都按预期进行了缓存（在底层-依赖关系，在顶层-应用程序的构建）； </li><li>  <code>docker-compose exec frontend npm install --save newDependency</code>可以正常工作，并且可以修改存储库中的<code>package.json</code> （很多人建议，如果使用COPY则不会这样）。 无论如何都不希望在容器外部运行<code>npm install --save newDependency</code> ，因为新软件包的某些依赖项可能已经存在并在另一个平台下构建（例如，在<code>npm install --save newDependency</code>内部的一个平台下，而不是在我们工作的macbook之下） ），但我们通常不希望开发计算机上存在Node。 一个Docker来统治他们！ </li></ul><br> 好吧，当然还有<code>docker/frontend/.dockerignore</code> ： <br><br><pre> <code class="plaintext hljs">.git .idea .logs .pytest_cache backend worker tools node_modules npm-debug tests venv</code> </pre><br> 因此，我们的容器框架已准备就绪，您可以将其装满内容！ <br><br><h2> 后端：Flask框架 </h2><br> 将<code>flask</code> ， <code>flask-cors</code> ， <code>gevent</code>和<code>gunicorn</code>到<code>requirements.txt</code>并在<code>backend/server.py</code>创建一个简单的Flask应用程序。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/server.py import os.path import flask import flask_cors class HabrAppDemo(flask.Flask): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # CORS        #    ,      # (  Access-Control-Origin  ). #   - . flask_cors.CORS(self) app = HabrAppDemo("habr-app-demo") env = os.environ.get("APP_ENV", "dev") print(f"Starting application in {env} mode") app.config.from_object(f"backend.{env}_settings")</span></span></code> </pre><br> 我们告诉Flask从<code>backend.{env}_settings</code>文件<code>backend.{env}_settings</code>拉出设置，这意味着我们还需要创建一个（至少为空）文件<code>backend/dev_settings.py</code> ，以使一切腾飞。 <br><br> 现在我们可以正式提升后端了！ <br><br><pre> <code class="plaintext hljs">habr-app-demo$ docker-compose up backend ... backend_1 | [2019-02-23 10:09:03 +0000] [6] [INFO] Starting gunicorn 19.9.0 backend_1 | [2019-02-23 10:09:03 +0000] [6] [INFO] Listening at: http://0.0.0.0:40001 (6) backend_1 | [2019-02-23 10:09:03 +0000] [6] [INFO] Using worker: gevent backend_1 | [2019-02-23 10:09:03 +0000] [9] [INFO] Booting worker with pid: 9</code> </pre><br> 我们继续前进。 <br><br><h2> 前端：Express框架 </h2><br> 让我们从创建一个包开始。 创建了前端文件夹并在其中运行<code>npm init</code>之后，经过一些简单的问题，我们最终得到了完整的package.json <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"habr-app-demo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"This is an app demo for Habr article."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"repository"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"git"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"git+https://github.com/Saluev/habr-app-demo.git"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tigran Saluev &lt;tigran@saluev.com&gt;"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"MIT"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bugs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://github.com/Saluev/habr-app-demo/issues"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"homepage"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://github.com/Saluev/habr-app-demo#readme"</span></span> }</code> </pre><br> 将来，我们在开发人员的机器上根本不需要Node.js（尽管我们仍然可以通过Docker闪避并启动<code>npm init</code> ，但是很好）。 <br><br> 在<code>Dockerfile</code>我们提到了<code>npm run build</code>和<code>npm run start</code> <code>Dockerfile</code>您需要将适当的命令添加到<code>package.json</code> ： <br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/frontend/package.json +++ b/frontend/package.json @@ -4,6 +4,8 @@ "description": "This is an app demo for Habr article.", "main": "index.js", "scripts": { + "build": "echo 'build'", + "start": "node index.js", "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" }, "repository": {</span></span></code> </pre><br>  <code>build</code>命令什么也没做，但是对我们仍然有用。 <br><br> 添加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Express</a>依赖项并在<code>index.js</code>创建一个简单的应用程序： <br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/frontend/package.json +++ b/frontend/package.json @@ -17,5 +17,8 @@ "bugs": { "url": "https://github.com/Saluev/habr-app-demo/issues" }, - "homepage": "https://github.com/Saluev/habr-app-demo#readme" + "homepage": "https://github.com/Saluev/habr-app-demo#readme", + "dependencies": { + "express": "^4.16.3" + } }</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js const express = require("express"); app = express(); app.listen(process.env.APP_FRONTEND_PORT); app.get("*", (req, res) =&gt; { res.send("Hello, world!") });</span></span></code> </pre><br> 现在， <code>docker-compose up frontend</code>提升了我们的前端！ 此外，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http：// localhost：40002上</a> ，经典的“ Hello，world”应该已经展示出来了。 <br><br><h2> 前端：使用webpack和React应用程序构建 </h2><br> 现在是时候在我们的应用程序中描绘比纯文本更多的东西了。 在本节中，我们将添加<code>App</code>的最简单的React组件并配置程序集。 <br><br> 在React中进行编程时，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JSX</a>非常方便， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JSX</a>是一种JavaScript的方言，通过形式的语法构造得到扩展 <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyButton</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"blue"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{this.props.caption}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyButton</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; }</code> </pre><br> 但是，JavaScript引擎不了解它，因此通常将构建阶段添加到前端。 特殊的JavaScript编译器（yeah-yeah）将语法糖转换为<s>丑陋的</s>经典JavaScript，处理导入，缩小等操作。 <br><br><img src="https://habrastorage.org/webt/f1/rl/0j/f1rl0jer0cxs_ll69yagvwm_0gc.jpeg"><br><br>  <i>2014年。</i>  <i>apt-cache搜索Java</i> <br><br> 因此，最简单的React组件看起来非常简单。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/app.js import React, {Component} from 'react' class App extends Component { render() { return &lt;h1&gt;Hello, world!&lt;/h1&gt; } } export default App</span></span></code> </pre><br> 他只会用更具说服力的图钉向我们表示问候。 <br><br> 添加文件<code>frontend/src/template.js</code>其中包含我们未来应用程序的最小HTML框架： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/template.js export default function template(title) { let page = ` &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;${title}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="/dist/client.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; return page; }</span></span></code> </pre><br> 添加客户端入口点： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {render} from 'react-dom' import App from './components/app' render( &lt;App/&gt;, document.querySelector('#app') );</span></span></code> </pre><br> 要打造所有这些美丽，我们需要： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">webpack</a>是JS的时尚青年<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构建器</a> （尽管我三个小时都没有在前端阅读文章，所以我不确定时尚）； <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">babel</a>是适用于各种乳液（如JSX）的编译器，同时是适用于所有IE外壳的polyfill提供程序。 <br><br> 如果前端的上一个迭代仍在运行，那么您要做的就是 <br><br><pre> <code class="bash hljs">docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> frontend npm install --save \ react \ react-dom docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> frontend npm install --save-dev \ webpack \ webpack-cli \ babel-loader \ @babel/core \ @babel/polyfill \ @babel/preset-env \ @babel/preset-react</code> </pre><br> 安装新的依赖项。 现在配置webpack： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/webpack.config.js const path = require("path"); //  . clientConfig = { mode: "development", entry: { client: ["./src/client.js", "@babel/polyfill"] }, output: { path: path.resolve(__dirname, "../dist"), filename: "[name].js" }, module: { rules: [ { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" } ] } }; //  .     : // 1. target: "node" -      import path. // 2.   ..,    ../dist --   //    ,   ! serverConfig = { mode: "development", target: "node", entry: { server: ["./index.js", "@babel/polyfill"] }, output: { path: path.resolve(__dirname, ".."), filename: "[name].js" }, module: { rules: [ { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" } ] } }; module.exports = [clientConfig, serverConfig];</span></span></code> </pre><br> 要使babel正常工作，您需要配置<code>frontend/.babelrc</code> ： <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"presets"</span></span>: [<span class="hljs-string"><span class="hljs-string">"@babel/env"</span></span>, <span class="hljs-string"><span class="hljs-string">"@babel/react"</span></span>] }</code> </pre><br> 最后，使我们的<code>npm run build</code>命令有意义： <br><br><pre> <code class="json hljs">// frontend/package.json ... <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: <span class="hljs-string"><span class="hljs-string">"webpack"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node /app/server.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, ...</code> </pre><br> 现在，我们的客户端以及<code>../dist/client.js</code>及其所有依赖项，通过babel运行，编译并折叠成一个整体的缩小文件<code>../dist/client.js</code> 。 添加将其作为静态文件上传到我们的Express应用程序的功能，并且在默认路由中，我们将开始返回HTML： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js // ,    , //  - . import express from 'express' import template from './src/template' let app = express(); app.use('/dist', express.static('../dist')); app.get("*", (req, res) =&gt; { res.send(template("Habr demo app")); }); app.listen(process.env.APP_FRONTEND_PORT);</span></span></code> </pre><br> 成功！ 现在，如果我们运行<code>docker-compose up --build frontend</code> ，我们将看到“ Hello，world！” 在一个新的闪亮包装中，如果您安装了React开发人员工具扩展（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Chrome</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Firefox</a> ），那么开发人员工具中还会有一个React组件树： <br><br><img src="https://habrastorage.org/webt/q1/it/gu/q1itgukw2k0ko60pghlwwkfqfn0.png"><br><br><h2> 后端：MongoDB中的数据 </h2><br> 在继续前进并为我们的应用程序注入生命之前，您必须首先将其呼吸到后端。 似乎我们要存储在Markdown中标记的卡片-是时候这样做了。 <br><br> 尽管<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">python中有用于MongoDB的ORM</a> ，但我认为对ORM的使用是恶意的，因此我将适当的解决方案的研究交给您。 相反，我们将为卡片和随附的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DAO</a>做一个简单的类： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/storage/card.py import abc from typing import Iterable class Card(object): def __init__(self, id: str = None, slug: str = None, name: str = None, markdown: str = None, html: str = None): self.id = id self.slug = slug #    self.name = name self.markdown = markdown self.html = html class CardDAO(object, metaclass=abc.ABCMeta): @abc.abstractmethod def create(self, card: Card) -&gt; Card: pass @abc.abstractmethod def update(self, card: Card) -&gt; Card: pass @abc.abstractmethod def get_all(self) -&gt; Iterable[Card]: pass @abc.abstractmethod def get_by_id(self, card_id: str) -&gt; Card: pass @abc.abstractmethod def get_by_slug(self, slug: str) -&gt; Card: pass class CardNotFound(Exception): pass</span></span></code> </pre><br>  （如果您仍未在Python中使用类型注释，请务必查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这些</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> ！） <br><br> 现在，让我们创建<code>CardDAO</code>接口的实现，该实现将<code>CardDAO</code>中的<code>Database</code>对象<code>pymongo</code> （是的，是将<code>pymongo</code>添加到<code>requirements.txt</code> ）： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/storage/card_impl.py from typing import Iterable import bson import bson.errors from pymongo.collection import Collection from pymongo.database import Database from backend.storage.card import Card, CardDAO, CardNotFound class MongoCardDAO(CardDAO): def __init__(self, mongo_database: Database): self.mongo_database = mongo_database # , slug   . self.collection.create_index("slug", unique=True) @property def collection(self) -&gt; Collection: return self.mongo_database["cards"] @classmethod def to_bson(cls, card: Card): # MongoDB     BSON.  #       BSON- #  ,      . result = { k: v for k, v in card.__dict__.items() if v is not None } if "id" in result: result["_id"] = bson.ObjectId(result.pop("id")) return result @classmethod def from_bson(cls, document) -&gt; Card: #   ,     #     ,     #  .    id    # ,   -   . document["id"] = str(document.pop("_id")) return Card(**document) def create(self, card: Card) -&gt; Card: card.id = str(self.collection.insert_one(self.to_bson(card)).inserted_id) return card def update(self, card: Card) -&gt; Card: card_id = bson.ObjectId(card.id) self.collection.update_one({"_id": card_id}, {"$set": self.to_bson(card)}) return card def get_all(self) -&gt; Iterable[Card]: for document in self.collection.find(): yield self.from_bson(document) def get_by_id(self, card_id: str) -&gt; Card: return self._get_by_query({"_id": bson.ObjectId(card_id)}) def get_by_slug(self, slug: str) -&gt; Card: return self._get_by_query({"slug": slug}) def _get_by_query(self, query) -&gt; Card: document = self.collection.find_one(query) if document is None: raise CardNotFound() return self.from_bson(document)</span></span></code> </pre><br> 是时候在后端设置中注册Monga配置了。 我们只是用mongo <code>mongo</code>命名了我们的容器，所以<code>MONGO_HOST = "mongo"</code> ： <br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/backend/dev_settings.py +++ b/backend/dev_settings.py @@ -0,0 +1,3 @@ +MONGO_HOST = "mongo" +MONGO_PORT = 27017 +MONGO_DATABASE = "core"</span></span></code> </pre><br> 现在我们需要创建<code>MongoCardDAO</code>并为Flask应用程序提供访问权限。 尽管现在我们有了一个非常简单的对象层次结构（设置→pymongo客户端→pymongo数据库→ <code>MongoCardDAO</code> ），但让我们立即创建一个进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">依赖项注入</a>的集中式King组件（当我们处理worker和工具时，它将再次派上用场）。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/wiring.py import os from pymongo import MongoClient from pymongo.database import Database import backend.dev_settings from backend.storage.card import CardDAO from backend.storage.card_impl import MongoCardDAO class Wiring(object): def __init__(self, env=None): if env is None: env = os.environ.get("APP_ENV", "dev") self.settings = { "dev": backend.dev_settings, # (    # ,   !) }[env] #        . #        DI,  . self.mongo_client: MongoClient = MongoClient( host=self.settings.MONGO_HOST, port=self.settings.MONGO_PORT) self.mongo_database: Database = self.mongo_client[self.settings.MONGO_DATABASE] self.card_dao: CardDAO = MongoCardDAO(self.mongo_database)</span></span></code> </pre><br><br> 是时候为Flask应用程序添加新路线并欣赏美景了！ <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/server.py import os.path import flask import flask_cors from backend.storage.card import CardNotFound from backend.wiring import Wiring env = os.environ.get("APP_ENV", "dev") print(f"Starting application in {env} mode") class HabrAppDemo(flask.Flask): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) flask_cors.CORS(self) self.wiring = Wiring(env) self.route("/api/v1/card/&lt;card_id_or_slug&gt;")(self.card) def card(self, card_id_or_slug): try: card = self.wiring.card_dao.get_by_slug(card_id_or_slug) except CardNotFound: try: card = self.wiring.card_dao.get_by_id(card_id_or_slug) except (CardNotFound, ValueError): return flask.abort(404) return flask.jsonify({ k: v for k, v in card.__dict__.items() if v is not None }) app = HabrAppDemo("habr-app-demo") app.config.from_object(f"backend.{env}_settings")</span></span></code> </pre><br> 重新启动<code>docker-compose up --build backend</code> ： <br><br><img src="https://habrastorage.org/webt/ts/_a/1l/ts_a1ljldp9jztjvlupm4z6f29i.png"><br><br> 糟糕...哦，是的。 我们需要添加内容！ 我们将打开tools文件夹，并在其中添加一个脚本，以添加一个测试卡： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tools/add_test_content.py from backend.storage.card import Card from backend.wiring import Wiring wiring = Wiring() wiring.card_dao.create(Card( slug="helloworld", name="Hello, world!", markdown=""" This is a hello-world page. """))</span></span></code> </pre><br>  <code>docker-compose exec backend python -m tools.add_test_content</code>用<code>docker-compose exec backend python -m tools.add_test_content</code>容器内部的内容填充我们的<code>docker-compose exec backend python -m tools.add_test_content</code> 。 <br><br><img src="https://habrastorage.org/webt/em/n2/la/emn2laspljezpnoc66oeccj42l4.png"><br><br> 成功！ 现在是时候在前端提供支持了。 <br><br><h2> 前端：Redux </h2><br> 现在我们要制作route <code>/card/:id_or_slug</code> ，通过它我们的React应用程序将打开，从API加载card数据并以某种方式向我们展示。 在这里，也许是最困难的部分开始了，因为我们希望服务器立即为我们提供包含卡片内容的HTML，适合索引，但是与此同时，当应用程序在卡片之间导航时，它会从API接收JSON形式的所有数据，并且页面不会过载。 这样，所有这些-无需复制粘贴！ <br><br> 让我们从添加Redux开始。  Redux是一个用于存储状态的JavaScript库。 这个想法是，您的组件具有一个集中的状态，而不是通过在用户操作和其他有趣事件期间发生变化的上千个隐式状态，并通过集中的操作机制进行任何更改。 因此，如果较早进行导航，我们首先打开了加载的GIF，然后通过AJAX发出了请求，最后在成功回调中，我们更新了页面的必要部分，然后在Redux范式中，我们被邀请发送动作“将内容更改为带有动画的gif”。将更改全局状态，以便您的一个组件将丢弃先前的内容并放入动画，然后发出请求，并在其成功回调中发送另一个操作，“将内容更改为已加载”。 总的来说，现在我们将自己看到它。 <br><br> 让我们从在容器中安装新的依赖关系开始。 <br><br><pre> <code class="bash hljs">docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> frontend npm install --save \ redux \ react-redux \ redux-thunk \ redux-devtools-extension</code> </pre><br> 实际上，第一个是Redux，第二个是用于跨React和Redux的特殊库（由交配专家编写），第三个是非常必要的，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">README中</a>有充分的理由，最后，第四个是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redux DevTools</a>工作所需的库<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">扩展名</a> 。 <br><br> 让我们从样板Redux代码开始：创建一个不执行任何操作的reducer并初始化状态。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js export default function root(state = {}, action) { return state; }</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/configureStore.js import {createStore, applyMiddleware} from "redux"; import thunkMiddleware from "redux-thunk"; import {composeWithDevTools} from "redux-devtools-extension"; import rootReducer from "./reducers"; export default function configureStore(initialState) { return createStore( rootReducer, initialState, composeWithDevTools(applyMiddleware(thunkMiddleware)), ); }</span></span></code> </pre><br> 我们的客户有所改变，在心理上准备与Redux合作： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {render} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' //      ... const store = configureStore(); render( // ...      , //     &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt;, document.querySelector('#app') );</span></span></code> </pre><br> 现在我们可以运行docker-compose up --build frontend来确保没有任何损坏，并且我们的原始状态已经出现在Redux DevTools中： <br><br><img src="https://habrastorage.org/webt/x0/hr/_e/x0hr_empfso4poji4s8egshlcye.png"><br><br><h2> 前端：卡页 </h2><br> 在制作带有SSR的页面之前，您需要制作没有SSR的页面！ 最后，让我们使用我们独创的API来访问卡并在前端组成卡页面。 <br><br> 是时候利用情报并重新设计我们的状态结构了。 关于此主题<a href="">的</a>材料<a href="">很多</a> ，因此我建议不要滥用智力，而将重点放在简单性上。 例如： <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"page"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"card"</span></span>, //     //       type=card: <span class="hljs-string"><span class="hljs-string">"cardSlug"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, //     <span class="hljs-attr"><span class="hljs-attr">"isFetching"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, //      API <span class="hljs-attr"><span class="hljs-attr">"cardData"</span></span>: {...}, //   (  ) // ... }, // ... }</code> </pre><br> 让我们获得“卡片”组件，该组件将cardData的内容作为道具（实际上是mongo中我们卡片的内容）： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/card.js import React, {Component} from 'react'; class Card extends Component { componentDidMount() { document.title = this.props.name } render() { const {name, html} = this.props; return ( &lt;div&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;!---,  HTML  React  - !--&gt; &lt;div dangerouslySetInnerHTML={{__html: html}}/&gt; &lt;/div&gt; ); } } export default Card;</span></span></code> </pre><br> 现在，让我们使用卡片获取整个页面的组件。 他将负责从API中获取必要的数据并将其传输到Card。 我们将以React-Redux方式进行数据获取。 <br><br> 首先，创建文件<code>frontend/src/redux/actions.js</code>并创建一个从API中提取卡中内容的操作（如果尚未创建的话）： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchCardIfNeeded</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = getState().page; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state.cardData === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> || state.cardData.slug !== state.cardSlug) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch(fetchCard()); } }; }</code> </pre><br>  <code>fetchCard</code>操作实际上使获取工作稍微复杂一些： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,    . //     , , //    . dispatch(startFetchingCard()); //    API. let url = apiPath() + "/card/" + getState().page.cardSlug; // , ,   ,  //    . , ,  //    . return fetch(url) .then(response =&gt; response.json()) .then(json =&gt; dispatch(finishFetchingCard(json))); }; // ,  redux-thunk   //     . } function startFetchingCard() { return { type: START_FETCHING_CARD }; } function finishFetchingCard(json) { return { type: FINISH_FETCHING_CARD, cardData: json }; } function apiPath() { //    .    server-side // rendering,   API     -  //         localhost, //   backend. return "http://localhost:40001/api/v1"; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哦，我们采取了某种措施！</font><font style="vertical-align: inherit;">在reducer中必须支持：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js import { START_FETCHING_CARD, FINISH_FETCHING_CARD } from "./actions"; export default function root(state = {}, action) { switch (action.type) { case START_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: true } }; case FINISH_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: false, cardData: action.cardData } } } return state; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（请注意用于通过更改单个字段来克隆对象的流行语法。）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既然所有逻辑都是在Redux操作中执行的，则组件本身</font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将看起来相对简单：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/cardPage.js import React, {Component} from 'react'; import {connect} from 'react-redux' import {fetchCardIfNeeded} from '../redux/actions' import Card from './card' class CardPage extends Component { componentWillMount() { //   ,  React  //   .      //   ,    " // "   ,    //  - .    -   //       HTML  // renderToString,      SSR. this.props.dispatch(fetchCardIfNeeded()) } render() { const {isFetching, cardData} = this.props; return ( &lt;div&gt; {isFetching &amp;&amp; &lt;h2&gt;Loading...&lt;/h2&gt;} {cardData &amp;&amp; &lt;Card {...cardData}/&gt;} &lt;/div&gt; ); } } //       ,   //  .        //  react-redux.   page    //  dispatch,   . function mapStateToProps(state) { const {page} = state; return page; } export default connect(mapStateToProps)(CardPage);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在我们的根App组件中添加一个简单的page.type处理： </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/app.js import React, {Component} from 'react' import {connect} from "react-redux"; import CardPage from "./cardPage" class App extends Component { render() { const {pageType} = this.props; return ( &lt;div&gt; {pageType === "card" &amp;&amp; &lt;CardPage/&gt;} &lt;/div&gt; ); } } function mapStateToProps(state) { const {page} = state; const {type} = page; return { pageType: type }; } export default connect(mapStateToProps)(App);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，最后一刻仍然存在-您需要以某种方式进行初始化</font></font><code>page.type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>page.cardSlug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具体取决于页面的URL。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是本文仍然有很多部分，但是我们现在无法提供高质量的解决方案。</font><font style="vertical-align: inherit;">让我们暂时做它。</font><font style="vertical-align: inherit;">那完全是愚蠢的。</font><font style="vertical-align: inherit;">例如，初始化应用程序时的常规！</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {render} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' let initialState = { page: { type: "home" } }; const m = /^\/card\/([^\/]+)$/.exec(location.pathname); if (m !== null) { initialState = { page: { type: "card", cardSlug: m[1] }, } } const store = configureStore(initialState); render( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt;, document.querySelector('#app') );</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以在帮助下重建前端，</font></font><code>docker-compose up --build frontend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以享用我们的卡了</font></font><code>helloworld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">…… </font></font><br><br><img src="https://habrastorage.org/webt/vj/qi/iu/vjqiiu9iu3c0ieigltqbu35smfw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等等，等等……我们的内容在哪里？</font><font style="vertical-align: inherit;">哦，我们忘了解析Markdown！</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 工人：RQ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解析Markdown并为可能无限制大小的卡生成HTML是一项典型的“繁重”任务，该任务通常在单独的工作机上排队并执行，而不是在保存更改时直接在后端解决。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务队列有许多开源实现。</font><font style="vertical-align: inherit;">我们将使用Redis和一个简单的库</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RQ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Redis Queue），该</font><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pickle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格式传输任务参数，</font><font style="vertical-align: inherit;">并组织我们的产卵过程进行处理。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是时候添加萝卜了，具体取决于设置和接线！</font></font><br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/requirements.txt +++ b/requirements.txt @@ -3,3 +3,5 @@ flask-cors gevent gunicorn pymongo +redis +rq --- a/backend/dev_settings.py +++ b/backend/dev_settings.py @@ -1,3 +1,7 @@ MONGO_HOST = "mongo" MONGO_PORT = 27017 MONGO_DATABASE = "core" +REDIS_HOST = "redis" +REDIS_PORT = 6379 +REDIS_DB = 0 +TASK_QUEUE_NAME = "tasks" --- a/backend/wiring.py +++ b/backend/wiring.py @@ -2,6 +2,8 @@ import os from pymongo import MongoClient from pymongo.database import Database +import redis +import rq import backend.dev_settings from backend.storage.card import CardDAO @@ -21,3 +23,11 @@ class Wiring(object): port=self.settings.MONGO_PORT) self.mongo_database: Database = self.mongo_client[self.settings.MONGO_DATABASE] self.card_dao: CardDAO = MongoCardDAO(self.mongo_database) + + self.redis: redis.Redis = redis.StrictRedis( + host=self.settings.REDIS_HOST, + port=self.settings.REDIS_PORT, + db=self.settings.REDIS_DB) + self.task_queue: rq.Queue = rq.Queue( + name=self.settings.TASK_QUEUE_NAME, + connection=self.redis)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 工人的样板代码。 </font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># worker/__main__.py import argparse import uuid import rq import backend.wiring parser = argparse.ArgumentParser(description="Run worker.") #   ,      #  .  ,       rq. parser.add_argument( "--burst", action="store_const", const=True, default=False, help="enable burst mode") args = parser.parse_args() #       Redis. wiring = backend.wiring.Wiring() with rq.Connection(wiring.redis): w = rq.Worker( queues=[wiring.settings.TASK_QUEUE_NAME], #         # ,    . name=uuid.uuid4().hex) w.work(burst=args.burst)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于解析本身，连接</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">失调</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">并编写一个简单的函数：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/tasks/parse.py import mistune from backend.storage.card import CardDAO def parse_card_markup(card_dao: CardDAO, card_id: str): card = card_dao.get_by_id(card_id) card.html = _parse_markdown(card.markdown) card_dao.update(card) _parse_markdown = mistune.Markdown(escape=True, hard_wrap=False)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑上：我们需要</font></font><code>CardDAO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获取卡的源代码并保存结果。</font><font style="vertical-align: inherit;">但是包含与外部存储器的连接的对象无法通过pickle进行序列化-这意味着该任务无法立即执行并排队等待RQ。</font><font style="vertical-align: inherit;">以一种好的方式，我们需要</font></font><code>Wiring</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在侧面</font><font style="vertical-align: inherit;">创建</font><font style="vertical-align: inherit;">一个工作器，并将其扔给各种各样……让我们这样做：</font></font><br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/worker/__main__.py +++ b/worker/__main__.py @@ -2,6 +2,7 @@ import argparse import uuid import rq +from rq.job import Job import backend.wiring @@ -16,8 +17,23 @@ args = parser.parse_args() wiring = backend.wiring.Wiring() + +class JobWithWiring(Job): + + @property + def kwargs(self): + result = dict(super().kwargs) + result["wiring"] = backend.wiring.Wiring() + return result + + @kwargs.setter + def kwargs(self, value): + super().kwargs = value + + with rq.Connection(wiring.redis): w = rq.Worker( queues=[wiring.settings.TASK_QUEUE_NAME], - name=uuid.uuid4().hex) + name=uuid.uuid4().hex, + job_class=JobWithWiring) w.work(burst=args.burst)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们宣布了我们的工作类别，将布线作为所有问题中的一个额外争论。</font><font style="vertical-align: inherit;">（请注意，它每次都会创建一个新的连线，因为某些任务无法在任务开始处理之前在RQ内发生的派生之前创建。）因此，我们所有的任务都不依赖于连线-即依赖于所有对象-让我们让我们做一个装饰器，它只能从布线中获得必要的东西：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/tasks/task.py import functools from typing import Callable from backend.wiring import Wiring def task(func: Callable): #    : varnames = func.__code__.co_varnames @functools.wraps(func) def result(*args, **kwargs): #  .  .pop(),     # ,        . wiring: Wiring = kwargs.pop("wiring") wired_objects_by_name = wiring.__dict__ for arg_name in varnames: if arg_name in wired_objects_by_name: kwargs[arg_name] = wired_objects_by_name[arg_name] #          #   ,  -   . return func(*args, **kwargs) return result</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为我们的任务添加装饰器，享受生活： </font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mistune <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> backend.storage.card <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CardDAO <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> backend.tasks.task <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> task @task <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_card_markup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(card_dao: CardDAO, card_id: str)</span></span></span><span class="hljs-function">:</span></span> card = card_dao.get_by_id(card_id) card.html = _parse_markdown(card.markdown) card_dao.update(card) _parse_markdown = mistune.Markdown(escape=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hard_wrap=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">享受生活？</font><font style="vertical-align: inherit;">gh，我想说，我们开始工作了：</font></font><br><br><pre> <code class="plaintext hljs">$ docker-compose up worker ... Creating habr-app-demo_worker_1 ... done Attaching to habr-app-demo_worker_1 worker_1 | 17:21:03 RQ worker 'rq:worker:49a25686acc34cdfa322feb88a780f00' started, version 0.13.0 worker_1 | 17:21:03 *** Listening on tasks... worker_1 | 17:21:03 Cleaning registries for queue: tasks</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">III……他什么都不做！</font><font style="vertical-align: inherit;">当然，因为我们没有设定单个任务！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们重写一下创建测试卡的工具，以便它：a）如果已经创建了测试卡，它就不会掉下来（在我们的例子中）；</font><font style="vertical-align: inherit;">b）将任务放在marqdown的解析中。</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tools/add_test_content.py from backend.storage.card import Card, CardNotFound from backend.tasks.parse import parse_card_markup from backend.wiring import Wiring wiring = Wiring() try: card = wiring.card_dao.get_by_slug("helloworld") except CardNotFound: card = wiring.card_dao.create(Card( slug="helloworld", name="Hello, world!", markdown=""" This is a hello-world page. """)) # ,   card_dao.get_or_create,  #      ! wiring.task_queue.enqueue_call( parse_card_markup, kwargs={"card_id": card.id})</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，不仅可以在后端运行工具，还可以在工作线程上运行工具。</font><font style="vertical-align: inherit;">原则上，现在我们不在乎。</font><font style="vertical-align: inherit;">我们启动它，</font></font><code>docker-compose exec worker python -m tools.add_test_content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并在终端的相邻选项卡中看到一个奇迹-工人做了些什么！</font></font><br><br><pre> <code class="plaintext hljs">worker_1 | 17:34:26 tasks: backend.tasks.parse.parse_card_markup(card_id='5c715dd1e201ce000c6a89fa') (613b53b1-726b-47a4-9c7b-97cad26da1a5) worker_1 | 17:34:27 tasks: Job OK (613b53b1-726b-47a4-9c7b-97cad26da1a5) worker_1 | 17:34:27 Result is kept for 500 seconds</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用后端重建容器之后，我们终于可以在浏览器中看到卡的内容： </font></font><br><br><img src="https://habrastorage.org/webt/ii/5f/zb/ii5fzb_nh2p4-hbv7obhjmxr5kk.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 前端导航 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在继续进行SSR之前，我们需要使我们所有的React事情变得有意义，并使我们的单页面应用程序真正成为一个页面。</font><font style="vertical-align: inherit;">让我们更新我们的工具，以创建两个彼此链接的卡（“非一个，两个！妈妈，我现在大日期！”），然后我们将处理它们之间的导航。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐藏文字</font></font></b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tools/add_test_content.py def create_or_update(card): try: card.id = wiring.card_dao.get_by_slug(card.slug).id card = wiring.card_dao.update(card) except CardNotFound: card = wiring.card_dao.create(card) wiring.task_queue.enqueue_call( parse_card_markup, kwargs={"card_id": card.id}) create_or_update(Card( slug="helloworld", name="Hello, world!", markdown=""" This is a hello-world page. It can't really compete with the [demo page](demo). """)) create_or_update(Card( slug="demo", name="Demo Card!", markdown=""" Hi there, habrovchanin. You've probably got here from the awkward ["Hello, world" card](helloworld). Well, **good news**! Finally you are looking at a **really cool card**! """ ))</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以单击链接并考虑每次精美的应用程序如何重新启动。</font><font style="vertical-align: inherit;">别说了 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，让您的处理程序单击链接。</font><font style="vertical-align: inherit;">因为带有链接的HTML来自后端，并且我们在React上有应用程序，所以我们需要一些特定于React的焦点。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/card.js class Card extends Component { componentDidMount() { document.title = this.props.name } navigate(event) { //       .  //      ,    . if (event.target.tagName === 'A' &amp;&amp; event.target.hostname === window.location.hostname) { //     event.preventDefault(); //      this.props.dispatch(navigate(event.target)); } } render() { const {name, html} = this.props; return ( &lt;div&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;div dangerouslySetInnerHTML={{__html: html}} onClick={event =&gt; this.navigate(event)} /&gt; &lt;/div&gt; ); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于所有将逻辑卡加载到组件中的逻辑</font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在操作本身（惊人！）中，无需采取任何操作：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">link</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: NAVIGATE, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: link.pathname } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在这种情况下，添加一个愚蠢的减速器： </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js import { START_FETCHING_CARD, FINISH_FETCHING_CARD, NAVIGATE } from "./actions"; function navigate(state, path) { //     react-router,    ! // (       SSR.) let m = /^\/card\/([^/]+)$/.exec(path); if (m !== null) { return { ...state, page: { type: "card", cardSlug: m[1], isFetching: true } }; } return state } export default function root(state = {}, action) { switch (action.type) { case START_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: true } }; case FINISH_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: false, cardData: action.cardData } }; case NAVIGATE: return navigate(state, action.path) } return state; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于现在我们的应用程序状态可以更改，因此</font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要添加</font></font><code>componentDidUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与已经</font><font style="vertical-align: inherit;">添加的方法</font><font style="vertical-align: inherit;">相同</font><font style="vertical-align: inherit;">的方法</font></font><code>componentWillMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，在更新属性</font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（例如，</font></font><code>cardSlug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">导航期间的</font><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">）之后，还将请求来自后端的卡的内容（</font></font><code>componentWillMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅在初始化组件时才</font><font style="vertical-align: inherit;">这样</font><font style="vertical-align: inherit;">做）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好的，</font></font><code>docker-compose up --build frontend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的导航正常！</font></font><br><br><img src="https://habrastorage.org/webt/4l/ov/b_/4lovb_vai0fxv0tjx6zfcmwb8y8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">细心的读者会注意到，在卡片之间导航时，页面的URL不会更改-即使在屏幕截图中，我们也可以在演示卡地址上看到世界卡片Hello，即世界银行卡。</font><font style="vertical-align: inherit;">因此，前后导航也下降。</font><font style="vertical-align: inherit;">让我们立即添加一些带有历史的黑魔法来修复它！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以做的最简单的事情就是添加操作。</font></font><code>navigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挑战</font></font><code>history.pushState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">link</span></span></span><span class="hljs-function">) </span></span>{ history.pushState(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, link.href); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: NAVIGATE, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: link.pathname } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，单击链接时，浏览器地址栏中的URL将会真正改变。</font><font style="vertical-align: inherit;">但是，后退按钮</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会损坏</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使其正常工作，我们需要监听</font></font><code>popstate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">的事件</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此外，如果在这种情况下，我们想向后和向前（即通过</font></font><code>dispatch(navigate(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">进行导航</font><font style="vertical-align: inherit;">，则必须在该函数上</font></font><code>navigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加一个特殊的“请勿</font></font><code>pushState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">” </font><font style="vertical-align: inherit;">标志</font><font style="vertical-align: inherit;">（否则所有操作都会中断！）。</font><font style="vertical-align: inherit;">另外，为了区分“我们的”状态，我们应该使用</font></font><code>pushState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存元数据的功能。</font><font style="vertical-align: inherit;">有很多魔术和调试功能，所以让我们开始编写代码吧！</font><font style="vertical-align: inherit;">以下是该应用程序的外观：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/app.js class App extends Component { componentDidMount() { //     --   //      "". history.replaceState({ pathname: location.pathname, href: location.href }, ""); //     . window.addEventListener("popstate", event =&gt; this.navigate(event)); } navigate(event) { //    "" ,   //        ,    //   (or is it a good thing?..) if (event.state &amp;&amp; event.state.pathname) { event.preventDefault(); event.stopPropagation(); //      "  pushState". this.props.dispatch(navigate(event.state, true)); } } render() { // ... } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是导航动作： </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/actions.js export function navigate(link, dontPushState) { if (!dontPushState) { history.pushState({ pathname: link.pathname, href: link.href }, "", link.href); } return { type: NAVIGATE, path: link.pathname } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，故事将起作用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，最后一点：既然我们有了一个action </font></font><code>navigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，为什么我们不放弃客户端中用于计算初始状态的额外代码呢？</font><font style="vertical-align: inherit;">我们可以致电定位到当前位置：</font></font><br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/frontend/src/client.js +++ b/frontend/src/client.js @@ -3,23 +3,16 @@ import {render} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' +import {navigate} from "./redux/actions"; let initialState = { page: { type: "home" } }; -const m = /^\/card\/([^\/]+)$/.exec(location.pathname); -if (m !== null) { - initialState = { - page: { - type: "card", - cardSlug: m[1] - }, - } -} const store = configureStore(initialState); +store.dispatch(navigate(location));</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 复制粘贴已销毁！ </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 前端：服务器端渲染 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是时候使用我们的主要芯片了（我认为）-SEO友好。为了使搜索引擎可以索引我们的内容，该内容是在React组件中完全动态创建的，我们需要能够为它们提供呈现React的结果，还需要学习如何使该结果再次具有交互性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用方案很简单。首先：我们需要将React组件生成的HTML插入HTML模板中</font></font><code>App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。搜索引擎（以及禁用JS的浏览器，可以看到此HTML）。第二：在模板</font></font><code>&lt;script&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">添加一个标记，以将</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态转储</font><font style="vertical-align: inherit;">保存到某个位置（例如，object </font><font style="vertical-align: inherit;">），从该状态转储此HTML。然后，我们可以立即以这种状态在客户端初始化我们的应用程序，并显示需要什么（我们甚至可以应用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水合物</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到生成的HTML，以免重新创建应用程序的DOM树）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从编写一个返回渲染的HTML和最终状态的函数开始。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/server.js import "@babel/polyfill" import React from 'react' import {renderToString} from 'react-dom/server' import {Provider} from 'react-redux' import App from './components/app' import {navigate} from "./redux/actions"; import configureStore from "./redux/configureStore"; export default function render(initialState, url) { //  store,    . const store = configureStore(initialState); store.dispatch(navigate(url)); let app = ( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt; ); // ,        ! // ,         ? let content = renderToString(app); let preloadedState = store.getState(); return {content, preloadedState}; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在我们上面讨论过的模板中添加新的参数和逻辑： </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/template.js function template(title, initialState, content) { let page = ` &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;${title}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;${content}&lt;/div&gt; &lt;script&gt; window.__STATE__ = ${JSON.stringify(initialState)} &lt;/script&gt; &lt;script src="/dist/client.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; return page; } module.exports = template;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们的Express服务器变得更加复杂： </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js app.get("*", (req, res) =&gt; { const initialState = { page: { type: "home" } }; const {content, preloadedState} = render(initialState, {pathname: req.url}); res.send(template("Habr demo app", preloadedState, content)); });</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是客户端更容易： </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {hydrate} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' import {navigate} from "./redux/actions"; //         ! const store = configureStore(window.__STATE__); // render   hydrate. hydrate    // DOM tree,       . hydrate( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt;, document.querySelector('#app') );</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，您需要清除跨平台错误，例如“未定义历史记录”。</font><font style="vertical-align: inherit;">为此，请在中的某个位置添加一个简单的（到目前为止）函数</font></font><code>utility.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/utility.js export function isServerSide() { //   ,      process, //     -   . return process.env.APP_ENV !== undefined; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后会有一些常规更改，我不会在这里进行（但是可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相应的commit中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">结果，我们的React应用程序将能够在浏览器和服务器上进行渲染。</font></font><br><br> 有效！<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，正如他们所说，有一个警告...正在</font></font><br><br><img src="https://habrastorage.org/webt/gd/ac/ut/gdacut18knqjvzftjhkkuhnzxgk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加载？ Google在我超酷的时尚服务上看到的就是LOADING ？！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，似乎我们所有的异步性都对我们不利。现在，我们需要一种让服务器理解的方法，即在将React应用程序呈现为字符串并将其发送到客户端之前，需要等待后端的响应以及卡的内容。并且希望该方法相当通用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能有很多解决方案。一种方法是在一个单独的文件中描述应保护哪些数据的路径，并在呈现应用程序之前执行此操作（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。该解决方案具有许多优点。它很简单，很明确，而且行得通。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为一个实验（原始内容应该至少在文章中的某个位置！），我提出了另一种方案。</font><font style="vertical-align: inherit;">每次我们运行异步操作时（必须等待），在状态中的某个位置添加适当的承诺（例如，返回获取的承诺）。</font><font style="vertical-align: inherit;">因此，我们将提供一个地方，您可以随时检查所有内容是否已下载。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加两个新操作。</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/actions.js function addPromise(promise) { return { type: ADD_PROMISE, promise: promise }; } function removePromise(promise) { return { type: REMOVE_PROMISE, promise: promise, }; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动提取时将调用第一个，第二个将在调用结束时调用</font></font><code>.then()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在将其处理添加到减速器中：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js export default function root(state = {}, action) { switch (action.type) { case ADD_PROMISE: return { ...state, promises: [...state.promises, action.promise] }; case REMOVE_PROMISE: return { ...state, promises: state.promises.filter(p =&gt; p !== action.promise) }; ...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们将改善操作</font></font><code>fetchCard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/actions.js function fetchCard() { return (dispatch, getState) =&gt; { dispatch(startFetchingCard()); let url = apiPath() + "/card/" + getState().page.cardSlug; let promise = fetch(url) .then(response =&gt; response.json()) .then(json =&gt; { dispatch(finishFetchingCard(json)); // " ,  " dispatch(removePromise(promise)); }); // "  ,  " return dispatch(addPromise(promise)); }; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍然需要向</font></font><code>initialState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空数组中</font><font style="vertical-align: inherit;">添加</font><font style="vertical-align: inherit;">承诺，并使服务器等待所有承诺！</font><font style="vertical-align: inherit;">渲染函数变为异步，并采用以下形式：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/server.js function hasPromises(state) { return state.promises.length &gt; 0 } export default async function render(initialState, url) { const store = configureStore(initialState); store.dispatch(navigate(url)); let app = ( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt; ); //  renderToString     // (  ). CardPage     . renderToString(app); // ,   !    - //    (  // , ),     //    . let preloadedState = store.getState(); while (hasPromises(preloadedState)) { await preloadedState.promises[0]; preloadedState = store.getState() } //  renderToString.    HTML. let content = renderToString(app); return {content, preloadedState}; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于获得了</font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步，因此请求处理程序也稍微复杂一些：</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js app.get("*", (req, res) =&gt; { const initialState = { page: { type: "home" }, promises: [] }; render(initialState, {pathname: req.url}).then(result =&gt; { const {content, preloadedState} = result; const response = template("Habr demo app", preloadedState, content); res.send(response); }, (reason) =&gt; { console.log(reason); res.status(500).send("Server side rendering failed!"); }); });</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 等等！ </font></font><br><br><img src="https://habrastorage.org/webt/vt/ed/uj/vteduj-6tnshnodaw0setd3b0wu.png"><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，创建高科技应用程序并不是那么简单。</font><font style="vertical-align: inherit;">但是没有那么困难！</font><font style="vertical-align: inherit;">最终的应用程序位于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">存储库中</font></a><font style="vertical-align: inherit;">，从理论上讲，您只需要Docker即可运行它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果需要该文章，则甚至不会放弃该存储库！</font><font style="vertical-align: inherit;">我们将能够通过其他必要的知识来研究它：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 记录，监视，负载测试。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 测试，CI，CD。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 授权或全文搜索等更酷的功能。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 建立和开发生产环境。 </font></font></li></ul><br> 感谢您的关注！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444446/">https://habr.com/ru/post/zh-CN444446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444434/index.html">Java 12的时机已到！ 热门JEP的评论</a></li>
<li><a href="../zh-CN444436/index.html">什么是Mirai僵尸网络，如何保护我的设备？</a></li>
<li><a href="../zh-CN444438/index.html">开源简史-自由软件与专有软件的对抗</a></li>
<li><a href="../zh-CN444442/index.html">Jetson Nano：Nvidia机器学习单板</a></li>
<li><a href="../zh-CN444444/index.html">我们会议中最好的失败（小丑，JPoint，DotNext，Mobius，TechTrain等）</a></li>
<li><a href="../zh-CN444448/index.html">Mirai Clone为目标企业物联网设备增加了数十个新漏洞</a></li>
<li><a href="../zh-CN444456/index.html">Atari 65XE-USB键盘</a></li>
<li><a href="../zh-CN444460/index.html">从Python剧院海报的解析器到Telegram机器人。 第一部分</a></li>
<li><a href="../zh-CN444462/index.html">测试三星Galaxy S10-智能手机何时会赶上相机？</a></li>
<li><a href="../zh-CN444464/index.html">另一种使用std :: thread射腿的方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>