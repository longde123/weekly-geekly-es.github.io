<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïπÔ∏è üîú üë± .NET - Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a - Parte 2 ü¶è üë®üèΩ‚Äçü§ù‚Äçüë®üèº ‚ò£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Originalmente publiqu√© este art√≠culo en el blog CodingSight . 
 Tambi√©n est√° disponible en ruso aqu√≠ . 

 Este art√≠culo contiene la segunda parte de m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET - Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a - Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461471/">  <i>Originalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publiqu√©</a> este art√≠culo en el blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CodingSight</a> .</i> <i><br></i>  <i>Tambi√©n est√° disponible en ruso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .</i> <br><br>  Este art√≠culo contiene la segunda parte de mi discurso en la reuni√≥n de subprocesos m√∫ltiples.  Puedes echar un vistazo a la primera parte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  En la primera parte, me concentr√© en el conjunto b√°sico de herramientas utilizadas para iniciar un hilo o una tarea, las formas de rastrear su estado y algunas cosas interesantes adicionales como PLinq.  En esta parte, solucionar√© los problemas que puede encontrar en un entorno de subprocesos m√∫ltiples y algunas de las formas de resolverlos. <br><br><h2>  Contenido </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sobre los recursos compartidos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Posibles problemas en entornos de subprocesos m√∫ltiples</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Punto muerto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Condici√≥n de carrera</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ocupado-espera</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hilo de hambre</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M√©todos de sincronizaci√≥n</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enclavado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monitor.Enter, Monitor.Exit, lock</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monitor.Wait, Monitor.Pulse [Todos]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La familia ResetEvent</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusiones</a> </li></ul><br><a name="habracut"></a><a name="SharedResources"></a><br><h2>  Sobre los recursos compartidos </h2><br>  No puede escribir un programa cuyo trabajo se base en m√∫ltiples hilos sin tener recursos compartidos.  Incluso si funciona en su nivel de abstracci√≥n actual, encontrar√° que en realidad ha compartido recursos tan pronto como baje uno o m√°s niveles de abstracci√≥n.  Aqu√≠ hay algunos ejemplos: <br><br>  <b>Ejemplo # 1:</b> <br><br>  Para evitar posibles problemas, hace que los hilos funcionen con diferentes archivos, un archivo para cada hilo.  Le parece que el programa no tiene recursos compartidos de ning√∫n tipo. <br><br>  Al bajar algunos niveles, se llega a saber que solo hay un disco duro, y depende del controlador o del sistema operativo encontrar una soluci√≥n para los problemas con el acceso al disco duro. <br><br>  <b>Ejemplo # 2:</b> <br><br>  Despu√©s de leer el <i>ejemplo # 1</i> , decidi√≥ colocar los archivos en dos m√°quinas remotas diferentes con hardware y sistemas operativos f√≠sicamente diferentes.  Tambi√©n mantiene dos conexiones FTP o NFS diferentes. <br><br>  Al bajar algunos niveles nuevamente, comprende que nada ha cambiado realmente y que el problema de acceso competitivo ahora se delega al controlador de la tarjeta de red o al sistema operativo de la m√°quina en la que se ejecuta el programa. <br><br>  <b>Ejemplo # 3:</b> <br><br>  Despu√©s de tirar la mayor parte de su cabello sobre los intentos de probar que puede escribir un programa de subprocesos m√∫ltiples, decide deshacerse de los archivos por completo y mover los c√°lculos a dos objetos diferentes, con los enlaces a cada uno de los objetos disponibles solo para su espec√≠fico hilos <br><br>  Para martillar la √∫ltima docena de clavos en el ata√∫d de esta idea: un runtime y Garbage Collector, un programador de subprocesos, f√≠sicamente una RAM unificada y un procesador todav√≠a se consideran recursos compartidos. <br><br>  Entonces, aprendimos que es imposible escribir un programa multiproceso sin recursos compartidos en todos los niveles de abstracci√≥n y en todo el alcance de la pila de tecnolog√≠a.  Afortunadamente, cada nivel de abstracci√≥n (como regla general) se ocupa parcial o totalmente de los problemas de acceso competitivo o simplemente lo niega de inmediato (ejemplo: cualquier marco de UI no permite trabajar con elementos de diferentes hilos).  Por lo general, los problemas con los recursos compartidos aparecen en su nivel de abstracci√≥n actual.  Para cuidarlos, se introduce el concepto de sincronizaci√≥n. <br><a name="Problems"></a><br><h2>  Posibles problemas en entornos de subprocesos m√∫ltiples </h2><br>  Podemos clasificar los errores de software en las siguientes categor√≠as: <br><ol><li>  El programa no produce un resultado, se bloquea o se congela. </li><li>  El programa da un resultado incorrecto. </li><li>  El programa produce un resultado correcto pero no satisface algunos requisitos no relacionados con la funci√≥n: gasta demasiado tiempo o recursos. </li></ol><br>  En entornos de subprocesos m√∫ltiples, los principales problemas que provocan los errores n. ¬∞ 1 y n. ¬∞ 2 son el <b>punto muerto</b> y la <b>condici√≥n de la carrera</b> . <br><br><a name="Deadlock"></a><br><h3>  Punto muerto </h3><br>  El punto muerto es un bloqueo mutuo.  Hay muchas variaciones de un punto muerto.  El siguiente puede considerarse como el m√°s com√∫n: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Mientras el <b>Hilo # 1</b> estaba haciendo algo, el <b>Hilo # 2</b> bloque√≥ el recurso <b>B.</b>  Alg√∫n tiempo despu√©s, el <b>Hilo # 1</b> bloque√≥ el recurso <b>A</b> e intentaba bloquear el recurso B. desafortunadamente, esto nunca suceder√° porque el <b>Hilo # 2</b> solo soltar√° el recurso <b>B</b> despu√©s de bloquear el recurso <b>A.</b> <br><a name="RaceCondition"></a><br><h3>  Condici√≥n de carrera </h3><br>  Race-Condition es una situaci√≥n en la que tanto el comportamiento como los resultados de los c√°lculos dependen del planificador de subprocesos del entorno de ejecuci√≥n <br><br>  El problema es que su programa puede funcionar incorrectamente una vez en cien, o incluso en un mill√≥n. <br><br>  Las cosas pueden empeorar cuando surgen problemas de tres en tres.  Por ejemplo, el comportamiento espec√≠fico del planificador de subprocesos puede conducir a un punto muerto mutuo. <br><br>  Adem√°s de estos dos problemas que conducen a errores expl√≠citos, tambi√©n est√°n los problemas que, si no conducen a resultados de c√°lculo incorrectos, a√∫n pueden hacer que el programa tome mucho m√°s tiempo o recursos para producir el resultado deseado.  Dos de estos problemas son <b>Busy Wait</b> y <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Ocupado-espera </h3><br>  La espera ocupada es un problema que ocurre cuando el programa gasta los recursos del procesador en espera en lugar de en c√°lculo. <br><br>  Por lo general, este problema tiene el siguiente aspecto: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Este es un ejemplo de un c√≥digo extremadamente pobre, ya que ocupa completamente un n√∫cleo de su procesador sin hacer realmente nada productivo.  Dicho c√≥digo solo puede justificarse cuando es de importancia cr√≠tica procesar r√°pidamente un cambio de un valor en un hilo diferente.  Y por "r√°pidamente" quiero decir que no puedes esperar ni siquiera unos pocos nanosegundos.  En todos los dem√°s casos, es decir, en todos los casos que pueda tener una mente razonable, es mucho m√°s conveniente usar las variaciones de ResetEvent y sus versiones Slim.  Hablaremos de ellos un poco m√°s tarde. <br><br>  Probablemente, algunos lectores sugerir√≠an resolver el problema de que un n√∫cleo est√© completamente ocupado con la espera agregando Thread.Sleep (1) (o algo similar) en el ciclo.  Si bien resolver√° este problema, se crear√° uno nuevo: el tiempo que se tarda en reaccionar a los cambios ahora ser√° de 0,5 ms en promedio.  Por un lado, no es tanto, pero por otro lado, este valor es catastr√≥ficamente m√°s alto de lo que podemos lograr mediante el uso de primitivas de sincronizaci√≥n de la familia ResetEvent. <br><a name="ThreadStarvation"></a><br><h3>  Hilo de hambre </h3><br>  Thread Starvation es un problema con el programa que tiene demasiados hilos que operan simult√°neamente.  Aqu√≠, estamos hablando espec√≠ficamente de los hilos ocupados con el c√°lculo en lugar de esperar una respuesta de alg√∫n IO.  Con este problema, perdemos los posibles beneficios de rendimiento que vienen junto con los subprocesos porque el procesador pasa mucho tiempo cambiando de contexto. <br><br>  Puede encontrar estos problemas utilizando varios perfiladores.  La siguiente es una captura de pantalla del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generador de</a> perfiles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotTrace que</a> funciona en el modo L√≠nea de tiempo <br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(haga clic para agrandar).</i> <br><br>  Por lo general, los programas que no sufren el hambre del hilo no tienen secciones rosadas en los gr√°ficos que representan los hilos.  Adem√°s, en la categor√≠a Subsistemas, podemos ver que el programa estaba esperando CPU el 30.6% del tiempo. <br><br>  Cuando se diagnostica un problema de este tipo, puede solucionarlo de manera bastante simple: ha comenzado demasiados hilos a la vez, as√≠ que solo comience menos hilos. <br><a name="SyncPrimitives"></a><br><h2>  M√©todos de sincronizaci√≥n </h2><br><a name="Interlocked"></a><br><h3>  Enclavado </h3><br>  Este es probablemente el m√©todo de sincronizaci√≥n m√°s ligero.  Interlocked es un conjunto de operaciones at√≥micas simples.  Cuando se ejecuta una operaci√≥n at√≥mica, no puede pasar nada.  En .NET, Interlocked est√° representado por la clase est√°tica del mismo nombre con una selecci√≥n de m√©todos, cada uno de ellos implementando una operaci√≥n at√≥mica. <br><br>  Para darse cuenta del horror final de las operaciones no at√≥micas, intente escribir un programa que lance 10 hilos, cada uno de los cuales incremente la misma variable un mill√≥n de veces.  Cuando terminen con su trabajo, muestre el valor de esta variable.  Desafortunadamente, ser√° muy diferente de 10 millones.  Adem√°s, ser√° diferente cada vez que ejecute el programa.  Esto sucede porque incluso una operaci√≥n tan simple como el incremento no es at√≥mica, e incluye la extracci√≥n del valor de la memoria, el c√°lculo del nuevo valor y volver a escribirlo en la memoria.  Por lo tanto, dos hilos pueden realizar cualquiera de estas operaciones y se perder√° un incremento en este caso. <br><br>  La clase Interlocked proporciona los m√©todos de Incremento / Decremento, y no es dif√≠cil adivinar lo que se supone que deben hacer.  Son realmente √∫tiles si procesa datos en varios hilos y calcula algo.  Dicho c√≥digo funcionar√° mucho m√°s r√°pido que el bloqueo cl√°sico.  Si utilizamos Interlocked en la situaci√≥n descrita en el p√°rrafo anterior, el programa producir√≠a de manera confiable un valor de 10 millones en cualquier escenario. <br><br>  La funci√≥n del m√©todo CompareExchange no es tan obvia.  Sin embargo, su existencia permite la implementaci√≥n de muchos algoritmos interesantes.  Lo m√°s importante, los de la familia sin cerradura. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Este m√©todo toma tres valores.  El primero se pasa a trav√©s de una referencia y es el valor que se cambiar√° al segundo si location1 es igual a comparand cuando se realiza la comparaci√≥n.  Se devolver√° el valor original de location1.  Esto suena complicado, por lo que es m√°s f√°cil escribir un fragmento de c√≥digo que realice las mismas operaciones que CompareExchange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  La √∫nica diferencia es que la clase Interlocked implementa esto de una manera at√≥mica.  Entonces, si escribimos este c√≥digo nosotros mismos, podr√≠amos enfrentar un escenario en el que la condici√≥n location1 == comparand ya se ha cumplido.  Pero cuando se ejecuta la instrucci√≥n location1 = value, un subproceso diferente ya ha cambiado el valor de location1, por lo que se perder√°. <br><br>  Podemos encontrar un buen ejemplo de c√≥mo se puede usar este m√©todo en el c√≥digo que genera el compilador para cualquier evento de C #. <br><br>  Escribamos una clase simple con un evento llamado MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  Ahora, construyamos el proyecto en la configuraci√≥n de lanzamiento y abramos la construcci√≥n a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotPeek</a> con la opci√≥n "Mostrar c√≥digo generado por el compilador" habilitada: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Aqu√≠, podemos ver que el compilador ha generado un algoritmo bastante complejo detr√°s de escena.  Este algoritmo nos impide perder una suscripci√≥n al evento en el que algunos subprocesos se suscriben simult√°neamente a este evento.  Elaboremos el m√©todo de agregar teniendo en cuenta lo que hace el m√©todo CompareExchange detr√°s de escena: <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Esto es mucho m√°s manejable, pero probablemente a√∫n requiera una explicaci√≥n.  As√≠ es como describir√≠a el algoritmo: <br><br>  <i>Si MyEvent sigue siendo el mismo que en el momento en que comenzamos a ejecutar Delegate.Combine, config√∫relo en lo que Delegate.Combine devuelve.</i>  <i>Si no es el caso, intente nuevamente hasta que funcione.</i> <br><br>  De esta manera, las suscripciones nunca se perder√°n.  Tendr√° que resolver un problema similar si desea implementar una matriz din√°mica, segura para subprocesos y sin bloqueo.  Si de repente varios subprocesos comienzan a agregar elementos a esa matriz, es importante que todos esos elementos se agreguen con √©xito. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, lock </h3><br>  Estas construcciones se utilizan para la sincronizaci√≥n de subprocesos con mayor frecuencia.  Implementan el concepto de una secci√≥n cr√≠tica: es decir, el c√≥digo escrito entre las llamadas de Monitor.Enter y Monitor.Exit solo puede ejecutarse en un recurso en un punto del tiempo por un solo hilo.  El operador de bloqueo sirve como sintaxis-az√∫car alrededor de las llamadas de entrada / salida envueltas en try-finally.  Una calidad agradable de la secci√≥n cr√≠tica en .NET es que admite reentrada.  Esto significa que el siguiente c√≥digo puede ejecutarse sin problemas reales: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  Es poco probable que alguien escriba de esta manera exacta, pero si distribuye este c√≥digo entre algunos m√©todos a trav√©s de la profundidad de la pila de llamadas, esta funci√≥n puede ahorrarle algunos IF.  Para que este truco funcione, los desarrolladores de .NET tuvieron que agregar una limitaci√≥n: solo puede usar instancias de tipos de referencia como un objeto de sincronizaci√≥n, y se agregan unos pocos bytes a cada objeto donde se escribir√° el identificador de hilo. <br><br>  Esta peculiaridad del proceso de trabajo de la secci√≥n cr√≠tica en C # impone una limitaci√≥n interesante sobre el operador de bloqueo: no puede usar el operador de espera dentro del operador de bloqueo.  Al principio, esto me sorprendi√≥, ya que se puede compilar una construcci√≥n similar de Monitor de entrada y salida.  Cual es el trato?  Es importante volver a leer el p√°rrafo anterior y aplicar algunos conocimientos sobre c√≥mo funciona async / await: el c√≥digo despu√©s de waitit no se ejecutar√° en el mismo hilo que el c√≥digo antes de wait.  Esto depende del contexto de sincronizaci√≥n y de si se llama o no al m√©todo ConfigureAwait.  A partir de esto, se deduce que Monitor.Exit puede ejecutarse en un subproceso diferente que Monitor.Enter, lo que conducir√° a que se produzca SynchronizationLockException.  Si no me cree, intente ejecutar el siguiente c√≥digo en una aplicaci√≥n de consola: generar√° una <b>excepci√≥n SynchronizationLockException</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Vale la pena se√±alar que, en una aplicaci√≥n WinForms o WPF, este c√≥digo funcionar√° correctamente si lo llama desde el hilo principal, ya que habr√° un contexto de sincronizaci√≥n que implementa el retorno a UI-Thread despu√©s de la llamada en espera.  En cualquier caso, es mejor no jugar con secciones cr√≠ticas en el contexto de un c√≥digo que contiene el operador de espera.  En tales ejemplos, es mejor usar primitivas de sincronizaci√≥n que veremos m√°s adelante. <br><br>  Si bien estamos en el tema de las secciones cr√≠ticas en .NET, es importante mencionar una peculiaridad m√°s de c√≥mo se implementan.  Una secci√≥n cr√≠tica en .NET funciona en dos modos: spin-wait y core-wait.  Podemos representar el algoritmo spin-wait como el siguiente pseudoc√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Esta optimizaci√≥n est√° dirigida a capturar una secci√≥n cr√≠tica lo m√°s r√°pido posible en un corto per√≠odo de tiempo sobre la base de que, incluso si el recurso est√° actualmente ocupado, se lanzar√° muy pronto.  Si esto no sucede en un corto per√≠odo de tiempo, el subproceso cambiar√° a esperar en el modo central, lo que lleva tiempo, al igual que volver de esperar.  Los desarrolladores de .NET han optimizado el escenario de bloques cortos tanto como sea posible.  Desafortunadamente, si muchos subprocesos comienzan a tirar de la secci√≥n cr√≠tica entre ellos, puede provocar una carga repentina y alta en la CPU. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Despu√©s de haber mencionado el algoritmo de espera c√≠clico (spin-wait), vale la pena hablar sobre las estructuras SpinLock y SpinWait de BCL.  Debe usarlos si hay razones para suponer que siempre ser√° posible obtener un bloqueo muy r√°pidamente.  Por otro lado, no deber√≠a pensar realmente en ellos hasta que los resultados de la generaci√≥n de perfiles muestren que el cuello de botella de su programa se debe al uso de otras primitivas de sincronizaci√≥n. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Todos] </h3><br>  Deber√≠amos mirar estos dos m√©todos uno al lado del otro.  Con su ayuda, puede implementar varios escenarios Productor-Consumidor. <br><br>  Productor-Consumidor es un patr√≥n de dise√±o multiproceso / multiproceso que implica uno o m√°s hilos / procesos que producen datos y uno o m√°s procesos / hilos que procesan estos datos.  Por lo general, se usa una colecci√≥n compartida. <br><br>  Ambos m√©todos solo pueden ser llamados por un hilo que actualmente tiene un bloque.  El m√©todo Wait liberar√° el bloque y se congelar√° hasta que otro hilo llame a Pulse. <br><br>  Como demostraci√≥n de esto, escrib√≠ un peque√±o ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Us√© una imagen en lugar de texto aqu√≠ para mostrar con precisi√≥n el orden de ejecuci√≥n de la instrucci√≥n)</i> <br>  <b>Explicaci√≥n:</b> establec√≠ una latencia de 100 ms al iniciar el segundo subproceso para garantizar espec√≠ficamente que se ejecutar√° m√°s tarde. <br>  - T1: L√≠nea # 2 se inicia el hilo <br>  - T1: L√≠nea # 3 el hilo entra en una secci√≥n cr√≠tica <br>  - T1: L√≠nea # 6 el hilo se va a dormir <br>  - T2: L√≠nea # 3 se inicia el hilo <br>  - T2: l√≠nea # 4 se congela y espera la secci√≥n cr√≠tica <br>  - T1: L√≠nea # 7, deja ir la secci√≥n cr√≠tica y se congela mientras espera que salga Pulse <br>  - T2: L√≠nea # 8 ingresa a la secci√≥n cr√≠tica <br>  - T2: L√≠nea # 11 se√±ala T1 con la ayuda de Pulse <br>  - T2: L√≠nea # 14 sale de la secci√≥n cr√≠tica.  T1 no puede continuar su ejecuci√≥n antes de que esto suceda. <br>  - T1: L√≠nea # 15 sale de esperar <br>  - T1: l√≠nea # 16 sale de la secci√≥n cr√≠tica <br><br>  <i>Hay una observaci√≥n importante en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MSDN con</a> respecto al uso de los m√©todos Pulse / Wait: Monitor no almacena la informaci√≥n de estado, lo que significa que llamar al m√©todo Pulse antes del m√©todo Wait puede llevar a un punto muerto.</i>  <i>Si tal caso es posible, es mejor usar una de las clases de la familia ResetEvent.</i> <br><br>  El ejemplo anterior muestra claramente c√≥mo funcionan los m√©todos Wait / Pulse de la clase Monitor, pero a√∫n deja algunas preguntas sobre los casos en los que deber√≠amos usarlos.  Un buen ejemplo es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementaci√≥n</a> de BlockingQueue &lt;T&gt;.  Por otro lado, la implementaci√≥n de BlockingCollection &lt;T&gt; de System.Collections.Concurrent usa SemaphoreSlim para la sincronizaci√≥n. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Me encanta esta primitiva de sincronizaci√≥n, y est√° representada por la clase del mismo nombre del sistema.  Creo que muchos programas funcionar√≠an mucho mejor si sus desarrolladores usaran esta clase en lugar del bloqueo est√°ndar. <br><br>  Idea: muchos hilos pueden leer, y el √∫nico puede escribir.  Cuando un hilo quiere escribir, no se pueden iniciar nuevas lecturas; estar√°n esperando la escritura hasta el final.  Tambi√©n existe el concepto actualizable de bloqueo de lectura.  Puede usarlo cuando, durante el proceso de lectura, comprenda que es necesario escribir algo: tal bloqueo se transformar√° en un bloqueo de escritura en una operaci√≥n at√≥mica. <br><br>  En el espacio de nombres System.Threading, tambi√©n est√° la clase ReadWriteLock, pero se recomienda no usarla para un nuevo desarrollo.  La versi√≥n Slim ayudar√° a evitar casos que conducen a puntos muertos y permite capturar r√°pidamente un bloque, ya que admite la sincronizaci√≥n en el modo de espera de giro antes de pasar al modo central. <br><br>  Si no conoc√≠a esta clase antes de leer este art√≠culo, creo que ya ha recordado muchos ejemplos del c√≥digo recientemente escrito en el que este enfoque de bloques permiti√≥ que el programa funcionara de manera efectiva. <br><br>  La interfaz de la clase ReaderWriterLockSlim es simple y f√°cil de entender, pero no es tan c√≥moda de usar: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Por lo general, me gusta envolverlo en una clase, esto lo hace mucho m√°s pr√°ctico. <br><br>  <i><b>Idea:</b> crear m√©todos Read / WriteLock que devuelvan un objeto junto con el m√©todo Dispose.</i>  <i>Luego puede acceder a ellos en Uso, y probablemente no diferir√° demasiado del bloqueo est√°ndar cuando se trata de la cantidad de l√≠neas.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Esto nos permite escribir lo siguiente m√°s adelante en el c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  La familia ResetEvent </h3><br>  Incluyo las siguientes clases en esta familia: ManualResetEvent, ManualResetEventSlim y AutoResetEvent. <br><br>  La clase ManualResetEvent, su versi√≥n Slim y la clase AutoResetEvent pueden existir en dos estados: <br><br>  - Sin se√±alizaci√≥n: en este estado, todos los subprocesos que han llamado a WaitOne se congelan hasta que el evento cambia a un estado se√±alado. <br>  - Se√±alizado: en este estado, se liberan todos los hilos previamente congelados en una llamada WaitOne.  Todas las nuevas llamadas WaitOne en un evento se√±alado se realizan de manera relativamente instant√°nea. <br><br>  AutoResetEvent difiere de ManualResetEvent en que cambia autom√°ticamente al estado no se√±alado despu√©s de liberar <b>exactamente un subproceso</b> .  Si se congelan algunos subprocesos mientras se espera AutoResetEvent, al llamar a Set solo se liberar√° un subproceso aleatorio, a diferencia de ManualResetEvent que libera todos los subprocesos. <br><br>  Veamos un ejemplo de c√≥mo funciona AutoResetEvent: <br><br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br>  En estos ejemplos, podemos ver que el evento cambia al estado no se√±alado autom√°ticamente solo despu√©s de liberar el hilo que se congel√≥ en una llamada WaitOne. <br><br>  A diferencia de ReaderWriterLock, ManualResetEvent no se considera obsoleto incluso despu√©s de que apareci√≥ su versi√≥n Slim.  Esta versi√≥n Slim de la clase puede ser efectiva para esperas cortas como sucede en el modo Spin-Wait;  La versi√≥n est√°ndar es buena para largas esperas. <br><br>  Adem√°s de las clases ManualResetEvent y AutoResetEvent, tambi√©n est√° la clase CountdownEvent.  Esta clase es muy √∫til para implementar algoritmos que combinan resultados juntos despu√©s de una secci√≥n paralela.  Este enfoque se conoce como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fork-join</a> .  Hay un gran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> dedicado a esta clase, por lo que no lo describir√© en detalle aqu√≠. <br><a name="Conclusions"></a><br><h2>  Conclusiones </h2><br><ul><li>  Cuando se trabaja con subprocesos, hay dos problemas que pueden conducir a resultados incorrectos o incluso a la ausencia de resultados: condici√≥n de carrera y punto muerto. </li><li>  Los problemas que pueden hacer que el programa gaste m√°s tiempo o recursos son el hambre de hilos y la espera ocupada. </li><li>  .NET proporciona muchas formas de sincronizar hilos. </li><li>  Hay dos modos de espera en bloque: Spin Wait y Core Wait.  Algunas primitivas de sincronizaci√≥n de hilos en .NET usan ambas. </li><li>  Interlocked es un conjunto de operaciones at√≥micas que se pueden usar para implementar algoritmos sin bloqueo.  Es la primitiva de sincronizaci√≥n m√°s r√°pida. </li><li>  Los operadores de bloqueo y monitor de entrada / salida implementan el concepto de una secci√≥n cr√≠tica, un fragmento de c√≥digo que solo puede ser ejecutado por un hilo en un punto de tiempo. </li><li>  Los m√©todos Monitor.Pulse / Wait son √∫tiles para implementar escenarios Productor-Consumidor. </li><li>  ReaderWriterLockSlim puede ser m√°s √∫til que los casos de bloqueo est√°ndar cuando se espera una lectura paralela. </li><li>  La familia de clases ResetEvent puede ser √∫til para la sincronizaci√≥n de subprocesos. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461471/">https://habr.com/ru/post/461471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461461/index.html">La copia de seguridad prospera en la era de la nube, pero los carretes de cinta no se olvidan. Conversaci√≥n con Veeam</a></li>
<li><a href="../461463/index.html">Procesos de negocio en empresas: especulaci√≥n y realidad. Arrojar luz con R</a></li>
<li><a href="../461465/index.html">Gu√≠a de medici√≥n</a></li>
<li><a href="../461467/index.html">Un ejemplo de creaci√≥n de aplicaciones Makefile for Go</a></li>
<li><a href="../461469/index.html">¬øC√≥mo es escuchar c√≥digo a 1000 palabras por minuto?</a></li>
<li><a href="../461473/index.html">Algoritmos de depuraci√≥n en gr√°ficos, ahora con im√°genes</a></li>
<li><a href="../461475/index.html">AMA con Habr.1011</a></li>
<li><a href="../461483/index.html">Balanceo de carga de OpenStack</a></li>
<li><a href="../461487/index.html">Mini CTF Tasks</a></li>
<li><a href="../461493/index.html">Django 3.0 ser√° asincr√≥nico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>