<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📻 🙀 🧓🏼 Optimasi Kinerja Basis Data Oracle yang Proaktif 👩🏽‍🚒 🚶🏽 👨🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hal pertama yang kami temui ketika berbicara tentang pengoptimalan proaktif adalah tidak diketahui apa yang perlu dioptimalkan. "Lakukan itu, aku tida...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimasi Kinerja Basis Data Oracle yang Proaktif</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/428491/">  Hal pertama yang kami temui ketika berbicara tentang pengoptimalan proaktif adalah tidak diketahui apa yang perlu dioptimalkan.  "Lakukan itu, aku tidak tahu apa." <br><br><ul><li>  Tidak ada algoritma klasik. </li><li>  Masalahnya belum muncul (tidak diketahui), dan orang hanya bisa menebak di mana itu mungkin. </li><li>  Kita perlu menemukan beberapa titik kelemahan potensial dalam sistem. </li><li>  Cobalah untuk mengoptimalkan kinerja permintaan di tempat-tempat ini. </li></ul><br><h3>  Tujuan utama optimasi proaktif <br></h3><br>  Tugas utama optimasi proaktif berbeda dari tugas optimasi reaktif dan adalah sebagai berikut: <br><br><ul><li>  menghilangkan hambatan dalam database; </li><li>  penurunan konsumsi sumber daya basis data. </li></ul><br>  Momen terakhir adalah yang paling mendasar.  Dalam hal optimasi reaktif, kami tidak memiliki tugas untuk mengurangi konsumsi sumber daya secara keseluruhan, tetapi hanya tugas membawa waktu respon fungsi ke dalam batas yang dapat diterima. <br><br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Jika Anda bekerja dengan server pertempuran, Anda memiliki ide bagus tentang apa yang dimaksud insiden kinerja.  Anda harus keluar dari segalanya dan dengan cepat menyelesaikan masalah.  RNKO Payment Center LLC bekerja dengan banyak agen, dan sangat penting bagi mereka untuk memiliki masalah sesedikit mungkin.  Alexander Makarov di HighLoad ++ Siberia mengatakan apa yang dilakukan untuk secara signifikan mengurangi jumlah insiden kinerja.  Optimalisasi proaktif datang untuk menyelamatkan.  Dan mengapa dan bagaimana itu diproduksi di server tempur, baca di bawah ini. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/r_/kt/zz/r_ktzzegcm2xca_nrh4yusjtpqy.png"><br><br>  <strong>Tentang Pembicara:</strong> Alexander Makarov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">AL_IG_Makarov</a> ), Administrator Terkemuka dari Database Oracle, LLC RNCO Payment Center.  Terlepas dari posisinya, hanya ada sedikit administrasi seperti itu, tugas-tugas utama terkait dengan memelihara kompleks dan pengembangannya, khususnya, memecahkan masalah kinerja. <br><br><h1>  Apakah optimalisasi pada basis data tempur proaktif? <br></h1><br>  Pertama, kami akan berurusan dengan ketentuan yang disebut oleh laporan ini sebagai "optimalisasi kinerja proaktif."  Terkadang Anda dapat memenuhi sudut pandang bahwa optimalisasi proaktif adalah ketika analisis bidang masalah dilakukan sebelum aplikasi diluncurkan.  Misalnya, kami mengetahui bahwa beberapa kueri tidak berfungsi optimal, karena tidak ada cukup indeks atau kueri menggunakan algoritma yang tidak efisien, dan pekerjaan ini dilakukan pada server uji. <br><br>  Namun demikian, kami di RNCO melakukan proyek ini <strong>di server pertempuran</strong> .  Sering kali saya mendengar: “Bagaimana bisa begitu?  Anda melakukannya di server tempur - itu berarti itu bukan optimasi kinerja proaktif! "  Di sini kita perlu mengingat pendekatan yang dikembangkan di ITIL.  Dari sudut pandang ITIL, kami memiliki: <br><br><ul><li>  insiden kinerja adalah apa yang telah terjadi; </li><li>  langkah-langkah yang kami ambil untuk mencegah terjadinya insiden kinerja. </li></ul><br>  Dalam hal ini, tindakan kami proaktif.  Terlepas dari kenyataan bahwa kami sedang memecahkan masalah pada server tempur, masalah itu sendiri belum muncul: insiden itu tidak terjadi, kami tidak lari dan tidak mencoba menyelesaikan masalah ini dalam waktu singkat. <br><br>  Jadi, dalam laporan ini, proaktif dipahami sebagai <strong>proaktif dalam arti ITIL</strong> , kami memecahkan masalah sebelum insiden kinerja terjadi. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y68RLr825VE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Titik referensi <br></h1><br>  RNKO "Pusat Pembayaran" melayani 2 sistem besar: <br><br><ul><li>  RBS-Bank Ritel; </li><li>  Bank CFT. </li></ul><br>  Sifat beban pada sistem ini adalah campuran (DSS + OLTP): ada sesuatu yang bekerja sangat cepat, ada laporan, ada beban sedang. <br><br>  Kita dihadapkan dengan kenyataan yang tidak terlalu sering, tetapi dengan frekuensi tertentu, insiden kinerja terjadi.  Mereka yang bekerja dengan server pertempuran membayangkan apa itu.  Ini berarti bahwa Anda harus keluar dari segalanya dan dengan cepat menyelesaikan masalah, karena saat ini klien tidak dapat menerima layanan, sesuatu yang tidak berfungsi sama sekali, atau berfungsi sangat lambat. <br><br>  Karena cukup banyak agen dan klien terikat dengan organisasi kami, ini sangat penting bagi kami.  Jika kami tidak dapat dengan cepat menyelesaikan insiden kinerja, maka pelanggan kami akan menderita dengan satu atau lain cara.  Misalnya, mereka tidak akan dapat mengisi kembali kartu atau melakukan transfer.  Oleh karena itu, kami bertanya-tanya apa yang bisa dilakukan untuk menghilangkan bahkan insiden kinerja yang jarang terjadi ini.  Untuk bekerja dalam mode ketika Anda harus meninggalkan semuanya dan menyelesaikan masalah - ini tidak sepenuhnya benar.  Kami menggunakan sprint dan menyusun rencana kerja sprint.  Kehadiran insiden kinerja juga merupakan penyimpangan dari rencana kerja. <br><br>  Sesuatu harus dilakukan dengan ini! <br><br><h1>  Pendekatan Optimasi <br></h1><br>  Kami berpikir dan memahami teknologi optimasi proaktif.  Tetapi sebelum saya berbicara tentang optimasi proaktif, saya harus mengatakan beberapa kata tentang optimasi reaktif klasik. <br><br><h2>  Optimalisasi reaktif <br></h2><br>  Skenarionya sederhana, ada server tempur di mana sesuatu terjadi: mereka meluncurkan laporan, klien menerima pernyataan, saat ini ada aktivitas yang sedang berlangsung di database, dan tiba-tiba seseorang memutuskan untuk memperbarui semacam direktori yang bervolume.  Sistem mulai melambat.  Pada saat ini, klien datang dan berkata: "Saya tidak bisa melakukan ini atau itu" - kita perlu menemukan alasan mengapa dia tidak bisa melakukan ini. <br><br>  <strong>Algoritma tindakan klasik:</strong> <br><br><ol><li>  Reproduksi masalahnya. </li><li>  Temukan lokasi masalah. </li><li>  Optimalkan tempat masalah. </li></ol><br>  Dalam kerangka pendekatan reaktif, tugas utama bukanlah menemukan akar penyebab itu sendiri dan menghilangkannya, tetapi untuk membuat sistem bekerja secara normal.  Penghapusan akar penyebabnya bisa ditanggulangi nanti.  Yang utama adalah mengembalikan server dengan cepat sehingga klien dapat menerima layanan. <br><br><h3>  Tujuan utama optimasi reaktif <br></h3><br>  Dalam optimasi reaktif, dua tujuan utama dapat dibedakan: <br><br>  1. <strong>Penurunan waktu respons</strong> . <br><br>  Suatu tindakan, misalnya, menerima laporan, pernyataan, transaksi, harus dilakukan untuk beberapa waktu yang dijadwalkan.  Penting untuk memastikan bahwa waktu menerima layanan kembali ke batas yang dapat diterima klien.  Mungkin layanan bekerja sedikit lebih lambat dari biasanya, tetapi bagi klien ini dapat diterima.  Kemudian kami percaya bahwa insiden kinerja telah dihilangkan, dan kami mulai bekerja pada akar penyebabnya. <br><br>  2. <strong>Peningkatan jumlah objek yang diproses per unit waktu selama pemrosesan batch</strong> . <br><br>  Ketika pemrosesan batch transaksi sedang berlangsung, perlu untuk mengurangi waktu pemrosesan satu objek dari paket. <br><br>  <strong>Kelebihan pendekatan reaktif:</strong> <br><br>  ● <em>Berbagai alat dan teknik</em> adalah nilai tambah utama dari pendekatan reaktif. <br><br>  Kita dapat menggunakan alat pemantauan untuk memahami apa masalahnya secara langsung: tidak ada cukup CPU, utas, memori, atau sistem disk terpeleset, atau log sedang diproses secara lambat.  Ada banyak alat dan teknik untuk mempelajari masalah kinerja saat ini di database Oracle. <br><br>  ● <em>Waktu respons yang diinginkan</em> adalah nilai tambah lainnya. <br><br>  Dalam proses kerja seperti itu, kami membawa situasi ke waktu respons yang dapat diterima, yaitu, kami tidak mencoba menguranginya ke nilai minimum, tetapi kami mencapai nilai tertentu dan setelah tindakan ini selesai, karena kami yakin telah mencapai batas yang dapat diterima. <br><br>  <strong>Kontra dari pendekatan reaktif:</strong> <br><br><ul><li>  <em>Insiden kinerja tetap ada</em> - ini adalah minus terbesar dari pendekatan reaktif, karena kita tidak selalu dapat mencapai akar penyebabnya.  Dia bisa tinggal di suatu tempat di luar jalan dan berbaring di tempat yang lebih dalam, terlepas dari kenyataan bahwa kami mencapai kinerja yang dapat diterima. </li></ul><br>  Dan bagaimana menghadapi insiden kinerja jika belum terjadi?  Mari kita coba merumuskan bagaimana optimasi proaktif dapat dilakukan untuk mencegah situasi seperti itu. <br><br><h2>  Optimasi Proaktif <br></h2><br>  Hal pertama yang kami temui adalah tidak diketahui apa yang perlu dioptimalkan.  "Lakukan itu, aku tidak tahu apa." <br><br><ul><li>  Tidak ada algoritma klasik. </li><li>  Masalahnya belum muncul (tidak diketahui), dan orang hanya bisa menebak di mana itu mungkin. </li><li>  Kita perlu menemukan beberapa titik kelemahan potensial dalam sistem. </li><li>  Cobalah untuk mengoptimalkan kinerja permintaan di tempat-tempat ini. </li></ul><br><h3>  Tujuan utama optimasi proaktif <br></h3><br>  Tugas utama optimasi proaktif berbeda dari tugas optimasi reaktif dan adalah sebagai berikut: <br><br><ul><li>  menghilangkan hambatan dalam database; </li><li>  penurunan konsumsi sumber daya basis data. </li></ul><br>  Momen terakhir adalah yang paling mendasar.  Dalam hal optimasi reaktif, kami tidak memiliki tugas untuk mengurangi konsumsi sumber daya secara keseluruhan, tetapi hanya tugas membawa waktu respons fungsionalitas ke dalam batas yang dapat diterima. <br><br><h3>  Bagaimana menemukan kemacetan di database? <br></h3><br>  Ketika kita mulai memikirkan masalah ini, banyak sub-tugas yang muncul segera.  Perlu untuk melakukan: <br><br><ul><li>  Pengujian CPU </li><li>  uji beban pada baca / catatan; </li><li>  stress testing dengan jumlah sesi aktif; </li><li>  uji beban pada ... dll. </li></ul><br>  Jika kami mencoba mensimulasikan masalah ini pada kompleks pengujian, kami mungkin menemukan fakta bahwa masalah yang muncul pada server pengujian tidak ada hubungannya dengan pertempuran.  Ada banyak alasan untuk ini, dimulai dengan fakta bahwa server pengujian biasanya lebih lemah.  Adalah baik jika memungkinkan untuk membuat server uji salinan yang tepat dari pertempuran, tetapi ini tidak menjamin bahwa beban akan direproduksi dengan cara yang sama, karena Anda perlu mereproduksi aktivitas pengguna secara akurat dan banyak lagi faktor berbeda yang memengaruhi beban akhir.  Jika Anda mencoba mensimulasikan situasi ini, maka, pada umumnya, tidak ada yang menjamin bahwa hal yang persis sama akan terjadi yang akan terjadi di server pertempuran. <br><br>  Jika dalam satu kasus masalah muncul karena registri baru tiba, maka di lain itu mungkin timbul karena pengguna meluncurkan laporan besar melakukan semacam besar, karena yang mengisi tablespace sementara, dan, seperti sebagai hasilnya, sistem mulai melambat.  Artinya, alasannya bisa berbeda, dan tidak selalu mungkin untuk memprediksi mereka.  Karenanya, <strong>kami mengabaikan upaya untuk mencari kemacetan di server uji</strong> hampir sejak awal.  Kami hanya mengandalkan server tempur dan apa yang terjadi di sana. <br><br>  Apa yang harus dilakukan dalam kasus ini?  Mari kita coba untuk memahami sumber daya apa yang paling mungkin kurang di tempat pertama. <br><br><h3>  Mengurangi konsumsi sumber daya basis data <br></h3><br>  Berdasarkan kompleks industri yang kami miliki, <strong>kekurangan sumber daya yang paling sering diamati dalam pembacaan disk dan CPU</strong> .  Karena itu, pertama-tama, kita akan mencari kelemahan di area ini. <br><br>  Pertanyaan penting kedua: bagaimana cara mencari sesuatu? <br>  Pertanyaannya sangat tidak sepele.  Kami menggunakan Oracle Enterprise Edition dengan opsi Paket Diagnostik dan untuk kami sendiri kami menemukan alat seperti itu - <b>laporan AWR</b> (dalam edisi lain Oracle Anda dapat menggunakan <b>laporan STATSPACK</b> ).  Di PostgreSQL ada analog - pgstatspack, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_profile dari</a> Andrey Zubkov.  Produk terakhir, seperti yang saya mengerti, muncul dan mulai berkembang hanya tahun lalu.  Untuk MySQL, saya tidak dapat menemukan alat serupa, tetapi saya bukan ahli MySQL. <br><br>  Pendekatan itu sendiri tidak terikat pada jenis database tertentu.  Jika mungkin untuk memperoleh informasi tentang beban sistem dari beberapa laporan, maka, dengan menggunakan teknik yang akan saya bicarakan sekarang, Anda dapat melakukan pekerjaan pada optimasi proaktif <strong>atas dasar apa pun</strong> . <br><br><h3>  <strong>Optimalisasi 5 operasi teratas</strong> <br></h3><br>  Teknologi optimisasi proaktif yang telah kami kembangkan dan gunakan di Pusat Pembayaran RNCO terdiri dari empat tahap. <br><br>  <strong>Tahap 1. Kami menerima laporan AWR untuk periode sebanyak mungkin.</strong> <br><br>  Durasi terbesar yang mungkin diperlukan untuk rata-rata beban pada hari yang berbeda dalam seminggu, karena kadang-kadang sangat berbeda.  Sebagai contoh, pendaftar selama seminggu terakhir tiba di RBS-Retail Bank pada hari Selasa, mereka mulai diproses, dan sepanjang hari kami memiliki beban yang di atas rata-rata sekitar 2-3 kali.  Di hari lain, bebannya lebih sedikit. <br><br>  Jika Anda tahu bahwa sistem memiliki beberapa spesifik - pada beberapa hari bebannya lebih besar, pada beberapa hari - kurang, maka Anda perlu menerima laporan untuk periode ini secara terpisah dan bekerja dengannya secara terpisah jika kami ingin mengoptimalkan interval waktu tertentu .  Jika Anda perlu mengoptimalkan situasi keseluruhan di server, Anda bisa mendapatkan laporan besar untuk bulan itu, dan melihat apa yang sebenarnya dikonsumsi sumber daya server. <br><br>  Terkadang situasi yang sangat tidak terduga muncul.  Misalnya, dalam kasus CFT Bank, permintaan yang memeriksa antrian server laporan mungkin berada di 10 besar.  Selain itu, permintaan ini resmi dan tidak menjalankan logika bisnis, tetapi hanya memeriksa apakah ada laporan tentang eksekusi atau tidak. <br><br>  <strong>Tahap 2. Kami melihat bagian:</strong> <br><br><ul><li>  SQL dipesan dengan Waktu Berlalu - Kueri SQL diurutkan berdasarkan runtime; </li><li>  SQL dipesan berdasarkan Waktu CPU - untuk penggunaan CPU; </li><li>  SQL dipesan oleh Gets - oleh bacaan logis; </li><li>  SQL dipesan oleh Bacaan - untuk bacaan fisik. </li></ul><br>  Bagian-bagian lain dari SQL yang dipesan oleh dipelajari sesuai kebutuhan. <br><br>  <strong>Tahap 3. Kami menentukan operasi induk dan permintaan bergantung padanya.</strong> <br><br>  Laporan AWR memiliki bagian terpisah di mana, tergantung pada versi Oracle, 15 atau lebih permintaan teratas ditampilkan di masing-masing bagian ini.  Tapi pertanyaan ini Oracle dalam laporan AWR menunjukkan kekacauan. <br>  Misalnya, ada operasi induk, di dalamnya bisa ada 3 permintaan teratas.  Oracle dalam laporan AWR akan menunjukkan operasi induk dan ketiga kueri ini.  Oleh karena itu, Anda perlu melakukan analisis daftar ini dan melihat permintaan spesifik operasi apa yang merujuk, mengelompokkannya. <br><br>  <strong>Tahap 4. Kami mengoptimalkan 5 operasi teratas.</strong> <br><br>  Setelah pengelompokan seperti itu, output adalah daftar operasi yang paling sulit Anda pilih.  Kami dibatasi hingga 5 operasi (bukan permintaan, yaitu operasi).  Jika sistem lebih kompleks, maka Anda dapat mengambil lebih banyak. <br><br><h3>  Kesalahan desain kueri umum <br></h3><br>  Selama penerapan teknik ini, kami telah menyusun daftar kecil kesalahan desain yang khas.  Beberapa kesalahan sangat sederhana sehingga tampaknya tidak mungkin terjadi. <br><br>  ● <strong>Kurangnya indeks → Pemindaian penuh</strong> <br>  Ada kasus-kasus yang sangat insidental, misalnya, dengan tidak adanya indeks pada skema pertempuran.  Kami memiliki contoh konkret di mana kueri untuk waktu yang lama bekerja dengan cepat tanpa indeks.  Tapi ada pemindaian penuh, dan ketika ukuran meja berangsur-angsur tumbuh, kueri mulai bekerja lebih lambat, dan dari kuartal ke kuartal butuh waktu lebih lama.  Pada akhirnya, kami memperhatikannya dan ternyata indeksnya tidak ada. <br><br>  ● <strong>Pilihan besar → Pemindaian penuh</strong> <br>  Kesalahan umum kedua adalah sampel data besar - kasus klasik pemindaian penuh.  Semua orang tahu bahwa pemindaian penuh harus digunakan hanya ketika benar-benar dibenarkan.  Kadang-kadang ada kasus ketika pemindaian penuh ditemukan di mana dimungkinkan untuk dilakukan tanpanya, misalnya, jika Anda mentransfer kondisi pemfilteran dari kode pl / sql ke kueri. <br><br>  ● <strong>Indeks tidak efektif → SCAN RANGE INDEX Panjang</strong> <br>  Mungkin ini bahkan kesalahan yang paling umum, yang untuk beberapa alasan mereka mengatakan sangat sedikit - yang disebut indeks tidak efisien (pemindaian indeks panjang, lama INDEX RANGE SCAN).  Misalnya, kami memiliki tabel untuk pendaftar.  Dalam permintaan, kami mencoba menemukan semua pendaftar dari agen ini, dan pada akhirnya menambahkan semacam kondisi penyaringan, misalnya, untuk periode tertentu, atau dengan nomor tertentu, atau klien tertentu.  Dalam situasi seperti itu, indeks biasanya dibangun hanya pada bidang "agen" untuk alasan universalitas penggunaan.  Hasilnya adalah gambar berikut: pada tahun pertama kerja, misalnya, agen memiliki 100 entri dalam tabel ini, tahun depan sudah 1.000, pada tahun lain mungkin ada 10.000 entri.  Beberapa waktu berlalu, catatan ini menjadi 100.000. Jelas, permintaan mulai bekerja lambat, karena dalam permintaan Anda perlu menambahkan tidak hanya agen pengenal itu sendiri, tetapi juga beberapa filter tambahan, dalam hal ini berdasarkan tanggal.  Jika tidak, akan muncul bahwa ukuran sampel akan meningkat dari tahun ke tahun, karena jumlah pendaftar untuk agen ini bertambah.  Masalah ini harus diatasi di tingkat indeks.  Jika ada terlalu banyak data, maka kita harus sudah berpikir ke arah partisi. <br><br>  ● <strong>cabang kode distribusi yang tidak perlu</strong> <br>  Ini juga merupakan kasus yang aneh, tetapi, bagaimanapun, itu terjadi.  Kami melihat kueri teratas, dan kami melihat beberapa kueri aneh di sana.  Kami datang ke pengembang dan berkata: "Kami menemukan beberapa permintaan, mari kita mencari tahu dan melihat apa yang bisa dilakukan tentang itu."  Pengembang berpikir, kemudian muncul setelah beberapa saat dan berkata: “Cabang kode ini seharusnya tidak ada di sistem Anda.  Anda tidak menggunakan fungsi ini. "  Kemudian pengembang menyarankan agar Anda mengaktifkan beberapa pengaturan khusus untuk mengatasi bagian kode ini. <br><br><h3>  Studi kasus <br></h3><br>  Sekarang saya ingin mempertimbangkan dua contoh dari praktik nyata kami.  Ketika kita berurusan dengan kueri teratas, tentu saja kita pertama-tama memikirkan fakta bahwa harus ada sesuatu yang sangat berat, non-sepele, dengan operasi yang kompleks.  Sebenarnya, ini tidak selalu terjadi.  Kadang-kadang ada kasus ketika pertanyaan yang sangat sederhana masuk dalam operasi teratas. <br><br><h4>  Contoh 1 <br></h4><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_reestr_in_oper o <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.type_oper = <span class="hljs-string"><span class="hljs-string">'proc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> l.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_link l <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> l.s_rnko = :<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> o.date_oper_bnk <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, o.date_reg <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Dalam contoh ini, kueri hanya terdiri dari dua tabel, dan ini bukan tabel berat - hanya beberapa juta rekaman.  Akan terlihat lebih mudah?  Namun, permintaan mencapai puncak. <br><br>  Mari kita coba mencari tahu apa yang salah dengannya. <br><br>  Di bawah ini adalah gambar dari Enterprise Manager Cloud Control - data statistik dari permintaan ini (Oracle memiliki alat seperti itu).  Dapat dilihat bahwa ada beban reguler pada permintaan ini (grafik atas).  Angka 1 di samping menunjukkan bahwa rata-rata tidak lebih dari satu sesi berjalan.  Diagram hijau menunjukkan bahwa <strong>permintaan hanya menggunakan CPU</strong> , yang sangat menarik. <br><br><img src="https://habrastorage.org/webt/cd/jl/tm/cdjltmcxv_hgjn7ykitlcdjwdes.jpeg"><br><br>  Mari kita coba mencari tahu apa yang sedang terjadi di sini? <br><br><img src="https://habrastorage.org/webt/gk/h9/8r/gkh98r5cr3dprhk49xl0d3-y1nm.jpeg"><br><br>  Di atas adalah tabel dengan statistik berdasarkan permintaan.  Hampir 700 ribu peluncuran - ini tidak akan mengejutkan siapa pun.  Tetapi interval waktu dari Waktu Muatan Pertama pada 15 Desember hingga Waktu Muatan Terakhir pada 22 Desember (lihat gambar sebelumnya) adalah satu minggu.  Jika Anda menghitung jumlah awal per detik, ternyata <strong>kueri dieksekusi rata-rata setiap detik</strong> . <br><br>  Kami melihat lebih jauh.  Waktu eksekusi permintaan adalah 0,93 detik, mis.  kurang dari sedetik, itu bagus.  Kami bisa bersukacita - permintaannya tidak berat.  Namun demikian, ia mencapai puncak, yang berarti ia menghabiskan banyak sumber daya.  Di mana ia menghabiskan banyak sumber daya? <br><br>  Tabel memiliki garis untuk bacaan logis.  Kami melihat bahwa untuk satu peluncuran diperlukan hampir 8 ribu blok (biasanya 1 blok adalah 8 KB).  Ternyata permintaan itu, yang bekerja satu detik sekali, memuat sekitar 64 MB data dari memori.  Ada yang salah di sini, kita perlu mengerti. <br><br>  Mari kita lihat rencananya: ada pemindaian penuh.  Baiklah, mari kita lanjutkan. <br><br><pre> <code class="sql hljs"> Plan hash value: 634977963 <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------- | Id | Operation | Name | ------------------------------------------------------------------- | 0 | SELECT STATEMENT | | |* 1 | COUNT STOPKEY | | | 2 | VIEW | | |* 3 | SORT ORDER BY STOPKEY | | | 4 | NESTED LOOPS | | | 5 | TABLE ACCESS BY INDEX ROWID| RNKO_DEP_LINK | |* 6 | INDEX UNIQUE SCAN | UK_RNKODEPLINK$S_RNKO | |* 7 | TABLE ACCESS FULL | RNKO_DEP_REESTR_IN_OPER | ------------------------------------------------------------------- Predicate Information (identified by operation id): 1 - filter(ROWNUM=1) 3 - filter(ROWNUM=1) 6 - access("L"."S_RNKO"=:1) 7 - filter(("O"."TYPE_OPER"='proc' AND "O"."EAN_RNKO"="L"."EAN_RNKO"))</span></span></code> </pre><br>  Dalam tabel rnko_dep_reestr_in_oper, hanya ada 5 juta baris dan panjang baris rata-rata adalah 150 byte.  Tapi ternyata tidak ada cukup indeks untuk bidang yang terhubung - subquery terhubung ke permintaan melalui bidang ean_rnko, yang tidak ada indeks! <br><br>  Apalagi, meski dia muncul, nyatanya situasinya tidak akan terlalu bagus.  Pemindaian indeks yang panjang (panjang INDEX RANGE SCAN) akan terjadi.  ean_rnko adalah pengidentifikasi internal agen.  Registrasi agen akan terakumulasi, dan setiap tahun jumlah data yang akan dipilih akan meningkat, dan permintaan akan melambat. <br><br>  <strong>Solusi:</strong> buat indeks untuk bidang ean_rnko dan date_reg, minta pengembang membatasi kedalaman pemindaian berdasarkan tanggal dalam permintaan ini.  Maka Anda setidaknya dapat sampai batas tertentu menjamin bahwa kinerja permintaan akan tetap kira-kira pada batas yang sama, karena ukuran sampel akan terbatas pada interval waktu yang tetap, dan seluruh tabel tidak perlu dibaca.  Ini adalah poin yang sangat penting, lihat apa yang terjadi. <br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Setelah optimasi, waktu operasi menjadi kurang dari seperseratus detik (itu adalah 0,93), jumlah blok menjadi rata-rata 8,5 - 1000 kali lebih sedikit dari sebelumnya. <br><br><h4>  Contoh 2 <br></h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> loy$barcodes t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> t.id_processing = :b1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.id_rec_out <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.barcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.status = <span class="hljs-string"><span class="hljs-string">'u'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.id_card <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Saya memulai ceritanya dengan mengatakan bahwa biasanya sesuatu yang rumit diharapkan di bagian atas permintaan.  Di atas adalah contoh kueri "kompleks" yang masuk ke satu tabel (!), Dan itu juga masuk ke kueri teratas :) Ada indeks di bidang ID_PROCESSING! <br>  Ada 3 kondisi IS NULL dalam kueri ini, dan, seperti yang kita ketahui, kondisi tersebut tidak diindeks (Anda tidak dapat menggunakan indeks dalam kasus ini).  Plus, hanya ada dua kondisi dari jenis kesetaraan (oleh ID_PROCESSING dan STATUS). <br><br>  Mungkin, pengembang yang akan melihat permintaan ini, pertama-tama akan menyarankan untuk membuat indeks pada ID_PROCESSING dan STATUS.  Tetapi mengingat jumlah data yang akan dipilih (akan ada banyak dari mereka), solusi ini tidak berfungsi. <br><br>  Namun, permintaan tersebut menghabiskan banyak sumber daya, yang berarti bahwa sesuatu harus dilakukan untuk membuatnya bekerja lebih cepat.  Mari kita coba mencari tahu alasannya. <br><img src="https://habrastorage.org/webt/wt/s4/cx/wts4cxw4pwappessb8lypge_uzg.png"><br><br>  Statistik di atas adalah untuk 1 hari, yang menunjukkan bahwa permintaan diluncurkan setiap 5 menit.  Konsumsi sumber daya utama adalah CPU dan pembacaan disk.  Di bawah ini pada grafik dengan statistik jumlah permintaan dimulai, dapat dilihat bahwa semuanya teratur - jumlah awal hampir tidak berubah dari waktu ke waktu - situasi yang cukup stabil. <br><img src="https://habrastorage.org/webt/5x/09/ge/5x09gen-19peucgd4eu430ichrq.png"><br><br>  Dan jika Anda melihat lebih jauh, Anda dapat melihat bahwa waktu permintaan terkadang berubah cukup kuat - beberapa kali, yang sudah signifikan. <br><img src="https://habrastorage.org/webt/ue/tj/mx/uetjmxbf2hbrv6kvzojoshoisyy.png"><br><br>  Mari kita cari tahu selanjutnya. <br><br>  Oracle Enterprise Manager memiliki utilitas Pemantauan SQL.  Dengan utilitas ini Anda dapat melihat secara real time konsumsi sumber daya berdasarkan permintaan. <br><img src="https://habrastorage.org/webt/ap/j6/k-/apj6k--jewoeighhu8_7edfkiu8.png"><br><br>  Laporan di atas untuk permintaan yang bermasalah.  Pertama-tama, kita harus tertarik pada fakta bahwa INDEX RANGE SCAN (bottom line) di kolom Actual Rows menunjukkan 17 juta baris.  Mungkin layak dipertimbangkan. <br><br>  Jika kita melihat lebih jauh pada rencana implementasi, ternyata setelah item berikutnya dalam rencana, dari 17 juta baris ini, hanya tersisa 1705. Pertanyaannya adalah, mengapa 17 juta dipilih?  Sekitar 0,01% tetap dalam sampel akhir, yaitu <strong>, jelas tidak efisien, pekerjaan yang tidak perlu dilakukan</strong> .  Apalagi pekerjaan ini dilakukan setiap 5 menit.  Inilah masalahnya!  Oleh karena itu, permintaan ini mengenai kueri teratas. <br><br>  Mari kita coba selesaikan masalah non-sepele ini.  Indeks yang memohon sendiri pada awalnya tidak efisien, jadi Anda harus membuat sesuatu yang rumit dan mengalahkan kondisi IS NULL. <br><br><h4>  Indeks baru <br></h4><br>  Kami berkonsultasi dengan pengembang, berpikir, dan sampai pada keputusan ini: kami membuat indeks fungsional di mana ada kolom ID_PROCESSING, yang dengan kondisi kesetaraan dalam permintaan, dan kami memasukkan semua bidang lain sebagai argumen fungsi ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> gc.loy$barcod_unload_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> gc.loy$barcodes (gc.loy_barcodes_ic_unload(id_rec_out, barcode, id_card, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>), id_processing);  function loy_barcodes_ic_unload( pIdRecOut in loy$barcodes.id_rec_out%type, pBarcode in loy$barcodes.barcode%type, pIdCard in loy$barcodes.id_card%type, pStatus in loy$barcodes.status%type) return varchar2 deterministic is vRes varchar2(1) := ''; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pIdRecOut <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pBarcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pIdCard <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pStatus = <span class="hljs-string"><span class="hljs-string">'U'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vRes := pStatus; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; return vRes; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> loy_barcodes_ic_unload;</code> </pre><br>  Fungsi ini adalah tipe deterministik, yaitu, pada set parameter yang sama ia selalu memberikan jawaban yang sama.  Kami memastikan bahwa fungsi ini selalu selalu mengembalikan satu nilai - dalam hal ini "U".  Ketika semua persyaratan ini terpenuhi, "U" dikeluarkan, saat tidak terpenuhi - NULL.  Indeks fungsional semacam itu memungkinkan untuk memfilter data secara efektif. <br><br>  Penerapan indeks ini menghasilkan hasil sebagai berikut: <br><br><img src="https://habrastorage.org/webt/xh/wj/nb/xhwjnbiaw-hvj7uumjpwr9uu-mi.png"><br><br>  Di sini, satu kolom adalah satu snapshot, mereka dilakukan setiap setengah jam dari database.  Kami telah mencapai tujuan kami dan indeks ini sangat efektif.  Mari kita lihat karakteristik kuantitatif: <br><br><table width="408"><tbody><tr><td width="408" colspan="3">  Statistik permintaan rata-rata <br><br></td></tr><tr><td width="174"></td><td width="124">  <strong>Sebelumnya</strong> <br><br></td><td width="110">  <strong>SETELAH</strong> <br><br></td></tr><tr><td width="174">  Waktu yang Berlalu, dtk <br><br></td><td width="124">  143.21 <br><br></td><td width="110">  60.7 <br><br></td></tr><tr><td width="174">  Waktu CPU, dtk <br><br></td><td width="124">  33.23 <br><br></td><td width="110">  45.38 <br><br></td></tr><tr><td width="174">  Buffer Mendapat Blok <br><br></td><td width="124">  6`288`237.67 <br><br></td><td width="110">  1`589`836 <br><br></td></tr><tr><td width="174">  Disk Membaca Blok <br><br></td><td width="124">  266`600.33 <br><br></td><td width="110">  2`680 <br><br></td></tr></tbody></table><br>  Waktu operasi berkurang 2,5 kali, dan konsumsi sumber daya (Buffer Gets) - sekitar 4. Jumlah blok data yang dibaca dari disk menurun sangat signifikan. <br><br><h3>  Hasil Optimasi Proaktif <br></h3><br>  Kami telah menerima: <br><br><ul><li>  mengurangi beban pada basis data; </li><li>  meningkatkan stabilitas database; </li><li>  pengurangan yang signifikan dalam jumlah insiden kinerja perangkat lunak. </li></ul><br>  <strong>Insiden kinerja menurun 10 kali lipat</strong> .  Ini adalah jumlah subyektif, sebelum insiden terjadi di kompleks RBS-Retail Bank 1-2 kali sebulan, tetapi sekarang kita secara praktis telah melupakannya. <br><br>  Ini menimbulkan pertanyaan - bagaimana dengan insiden kinerja perangkat lunak?  Kami tidak berurusan dengan mereka secara langsung? <br><br>  Kembali ke jadwal terakhir.  Jika Anda ingat, ada pemindaian penuh, itu diperlukan untuk menyimpan sejumlah besar blok dalam memori.  Karena permintaan dieksekusi secara teratur, semua blok ini disimpan dalam cache Oracle.  Ternyata jika saat ini beban tinggi terjadi di database, misalnya, seseorang mulai menggunakan memori secara aktif, Anda akan memerlukan cache untuk menyimpan blok data.  Dengan demikian, bagian dari data untuk permintaan kami akan ramai, yang berarti bahwa kami harus melakukan pembacaan fisik.  Jika Anda melakukan pembacaan fisik, waktu menjalankan kueri akan segera meningkat secara luar biasa. <br><br>  Pembacaan logis bekerja dengan memori, itu terjadi dengan cepat, dan setiap akses ke disk lambat (jika Anda melihat waktu, milidetik).  Jika Anda beruntung, dan ada data ini dalam cache sistem operasi atau dalam cache array, maka itu akan tetap puluhan mikrodetik.  Membaca dari cache Oracle jauh lebih cepat. <br><br>  Ketika kami menyingkirkan pemindaian penuh, kebutuhan untuk menyimpan sejumlah besar blok dalam cache (Buffer Cache) menghilang.  Ketika ada kekurangan sumber daya ini, permintaan lebih atau kurang stabil.  Tidak ada lagi paku besar seperti itu dengan indeks lama. <br><br>  <strong>Ringkasan Optimasi Proaktif:</strong> <br><br><ul><li>  Optimalisasi permintaan awal harus dilakukan pada server pengujian, untuk melihat bagaimana kueri dan logika bisnis mereka bekerja, agar tidak melakukan apa pun yang berlebihan.  Karya-karya ini tetap ada. </li><li>  Tetapi secara berkala, setiap beberapa bulan sekali, masuk akal untuk menghapus laporan tentang muatan penuh dari server, melakukan pencarian untuk pertanyaan dan operasi teratas dalam database dan mengoptimalkannya. </li></ul><br>  <strong>Ada banyak alat untuk mendapatkan statistik dalam database Oracle:</strong> <br><br><ul><li>  Laporan AWR (DBMS_WORKLOAD_REPOSITORY.awr_report_html); </li><li>  Enterprise Manager Cloud Control 12c (Detail SQL); </li><li>  Laporan Aktif Perincian SQL (DBMS_PERF.report_sql); </li><li>  Pemantauan SQL (tab dalam EMCC); </li><li>  Laporan Pemantauan SQL (DBMS_SQLTUNE.report_sql_monitor *). </li></ul><br>  Beberapa alat ini berfungsi di konsol, yaitu, mereka tidak terikat dengan Enterprise Manager. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh alat Oracle untuk mengumpulkan statistik</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d9/nk/rr/d9nkrrmgv-omldaqotcf1vxxub0.png"><br><br><ul><li>  Grafik atas menunjukkan berapa banyak sesi yang berfungsi dengan permintaan ini. </li><li>  Blok kiri menunjukkan dari mana permintaan ini diluncurkan, di mana modul itu berada. </li><li>  Kiri bawah - informasi tentang penggunaan kumpulan bersama. </li><li>  Di sebelah kanan, diagram menunjukkan acara tunggu yang ada di sistem.  Dalam hal ini, hanya CPU. </li><li>  Kanan bawah - yang paling menarik - piring dengan karakteristik kualitas yang paling penting ketika menganalisis masalah kinerja. </li></ul><br><img src="https://habrastorage.org/webt/h-/xw/en/h-xwenxxptrffbthe3bsj-dl0n4.png"><br><br>  SQL-Monitoring menunjukkan bagaimana semuanya terlihat secara real time (di mana roda gigi hijau berputar, kueri berfungsi sekarang). <br><img src="https://habrastorage.org/webt/ke/3n/vg/ke3nvg_q8afcbolkbcxdnkg3qaa.png"><br><br>  Di atas adalah isi internal laporan SQL-Monitoring.  Itu menunjukkan secara real time baris query mana yang dieksekusi dan berapa banyak baris yang dibacanya (kolom Baris Aktual).  Dalam hal ini, INDEX RANGE SCAN telah menghitung 5 juta. <br><br><img src="https://habrastorage.org/webt/ow/39/j1/ow39j1yvfaecppovtbgjb8tgsaq.png"><br><br>  Alat teks Laporan Pemantauan SQL, di mana ada beberapa informasi (tidak semua). <br><img src="https://habrastorage.org/webt/br/zu/py/brzupy-mengmdxvh_cppnsogl0w.png"><br></div></div><br>  <strong>Bonus:</strong> spesialis RNCO "Pusat Pembayaran" dan CFT dipersiapkan dengan baik untuk konferensi di Novosibirsk, membuat beberapa laporan yang berguna, dan juga mengorganisir radio keluar yang nyata.  Selama dua hari, para ahli, pembicara, dan penyelenggara berhasil mengunjungi radio CFT.  Anda dapat kembali ke musim panas Siberia dengan memasukkan entri, berikut adalah tautan ke blok: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes: pro dan kontra</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ilmu Data &amp; Pembelajaran Mesin</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOps</a> . <br><br><blockquote>  Di HighLoad ++ di Moskow, yang sudah 8 dan 9 November, akan ada hal yang lebih menarik.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Program ini</a> mencakup laporan tentang semua aspek pekerjaan pada proyek yang sangat banyak dimuat, kelas master, pertemuan dan acara dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mitra</a> yang akan berbagi saran ahli dan menemukan sesuatu yang mengejutkan.  Pastikan untuk menulis tentang yang paling menarik dan beri tahu di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buletin</a> , terhubung! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428491/">https://habr.com/ru/post/id428491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428477/index.html">Bagi yang memilih firewall</a></li>
<li><a href="../id428481/index.html">Kontrak digital: panduan singkat untuk BUKAN pengacara</a></li>
<li><a href="../id428485/index.html">Kebanyakan orang yang mengganggu adalah iklan yang tidak relevan dan penggunaan gadget di depan umum</a></li>
<li><a href="../id428487/index.html">Mengapa Ruby on Rails baik dan bagaimana mempercepat pengembangan</a></li>
<li><a href="../id428489/index.html">Ketipisan dan ketebalan ikon. Sketch Pro, fitur render, dan permainan dengan ketebalan garis</a></li>
<li><a href="../id428493/index.html">Git subrepo</a></li>
<li><a href="../id428495/index.html">Bagaimana saya melakukan simulator sepakbola selama 13 tahun</a></li>
<li><a href="../id428497/index.html">Noolite SUF-1-300 Kustom Wireless Dimmer</a></li>
<li><a href="../id428499/index.html">Raksasa biru menyeramkan dapat mengungkap rahasia evolusi bintang</a></li>
<li><a href="../id428501/index.html">DartUP: konferensi bahasa Rusia pertama tentang Dart dan Flutter 1 Desember di St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>