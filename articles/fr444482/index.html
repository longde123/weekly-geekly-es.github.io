<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¢ üçç üßùüèª Qu'est-ce qui gonfle la m√©moire dans Ruby? üèùÔ∏è ü•ù üññüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chez Phusion, nous avons un simple proxy HTTP multi-thread en Ruby (distribue les packages DEB et RPM). J'ai vu dessus une consommation de m√©moire de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qu'est-ce qui gonfle la m√©moire dans Ruby?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444482/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chez Phusion, nous avons</a> un simple proxy HTTP multi-thread en Ruby (distribue les packages DEB et RPM).  J'ai vu dessus une consommation de m√©moire de 1,3 Go.  Mais c'est fou pour un processus apatride ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/f7a/d2b/9baf7ad2bd3ecdfb0779482c018473eb.jpg"></div><br>  <i><font color="gray">Question: qu'est-ce que c'est?</font></i>  <i><font color="gray">R√©ponse: Ruby utilise la m√©moire au fil du temps!</font></i> <br><br>  Il s'av√®re que je ne suis pas seul dans ce probl√®me.  Les applications Ruby peuvent utiliser beaucoup de m√©moire.  Mais pourquoi?  Selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Heroku</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nate Burkopek</a> , les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ballonnements</a> sont principalement dus √† la fragmentation de la m√©moire et √† une distribution excessive des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tas</a> . <br><a name="habracut"></a><br>  Berkopek a conclu qu'il existe deux solutions: <br><br><ol><li>  Utilisez un allocateur de m√©moire compl√®tement diff√©rent de celui de la glibc - g√©n√©ralement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jemalloc</a> , ou: </li><li> D√©finissez la variable d'environnement magique <code>MALLOC_ARENA_MAX=2</code> . </li></ol><br>  Je m'inqui√®te de la description du probl√®me et des solutions propos√©es.  Il y a quelque chose qui ne va pas ici ... Je ne suis pas s√ªr que le probl√®me soit enti√®rement d√©crit correctement ou que ce soient les seules solutions disponibles.  Cela m'√©nerve aussi que beaucoup se r√©f√®rent √† jemalloc comme un bassin d'argent magique. <br><br>  <b>La magie n'est qu'une science que nous ne comprenons pas encore</b> .  J'ai donc fait un voyage de recherche pour d√©couvrir toute la v√©rit√©.  Cet article couvrira les sujets suivants: <br><br><ol><li>  Comment fonctionne l'allocation de m√©moire. <br></li><li>  Quelle est cette ¬´fragmentation¬ª et ¬´distribution excessive¬ª de la m√©moire dont tout le monde parle? <br></li><li>  Qu'est-ce qui cause une grande consommation de m√©moire?  La situation est-elle coh√©rente avec ce que les gens disent ou y a-t-il autre chose?  (spoiler: oui, il y a autre chose). <br></li><li>  Existe-t-il des solutions alternatives?  (spoiler: j'en ai trouv√© un). </li></ol><br>  <i>Remarque: cet article ne concerne que Linux et uniquement les applications Ruby multithread.</i> <br><br><h1>  Table des mati√®res </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Allocation de m√©moire Ruby: une introduction</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rubis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Allocateur de m√©moire syst√®me</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le noyau</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©finition de l'utilisation de la m√©moire</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce que la fragmentation?</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fragmentation au niveau du rubis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fragmentation d'allocation de m√©moire</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La fragmentation de la page du tas Ruby provoque-t-elle une surcharge de la m√©moire?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âtude de fragmentation d'allocation de m√©moire</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Allocation de m√©moire excessive et glibc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visualisation des tas de syst√®me</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tour de magie: circoncision</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source du visualiseur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Et la performance?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Besoin de plus de tests.</a> </li></ul></li></ul><br><a name="1"></a><h1>  Allocation de m√©moire Ruby: une introduction </h1><br>  Ruby alloue de la m√©moire √† trois niveaux, de haut en bas: <br><br><ol><li>  Interpr√®te Ruby qui g√®re les objets Ruby. <br></li><li>  La biblioth√®que d'allocateurs de m√©moire du syst√®me d'exploitation. <br></li><li>  Le noyau. </li></ol><br>  Passons en revue chaque niveau. <br><br><a name="1_1"></a><h3>  Rubis </h3><br>  De son c√¥t√©, Ruby organise les objets dans des zones de m√©moire appel√©es <i>pages de tas Ruby</i> .  Une telle page de segment est divis√©e en emplacements de m√™me taille, o√π un objet occupe un emplacement.  Que ce soit une cha√Æne, une table de hachage, un tableau, une classe ou autre chose, il occupe un emplacement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/155/0be/2d61550be208df42ad3052ca1f821807.png"></div><br><br>  Les emplacements sur la page de tas peuvent √™tre occup√©s ou libres.  Lorsque Ruby s√©lectionne un nouvel objet, il essaie imm√©diatement d'occuper un emplacement libre.  S'il n'y a pas d'emplacements libres, une nouvelle page de tas sera mise en √©vidence. <br><br>  L'emplacement est petit, environ 40 octets.  De toute √©vidence, certains objets ne rentreront pas dedans, par exemple, des lignes de 1 Mo.  Ruby stocke ensuite les informations ailleurs en dehors de la page de segment de m√©moire et place un pointeur sur cette zone de m√©moire externe dans l'emplacement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/e96/1c6/1e5e961c6c90ed1cd17daa8ab19d8212.png"></div><br>  <i><font color="gray">Les donn√©es qui ne tiennent pas dans l'emplacement sont stock√©es en dehors de la page de segment de m√©moire.</font></i>  <i><font color="gray">Ruby place un pointeur sur ces donn√©es externes dans le slot</font></i> <br><br>  Les pages de segment Ruby et toutes les zones de m√©moire externe sont allou√©es √† l'aide de l'allocateur de m√©moire syst√®me. <br><br><a name="1_2"></a><h3>  Allocateur de m√©moire syst√®me </h3><br>  L'allocateur de m√©moire du syst√®me d'exploitation fait partie de la glibc (runtime C).  Il est utilis√© par presque toutes les applications, pas seulement Ruby.  Il a une API simple: <br><br><ul><li>  La m√©moire est allou√©e en appelant <code>malloc(size)</code> .  Vous lui donnez le nombre d'octets que vous souhaitez allouer et il renvoie soit l'adresse d'allocation, soit une erreur. </li><li>  La m√©moire allou√©e est lib√©r√©e en appelant <code>free(address)</code> . </li></ul><br>  Contrairement √† Ruby, o√π des emplacements de m√™me taille sont allou√©s, l'allocateur de m√©moire traite les demandes d'allocation de m√©moire de n'importe quelle taille.  Comme vous l'apprendrez plus tard, ce fait entra√Æne certaines complications. <br><br>  √Ä son tour, l'allocateur de m√©moire acc√®de √† l'API du noyau.  Cela prend des morceaux de m√©moire beaucoup plus importants au noyau que ne le demandent ses propres abonn√©s, car l'appel du noyau est cher et l'API du noyau a une limitation: elle ne peut allouer de la m√©moire que par multiples de 4 Ko. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/dba/21a/323dba21a7b5ad2df8e1f9335d6b7c11.png"></div><br>  <i><font color="gray">L'allocateur de m√©moire alloue de gros morceaux - on les appelle des tas de syst√®me - et partage leur contenu pour satisfaire les demandes des applications</font></i> <br><br>  La zone de m√©moire que l'allocateur de m√©moire alloue √† partir du noyau s'appelle le tas.  Notez que cela n'a rien √† voir avec les pages du tas Ruby, donc pour plus de clart√©, nous utiliserons le terme <i>tas syst√®me</i> . <br><br>  L'allocateur de m√©moire affecte ensuite des parties des tas du syst√®me √† ses appelants jusqu'√† ce qu'il y ait de l'espace libre.  Dans ce cas, l'allocateur de m√©moire alloue un nouveau segment syst√®me √† partir du noyau.  Ceci est similaire √† la fa√ßon dont Ruby s√©lectionne les objets dans les pages d'un tas Ruby. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/f81/c11/453f81c11aaadb818ecdcf798112db99.png"></div><br>  <i><font color="gray">Ruby alloue de la m√©moire √† partir de l'allocateur de m√©moire, qui √† son tour alloue de la m√©moire √† partir du noyau</font></i> <br><br><a name="1_3"></a><h3>  Le noyau </h3><br>  Le noyau ne peut allouer de la m√©moire qu'en unit√©s de 4 Ko.  Un tel bloc 4K est appel√© une page.  Pour √©viter toute confusion avec les pages de tas Ruby, pour plus de clart√©, nous utiliserons le terme <i>page syst√®me</i> (page OS). <br><br>  La raison est difficile √† expliquer, mais c'est ainsi que fonctionnent tous les noyaux modernes. <br><br>  L'allocation de m√©moire via le noyau a un impact significatif sur les performances, c'est pourquoi les allocateurs de m√©moire tentent de minimiser le nombre d'appels du noyau. <br><br><a name="1_4"></a><h3>  D√©finition de l'utilisation de la m√©moire </h3><br>  Ainsi, la m√©moire est allou√©e √† plusieurs niveaux, et chaque niveau alloue plus de m√©moire qu'il n'en a r√©ellement besoin.  Les pages de tas Ruby peuvent avoir des emplacements libres, ainsi que des tas de syst√®me.  Par cons√©quent, la r√©ponse √† la question "Quelle quantit√© de m√©moire est utilis√©e?"  d√©pend compl√®tement du niveau que vous demandez! <br><br>  Des outils comme <code>top</code> ou <code>ps</code> montrent l'utilisation de la m√©moire du point de vue du <b>noyau</b> .  Cela signifie que les niveaux sup√©rieurs doivent fonctionner de concert pour lib√©rer la m√©moire du point de vue du noyau.  Comme vous l'apprendrez plus tard, c'est plus difficile qu'il n'y para√Æt. <br><br><a name="2"></a><h1>  Qu'est-ce que la fragmentation? </h1><br>  La fragmentation de la m√©moire signifie que les allocations de m√©moire sont dispers√©es de mani√®re al√©atoire.  Cela peut provoquer des probl√®mes int√©ressants. <br><br><a name="2_1"></a><h3>  Fragmentation au niveau du rubis </h3><br>  Consid√©rez la collecte des ordures Ruby.  Le ramasse-miettes d'un objet signifie marquer l'emplacement de page de tas Ruby comme libre, ce qui permet de le r√©utiliser.  Si la page enti√®re du tas Ruby se compose uniquement d'emplacements libres, sa page enti√®re peut √™tre lib√©r√©e dans l'allocateur de m√©moire (et, √©ventuellement, dans le noyau). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/cde/97d/27bcde97d27e6aeed3dc2020a4eda766.png"></div><br><br>  Mais que se passe-t-il si tous les emplacements ne sont pas gratuits?  Que se passe-t-il si nous avons plusieurs pages du tas Ruby et que le garbage collector lib√®re des objets √† diff√©rents endroits, de sorte qu'√† la fin il y a beaucoup de slots libres, mais sur des pages diff√©rentes?  Dans cette situation, Ruby a des emplacements libres pour placer des objets, mais l'allocateur de m√©moire et le noyau continueront d'allouer de la m√©moire! <br><br><a name="2_2"></a><h3>  Fragmentation d'allocation de m√©moire </h3><br>  L'allocateur de m√©moire a un probl√®me similaire mais compl√®tement diff√©rent.  Il n'a pas besoin d'effacer imm√©diatement tous les tas du syst√®me.  Th√©oriquement, il peut lib√©rer n'importe quelle page syst√®me unique.  Mais comme l'allocateur de m√©moire traite des allocations de m√©moire de taille arbitraire, il peut y avoir plusieurs allocations sur la page syst√®me.  Il ne peut pas lib√©rer la page syst√®me tant que toutes les s√©lections ne sont pas lib√©r√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76b/723/850/76b72385026fa24bd18b7db324d7353b.png"></div><br><br>  Pensez √† ce qui se passe si nous avons une allocation de 3 Ko, ainsi qu'une allocation de 2 Ko, divis√©e en deux pages syst√®me.  Si vous lib√©rez les 3 premiers Ko, les deux pages syst√®me resteront partiellement occup√©es et ne pourront pas √™tre lib√©r√©es. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/cf1/70f/cc2cf170facbc6bca673014e33389606.png"></div><br><br>  Par cons√©quent, si les circonstances √©chouent, il y aura beaucoup d'espace libre sur les pages syst√®me, mais elles ne seront pas enti√®rement lib√©r√©es. <br><br>  Pire encore: que se passe-t-il s'il y a beaucoup de places libres, mais qu'aucune n'est assez grande pour satisfaire une nouvelle demande d'allocation?  L'allocateur de m√©moire devra allouer un tout nouveau tas syst√®me. <br><br><a name="3"></a><h1>  La fragmentation de la page du tas Ruby provoque-t-elle une surcharge de la m√©moire? </h1><br>  Il est probable que la fragmentation entra√Æne une surutilisation de la m√©moire dans Ruby.  Si oui, laquelle des deux fragmentations est la plus nuisible?  C'est ... <br><br><ol><li>  Fragmentation de la page du tas de rubis?  Ou <br></li><li>  Fragmentation de l'allocateur de m√©moire? </li></ol><br>  La premi√®re option est assez simple √† v√©rifier.  Ruby fournit deux API: <code>ObjectSpace.memsize_of_all</code> et <code>GC.stat</code> .  Gr√¢ce √† ces informations, vous pouvez calculer toute la m√©moire re√ßue par Ruby de l'allocateur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb8/f7e/30e/cb8f7e30e363d2fa57f0fc37b84183fe.png"></div><br><br>  <code>ObjectSpace.memsize_of_all</code> renvoie la m√©moire occup√©e par tous les objets Ruby actifs.  Autrement dit, tout l'espace dans leurs emplacements et toutes les donn√©es externes.  Dans le diagramme ci-dessus, il s'agit de la taille de tous les objets bleus et oranges. <br><br>  <code>GC.stat</code> permet de conna√Ætre la taille de tous les emplacements libres, c'est-√†-dire toute la zone grise dans l'illustration ci-dessus.  Voici l'algorithme: <br><br><pre> <code class="cpp hljs">GC.stat[:heap_free_slots] * GC::INTERNAL_CONSTANTS[:RVALUE_SIZE]</code> </pre> <br>  Pour les r√©sumer, c'est toute la m√©moire que Ruby conna√Æt, et cela implique de fragmenter les pages du tas Ruby.  Si, du point de vue du noyau, l'utilisation de la m√©moire est plus √©lev√©e, alors la m√©moire restante va quelque part en dehors du contr√¥le de Ruby, par exemple, vers des biblioth√®ques tierces ou la fragmentation. <br><br>  J'ai √©crit un programme de test simple qui cr√©e un tas de threads, chacun s√©lectionnant des lignes dans une boucle.  Voici le r√©sultat apr√®s un certain temps: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/859/2fc/a4e8592fc1d2edf2f11957844d33e55d.png"></div><br><br>  c'est ... juste ... fou! <br><br>  Le r√©sultat montre que Ruby a un effet si faible sur la quantit√© totale de m√©moire utilis√©e, peu importe si les pages du tas Ruby sont fragment√©es ou non. <br><br>  Faut chercher le coupable ailleurs.  Au moins maintenant, nous savons que Ruby n'est pas √† bl√¢mer. <br><br><a name="4"></a><h1>  √âtude de fragmentation d'allocation de m√©moire </h1><br>  Un autre suspect probable est un allocateur de m√©moire.  √Ä la fin, Nate Berkopek et Heroku ont remarqu√© que s'occuper de l'allocateur de m√©moire (soit un remplacement Jemalloc complet ou la d√©finition de la variable d'environnement magique <code>MALLOC_ARENA_MAX=2</code> ) r√©duit consid√©rablement l'utilisation de la m√©moire. <br><br>  Voyons d'abord ce que fait <code>MALLOC_ARENA_MAX=2</code> et pourquoi cela aide.  Ensuite, nous examinons la fragmentation au niveau du distributeur. <br><br><a name="4_1"></a><h3>  Allocation de m√©moire excessive et glibc </h3><br>  La raison <code>MALLOC_ARENA_MAX=2</code> laquelle <code>MALLOC_ARENA_MAX=2</code> aide est √† <code>MALLOC_ARENA_MAX=2</code> multithreading.  Lorsque plusieurs threads tentent simultan√©ment d'allouer de la m√©moire √† partir du m√™me tas syst√®me, ils se battent pour l'acc√®s.  Un seul thread √† la fois peut recevoir de la m√©moire, ce qui r√©duit les performances de l'allocation de m√©moire multi-thread. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a40/99c/65b/a4099c65b73541efa05c38008fa0e181.png"></div><br>  <i><font color="gray">Un seul thread √† la fois peut fonctionner avec le tas syst√®me.</font></i>  <i><font color="gray">Dans les t√¢ches multithreads, un conflit survient et, par cons√©quent, les performances diminuent</font></i> <br><br>  Dans l'allocateur de m√©moire pour un tel cas, il y a optimisation.  Il essaie de cr√©er plusieurs tas de syst√®me et de les affecter √† diff√©rents threads.  La plupart du temps, un thread ne fonctionne qu'avec son propre segment de m√©moire, √©vitant les conflits avec d'autres threads. <br><br>  En fait, le nombre maximum de segments syst√®me allou√©s de cette mani√®re est par d√©faut √©gal au nombre de processeurs virtuels multipli√© par 8. Autrement dit, dans un syst√®me dual-core avec deux hyper-threads, chacun produit <code>2 * 2 * 8 = 32</code> segments syst√®me!  C'est ce que j'appelle <b>une distribution excessive</b> . <br><br>  Pourquoi le multiplicateur par d√©faut est-il si grand?  Parce que le principal d√©veloppeur de l'allocateur de m√©moire est Red Hat.  Leurs clients sont de grandes entreprises avec des serveurs puissants et une tonne de RAM.  L'optimisation ci-dessus vous permet d'augmenter les performances moyennes de multithreading de 10% en raison d'une augmentation significative de l'utilisation de la m√©moire.  Pour les clients de Red Hat, c'est un bon compromis.  Pour la plupart des autres - √† peine. <br><br>  Nate dans son blog et son article Heroku affirment que l'augmentation du nombre de tas de syst√®me augmente la fragmentation et citent la documentation officielle.  La variable <code>MALLOC_ARENA_MAX</code> r√©duit le nombre maximal de <code>MALLOC_ARENA_MAX</code> syst√®me allou√©s pour le multithreading.  Par cette logique, il r√©duit la fragmentation. <br><br><a name="4_2"></a><h3>  Visualisation des tas de syst√®me </h3><br>  La d√©claration de Nate et Heroku est-elle vraie que l'augmentation du nombre de tas de syst√®me augmente la fragmentation?  En fait, y a-t-il un probl√®me de fragmentation au niveau de l'allocateur de m√©moire?  Je ne voulais prendre aucune de ces hypoth√®ses pour acquise, alors j'ai commenc√© l'√©tude. <br><br>  Malheureusement, il n'y a pas d'outils pour visualiser les tas de syst√®me, <b>j'ai</b> donc <b>√©crit moi-m√™me un tel visualiseur</b> . <br><br>  Tout d'abord, vous devez en quelque sorte conserver le sch√©ma de distribution des tas de syst√®me.  J'ai √©tudi√© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source de l'allocateur de m√©moire</a> et regard√© comment il repr√©sente en interne la m√©moire.  Il a ensuite √©crit une biblioth√®que qui it√®re sur ces structures de donn√©es et √©crit le sch√©ma dans un fichier.  Enfin, il a √©crit un outil qui prend un tel fichier en entr√©e et compile la visualisation en images HTML et PNG ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code source</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/adb/064/309adb06474b3ec49bb2d0d6622bbb48.png"></div><br><br>  Voici un exemple de visualisation d'un segment de syst√®me sp√©cifique (il y en a beaucoup plus).  Les petits blocs de cette visualisation repr√©sentent des pages syst√®me. <br><br><ul><li>  Les zones rouges sont des cellules de m√©moire utilis√©es. </li><li>  Les gris sont des zones libres qui ne sont pas restitu√©es au c≈ìur. </li><li>  Les zones blanches sont lib√©r√©es pour le noyau. </li></ul><br>  Les conclusions suivantes peuvent √™tre tir√©es de la visualisation: <br><br><ol><li>  Il y a une certaine fragmentation.  Les taches rouges sont dispers√©es dans la m√©moire et certaines pages syst√®me ne sont qu'√† moiti√© rouges. <br></li><li>  √Ä ma grande surprise, la <i>plupart des</i> tas de syst√®me contiennent une quantit√© importante de pages syst√®me enti√®rement gratuites (grises)! </li></ol><br>  Et puis il m'est apparu: <br><br>  <i><b>Bien que la fragmentation reste un probl√®me, ce n'est pas la question!</b></i> <br><br>  Au contraire, le probl√®me est beaucoup de gris: cet allocateur de m√©moire <i>ne renvoie pas de m√©moire au noyau</i> ! <br><br>  Apr√®s avoir r√©examin√© le code source de l'allocateur de m√©moire, il s'est av√©r√© que par d√©faut, il n'envoie que les pages syst√®me au noyau √† la fin du tas syst√®me, et m√™me <i>rarement</i> .  Probablement, un tel algorithme est impl√©ment√© pour des raisons de performances. <br><br><a name="5"></a><h1>  Tour de magie: circoncision </h1><br>  Heureusement, j'ai trouv√© une astuce.  Il y a une interface de programmation qui forcera l'allocateur de m√©moire √† lib√©rer pour le noyau non seulement la derni√®re, mais <i>toutes les</i> pages syst√®me pertinentes.  Il s'appelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">malloc_trim</a> . <br><br>  Je connaissais cette fonction, mais je ne pensais pas qu'elle √©tait utile, car le manuel dit ce qui suit: <br><br><blockquote>  La fonction malloc_trim () essaie de lib√©rer de la m√©moire libre en haut du tas. </blockquote><br>  <b>Le manuel est faux!</b>  L'analyse du code source indique que le programme lib√®re toutes les pages syst√®me pertinentes, pas seulement le haut. <br><br>  Que se passe-t-il si cette fonction est appel√©e pendant la r√©cup√©ration de place?  J'ai modifi√© le code source de Ruby 2.6 pour appeler <code>malloc_trim()</code> dans la fonction gc_start de gc.c, par exemple: <br><br><pre> <code class="cpp hljs">gc_prof_timer_start(objspace); { gc_marks(objspace, do_full_mark); <span class="hljs-comment"><span class="hljs-comment">// BEGIN MODIFICATION if (do_full_mark) { malloc_trim(0); } // END MODIFICATION } gc_prof_timer_stop(objspace);</span></span></code> </pre> <br>  Et voici les r√©sultats des tests: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/cfc/063/1f4cfc063a1c0672a80ed11baec2c323.png"></div><br><br>  <b>Quelle grande diff√©rence!</b>  Un simple patch a r√©duit la consommation de m√©moire √† presque <code>MALLOC_ARENA_MAX=2</code> . <br><br>  Voici √† quoi cela ressemble dans la visualisation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/410/594/9de410594884baa131d3b8e52d7c6656.png"></div><br><br>  Nous voyons de nombreuses zones blanches qui correspondent aux pages syst√®me lib√©r√©es dans le noyau. <br><br><a name="6"></a><h1>  Conclusion </h1><br>  Il s'est av√©r√© que la fragmentation n'avait rien √† voir avec cela.  La d√©fragmentation est toujours utile, mais le principal probl√®me est que l'allocateur de m√©moire n'aime pas lib√©rer de la m√©moire dans le noyau. <br><br>  Heureusement, la solution s'est av√©r√©e tr√®s simple.  L'essentiel √©tait de trouver la cause profonde. <br><br><a name="6_1"></a><h3>  Code source du visualiseur </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source</a> <br><br><a name="6_2"></a><h3>  Et la performance? </h3><br>  La performance est rest√©e l'une des principales pr√©occupations.  L'appel de <code>malloc_trim()</code> ne peut pas √™tre <code>malloc_trim()</code> gratuitement, mais selon le code, l'algorithme fonctionne en temps lin√©aire.  Je me suis donc tourn√© vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Noah Gibbs</a> , qui a lanc√© la r√©f√©rence Rails Ruby Bench.  √Ä ma grande surprise, le patch a provoqu√© une l√©g√®re <b>augmentation des</b> performances. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/115/88c/7e511588c662a60e0f8a82556b2e1988.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/c8e/f91/474c8ef919bf360ecf45f365e1a87ab0.jpg"></div><br><br>  Cela m'a √©poustoufl√©.  L'effet est incompr√©hensible, mais les nouvelles sont bonnes. <br><br><a name="6_3"></a><h3>  Besoin de plus de tests. </h3><br>  Dans le cadre de cette √©tude, seul un nombre limit√© de cas a √©t√© v√©rifi√©.  On ne sait pas quel est l'impact sur les autres charges de travail.  Si vous souhaitez aider avec les tests, veuillez <a href="">me contacter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444482/">https://habr.com/ru/post/fr444482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444470/index.html">20 habitudes pour l'hygi√®ne de l'attention: comment utiliser la technologie, mais ne pas les laisser prendre leur temps et leur attention</a></li>
<li><a href="../fr444472/index.html">√âmulation de services Web Amazon dans un processus JVM. √âviter Roskomnadzor et acc√©l√©rer le d√©veloppement et les tests</a></li>
<li><a href="../fr444474/index.html">Construction de la ligne de communication Sakhalin-Kuril. Tour Segero - T√©l√©ph√©rique</a></li>
<li><a href="../fr444476/index.html">Concours de RUSNANO: suivez un cours en ligne sur la micro√©lectronique moderne, puis une visite pratique avec des FPGA, obtenez un prix</a></li>
<li><a href="../fr444480/index.html">Comment r√©duire d'un tiers le poids d'un √©l√©ment structurel d'avion</a></li>
<li><a href="../fr444484/index.html">Estimation des conditions de d√©veloppement et de test des t√¢ches (non n√©cessaire)</a></li>
<li><a href="../fr444486/index.html">Le projet SIRIUS-19 est une simulation de quatre mois d'une exp√©dition sur la Lune dans un complexe au sol √† Moscou</a></li>
<li><a href="../fr444490/index.html">J'ai scann√© l'Ukraine</a></li>
<li><a href="../fr444492/index.html">Des aventures √† l'improviste</a></li>
<li><a href="../fr444494/index.html">La Moto Volante (Lazareth LMV 496) - moto transformateur volant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>