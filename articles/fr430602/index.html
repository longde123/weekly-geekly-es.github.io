<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕸️ 🛀🏼 🍣 Vulnérabilités dans Etherium Smart Contracts. Exemples de code 👷 👨🏾‍✈️ 🍙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avec ce billet, je commence une série d'articles sur la sécurité des contrats intelligents Ethereum. Je pense que ce sujet est très pertinent, car le ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vulnérabilités dans Etherium Smart Contracts. Exemples de code</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430602/">  Avec ce billet, je commence une série d'articles sur la sécurité des contrats intelligents Ethereum.  Je pense que ce sujet est très pertinent, car le nombre de développeurs augmente comme une avalanche, et il n'y a personne à sauver du "rake".  Au revoir - traductions ... <br><br><h3>  1. Analyse des contrats Live Ethereum pour une erreur d'envoi non contrôlé </h3><br><p>  Original - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Numérisation des contrats Ethereum en direct pour le "Envoi non contrôlé ..."</a> </p><br>  Auteurs: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zikai Alex Wen</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrew Miller</a> <br><br><p> La programmation de contrat intelligent Ethereum est connue pour être sujette aux erreurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[1]</a> .  Récemment, nous avons vu que plusieurs <br>  les contrats intelligents haut de gamme tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">King of the Ether</a> et <a href="">The DAO-1.0</a> contenaient des vulnérabilités causées par des erreurs de programmation. <br><br>  Depuis mars 2015, les programmeurs de contrats intelligents ont été avertis des dangers de programmation spécifiques qui peuvent survenir lorsque les contrats s'envoient des messages <a href="">[6]</a> . <br><br>  Plusieurs guides de programmation recommandent comment éviter les erreurs courantes (dans les livres blancs Ethereum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[3]</a> et dans un guide indépendant de UMD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[2]</a> ).  Bien que ces dangers soient suffisamment compréhensibles pour les éviter, les conséquences d'une telle erreur sont terribles: l'argent peut être bloqué, perdu ou volé. <br><br>  Les erreurs résultant de ces dangers sont-elles courantes?  Existe-t-il des contrats de blockchain Ethereum plus vulnérables mais vivants?  Dans cet article, nous répondons à cette question en analysant les contrats sur la blockchain live Ethereum à l'aide du nouvel outil d'analyse que nous avons développé. <br></p><br><a name="habracut"></a><h3>  Quelle est l'erreur d'envoi non contrôlé? <br></h3><br><p>  Pour envoyer un contrat de temps d'antenne à une autre adresse, le moyen le plus simple consiste à utiliser le mot clé <strong>send</strong> .  Cela agit comme une méthode définie pour chaque objet.  Par exemple, l'extrait de code suivant peut être trouvé dans un contrat intelligent qui implémente un jeu de société. <br></p><br><p></p><pre><code class="plaintext hljs">/*** Listing 1 ***/ if (gameHasEnded &amp;&amp; !( prizePaidOut ) ) { winner.send(1000); //    prizePaidOut = True; }</code> </pre> <br><p>  Le problème ici est que la méthode d' <strong>envoi</strong> peut échouer.  Si cela ne fonctionne pas, le gagnant ne recevra pas l'argent, mais la variable prizePaidOut sera définie sur True. <br><br>  Il existe deux cas différents où la fonction <strong>winner.send ()</strong> peut échouer.  Nous analyserons la différence entre eux plus tard.  Le premier cas est que l'adresse du <strong>gagnant</strong> est un contrat (pas un compte utilisateur), et le code de ce contrat lève une exception (par exemple, s'il utilise trop de «gaz»).  Dans l’affirmative, il s’agit peut-être dans ce cas d’une «erreur du gagnant».  Le deuxième cas est moins évident.  La machine virtuelle Ethereum dispose d'une ressource limitée appelée « <strong>callstack</strong> » (profondeur de pile d'appels), et cette ressource peut être utilisée par un autre code de contrat qui a été précédemment exécuté dans une transaction.  Si la <strong>pile d'appels</strong> a déjà été utilisée au moment où la commande d' <strong>envoi</strong> est exécutée, la commande échouera, quelle que soit la façon dont le <strong>gagnant est</strong> déterminé.  Le prix du gagnant sera détruit sans faute de sa part! </p><br><br>  Comment éviter cette erreur? <br><br>  La documentation Ethereum contient un bref avertissement concernant ce danger potentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[3]</a> : "Il existe un certain danger lors de l'utilisation de l' <strong>envoi - la</strong> transmission échoue si la profondeur de la pile d'appels est de 1024 (cela peut toujours être causé par l'appelant), et échoue également si le destinataire "gas" se termine. Par conséquent, pour assurer une diffusion en toute sécurité, vérifiez toujours la valeur de retour de l' <strong>envoi,</strong> ou mieux encore: utilisez un modèle dans lequel le destinataire retire de l'argent. " <br><p>  Deux phrases.  La première consiste à vérifier la valeur de retour d' <strong>envoi</strong> pour voir si elle s'est terminée avec succès.  Si ce n'est pas le cas, lancez une exception pour restaurer l'état. </p><br><p></p><pre> <code class="plaintext hljs"> /*** Listing 2 ***/ if (gameHasEnded &amp;&amp; !( prizePaidOut ) ) { if (winner.send(1000)) prizePaidOut = True; else throw; }</code> </pre> <br><p>  C'est une solution adéquate pour l'exemple actuel, mais pas toujours la bonne décision.  Supposons que nous modifions notre exemple de sorte que lorsque le jeu est terminé, le gagnant et le perdant annulent leur fortune.  Une application évidente d'une solution «formelle» serait la suivante: <br></p><br><p></p><pre> <code class="plaintext hljs">/*** Listing 3 ***/ if (gameHasEnded &amp;&amp; !( prizePaidOut ) ) { if (winner.send(1000) &amp;&amp; loser.send(10)) prizePaidOut = True; else throw; }</code> </pre> <br><p>  Cependant, c'est une erreur car elle introduit une vulnérabilité supplémentaire.  Bien que ce code protège le <strong>gagnant</strong> d'une attaque par <strong>pile d'appels</strong> , il rend également le <strong>gagnant</strong> et le <strong>perdant</strong> vulnérables l'un à l'autre.  Dans ce cas, nous voulons empêcher une attaque par <strong>pile d'appels</strong> , mais continuer l'exécution si la commande <strong>send</strong> échoue pour une raison quelconque. <br><br>  Par conséquent, même la meilleure meilleure pratique (recommandée dans notre Guide du programmeur Ethereum et Serpent, bien qu'elle s'applique également à Solidity), consiste à rechercher une ressource de <strong>pile d'appels</strong> .  Nous pouvons définir une macro <strong>callStackIsEmpty ()</strong> , qui retournera une erreur si et seulement si <strong>callstack est</strong> vide. </p><br><p></p><pre> <code class="plaintext hljs">/*** Listing 4 ***/ if (gameHasEnded &amp;&amp; !( prizePaidOut ) ) { if (callStackIsEmpty()) throw; winner.send(1000) loser.send(10) prizePaidOut = True; }</code> </pre> <br><p>  Encore mieux, la recommandation de la documentation Ethereum - «Utilisez un modèle dans lequel le destinataire prend l'argent» est un peu cryptique, mais a une explication.  La suggestion est de réorganiser votre code afin que l'effet de l'échec d' <strong>envoi</strong> soit isolé et n'affecte qu'un seul destinataire à la fois.  Voici un exemple de cette approche.  Cependant, cette astuce est également un anti-modèle.  Il accepte la responsabilité de vérifier la <strong>pile d'appels aux</strong> destinataires eux-mêmes, ce qui permet de tomber dans le même piège. <br></p><br><p></p><pre> <code class="plaintext hljs">/*** Listing 5 ***/ if (gameHasEnded &amp;&amp; !( prizePaidOut ) ) { accounts[winner] += 1000 accounts[loser] += 10 prizePaidOut = True; } ... function withdraw(amount) { if (accounts[msg.sender] &gt;= amount) { msg.sender.send(amount); accounts[msg.sender] -= amount; } }</code> </pre> <br><p>  De nombreux contrats intelligents hautement développés sont vulnérables.  La loterie du Roi de l'Air du Trône est le cas le plus connu de cette erreur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[4]</a> .  Cette erreur n'a été constatée que lorsque le montant de 200 éthers (d'une valeur supérieure à 2000 dollars américains au prix actuel) n'a pas pu obtenir le gagnant légitime de la loterie.  Le code correspondant dans King of the Ether est similaire au code de l'extrait 2. Heureusement, dans ce cas, le développeur du contrat a pu utiliser la fonction non liée dans le contrat comme une «dérogation manuelle» pour libérer les fonds bloqués.  Un administrateur moins scrupuleux pourrait utiliser la même fonction pour voler la diffusion! <br></p><cut></cut><br>  Suite de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyse des contrats Live Ethereum pour une erreur d'envoi non contrôlé.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2e partie</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430602/">https://habr.com/ru/post/fr430602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430580/index.html">Meilleurs livres sur le framework Django</a></li>
<li><a href="../fr430590/index.html">En Allemagne, a développé les exigences pour les routeurs domestiques</a></li>
<li><a href="../fr430592/index.html">Internet client dans une machine virtuelle isolée QEMU utilisant le tunneling de port sur un canal SPICE</a></li>
<li><a href="../fr430596/index.html">Comment préparer une stratégie produit? Guide du chef de produit</a></li>
<li><a href="../fr430600/index.html">Mars - du chocolat aux robots</a></li>
<li><a href="../fr430604/index.html">Technologies utilisées dans l'analyseur de code PVS-Studio pour rechercher des erreurs et des vulnérabilités potentielles</a></li>
<li><a href="../fr430606/index.html">Webinaire Group-IB: «Enquête judiciaire sur les artefacts RDP sous Windows»</a></li>
<li><a href="../fr430610/index.html">Comment se débarrasser de vos appareils électroniques en toute sécurité</a></li>
<li><a href="../fr430612/index.html">Comment, dans les années 80, les gens ont téléchargé des jeux de la radio</a></li>
<li><a href="../fr430614/index.html">Vendredi noir 2018 chez Madrobots.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>