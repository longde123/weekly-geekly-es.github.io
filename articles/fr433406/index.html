<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèª üêõ ‚òÇÔ∏è Pens√©e fonctionnelle. Partie 9 üîÅ ü§Ø üëàüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C'est d√©j√† la partie 9 d'une s√©rie d'articles sur la programmation fonctionnelle en F #! Je suis s√ªr que sur Habr√©, il n'y a pas beaucoup de cycles au...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pens√©e fonctionnelle. Partie 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433406/"><p>  C'est d√©j√† la partie 9 d'une s√©rie d'articles sur la programmation fonctionnelle en F #!  Je suis s√ªr que sur Habr√©, il n'y a pas beaucoup de cycles aussi longs.  Mais nous n'allons pas nous arr√™ter.  Aujourd'hui, nous allons parler des fonctions imbriqu√©es, des modules, des espaces de noms et du m√©lange des types et des fonctions dans les modules. </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Premi√®re partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deuxi√®me partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Troisi√®me partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quatri√®me partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cinqui√®me partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sixi√®me partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Septi√®me partie</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Huiti√®me partie</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p>  Vous savez maintenant comment d√©finir des fonctions, mais comment les organiser? </p><br><p>  F # a trois options: </p><br><ul><li>  les fonctions peuvent √™tre imbriqu√©es dans d'autres fonctions. </li><li>  au niveau de l'application, les fonctions de niveau sup√©rieur sont regroup√©es en ¬´modules¬ª. </li><li>  ou vous pouvez suivre une approche orient√©e objet et attacher des fonctions aux types comme m√©thodes. </li></ul><br><p>  Dans cet article, nous examinerons les deux premi√®res m√©thodes et la derni√®re dans la suivante. </p><br><h2>  Fonctions imbriqu√©es </h2><br><p>  En F #, vous pouvez d√©finir des fonctions √† l'int√©rieur d'autres fonctions.  C'est un bon moyen d'encapsuler des fonctions auxiliaires qui ne sont n√©cessaires que pour la fonction principale et ne doivent pas √™tre visibles de l'ext√©rieur. </p><br><p> Dans l'exemple ci-dessous, <code>add</code> imbriqu√© dans <code>addThreeNumbers</code> : </p><br><pre> <code class="plaintext hljs">let addThreeNumbers xyz = //     let add n = fun x -&gt; x + n //    x |&gt; add y |&gt; add z addThreeNumbers 2 3 4</code> </pre> <br><p>  Les fonctions imbriqu√©es peuvent acc√©der directement aux param√®tres parents, car elles sont dans sa port√©e. <br>  Ainsi, dans l'exemple ci-dessous, la fonction imbriqu√©e <code>printError</code> pas besoin de param√®tres, car  elle peut acc√©der directement √† <code>n</code> et <code>max</code> . </p><br><pre> <code class="plaintext hljs">let validateSize max n = //       let printError() = printfn "Oops: '%i' is bigger than max: '%i'" n max //    if n &gt; max then printError() validateSize 10 9 validateSize 10 11</code> </pre> <br><p>  Un mod√®le tr√®s courant est la fonction principale qui d√©finit la fonction d'aide r√©cursive imbriqu√©e, qui est appel√©e avec les valeurs initiales correspondantes. <br>  Voici un exemple d'un tel code: </p><br><pre> <code class="plaintext hljs">let sumNumbersUpTo max = //      let rec recursiveSum n sumSoFar = match n with | 0 -&gt; sumSoFar | _ -&gt; recursiveSum (n-1) (n+sumSoFar) //       recursiveSum max 0 sumNumbersUpTo 10</code> </pre> <br><p>  Essayez d'√©viter l'imbrication profonde, en particulier dans les cas d'acc√®s direct (pas sous forme de param√®tres) aux variables parentes. <br>  Les fonctions imbriqu√©es trop profond√©ment seront aussi difficiles √† comprendre que la pire de nombreuses branches imp√©ratives imbriqu√©es. </p><br><p>  Un exemple de comment <em>ne pas</em> faire: </p><br><pre> <code class="plaintext hljs">// wtf,    ? let fx = let f2 y = let f3 z = x * z let f4 z = let f5 z = y * z let f6 () = y * x f6() f4 y x * f2 x</code> </pre> <br><h2>  Modules </h2><br><p>  Un module est simplement un ensemble de fonctions regroup√©es, g√©n√©ralement parce qu'elles fonctionnent avec le ou les m√™mes types de donn√©es. </p><br><p>  Une d√©finition de module est tr√®s similaire √† une d√©finition de fonction.  Il commence par le mot-cl√© <code>module</code> , puis vient le signe <code>=</code> , suivi du contenu du module. <br>  Le contenu du module <em>doit</em> √™tre format√© avec un d√©calage, ainsi que les expressions dans la d√©finition des fonctions. </p><br><p>  D√©finition d'un module contenant deux fonctions: </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Si vous ouvrez ce code dans Visual Studio, lorsque vous passez la souris sur <code>add</code> vous pouvez voir le nom complet <code>add</code> , qui est en fait <code>MathStuff.add</code> , comme si <code>MastStuff</code> √©tait une classe et <code>add</code> √©tait une m√©thode. </p><br><p>  En fait, c'est exactement ce qui se passe.  Dans les coulisses, le compilateur F # cr√©e une classe statique avec des m√©thodes statiques.  L'√©quivalent C # ressemblerait √† ceci: </p><br><pre> <code class="plaintext hljs">static class MathStuff { static public int add(int x, int y) { return x + y; } static public int subtract(int x, int y) { return x - y; } }</code> </pre> <br><p>  Reconna√Ætre que les modules ne sont que des classes statiques et que les fonctions sont des m√©thodes statiques donnera une bonne compr√©hension du fonctionnement des modules en F #, car la plupart des r√®gles qui s'appliquent aux classes statiques s'appliquent √©galement aux modules. </p><br><p>  Et tout comme en C #, chaque fonction autonome doit faire partie de la classe, en F #, chaque fonction autonome <em>doit</em> faire partie du module. </p><br><h3>  Acc√®s aux fonctions en dehors du module </h3><br><p>  Si vous devez acc√©der √† une fonction √† partir d'un autre module, vous pouvez vous y r√©f√©rer par son nom complet. </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y module OtherStuff = //     MathStuff let add1 x = MathStuff.add x 1</code> </pre> <br><p>  Vous pouvez √©galement importer toutes les fonctions d'un autre module √† l'aide de la directive <code>open</code> , apr√®s quoi vous pouvez utiliser le nom court au lieu du nom complet. </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff //      let add1 x = add x 1</code> </pre> <br><p>  Les r√®gles d'utilisation des noms sont tr√®s attendues.  Vous pouvez toujours acc√©der √† une fonction par son nom complet, ou vous pouvez utiliser des noms relatifs ou incomplets selon l'√©tendue actuelle. </p><br><h3>  Modules imbriqu√©s </h3><br><p>  Comme les classes statiques, les modules peuvent contenir des modules imbriqu√©s: </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  D'autres modules peuvent faire r√©f√©rence √† des fonctions dans des modules imbriqu√©s en utilisant le nom complet ou relatif, selon le cas: </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff let add1 x = add x 1 //   let add1Float x = MathStuff.FloatLib.add x 1.0 //   let sub1Float x = FloatLib.subtract x 1.0</code> </pre> <br><h3>  Modules de haut niveau </h3><br><p>  Ainsi, puisque les modules peuvent √™tre imbriqu√©s, par cons√©quent, en remontant la cha√Æne, vous pouvez atteindre un module parent de niveau sup√©rieur.  √áa l'est vraiment. </p><br><p>  Les modules de niveau sup√©rieur sont d√©finis diff√©remment, contrairement aux modules pr√©sent√©s pr√©c√©demment. </p><br><ul><li>  La <code>module MyModuleName</code> <em>doit</em> √™tre la premi√®re d√©claration du fichier </li><li>  Signe <code>=</code> manquant </li><li>  Le contenu du module <em>ne</em> doit <em>pas</em> √™tre en retrait </li></ul><br><p>  En g√©n√©ral, une d√©claration de ¬´niveau sup√©rieur¬ª doit exister dans chaque fichier <code>.FS</code> source.  Il y a quelques exceptions, mais c'est toujours une bonne pratique.  Le nom du module ne doit pas n√©cessairement correspondre au nom du fichier, mais deux fichiers ne peuvent pas contenir de modules du m√™me nom. </p><br><p>  Pour les fichiers <code>.FSX</code> , la d√©claration de module n'est pas n√©cessaire, dans ce cas, le nom du fichier de script devient automatiquement le nom du module. </p><br><p>  Un exemple d'un <code>MathStuff</code> d√©clar√© en tant que module "top module": </p><br><pre> <code class="plaintext hljs">//    module MathStuff let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Notez qu'il n'y a pas de retrait dans le code ¬´de niveau sup√©rieur¬ª ( <code>module MathStuff</code> ), tandis que le contenu du module <code>FloatLib</code> imbriqu√© <code>FloatLib</code> encore √™tre mis en retrait. </p><br><h3>  Autres contenus du module </h3><br><p>  En plus des fonctions, les modules peuvent contenir d'autres d√©clarations, telles que des d√©clarations de type, des valeurs simples et du code d'initialisation (par exemple, des constructeurs statiques) </p><br><pre> <code class="plaintext hljs">module MathStuff = //  let add xy = x + y let subtract xy = x - y //   type Complex = {r:float; i:float} type IntegerFunction = int -&gt; int -&gt; int type DegreesOrRadians = Deg | Rad // "" let PI = 3.141 // "" let mutable TrigType = Deg //  /   do printfn "module initialized"</code> </pre><br><p>  Soit dit en passant, si vous ex√©cutez ces exemples de mani√®re interactive, vous devrez peut-√™tre red√©marrer la session suffisamment souvent pour que le code reste ¬´frais¬ª et ne soit pas infect√© par les calculs pr√©c√©dents. </p><br><h3>  Dissimulation (chevauchement, ombrage) </h3><br><p>  Ceci est encore notre exemple de module.  Notez que <code>MathStuff</code> contient la fonction d' <code>add</code> <em>ainsi</em> que <code>FloatLib</code> . </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Que se passe-t-il si vous ouvrez les <em>deux</em> modules dans la port√©e actuelle et appelez <code>add</code> ? </p><br><pre> <code class="plaintext hljs">open MathStuff open MathStuff.FloatLib let result = add 1 2 // Compiler error: This expression was expected to // have type float but here has type int</code> </pre> <br><p>  Et il est arriv√© que le module <code>MathStuff.FloatLib</code> red√©finisse le <code>MathStuff</code> origine, qui √©tait bloqu√© (masqu√©) par le module <code>FloatLib</code> . </p><br><p>  Par cons√©quent, nous obtenons l'erreur du compilateur FS0001, car le premier param√®tre <code>1</code> √©tait attendu comme un flottant.  Pour r√©soudre ce probl√®me, vous devez remplacer <code>1</code> par <code>1.0</code> . </p><br><p>  Malheureusement, en pratique, cela est <em>discr√®tement</em> et facilement ignor√©.  Parfois, en utilisant cette technique, vous pouvez effectuer des astuces int√©ressantes, presque comme des sous-classes, mais le plus souvent, la pr√©sence de fonctions du m√™me nom est g√™nante (par exemple, dans le cas de la fonction de <code>map</code> extr√™mement courante). </p><br><p>  Si vous souhaitez √©viter ce comportement, il existe un moyen de l'arr√™ter avec l'attribut <code>RequireQualifiedAccess</code> .  Le m√™me exemple dans lequel les deux modules sont d√©cor√©s avec cet attribut: </p><br><pre> <code class="plaintext hljs">[&lt;RequireQualifiedAccess&gt;] module MathStuff = let add xy = x + y let subtract xy = x - y //   [&lt;RequireQualifiedAccess&gt;] module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Maintenant, la directive <code>open</code> n'est pas disponible: </p><br><pre> <code class="plaintext hljs">open MathStuff //  open MathStuff.FloatLib // </code> </pre> <br><p>  Mais vous pouvez toujours acc√©der aux fonctions (sans aucune ambigu√Øt√©) via leurs noms complets: </p><br><pre> <code class="plaintext hljs">let result = MathStuff.add 1 2 let result = MathStuff.FloatLib.add 1.0 2.0</code> </pre> <br><h3>  Contr√¥le d'acc√®s </h3><br><p>  F # prend en charge l'utilisation d'op√©rateurs de contr√¥le d'acc√®s .NET standard tels que <code>public</code> , <code>private</code> et <code>internal</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'article MSDN</a> contient des informations compl√®tes. </p><br><ul><li>  Ces sp√©cificateurs d'acc√®s peuvent √™tre appliqu√©s aux fonctions, valeurs, types et autres d√©clarations de niveau sup√©rieur ("let bound") d'un module.  Ils peuvent √©galement √™tre sp√©cifi√©s pour les modules eux-m√™mes (par exemple, un module imbriqu√© priv√© peut √™tre n√©cessaire). </li><li>  Par d√©faut, tout a un acc√®s public (√† l'exception de plusieurs cas), donc pour les prot√©ger, vous devrez utiliser <code>private</code> ou <code>internal</code> . </li></ul><br><p>  Ces sp√©cificateurs d'acc√®s ne sont qu'un moyen de contr√¥ler la visibilit√© en F #.  Une mani√®re compl√®tement diff√©rente consiste √† utiliser des fichiers de signature qui ressemblent √† des fichiers d'en-t√™te C. Ils d√©crivent de mani√®re abstraite le contenu du module.  Les signatures sont tr√®s utiles pour une encapsulation s√©rieuse, mais pour consid√©rer leurs capacit√©s, vous devrez attendre la s√©rie pr√©vue sur l'encapsulation et la <em>s√©curit√© bas√©e sur les capacit√©s</em> . </p><br><h2>  Espaces de noms </h2><br><p>  Les espaces de noms en F # sont similaires aux espaces de noms de C #.  Ils peuvent √™tre utilis√©s pour organiser les modules et les types afin d'√©viter les conflits de noms. </p><br><p>  Un espace de noms d√©clar√© √† l'aide du mot cl√© <code>namespace</code> : </p><br><pre> <code class="plaintext hljs">namespace Utilities module MathStuff = //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  En raison de cet espace de noms, le nom complet du module <code>MathStuff</code> devenu <code>Utilities.MathStuff</code> et le nom complet <code>add</code> est <code>Utilities.MathStuff.add</code> . </p><br><p>  Les m√™mes r√®gles d'indentation s'appliquent aux modules dans un espace de noms qui ont √©t√© montr√©s ci-dessus pour les modules. </p><br><p>  Vous pouvez √©galement d√©clarer un espace de noms explicitement en ajoutant un point dans le nom du module.  C'est-√†-dire  Le code ci-dessus peut √™tre r√©√©crit comme ceci: </p><br><pre> <code class="plaintext hljs">module Utilities.MathStuff //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Le nom complet du module <code>MathStuff</code> est toujours <code>Utilities.MathStuff</code> , mais maintenant c'est un module de niveau sup√©rieur et son contenu n'a pas besoin de retrait. </p><br><p>  Quelques fonctionnalit√©s suppl√©mentaires pour l'utilisation des espaces de noms: </p><br><ul><li>  Les espaces de noms sont facultatifs pour les modules.  Contrairement √† C #, pour les projets F #, il n'y a pas d'espace de noms par d√©faut, donc un module de niveau sup√©rieur sans espace de noms sera global.  Si vous pr√©voyez de cr√©er des biblioth√®ques r√©utilisables, vous devez ajouter plusieurs espaces de noms pour √©viter les conflits avec le code des autres biblioth√®ques. </li><li>  Les espaces de noms peuvent contenir directement des d√©clarations de type, mais pas des d√©clarations de fonction.  Comme indiqu√© pr√©c√©demment, toutes les d√©clarations de fonctions et de valeurs doivent faire partie d'un module. </li><li>  Enfin, gardez √† l'esprit que les espaces de noms ne fonctionnent pas dans les scripts.  Par exemple, si vous essayez d'envoyer une d√©claration d'espace de noms, telle que <code>namespace Utilities</code> de <code>namespace Utilities</code> , √† une fen√™tre interactive, une erreur est re√ßue. </li></ul><br><h3>  Hi√©rarchie des espaces de noms </h3><br><p>  Vous pouvez cr√©er une hi√©rarchie d'espaces de noms en divisant simplement les noms par des points: </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y</code> </pre> <br><p>  Vous pouvez √©galement d√©clarer <em>deux</em> espaces de noms dans un fichier si vous le souhaitez.  Il convient de noter que tous les espaces de noms <em>doivent</em> √™tre d√©clar√©s par leur nom complet - ils ne prennent pas en charge l'imbrication. </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core.Extra module MoreMathStuff = let add xy = x + y</code> </pre> <br><p>  Un conflit de nom entre l'espace de noms et le module n'est pas possible. </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core //    - Core.Utilities //     ! module Utilities = let add xy = x + y</code> </pre> <br><h2>  M√©langer les types et les fonctions dans les modules </h2><br><p>  Comme nous l'avons vu, les modules se composent g√©n√©ralement de nombreuses fonctions interd√©pendantes qui interagissent avec un type de donn√©es particulier. </p><br><p>  Dans la POO, les structures de donn√©es et les fonctions au-dessus d'eux seraient combin√©es au sein d'une classe.  Et en F # fonctionnel, les structures de donn√©es et les fonctions au-dessus sont combin√©es dans un module. </p><br><p>  Il existe deux mod√®les pour combiner des types et des fonctions: </p><br><ul><li>  le type est d√©clar√© s√©par√©ment des fonctions </li><li>  le type est d√©clar√© dans le m√™me module que les fonctions </li></ul><br><p>  Dans le premier cas, le type est d√©clar√© en <em>dehors de</em> tout module (mais dans l'espace de noms), apr√®s quoi les fonctions qui fonctionnent avec ce type sont plac√©es dans le module du m√™me type. </p><br><pre> <code class="plaintext hljs">//    namespace Example //      type PersonType = {First:string; Last:string} //    ,     module Person = //  let create first last = {First=first; Last=last} // ,     let fullName {First=first; Last=last} = first + " " + last let person = Person.create "john" "doe" Person.fullName person |&gt; printfn "Fullname=%s"</code> </pre> <br><p>  Alternativement, le type est d√©clar√© <em>√† l'int√©rieur du</em> module et a un nom simple tel que " <code>T</code> " ou le nom du module.  L'acc√®s aux fonctions est approximativement le suivant: <code>MyModule.Func</code> et <code>MyModule.Func2</code> , et l'acc√®s au type: <code>MyModule.T</code> : </p><br><pre> <code class="plaintext hljs">module Customer = // Customer.T -      type T = {AccountId:int; Name:string} //  let create id name = {T.AccountId=id; T.Name=name} // ,     let isValid {T.AccountId=id; } = id &gt; 0 let customer = Customer.create 42 "bob" Customer.isValid customer |&gt; printfn "Is valid?=%b"</code> </pre> <br><p>  Notez que dans les deux cas, il doit y avoir une fonction constructeur qui cr√©e une nouvelle instance du type (usine).  Ensuite, dans le code client, vous n'avez pratiquement pas √† acc√©der explicitement au nom du type, et vous n'aurez pas √† vous demander si le type est √† l'int√©rieur du module ou non. </p><br><p>  Alors quelle voie choisir? </p><br><ul><li>  La premi√®re approche ressemble plus √† .NET classique et devrait √™tre pr√©f√©r√©e si vous pr√©voyez d'utiliser cette biblioth√®que pour du code en dehors de F #, o√π une classe existante s√©par√©ment est attendue. </li><li>  La deuxi√®me approche est plus courante dans d'autres langages fonctionnels.  Le type √† l'int√©rieur du module se compile comme une classe imbriqu√©e, ce qui n'est g√©n√©ralement pas tr√®s pratique pour les langages OOP. </li></ul><br><p>  Pour vous-m√™me, vous pouvez exp√©rimenter les deux m√©thodes.  Dans le cas du d√©veloppement d'√©quipe, un style doit √™tre choisi. </p><br><h3>  Modules contenant uniquement des types </h3><br><p>  S'il existe de nombreux types qui doivent √™tre d√©clar√©s sans aucune fonction, ne vous emb√™tez pas √† utiliser le module.  Vous pouvez d√©clarer des types directement dans l'espace de noms sans recourir √† des classes imbriqu√©es. </p><br><p>  Par exemple, vous pourriez vouloir faire ceci: </p><br><pre> <code class="plaintext hljs">//    module Example //     type PersonType = {First:string; Last:string} //    ,  ...</code> </pre> <br><p>  Et voici une autre fa√ßon de faire de m√™me.  Le <code>module</code> mots <code>module</code> simplement remplac√© par l' <code>namespace</code> mots. </p><br><pre> <code class="plaintext hljs">//    namespace Example //     type PersonType = {First:string; Last:string}</code> </pre> <br><p>  Dans les deux cas, <code>PersonType</code> aura le m√™me nom complet. </p><br><p>  Veuillez noter que ce remplacement ne fonctionne qu'avec les types.  Les fonctions doivent <strong>toujours</strong> √™tre d√©clar√©es √† l'int√©rieur du module. </p><br><h1>  Ressources suppl√©mentaires </h1><br><p>  Il existe de nombreux didacticiels pour F #, y compris des documents pour ceux qui viennent avec une exp√©rience C # ou Java.  Les liens suivants peuvent √™tre utiles pour approfondir F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">F # pour le plaisir et le profit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprenez X en Y minutes: F #</a> </li></ul><br><p>  Plusieurs autres fa√ßons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de commencer √† apprendre le F # sont</a> √©galement d√©crites. </p><br><p>  Enfin, la communaut√© F # est tr√®s conviviale pour les d√©butants.  Il y a un chat tr√®s actif chez Slack, soutenu par la F # Software Foundation, avec des salles pour d√©butants que vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pouvez rejoindre librement</a> .  Nous vous recommandons fortement de le faire! </p><br><p>  N'oubliez pas de visiter le site de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communaut√© russophone F #</a> !  Si vous avez des questions sur l'apprentissage d'une langue, nous serons heureux d'en discuter dans les salles de chat: </p><br><ul><li>  room <code>#ru_general</code> dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Slack Chat de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chat dans Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discuter avec gitter</a> </li><li>  room #en_general dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Slack Chat de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">F # Software Foundation</a> </li></ul><br><h2>  √Ä propos des auteurs de traduction </h2><br><p>  Traduit par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  La traduction et les modifications √©ditoriales ont √©t√© apport√©es par les efforts de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communaut√© russophone des d√©veloppeurs F #</a> .  Nous remercions √©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>@schvepsss</em></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>@shwars d'</em></a> avoir pr√©par√© cet article pour publication. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433406/">https://habr.com/ru/post/fr433406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433396/index.html">Frontend 2018: r√©sultats de l'ann√©e</a></li>
<li><a href="../fr433398/index.html">Pens√©e fonctionnelle. Partie 7</a></li>
<li><a href="../fr433400/index.html">Tutoriel React Partie 2: Composants fonctionnels</a></li>
<li><a href="../fr433402/index.html">Pens√©e fonctionnelle. Partie 8</a></li>
<li><a href="../fr433404/index.html">Tutoriel React, partie 3: fichiers de composants, structure du projet</a></li>
<li><a href="../fr433408/index.html">Gestion efficace de la m√©moire dans Node.js</a></li>
<li><a href="../fr433410/index.html">Pens√©e fonctionnelle. Partie 10</a></li>
<li><a href="../fr433412/index.html">Pens√©e fonctionnelle. Partie 11: Finale</a></li>
<li><a href="../fr433414/index.html">Test du moniteur r√©seau PRTG et comparaison avec Zabbix</a></li>
<li><a href="../fr433420/index.html">R√©sultats ZeroNights 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>