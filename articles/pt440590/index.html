<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèΩ ‚åõÔ∏è üî∏ Onde est√£o as pernas do Java Memory Model üç∞ ü•ì üôãüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hardware e compiladores modernos est√£o prontos para virar nosso c√≥digo de cabe√ßa para baixo, se ele funcionar mais r√°pido. E seus fabricantes escondem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Onde est√£o as pernas do Java Memory Model</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440590/"> Hardware e compiladores modernos est√£o prontos para virar nosso c√≥digo de cabe√ßa para baixo, se ele funcionar mais r√°pido.  E seus fabricantes escondem cuidadosamente sua cozinha interna.  E est√° tudo bem, desde que o c√≥digo seja executado em um thread. <br><br>  Em um ambiente multithread, voc√™ pode observar constantemente coisas interessantes.  Por exemplo, a execu√ß√£o de instru√ß√µes do programa n√£o est√° na ordem que est√° escrita no c√≥digo-fonte.  Concordo, √© desagrad√°vel perceber que executar o c√≥digo fonte linha por linha √© apenas nossa imagina√ß√£o. <br><br>  Mas todo mundo j√° percebeu, porque de alguma forma voc√™ tem que viver com isso.  E os programadores Java at√© vivem bem.  Como o Java possui um modelo de mem√≥ria - o Java Memory Model (JMM), que fornece regras bastante simples para escrever o c√≥digo multiencadeado correto. <br><br>  E essas regras s√£o suficientes para a maioria dos programas.  Se voc√™ n√£o os conhece, mas escreve ou deseja escrever programas multithread em Java, √© melhor se familiarizar com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eles o</a> mais r√°pido poss√≠vel.  E se voc√™ souber, mas voc√™ n√£o tem contexto suficiente ou √© interessante saber de onde as pernas da JMM crescem, este artigo pode ajud√°-lo. <br><a name="habracut"></a><br><h2>  E perseguindo abstra√ß√£o </h2><br>  Na minha opini√£o, h√° uma torta, ou, mais adequado, um iceberg.  JMM √© a ponta do iceberg.  O iceberg em si √© uma teoria da programa√ß√£o multithread sob a √°gua.  Sob o iceberg est√° o inferno. <br><br><img src="https://habrastorage.org/webt/ub/jg/rf/ubjgrfe8bec3-ix9qgnkik3avoy.png"><br><br>  Um iceberg √© uma abstra√ß√£o; se vazar, certamente veremos o inferno.  Embora muitas coisas interessantes estejam acontecendo por l√°, no artigo de revis√£o, n√£o chegaremos a isso. <br><br>  No artigo, estou mais interessado nos seguintes t√≥picos: <br><br><ul><li>  Teoria e Terminologia </li><li>  Como a teoria da programa√ß√£o multithread √© refletida no JMM </li><li>  Modelos de Programa√ß√£o Competitiva </li></ul><br>  A teoria da programa√ß√£o multithread permite que voc√™ se afaste da complexidade dos processadores e compiladores modernos, e simula a execu√ß√£o de programas multithread e estuda suas propriedades.  Roman Elizarov fez um excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> , cujo objetivo √© fornecer uma base te√≥rica para a compreens√£o do JMM.  Eu recomendo o relat√≥rio a todos os interessados ‚Äã‚Äãneste t√≥pico. <br><br>  Por que √© importante conhecer a teoria?  Na minha opini√£o, espero apenas que, alguns programadores tenham uma opini√£o de que o JMM √© uma complica√ß√£o da linguagem e corre√ß√£o de alguns problemas de plataforma com multithreading.  A teoria mostra que o Java n√£o complicou, mas simplificou e tornou a programa√ß√£o multithread muito mais previs√≠vel e complexa. <br><br><h2>  Concorr√™ncia e Concorr√™ncia </h2><br>  Primeiro, vamos olhar para a terminologia.  Infelizmente, n√£o h√° consenso na terminologia - ao estudar diferentes materiais, voc√™ pode encontrar diferentes defini√ß√µes de concorr√™ncia e simultaneidade. <br><br>  O problema √© que, mesmo que cheguemos ao fundo da verdade e encontremos as defini√ß√µes exatas desses conceitos, ainda n√£o vale a pena esperar que todos signifiquem a mesma coisa com esses conceitos.  Voc√™ n√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">encontrar√° os</a> fins aqui. <br><br>  Roman Elizarov, em um relat√≥rio, a teoria da programa√ß√£o paralela para os profissionais sugere que √†s vezes esses conceitos s√£o mistos.  A programa√ß√£o paralela √†s vezes se distingue como um conceito geral dividido em competitivo e distribu√≠do. <br><br>  Parece-me que, no contexto do JMM, voc√™ ainda precisa separar concorr√™ncia e paralelismo, ou melhor, at√© entender que existem dois paradigmas diferentes, n√£o importa como eles sejam chamados. <br><br>  Muitas vezes citado por Rob Pike, que distingue os conceitos da seguinte maneira: <br><br><ul><li>  A concorr√™ncia √© uma maneira de resolver simultaneamente muitos problemas </li><li>  A simultaneidade √© uma maneira de executar diferentes partes de uma √∫nica tarefa. </li></ul><br>  A opini√£o de Rob Pike n√£o √© um padr√£o, mas, na minha opini√£o, √© conveniente desenvolv√™-lo para aprofundar o estudo da quest√£o.  Leia mais sobre as diferen√ßas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Provavelmente, uma maior compreens√£o do problema aparecer√° se destacarmos os principais recursos de um programa competitivo e paralelo.  Existem muitos sinais, considere os mais significativos. <br><br>  Sinais de competi√ß√£o. <br><br><ul><li>  A presen√ßa de v√°rios fluxos de controle (por exemplo, Thread em Java, corotina no Kotlin), se houver apenas um fluxo de controle, n√£o haver√° execu√ß√£o competitiva </li><li>  Resultado n√£o determin√≠stico.  O resultado depende de eventos aleat√≥rios, implementa√ß√£o e como a sincroniza√ß√£o foi realizada.  Mesmo que cada fluxo seja completamente determin√≠stico, o resultado final ser√° n√£o determin√≠stico </li></ul><br>  Um programa paralelo ter√° um conjunto diferente de recursos. <br><br><ul><li>  Opcional possui v√°rios fluxos de controle </li><li>  Isso pode levar a um resultado determin√≠stico, por exemplo, o resultado da multiplica√ß√£o de cada elemento da matriz por um n√∫mero n√£o ser√° alterado se voc√™ o multiplicar em partes em paralelo </li></ul><br>  Curiosamente, a execu√ß√£o paralela √© poss√≠vel em um √∫nico fluxo de controle e at√© em uma arquitetura de n√∫cleo √∫nico.  O fato √© que o paralelismo no n√≠vel de tarefas (ou fluxos de controle) aos quais estamos acostumados n√£o √© a √∫nica maneira de realizar c√°lculos em paralelo. <br><br>  A simultaneidade √© poss√≠vel no n√≠vel de: <br><br><ul><li>  bits (por exemplo, em m√°quinas de 32 bits, a adi√ß√£o ocorre em uma a√ß√£o, processando todos os 4 bytes de um n√∫mero de 32 bits em paralelo) </li><li>  instru√ß√µes (em um n√∫cleo, em um thread, o processador pode executar instru√ß√µes em paralelo, apesar do c√≥digo ser seq√ºencial) </li><li>  dados (existem arquiteturas com processamento paralelo de dados (dados m√∫ltiplos de instru√ß√£o √∫nica) que podem executar uma instru√ß√£o em um grande conjunto de dados) </li><li>  tarefas (implica a presen√ßa de v√°rios processadores ou n√∫cleos) </li></ul><br>  A simultaneidade no n√≠vel da instru√ß√£o √© um exemplo de otimiza√ß√µes que ocorrem com a execu√ß√£o de c√≥digo ocultas do programador. <br><br>  √â garantido que o c√≥digo otimizado ser√° equivalente ao original dentro da estrutura de um thread, porque √© imposs√≠vel escrever um c√≥digo adequado e previs√≠vel se ele n√£o fizer o que o programador pretendia. <br><br>  Nem tudo o que √© executado em paralelo √© importante para o JMM.  A execu√ß√£o simult√¢nea no n√≠vel da instru√ß√£o em um √∫nico encadeamento n√£o √© considerada no JMM. <br><br>  A terminologia √© muito inst√°vel, com uma apresenta√ß√£o de Roman Elizarov chamada "Teoria da programa√ß√£o <b>paralela</b> para profissionais", embora exista mais sobre programa√ß√£o competitiva, se voc√™ se ater ao que foi dito acima. <br><br>  No contexto do JMM, no artigo vou me ater ao termo competi√ß√£o, uma vez que a competi√ß√£o √© geralmente sobre o estado geral.  Mas aqui voc√™ precisa ter cuidado para n√£o se apegar a termos, mas entenda que existem paradigmas diferentes. <br><br><h2>  Modelos com um estado comum: "rota√ß√£o de opera√ß√µes" e "aconteceu antes" </h2><br>  Em seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo,</a> Maurice Herlichi (autor da programa√ß√£o The Art Of Multiprocessor) escreve que um sistema competitivo cont√©m uma cole√ß√£o de processos seq√ºenciais (em trabalhos te√≥ricos significa o mesmo que um encadeamento) que se comunicam atrav√©s da mem√≥ria compartilhada. <br><br>  O modelo de estado geral inclui c√°lculos com mensagens, em que o estado compartilhado √© uma fila de mensagens e c√°lculos com mem√≥ria compartilhada, onde o estado comum s√£o estruturas na mem√≥ria. <br><br>  Cada um dos c√°lculos pode ser simulado. <br><br>  O modelo √© baseado em uma m√°quina de estados finitos.  O modelo se concentra exclusivamente no estado compartilhado e os dados locais de cada um dos fluxos s√£o completamente ignorados.  Cada a√ß√£o dos fluxos sobre um estado compartilhado √© uma fun√ß√£o da transi√ß√£o para um novo estado. <br><br>  Por exemplo, se 4 threads gravam dados em uma vari√°vel compartilhada, haver√° 4 fun√ß√µes para a transi√ß√£o para um novo estado.  Qual dessas fun√ß√µes ser√° aplicada depende da cronologia dos eventos no sistema. <br><br>  Os c√°lculos de passagem de mensagens s√£o modelados de maneira semelhante, apenas as fun√ß√µes de estado e de transi√ß√£o dependem do envio ou recebimento de mensagens. <br><br>  Se o modelo lhe pareceu complicado, no exemplo, vamos corrigi-lo.  √â realmente muito simples e intuitivo.  Tanto √© assim que, sem conhecer a exist√™ncia desse modelo, a maioria das pessoas ainda analisar√° o programa como o modelo sugere. <br><br>  Esse modelo √© chamado de modelo de <b>desempenho por meio da altern√¢ncia de opera√ß√µes</b> (o nome foi ouvido em um relat√≥rio por Roman Elizarov). <br><br>  Na intui√ß√£o e na naturalidade, voc√™ pode escrever com seguran√ßa as vantagens do modelo.  Voc√™ pode entrar no mundo selvagem com as palavras-chave <b>Consist√™ncia sequencial</b> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trabalho de</a> Leslie Lamport. <br><br>  No entanto, h√° um esclarecimento importante sobre esse modelo.  O modelo tem a limita√ß√£o de que todas as a√ß√µes em um estado compartilhado devem ser instant√¢neas e, ao mesmo tempo, as a√ß√µes n√£o podem ocorrer simultaneamente.  Eles dizem que esse sistema tem uma <b>ordem linear</b> - todas as a√ß√µes no sistema s√£o ordenadas. <br><br>  Na pr√°tica, isso n√£o acontece.  A opera√ß√£o n√£o ocorre instantaneamente, mas √© executada em um intervalo; em sistemas com v√°rios n√∫cleos, esses intervalos podem se cruzar.  Obviamente, isso n√£o significa que o modelo seja in√∫til na pr√°tica, basta criar certas condi√ß√µes para seu uso. <br><br>  Enquanto isso, considere outro <b>modelo - ‚Äúaconteceu antes‚Äù,</b> que n√£o se concentra no estado, mas no conjunto de c√©lulas de mem√≥ria de leitura e grava√ß√£o durante a execu√ß√£o (hist√≥rico) e seus relacionamentos. <br><br>  O modelo diz que eventos em diferentes fluxos n√£o s√£o instant√¢neos e at√¥micos, mas em paralelo, e n√£o √© poss√≠vel construir ordem entre eles.  Eventos (grava√ß√£o e leitura de dados compartilhados) em fluxos em uma arquitetura multiprocessador ou multin√∫cleo ocorrem realmente em paralelo.  N√£o h√° conceito de tempo global no sistema, n√£o podemos entender quando uma opera√ß√£o terminou e a outra come√ßou. <br><br>  Na pr√°tica, isso significa que podemos escrever um valor para uma vari√°vel em um segmento e faz√™-lo, digamos de manh√£, e ler o valor dessa vari√°vel em outro segmento √† noite, e n√£o podemos dizer que leremos o valor escrito de manh√£ com certeza.  Em teoria, essas opera√ß√µes ocorrem paralelamente e n√£o est√° claro quando uma terminar√° e outra opera√ß√£o come√ßar√°. <br><br>  √â dif√≠cil imaginar como acontece que opera√ß√µes simples de leitura e grava√ß√£o executadas em diferentes momentos do dia ocorrem simultaneamente.  Mas se voc√™ pensar bem, realmente n√£o nos importa quando os eventos de escrita e leitura ocorrem, se n√£o podemos garantir que veremos o resultado da grava√ß√£o. <br><br>  E realmente n√£o podemos ver o resultado da grava√ß√£o, ou seja,  em uma vari√°vel cujo valor √© <i>0</i> no fluxo <i>P,</i> escrevemos <i>1</i> e no fluxo <i>Q</i> lemos essa vari√°vel.  N√£o importa quanto tempo f√≠sico passe ap√≥s a grava√ß√£o, ainda podemos ler <i>0</i> . <br><br>  <b>√â assim que os computadores funcionam e o modelo reflete isso.</b> <br><br>  O modelo √© completamente abstrato e precisa de visualiza√ß√£o conveniente para um trabalho conveniente.  Para visualiza√ß√£o e somente para isso, √© usado um modelo com tempo global, com reservas de que, para provar as propriedades dos programas, o tempo global n√£o √© usado.  Na visualiza√ß√£o, cada evento √© representado como um intervalo com um come√ßo e um fim. <br><br>  Os eventos ocorrem em paralelo, como descobrimos.  Mas, ainda assim, o sistema tem uma <b>ordem parcial</b> , uma vez que existem pares especiais de eventos que t√™m uma ordem; nesse caso, eles dizem que esses eventos t√™m um relacionamento "aconteceu antes".  Se voc√™ ouvir pela primeira vez sobre o relacionamento "aconteceu antes", provavelmente saber o fato de que esse tipo de organiza√ß√£o organiza eventos n√£o ajudar√° muito. <br><br><h2>  Tentando analisar um programa Java </h2><br>  Consideramos um m√≠nimo te√≥rico, vamos tentar seguir em frente e considerar um programa multithread em uma linguagem espec√≠fica - Java, a partir de dois threads com um estado mut√°vel comum. <br><br>  Um exemplo cl√°ssico. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { a = <span class="hljs-number"><span class="hljs-number">0</span></span>; b = <span class="hljs-number"><span class="hljs-number">0</span></span>; x = <span class="hljs-number"><span class="hljs-number">0</span></span>; y = <span class="hljs-number"><span class="hljs-number">0</span></span>; } Thread p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { a = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = b; }); Thread q = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { b = <span class="hljs-number"><span class="hljs-number">1</span></span>; y = a; }); p.start(); q.start(); p.join(); q.join(); System.out.println(<span class="hljs-string"><span class="hljs-string">"x="</span></span> + x + <span class="hljs-string"><span class="hljs-string">", y="</span></span> + y);</code> </pre> <br>  Precisamos simular a execu√ß√£o deste programa e obter todos os resultados poss√≠veis - os valores das vari√°veis ‚Äã‚Äãx e y.  Haver√° v√°rios resultados, como lembramos da teoria, esse programa √© n√£o determin√≠stico. <br><br>  Como vamos modelar?  Eu quero imediatamente usar o modelo de opera√ß√µes intercaladas.  Mas o modelo "aconteceu antes" nos diz que os eventos em um encadeamento s√£o paralelos aos eventos de outro encadeamento.  Portanto, o modelo de opera√ß√µes alternadas aqui n√£o √© apropriado se n√£o houver um relacionamento "aconteceu antes" entre as opera√ß√µes. <br><br>  O resultado da execu√ß√£o de cada encadeamento √© sempre determinado, uma vez que os eventos em um encadeamento s√£o sempre ordenados, considere que eles recebem um relacionamento "aconteceu antes" gratuitamente.  Mas como eventos em diferentes fluxos podem obter o relacionamento "aconteceu antes" n√£o √© totalmente √≥bvio.  Obviamente, essa rela√ß√£o √© formalizada no modelo, todo o modelo √© escrito em linguagem matem√°tica.  Mas o que fazer com isso na pr√°tica, em um idioma espec√≠fico, n√£o √© imediatamente entendido. <br><br>  Quais s√£o as op√ß√µes? <br><br>  Ignore restri√ß√µes e simule intercala√ß√£o.  Voc√™ pode tentar, talvez nada de ruim aconte√ßa. <br><br>  Para entender que tipo de resultado pode ser obtido, simplesmente enumeramos todas as variantes poss√≠veis de execu√ß√£o. <br><br>  Todas as execu√ß√µes poss√≠veis de programas podem ser representadas como uma m√°quina de estados finitos. <br><br><img src="https://habrastorage.org/webt/z_/nb/a4/z_nba4dq4_xlfkdvw7vypddxo3s.jpeg"><br><br>  Cada c√≠rculo √© um estado do sistema, no nosso caso as vari√°veis <i>a, b, x, y</i> .  Uma fun√ß√£o de transi√ß√£o √© uma a√ß√£o em um estado que coloca o sistema em um novo estado.  Como dois fluxos podem executar a√ß√µes no estado geral, haver√° duas transi√ß√µes de cada estado.  C√≠rculos duplos s√£o os estados finais e iniciais do sistema. <br><br>  No total, s√£o poss√≠veis 6 execu√ß√µes diferentes, que resultam em pares de valores x, y: <br> <code>(1, 1), (1, 0), (0, 1) <br></code> <br><img src="https://habrastorage.org/webt/uu/dn/ev/uudnevagixnomxjnrydhfgrph4i.png"><br><br>  Podemos executar o programa e verificar os resultados.  Como conv√©m a um programa competitivo, ele ter√° um resultado n√£o determin√≠stico. <br><br>  Para testar programas competitivos, √© melhor usar ferramentas especiais ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramenta</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> ). <br><br>  Mas voc√™ pode tentar executar o programa v√°rios milh√µes de vezes, ou melhor ainda, escrever um ciclo que far√° isso por n√≥s. <br><br>  Se executarmos o c√≥digo em uma arquitetura de n√∫cleo √∫nico ou processador √∫nico, obteremos o resultado do conjunto que esperamos.  O modelo de rota√ß√£o funcionar√° bem.  Na arquitetura multin√∫cleo, por exemplo, x86, podemos nos surpreender com o resultado - podemos obter o resultado (0,0), que n√£o pode estar de acordo com a nossa modelagem. <br><br>  A explica√ß√£o para isso pode ser encontrada na Internet pela palavra-chave <b>reordenar</b> .  Agora √© importante entender que a <b>modelagem intercalada n√£o √© realmente adequada em uma situa√ß√£o em que n√£o podemos determinar a ordem de acesso ao estado compartilhado</b> . <br><br><h2>  Teoria da Programa√ß√£o Competitiva e JMM </h2><br>  √â hora de examinar mais de perto o relacionamento "aconteceu antes" e como ele faz amizade com a JMM.  A defini√ß√£o original do relacionamento "aconteceu antes" pode ser encontrada em Hor√°rio, Rel√≥gios e Ordena√ß√£o de eventos em um sistema distribu√≠do. <br><br>  O modelo de mem√≥ria de linguagem ajuda a escrever um c√≥digo competitivo, pois determina quais opera√ß√µes est√£o relacionadas ao ‚Äúaconteceu antes‚Äù.  Uma lista dessas opera√ß√µes √© apresentada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o</a> na se√ß√£o Acontece antes do pedido.  De fato, esta se√ß√£o responde √† pergunta - sob quais condi√ß√µes veremos o resultado da grava√ß√£o em outro fluxo. <br><br>  Existem v√°rios pedidos no JMM.  Alexei Shipilev fala vigorosamente sobre as regras em um de seus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rios</a> . <br><br>  No modelo de tempo global, todas as opera√ß√µes no mesmo encadeamento est√£o em ordem.  Por exemplo, os eventos de escrita e leitura de uma vari√°vel podem ser representados como dois intervalos; o modelo garante que esses intervalos nunca se cruzem na estrutura de um √∫nico fluxo.  No JMM, esse pedido √© chamado de Pedido de Programa ( <i>PO</i> ). <br><br>  <i>O PO</i> vincula a√ß√µes em um √∫nico encadeamento e n√£o diz nada sobre a ordem de execu√ß√£o, apenas fala sobre a ordem no c√≥digo-fonte.  Isso √© suficiente para garantir o <b>determinismo de cada fluxo separadamente</b> .  <i>O pedido</i> pode ser considerado como dados brutos.  <i>O PO √©</i> sempre f√°cil de organizar em um programa - todas as opera√ß√µes (ordem linear) no c√≥digo-fonte em um √∫nico fluxo ter√£o <i>PO</i> . <br><br>  No nosso exemplo, temos algo como o seguinte: <br><br>  <code>P: a = 1 PO x = b</code> - escrevendo para a e lendo b tem ordem de PO <br>  <code>Q: b = 1 PO y = a</code> - escreva em be leia a com a ordem dos PO <br><br>  Eu espiei essa forma de escrever <i>w (a, 1) PO r (b): 0.</i> Espero realmente que ningu√©m a tenha patenteado para relat√≥rios.  No entanto, a especifica√ß√£o tem uma forma semelhante. <br><br>  Mas cada thread individualmente n√£o √© particularmente interessante para n√≥s, uma vez que os threads t√™m um estado comum, estamos mais interessados ‚Äã‚Äãna intera√ß√£o dos fluxos.  Tudo o que queremos √© ter certeza de que veremos um registro de vari√°veis ‚Äã‚Äãem outros threads. <br><br>  Deixe-me lembr√°-lo de que isso n√£o deu certo para n√≥s, porque as opera√ß√µes de escrever e ler vari√°veis ‚Äã‚Äãem diferentes fluxos n√£o s√£o instant√¢neas (s√£o segmentos que se cruzam), respectivamente, √© imposs√≠vel analisar onde est√£o o in√≠cio e o fim das opera√ß√µes. <br><br>  A id√©ia √© simples - no momento em que lemos a vari√°vel a no fluxo <i>Q</i> , o registro dessa mesma vari√°vel no fluxo <i>P</i> pode n√£o terminar ainda.  E n√£o importa quanto tempo f√≠sico esses eventos compartilhem - um nanossegundo ou algumas horas. <br><br>  Para solicitar eventos, precisamos do relacionamento "aconteceu antes".  O JMM define esse relacionamento.  A especifica√ß√£o corrige o pedido em um thread: <br><br>  <i>Se a opera√ß√£o xey estiver no mesmo encadeamento e no <i>PO</i> x ocorrer primeiro, e depois y, x ocorreu antes de y.</i> <i><br></i> <br><br>  Olhando para o futuro, podemos dizer que podemos substituir todos os <i>pedidos</i> por Happens-before ( <i>HB</i> ): <br><br><pre> <code class="plaintext hljs">P: w(a, 1) HB r(b) Q: w(b, 1) HB r(a)</code> </pre> <br>  Mas, novamente, retornamos na estrutura de um fluxo.  <i>O HB √©</i> poss√≠vel entre opera√ß√µes que ocorrem em threads diferentes. Para lidar com esses casos, conheceremos outros pedidos. <br><br>  Ordem de Sincroniza√ß√£o ( <i>SO</i> ) - vincula A√ß√µes de Sincroniza√ß√£o ( <i>SA</i> ), uma lista completa de <i>SA √©</i> fornecida na especifica√ß√£o, na se√ß√£o 17.4.2.  Ac√ß√µes  Aqui est√£o alguns deles: <br><br><ul><li>  Leitura de vari√°vel vol√°til </li><li>  Escrevendo vari√°vel vol√°til </li><li>  Bloqueio do monitor </li><li>  Desbloquear monitor </li></ul><br>  <i>O SO</i> √© interessante para n√≥s, porque possui a propriedade de que todas as leituras na ordem do <i>SO</i> veem as √∫ltimas entradas no <i>SO</i> .  E eu lembro que estamos apenas conseguindo isso. <br><br>  Neste local, repetirei o que estamos buscando.  Temos um programa multithread, queremos simular todas as execu√ß√µes poss√≠veis e obter todos os resultados que ela pode fornecer.  Existem modelos que permitem que isso seja feito de maneira simples.  Mas eles exigem que todas as a√ß√µes no estado compartilhado sejam ordenadas. <br><br>  De acordo com a propriedade <i>SO</i> - se todas as a√ß√µes do programa forem <i>SA</i> , alcan√ßaremos nosso objetivo.  I.e.  podemos definir <i>modificador vol√°til</i> para todas as vari√°veis ‚Äã‚Äãe podemos usar o modelo de altern√¢ncia.  Se a intui√ß√£o diz que isso n√£o vale a pena, ent√£o voc√™ est√° absolutamente certo.  Com essas a√ß√µes, simplesmente proibimos otimiza√ß√µes sobre o c√≥digo, √© claro, √†s vezes essa √© uma boa op√ß√£o, mas esse definitivamente n√£o √© um caso geral. <br><br>  Considere outra ordem de sincroniza√ß√£o com ( <i>SW</i> ) - SO para pares vol√°teis espec√≠ficos de desbloqueio / bloqueio, grava√ß√£o / leitura.  N√£o importa em que fluxo essas a√ß√µes estar√£o, o principal √© que elas estejam no mesmo monitor, vari√°vel vol√°til.  <i>O SW</i> fornece uma ponte entre os threads. <br><br>  E agora chegamos √† ordem mais interessante - acontece antes ( <i>HB</i> ). <br>  <i>HB</i> √© um fechamento transitivo da uni√£o de <i>SW</i> e <i>PO</i> .  <i>O PO</i> fornece uma ordem linear dentro do fluxo e o <i>SW</i> fornece uma ponte entre os fluxos.  <i>HB √©</i> transitivo, isto <i>√©</i> ,  se <br><br><pre> <code class="plaintext hljs">x HB y  y HB z,  x HB z</code> </pre> <br>  A especifica√ß√£o possui uma lista de relacionamentos da <i>HB</i> , voc√™ pode se familiarizar com ela com mais detalhes, aqui est√£o algumas da lista: <br><br>  Dentro de um √∫nico encadeamento, qualquer opera√ß√£o acontece antes de qualquer opera√ß√£o seguinte no c√≥digo-fonte. <br><br>  A sa√≠da de um bloco / m√©todo sincronizado acontece antes de inserir um bloco / m√©todo sincronizado no mesmo monitor. <br><br>  Escrever um campo <i>vol√°til</i> acontece antes de ler o mesmo campo <i>vol√°til</i> . <br><br>  Vamos voltar ao nosso exemplo: <br><br><pre> <code class="plaintext hljs">P: a = 1 PO x = b Q: b = 1 PO y = a</code> </pre> <br>  Vamos voltar ao nosso exemplo e tentar analisar o programa, levando em considera√ß√£o os pedidos. <br><br>  A an√°lise do programa usando o JMM baseia-se em apresentar hip√≥teses e em confirm√°-las ou refut√°-las. <br><br><img src="https://habrastorage.org/webt/pu/hy/nz/puhynztfclug7afvnbpfht54wsg.png"><br><br>  Come√ßamos nossa an√°lise com a hip√≥tese de que nem uma √∫nica execu√ß√£o do programa fornece o resultado (0, 0).  A aus√™ncia de um resultado (0, 0) em todas as execu√ß√µes √© uma propriedade suposta do programa. <br><br>  Testamos a hip√≥tese construindo diferentes execu√ß√µes. <br><br>  Vi a nomenclatura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> (√†s vezes aparece em vez de <code>‚Ä¶</code> palavra <code>race</code> com uma flecha, o pr√≥prio Alexey usa a seta e a palavra corrida em seus relat√≥rios, mas avisa que essa ordem n√£o existe no JMM e usa essa nota√ß√£o para maior clareza). <br><br>  Fazemos uma pequena reserva. <br><br>  Como todas as a√ß√µes em vari√°veis ‚Äã‚Äãcomuns s√£o importantes para n√≥s, e no exemplo, as vari√°veis ‚Äã‚Äãcomuns s√£o <i>a, b, x, y</i> .  Ent√£o, por exemplo, a opera√ß√£o x = b deve ser considerada como r (b) ew (x, b) e <code>r(b) HB w(x,b)</code> (com base no <i>PO</i> ).  Mas como a vari√°vel x n√£o √© lida em nenhum lugar dos threads (a leitura impressa no final do c√≥digo n√£o √© interessante, porque ap√≥s a opera√ß√£o de jun√ß√£o no thread veremos o valor x), n√£o podemos considerar a a√ß√£o w (x, b). <br><br>  Verifique a primeira apresenta√ß√£o. <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(b): 0 ‚Ä¶ w(b, 1) HB r(a): 0</code> </pre> <br>  No fluxo <i>Q,</i> lemos a vari√°vel a, escrevemos para essa vari√°vel no fluxo <i>P.</i>  N√£o h√° ordem entre escrever e ler <i>(PO, SW, HB)</i> . <br><br>  Se a vari√°vel for escrita em um segmento e a leitura estiver em outro segmento e n√£o houver rela√ß√£o <i>HB</i> entre opera√ß√µes, eles dizem que a vari√°vel √© lida sob corrida.  E, de acordo com a JMM, podemos ler o √∫ltimo valor registrado em <i>HB</i> ou qualquer outro valor. <br><br>  Tal desempenho √© poss√≠vel.  A execu√ß√£o <b>n√£o viola o JMM</b> .  Ao ler a vari√°vel a, voc√™ pode ver qualquer valor, pois a leitura ocorre sob a corrida e n√£o h√° garantia de que veremos a a√ß√£o w (a, 1).  Isso n√£o significa que o programa funcione corretamente, simplesmente significa que esse resultado √© esperado. <br><br>  N√£o faz sentido considerar o restante da execu√ß√£o, pois a <b>hip√≥tese j√° est√° destru√≠da</b> . <br><br>  O JMM diz que, se o programa n√£o tiver corridas de dados, todas as execu√ß√µes poder√£o ser consideradas como seq√ºenciais.  Vamos nos livrar da corrida, para isso precisamos otimizar as opera√ß√µes de leitura e grava√ß√£o em diferentes threads.  √â importante entender que um programa multithread, ao contr√°rio de um seq√ºencial, possui v√°rias execu√ß√µes.  E para dizer que um programa tem alguma propriedade, √© necess√°rio provar que o programa tem essa propriedade n√£o em uma das execu√ß√µes, mas em todas as execu√ß√µes. <br><br>  Para provar que o programa n√£o √© de corrida, voc√™ precisa fazer isso em todas as apresenta√ß√µes.  Vamos tentar criar <i>SA</i> e marcar a vari√°vel a com um <i>modificador vol√°til</i> .  Vari√°veis <i>vol√°teis</i> ser√£o prefixadas com v. <br><br>  Propomos <b>uma nova hip√≥tese</b> .  Se a vari√°vel a for tornada <i>vol√°til</i> , nenhuma execu√ß√£o do programa fornecer√° o resultado (0, 0). <br><br><pre> <code class="plaintext hljs">w(va, 1) HB r(b): 0 ‚Ä¶ w(b, 1) HB r(va): 0</code> </pre> <br>  A execu√ß√£o <b>n√£o viola o JMM</b> .  Ler va acontece sob a corrida.  Qualquer ra√ßa destr√≥i a transitividade da HB. <br><br>  Apresentamos <b>outra hip√≥tese</b> .  Se a vari√°vel b for tornada <i>vol√°til</i> , nenhuma execu√ß√£o do programa fornecer√° o resultado (0, 0). <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(vb): 0 ‚Ä¶ w(vb, 1) HB r(a): 0</code> </pre> <br>  A execu√ß√£o n√£o viola o JMM.  A leitura de um ocorre sob a corrida. <br><br>  Vamos <b>testar a hip√≥tese de</b> que, se as vari√°veis ‚Äã‚Äãa e b s√£o <i>vol√°teis</i> , nenhuma execu√ß√£o do programa fornecer√° o resultado (0, 0). <br><br>  Verifique a primeira apresenta√ß√£o. <br><br><pre> <code class="plaintext hljs">w(va, 1) SO r(vb): 0 SO w(vb, 1) SO r(va): 0</code> </pre> <br>  Como todas as a√ß√µes no programa <i>SA</i> (especificamente lendo ou gravando uma vari√°vel <i>vol√°til</i> ), obtemos a ordem <i>SO</i> completa entre todas as a√ß√µes.  Isso significa que r (va) deve ver w (va, 1).  Esta <b>execu√ß√£o viola o JMM</b> . <br><br>  √â necess√°rio prosseguir para a pr√≥xima execu√ß√£o para confirmar a hip√≥tese.  Mas como haver√° <i>SO</i> para qualquer execu√ß√£o, voc√™ pode se desviar do formalismo - √© √≥bvio que o resultado (0, 0) viola o JMM para qualquer execu√ß√£o. <br><br>  Para usar o modelo de rota√ß√£o, voc√™ precisa adicionar <i>vol√°teis</i> para as vari√°veis ‚Äã‚Äãa e b.  Esse programa fornecer√° os resultados (1,1), (1,0) ou (0,1). <br><br>  No final, podemos dizer que programas muito simples s√£o bastante simples de analisar. <br><br>  Por√©m, programas complexos com um grande n√∫mero de execu√ß√µes e dados compartilhados s√£o dif√≠ceis de analisar, pois voc√™ precisa verificar todas as execu√ß√µes. <br><br><h2>  Outros modelos de execu√ß√£o competitivos </h2><br>  Por que considerar outros modelos de programa√ß√£o competitivos? <br><br>  O uso de threads e primitivas de sincroniza√ß√£o pode resolver todos os problemas.  Tudo isso √© verdade, mas o problema √© que examinamos um exemplo de uma d√∫zia de linhas de c√≥digo, em que quatro linhas de c√≥digo funcionam de maneira √∫til. <br><br>  E l√° encontramos v√°rias perguntas, at√© o ponto em que, sem a especifica√ß√£o, n√£o conseguimos calcular corretamente todos os resultados poss√≠veis.  Threads e primitivas de sincroniza√ß√£o s√£o uma coisa muito dif√≠cil, cuja utiliza√ß√£o √© certamente justificada em alguns casos.  Basicamente, esses casos est√£o relacionados ao desempenho. <br><br>  Desculpe, me refiro muito a Elizarov, mas o que posso fazer se uma pessoa realmente tiver experi√™ncia nesse campo.  Ent√£o, ele tem outro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> maravilhoso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> "Milh√µes de cita√ß√µes por segundo em Java puro", no qual ele diz que um estado imut√°vel √© bom, mas n√£o copiarei meus milh√µes de cita√ß√µes para cada fluxo, desculpe.  Mas nem todos t√™m milh√µes de cita√ß√µes; muitos, obviamente, t√™m tarefas mais modestas.  Existem modelos de programa√ß√£o competitivos que permitem esquecer o JMM e ainda escrever c√≥digos competitivos e seguros? <br><br>  Se voc√™ est√° realmente interessado nesta quest√£o, recomendo vivamente o livro de Paul Butcher, ‚ÄúSete modelos de competi√ß√£o em sete semanas.  N√≥s revelamos os segredos dos fluxos. ‚Äù  Infelizmente, n√£o foi poss√≠vel encontrar informa√ß√µes suficientes sobre o autor, mas o livro deve abrir seus olhos para novos paradigmas.  Infelizmente, n√£o tenho experi√™ncia com muitos outros modelos de competi√ß√£o, por isso recebi a resenha deste livro. <br><br>  Respondendo √† pergunta acima.  Tanto quanto eu entendo, existem modelos de programa√ß√£o competitivos que podem pelo menos reduzir bastante a necessidade de conhecimento das nuances do JMM.  No entanto, se houver um estado e fluxos mut√°veis, n√£o estrague nenhuma abstra√ß√£o sobre eles, ainda haver√° um local em que esses fluxos devem sincronizar o acesso ao estado.  Outra pergunta √© que voc√™ provavelmente n√£o precisa sincronizar o acesso, por exemplo, uma estrutura pode responder por isso.  Mas, como dissemos, mais cedo ou mais tarde, a abstra√ß√£o pode ocorrer. <br><br>  Voc√™ pode excluir o estado mut√°vel.  No mundo da programa√ß√£o funcional, essa √© uma pr√°tica normal.  Se n√£o houver estruturas mut√°veis, provavelmente n√£o haver√° problemas com a mem√≥ria compartilhada por defini√ß√£o.  Existem representantes de linguagens funcionais na JVM, como Clojure.  O Clojure √© uma linguagem funcional h√≠brida, porque ainda permite alterar as estruturas de dados, mas fornece ferramentas mais eficientes e seguras para isso. <br><br>  Linguagens funcionais s√£o uma √≥tima ferramenta para trabalhar com c√≥digo competitivo.  Pessoalmente, eu n√£o o uso, porque minha √°rea de atividade √© o desenvolvimento m√≥vel e simplesmente n√£o √© popular.  Embora certas abordagens possam ser adotadas. <br><br>  Outra maneira de trabalhar com dados mut√°veis ‚Äã‚Äã√© impedir o compartilhamento de dados.  Os atores s√£o um modelo de programa√ß√£o.  Os atores simplificam a programa√ß√£o, n√£o permitindo o acesso simult√¢neo aos dados.  Isso √© alcan√ßado pelo fato de que uma fun√ß√£o que executa trabalho em um momento no tempo pode funcionar em apenas um encadeamento. <br><br>  No entanto, um ator pode alterar o estado interno.  Dado que, no momento seguinte, o mesmo ator pode ser executado em outro encadeamento, isso pode ser um problema.  O problema pode ser resolvido de diferentes maneiras, em linguagens de programa√ß√£o como Erlang ou Elixir, onde o modelo de ator √© parte integrante da linguagem, voc√™ pode usar a recurs√£o para chamar um ator com um novo estado. <br><br>  Em Java, as recurs√µes podem ser muito caras.  No entanto, em Java, existem estruturas para um trabalho conveniente com este modelo, provavelmente o mais popular √© o Akka.  Os desenvolvedores da Akka cuidaram de tudo, voc√™ pode ir para a se√ß√£o de documenta√ß√£o da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Akka e do Java Memory Model</a> e ler sobre dois casos em que o acesso a um estado compartilhado pode ocorrer a partir de threads diferentes.  Mais importante, por√©m, a documenta√ß√£o diz a quais eventos se relacionam "aconteceram antes".  I.e.  isso significa que podemos alterar o estado do ator o quanto quisermos, mas quando recebermos a pr√≥xima mensagem e possivelmente a processarmos em outro segmento, temos a garantia de ver todas as altera√ß√µes feitas em outro segmento. <br><br><h2>  Por que o modelo de rosqueamento √© t√£o popular? </h2><br>  Examinamos dois modelos de programa√ß√£o competitiva; na verdade, existem ainda mais deles que tornam a programa√ß√£o competitiva mais f√°cil e segura. <br><br>  Mas por que ent√£o os fios e bloqueios ainda s√£o t√£o populares? <br><br>  Parece-me que o motivo √© a simplicidade da abordagem, √© claro, por um lado, √© f√°cil cometer muitos erros n√£o √≥bvios com fluxos, dar um tiro no p√© etc.  Mas, por outro lado <b>, n√£o h√° nada complicado nos fluxos, especialmente se voc√™ n√£o pensa nas consequ√™ncias</b> . <br><br>  Em um determinado momento, o kernel pode executar uma instru√ß√£o (na verdade n√£o, a concorr√™ncia existe no n√≠vel da instru√ß√£o, mas agora n√£o importa), mas devido √† multitarefa, mesmo em m√°quinas de n√∫cleo √∫nico, v√°rios programas podem ser executados simultaneamente (√© claro, pseudo simultaneamente). <br><br>  Para que a multitarefa funcione, voc√™ precisa de concorr√™ncia.  Como j√° descobrimos, a concorr√™ncia √© imposs√≠vel sem v√°rios fluxos de gerenciamento. <br><br>  Quantas threads voc√™ acha que um programa que roda em um processador de celular com quatro n√∫cleos precisa ser o mais r√°pido e responsivo poss√≠vel? <br><br>  Pode haver v√°rias dezenas.  Agora, a pergunta √©: por que precisamos de tantos threads para um programa que roda em hardware que permite executar apenas 2-4 threads por vez? <br><br>  Para tentar responder a essa pergunta, suponha que apenas nosso programa esteja sendo executado no dispositivo e nada mais.  Como gerenciar√≠amos os recursos fornecidos a n√≥s? <br><br>  Voc√™ pode fornecer um n√∫cleo para a interface do usu√°rio, o restante do kernel para quaisquer outras tarefas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se um dos threads estiver bloqueado, por exemplo, o thread pode ir para o controlador de mem√≥ria e aguardar uma resposta; ent√£o, obteremos um kernel bloqueado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quais tecnologias existem para resolver o problema? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem threads em Java, podemos criar muitos threads e outros threads poder√£o executar opera√ß√µes enquanto algum segmento estiver bloqueado. Com uma ferramenta como threads, podemos simplificar nossas vidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A abordagem com threads n√£o √© livre, a cria√ß√£o de threads geralmente leva tempo (√© decidido por conjuntos de threads), a mem√≥ria √© alocada para eles, alternar entre threads √© uma opera√ß√£o cara. Mas √© relativamente f√°cil programar com eles, portanto essa √© uma tecnologia massiva que √© t√£o amplamente usada em linguagens gerais, como Java.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java geralmente adora fluxos, n√£o √© necess√°rio criar para cada a√ß√£o um fluxo; existem coisas de n√≠vel superior, como Executors, que permitem trabalhar com pools e escrever c√≥digos mais escal√°veis ‚Äã‚Äãe flex√≠veis. Os fluxos s√£o realmente convenientes, voc√™ pode fazer uma solicita√ß√£o de bloqueio para a rede e gravar o processamento de resultados na pr√≥xima linha. Mesmo se esperarmos o resultado por v√°rios segundos, ainda podemos executar outras tarefas, pois o sistema operacional cuidar√° da distribui√ß√£o do tempo do processador entre os threads. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os fluxos s√£o populares n√£o apenas no desenvolvimento de back-end; no desenvolvimento m√≥vel, √© considerado normal criar dezenas de fluxos para que voc√™ possa bloquear um fluxo por alguns segundos, aguardando o download dos dados pela rede ou do soquete.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idiomas como Erlang ou Clojure ainda s√£o de nicho e, portanto, os modelos de programa√ß√£o competitivos que eles usam n√£o s√£o t√£o populares. </font><font style="vertical-align: inherit;">No entanto, as previs√µes para eles s√£o as mais otimistas.</font></font><br><br><h2>  Conclus√µes </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ estiver desenvolvendo na plataforma JVM, precisar√° aceitar as regras do jogo indicado pela plataforma. </font><font style="vertical-align: inherit;">Essa √© a √∫nica maneira de escrever c√≥digo multithread normal. </font><font style="vertical-align: inherit;">√â muito desej√°vel entender o contexto de tudo o que acontece, para que seja mais f√°cil aceitar as regras do jogo. </font><font style="vertical-align: inherit;">√â ainda melhor olhar em volta e se familiarizar com outros paradigmas, embora voc√™ n√£o possa chegar a lugar algum do submarino, mas pode descobrir novas abordagens e ferramentas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Materiais adicionais </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentei colocar no texto do artigo links para fontes das quais obtive informa√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, o material JMM √© f√°cil de encontrar na Internet. </font><font style="vertical-align: inherit;">Aqui vou postar links para algum material adicional associado ao JMM e que pode n√£o chamar minha aten√ß√£o imediatamente. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leitura</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Shipilev's blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Eu sei o que √© √≥bvio, mas √© apenas um pecado para n√£o mencionar</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog de Cheremin Ruslan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ele n√£o escreveu ativamente recentemente, √© preciso procurar as entradas antigas no blog, acredite em mim, vale a pena - existe uma fonte</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr Gleb Smirnov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - existem excelentes artigos sobre multithreading e o modelo de mem√≥ria</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O blog de Roman Elizarov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© abandonado, mas escava√ß√µes arqueol√≥gicas precisam ser realizadas. </font><font style="vertical-align: inherit;">Em geral, Roman fez muito para educar as pessoas na teoria da programa√ß√£o multithread, procur√°-la na m√≠dia.</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podcasts</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problemas que achei particularmente interessantes. </font><font style="vertical-align: inherit;">Eles n√£o s√£o sobre JMM, s√£o sobre o Inferno, o que est√° acontecendo na gl√¢ndula. </font><font style="vertical-align: inherit;">Mas depois de ouvi-los, quero beijar os criadores do JMM, que nos protegeram disso tudo.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 62</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Fora Alexander Titov e Amir Ayupov, engenheiros da Intel e Alexei Markin, programador do ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 63</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Fora Alexei Markin, programador do ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debriefing: # 107 Hist√≥rias de alpinistas</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debriefing: # 154 Guts - Ataque de Ano Novo</font></font></a> <br></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√≠deo</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al√©m dos discursos das pessoas acima mencionadas, preste aten√ß√£o ao v√≠deo acad√™mico.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Centro de Ci√™ncia da Computa√ß√£o - Palestra 11. Modelos de Mem√≥ria e Problemas de Visibilidade</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teoria e pr√°tica da programa√ß√£o multithread</font></font></a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440590/">https://habr.com/ru/post/pt440590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440576/index.html">Altera√ß√µes importantes no CTE no PostgreSQL 12</a></li>
<li><a href="../pt440582/index.html">Os carros el√©tricos s√£o puxados para o fundo da corpora√ß√£o automobil√≠stica?</a></li>
<li><a href="../pt440584/index.html">O que h√° de errado com o Raspberry Pi</a></li>
<li><a href="../pt440586/index.html">Consenso Exonum: Como Funciona</a></li>
<li><a href="../pt440588/index.html">O MIT aprendeu a transmitir som com um laser</a></li>
<li><a href="../pt440592/index.html">Criando um jogo AR com Vuforia</a></li>
<li><a href="../pt440594/index.html">1C e Yandex, computa√ß√£o em nuvem. Para cima e para baixo</a></li>
<li><a href="../pt440596/index.html">Flightradar24 - como funciona?</a></li>
<li><a href="../pt440598/index.html">Sonda InSight Marciana funciona com sucesso no Planeta Vermelho</a></li>
<li><a href="../pt440600/index.html">Quantos nomes de dom√≠nio .com n√£o s√£o usados?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>