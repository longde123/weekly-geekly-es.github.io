<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•° üòå üë©üèæ‚Äç‚öñÔ∏è Steuerung von RGB-LEDs √ºber Cypress UDB Microcontroller PSoC üìé üëäüèΩ ‚è∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Ich wollte schon lange die Technik des Programmierens von UDB-Bl√∂cken in Cypress PSoC-Controllern lernen, aber irgendwie haben alle meine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Steuerung von RGB-LEDs √ºber Cypress UDB Microcontroller PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429882/"><img src="https://habrastorage.org/webt/is/cg/hl/iscghlsqtbktd8fhkstyrghp9ee.jpeg"><br><br><h2>  Einf√ºhrung </h2><br>  Ich wollte schon lange die Technik des Programmierens von UDB-Bl√∂cken in Cypress PSoC-Controllern lernen, aber irgendwie haben alle meine H√§nde nicht erreicht.  Und so entstand ein Problem, bei dem dies getan werden konnte.  Als ich die Materialien aus dem Netzwerk verstand, stellte ich fest, dass praktische Empfehlungen f√ºr die Arbeit mit UDB auf verschiedene Variationen von Z√§hlern und PWMs beschr√§nkt sind.  Aus irgendeinem Grund nehmen alle Autoren ihre Variationen dieser beiden kanonischen Beispiele vor, so dass die Beschreibung von etwas anderem f√ºr die Leser durchaus interessant sein kann. <br><a name="habracut"></a><br>  Also.  Es gab ein Problem bei der dynamischen Verwaltung einer langen Reihe von WS2812B-RGB-LEDs.  Klassische Ans√§tze zu diesem Thema sind bekannt.  Sie k√∂nnen das triviale Arduino nehmen, aber dort erfolgt die Ausgabe programmgesteuert. W√§hrend die Daten ausgegeben werden, ist alles andere inaktiv, da sonst die Zeitdiagramme fehlschlagen.  Sie k√∂nnen STM32 verwenden und Daten entweder √ºber DMA an PWM oder √ºber DMA an SPI ausgeben.  Techniken sind bekannt.  Ich habe sogar einmal pers√∂nlich eine Reihe von 16 Dioden √ºber SPI gesteuert.  Aber der Overhead ist gro√üartig.  Ein Datenbit in LEDs belegt 8 Bit im Speicher f√ºr PWM und 3 bis 4 Bit (abh√§ngig von der PLL-K√ºhle in der Steuerung) f√ºr SPI.  Es gibt zwar nur wenige LEDs, dies ist jedoch nicht be√§ngstigend. Wenn jedoch beispielsweise einige Hundert vorhanden sind, sollten 200 * 24 = 4800 Bit = 600 Byte n√ºtzliche Daten physisch in einem Puffer mit einer Kapazit√§t von mehr als 4 Kilobyte f√ºr die PWM-Option oder mehr als 2 Kilobyte f√ºr SPI gespeichert werden Optionen.  F√ºr die dynamische Anzeige von Puffern sollten mehrere vorhanden sein, und STM32F103 verf√ºgt √ºber RAM f√ºr alles, was mit 20 Kilobyte zu tun hat.  Nicht dass wir auf eine nicht realisierbare Aufgabe gesto√üen w√§ren, aber ein Grund zu pr√ºfen, ob dies auf dem PSoC implementiert werden kann, ohne zus√§tzlichen RAM ausgeben zu m√ºssen, ist ziemlich wichtig. <br><br><h2>  Theorie Referenzen </h2><br>  Lassen Sie uns zun√§chst herausfinden, was f√ºr ein Biest eine solche UDB ist und wie sie damit arbeiten.  Dabei helfen wunderbare Lehrfilme des Controller-Herstellers. <br><br>  Sie sollten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aus</a> mit dem Anschauen beginnen. Am Ende jedes Videos befindet sich ein Link zur n√§chsten Serie.  Schritt f√ºr Schritt erwerben Sie Grundkenntnisse und betrachten das kanonische Beispiel ‚ÄûZ√§hler‚Äú.  Nun, und ein Ampelkontrollsystem. <br><br>  Etwa das gleiche, aber in kleine St√ºcke geschnitten, k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier sehen</a> .  Mein Video wurde nicht abgespielt, kann aber heruntergeladen und lokal angezeigt werden.  Unter anderem gibt es auch ein kanonisches Beispiel f√ºr die Implementierung von PWM. <br><br><h2>  Fertige L√∂sungen </h2><br>  Um das Rad nicht neu zu erfinden (und umgekehrt - um die Methodik aus den Erfahrungen anderer zu lernen), st√∂berte ich im Netzwerk nach vorgefertigten L√∂sungen f√ºr die Steuerung von RGB-LEDs.  Die beliebteste L√∂sung ist StripLightLib.cylib.  Aber seit vielen Jahren plant er, Add DMA-Unterst√ºtzung hinzuzuf√ºgen.  Aber ich m√∂chte eine L√∂sung ausprobieren, die nicht vom Zentralprozessor abh√§ngt.  Ich m√∂chte den Prozess starten und ihn vergessen und mich auf die Vorbereitung des n√§chsten Frames konzentrieren. <br><br>  Die L√∂sung, die meinen W√ºnschen entspricht, wurde unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/PolyVinalDistillate/PSoC_DMA_NeoPixel gefunden</a> . <br><br>  Dort ist alles in UDB implementiert (aber LEDs sind nur eine Ausrede, das Ziel ist es, UDB zu lernen).  Es gibt Unterst√ºtzung f√ºr DMA.  Und das Projekt dort ist klar sch√∂n organisiert. <br><br><h2>  Probleme der als Basis gew√§hlten L√∂sung </h2><br>  Wie ist die "Firmware" im Projekt PSoC_DMA_NeoPixel, kann jeder nach dem Lesen des Artikels sehen.  Dadurch wird das Material repariert.  Im Moment m√∂chte ich nur sagen, dass ich zuerst die Logik der urspr√ºnglichen Firmware vereinfacht habe, ohne den Ressourcenverbrauch zu reduzieren (aber es ist einfacher zu verstehen).  Dann begann er zu experimentieren, um die Automatenlogik zu ersetzen, die einen Ressourcengewinn versprach, aber auf ein ernstes Problem stie√ü.  Und so entschied er - es wird nicht beseitigt!  Und vage Zweifel qu√§lten mich: Hatte der englische Autor das gleiche Problem?  Seine Demo blinkt sehr sch√∂n mit LEDs.  Aber was ist, wenn wir die sch√∂ne F√ºllung durch ‚Äûalle Einheiten‚Äú ersetzen und die Ausgabe nicht mit unseren Augen, sondern mit einem Oszilloskop steuern? <br>  So grob wie m√∂glich (man k√∂nnte sogar ‚Äûbrutal‚Äú sagen) bilden wir die Daten: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> (pPixelArray,<span class="hljs-number"><span class="hljs-number">0xff</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pPixelArray)); <span class="hljs-comment"><span class="hljs-comment">//Call NeoPixel update function (non blocking) to trigger DMA pixel update NP_Update();</span></span></code> </pre> <br>  Und hier sehen wir ein solches Bild auf einem Oszilloskop: <br><br><img src="https://habrastorage.org/webt/kv/u7/wu/kvu7wuciw7tafpf_cjjbp4m-gzw.png"><br><br>  Das erste Bit hat eine andere Breite als der Rest.  Ich bat darum, alle Einheiten zu schicken, aber nicht alle gehen.  Unter ihnen auf Null gesetzt!  √Ñndern Sie den Scan: <br><br><img src="https://habrastorage.org/webt/2k/ev/mb/2kevmb_fna8e8oce9pkdwhaofcg.png"><br><br>  Die Breite ist f√ºr jedes achte Bit unterschiedlich. <br><br>  Im Allgemeinen ist dieses Beispiel als eigenst√§ndige L√∂sung nicht geeignet, sondern als Inspirationsquelle - einfach perfekt.  Erstens ist seine Inoperabilit√§t mit dem Auge nicht sichtbar (die LEDs sind immer noch hell, das Auge sieht nicht, dass sie halb halb leuchten), aber der Code ist gut strukturiert, es ist sch√∂n, ihn als Grundlage zu nehmen.  Zweitens bietet dieses Beispiel Raum f√ºr M√∂glichkeiten zur Vereinfachung, und drittens werden Sie dar√ºber nachdenken, wie Sie den Fehler beheben k√∂nnen.  Das Wichtigste ist, das Material zu verstehen!  Nachdem ich den Artikel gelesen habe, empfehle ich erneut, das urspr√ºngliche Beispiel zu analysieren und zu erkennen, wie es funktioniert. <br><br><h2>  Praktischer Teil </h2><br>  Jetzt fangen wir an zu √ºben.  Wir testen die Hauptaspekte der Firmware-Entwicklung f√ºr UDB.  Betrachten Sie die Beziehung und die grundlegenden Techniken.  √ñffnen Sie dazu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine Version des Projekts</a> .  Der linke Block speichert Informationen zu Arbeitsdateien.  Standardm√§√üig ist die Registerkarte <b>Quelle</b> ge√∂ffnet.  Die Hauptquelle des Projekts ist die Datei <b>main.c.</b>  Tats√§chlich gibt es keine anderen Arbeitsdateien in der Gruppe <b>Quelldateien</b> . <br><br><img src="https://habrastorage.org/webt/-n/xu/lm/-nxulmetonhzhf6lwlvr30f-2r8.png"><br><br>  Die Gruppe <b>Generierte Quelle</b> enth√§lt Bibliotheksfunktionen.  Es ist besser, sie nicht zu bearbeiten.  Nach jeder √Ñnderung der ‚ÄûFirmware‚Äú von UDB wird diese Gruppe neu generiert.  Wo ist also die Beschreibung des Codes f√ºr UDB in dieser Idylle?  Um es zu sehen, m√ºssen Sie zur Registerkarte <b>Komponenten</b> wechseln: <br><br><img src="https://habrastorage.org/webt/qb/yj/ku/qbyjkuvng7ibcdlhiftcf5qld6o.png"><br><br>  Der Autor des urspr√ºnglichen Projekts hat einen zweistufigen Satz von Komponenten erstellt.  Auf der obersten Ebene liegt die Schaltung <b>NeoPixel_v1_2.cysch</b> .  Dies ist aus dem Hauptschema ersichtlich: <br><br><img src="https://habrastorage.org/webt/z3/cg/fr/z3cgfrfl4k_rdsuu2dw6kykq_o4.png"><br><br>  Die Komponente ist wie folgt: <br><br><img src="https://habrastorage.org/webt/zp/h3/yw/zph3ywaeojjenc6ailxcmsb3f0m.png"><br><br>  Die Softwareunterst√ºtzung f√ºr dieses Schema wird sp√§ter erl√§utert.  <b>Stellen</b> Sie in der Zwischenzeit fest, dass es sich selbst um eine regul√§re DMA-Einheit und ein bestimmtes Symbol <b>NeoPixDrv_v1 handelt</b> .  Dieser mysteri√∂se Block ist oben im Baum beschrieben, der sich aus dem folgenden Tooltip ergibt: <br><br><img src="https://habrastorage.org/webt/zk/_u/2p/zk_u2pxpdmiokfow6b4iur-_ab0.png"><br><br><h2>  UDB "Firmware" </h2><br>  √ñffnen Sie diese Komponente (Datei mit der Erweiterung <b>.cyudb</b> ).  Die ge√∂ffnete Zeichnung ist einfach riesig.  Wir beginnen zu verstehen, was was ist. <br><br><img src="https://habrastorage.org/webt/e6/co/4l/e6co4lsbmphoom6ikhuhutzkzbe.png"><br><br>  Im Gegensatz zum Autor des urspr√ºnglichen Projekts betrachte ich die √úbertragung jedes Datenbits in Form von drei gleichen (zeitlichen) Teilen: <br><br><ol><li>  Startteil (immer 1) </li><li>  Datenteil </li><li>  Teil stoppen (immer 0) </li></ol><br>  Bei diesem Ansatz ist keine gro√üe Anzahl von Z√§hlern erforderlich (im Original gab es bis zu drei Teile, die eine gro√üe Menge an Ressourcen verbrauchten).  Die Dauer aller Teile ist gleich und kann mit einem Register eingestellt werden.  Somit enth√§lt der √úbergangsgraph der Firmware die folgenden Zust√§nde: <br><br>  <b>Leerlaufzustand</b> .  Die Maschine bleibt darin, bis neue Daten im FIFO eintreffen. <br><br><img src="https://habrastorage.org/webt/s_/r5/zn/s_r5zn54lff9nd9thvqxphyxjqq.png"><br><br>  Aus den Schulungsvideos war mir nicht ganz klar, wie der Zustand der Maschine mit ALU zusammenh√§ngt.  Die Autoren verwenden Kommunikation selbstverst√§ndlich, aber ich als Anf√§nger konnte sie nicht sofort sehen.  Lassen Sie uns einen kurzen Blick darauf werfen.  Die obige Abbildung zeigt, dass der Ruhezustand mit dem Wert 1'b0 codiert ist.  3'b000 wird korrekter sein, aber der Editor wird alles trotzdem wiederholen.  Die Eing√§nge des <b>Datenpfadblocks werden folgenderma√üen</b> beschrieben: <br><br><img src="https://habrastorage.org/webt/dq/qc/zp/dqqczpv87oulrwzvu-cbcmucsee.png"><br><br>  Wenn Sie darauf doppelklicken, wird eine detailliertere Version angezeigt: <br><br><img src="https://habrastorage.org/webt/pu/xm/ts/puxmtsmg3jf3hjnwstnpbeu-exe.png"><br><br>  Dies bedeutet, dass das Nullbit der Adresse des ALU-Befehls dem Nullbit der Variablen entspricht, die den Zustand der Maschine festlegt.  Der erste ist der erste, der zweite ist der zweite.  Falls gew√ºnscht, k√∂nnen beliebige Variablen und sogar Ausdr√ºcke mit den Adressbits des ALU-Befehls abgeglichen werden (in der Originalversion wurde das zweite Bit der Adresse des ALU-Befehls mit einem Ausdruck abgeglichen, au√üerdem wird es in der aktuellen Version nicht explizit verwendet, aber es ist sehr offensichtlich als gehirntragendes Beispiel, dann k√∂nnen Sie einen Blick darauf werfen). <br><br>  Also.  Bei den aktuellen Einstellungen der Eing√§nge, bei denen es sich um den bin√§ren Statuscode der Maschine handelt, wird ein solcher ALU-Befehl verwendet.  Wenn wir uns im <b>Ruhezustand</b> mit dem Code 000 befinden, wird der Nullbefehl verwendet.  Da ist sie: <br><br><img src="https://habrastorage.org/webt/4p/oz/gt/4pozgtr4-p66hypvlz2rqdjta2a.png"><br><br>  Ich wei√ü bereits aus diesem Eintrag, dass dies ein banaler NOP ist.  Sie k√∂nnen jedoch darauf doppelklicken und die Vollversion lesen: <br><br><img src="https://habrastorage.org/webt/-a/vl/ii/-avliivwnptl2ra9ipfxseurxqk.png"><br><br>  NOPs sind √ºberall eingeschrieben.  Register sind mit nichts gef√ºllt. <br><br>  Lassen Sie uns nun herausfinden, was f√ºr eine mysteri√∂se Flagge <b>! NoData</b> , die die Maschine zwingt, den <b>Ruhezustand</b> zu verlassen.  Dies ist der Ausgang aus dem <b>Datenpfadblock</b> .  Insgesamt k√∂nnen bis zu sechs Ausg√§nge beschrieben werden.  Es ist nur so, dass <b>Datapath</b> viel mehr Flags erzeugen kann, aber es gibt nicht gen√ºgend Trace-Ressourcen f√ºr alle, sodass wir ausw√§hlen m√ºssen, welche sechs (oder weniger) wir wirklich ben√∂tigen.  Hier ist die Liste in der Abbildung: <br><br><img src="https://habrastorage.org/webt/qf/a7/yd/qfa7ydqxuql3khszkw1mqbdb63m.png"><br><br>  Wenn Sie darauf doppelklicken, werden die Details angezeigt: <br><br><img src="https://habrastorage.org/webt/vu/zo/2z/vuzo2zxg56zpyaavdunmw60eapg.png"><br><br>  Hier ist die vollst√§ndige Liste der Flags, die angezeigt werden k√∂nnten: <br><br><img src="https://habrastorage.org/webt/gi/la/jf/gilajfhzmatw2hjtfjk9xl1gs7m.png"><br><br>  Nachdem Sie das gew√ºnschte Flag ausgew√§hlt haben, sollten Sie ihm einen Namen geben.  Von nun an hat das System eine Flagge.  Wie Sie sehen k√∂nnen, ist das <b>NoData-</b> Flag der Name f√ºr den <b>Blockstatus</b> der Kette <b>F0 (leer)</b> .  Das hei√üt, ein Zeichen daf√ºr, dass sich keine Daten im Eingabepuffer befinden.  Ah <b>! NoData</b> bzw. seine Inversion.  Zeichen der Datenverf√ºgbarkeit.  Sobald die Daten in das FIFO eintreten (programmgesteuert oder unter Verwendung von DMA), wird das Flag gel√∂scht (und seine Inversion gespannt), und beim n√§chsten Taktzyklus verl√§sst der Automat den Ruhezustand und wechselt in den <b>GetData-</b> Zustand. <br><br><img src="https://habrastorage.org/webt/lw/o3/av/lwo3avzjvfqynfpw-3t075oat-0.png"><br><br>  Wie Sie sehen k√∂nnen, verl√§sst der Automat diesen Zustand bedingungslos, nachdem er genau einen Taktzyklus ausgef√ºhrt hat.  F√ºr diesen Status werden im √úbergangsdiagramm keine Aktionen angezeigt.  Aber Sie sollten immer darauf achten, was ALU tun wird.  Der Statuscode lautet 1'b1, dh 3'b001.  Wir sehen uns die entsprechende Adresse in ALU an: <br><br><img src="https://habrastorage.org/webt/ic/zk/y8/iczky8asdanru7kzgfzznebiynm.png"><br><br>  Da ist etwas.  Wenn Sie keine Erfahrung mit dem Lesen der hier geschriebenen Informationen haben, √∂ffnen Sie sie, indem Sie auf die entsprechende Zelle doppelklicken: <br><br><img src="https://habrastorage.org/webt/vu/yf/gf/vuyfgfecoxpfd1brc6v_lzu4a3w.png"><br><br>  Daraus folgt, dass die ALU selbst noch keine Aktionen ausf√ºhrt.  Der Inhalt von FIFO0, dh die vom Programm oder vom DMA-Block kommenden Daten, werden jedoch in das A0-Register gestellt.  Mit Blick auf die Zukunft werde ich sagen, dass A0 als Schieberegister verwendet wird, aus dem das Byte in serieller Form austritt.  Register A1 setzt den Wert von Register D1.  Im Allgemeinen werden normalerweise alle D-Register in Software gef√ºllt, bevor die Hardware aktiv wird.  Wenn wir dann die API untersuchen, werden wir sehen, dass die Anzahl der Takt-Ticks in dieses Register eingef√ºgt wird, wodurch die Dauer des dritten Bits festgelegt wird.  Also.  In A0 fiel der verschobene Wert und in A1 die Dauer des Startteils des Bits.  Und beim n√§chsten Schlag wird die Maschine sicherlich in den Zustand <b>Constant1 gehen</b> . <br><br><img src="https://habrastorage.org/webt/ue/jx/fh/uejxfhlbmgbh0wgkuy2k4fe-qva.png"><br><br>  Wie der Name des Zustands andeutet, wird hier die Konstante 1 generiert. Schauen wir uns die Dokumentation f√ºr die LED an.  So sollte das Ger√§t √ºbertragen werden: <br><br><img src="https://habrastorage.org/webt/cn/2t/i3/cn2ti3ppzpacxrbyi2uy8mq5wte.png"><br><br>  Und hier ist es - Null: <br><br><img src="https://habrastorage.org/webt/z6/yg/vp/z6ygvphpsb700_acfvwiek9mbeo.png"><br><br>  Rote Linien habe ich hinzugef√ºgt.  Wenn wir davon ausgehen, dass die Dauer von Dritteln gleich ist, sind die Anforderungen f√ºr die Dauer von Impulsen (in derselben Dokumentation angegeben) erf√ºllt.  Das hei√üt, jeder Impuls besteht aus einer Starteinheit, einem Datenbit und einer Stoppnull.  Tats√§chlich wird die Starteinheit √ºbertragen, wenn sich die Maschine im Zustand <b>Constant1 befindet</b> . <br><br>  In diesem Zustand rastet die Maschine das Ger√§t in seinem internen Ausl√∂ser ein.  Der Name des Triggers lautet <b>CurrentBit</b> .  Im urspr√ºnglichen Projekt war es im Allgemeinen ein Ausl√∂ser, der den Zustand des Hilfsautomaten festlegt.  Ich entschied, dass diese Maschine nur alle verwirren w√ºrde, also startete ich einfach einen Ausl√∂ser.  Es wird nirgendwo beschrieben.  Wenn Sie jedoch die Statuseigenschaften eingeben, wird der folgende Datensatz in der Tabelle angezeigt: <br><br><img src="https://habrastorage.org/webt/tz/2e/m4/tz2em4pv4kxwsg5fvzkhx7-ve_w.png"><br><br>  Und unter dem Status in der Grafik befindet sich ein solcher Text: <br><br><img src="https://habrastorage.org/webt/bx/az/0c/bxaz0clixua21k_umbqpch3vrca.png"><br><br>  Lassen Sie sich nicht durch das Gleichheitszeichen symbolisieren.  Dies sind die Funktionen des Editors.  Im resultierenden Verilog-Code (automatisch vom selben System generiert) wird ein Pfeil angezeigt: <br><br><pre> <code class="plaintext hljs">Constant1 : begin CurrentBit &lt;= (1); if (( CycleTimeout ) == 1'b1) begin MainState &lt;= Setup1 ; end end</code> </pre> <br>  Der in diesem Trigger zwischengespeicherte Wert ist die Ausgabe unseres gesamten Blocks: <br><br><img src="https://habrastorage.org/webt/bv/jq/qd/bvjqqdmqg-2framc6_trktlfix4.png"><br><br>  Das hei√üt, wenn die Maschine in den Zustand von <b>Konstante1</b> eingetreten ist, erh√§lt die Ausgabe des Blocks, den wir entwickeln, einen.  Nun wollen wir sehen, wie die ALU f√ºr die Adresse 3'b010 programmiert ist: <br><br><img src="https://habrastorage.org/webt/5e/4v/hi/5e4vhiqa5gl7wo6xk0zzea_8_dm.png"><br><br>  Wir enth√ºllen dieses Element: <br><br><img src="https://habrastorage.org/webt/ij/wx/fc/ijwxfcl3zzmuhlef2qq-j6hhkme.png"><br><br>  Einheit 1 wird vom Register A1 abgezogen.  Der Ausgabewert von ALU f√§llt in das Register A1.  Oben haben wir angenommen, dass A1 ein Taktz√§hler ist, der zum Einstellen der Dauer des Ausgangsimpulses verwendet wird.  Ich m√∂chte Sie daran erinnern, dass es im letzten Schritt von D1 gebootet wurde. <br>  Was ist die Voraussetzung f√ºr den Austritt aus einem Staat?  <b>CycleTimeOut</b> .  Es wird unter den Ausg√§ngen wie folgt beschrieben: <br><br><img src="https://habrastorage.org/webt/7m/1c/pn/7m1cpnxbqkt6fv4x5fv73idlp3g.png"><br><br>  Also bringen wir Logik zusammen.  Im vorherigen Zustand fiel der Inhalt des zuvor vom Programm ausgef√ºllten Registers D1 in das Register A1.  In diesem Schritt √ºbersetzt die Maschine den <b>CurrentBit-</b> Trigger in eins, und in ALU nimmt das A1-Register bei jedem Taktzyklus ab.  Wenn A1 Null wird, wird automatisch das Flag gesetzt, dem der Autor den Namen <b>CycleTimeout gegeben hat</b> , wodurch der Computer in den <b>Status Setup1 wechselt</b> . <br><br>  Der Zustand <b>Setup1</b> bereitet Daten f√ºr die √úbertragung des <b>Nutzimpulses</b> vor. <br><br><img src="https://habrastorage.org/webt/on/3g/j-/on3gj-j0zujays_x6uxn_grjnq8.png"><br><br>  Wir sehen uns die ALU-Anweisung bei 3'b011 an.  Ich werde es sofort √∂ffnen: <br><br><img src="https://habrastorage.org/webt/2u/uu/tl/2uuutl1vwixsvirqgsuwfvxhsb4.png"><br><br>  Es scheint, dass ALU keine Aktionen hat.  Operation NOP.  Und der ALU-Ausgang kommt nicht weiter.  Aber das ist nicht so.  Eine √§u√üerst wichtige Aktion ist die Datenverschiebung in ALU.  Tatsache ist, dass das √úbertragsbit zwischen den Ausg√§ngen mit unserer <b>ShiftOut-</b> Kette verbunden ist: <br><br><img src="https://habrastorage.org/webt/ov/8g/-e/ov8g-emfyzhu3vhj65unf0ukirw.png"><br><br>  Und als Ergebnis dieser Verschiebungsoperation wird der verschobene Wert selbst nirgendwo hinkommen, aber die <b>ShiftOut-</b> Kette nimmt den Wert des h√∂chstwertigen Bits des Registers A0 an.  Das hei√üt, die Daten, die √ºbertragen werden sollen.  Im Status des Diagramms ist ersichtlich, dass dieser Wert, der die ALU in der <b>ShiftOut-</b> Kette <b>belassen</b> hat, im <b>CurrentBit-</b> Trigger zwischengespeichert wird.  Lassen Sie mich die Zeichnung noch einmal zeigen, um den Artikel nicht zur√ºckzuspulen: <br><br><img src="https://habrastorage.org/webt/3t/kq/ef/3tkqefuwb4cbt1mdx7uiqlwazjo.png"><br><br>  Die √úbertragung des zweiten Teils des Bits beginnt - der unmittelbare Wert ist 0 oder 1. <br><br>  Wir kehren zu den Anweisungen f√ºr ALU zur√ºck.  Zus√§tzlich zu dem, was bereits gesagt wurde, ist es klar, dass der Inhalt des Registers D1 erneut in das Register A1 gestellt wird, um die Dauer des zweiten Drittels des Impulses erneut zu messen. <br><br>  Der <b>DataStage-</b> Status ist dem <b>Constant1-</b> Status sehr √§hnlich.  Der Automat subtrahiert einfach eins von A1 und tritt in den n√§chsten Zustand ein, wenn er Null erreicht.  Lassen Sie es mich sogar so zeigen: <br><br><img src="https://habrastorage.org/webt/ya/ir/hs/yairhsxxk0q9jvmctsthu0lswjk.png"><br><br>  und so: <br><br><img src="https://habrastorage.org/webt/_-/cj/k9/_-cjk95cwake-lvvpgv5p4gc33i.png"><br><br>  Dann kommt der Zustand von <b>Setup2</b> , dessen Essenz wir bereits kennen. <br><br><img src="https://habrastorage.org/webt/x6/bw/qa/x6bwqa1zi6_s0zdcazzcgcp_emw.png"><br><br>  In diesem Zustand wird der <b>CurrentBit-</b> Trigger auf Null zur√ºckgesetzt (da das dritte Drittel des Impulses √ºbertragen wird, der <b>Stoppteil</b> , und es ist immer Null).  ALU l√§dt den Inhalt von D1 in A1.  Sie k√∂nnen es sogar in einer kurzen Notiz mit Ihrem geschulten Auge sehen: <br><br><img src="https://habrastorage.org/webt/dv/pm/1q/dvpm1qqxtwut-1egggnj5mgintu.png"><br><br>  Der Status von <b>Constant0 ist</b> vollst√§ndig identisch mit dem <b>Status</b> von <b>Constant1</b> und <b>DataStage</b> .  Subtrahieren Sie die Einheit von A1.  Wenn der Wert Null erreicht, <b>kehren Sie</b> zum <b>ShiftData-</b> Status zur√ºck: <br><br><img src="https://habrastorage.org/webt/d2/bs/bx/d2bsbxn-pd5opvpeh3g8us5aqkg.png"><br><br><img src="https://habrastorage.org/webt/4i/g2/my/4ig2mytms6p5mt2_msq8cwl33hi.png"><br><br>  Der Status von <b>ShiftData ist</b> komplexer.  In den entsprechenden Anweisungen f√ºr ALU werden die folgenden Aktionen ausgef√ºhrt: <br><br><img src="https://habrastorage.org/webt/r7/hn/bx/r7hnbxsnr0ynuxfexzrlisurybi.png"><br><br>  Das Register A0 wird um 1 Bit verschoben, und die Ergebnisse werden in A0 zur√ºckgesetzt.  In A1 wird der Inhalt von D1 erneut eingef√ºgt, um mit dem Messen des Startdrittels f√ºr das n√§chste Datenbit zu beginnen. <br><br>  Es ist besser, die Ausgabepfeile unter Ber√ºcksichtigung der Priorit√§ten zu ber√ºcksichtigen, f√ºr die wir auf den <b>ShiftData-</b> Status <b>doppelklicken</b> . <br><br><img src="https://habrastorage.org/webt/sp/dx/f1/spdxf1xnw2j_7ytbypqrbhql6da.png"><br><br>  Wenn nicht das letzte Bit √ºbertragen wird (etwa wie dieses Flag gebildet wird, etwas niedriger), √ºbertragen wir eines f√ºr das n√§chste Bit des aktuellen Bytes. <br><br>  Wenn das letzte Bit √ºbertragen wird und keine Daten im FIFO vorhanden sind, wechseln wir in den Ruhezustand. <br><br>  Wenn schlie√ülich das letzte Bit √ºbertragen wird, sich jedoch Daten im FIFO befinden, fahren wir mit der Auswahl und √úbertragung des n√§chsten Bytes fort. <br><br>  Nun zum Bitz√§hler.  In ALU befinden sich nur zwei Batterien: A0 und A1.  Sie sind bereits vom Schieberegister bzw. vom Verz√∂gerungsz√§hler belegt.  Daher wird ein Bitz√§hler extern verwendet. <br><br><img src="https://habrastorage.org/webt/dx/p2/wv/dxp2wv0kt0othgs12nwnq7anuqs.png"><br><br>  Doppelklicken Sie darauf: <br><br><img src="https://habrastorage.org/webt/dz/tj/kz/dztjkza856xdotpsckoje-fnmzo.png"><br><br>  Der Wert beim Booten ist sechs.  Es wird mit dem im Abschnitt "Variablen" beschriebenen <b>LoadCounter-</b> Flag geladen: <br><br><img src="https://habrastorage.org/webt/e3/-a/tf/e3-atfbenscj9nudppvxrab9ylg.png"><br><br>  Das hei√üt, wenn das n√§chste Datenbyte genommen wird, wird diese Konstante auf dem Weg geladen. <br><br>  Wenn die Maschine in den <b>ShiftData-</b> Status wechselt, verringert der Z√§hler den Wert.  Wenn es Null erreicht, ist der Ausgang <b>TerminalCount</b> mit der Schaltung unseres <b>FinalBit-Seeds verbunden</b> .  Es ist diese Schaltung, die festlegt, ob die Maschine das n√§chste Bit des aktuellen Bytes √ºbertr√§gt oder ein neues Byte √ºbertr√§gt (nun, oder auf ein neues Datenpaket warten). <br><br>  Eigentlich ist alles aus Logik.  Wie das <b>SpaceForData-</b> Signal <b>erzeugt wird</b> , das den Status des <b>Hungry-</b> Ausgangs <b>festlegt</b> (wodurch die DMA-Einheit dar√ºber informiert wird, dass die n√§chsten Daten √ºbertragen werden k√∂nnen), werden die Leser aufgefordert, unabh√§ngig zu verfolgen. <br><br><h2>  Software-Support </h2><br>  Der Autor des urspr√ºnglichen Projekts hat sich daf√ºr entschieden, Software-Unterst√ºtzung f√ºr das gesamte System in dem Block bereitzustellen, der die integrierte L√∂sung beschreibt.  Ich m√∂chte Sie daran erinnern, dass es sich um diesen Block handelt: <br><br><img src="https://habrastorage.org/webt/pi/uz/vz/piuzvzjzbcuaqyqqlwnvrmwgh8m.png"><br><br>  Ab dieser Ebene k√∂nnen Sie sowohl die DMA-Bibliothekseinheit als auch alle im UDB-Teil enthaltenen Teile steuern.  Um die API zu implementieren, f√ºgte der Autor des Originals die Header- und Programmdateien hinzu: <br><br><img src="https://habrastorage.org/webt/af/2y/aw/af2yaw0qcmxmjzsevxq30sjwfc4.png"><br><br>  Das Textformat dieser Dateien macht Sie traurig.  Die ganze Schuld liegt in der Liebe der PSoC Designer-Entwickler zu den "reinen".  Daher die schrecklichen Makros und Kilometernamen.  Die Klassenorganisation in C ++ w√§re hier n√ºtzlich.  Zumindest haben wir dies bei der Implementierung unseres RTOS MAX √ºberpr√ºft: Es hat sich als sch√∂n und bequem herausgestellt.  Aber hier k√∂nnen Sie viel streiten, aber Sie m√ºssen das verwenden, was von oben auf uns herabgesetzt wurde.  Ich werde nur kurz zeigen, wie die API-Funktion mit diesen Makros aussieht: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* `$INSTANCE_NAME`_Start(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nNumberOfNeopixels, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pBuffer, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fSpeedMHz) { <span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... `$INSTANCE_NAME`_g_pFrameBuffer = NULL; if((0.3/(1.0/(fSpeedMHz))) &gt; 255) return NULL; unsigned char fCyclesOn = (unsigned char)(0.35/(1.0/(fSpeedMHz))); `$INSTANCE_NAME`_g_nFrameBufferSize = nNumberOfNeopixels*3; //Configure for 19.2 MHz operation `$INSTANCE_NAME`_Neo_BITCNT_Start(); //Counts bits in a byte //Sets bitrate frequency in number of clocks. Must be larger than largest of above two counter periods CY_SET_REG8(`$INSTANCE_NAME`_Neo_DPTH_D1_PTR, fCyclesOn+1); //Setup a DMA channel `$INSTANCE_NAME`_g_nDMA_Chan = `$INSTANCE_NAME`_DMA_DmaInitialize(`$INSTANCE_NAME`_DMA_BYTES_PER_BURST, `$INSTANCE_NAME`_DMA_REQUEST_PER_BURST, HI16(`$INSTANCE_NAME`_DMA_SRC_BASE), HI16(`$INSTANCE_NAME`_DMA_DST_BASE)); if(pBuffer == NULL) ...</span></span></code> </pre> <br>  Diese Spielregeln m√ºssen akzeptiert werden.  Jetzt wissen Sie, woher Sie sich bei der Entwicklung Ihrer Funktionen inspirieren lassen k√∂nnen (am besten im urspr√ºnglichen Projekt).  Und ich spreche lieber √ºber die Details und nehme die Option, die bereits vom Generator verarbeitet wurde. <br><br>  Nach dem Generieren des Codes (unten beschrieben) wird diese Datei hier gespeichert: <br><br><img src="https://habrastorage.org/webt/b2/c_/j_/b2c_j_llpmg3yjjwirq4b3bjkag.png"><br><br>  Und die Ansicht ist bereits perfekt lesbar.  Bisher gibt es zwei Funktionen.  Der erste initialisiert das System, der zweite startet die Daten√ºbertragung vom Puffer zur LED-Leitung. <br><br>  Die Initialisierung betrifft alle Teile des Systems.  Der 7-Bit-Z√§hler, der Teil des UDB-Systems ist, wird initialisiert: <br><br><pre> <code class="cpp hljs"> NP_Neo_BITCNT_Start(); <span class="hljs-comment"><span class="hljs-comment">//Counts bits in a byte</span></span></code> </pre> <br>  Es gibt eine konstante Berechnung, die in das D1-Register geladen werden sollte (ich erinnere mich, dass sie die Dauer jedes der dritten Bits festlegt): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fCyclesOn = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)(<span class="hljs-number"><span class="hljs-number">0.35</span></span>/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/(fSpeedMHz))); CY_SET_REG8(NP_Neo_DPTH_D1_PTR, fCyclesOn+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Das Einrichten eines DMA-Blocks √ºbernimmt den gr√∂√üten Teil dieser Funktion.  Der Puffer wird als Quelle und der FIFO0 des UDB-Blocks als Empf√§nger verwendet (NP_Neo_DPTH_F0_PTR im Kilometerdatensatz).  Der Autor hatte einen Teil dieser Einstellung in der Daten√ºbertragungsfunktion.  Aber meiner Meinung nach ist es zu verschwenderisch, alle Berechnungen f√ºr jede √úbertragung durchzuf√ºhren.  Besonders wenn man bedenkt, dass eine der Aktionen innerhalb der Funktion sehr, sehr umfangreich aussieht. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... NP_g_pFrameBuffer = NULL; NP_g_nFrameBufferSize = nNumberOfNeopixels*3; //Setup a DMA channel NP_g_nDMA_Chan = NP_DMA_DmaInitialize(NP_DMA_BYTES_PER_BURST, NP_DMA_REQUEST_PER_BURST, HI16(NP_DMA_SRC_BASE), HI16(NP_DMA_DST_BASE)); ... NP_g_nDMA_TD = CyDmaTdAllocate(); CyDmaTdSetConfiguration(NP_g_nDMA_TD, NP_g_nFrameBufferSize, CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(NP_g_nDMA_TD, LO16((uint32)NP_g_pFrameBuffer), LO16((uint32)NP_Neo_DPTH_F0_PTR)); CyDmaChSetInitialTd(NP_g_nDMA_Chan, NP_g_nDMA_TD);</span></span></code> </pre><br>  Die zweite Funktion vor dem Hintergrund der ersten ist die Spitze des Lakonismus.  Es ist nur so, dass der erste in der Initialisierungsphase aufgerufen wird, wenn die Leistungsanforderungen recht kostenlos sind.  W√§hrend des Betriebs ist es besser, Prozessorzyklen nicht mit √ºberfl√ºssigen Dingen zu verschwenden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NP_Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(NP_g_pFrameBuffer) { CyDmaChEnable(NP_g_nDMA_Chan, <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br>  Es gibt eindeutig nicht gen√ºgend Funktionen, um mit mehreren Puffern zu arbeiten (um eine doppelte Pufferung bereitzustellen), aber im Allgemeinen w√ºrde eine Diskussion der API-Funktionen den Rahmen des Artikels sprengen.  Die Hauptsache ist nun zu zeigen, wie man der entwickelten Firmware Software-Unterst√ºtzung hinzuf√ºgt.  Jetzt wissen wir, wie es geht. <br><br><h2>  Projektgenerierung </h2><br>  Also, der gesamte Firmware-Teil ist fertig, die API wird hinzugef√ºgt, was ist als n√§chstes zu tun?  W√§hlen Sie den Men√ºpunkt <b>Build-&gt; Generate Application</b> . <br><br><img src="https://habrastorage.org/webt/b-/5d/yv/b-5dyvvwubusbcm5f4xzy7bhie4.png"><br><br>  Wenn alles gut geht, k√∂nnen Sie die Registerkarte <b>Ergebnisse</b> √∂ffnen und die Datei mit der Erweiterung <b>rpt anzeigen</b> . <br><br><img src="https://habrastorage.org/webt/d2/5e/4d/d25e4d3xlv845numi21z2wzxzba.png"><br><br>  Es zeigt, wie viel Systemressourcen in die Implementierung der Firmware geflossen sind. <br><br><img src="https://habrastorage.org/webt/bv/mm/yn/bvmmynvgxcssd33wk-aetjwwbd4.png"><br><br><img src="https://habrastorage.org/webt/wr/_u/mo/wr_umoub3comqr_3v4qxcqbhpwi.png"><br><br>  Wenn ich die Ergebnisse mit denen des urspr√ºnglichen Projekts vergleiche, wird meine Seele w√§rmer. <br><br>  Gehen Sie nun zur Registerkarte <b>Quelle</b> und beginnen Sie mit der Arbeit mit dem Software-Teil.  Dies ist jedoch bereits trivial und erfordert keine besonderen Erkl√§rungen. <br><br><img src="https://habrastorage.org/webt/w4/d6/d5/w4d6d5fhjcllllxyqtjva7j-upo.png"><br><br><h2>  Fazit </h2><br>  Ich hoffe, dass die Leser anhand dieses Beispiels etwas Neues und Interessantes √ºber die praktische Arbeit mit UDB-Bl√∂cken gelernt haben.  Ich habe versucht, mich auf eine bestimmte Aufgabe (LED-Steuerung) sowie auf die Entwurfsmethodik zu konzentrieren, da ich einige Aspekte verstehen musste, die f√ºr Spezialisten offensichtlich waren.  Ich habe versucht, sie zu markieren, w√§hrend die Erinnerungen an die Suche frisch sind.  Was das gel√∂ste Problem betrifft, so erwiesen sich die Zeitdiagramme f√ºr mich als nicht so ideal wie die des Autors der urspr√ºnglichen Entwicklung, aber sie passen perfekt zu den in der Dokumentation f√ºr die LEDs definierten Toleranzen, und die Systemressourcen waren erheblich geringer. <br><br>  Tats√§chlich ist dies nur ein Teil der gefundenen nicht standardm√§√üigen Informationen.  Insbesondere aus den meisten Materialien scheint es, dass UDB nur mit seriellen Daten gut funktioniert, dies ist jedoch nicht der Fall.  Gefundene Anwendungsnotiz, die kurz zeigt, wie Sie Daten ansteuern und parallel schalten k√∂nnen.  Basierend auf diesen Informationen k√∂nnten wir spezifische Beispiele betrachten (obwohl es unm√∂glich ist, den FX2LP, einen anderen Controller von Cypress, zu √ºberschatten: PSoC hat eine niedrigere USB-Busgeschwindigkeit). <br><br>  Mein Kopf dreht sich um Ideen, wie ich das Problem des ‚ÄûFlashens‚Äú eines 3D-Druckers l√∂sen kann, das mich schon lange gequ√§lt hat.  Dort verschlingen Interrupts, die Schrittmotoren bedienen, nur einen wahnsinnigen Prozentsatz der CPU-Zeit.  Im Allgemeinen habe ich in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel √ºber RTOS MAX</a> viel √ºber Interrupts und Prozessorzeit gesprochen.  Es gibt Sch√§tzungen, dass es f√ºr die Wartung von Schrittmotoren m√∂glich ist, alle tempor√§ren H√ºtten vollst√§ndig zur UDB zu bringen, so dass der Prozessor eine rein rechnerische Aufgabe bleibt, ohne bef√ºrchten zu m√ºssen, dass er in einem bestimmten Zeitfenster keine Zeit daf√ºr hat. <br><br>  Diese Dinge k√∂nnen jedoch nur begr√ºndet werden, wenn das Thema interessant ist. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429882/">https://habr.com/ru/post/de429882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429866/index.html">Gewusst wie: IT-Begriffe in Englisch</a></li>
<li><a href="../de429872/index.html">Sound- und musikbasierte Umgebungsgenerierung in Unity3D</a></li>
<li><a href="../de429876/index.html">Die Forscher haben die m√§chtigsten Werbeblocker √ºberwunden, der Formatkrieg kommt</a></li>
<li><a href="../de429878/index.html">Warum sind mit dem Wachstum des Unternehmens die Entwickler, die an der Spitze standen, ‚Äû√ºber Bord‚Äú?</a></li>
<li><a href="../de429880/index.html">Pix4D - von Fotos bis zu Messungen</a></li>
<li><a href="../de429884/index.html">PROSTOR 2018 Konferenz: Fragen und Antworten zur Zukunft der Speicherung</a></li>
<li><a href="../de429888/index.html">Stapelbasierter Taschenrechner auf der Cyclone IV FPGA-Karte</a></li>
<li><a href="../de429890/index.html">Offenes Webinar "Generative gegnerische Netzwerke"</a></li>
<li><a href="../de429892/index.html">xonsh - Python als Shell-Ersatz</a></li>
<li><a href="../de429894/index.html">Verwenden eines Fischauges auf einem Raspberry Pi 3 mit ROS - Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>