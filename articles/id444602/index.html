<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘 🔞 ☘️ Enkapsulasi dalam C ++ dan C 👆🏿 🚇 🤹🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Definisi 


 Enkapsulasi adalah seperangkat alat untuk mengontrol akses ke data atau metode yang mengelola data itu. Definisi terperinci dari istilah ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enkapsulasi dalam C ++ dan C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444602/"><p><img src="https://habrastorage.org/webt/uq/da/c9/uqdac9e3znu_dgoypeekipj7so8.png"></p><br><h1 id="opredelenie">  Definisi </h1><br><p>  Enkapsulasi adalah seperangkat alat untuk mengontrol akses ke data atau metode yang mengelola data itu.  Definisi terperinci dari istilah "enkapsulasi" dapat ditemukan dalam publikasi saya sebelumnya tentang Habré di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ini.  Artikel ini berfokus pada contoh enkapsulasi dalam C ++ dan C. </p><br><h1 id="inkapsulyaciya-v-si">  Enkapsulasi dalam C ++ </h1><br><p> Secara default, dalam suatu kelas ( <code>class</code> ) data dan metode bersifat pribadi ( <code>private</code> );  mereka hanya dapat dibaca dan dimodifikasi oleh kelas tempat mereka berada.  Tingkat akses dapat diubah menggunakan kata kunci yang sesuai yang disediakan C ++. </p><br><p>  Beberapa kualifikasi tersedia dalam C ++, dan mereka memodifikasi akses data sebagai berikut: </p><a name="habracut"></a><br><ul><li>  data publik tersedia untuk semua orang; </li><li>  protected ( <code>protected</code> ) - hanya tersedia untuk kelas dan kelas anak; </li><li>  privat - <code>private</code> - hanya tersedia untuk kelas di mana mereka berada. </li></ul><br><p>  Untuk singkatnya, hanya dua tingkat (swasta dan publik) yang akan disorot dalam contoh. </p><br><h2 id="primer-inkapsulyacii">  Contoh enkapsulasi </h2><br><p>  Di kelas <code>Contact</code> , variabel dan metode publik dapat diakses dari program utama.  Variabel dan metode pribadi hanya dapat dibaca, dipanggil, atau diubah oleh kelas itu sendiri. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } void print_numbers() { cout &lt;&lt; "Mobile number: " &lt;&lt; mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; home_number &lt;&lt; endl; } }; int main() { Contact Tony; Tony.print_numbers(); // cout &lt;&lt; Tony.mobile_number &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  Mencoba mencetak atau memodifikasi variabel private <code>mobile_number</code> dari program <code>main</code> ( <code>main</code> ) akan menyebabkan kesalahan kompilasi karena akses ke data pribadi di kelas terbatas. </p><br><h2 id="narushenie-inkapsulyacii-s-druzyami-horoshaya-praktika">  Pelanggaran Enkapsulasi dengan Teman (Praktik yang Baik) </h2><br><p>  Di C ++, ada kata kunci “teman” yang memungkinkan Anda menambahkan pengecualian pada aturan umum untuk mengakses data.  Jika suatu fungsi atau kelas disebut sebagai teman dari kelas <code>Contact</code> , mereka mendapatkan akses gratis ke data pribadi atau dilindungi. </p><br><p>  Ada dua aturan dasar persahabatan - persahabatan tidak diwariskan dan tidak saling menguntungkan.  Juga, kehadiran "teman" tidak mengubah tingkat keamanan data - data pribadi tetap pribadi dengan pengecualian "teman". </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } // Declaring a global 'friend' function friend void print_numbers( Contact some_contact ); }; void print_numbers( Contact some_contact ) { cout &lt;&lt; "Mobile number: " &lt;&lt; some_contact.mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; some_contact.home_number &lt;&lt; endl; } int main() { Contact Tony; print_numbers(Tony); return 0; }</span></span></span></span></code> </pre> <br><p>  Dalam contoh ini, fungsi <code>print_numbers()</code> adalah fungsi normal, bukan metode kelas <code>Contact</code> .  Mendeklarasikan fungsi <code>print_numbers()</code> "teman" kelas <code>Contact</code> adalah satu-satunya alasan fungsi <code>print_numbers()</code> memiliki akses ke data pribadi.  Jika Anda menghapus baris dengan definisi teman, kode tidak akan dikompilasi. </p><br><p>  <em>Catatan</em> : lebih baik tidak menyalahgunakan teman.  Menambahkan teman harus dianggap sebagai pengecualian, bukan sebagai praktik umum. </p><br><h2 id="narushenie-inkapsulyacii-s-preobrazovaniem-tipov-i-ukazatelyami-plohaya-praktika">  Pelanggaran Enkapsulasi dengan Konversi dan Pointer Jenis (Praktik Buruk) </h2><br><p>  Pertama-tama, perlu dicatat bahwa menggunakan pointer dan ketik konversi dengan cara ini adalah ide yang buruk.  Metode ini tidak menjamin penerimaan data yang diperlukan.  Itu kurang dibaca dan tidak dipelihara.  Meskipun demikian, ia ada. </p><br><p>  C ++ mewarisi banyak alat dari C, salah satunya adalah <code>typecasting</code> .  Secara default, semua variabel dan metode di kelas bersifat pribadi.  Pada saat yang sama, tingkat standar akses data dalam struktur ( <code>struct</code> ) adalah publik.  Dimungkinkan untuk membuat struktur atau kelas yang sepenuhnya publik di mana data akan ditempatkan secara identik dengan data dalam kelas <code>Contact</code> dan menggunakan konversi tipe untuk mengakses data pribadi. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } void print_numbers() { cout &lt;&lt; "Mobile number: " &lt;&lt; mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; home_number &lt;&lt; endl; } }; struct Contact_struct { int mobile_number; int home_number; }; int main() { Contact Tony; Contact_struct * structured_Tony; Tony.print_numbers(); structured_Tony = (Contact_struct *) &amp; Tony; structured_Tony-&gt;mobile_number = 20; structured_Tony-&gt;home_number = 30; Tony.print_numbers(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Data pribadi telah dibaca dan dimodifikasi karena konversi jenis</em> </p><br><h1 id="inkapsulyaciya-v-si-1">  Enkapsulasi C </h1><br><p>  Enkapsulasi secara tradisional dianggap sebagai salah satu prinsip utama OOP.  Namun, ini tidak membatasi penggunaan prinsip ini dalam bahasa yang berorientasi prosedural.  Di C, enkapsulasi telah digunakan untuk waktu yang lama, meskipun tidak ada kata kunci "pribadi" dan "publik". </p><br><h2 id="privatnye-peremennye">  Variabel pribadi </h2><br><p>  Dalam konteks enkapsulasi, semua data dalam C dapat dianggap publik secara default.  Tingkat akses ke variabel dalam struktur ( <code>struct</code> ) dapat diubah menjadi pribadi jika definisi mereka diisolasi dari program utama.  Efek yang diinginkan dapat dicapai dengan menggunakan file header (header, .h) dan sumber (source, .c) yang terpisah. </p><br><p>  Dalam contoh ini, struktur didefinisikan dalam file sumber terpisah "private_var.c".  Karena menginisialisasi struktur dalam C memerlukan pengalokasian dan membebaskan memori, beberapa fungsi pembantu telah ditambahkan. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct Contact { int mobile_number; int home_number; }; struct Contact * create_contact() { struct Contact * some_contact; some_contact = malloc(sizeof(struct Contact)); some_contact-&gt;mobile_number = 12345678; some_contact-&gt;home_number = 87654321; return( some_contact ); } void delete_contact( struct Contact * some_contact ) { free(some_contact); }</span></span></span></span></code> </pre> <br><p>  Dalam file header yang sesuai "private_var.h", struktur <code>Contact</code> dideklarasikan, tetapi isinya tetap tersembunyi ke program utama. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PRIVATE_VAR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PRIVATE_VAR struct Contact; struct Contact * create_contact(); void delete_contact( struct Contact * some_contact ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PRIVATE_VAR */</span></span></span></span></code> </pre> <br><p>  Dengan demikian, untuk "main.c" isi struktur tidak diketahui dan upaya untuk membaca atau memodifikasi data pribadi akan menyebabkan kesalahan kompilasi. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); // printf( "Mobile number: %d\n", Tony-&gt;mobile_number); // will cause compile time error delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><h2 id="poluchenie-dostupa-k-privatnym-peremennym-s-ukazatelyami">  Mengakses variabel pribadi dengan Pointer </h2><br><p>  Konversi tipe dapat digunakan untuk mengatasi enkapsulasi dalam C serta C ++, tetapi pendekatan ini telah dijelaskan.  Mengetahui bahwa dalam struktur data diatur dalam urutan deklarasi mereka, pointer dan aritmatika pointer cocok untuk mencapai tujuan. </p><br><p>  Akses ke variabel dalam struktur terbatas.  Namun, hanya variabel yang disembunyikan, bukan memori tempat data disimpan.  Pointer dapat dianggap sebagai referensi ke alamat memori, dan jika memori ini tersedia untuk program, data yang disimpan dalam memori ini dapat dibaca dan diubah.  Jika pointer ditugaskan ke memori di mana struktur menyimpan datanya - mereka dapat dibaca.  Menggunakan definisi struktur yang sama (file ".c" dan ".h" yang sama) dan file "main.c" yang dimodifikasi, pembatasan akses diatasi. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); int * mobile_number_is_here = (int *)Tony; printf("Mobile number: %d\n", *mobile_number_is_here); int * home_number_is_here = mobile_number_is_here + 1; *home_number_is_here = 1; printf("Modified home number: %d\n", *home_number_is_here); delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Data dalam struktur telah dibaca dan dimodifikasi</em> </p><br><h2 id="privatnye-funkcii">  Fungsi pribadi </h2><br><p>  Fungsi, sebagai eksternal ( <code>extern</code> ) secara default, terlihat di seluruh <code>translation unit</code> disebut.  Dengan kata lain, jika beberapa file dikompilasi bersama menjadi satu file objek, salah satu file ini akan dapat mengakses fungsi apa pun dari file lainnya.  Menggunakan <code>static</code> "statis" saat membuat fungsi akan membatasi visibilitasnya ke file yang didefinisikan. Oleh karena itu, untuk memastikan privasi fungsi, Anda perlu melakukan beberapa langkah: </p><br><ul><li>  fungsi harus dinyatakan statis ( <code>static</code> ) baik dalam file sumber (.c) atau dalam file header yang sesuai (.h); </li><li>  definisi fungsi harus dalam file sumber terpisah. </li></ul><br><p>  Dalam contoh ini, fungsi statis <code>print_numbers()</code> didefinisikan dalam file "private_funct.c".  By the way, fungsi <code>delete_contact()</code> berhasil memanggil <code>print_numbers()</code> karena mereka berada di file yang sama. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_funct.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct Contact { int mobile_number; int home_number; }; struct Contact * create_contact() { struct Contact * some_contact; some_contact = malloc(sizeof(struct Contact)); some_contact-&gt;mobile_number = 12345678; some_contact-&gt;home_number = 87654321; return( some_contact ); } static void print_numbers( struct Contact * some_contact ) { printf("Mobile number: %d, ", some_contact-&gt;mobile_number); printf("home number = %d\n", some_contact-&gt;home_number); } void delete_contact( struct Contact * some_contact ) { print_numbers(some_contact); free(some_contact); }</span></span></span></span></code> </pre> <br><p>  Dalam file header yang sesuai "private_funct.h", <code>print_numbers()</code> dinyatakan sebagai fungsi statis. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PRIVATE_FUNCT_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PRIVATE_FUNCT_H struct Contact; struct Contact * create_contact(); static void print_numbers( struct Contact * some_contact ); void delete_contact( struct Contact * my_points ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PRIVATE_FUNCT_H */</span></span></span></span></code> </pre> <br><p>  Program utama, "main.c", berhasil memanggil <code>print_numbers()</code> secara tidak langsung melalui <code>delete_contact()</code> , karena kedua fungsi berada dalam dokumen yang sama.  Namun, upaya untuk memanggil <code>print_numbers()</code> dari program utama akan <code>print_numbers()</code> kesalahan. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_funct.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); // print_numbers( Tony ); // will cause compile time error delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><h2 id="poluchenie-dostupa-k-privatnym-funkciyam">  Mengakses Fitur Pribadi </h2><br><p>  <code>print_numbers()</code> memanggil <code>print_numbers()</code> dari program utama.  Untuk melakukan ini, Anda dapat menggunakan kata kunci <code>goto</code> atau meneruskan pointer ke fungsi pribadi di <code>main</code> .  Kedua metode memerlukan perubahan baik dalam file sumber "private_funct.c", atau langsung di tubuh fungsi itu sendiri.  Karena metode ini tidak mem-bypass enkapsulasi dan membatalkannya, mereka berada di luar cakupan artikel ini. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Enkapsulasi ada di luar bahasa OOP.  Bahasa OOP modern membuat penggunaan enkapsulasi menjadi nyaman dan alami.  Ada banyak cara untuk menghindari enkapsulasi dan menghindari praktik yang dipertanyakan akan membantu melestarikannya dalam C dan C ++. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444602/">https://habr.com/ru/post/id444602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444592/index.html">Militer AS berencana untuk menggunakan exoskeleton tipe baru</a></li>
<li><a href="../id444594/index.html">Besar o</a></li>
<li><a href="../id444596/index.html">Iodide: Editor Sains Interaktif Mozilla</a></li>
<li><a href="../id444598/index.html">CD itu berusia 40 tahun dan dia sudah mati (kan?)</a></li>
<li><a href="../id444600/index.html">Ulasan dari 14 cm tanpa kepala 2019</a></li>
<li><a href="../id444610/index.html">Statistik dan pemantauan skrip PHP secara real time. ClickHouse dan Grafana pergi untuk membantu Pinba</a></li>
<li><a href="../id444612/index.html">Kerugian makro untuk kode C ++</a></li>
<li><a href="../id444614/index.html">Seluruh sejarah Linux. Bagian II: pasang surut perusahaan</a></li>
<li><a href="../id444616/index.html">Membuat Perekam Suara Android Anda Sendiri Menggunakan Kotlin</a></li>
<li><a href="../id444620/index.html">Menggunakan File Urutan Kernel Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>