<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèæ üßïüèΩ üï¶ Wie wir unsere Workflow-Engine hergestellt haben üÉè ‚èπÔ∏è üê†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei DIRECTUM entwickeln wir das DirectumRX ECM-System. Das Kernelement des Workflow-Moduls f√ºr das ECM-System ist die Engine. Er ist daf√ºr verantwortl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir unsere Workflow-Engine hergestellt haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/468803/">  Bei DIRECTUM entwickeln wir das DirectumRX ECM-System.  Das Kernelement des Workflow-Moduls f√ºr das ECM-System ist die Engine.  Er ist daf√ºr verantwortlich, den Status der Prozessinstanz (Instanz) w√§hrend des Lebenszyklus zu √§ndern.  Bevor Sie mit der Entwicklung des Workflow-Moduls beginnen, sollten Sie sich entscheiden: Nehmen Sie eine vorgefertigte Engine oder schreiben Sie Ihre eigene.  Anfangs haben wir uns f√ºr die erste Option entschieden.  Wir haben die Windows Workflow Foundation (WF) -Engine verwendet und insgesamt hat sie uns gepasst.  Aber im Laufe der Zeit wurde uns klar, dass wir unseren eigenen Motor brauchten.  Wie das passiert ist und was daraus geworden ist, werde ich weiter unten erz√§hlen. <br><a name="habracut"></a><br><h2>  Alter Motor </h2><br><h3>  Warum wf? </h3><br>  Bereits 2013, als es Zeit war, ein Workflow-Modul f√ºr DirectumRX zu entwickeln, entschieden wir uns f√ºr eine vorgefertigte Engine.  Betrachtet von Windows Workflow Foundation (WF), ActiveFlow, K2.NET, WorkflowEngine.NET, cDevWorkflow, NetBpm.  Einige waren mit den Kosten nicht zufrieden, andere waren roh, andere waren zu diesem Zeitpunkt schon lange nicht mehr unterst√ºtzt worden. <br>  Infolgedessen fiel die Wahl auf WF.  Wir haben dann aktiv den Microsoft-Stack (WCF, WPF) verwendet und entschieden, dass ein anderes W uns nicht verletzen w√ºrde.  Ein weiterer Vorteil war unser Status als Microsoft Gold Application Development Partner, der es erm√∂glichte, Produkte mit Microsoft-Technologien zu entwickeln.  Im Allgemeinen passten die F√§higkeiten des Motors zu uns und deckten fast alle unsere F√§lle ab. <br><br><h3>  Was ist los mit WF? </h3><br>  Nach 6 Jahren mit WF haben wir eine Reihe von Problemen angeh√§uft, und die Kosten f√ºr die L√∂sung dieser Probleme waren zu hoch.  Wir begannen dar√ºber nachzudenken, unseren eigenen Motor zu entwickeln.  Ich werde Ihnen von einigen erz√§hlen. <br><br><h4>  Teure Diagnose und Fehlerbehebungen </h4><br>  Jahre vergingen, die Anzahl der Produktinstallationen und die Last nahmen zu.  Es traten Fehler auf, deren Diagnose und Korrektur viele Ressourcen in Anspruch nahm.  Dies wurde durch eine Reihe von Gr√ºnden erleichtert: mangelnde Kompetenzen, Konstruktionsfehler beim Einbetten der vorherigen Engine und Funktionen von WF. <br>  Wir hatten genug Grundkompetenzen, um WF DirectumRX einzubauen. Das gleiche Niveau reichte aus, um einfache Fehler zu beheben.  In komplexen F√§llen reichten die Kompetenzen nicht aus - die Analyse von Protokollen, die Analyse des Status der Instanz usw. waren schwierig. <br>  Es war m√∂glich, eine Person zu Kursen √ºber WF zu schicken, aber sie lernen kaum, wie man den Status einer Instanz analysiert und ihre √Ñnderung mit Protokollen verkn√ºpft.  Und ehrlich gesagt hatte niemand den besonderen Wunsch, seine F√§higkeiten mit praktisch toter Technologie zu verbessern. <br>  Eine andere M√∂glichkeit besteht darin, eine Person mit den entsprechenden Kompetenzen einzustellen.  Aber einen in Ischewsk zu finden, ist keine so triviale Aufgabe und nicht die Tatsache, dass sein Niveau ausreicht, um unsere Probleme zu l√∂sen. <br>  Tats√§chlich stehen wir vor einer hohen Eintrittsschwelle zur Unterst√ºtzung von WF.  Ich denke, wir w√ºrden uns auf die eine oder andere Weise mit diesem Problem befassen, wenn nicht aus einer Reihe anderer Gr√ºnde. <br>  Ein weiteres Problem war, dass wir beim Erstellen von Prozessdiagrammen unsere eigene Notation verwenden.  Es ist visueller und einfacher zu entwickeln.  Beispielsweise erlaubt WF nicht, ein vollwertiges Diagramm zu implementieren. Sie k√∂nnen keine Sackgassenbl√∂cke zeichnen. Es gibt Funktionen zum Zeichnen paralleler Zweige.  Die Amortisation hierf√ºr ist die Umwandlung unserer Schaltungen in WF-Schaltungen, die nicht so einfach sind und eine Reihe von Einschr√§nkungen auferlegen.  Beim Debuggen musste ich den Status der WF-Schaltung analysieren. Aus diesem Grund ging die Sichtbarkeit verloren. Ich musste Bl√∂cke und Gesichter miteinander vergleichen, um zu verstehen, in welchem ‚Äã‚ÄãSchritt sich die Instanz befand. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/db/7p/fo/db7pfo4ik9gbjjpge475jbnn8zo.png" alt="Bild"></div><br>  <i><font color="99999">Darstellung der Schaltung in DirectumRX</font></i> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e8/40/o7/e840o7sz-zleiogtdvyzhownh2o.png" alt="Bild"></div><br>  <i><font color="99999">Darstellung der Schaltung in WF</font></i> <br>  Wir waren auch mit der Tatsache konfrontiert, dass die WF-Dokumentation das Instanz-Repository schlecht beschreibt.  Wie ich oben geschrieben habe, ist dies bei der Analyse eines Fehlers erforderlich, um den Status der Prozessinstanz zu verstehen.  Au√üerdem wird ein Teil der Daten verschl√ºsselt, was auch die Analyse st√∂rt. <br><br><h4>  Postgres als DBMS </h4><br>  In Russland gibt es seit vielen Jahren einen Trend zur Importsubstitution, und eine der Anforderungen an die Plattform ist immer h√§ufiger die Unterst√ºtzung von Open-Source-Datenbankverwaltungssystemen (DBMS) oder inl√§ndischem DBMS.  Meistens ist es Postgres.  Standardm√§√üig unterst√ºtzt WF nur MS SQL.  Um mit anderen Datenbanken zu arbeiten, k√∂nnen Sie Drittanbieter verwenden.  Wir haben dotConnect von DevArt ausgew√§hlt. <br>  W√§hrend die Ladung leicht war, funktionierte alles gut.  Sobald wir das System unter Last fuhren, traten Probleme auf.  WF konnte pl√∂tzlich die Verarbeitung von Instanzen stoppen und stoppen (vorbereitete Transaktionen wurden beendet), oder alle Nachrichten gingen an die MSMQ Poisoned Queue usw.  Wir haben uns mit all diesen Problemen befasst, aber viel Zeit damit verbracht.  Es gab keine Garantie daf√ºr, dass keine neue erscheinen w√ºrde, deren L√∂sung den gleichen Betrag ausgeben m√ºsste. <br><br><h4>  Pflege auf .net Kern </h4><br>  Nachdem Microsoft .Net Core angek√ºndigt hatte, beschlossen wir, schrittweise darauf zuzugreifen, um eine plattform√ºbergreifende L√∂sung f√ºr unsere L√∂sungen zu erreichen.  Microsoft hat beschlossen, WF nicht an Bord zu nehmen, was uns die √úbertragung des Workflow-Moduls auf .Net Core in der Form versperrte, in der es vorhanden war.  Wir sind uns bewusst, dass es inoffizielle WF-Ports auf .Net Core gibt, darunter auch von WF-Entwicklern, aber nicht alle sind zu 100% kompatibel.  Ein weiterer Faktor war die Weigerung von Microsoft, .Net zu entwickeln.  zugunsten von .Net Core. <br><br><h2>  Neuer Motor </h2><br>  Angesichts all dieser Probleme, L√∂sungsoptionen, der Komplexit√§t von Refactoring und Korrekturen und der Abw√§gung aller Vor- und Nachteile haben wir uns entschlossen, auf eine neue Engine umzusteigen.  Wir haben zun√§chst vorhandene analysiert. <br><br><h3>  Die Wahl </h3><br>  Die Hauptanforderungen bei der Auswahl eines Motors waren: <br><ul><li>  Arbeit an .Net Core; </li><li>  Skalierbarkeit </li><li>  Konvertierung vorhandener Prozessinstanzen mit der M√∂glichkeit, die Ausf√ºhrung nach der Konvertierung fortzusetzen </li><li>  angemessene Kosten f√ºr die Analyse bestehender Probleme </li><li>  arbeiten mit verschiedenen DBMS </li></ul><br>  Dar√ºber hinaus war es erforderlich, dass die Aktivit√§t (Aktivit√§t) Anwendungscode in C # ausf√ºhren konnte, dass Bl√∂cke debuggt werden konnten usw. <br>  Im Rahmen der Analyse bestehender Motoren haben wir Folgendes untersucht: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kern wf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flowwright</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">K2-Workflow</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Workflow-Kern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeebe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Workflow-Engine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dauerhaftes Aufgaben-Framework</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Camunda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Orleans Aktivit√§ten</a> </li></ol><br>  Nachdem wir alle Anforderungen an die √ºberpr√ºften L√∂sungen gestellt und die Kosten f√ºr bezahlte L√∂sungen addiert hatten, waren wir der Ansicht, dass unser Motor nicht sehr teuer ist, zu 100% f√ºr unsere Anforderungen geeignet und leicht zu verfeinern ist. <br><br><h3>  Implementierung / Architektur </h3><br>  In der vorherigen Implementierung war das WF-Modul ein WCF-Dienst, mit dem WF-Bibliotheken verbunden waren.  Er war in der Lage, Prozessinstanzen zu erstellen, Prozesse zu starten, Bl√∂cke auszuf√ºhren, einschlie√ülich Gesch√§ftslogik (von Entwicklern geschriebener Code).  All dies wurde in der IIS-Anwendung gehostet. <br>  In der neuen Implementierung haben wir uns entsprechend dem Trend der Microservice-Architektur entschlossen, den Service sofort in zwei Teile zu unterteilen: Workflow Process Service (WPS) und Workflow Block Service (WBS), die separat gehostet werden k√∂nnen.  Ein weiteres Glied in dieser Kette ist der Anwendungsdienst, der das DirectumRX-System und die Gesch√§ftslogik implementiert und mit dem Clients arbeiten. <br>  WPS ‚Äûgeht‚Äú gem√§√ü dem Schema, WBS verarbeitet Bl√∂cke und f√ºhrt bei jedem Schritt Gesch√§ftslogik aus.  Der Befehl zum Starten des Prozesses kommt vom Anwendungsserver.  Die Interaktion zwischen den Diensten erfolgt mit RabbitMQ.  Im Folgenden werde ich Ihnen mehr √ºber jeden von ihnen erz√§hlen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/-u/ae/lh-uaeasg_8-9xjjtoif5ff1ycg.png"></div><br><br><h4>  Wps </h4><br>  Der Workflow Process Service ist ein Microservice, der f√ºr das Starten von Prozessen und das Umgehen des Prozessdiagramms verantwortlich ist. <br>  Das Service-Repository enth√§lt Prozessdiagramme mit Unterst√ºtzung f√ºr die Versionierung und den serialisierten Status von Prozessinstanzen.  Sie k√∂nnen MS SQL und Postgres als Speicher verwenden. <br>  Der Dienst kann Nachrichten verarbeiten, die von anderen Diensten √ºber RabbitMQ empfangen wurden.  Nachrichten sind im Wesentlichen eine Service-API.  Arten von Nachrichten, die der Dienst empfangen kann: <br><ul><li>  StartProcess - Erstellen Sie eine neue Prozessinstanz und starten Sie einen Crawl darauf. </li><li>  CompleteBlock - Abschluss des Blocks. Nach dieser Nachricht verschiebt der Dienst die Prozessinstanz weiter entlang des Schemas. </li><li>  Suspend / ResumeProcess - Unterbricht die Ausf√ºhrung einer Prozessinstanz, z. B. aufgrund eines Fehlers bei der Verarbeitung eines Blocks, und setzt die Ausf√ºhrung fort, nachdem der Fehler behoben wurde. </li><li>  Abort / RestartProcess - Stoppen Sie die Ausf√ºhrung der Prozessinstanz und starten Sie sie erneut. </li><li>  DeleteProcess - L√∂scht eine Prozessinstanz. </li></ul><br>  Das Schema besteht aus Bl√∂cken und Verbindungen zwischen ihnen (Fl√§chen).  Jedes Gesicht hat eine Kennung, das sogenannte "Ausf√ºhrungsergebnis".  Es gibt 5 Arten von Bl√∂cken: <br><ul><li>  StartBlock </li><li>  Blockieren </li><li>  OrBlock; </li><li>  AndBlock; </li><li>  FinishBlock. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/xw/16/nuxw16yktjqodwjbaxmevmogcgk.png" alt="Bild"></div><br>  <i><font color="99999">WPS-Schemaansicht</font></i> <br>  Wenn eine Nachricht zu Beginn des Prozesses eintrifft, erstellt der Dienst eine Instanz und beginnt, gem√§√ü dem Schema zu "laufen".  Die Klasse, die nach dem Schema f√ºr das ‚ÄûGehen‚Äú verantwortlich ist, nennen wir scherzhaft den ‚ÄûStepator‚Äú.  Eine Schaltung beginnt immer mit einem StartBlock.  Dann nimmt der Strider alle ausgehenden Gesichter und aktiviert sie.  Jeder Block arbeitet nach dem Prinzip des "UND" -Blocks, d.h.  Alle eingehenden Gesichter m√ºssen aktiv sein, damit der Block aktiviert werden kann.  Der Algorithmus entscheidet dann, welche Bl√∂cke aktiviert werden k√∂nnen, und sendet eine PSP-Nachricht, um diese Bl√∂cke zu aktivieren.  WBS verarbeitet den Block und gibt das Ergebnis des WPS zur√ºck.  Abh√§ngig vom Ergebnis der Ausf√ºhrung w√§hlt der Strider die entsprechenden Fl√§chen aus, die zur Aktivierung aus dem Block kommen, und der Prozess wird fortgesetzt. <br>  W√§hrend der Entwicklung stie√üen wir auf interessante Situationen im Zusammenhang mit zyklischen Verbindungen zwischen Bl√∂cken, die bei der Entscheidung, welcher Block aktiviert / gestoppt werden soll, eine zus√§tzliche Logik aufwiesen. <br>  Der Dienst ist autonom, d.h.  √úbergeben Sie ihm einfach das Schema im Json-Format, schreiben Sie Ihren eigenen Block-Handler und Sie k√∂nnen Nachrichten austauschen. <br><br><h4>  Wbs </h4><br>  Der Workflow-Blockdienst ist ein Dienst, der Blockdiagramme verarbeitet.  Der Dienst kennt die Essenz der Gesch√§ftslogik wie Aufgabe, Aufgabe usw.  Diese Entit√§ten k√∂nnen der DDS-Entwicklungsumgebung (DirectumRX Development Studio) hinzugef√ºgt werden.  Zum Beispiel haben unsere Bl√∂cke ein Ereignis, um den Block zu starten.  Der Code f√ºr diesen Ereignishandler wird vom Entwickler in DDS geschrieben, und WBS f√ºhrt diesen Code aus.  Tats√§chlich ist dies unsere Implementierung des Block-Handlers, den Sie durch Ihren eigenen ersetzen k√∂nnen. <br>  Der Dienst speichert den Status der Bl√∂cke.  Zus√§tzlich zu den grundlegenden Eigenschaften (ID, Status) kann der Block andere Informationen enthalten, die f√ºr die Ausf√ºhrung / Beendigung / Suspendierung des Blocks erforderlich sind. <br>  Bl√∂cke k√∂nnen sich in einem Zustand befinden: <br><ul><li>  Abgeschlossen - geht nach erfolgreichem Abschluss der Arbeiten am Block in diesen Zustand √ºber; </li><li>  Ausstehend - befindet sich in einem Wartezustand, wenn einige Arbeiten innerhalb des Blocks ausgef√ºhrt werden. Beispielsweise ist vom Benutzer eine Antwort erforderlich. </li><li>  Abgebrochen - wechselt in diesen Zustand, wenn der Prozess gestoppt wird. </li><li>  Angehalten - wechselt in diesen Zustand, wenn der Prozess angehalten wird, wenn ein Fehler auftritt. </li></ul><br>  Wenn eine Nachricht zur Ausf√ºhrung des Blocks eintrifft, wird der Block ausgef√ºhrt, und der PSP sendet eine Nachricht mit dem Ergebnis des Blocks. <br><br><h4>  Skalierbarkeit </h4><br>  WPS und WBS k√∂nnen in mehreren Instanzen bereitgestellt werden.  Zu einem bestimmten Zeitpunkt kann nur ein WPS-Dienst eine Prozessinstanz verarbeiten.  Gleiches gilt f√ºr die Verarbeitung von Bl√∂cken - eine Prozessinstanz kann jeweils nur einen Block verarbeiten.  Dies wird durch Sperren unterst√ºtzt, die w√§hrend der Verarbeitung auf den Prozess gesetzt werden.  Wenn sich mehrere Nachrichten in der Warteschlange befinden, um einen Prozess / Bl√∂cke in einem Prozess zu verarbeiten, wird die Nachricht f√ºr einige Zeit verschoben.  Gleichzeitig kann jeder Dienst gleichzeitig an mehreren Prozessinstanzen arbeiten. <br>  Eine Situation kann auftreten, wenn mehrere Nachrichten in einem Prozess nach dem anderen eingehen, um Bl√∂cke (parallele Verzweigungen) zu verarbeiten.  Um die Anzahl der Situationen zu verringern, in denen Sie Nachrichten verschieben m√ºssen, nimmt WBS mehrere Nachrichten gleichzeitig auf und f√ºhrt sie nacheinander aus, wobei das Senden an die Warteschlange zur erneuten Ausf√ºhrung aufgrund der Blockierung des Prozesses umgangen wird. <br><br><h3>  Konvertierung </h3><br>  Nach dem √úbergang zu einer neuen Engine stellte sich die Frage, was mit vorhandenen Prozessinstanzen zu tun ist.  Die bevorzugte Option war ihre Umr√ºstung, so dass sie weiter an dem neuen Motor arbeiteten.  Die Vorteile liegen auf der Hand: Wir unterst√ºtzen nur einen Motor, die Probleme bei der Unterst√ºtzung des alten Motors verschwinden (siehe oben).  Es bestand jedoch das Risiko, dass wir nicht vollst√§ndig herausfinden k√∂nnen, wie wir die ben√∂tigten Daten aus serialisierten Prozessinstanzen abrufen k√∂nnen.  Es gab auch einen Fallback: Bestehende Instanzen auf der alten Engine finalisieren und neue auf einer neuen Engine starten.  Die Nachteile dieser Option ergeben sich aus den Vorteilen der vorherigen Option. Au√üerdem sind zus√§tzliche Ressourcen erforderlich, um beide Motoren zu verdrehen. <br>  F√ºr die Konvertierung mussten wir den alten Status des Prozesses im WF-Format √ºbernehmen und die Status von Prozessen und Bl√∂cken generieren.  Wir haben ein Dienstprogramm geschrieben, das den serialisierten Status einer Prozessinstanz in der Datenbank √ºbernommen, eine Liste der aktiven Bl√∂cke und Ausf√ºhrungsergebnisse f√ºr Gesichter daraus gezogen und den Prozess virtuell ausgef√ºhrt hat.  Als Ergebnis haben wir den Status der Instanz zum Zeitpunkt der Konvertierung erhalten. <br>  Es traten Schwierigkeiten auf, Prozessprozessinstanzdaten in WF ordnungsgem√§√ü zu deserialisieren.  Der Status der Prozessinstanz (Instanz) von WF wird in der Datenbank als xaml gespeichert.  Wir konnten keine klare Beschreibung der Struktur dieses XAML finden, wir mussten den ganzen Weg empirisch gehen.  Analysierte Daten manuell und holte die ben√∂tigten Informationen heraus.  Im Rahmen dieser Aufgabe haben wir eine weitere Option ausgearbeitet: Verwenden von WF-Tools, um den Status der Instanz zu deserialisieren und Informationen von Objekten abzurufen.  Aufgrund der Tatsache, dass die Struktur solcher Objekte sehr komplex war, haben wir diese Idee aufgegeben und uns f√ºr das ‚Äûmanuelle‚Äú Parsen von xaml entschieden. <br>  Infolgedessen war die Konvertierung erfolgreich und alle Prozessinstanzen wurden von der neuen Engine verarbeitet. <br><br><h2>  Fazit </h2><br>  Was hat uns die Workflow-Engine gegeben?  Tats√§chlich haben wir es geschafft, alle am Anfang des Artikels angesprochenen Probleme zu √ºberwinden: <br><ul><li>  Die Engine ist in .NET Core geschrieben. </li><li>  Es handelt sich um einen von IIS unabh√§ngigen Self-Host-Dienst. </li><li>  Als Testoperation verwenden wir die neue Engine aktiv im Unternehmenssystem und haben es geschafft, sicherzustellen, dass die Analyse von Fehlern viel weniger Zeit in Anspruch nimmt. </li><li>  Nach vorl√§ufigen Daten wurden Lasttests auf Postgres durchgef√ºhrt. Das WPS + WBS-Bundle kann die Last von 5000 gleichzeitigen Benutzern problemlos bew√§ltigen. </li><li>  und nat√ºrlich ist es wie jede interessante Arbeit eine interessante Erfahrung. </li></ul><br>  Als Bonus haben wir einen klaren und unterst√ºtzten Code erhalten, den wir an uns selbst anpassen k√∂nnen. <br>  Die Kosten des Motors erwiesen sich als vergleichbar mit denen, die wir f√ºr den Kauf / die Anpassung eines Drittanbieterprodukts ausgeben m√ºssten.  Im Moment halten wir die Entscheidung, einen eigenen Motor zu entwickeln, f√ºr gerechtfertigt. <br>  Wir warten auch auf Lasttests f√ºr mehr als 10.000 gleichzeitige Benutzer.  Vielleicht ist eine Optimierung erforderlich, oder vielleicht hebt sie ab?  ;-); <br>  Wir haben k√ºrzlich DirectumRX 3.2 ver√∂ffentlicht, das den neuen Workflow enth√§lt.  Mal sehen, wie sich der Motor den Kunden zeigt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468803/">https://habr.com/ru/post/de468803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468785/index.html">Intel Stratix 10 DX vervollst√§ndigt die Stratix 10 FPGA-Linie</a></li>
<li><a href="../de468789/index.html">2. Typische Anwendungsf√§lle f√ºr Check Point Maestro</a></li>
<li><a href="../de468793/index.html">Wir besch√§ftigen uns mit der Kryptow√§hrungswaage. Details</a></li>
<li><a href="../de468797/index.html">Brennweite des Auges. Was ist das? (Aktualisiert)</a></li>
<li><a href="../de468799/index.html">Antimuster in Reaktion oder schlechte Tipps f√ºr Anf√§nger</a></li>
<li><a href="../de468805/index.html">System.Console, Mono und NCurses</a></li>
<li><a href="../de468811/index.html">Technologien Yandex Turbo Pages und Google AMP f√ºr den E-Commerce</a></li>
<li><a href="../de468817/index.html">Kryptografische Workstation basierend auf Public-Key-Standards. Stellen Sie SSL-Zertifikate aus. Nachwort</a></li>
<li><a href="../de468819/index.html">Offenlegung der Telegrammnummer v.2 - Social Engineering</a></li>
<li><a href="../de468821/index.html">Wie schreibe ich einen intelligenten Vertrag mit Python √ºber Ontologie? Teil 1: Die Blockchain & Block API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>