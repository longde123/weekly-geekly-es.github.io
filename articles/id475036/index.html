<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐡 🚴🏿 😧 Migrasi Cassandra ke Kubernetes: fitur dan solusi ♠️ ☃️ 👇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami secara teratur menemukan basis data Apache Cassandra dan kebutuhan untuk mengoperasikannya dalam kerangka infrastruktur berbasis Kubernetes. Pada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Migrasi Cassandra ke Kubernetes: fitur dan solusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/475036/"><img src="https://habrastorage.org/webt/5a/mf/ts/5amftsu06d04r-vmvx9to725ss0.png"><br><br>  Kami secara teratur menemukan basis data Apache Cassandra dan kebutuhan untuk mengoperasikannya dalam kerangka infrastruktur berbasis Kubernetes.  Pada artikel ini, kami akan membagikan visi kami tentang langkah-langkah yang diperlukan, kriteria dan solusi yang ada (termasuk tinjauan umum operator) untuk migrasi Cassandra ke K8s. <a name="habracut"></a><br><br><h2>  "Siapa yang bisa mengendalikan wanita akan mengatasi negara" </h2><br>  Siapakah Cassandra?  Ini adalah sistem penyimpanan terdistribusi yang dirancang untuk mengelola sejumlah besar data sambil menyediakan ketersediaan tinggi tanpa satu titik kegagalan.  Proyek ini hampir tidak membutuhkan pengenalan yang panjang, jadi saya hanya akan memberikan fitur utama Cassandra, yang akan relevan dalam konteks artikel tertentu: <br><br><ul><li>  Cassandra ditulis dalam bahasa Jawa. </li><li>  Topologi Cassandra mencakup beberapa tingkatan: <ul><li>  Node - satu instance Cassandra; </li><li>  Rack - sekelompok instance Cassandra, disatukan oleh atribut apa pun, yang terletak di satu pusat data; </li><li>  Datacenter - totalitas semua kelompok instance Cassandra yang terletak di satu pusat data; </li><li>  Cluster - kumpulan semua pusat data. </li></ul></li><li>  Cassandra menggunakan alamat IP untuk mengidentifikasi tuan rumah. </li><li>  Untuk kecepatan operasi baca dan tulis, Cassandra menyimpan sebagian data dalam RAM. </li></ul><br>  Sekarang untuk potensi perpindahan aktual ke Kubernetes. <br><br><h2>  Daftar periksa untuk migrasi </h2><br>  Berbicara tentang migrasi Cassandra ke Kubernetes, kami berharap akan menjadi lebih nyaman untuk mengelolanya dengan langkah tersebut.  Apa yang akan diperlukan untuk ini, apa yang akan membantu dalam hal ini? <br><br><h3>  1. Penyimpanan data </h3><br>  Seperti yang telah ditentukan, bagian dari data yang disimpan Cassanda dalam RAM - dalam <i>Memtable</i> .  Tetapi ada bagian lain dari data yang disimpan ke disk - dalam bentuk <i>SSTable</i> .  Untuk data ini ditambahkan <i>Log Log</i> entitas - catatan semua transaksi yang juga disimpan ke disk. <br><br><img src="https://habrastorage.org/webt/2g/2e/ck/2g2eck2szmozuahdx4oinucww9o.png"><br>  <i>Skema Transaksi Tulis Cassandra</i> <br><br>  Di Kubernetes, kita bisa menggunakan PersistentVolume untuk menyimpan data.  Berkat mekanisme yang dikembangkan dengan baik, bekerja dengan data di Kubernet menjadi lebih mudah setiap tahun. <br><br><img src="https://habrastorage.org/webt/3f/_6/eh/3f_6eh1n50l6dofpd9pds9s4ewg.png"><br>  <i>Untuk setiap pod dengan Cassandra, kami akan mengalokasikan PersistentVolume kami</i> <br><br>  Penting untuk dicatat bahwa Cassandra sendiri menyiratkan replikasi data, menawarkan mekanisme bawaan untuk ini.  Oleh karena itu, jika Anda sedang membangun cluster Cassandra dari sejumlah besar node, maka tidak perlu menggunakan sistem terdistribusi seperti Ceph atau GlusterFS untuk menyimpan data.  Dalam hal ini, akan logis untuk menyimpan data pada disk host menggunakan disk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">persisten lokal</a> atau memasang <code>hostPath</code> . <br><br>  Pertanyaan lain adalah apakah Anda ingin membuat lingkungan pengembangan yang terpisah untuk setiap cabang fitur.  Dalam hal ini, pendekatan yang benar adalah dengan menaikkan satu simpul Cassandra, dan menyimpan data dalam penyimpanan terdistribusi, yaitu  Ceph dan GlusterFS yang disebutkan akan menjadi pilihan Anda.  Maka pengembang akan yakin bahwa ia tidak akan kehilangan data pengujian bahkan jika salah satu node dari cluster Kuberntes hilang. <br><br><h3>  2. Pemantauan </h3><br>  Pilihan yang sebenarnya non-alternatif untuk pemantauan di Kubernetes adalah Prometheus <i>(kami membicarakan hal ini secara rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan terkait</a> )</i> .  Bagaimana kabar Cassandra dengan pengekspor metrik untuk Prometheus?  Dan, apa yang lebih penting dalam beberapa hal, dengan dashboard yang cocok untuk mereka untuk Grafana? <br><br><img src="https://habrastorage.org/webt/g0/vq/et/g0vqetugsowufigbskokdr74_2q.png"><br>  <i>Contoh penampilan grafik di Grafana for Cassandra</i> <br><br>  Hanya ada dua eksportir: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jmx_exporter</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cassandra_exporter</a> . <br><br>  Kami memilih yang pertama untuk diri kami sendiri, karena: <br><br><ol><li>  Eksportir JMX tumbuh dan berkembang, sedangkan Eksportir Cassandra belum bisa mendapatkan dukungan masyarakat yang tepat.  Eksportir Cassandra masih belum mendukung sebagian besar versi Cassandra. </li><li>  Anda dapat menjalankannya sebagai javaagent dengan menambahkan flag <code>-javaagent:&lt;plugin-dir-name&gt;/cassandra-exporter.jar=--listen=:9180</code> . </li><li>  Baginya ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dashboad</a> yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memadai</a> yang tidak kompatibel dengan Cassandra Eksportir. </li></ol><br><h3>  3. Pemilihan primitif Kubernetes </h3><br>  Menurut struktur cluster Cassandra di atas, kami akan mencoba menerjemahkan semua yang dijelaskan di sana ke dalam terminologi Kubernetes: <br><br><ul><li>  Cassandra Node → Pod </li><li>  Cassandra Rack → StatefulSet </li><li>  Cassandra Datacenter → kumpulan dari StatefulSets </li><li>  Cassandra Cluster → ??? </li></ul><br>  Ternyata beberapa entitas tambahan hilang untuk mengelola seluruh cluster Cassandra sekaligus.  Tetapi jika sesuatu tidak ada di sana, kita dapat membuatnya!  Kubernetes memiliki mesin definisi sumber daya khusus yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Custom Resource Definition</a> . <br><br><img src="https://habrastorage.org/webt/pt/ob/st/ptobst6r86hra1aakwvpcypws8e.png"><br>  <i>Pengumuman sumber daya tambahan untuk log dan peringatan</i> <br><br>  Tetapi Sumber Daya Kustom saja tidak berarti apa-apa: Anda memerlukan <b>pengontrol</b> untuk itu.  Anda mungkin harus menggunakan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operator Kubernetes</a> ... <br><br><h3>  4. Identifikasi polong </h3><br>  Poin di atas, kami sepakat bahwa satu simpul Cassandra akan sama dengan satu pod di Kubernetes.  Tetapi alamat IP pod akan berbeda setiap kali.  Dan identifikasi node di Cassandra terjadi tepat berdasarkan alamat IP ... Ternyata setelah setiap penghapusan pod, cluster Cassandra akan menambahkan node baru. <br><br>  Ada jalan keluar, dan bahkan tidak ada satu pun: <br><br><ol><li>  Kami dapat menyimpan catatan dengan pengidentifikasi host (UUID yang secara unik mengidentifikasi contoh Cassandra) atau dengan alamat IP dan menyimpan semua ini dalam beberapa struktur / tabel.  Metode ini memiliki dua kelemahan utama: <br><br><ul><li>  Risiko kondisi balapan ketika dua node jatuh sekaligus.  Setelah upgrade, node Cassandra akan secara bersamaan pergi untuk meminta alamat IP untuk diri mereka sendiri dari tabel dan bersaing untuk sumber daya yang sama. </li><li>  Jika simpul Cassandra telah kehilangan datanya, kami tidak akan lagi dapat mengidentifikasinya. </li></ul></li><li>  Solusi kedua sepertinya hack kecil, tapi tetap saja: kita bisa membuat Layanan dengan ClusterIP untuk setiap simpul Cassandra.  Masalah dengan implementasi ini: <br><br><ul><li>  Jika ada banyak node di Cassandra cluster, kami harus membuat banyak Layanan. </li><li>  Fitur ClusterIP diimplementasikan melalui iptables.  Ini bisa menjadi masalah jika cluster Cassandra memiliki banyak (1000 ... atau bahkan 100?) Node.  Meskipun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">balancing berdasarkan IPVS</a> dapat menyelesaikan masalah ini. </li></ul></li><li>  Solusi ketiga adalah menggunakan jaringan node untuk node Cassandra alih-alih jaringan pod khusus dengan mengaktifkan pengaturan <code>hostNetwork: true</code> .  Metode ini menerapkan batasan tertentu: <br><br><ul><li>  Untuk mengganti node.  Perlu bahwa host baru harus memiliki alamat IP yang sama dengan yang sebelumnya (di awan seperti AWS, GCP, ini hampir tidak mungkin dilakukan); </li><li>  Menggunakan jaringan node cluster, kami mulai bersaing untuk sumber daya jaringan.  Oleh karena itu, menempatkan satu node cluster lebih dari satu pod dengan Cassandra akan bermasalah. </li></ul></li></ol><br><h3>  5. Cadangan </h3><br>  Kami ingin menyimpan versi lengkap data untuk satu simpul Cassandra pada jadwal.  Kubernetes memberikan peluang yang nyaman menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CronJob</a> , tapi di sini Cassandra memasukkan tongkat ke roda. <br><br>  Biarkan saya mengingatkan Anda bahwa sebagian data yang disimpan Cassandra dalam memori.  Untuk membuat cadangan penuh, Anda perlu mentransfer data dari memori ( <i>Memtables</i> ) ke disk ( <i>SSTable</i> ).  Pada titik ini, simpul Cassandra berhenti menerima koneksi, sepenuhnya dimatikan dari cluster. <br><br>  Setelah itu, cadangan ( <i>foto</i> ) dihapus dan skema ( <i>keyspace</i> ) <i>disimpan</i> .  Dan kemudian ternyata hanya cadangan tidak memberi kita apa-apa: Anda perlu menyimpan pengidentifikasi data yang bertanggung jawab atas simpul Cassandra - ini adalah token khusus. <br><br><img src="https://habrastorage.org/webt/ve/el/00/veel00wgdubtmtyhjn2gh9kx4rw.png"><br>  <i>Distribusi token untuk mengidentifikasi data mana yang bertanggung jawab atas simpul Cassandra</i> <br><br>  Contoh skrip untuk menghapus Cassandra dari Google di Kubernetes dapat ditemukan di <a href="">tautan ini</a> .  Satu-satunya titik bahwa skrip tidak memperhitungkan adalah membuang data ke node sebelum menghapus snapshot.  Artinya, pencadangan dilakukan bukan untuk kondisi saat ini, tetapi untuk kondisi sedikit lebih awal.  Tapi ini membantu untuk tidak membuat simpul keluar dari pekerjaan, yang tampaknya sangat logis. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -eu <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ -z <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> info <span class="hljs-string"><span class="hljs-string">"Please provide a keyspace"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> KEYSPACE=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> result=$(nodetool snapshot <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KEYSPACE}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ $? -ne 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Error while making snapshot"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> timestamp=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$result</span></span></span><span class="hljs-string">"</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/Snapshot directory: / { print $3 }'</span></span>) mkdir -p /tmp/backup <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $(find <span class="hljs-string"><span class="hljs-string">"/var/lib/cassandra/data/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KEYSPACE}</span></span></span><span class="hljs-string">"</span></span> -name <span class="hljs-variable"><span class="hljs-variable">$timestamp</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> table=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${path}</span></span></span><span class="hljs-string">"</span></span> | awk -F <span class="hljs-string"><span class="hljs-string">"[/-]"</span></span> <span class="hljs-string"><span class="hljs-string">'{print $7}'</span></span>) mkdir /tmp/backup/<span class="hljs-variable"><span class="hljs-variable">$table</span></span> mv <span class="hljs-variable"><span class="hljs-variable">$path</span></span> /tmp/backup/<span class="hljs-variable"><span class="hljs-variable">$table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> tar -zcf /tmp/backup.tar.gz -C /tmp/backup . nodetool clearsnapshot <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${KEYSPACE}</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br>  <i>Contoh bash script untuk menghapus cadangan dari satu simpul Cassandra</i> <br><br><h2>  Solusi siap pakai untuk Cassandra di Kubernetes </h2><br>  Apa yang saat ini mereka gunakan untuk menggunakan Cassandra di Kubernetes, dan mana di antaranya yang paling cocok untuk persyaratan yang diberikan? <br><br><h3>  1. StatefulSet atau Solusi Helm Chart </h3><br>  Menggunakan StatefulSets dasar untuk memulai Cassandra cluster adalah opsi yang baik.  Dengan menggunakan grafik Helm dan templat Go, Anda dapat menyediakan antarmuka fleksibel bagi pengguna untuk menggunakan Cassandra. <br><br>  Biasanya ini berfungsi dengan baik ... sampai sesuatu yang tidak terduga terjadi - misalnya, sebuah simpul turun.  Alat standar Kubernetes tidak bisa memperhitungkan semua fitur di atas.  Selain itu, pendekatan ini sangat terbatas dalam hal bagaimana dapat diperluas untuk penggunaan yang lebih kompleks: penggantian node, cadangan, pemulihan, pemantauan, dll. <br><br>  Perwakilan: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagan dari repositori Helm utama</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagan dari bitnami</a> . </li></ul><br>  Kedua grafik sama-sama bagus, tetapi rentan terhadap masalah yang dijelaskan di atas. <br><br><h3>  2. Solusi berdasarkan Operator Kubernetes </h3><br>  Opsi semacam itu lebih menarik karena mereka menyediakan kapabilitas manajemen klaster yang luas.  Untuk mendesain pernyataan Cassandra, seperti basis data lainnya, pola yang bagus tampak seperti Sidecar &lt;-&gt; Pengontrol &lt;-&gt; CRD: <br><br><img src="https://habrastorage.org/webt/4y/3b/ac/4y3bacrtm3apdyirfanehdzf82w.png"><br>  <i>Diagram manajemen simpul dalam pernyataan Cassandra yang dirancang dengan baik</i> <br><br>  Pertimbangkan operator yang ada. <br><br><h4>  1. Cassandra-operator oleh instaclustr </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </li><li>  Kesediaan: Alpha </li><li>  Lisensi: Apache 2.0 </li><li>  Diimplementasikan di: Jawa </li></ul><br>  Ini memang proyek yang sangat menjanjikan dan berkembang pesat dari sebuah perusahaan yang menawarkan penyebaran yang dikelola Cassandra.  Itu, seperti dijelaskan di atas, menggunakan wadah sespan yang menerima perintah melalui HTTP.  Itu ditulis dalam Java, jadi kadang-kadang tidak memiliki fungsi perpustakaan client-go yang lebih maju.  Selain itu, operator tidak mendukung Racks yang berbeda untuk satu Datacenter. <br><br>  Tetapi operator memiliki keunggulan seperti dukungan pemantauan, manajemen klaster tingkat tinggi menggunakan CRD, dan bahkan dokumentasi untuk menghapus cadangan. <br><br><h4>  2. Navigator oleh Jetstack </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </li><li>  Kesediaan: Alpha </li><li>  Lisensi: Apache 2.0 </li><li>  Diimplementasikan di: Golang </li></ul><br>  Pernyataan untuk menggunakan DB-as-a-Service.  Saat ini mendukung dua database: Elasticsearch dan Cassandra.  Ini memiliki solusi menarik seperti kontrol akses ke database melalui RBAC (untuk ini, apiserver navigator terpisah dimunculkan).  Sebuah proyek yang menarik, yang layak untuk dilihat lebih dekat, tetapi komitmen terakhir dibuat satu setengah tahun yang lalu, yang jelas mengurangi potensinya. <br><br><h4>  3. Cassandra-operator dari vgkowski </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </li><li>  Kesediaan: Alpha </li><li>  Lisensi: Apache 2.0 </li><li>  Diimplementasikan di: Golang </li></ul><br>  Mereka tidak menganggapnya “serius”, karena komit terakhir ke repositori adalah lebih dari setahun yang lalu.  Pengembangan operator ditinggalkan: versi terbaru dari Kubernetes, dinyatakan sebagai didukung, adalah 1.9. <br><br><h4>  4. Cassandra-operator dari Rook </h4><br><ul><li>  <a href="">Github</a> </li><li>  Kesediaan: Alpha </li><li>  Lisensi: Apache 2.0 </li><li>  Diimplementasikan di: Golang </li></ul><br>  Operator yang pengembangannya tidak berjalan secepat yang kita inginkan.  Ini memiliki struktur CRD yang dipikirkan dengan matang untuk mengelola cluster, memecahkan masalah mengidentifikasi node menggunakan Layanan dengan ClusterIP ("hack" yang sama) ... tetapi untuk sekarang itu saja.  Tidak ada pemantauan dan cadangan di luar kotak sekarang (ngomong-ngomong, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mulai</a> memantau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diri</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sendiri</a> ).  Hal yang menarik adalah bahwa dengan menggunakan operator ini Anda juga dapat menggunakan ScyllaDB. <br><br>  <i>NB: Kami menggunakan operator ini dengan modifikasi kecil di salah satu proyek kami.</i>  <i>Tidak ada masalah dalam pekerjaan operator selama seluruh operasi (~ 4 bulan beroperasi).</i> <br><br><h4>  5. CassKop by Orange </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </li><li>  Kesediaan: Alpha </li><li>  Lisensi: Apache 2.0 </li><li>  Diimplementasikan di: Golang </li></ul><br>  Operator termuda dalam daftar: komit pertama dibuat pada 23 Mei 2019.  Sudah, di gudang senjatanya ada sejumlah besar fitur dari daftar kami, lebih detail yang dapat ditemukan di repositori proyek.  Operator didasarkan pada operator populer-SDK.  Mendukung pemantauan out-of-box.  Perbedaan utama dari operator lain adalah penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin CassKop</a> , diimplementasikan dalam Python dan digunakan untuk komunikasi antara node Cassandra. <br><br><h2>  Kesimpulan </h2><br>  Jumlah pendekatan dan opsi yang memungkinkan untuk memindahkan Cassandra ke Kubernetes berbicara untuk dirinya sendiri: topiknya sangat diminati. <br><br>  Pada tahap ini, Anda dapat mencoba salah satu di atas dengan risiko dan risiko Anda sendiri: tidak ada pengembang yang menjamin 100% kinerja solusi mereka di lingkungan produksi.  Namun sekarang, banyak produk yang tampak menjanjikan untuk mencoba menggunakannya di tribun pengembangan. <br><br>  Saya pikir di masa depan wanita di kapal ini harus pergi! <br><br><h2>  PS </h2><br>  Baca juga di blog kami: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Migrasi MongoDB ke Kubernet yang tidak terhalang</a> "; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Migrasi RabbitMQ yang tidak terhalang ke Kubernetes</a> ”; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Database dan Kubernetes (review dan laporan video)</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">K8 tips &amp; trik: Mempercepat bootstrap dari database besar.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475036/">https://habr.com/ru/post/id475036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475024/index.html">Berlari adalah olahraga yang ideal untuk pekerja jarak jauh. Bagian 1: jalan menuju balapan pertama sejauh seratus kilometer</a></li>
<li><a href="../id475026/index.html">3 cerita kecelakaan Kubernetes dalam produksi: anti-afinitas, shutdown anggun, webhook</a></li>
<li><a href="../id475028/index.html">Pengamatan tentang penerapan ML dalam bisnis pada saham ŽijemeIT</a></li>
<li><a href="../id475032/index.html">Gartner Hype Cycle 2019: tanya jawab</a></li>
<li><a href="../id475034/index.html">Grafik di browser untuk Arduino dan STM32</a></li>
<li><a href="../id475038/index.html">Set pertama "Matematika Terapan dan Ilmu Komputer" di St. Petersburg HSE: siapa mereka dan bagaimana cara bekerja dengannya?</a></li>
<li><a href="../id475044/index.html">Membangun serverless Anda sendiri berdasarkan Fn</a></li>
<li><a href="../id475046/index.html">Apakah akhirnya membenarkan cara? (!) SEO hitam dan abu-abu</a></li>
<li><a href="../id475048/index.html">Penjelasan uji hipotesis intuitif dan nilai-p</a></li>
<li><a href="../id475050/index.html">ESports - mainkan, mainkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>