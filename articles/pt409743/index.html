<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèø üèúÔ∏è ü§ôüèΩ Controlador DIY do painel de LED no CPLD usando modula√ß√£o BAM üòä üíÖüèª üëã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° algum tempo, ele participou de uma discuss√£o sobre o projeto DIY de um rel√≥gio LED de matriz. 
 E o que me surpreendeu - a antiga matriz monocrom√°t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Controlador DIY do painel de LED no CPLD usando modula√ß√£o BAM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/409743/">  H√° algum tempo, ele participou de uma discuss√£o sobre o projeto DIY de um rel√≥gio LED de matriz. <br>  E o que me surpreendeu - a antiga matriz monocrom√°tica de LED 8x8 com um passo de 5 mil√≠metros foi usada como um dispositivo de exibi√ß√£o.  Al√©m disso, placas de circuito impresso complexas foram criadas para eles, uma indica√ß√£o din√¢mica suave foi feita.  E isso ocorre em um momento em que os pain√©is LED de 64x32 em cores, prontos para uso, com passo de 3 mm, est√£o dispon√≠veis h√° muito tempo a um pre√ßo de US $ 10 a 20.  E a variedade geral desses pain√©is √© muito grande e tem uma densidade de pixels de 2 a 10 mm e quase qualquer tamanho. <br><a name="habracut"></a><br>  Ao mesmo tempo, o uso desses pain√©is em projetos de bricolage √© bastante dif√≠cil - os controladores prontos custam muito dinheiro e n√£o possuem uma API normal.  √â bastante dif√≠cil fazer uma varredura bastante r√°pida do painel em microcontroladores comumente usados ‚Äã‚Äãem bricolage.  Al√©m disso, os intervalos de tempo devem ser mantidos com alta precis√£o - caso contr√°rio, uma irregularidade vis√≠vel do brilho come√ßa. <br><br>  Existem boas solu√ß√µes na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Adafruit</a> , mas todas s√£o bastante caras e complexas. <br><br>  Depois de pensar um pouco, o pensamento surgiu - por que n√£o fazer uma placa extremamente barata que ser√° uma ponte entre uma placa de centavo comum como um arduino e um painel de LED?  Depois de alguns meses de confus√£o, nasceu algo que funcionava. <br><br>  Este artigo descreve a segunda vers√£o aprimorada do controlador. <br><cut><br><h2>  Desafio </h2><br>  Como tarefa b√°sica, eu queria poder controlar um painel com um tamanho total de pelo menos 64x64, al√©m de poder trabalhar pelo menos em Highcolor (RGB565), mantendo uma taxa de atualiza√ß√£o de tela aceit√°vel (pelo menos 50Hz).  Na primeira vers√£o do controlador, a tarefa b√°sica foi totalmente implementada, mas surgiu a id√©ia de implementar a tarefa por outro m√©todo muito promissor, a partir do qual a segunda vers√£o nasceu. <br><br><h2>  Explica√ß√£o b√°sica do design de um painel LED t√≠pico </h2><br>  Interface de entrada HUB75: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2d/yn/gt/2dyngtqqelfmxsb9iseipe2c29u.jpeg"></div><br>  Em cada entrada de cor, h√° uma cadeia de registros do tipo HC595 (mas vers√µes especiais de 16 canais para LEDs).  Existem tantos registros suficientes para a largura do painel.  Permiss√µes de fragmenta√ß√£o, inicializa√ß√£o paralela e sa√≠da s√£o comuns a todos os registros.  As entradas ABCDE - essa √© a escolha de uma s√©rie - v√£o para um decodificador convencional. <br><br>  Princ√≠pio de funcionamento: <br><br><ul><li>  Para definir os dados como entradas RGB, clique no bot√£o CLK.  Repita at√© carregarmos toda a linha </li><li>  desligue as sa√≠das OE = 1 (para que n√£o haja interfer√™ncia) </li><li>  atribuir ao decodificador o n√∫mero da linha carregada </li><li>  clique em carregamento paralelo LAT - os dados da linha s√£o transferidos para os registros de sa√≠da <br>  ativar sa√≠das OE = 0 </li><li>  repita para a pr√≥xima linha </li></ul><br>  Essa √© uma indica√ß√£o din√¢mica cl√°ssica.  √â claro que, com esse m√©todo em um desses ciclos, podemos ligar / desligar apenas cada LED espec√≠fico. <br><br>  Para obter grada√ß√µes de brilho com o PWM cl√°ssico, esse ciclo deve ser repetido N-1 vezes, onde N √© o n√∫mero de grada√ß√µes de brilho (256 para RGB888).  E, considerando que, ao mesmo tempo, ele ainda pisca - tudo isso deve ser feito muito, muito rapidamente. <br><br>  Existe uma solu√ß√£o alternativa - BAM (Bit Angle Modulation).  Nesse caso, o tempo de brilho em cada ciclo √© proporcional ao peso do bit exibido.  Ou seja, para RGB888, voc√™ precisa de apenas 8 ciclos de exibi√ß√£o.  Um pouco mais detalhado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  A primeira vers√£o do controlador usava o PWM cl√°ssico, que impunha um limite estrito no n√∫mero de ciclos de varredura.  Na segunda vers√£o, o BAM √© implementado, o que deu um enorme ganho de velocidade. <br><br><h2>  Implementa√ß√£o </h2><br>  Era √≥bvio que um microcontrolador convencional puxa apenas pequenos pain√©is - os grandes simplesmente n√£o t√™m velocidade suficiente.  Portanto, o CPLD ou o FPGA √© indispens√°vel aqui - √© fisicamente imposs√≠vel produzir dezenas de MB / s em microcontroladores de baixo custo. <br><br>  Como mem√≥ria, fui recomendado no f√≥rum IXBT pela muito interessante mem√≥ria FIFO Averlogic AL422B, que possui aproximadamente 400kbytes de mem√≥ria e pode operar em frequ√™ncias de at√© 50MHz. <br><br>  Considerando que meu principal requisito era o baixo custo m√°ximo dos componentes, para que o cachecol acabado fosse acess√≠vel aos fabricantes caseiros, foi escolhido o Altera EPM3064 - CPLD com 64 macroc√©lulas.  Ao mesmo tempo, um n√∫mero t√£o pequeno de macroc√©lulas n√£o permite criar uma placa configur√°vel dinamicamente - a configura√ß√£o deve ser compilada diretamente no CPLD. <br><br>  ‚Üí O circuito resultante est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> <br><br>  Detalhes: <br><br><ul><li>  CPLD EPM3064ATC44-10 - o pre√ßo de Ali √© de US $ 13 a 15 por uma d√∫zia </li><li>  FIFO RAM AL422B - o pre√ßo de Ali √© de cerca de US $ 15 por d√∫zia </li><li>  Oscilador de cristal de 50MHz.  A placa fornece a instala√ß√£o nos gabinetes DIP14 / DIP8 / 7050.  O pre√ßo de Ali √© de cerca de US $ 6-7 por d√∫zia </li><li>  Estabilizador de 3.3V no pacote SOT223.  Pre√ßo em Chip and Dip - 40r cada </li><li>  Conector IDC-10MS.  Pre√ßo em Chip &amp; Dip - 3 p / pe√ßa </li><li>  Conector IDC-16MS.  Pre√ßo em Chip &amp; Dip - 8 r / pe√ßa </li><li>  Conector IDC-14MS.  Pre√ßo em Chip &amp; Dip - 7 r / pe√ßa </li><li>  Capacitores 1 microfarad 0805 - 8 pe√ßas de cerca de 1 r / pe√ßa </li><li>  Capacitor 0.1uF 0805 - cerca de 1 r / pe√ßa </li><li>  Resistor 10k 0805 - um centavo </li></ul><br>  O total em detalhes √© obtido 1,5 + 1,5 + 0,7 = US $ 3,7 e 40 + 3 + 8 + 7 + 8 * 1 + 1 = 67 p.  Todos juntos dentro de US $ 5 - um centavo. <br><br>  ‚Üí A imagem original do quadro est√° <a href="">aqui</a> <br><br>  ‚Üí <a href="">Arquivos</a> gerber preparados <a href="">para pedidos</a> <br><br>  O conselho est√° preparado para a primeira vers√£o, na qual n√£o havia controle de ER.  Para us√°-lo com a segunda vers√£o, voc√™ deve cortar o jumper entre os terminais 23 e 24 do AL422B e lan√ßar os fios do terminal 28 do EPM3064 (que √© levado ao bloco de terminais) para o terminal 24 do AL422B. <br><br>  Ao soldar a placa, n√£o se esque√ßa de soldar os jumpers na parte traseira da placa. <br><br><img src="https://habrastorage.org/webt/y6/hy/i6/y6hyi6obrqqyyybfvractvmtuqy.jpeg"><br><br><img src="https://habrastorage.org/webt/u1/n1/jr/u1n1jr2zzs7sqfwpzxji2xpg2pg.jpeg"><br><br><h2>  C√°lculos </h2><br>  Os c√°lculos dos par√¢metros necess√°rios s√£o bastante complicados. <br><br>  O fato √© que, no controlador, dois processos s√£o executados em paralelo - carregando os dados da pr√≥xima linha / indicando uma linha j√° carregada. <br><br>  Os processos iniciam simultaneamente, mas terminam em momentos diferentes; portanto, um processo mais r√°pido aguarda a conclus√£o de um processo mais longo. <br><br>  ‚Üí Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tablet Excel</a> foi feito para o c√°lculo <br><br>  Dados de origem: <br><br><ul><li>  CRYSTAL_FRQ (MHz) - frequ√™ncia do gerador (50 MHz) </li><li>  PIXEL_COUNT - o n√∫mero de pixels na barra de download.  Mais detalhes na se√ß√£o de comuta√ß√£o. </li><li>  RGB_INPUTS - o n√∫mero de entradas RGB usadas na interface HUB75E do painel usado.  1 ou 2 </li><li>  BYTES_PER_PIXEL - bytes por pixel.  No nosso caso, sempre 3 - RGB888 </li><li>  SCAN_LINES - n√∫mero de linhas de varredura no painel usado.  16/08/32 </li></ul><br>  Par√¢metros selecionados: <br><br><ul><li>  PRE_DELAY - atraso do sinal LAT at√© que o OE seja ligado, definido em ticks </li><li>  PRESCALER - pr√©-calibrador para o contador principal.  Ou seja, se a lista de pre√ßos for 8 e o peso do bit atual for 4, o OE ser√° ativado por 8 * 4 = 32 ciclos </li><li>  POST_DELAY - atraso m√≠nimo de desligar o OE para o pr√≥ximo sinal LAT, definido em ticks </li></ul><br>  Por exemplo, temos um painel 32x32 com 8 linhas de digitaliza√ß√£o e 2 entradas RGB.  Esse painel possui dois conectores HUB75E, ou seja, fisicamente, s√£o dois pain√©is 32x16.  Conectamos esses pain√©is em s√©rie, ou seja, logicamente esse painel ser√° semelhante a 64x16. <br><br>  PRE_DELAY e POST_DELAY s√£o intervalos de apagamento antes e depois da ativa√ß√£o da sa√≠da (OE), para que os multiplexadores possam alternar as sa√≠das e as teclas abrir / fechar.  Sem eles, haver√° "truques" da queima de pixels para as linhas adjacentes.  Os valores s√£o selecionados experimentalmente para um painel espec√≠fico.  Geralmente 15 medidas s√£o suficientes (definidas em medidas). <br><br>  Isso levanta a quest√£o de escolher pr√©-calibrador - como escolher. <br><br>  Um valor baixo do pr√©-calibrador fornece um tempo de exibi√ß√£o de quadro curto, mas reduz o brilho geral.  O alto valor do pr√©-calibrador aumenta o tempo de exibi√ß√£o do quadro, ou seja, quando enumera, treme na tela. <br><br>  Vamos tentar PRESCALER = 1 <br><br>  Temos: <br><br>  OE_EFFICIENCY - 8,3%, ou seja, o painel funcionar√° apenas 8,3% do brilho m√°ximo poss√≠vel <br>  FRAMES_PER_SECOND - 2034 fps - mas a taxa de atualiza√ß√£o da imagem ser√° enorme - mais de 2000 fps. <br><br>  A perda de brilho j√° √© muito grande. <br><br>  Vamos tentar PRESCALER = 16 <br><br>  Temos: <br><br>  OE_EFFICIENCY - 72,9%, ou seja, o painel funcionar√° com 72,9% do brilho m√°ximo poss√≠vel <br>  FRAMES_PER_SECOND - 1117 - e a taxa de atualiza√ß√£o da imagem √© muito boa - mais de 1000 qps. <br>  Bem, √© bastante normal - uma efici√™ncia de mais de 50% √© bastante normal e a taxa de quadros √© muito boa. <br><br>  A regra geral √© PRESCALER √© cerca de 8 vezes menor que o produto PIXEL_COUNT * RGB_INPUTS <br><br>  Bem, continue a contar e verificar. <br><br><h2>  Comuta√ß√£o de pain√©is de LED </h2><br>  Todos os pain√©is s√£o conectados em s√©rie.  Diagrama de conex√£o: primeiro da direita para a esquerda e depois de baixo para cima.  Ou seja, primeiro conectamos as horizontais em s√©rie, depois a sa√≠da da linha inferior √† entrada da segunda linha a partir da parte inferior, etc.  para a linha superior. <br><br>  O controlador se apega ao painel inferior direito. <br><br>  Existem pain√©is que possuem dois conectores de entrada e dois de sa√≠da.  Esses pain√©is s√£o essencialmente apenas uma montagem mec√¢nica de dois pain√©is verticalmente.  Comutado como dois pain√©is independentes. <br><br>  Ap√≥s a montagem, precisamos calcular o comprimento total da cadeia em pixels - para isso olhamos - quantos pain√©is totais estavam na cadeia e multiplicar esse n√∫mero pela largura do painel em pixels.  Esse n√∫mero precisar√° ser direcionado para o valor PIXEL_COUNT durante a configura√ß√£o do CPLD e para a calculadora de tempo. <br><br><h2>  Firmware FPGA </h2><br>  Todos os arquivos necess√°rios est√£o no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> .  Voc√™ precisa fazer o download diretamente com a pasta <br><br>  Ap√≥s o registro, voc√™ deve baixar e instalar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quartus II 13.0sp1</a> no site da Altera.  Voc√™ precisa baixar EXATAMENTE ESTA vers√£o - as vers√µes mais recentes n√£o s√£o mais compat√≠veis com a s√©rie MAX3000.  N√£o √© necess√°rio quebr√°-lo - a vers√£o da Web (gratuita) √© suficiente.  Ao fazer o download, verifique as caixas de suporte para MAX3000 e Programmer.  S√≥ por precau√ß√£o, aviso - o pacote √© grande, cerca de dois shows.  Voc√™ tamb√©m precisar√° do Altera USB Blaster - o pre√ßo normal para todos √© de cerca de US $ 3. <br><br>  Abra o projeto al422_bam.qpf.  √Ä esquerda, abra a guia arquivo e abra o arquivo al422_bam.v - este √© o arquivo principal do projeto.  Nele, voc√™ precisa configurar os par√¢metros: <br><br>  Quantas entradas RGB em um painel - em pain√©is com uma entrada HUB75, pode haver 1 ou 2 entradas RGB.  Para descobrir exatamente quantas entradas s√£o poss√≠veis dessa maneira - pegamos o n√∫mero de pixels no painel verticalmente.  Divida pelo n√∫mero de linhas de digitaliza√ß√£o (indicadas na designa√ß√£o do painel como 8S, por exemplo).  Divida pelo n√∫mero de conectores de entrada (1 ou 2).  Por exemplo - eu tenho um painel 32x32, varredura 8S e dois conectores de entrada - 32/8/2 = 2 - o que significa duas entradas RGB. <br><br><pre><code class="hljs powershell">`define RGB_outs <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Quantas linhas de digitaliza√ß√£o no painel - como o padr√£o HUB75E √© suportado, ele pode ter at√© 32x.  O n√∫mero de linhas de digitaliza√ß√£o geralmente est√° no nome do painel na forma de 8S / 16S / 32S, respectivamente. <br><br>  Apenas uma linha deve ser descomentada: <br><br><pre> <code class="hljs powershell">`define SCAN_x8 <span class="hljs-number"><span class="hljs-number">1</span></span> //`define SCAN_x16 <span class="hljs-number"><span class="hljs-number">1</span></span> //`define SCAN_x32 <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  O n√∫mero total de pixels horizontais na cadeia.  Os pixels s√£o considerados em toda a cadeia de pain√©is - consulte a se√ß√£o acima ‚ÄúAlternando pain√©is de LED‚Äù <br><br><pre> <code class="hljs powershell">`define PIXEL_COUNT <span class="hljs-number"><span class="hljs-number">64</span></span></code> </pre><br>  As fases dos sinais de sa√≠da.  A configura√ß√£o mais t√≠pica √© a seguinte: o OE est√° ativo em um n√≠vel baixo (coment√°rios removidos), o CLK est√° em execu√ß√£o na frente (os coment√°rios est√£o ativados), o LAT est√° ativo em um n√≠vel alto (os coment√°rios est√£o ativados).  Todos os tipos de op√ß√µes estranhas s√£o poss√≠veis.  Descubra qual voc√™ possui apenas experimentalmente ou removendo o circuito e procurando folhas de dados para os chips usados). <br><br><pre> <code class="hljs powershell">//`define LED_LAT_ACTIVE_LOW <span class="hljs-number"><span class="hljs-number">1</span></span> `define LED_OE_ACTIVE_LOW <span class="hljs-number"><span class="hljs-number">1</span></span> //`define LED_CLK_ON_FALL <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Pr√© e p√≥s-atraso do sinal OE em rela√ß√£o ao LAT e pr√©-calibrador para o contador principal.  Veja acima. <br><br><pre> <code class="hljs powershell">`define OE_PRESCALER <span class="hljs-number"><span class="hljs-number">16</span></span> `define OE_PREDELAY <span class="hljs-number"><span class="hljs-number">31</span></span> `define OE_POSTDELAY <span class="hljs-number"><span class="hljs-number">31</span></span></code> </pre><br>  Tudo, pressione ctrl-L - o projeto √© compilado.  Se voc√™ n√£o estragou tudo, haver√° v√°rios avisos, mas n√£o deve haver erros.  Em seguida, conectamos a placa soldada ao USB Blaster e aplicamos energia √† placa.  No Quartus, v√° para ferramentas - programador.  Selecione USB-blaster na configura√ß√£o de hardware, clique em Iniciar.  √â isso a√≠, o CPLD est√° programado. <br><br><h2>  Pe√ßa do microcontrolador </h2><br>  A sa√≠da de dados para o controlador, em geral, √© extremamente simples - redefinimos o endere√ßo de grava√ß√£o e, em seguida, emitimos bytes de dados sequencialmente, acariciando-os com o sinal WCLK.  E parece que at√© um arduinka banal √© suficiente para o trabalho.  Mas h√° dois problemas: <br><br>  a) √â preciso muita mem√≥ria.  Mesmo um pequeno painel de 32x32 no modo RGB888 requer 3kBytes de mem√≥ria para um buffer de tela.  O Atmega328 baseado em Arduino comum cont√©m apenas 2kbytes de RAM.  Obviamente, voc√™ pode usar uma placa Mega baseada no Atmega2560, que cont√©m at√© 8 kB de RAM, mas mesmo isso n√£o √© suficiente para pain√©is de tamanho normal - um painel de 128x64 no modo RGB565 requer 16kB de mem√≥ria. <br><br>  b) No processo de trabalho com o AL422B, ocorreu uma falha que n√£o foi documentada em nenhum lugar - ao gravar dados a uma velocidade inferior a 2 MB / s, o contador de endere√ßos n√£o funciona corretamente e grava os dados "n√£o existem".  Talvez seja uma falha da minha festa.  Talvez n√£o.  Mas essa falha deve ser contornada.  Dado que o AVR8 opera em 16 MHz, √© quase imposs√≠vel obter dados dele nas velocidades desejadas. <br><br>  A solu√ß√£o proposta √© optar por len√ßos baratos com base no controlador STM32F103C8T6 de 32 bits.  Esse cachecol custa Ali cerca de US $ 2,5 por pe√ßa, ou US $ 1,7 na compra de uma d√∫zia, ou seja, ainda mais barato que um Arduino Nano.  Ao mesmo tempo, temos um microcontrolador de 32 bits completo operando a 72 MHz e com 20 kB de RAM e 64 kB de flash (compare com o Atmega328 de 2kB / 8kB, que est√° no Nano). <br><br>  Ao mesmo tempo, essas placas s√£o programadas com bastante √™xito no ambiente do Arduino.  Sobre isso, h√° um bom artigo sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rel√≥gio</a> , ent√£o n√£o o duplicarei.  Em geral, fa√ßa tudo como descrito no artigo. <br><br>  Em um ambiente arduino, escolha a placa gen√©rica STM32F103C, variante STM32F103C8.  Os dados passam pelo DMA, para que voc√™ possa usar qualquer op√ß√£o de otimiza√ß√£o. <br><br>  A troca ocorre da seguinte maneira: <br><br>  Pregou firmemente na biblioteca: <br>  A0..A7 ‚Üí DI0..DI7 AL422B <br>  B0 ‚Üí WCLK AL422B <br>  B1 ‚Üí WRST AL422B <br><br>  Atribu√≠do em um esbo√ßo ao controlador: <br>  B10 ‚Üí N√ìS AL422B <br><br>  Fio comum: <br>  G ‚Üí GND <br><br>  Bem, n√£o esque√ßa de fornecer energia de 5V / GND a partir do painel para os pinos correspondentes do controlador. <br><br>  Retire a pinagem do conector no controlador do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">circuito</a> . <br><br><img src="https://habrastorage.org/webt/nh/p7/_y/nhp7_ygm9hqmkawess06ypt1oy4.jpeg"><br><br><h2>  Parte do software </h2><br>  Como a tarefa era tornar tudo o mais simples e acess√≠vel poss√≠vel, todo o software foi feito para o ambiente Arduino e foi projetado como uma biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LED_PANEL</a> . <br><br>  A biblioteca LED-PANEL usa ativamente a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Adafruit GFX</a> , portanto, ela precisa ser instalada. <br><br>  Eu recomendo n√£o colocar a biblioteca LED_PANEL no diret√≥rio de bibliotecas, mas deix√°-la na pasta de esbo√ßo.  O fato √© que existem muitos par√¢metros ligados a ferro e, se voc√™ deseja transferir o trabalho para um microcontrolador mais "gordo", precisar√° alterar muitas coisas no pr√≥prio c√≥digo. <br><br>  A inicializa√ß√£o est√° aproximadamente no seguinte formato: <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"LED_PANEL.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> width 32 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> height 32 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bpp 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> scan_lines 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RGB_inputs 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> we_out_pin PB10 LED_PANEL led_panel = LED_PANEL(width, height, bpp, scan_lines, RGB_inputs, we_out_pin);</span></span></code> </pre><br>  isto √©, criamos uma inst√¢ncia da classe LED_PANEL, para a qual especificamos os par√¢metros: <br><br>  width - a largura total do painel em pixels (total) <br>  height - a altura total do painel em pixels (total) <br>  bpp - byte por pixel, 3 para RGB888.  A vers√£o BAM funciona apenas em RGB888 <br>  scan_lines - o n√∫mero de linhas de varredura √© 16/8/32.  Deve corresponder ao modo piscado no controlador. <br>  RGB_inputs - o n√∫mero de entradas RGB no conector HUB75 √© 1/2.  Deve corresponder ao modo piscado no controlador. <br>  we_out_pin - pino ao qual a sa√≠da WE est√° conectada <br><br>  Observe que durante a inicializa√ß√£o, apenas o pino WE √© especificado.  Todos os outros pinos s√£o registrados rigidamente no c√≥digo, uma vez que est√£o vinculados aos canais de timer e DMA usados ‚Äã‚Äãe sua altera√ß√£o implicar√° altera√ß√µes significativas no c√≥digo. <br><br>  Iniciando e limpando a tela na se√ß√£o de configura√ß√£o: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">led_panel</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.begin</span></span>(); <span class="hljs-selector-tag"><span class="hljs-selector-tag">led_panel</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.clear</span></span>();</code> </pre><br>  begin inicializa os pinos necess√°rios na sa√≠da, conecta um timer e DMA <br>  limpar limpa o buffer <br><br>  Para desenhar, voc√™ pode usar todos os procedimentos padr√£o da biblioteca Adafruit GFX - desde o drawPixel mais simples at√© a sa√≠da de texto.  Para gerar os procedimentos extra√≠dos para o buffer, s√£o utilizados: <br><br><pre> <code class="hljs pgsql">led_panel.<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>();</code> </pre><br>  Neste formul√°rio, o show inicia a transfer√™ncia de dados para o controlador via DMA e retorna imediatamente o controle.  Descubra se a transfer√™ncia foi finalizada com a ajuda da fun√ß√£o led_panel.OutIsFree () - se for verdadeira, a transfer√™ncia foi finalizada.  Existe um recurso - se voc√™ ligar para show quando a transfer√™ncia ainda n√£o tiver sido conclu√≠da - ele ser√° simplesmente ignorado. <br><br><pre> <code class="hljs pgsql">led_panel.<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>);</code> </pre><br>  an√°logo de show (), mas se voc√™ chamar show (false) e a transfer√™ncia ainda n√£o tiver sido conclu√≠da, o procedimento aguardar√° a conclus√£o da transfer√™ncia e inicie um novo controle de transfer√™ncia e retorno: <br><br><pre> <code class="hljs pgsql">led_panel.<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre><br>  an√°logo de show (false), mas se voc√™ chamar show (true), ap√≥s o in√≠cio de uma nova transfer√™ncia, o procedimento n√£o retornar√° o controle at√© que a transfer√™ncia seja conclu√≠da. <br><br>  Em geral, isso √© tudo. <br><br><img src="https://habrastorage.org/webt/pn/-a/of/pn-aofhwnhuuzszuk_mcf9upqje.jpeg"><br><br>  Algumas notas sobre o software: <br><br>  a) A corre√ß√£o gama √© introduzida ao recalcular a cor do RGB565 (que a biblioteca usa) com a fun√ß√£o ExpandColor.  Em todos os outros casos, √© utilizada uma fun√ß√£o de transfer√™ncia linear, ou seja, o brilho √© diretamente proporcional ao valor. <br>  b) O software permite conectar v√°rios controladores de LED a uma placa de microcontrolador.  Para fazer isso, envie as linhas de barramento de dados, RST e CLK para os controladores em paralelo.  O controlador desejado √© selecionado atrav√©s da linha WE.  No software, voc√™ precisa criar uma inst√¢ncia separada da classe LED_PANEL para cada controlador e cada inst√¢ncia deve ter linhas WE diferentes (o √∫ltimo par√¢metro) durante a inicializa√ß√£o. <br><br><h2>  A FAZER </h2><br>  - Lide com a "coleta" de flores nas fileiras vizinhas.  Parece uma fia√ß√£o ruim do pr√≥prio painel (as teclas est√£o desarrumadas), mas voc√™ precisa verificar.  Acabou de chegar um novo painel - vou verificar; <br>  - Crie uma nova vers√£o da placa - com ER j√° divorciado e a adi√ß√£o de conversores de n√≠vel de sa√≠da em 5V; <br>  - Fa√ßa a classe META_LED_PANEL, que permitir√° combinar v√°rios LED_PANELs em uma tela virtual - isso permitir√° criar telas muito grandes com v√°rios controladores; <br>  - No futuro, v√° para uma s√©rie de CPLD mais poderosa, por exemplo, o CycloneIV.  Isso aumentaria significativamente os recursos, mantendo um custo baixo (o EP4CE6E22 custa cerca de 5 $ para os chineses, enquanto h√° 100 vezes mais macroc√©lulas e cerca de 32 kB de mem√≥ria interna).  Mas farei isso algum dia depois.  Se eu quiser.  Uma vez que tais desenvolvimentos levam muito tempo. </cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt409743/">https://habr.com/ru/post/pt409743/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt409731/index.html">Revis√£o de rentabilidade Hashflare. Minha experi√™ncia em 6 meses</a></li>
<li><a href="../pt409733/index.html">Precisa de dados mais r√°pidos e um planeta mais limpo? Comece a desenvolver aster√≥ides</a></li>
<li><a href="../pt409735/index.html">Ilus√£o de n√≠vel de consenso</a></li>
<li><a href="../pt409739/index.html">Bloomberg: Telegram planeja ganhar mais de US $ 1 bilh√£o durante a OIC</a></li>
<li><a href="../pt409741/index.html">Casa Branca est√° interessada em lan√ßar o Falcon Heavy</a></li>
<li><a href="../pt409745/index.html">O especialista em IA alega que ele conseguiu entender em que idioma o manuscrito Voynich est√° escrito</a></li>
<li><a href="../pt409747/index.html">A rede neural AttnGAN desenha objetos em partes, usando o espa√ßo vetorial n√£o apenas de frases, mas tamb√©m de palavras</a></li>
<li><a href="../pt409749/index.html">Caldeira de pir√≥lise em casa ou quando o pre√ßo do g√°s n√£o importa</a></li>
<li><a href="../pt409751/index.html">Carta da Filkina: m√∫sica com dentes azuis - n√£o para exageros, mas para o bem</a></li>
<li><a href="../pt409753/index.html">ONU pode concluir experimento aleat√≥rio em larga escala para reduzir o aquecimento global</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>