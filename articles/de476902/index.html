<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏽 🈷️ 💢 Barrymore, wie ist das Treiben um Voximplant? Implementiert Web-Sockets, Sir 🚸 🤹 👴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebSocket ist ein fortschrittlicher Standard für die Vollduplex-Kommunikation (bidirektional) zwischen einem Client und einem Drittanbieter-Service in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Barrymore, wie ist das Treiben um Voximplant? Implementiert Web-Sockets, Sir</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/476902/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/go/qt/fp/goqtfpd9-lymms4l2uvqlrjghbi.png"></div><br>  WebSocket ist ein fortschrittlicher Standard für die Vollduplex-Kommunikation (bidirektional) zwischen einem Client und einem Drittanbieter-Service in Echtzeit.  Web-Sockets werden verwendet, um den kontinuierlichen Datenaustausch ohne zusätzliche HTTP-Anforderungen zu organisieren. <br><br>  Und wir freuen uns, Ihnen mitteilen zu können, dass dies in Voximplant dank des neuen <a href="https://voximplant.com/docs/references/voxengine">VoxEngine-</a> Moduls möglich geworden ist, das - surprise - <a href="https://voximplant.com/docs/references/voxengine/websocket">WebSocket heißt</a> .  Ab sofort können Sie Text und Audio unter voller Ausnutzung der Web-Sockets übertragen.  Kurz gesagt, Sie haben ein weiteres Tool zum Aktualisieren Ihrer Anwendung. <br><br>  In diesem Artikel erfahren Sie, wie Sie eine ausgehende WebSocket-Verbindung erstellen, einen Audiostream über diese Verbindung übertragen und mithilfe der <a href="https://cloud.google.com/speech-to-text/">Google Cloud-Sprach-Text-API</a> in Text konvertieren. <a name="habracut"></a><br><blockquote>  Bitte beachten Sie, dass Voximplant eine integrierte Funktion zur Konvertierung von Sprache in Text in Echtzeit unter der Steuerung des <a href="https://voximplant.com/docs/references/voxengine/asr">ASR-Moduls besitzt</a> .  Dieses Modul verwendet Funktionen von Google, Yandex und Tinkoff, Details finden Sie <a href="https://voximplant.com/blog/speech-to-text-asr">hier</a> . <br><br>  Der aktuelle Artikel beschreibt den Fall, dass Sie einen Drittanbieter-Service zum Konvertieren von Sprache in Text und / oder Ausgeben von Geld von seinem Konto und nicht vom Voximplant-Konto aus verwenden möchten. </blockquote><br>  Unser Modul bietet zwei Arbeitsformate: <br><ul><li>  Herstellen einer ausgehenden Verbindung; </li><li>  Empfangen einer eingehenden Verbindung und Erstellen eines Web-Sockets dafür. </li></ul><br><h3>  Ausgehend </h3><br>  Wenn Sie eine ausgehende Verbindung erstellen, müssen Sie zunächst das VoxEngine-Skript ausführen.  Rufen Sie dann die <a href="https://voximplant.com/docs/references/voxengine/websocket">VoxEngine.createWebSocket-</a> Methode auf, mit der das <a href="https://voximplant.com/docs/references/voxengine/websocket/websocket">WebSocket-</a> Objekt erstellt wird.  Diese Methode akzeptiert 2 Parameter: URL im Format 'wss: // + domain + path' und Protokolle (optional).  So würde es im Code aussehen: <br><br><pre><code class="javascript hljs">VoxEngine.addEventListener(AppEvents.CallAlerting, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> webSocket = VoxEngine.createWebSocket( <span class="hljs-comment"><span class="hljs-comment">/*url*/</span></span> <span class="hljs-string"><span class="hljs-string">"wss://your_link/"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       });</span></span></code> </pre> <br>  Wenn alles funktioniert, <a href="https://voximplant.com/docs/references/voxengine/call">sendet</a> die <a href="https://voximplant.com/docs/references/voxengine/call">call.sendMediaTo-</a> Methode den Audiostream an den Socket, und <a href="https://voximplant.com/docs/references/voxengine/websocket/websocket">WebSocket.send</a> sendet wiederum den decodierten Audiostream im JSON-Format über diesen Socket.  Infolgedessen erhalten Sie Nachrichten von dem Dienst, der die Anforderungen verarbeitet. <br><br>  Die <a href="https://voximplant.com/docs/references/voxengine/websocket/websocket">WebSocket.close-</a> Methode wird benötigt, um die Verbindung zu schließen.  Bitte beachten Sie, dass die Verbindung sowohl auf der Client-Seite als auch auf der Server-Seite geschlossen werden kann. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/lg/wo/zdlgwo-ftmjjyd0py1jviu_hrao.png"></div><br><h3>  Posteingang </h3><br>  Um eingehende Verbindungen zuzulassen, müssen Sie dies über <a href="https://voximplant.com/docs/references/voxengine/websocket">VoxEngine.allowWebSocketConnections</a> melden und das Ereignis <a href="https://voximplant.com/docs/references/voxengine/appevents">AppEvents.WebSocket</a> abonnieren.  Dann ist es möglich, die eingehende Verbindung zu akzeptieren und das WebSocket: event.WebSocket-Objekt abzurufen.  Siehe den Code unten: <br><br><pre> <code class="javascript hljs">VoxEngine.allowWebSocketConnections(); VoxEngine.addEventListener(AppEvents.WebSocket, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       });</span></span></code> </pre> <br>  Um einen eingehenden Web-Socket zu erstellen, benötigen Sie das accessSecureURL-Steuerelement.  Sie kann dem Ereignis <a href="https://voximplant.com/docs/references/voxengine/appevents">AppEvents.Started</a> oder der Antwort auf die HTTP-Anforderung entnommen werden, mit der die Sitzung gestartet wurde.  Beachten Sie, dass "https" in der URL in "wss" geändert werden muss. <br><br>  Die übrigen Schritte sind mit denen im Schema für ausgehende Verbindungen identisch. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3s/nn/8l/3snn8l5svneeye9byc-lmxqiems.png"></div><br><h2>  Du wirst brauchen </h2><br>  Um die WebSocket-Technologie und die Spracherkennung in Ihre Anwendung zu implementieren, benötigen Sie: <br><ul><li>  Voximplant-Konto.  Wenn Sie es nicht haben, können Sie sich <a href="https://manage.voximplant.com/auth/sign_up">hier</a> registrieren. </li><li>  Voximplant-Anwendung sowie ein Skript, eine Regel und ein einzelner Benutzer.  All dies wird in diesem Tutorial erstellt. </li><li>  einfaches Backend (wir starten den Server auf node.js) mit der Cloud-Client-Bibliothek, die für die Speech-to-Text-API verbunden ist; </li><li>  Web-Client zum <a href="https://phone.voximplant.com/">Tätigen</a> eines Anrufs (wir verwenden das Web-Telefon unter <a href="https://phone.voximplant.com/">phone.voximplant.com</a> ). </li></ul><br><h2>  1. VOXIMPLANT Einstellungen </h2><br>  <a href="https://manage.voximplant.com/auth">Melden</a> Sie sich zunächst unter <a href="https://manage.voximplant.com/auth">manage.voximplant.com/auth</a> in Ihrem Konto an.  Klicken Sie im Menü links auf "Programme", erstellen Sie ein neues und nennen Sie es websocket.  Gehen Sie in Ihre Anwendung, wechseln Sie zur Registerkarte Skripte, erstellen Sie ein Skript und fügen Sie den folgenden Code ein: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(Modules.WebSocket); VoxEngine.addEventListener(AppEvents.CallAlerting, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ call = e.call; call.answer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> webSocket = VoxEngine.createWebSocket( <span class="hljs-comment"><span class="hljs-comment">/*url*/</span></span> <span class="hljs-string"><span class="hljs-string">"wss://your_ngrok_link/"</span></span>); webSocket.addEventListener(WebSocketEvents.ERROR, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ Logger.write(<span class="hljs-string"><span class="hljs-string">"LOG OUTGOING: WebSocketEvents.ERROR"</span></span>); call.sendMessage(<span class="hljs-string"><span class="hljs-string">"LOG OUTGOING: WebSocketEvents.ERROR"</span></span>); }); webSocket.addEventListener(WebSocketEvents.CLOSE, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ Logger.write(<span class="hljs-string"><span class="hljs-string">"LOG OUTGOING: WebSocketEvents.CLOSE: "</span></span> + e.reason); call.sendMessage(<span class="hljs-string"><span class="hljs-string">"LOG OUTGOING: WebSocketEvents.CLOSE: "</span></span> + e.reason); }); webSocket.addEventListener(WebSocketEvents.OPEN, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ Logger.write(<span class="hljs-string"><span class="hljs-string">"LOG OUTGOING: WebSocketEvents.OPEN"</span></span>); Logger.write(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(e)) call.sendMessage(<span class="hljs-string"><span class="hljs-string">"LOG OUTGOING: WebSocketEvents.OPEN"</span></span>); }); webSocket.addEventListener(WebSocketEvents.MESSAGE, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ Logger.write(<span class="hljs-string"><span class="hljs-string">"LOG OUTGOING: WebSocketEvents.MESSAGE: "</span></span> + e.text); call.sendMessage(<span class="hljs-string"><span class="hljs-string">"LOG OUTGOING: WebSocketEvents.MESSAGE: "</span></span> + e.text); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.text == <span class="hljs-string"><span class="hljs-string">"Hi there, I am a WebSocket server"</span></span>) { call.sendMediaTo(webSocket, { <span class="hljs-attr"><span class="hljs-attr">encoding</span></span>: WebSocketAudioEncoding.ULAW, <span class="hljs-string"><span class="hljs-string">"tag"</span></span>: <span class="hljs-string"><span class="hljs-string">"MyAudioStream"</span></span>, <span class="hljs-string"><span class="hljs-string">"customParameters"</span></span>: { <span class="hljs-string"><span class="hljs-string">"param1"</span></span>: <span class="hljs-string"><span class="hljs-string">"12345"</span></span> } }); } }); call.addEventListener(CallEvents.Disconnected, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ Logger.write(<span class="hljs-string"><span class="hljs-string">"LOG OUTGOING: terminating in 1 sec"</span></span>); webSocket.close(); setTimeout(VoxEngine.terminate, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); });</code> </pre> <br>  Dieses VoxEngine-Skript sendet einen Audio-Stream an WebSocket und verfolgt auch dessen Ereignisse (ERROR, CLOSE, OPEN, MESSAGE).  Wir können uns etwas später mit den Details des Drehbuchs befassen. <br><br>  Gehen wir nun zur Registerkarte "Routing", klicken Sie auf "Neue Regel" und nennen Sie es "Socket-Regel".  Jetzt müssen Sie nur noch Ihr Skript auswählen und die Maske standardmäßig verlassen (. *). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/st/mh/ih/stmhihjv-awc5zwu0-gb842u0hq.png" width="80%"></div><br>  Das Letzte, was Sie in dieser Phase tun müssen, ist, einen Benutzer zu erstellen.  Wechseln Sie zur Registerkarte „Benutzer“, klicken Sie auf „Benutzer erstellen“, geben Sie einen Namen (z. B. socketUser) und ein Kennwort ein und klicken Sie dann auf „Erstellen“.  Wir benötigen dieses Benutzername / Passwort-Paar für die Authentifizierung im Web-Client im letzten Schritt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wu/pj/wg/wupjwgi1ewke4tahase9so2q_ku.png" width="80%"></div><br>  Die Konfiguration ist abgeschlossen, aber bevor wir mit der Erstellung des Servers beginnen, schauen wir uns an, wie das WebSocket-Modul in unserem Szenario funktioniert. <br><br><h2>  2. Details des Skripts </h2><br>  Mit dem WebSocket-Modul können Entwickler eine stabile Verbindung herstellen und Daten über diese senden.  Um dieses Modul zu verwenden, müssen wir es ganz am Anfang des Skripts verbinden: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(Modules.WebSocket);</code> </pre> <br>  Über die Methode createWebSocket bestimmen wir die URL und die Protokolle (optional).  Wie Sie die URL für WebSocket erhalten, erfahren Sie im nächsten Abschnitt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> webSocket = VoxEngine.createWebSocket( <span class="hljs-comment"><span class="hljs-comment">/*url*/</span></span> <span class="hljs-string"><span class="hljs-string">"wss://your_ngrok_link/"</span></span>);</code> </pre> <br>  Nach dem Erstellen des WebSocket-Objekts wird der Aufruf weiterhin im Handler verwaltet.  Das heißt, wir senden die Medien mit der Methode call.sendMediaTo an das WebSocket-Objekt. <br><br>  Hier können Sie das bevorzugte Kodierungsformat, das Tag und einige benutzerdefinierte Parameter festlegen.  Wenn Sie die Kodierung nicht einstellen, wird standardmäßig PCM8 verwendet. <br><br>  Diese Methode wird aufgerufen, wenn eine erfolgreiche Verbindungsnachricht <a href="https://voximplant.com/docs/references/voxengine/websocket/websocketevents">empfangen wird</a> .  In unserem Szenario sieht der Anrufcode folgendermaßen aus: <br><br><pre> <code class="javascript hljs">call.sendMediaTo(webSocket, { <span class="hljs-attr"><span class="hljs-attr">encoding</span></span>: WebSocketAudioEncoding.ULAW, <span class="hljs-string"><span class="hljs-string">"tag"</span></span>: <span class="hljs-string"><span class="hljs-string">"MyAudioStream"</span></span>, <span class="hljs-string"><span class="hljs-string">"customParameters"</span></span>: { <span class="hljs-string"><span class="hljs-string">"param1"</span></span>: <span class="hljs-string"><span class="hljs-string">"12345"</span></span> } });</code> </pre> <br>  Alle anderen WebSocket-Ereignisse, die Sie im Code sehen, dienen dem Debugging und senden Informationen an das Protokoll der Voximplant-Sitzung.  Sie können sie entfernen, wenn Sie möchten. <br><br>  Schließlich fügen wir den richtigen Datenübertragungsabschluss-Handler hinzu.  In unserem Fall beendet die Voximplant-Sitzung ihre Arbeit 1 Sekunde nach dem Ende des festgelegten Anrufs (getrennt): <br><br><pre> <code class="javascript hljs">call.addEventListener(CallEvents.Disconnected, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ Logger.write(<span class="hljs-string"><span class="hljs-string">"LOG OUTGOING: terminating in 1 sec"</span></span>); webSocket.close(); setTimeout(VoxEngine.terminate, <span class="hljs-number"><span class="hljs-number">1000</span></span>); });</code> </pre> <br>  Nachdem die Logik des Skripts klar ist, ist es Zeit, mit dem nächsten, sehr wichtigen Teil unseres Beispiels fortzufahren. <br><br><h2>  3. Backend </h2><br>  Stellen Sie zunächst sicher, dass Node.js. auf Ihrem Computer installiert ist.  Sie können es von <a href="https://nodejs.org/en/download/">der Node.js-</a> Hauptseite herunterladen.  Führen Sie anschließend die folgenden Befehle nacheinander im Terminalfenster aus, um die Arbeitsumgebung einzurichten: <br><br><pre> <code class="bash hljs">npm install express npm install ws npm install @google-cloud/speech</code> </pre> <br>  Und wenn dies erledigt ist, erstellen Sie eine leere JS-Datei und platzieren Sie den folgenden Code dort (die Nuancen des Codes werden unten hervorgehoben): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>)(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>).createServer(app); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WebSocket = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wss = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket.Server({ <span class="hljs-attr"><span class="hljs-attr">server</span></span>: http }); <span class="hljs-comment"><span class="hljs-comment">//     Google Cloud const speech = require('@google-cloud/speech'); //    const client = new speech.SpeechClient(); const config = { encoding: 'MULAW', sampleRateHertz: 8000, languageCode: 'ru-RU', }; const request = { config, interimResults: true, }; let audioInput = []; let recognizeStream = null; process.env["NODE_TLS_REJECT_UNAUTHORIZED"] = 0; app.get('/', function(req, res) { res.send('&lt;h1&gt;Hello world&lt;/h1&gt;'); }); wss.on('connection', (ws) =&gt; { //  ,       var wstream = fs.createWriteStream('myBinaryFile'); //   audioInput audioInput = []; //    recognizeStream = client .streamingRecognize(request) .on('error', err =&gt; { ws.close(); }) .on('data', data =&gt; { ws.send(data.results[0].alternatives[0].transcript) process.stdout.write( data.results[0] &amp;&amp; data.results[0].alternatives[0] ? `Transcription: ${data.results[0].alternatives[0].transcript}\n` : `\n\nError occurred, press Ctrl+C\n` ) }); ws.on('close', (message) =&gt; { console.log('The time limit for speech recognition has been reached. Please disconnect and call again.'); wstream.end(); }) //  ,     message ws.on('message', (message) =&gt; { //     base64  recognizeStream try { let data = JSON.parse(message) if (data.event == "media") { let b64data = data.media.payload; let buff = new Buffer.from(b64data, 'base64'); recognizeStream.write(buff); wstream.write(buff); } } catch (err) { console.log(message) } }); //      ws.send('Hi there, I am a WebSocket server'); }); http.listen(3000, function() { console.log('listening on *:3000'); });</span></span></code> </pre> <br>  Jetzt, da der Server konfiguriert ist, können wir die Spracherkennung durchführen.  Testen Sie Ihre Lösung lokal, indem Sie mit ngrok einen Tunnel auf localhost 3000 erstellen. <br><br>  Gehen Sie hierzu folgendermaßen vor <br><ol><li>  Installieren Sie ngrok, indem Sie den Anweisungen auf der <a href="https://dashboard.ngrok.com/">Website</a> folgen. </li><li>  Geben Sie Ihr Authtoken für ngrok an, um den Client an dieses Konto zu binden. </li><li>  Führen Sie den <code>node your_file_name.js</code> , um Ihren Server auf localhost: 3000 zu starten. </li><li>  Wechseln Sie zum Ordner ngrok auf Ihrem Computer, und führen Sie den Befehl <code>./ngrok http 3000</code> , um einen Tunnel zwischen dem <code>./ngrok http 3000</code> lokalen Server und der öffentlichen URL herzustellen. </li></ol><br>  Achten Sie auf die generierte öffentliche URL, wir verwenden sie als WebSocket-URL mit dem Präfix 'wss' im Skript: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ds/oy/rl/dsoyrlspc0-y5wyxqp0pbwvh38k.png" width="80%"></div><br><br><h2>  4. Spracherkennung </h2><br>  Sie haben wahrscheinlich bemerkt, dass unser Back-End-Code Zeilen enthält, die sich auf Google Cloud beziehen. <br><br>  Die Bibliothek selbst wird wie folgt importiert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> speech = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@google-cloud/speech'</span></span>);</code> </pre> <br>  Nun müssen Sie angeben, wie die Spracherkennungsanforderung verarbeitet werden soll.  Wählen Sie dazu Encoding, SampleRateHertz und LanguageCode in der generierten Konfiguration: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = { <span class="hljs-attr"><span class="hljs-attr">encoding</span></span>: <span class="hljs-string"><span class="hljs-string">'MULAW'</span></span>, <span class="hljs-attr"><span class="hljs-attr">sampleRateHertz</span></span>: <span class="hljs-number"><span class="hljs-number">8000</span></span>, <span class="hljs-attr"><span class="hljs-attr">languageCode</span></span>: <span class="hljs-string"><span class="hljs-string">'en-US'</span></span>, };</code> </pre> <br>  Erstellen Sie als Nächstes einen Schreibstrom, mit dem Sie die übertragenen Daten in einer Datei speichern können: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wstream = fs.createWriteStream(<span class="hljs-string"><span class="hljs-string">'myBinaryFile'</span></span>);</code> </pre> <br>  Wenn alles eingerichtet ist, müssen Sie die Nachricht analysieren und die Audiodaten im base64-Format in detectStream ablegen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(message) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.event == <span class="hljs-string"><span class="hljs-string">"media"</span></span>) { b64data = data.media.payload; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buff = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer.from(b64data, <span class="hljs-string"><span class="hljs-string">'base64'</span></span>); recognizeStream.write(buff); wstream.write(buff); }</code> </pre> <br>  Unmittelbar danach wird eine Erkennungsanforderung initiiert und die Verarbeitung dieser Anforderung beginnt: <br><br><pre> <code class="javascript hljs">recognizeStream = client .streamingRecognize(request) .on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, data =&gt; { ws.send(data.results[<span class="hljs-number"><span class="hljs-number">0</span></span>].alternatives[<span class="hljs-number"><span class="hljs-number">0</span></span>].transcript) });</code> </pre> <br>  Geben Sie abschließend die Anmeldeinformationen Ihres Dienstkontos ein, um die Google-Bibliothek mit ihrem Back-End zu verbinden.  Rufen Sie dazu die <a href="">Google-Authentifizierungsseite auf</a> und befolgen Sie alle dort aufgeführten Schritte.  Führen Sie dann den Befehl export in demselben Arbeitsbereich (auf derselben Registerkarte „Terminal“) wie den <code>node your_file_name.js:</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> GOOGLE_APPLICATION_CREDENTIALS=<span class="hljs-string"><span class="hljs-string">"/home/user/Downloads/[FILE_NAME].json"</span></span></code> </pre> <br><h2>  Sockets starten </h2><br>  Öffnen Sie <a href="https://phone.voximplant.com/">phone.voximplant.com</a> , füllen Sie das Formular aus und klicken Sie auf <a href="https://phone.voximplant.com/">Anmelden</a> .  Benutzername und Passwort beziehen sich auf den in Schritt 1 erstellten Benutzer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i8/cf/w-/i8cfw--mu0kpommcqb8bs_o5wmy.png" width="90%"></div><br>  Klicken Sie nach erfolgreicher Autorisierung auf Anrufen und sprechen Sie.  Die Speech-to-Text-Cloud wandelt Ihre Sprache in Echtzeit in Text um, und Sie können diesen Text im Terminalfenster sehen. <br><br>  Du hast es geschafft, Glückwunsch!  Wir hoffen, dass Ihnen der Artikel gefallen hat und wünschen Ihnen mehr Integration und neue Herausforderungen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/sv/px/eusvpx0ba-qq6mzpzbpdsadyn9s.png" width="80%"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476902/">https://habr.com/ru/post/de476902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476878/index.html">GP LED-Lampen</a></li>
<li><a href="../de476880/index.html">Sicherheitskrippen: CSRF</a></li>
<li><a href="../de476888/index.html">Welche UX-Designtrends folgen 2020?</a></li>
<li><a href="../de476890/index.html">Für diejenigen, die bei Houdini arbeiten. Über Nature of Vex und Bites of Python Kurse</a></li>
<li><a href="../de476900/index.html">Autonomes Gerät auf Arduino, das einen Temperaturanstieg (-abfall) signalisiert</a></li>
<li><a href="../de476904/index.html">Eine weitere Scheinbibliothek</a></li>
<li><a href="../de476906/index.html">Was ist neu in SOLIDWORKS 2020?</a></li>
<li><a href="../de476908/index.html">Ist Hadoop tot? Teil 2</a></li>
<li><a href="../de476910/index.html">Antiquitäten: Eine schwierige Auswahl an Soundkarten für DOS-Spiele</a></li>
<li><a href="../de476912/index.html">Buchungskreisrechte für Programmierer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>