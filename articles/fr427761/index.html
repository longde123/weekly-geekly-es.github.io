<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•“ ğŸŒ¿ ğŸ†˜ ImplÃ©mentation de l'algorithme k-means (k-means) en utilisant l'exemple du travail avec les pixels ğŸµï¸ ğŸ¤±ğŸ¾ ğŸ‘ˆğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour Ã  tous! RÃ©cemment, il a Ã©tÃ© nÃ©cessaire d'Ã©crire du code pour implÃ©menter la segmentation d'image en utilisant la mÃ©thode k-means (anglais k-me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ImplÃ©mentation de l'algorithme k-means (k-means) en utilisant l'exemple du travail avec les pixels</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427761/">  Bonjour Ã  tous!  RÃ©cemment, il a Ã©tÃ© nÃ©cessaire d'Ã©crire du code pour implÃ©menter la segmentation d'image en utilisant la mÃ©thode k-means (anglais k-means).  Eh bien, la premiÃ¨re chose que Google fait est d'aider.  J'ai trouvÃ© beaucoup d'informations, comme d'un point de vue mathÃ©matique (toutes sortes de gribouillis mathÃ©matiques complexes lÃ -bas, vous comprendrez ce que l'enfer y est Ã©crit), ainsi que certaines implÃ©mentations logicielles qui sont sur Internet en anglais.  Ces codes sont certainement beaux - sans aucun doute, mais l'essence de l'idÃ©e est difficile Ã  saisir.  D'une maniÃ¨re ou d'une autre, tout est compliquÃ©, confus, et pourtant, Ã  la main, Ã  la main, vous n'Ã©crirez pas le code, vous ne comprendrez rien.  Dans cet article, je veux montrer une mise en Å“uvre simple, non productive, mais, je l'espÃ¨re, comprÃ©hensible de ce merveilleux algorithme.  D'accord, allons-y! <br><a name="habracut"></a><br>  Alors, qu'est-ce que le clustering en termes de nos perceptions?  Permettez-moi de vous donner un exemple, disons qu'il y a une belle photo avec des fleurs du chalet de votre grand-mÃ¨re. <br><br><img src="https://habrastorage.org/webt/o2/0j/p5/o20jp5rx4sfpjieou7ipk8mfika.jpeg"><br><br>  La question est: pour dÃ©terminer combien de zones sur cette photo sont remplies d'environ la mÃªme couleur.  Eh bien, ce nâ€™est pas du tout difficile: des pÃ©tales blancs - un, des centres jaunes - deux (je ne suis pas biologiste, je ne sais pas comment on les appelle), trois verts.  Ces sections sont appelÃ©es clusters.  Un cluster est une combinaison de donnÃ©es ayant des caractÃ©ristiques communes (couleur, position, etc.).  Le processus de dÃ©termination et de placement de chaque composant des donnÃ©es dans de tels clusters - sections est appelÃ© clustering. <br><br>  Il existe de nombreux algorithmes de clustering, mais le plus simple d'entre eux est k-medium, qui sera discutÃ© plus tard.  K-means est un algorithme simple et efficace, facile Ã  mettre en Å“uvre Ã  l'aide d'une mÃ©thode logicielle.  Les donnÃ©es que nous distribuerons en grappes sont des pixels.  Comme vous le savez, un pixel de couleur a trois composants - rouge, vert et bleu.  L'imposition de ces composants crÃ©e ainsi une palette de couleurs existantes. <br><br><img src="https://habrastorage.org/webt/gf/5u/b1/gf5ub1f-9xv56o7b86jsozumzlw.jpeg"><br><br>  Dans la mÃ©moire de l'ordinateur, chaque composante de couleur est caractÃ©risÃ©e par un nombre compris entre 0 et 255. Autrement dit, en combinant diffÃ©rentes valeurs de rouge, vert et bleu, nous obtenons une palette de couleurs Ã  l'Ã©cran. <br><br>  En utilisant des pixels comme exemple, nous implÃ©mentons notre algorithme.  K-means est un algorithme itÃ©ratif, c'est-Ã -dire qu'il donnera le rÃ©sultat correct, aprÃ¨s un certain nombre de rÃ©pÃ©titions de certains calculs mathÃ©matiques. <br><br><h3>  Algorithme </h3><br><ol><li>  Vous devez savoir Ã  l'avance de combien de clusters vous avez besoin pour distribuer les donnÃ©es.  C'est un inconvÃ©nient important de cette mÃ©thode, mais ce problÃ¨me est rÃ©solu par des implÃ©mentations amÃ©liorÃ©es de l'algorithme, mais cela, comme on dit, est une histoire complÃ¨tement diffÃ©rente. </li><li>  Nous devons choisir les centres initiaux de nos grappes.  Comment?  Oui au hasard.  Pourquoi?  Pour que vous puissiez accrocher chaque pixel au centre du cluster.  Le centre est comme le roi, autour duquel ses sujets sont rassemblÃ©s - les pixels.  C'est la Â«distanceÂ» du centre au pixel qui dÃ©termine Ã  qui chaque pixel obÃ©ira. </li><li>  Nous calculons la distance de chaque centre Ã  chaque pixel.  Cette distance est considÃ©rÃ©e comme la distance euclidienne entre les points dans l'espace, et dans notre cas, comme la distance entre les trois composantes de couleur: <p><math> </math> $$ affiche $$ \ sqrt {(R_ {2} -R_ {1}) ^ 2 + (G_ {2} -G_ {1}) ^ 2 + (B_ {2} -B_ {1}) ^ 2} . $$ afficher $$ </p>  Nous calculons la distance du premier pixel Ã  chaque centre et dÃ©terminons la plus petite distance entre ce pixel et les centres.  Pour le centre, dont la distance est la plus petite, nous recalculons les coordonnÃ©es comme moyenne arithmÃ©tique entre chaque composante du pixel - le roi et le pixel - du sujet.  Notre centre se dÃ©place dans l'espace selon les calculs. </li><li>  AprÃ¨s avoir recomptÃ© tous les centres, nous distribuons les pixels en grappes, en comparant la distance de chaque pixel aux centres.  Un pixel est placÃ© dans un cluster, au centre duquel il est plus proche que les autres centres. </li><li>  Tout recommence, tant que les pixels restent dans les mÃªmes grappes.  Souvent, cela peut ne pas se produire, car avec une grande quantitÃ© de donnÃ©es, les centres se dÃ©placent dans un petit rayon et les pixels le long des bords des clusters sautent dans l'un ou l'autre cluster.  Pour ce faire, dÃ©terminez le nombre maximal d'itÃ©rations. </li></ol><br><h3>  ImplÃ©mentation </h3><br>  Je vais implÃ©menter ce projet en C ++.  Le premier fichier est Â«k_means.hÂ», dans lequel j'ai dÃ©fini les principaux types de donnÃ©es, les constantes et la classe principale pour travailler - Â«K_meansÂ». <br>  Pour caractÃ©riser chaque pixel, crÃ©ez une structure qui se compose de trois composants de pixel, pour lesquels j'ai choisi le type double pour des calculs plus prÃ©cis, et dÃ©fini Ã©galement quelques constantes pour que le programme fonctionne: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> KK = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  const int max_iterations = 100; //   typedef struct { double r; double g; double b; } rgb;</span></span></code> </pre> <br>  K_means se classe: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K_means</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; pixcel; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q_klaster; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k_pixcel; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; centr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identify_centers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rgb k1, rgb k2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.r - k2.r),<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.g - k2.g), <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.b - k2.b), <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute_s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: K_means() : q_klaster(<span class="hljs-number"><span class="hljs-number">0</span></span>), k_pixcel(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}; K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb *mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster); K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clustering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream &amp; os)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ~K_means(); <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k); };</code> </pre><br>  Passons en revue les composants de la classe: <br><br>  vectorpixcel - un vecteur pour les pixels; <br>  q_klaster - nombre de clusters; <br>  k_pixcel - nombre de pixels; <br>  vectorcentr - un vecteur pour regrouper les centres, le nombre d'Ã©lÃ©ments qu'il contient est dÃ©terminÃ© par q_klaster; <br>  identifier_centers () - une mÃ©thode pour sÃ©lectionner alÃ©atoirement les centres initiaux parmi les pixels d'entrÃ©e; <br>  compute () et compute_s () sont des mÃ©thodes intÃ©grÃ©es pour calculer la distance entre les pixels et les centres de recalcul, respectivement; <br>  trois constructeurs: le premier par dÃ©faut, le second pour initialiser les pixels du tableau, le troisiÃ¨me pour initialiser les pixels d'un fichier texte (dans mon implÃ©mentation, le fichier est d'abord accidentellement rempli de donnÃ©es, puis les pixels sont lus Ã  partir de ce fichier pour que le programme fonctionne, pourquoi pas directement dans le vecteur - juste nÃ©cessaire dans mon cas); <br>  clustering (std :: ostream &amp; os) - mÃ©thode de clustering; <br>  mÃ©thode et surcharge de l'instruction de sortie pour publier les rÃ©sultats. <br><br>  ImplÃ©mentation de la mÃ©thode: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::identify_centers() { srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)); rgb temp; rgb *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> rgb[q_klaster]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { temp = pixcel[<span class="hljs-number"><span class="hljs-number">0</span></span> + rand() % k_pixcel]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i; j &lt; q_klaster; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp.r != mas[j].r &amp;&amp; temp.g != mas[j].g &amp;&amp; temp.b != mas[j].b) { mas[j] = temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { centr.push_back(mas[i]); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> []mas; }</code> </pre><br>  Il s'agit d'une mÃ©thode pour sÃ©lectionner les centres de regroupement initiaux et les ajouter au vecteur central.  Une vÃ©rification est effectuÃ©e pour rÃ©pÃ©ter les centres et les remplacer dans ces cas. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb * mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { pixcel.push_back(*(mas + i)); } q_klaster = n_klaster; k_pixcel = n; identify_centers(); }</code> </pre><br>  Une implÃ©mentation de constructeur pour initialiser des pixels Ã  partir d'un tableau. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os) : q_klaster(n_klaster) { rgb temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (os &gt;&gt; temp.r &amp;&amp; os &gt;&gt; temp.g &amp;&amp; os &gt;&gt; temp.b) { pixcel.push_back(temp); } k_pixcel = pixcel.size(); identify_centers(); }</code> </pre><br>  Nous passons un objet d'entrÃ©e Ã  ce constructeur pour pouvoir entrer des donnÃ©es Ã  la fois du fichier et de la console. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::clustering(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n :"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*             :        ,    -  ,    ,   ,        .*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_1(k_pixcel, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_2(k_pixcel, <span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n----------------  â„–"</span></span> &lt;&lt; iter &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ----------------\n\n"</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*  :          .      ,   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[j], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*     m_k      .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"    #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"  #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>; centr[m_k].r = compute_s(pixcel[j].r, centr[m_k].r); centr[m_k].g = compute_s(pixcel[j].g, centr[m_k].g); centr[m_k].b = compute_s(pixcel[j].b, centr[m_k].b); os &lt;&lt; centr[m_k].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mas; } <span class="hljs-comment"><span class="hljs-comment">/*   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *mass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[k_pixcel]; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n  : "</span></span>&lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; k_pixcel; k++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[k], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   â„–"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*  .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } mass[k] = m_k; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" â„–"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"     #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*            .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n    : \n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k_pixcel; i++) { os &lt;&lt; mass[i] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; check_1[i] = *(mass + i); } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itr = KK + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mass[j] == i) { os &lt;&lt; pixcel[j].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; mass[j] = ++itr; } } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mass; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : \n"</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">/*         â€“  .*/</span></span> iter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_1 == check_2 || iter &gt;= max_iterations) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } check_2 = check_1; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n ."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre>  La principale mÃ©thode de clustering. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.k_pixcel; i++) { os &lt;&lt; k.pixcel[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - â„–"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.q_klaster; i++) { os &lt;&lt; k.centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n : "</span></span> &lt;&lt; k.q_klaster &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; k.k_pixcel &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os; }</code> </pre><br>  La sortie des donnÃ©es initiales. <br><br><h4>  Exemple de sortie </h4><br><div class="spoiler">  <b class="spoiler_title">Exemple de sortie</b> <div class="spoiler_text">  <em>Pixels de dÃ©part:</em> <em><br></em>  <em>255 140 50 - n Â° 0</em> <em><br></em>  <em>100 70 1 - n Â° 1</em> <em><br></em>  <em>150 20 200 - n Â° 2</em> <em><br></em>  <em>251 141 51 - n Â° 3</em> <em><br></em>  <em>104 69 3 - n Â° 4</em> <em><br></em>  <em>153 22 210 - n Â° 5</em> <em><br></em>  <em>252 138 54 - n Â° 6</em> <em><br></em>  <em>101 74 4 - n Â° 7</em> <em><br><br></em>  <em>Centres de regroupement initial alÃ©atoires:</em> <em><br></em>  <em>150 20 200 - # 0</em> <em><br></em>  <em>104 69 3 - # 1</em> <em><br></em>  <em>100 70 1 - # 2</em> <em><br><br></em>  <em>Nombre de grappes: 3</em> <em><br></em>  <em>Nombre de pixels: 8</em> <em><br><br></em>  <em>DÃ©but du cluster:</em> <em><br><br></em>  <em>NumÃ©ro d'itÃ©ration 0</em> <em><br><br></em>  <em>Distance entre le pixel 0 et le centre # 0: 218.918</em> <em><br></em>  <em>Distance entre le pixel 0 et le centre # 1: 173,352</em> <em><br></em>  <em>Distance entre le pixel 0 et le centre # 2: 176,992</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Recalculer le centre n Â° 1: 179,5 104,5 26,5</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 0: 211.189</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 1: 90,3369</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 2: 0</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Recalculer le centre # 2: 100 70 1</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 0: 0</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 1: 195.225</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 2: 211.189</em> <em><br></em>  <em>Distance centrale minimale # 0</em> <em><br></em>  <em>Compter le centre # 0: 150 20 200</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 0: 216.894</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 1: 83,933</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 2: 174,19</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Compter le centre # 1: 215,25 122,75 38,75</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 0: 208.149</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 1: 128,622</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 2: 4,58258</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Compter le centre # 2: 102 69,5 2</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 0: 10.6301</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 1: 208,212</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 2: 219,366</em> <em><br></em>  <em>Distance centrale minimale # 0</em> <em><br></em>  <em>Recalculer le centre # 0: 151,5 21 205</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 0: 215.848</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 1: 42.6109</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 2: 172.905</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Recalculer le centre n Â° 1: 233,625 130,375 46,375</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 0: 213.916</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 1: 150,21</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 2: 5.02494</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Recalculer le centre n Â° 2: 101,5 71,75 3</em> <em><br><br></em>  <em>Classons les pixels:</em> <em><br></em>  <em>La distance entre le pixel n Â° 0 et le centre # 0: 221.129</em> <em><br></em>  <em>La distance entre le pixel n Â° 0 et le centre n Â° 1: 23,7207</em> <em><br></em>  <em>La distance entre le pixel n Â° 0 et le centre n Â° 2: 174,44</em> <em><br></em>  <em>Pixel # 0 le plus proche du centre # 1</em> <em><br></em>  <em>La distance entre le pixel n Â° 1 et le centre # 0: 216.031</em> <em><br></em>  <em>La distance entre le pixel n Â° 1 et le centre n Â° 1: 153,492</em> <em><br></em>  <em>La distance du pixel n Â° 1 au centre n Â° 2: 3.05164</em> <em><br></em>  <em>Pixel # 1 le plus proche du centre # 2</em> <em><br></em>  <em>La distance entre le pixel n Â° 2 et le centre # 0: 5.31507</em> <em><br></em>  <em>La distance entre le pixel n Â° 2 et le centre n Â° 1: 206,825</em> <em><br></em>  <em>La distance entre le pixel n Â° 2 et le centre n Â° 2: 209,378</em> <em><br></em>  <em>Pixel # 2 le plus proche du centre # 0</em> <em><br></em>  <em>La distance entre le pixel numÃ©ro 3 et le centre # 0: 219.126</em> <em><br></em>  <em>La distance entre le pixel n Â° 3 et le centre n Â° 1: 20,8847</em> <em><br></em>  <em>La distance entre le pixel n Â° 3 et le centre n Â° 2: 171,609</em> <em><br></em>  <em>Pixel # 3 le plus proche du centre # 1</em> <em><br></em>  <em>La distance entre le pixel n Â° 4 et le centre # 0: 212,989</em> <em><br></em>  <em>La distance entre le pixel n Â° 4 et le centre n Â° 1: 149,836</em> <em><br></em>  <em>La distance entre le pixel n Â° 4 et le centre n Â° 2: 3,71652</em> <em><br></em>  <em>Pixel # 4 le plus proche du centre # 2</em> <em><br></em>  <em>La distance entre le pixel n Â° 5 et le centre # 0: 5.31507</em> <em><br></em>  <em>La distance entre le pixel n Â° 5 et le centre # 1: 212.176</em> <em><br></em>  <em>La distance entre le pixel n Â° 5 et le centre n Â° 2: 219.035</em> <em><br></em>  <em>Pixel # 5 le plus proche du centre # 0</em> <em><br></em>  <em>La distance entre le pixel numÃ©ro 6 et le centre # 0: 215.848</em> <em><br></em>  <em>La distance du pixel n Â° 6 au centre # 1: 21.3054</em> <em><br></em>  <em>La distance du pixel numÃ©ro 6 au centre # 2: 172.164</em> <em><br></em>  <em>Pixel # 6 le plus proche du centre # 1</em> <em><br></em>  <em>La distance du pixel n Â° 7 au centre # 0: 213.916</em> <em><br></em>  <em>La distance entre le pixel n Â° 7 et le centre n Â° 1: 150,21</em> <em><br></em>  <em>La distance entre le pixel n Â° 7 et le centre n Â° 2: 2,51247</em> <em><br></em>  <em>Pixel # 7 le plus proche du centre # 2</em> <em><br><br></em>  <em>Un tableau de pixels et de centres correspondants:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>RÃ©sultat du clustering:</em> <em><br></em>  <em>Groupe # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Groupe # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Groupe # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Nouveaux centres:</em> <em><br></em>  <em>151,5 21 205 - # 0</em> <em><br></em>  <em>233,625 130,375 46,375 - # 1</em> <em><br></em>  <em>101,5 71,75 3 - # 2</em> <em><br><br></em>  <em>NumÃ©ro d'itÃ©ration 1</em> <em><br><br></em>  <em>Distance entre le pixel 0 et le centre # 0: 221.129</em> <em><br></em>  <em>Distance entre le pixel 0 et le centre # 1: 23.7207</em> <em><br></em>  <em>Distance entre le pixel 0 et le centre # 2: 174,44</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Compter le centre # 1: 244.313 135.188 48.1875</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 0: 216.031</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 1: 165.234</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 2: 3.05164</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Recalculer le centre n Â° 2: 100,75 70,875 2</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 0: 5.31507</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 1: 212,627</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 2: 210,28</em> <em><br></em>  <em>Distance centrale minimale # 0</em> <em><br></em>  <em>Recalculer le centre # 0: 150,75 20,5 202,5</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 0: 217.997</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 1: 9.29613</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 2: 172.898</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Compter le centre # 1: 247.656 138.094 49.5938</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 0: 210.566</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 1: 166.078</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 2: 3.88306</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Comptage du centre n Â° 2: 102,375 69,9375 2,5</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 0: 7.97261</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 1: 219.471</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 2: 218,9</em> <em><br></em>  <em>Distance centrale minimale # 0</em> <em><br></em>  <em>Compter le centre # 0: 151.875 21.25 206.25</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 0: 216.415</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 1: 6.18805</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 2: 172.257</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Recalculer le centre # 1: 249.828 138.047 51.7969</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 0: 215.118</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 1: 168,927</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 2: 4,54363</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Recalculer le centre n Â° 2: 101,688 71,9688 3,25</em> <em><br><br></em>  <em>Classons les pixels:</em> <em><br></em>  <em>La distance du pixel n Â° 0 au centre # 0: 221.699</em> <em><br></em>  <em>La distance entre le pixel n Â° 0 et le centre # 1: 5.81307</em> <em><br></em>  <em>La distance entre le pixel n Â° 0 et le centre n Â° 2: 174,122</em> <em><br></em>  <em>Pixel # 0 le plus proche du centre # 1</em> <em><br></em>  <em>La distance entre le pixel n Â° 1 et le centre # 0: 217.244</em> <em><br></em>  <em>La distance entre le pixel n Â° 1 et le centre n Â° 1: 172,218</em> <em><br></em>  <em>La distance entre le pixel n Â° 1 et le centre n Â° 2: 3,43309</em> <em><br></em>  <em>Pixel # 1 le plus proche du centre # 2</em> <em><br></em>  <em>La distance entre le pixel n Â° 2 et le centre # 0: 6,64384</em> <em><br></em>  <em>La distance du pixel n Â° 2 au centre # 1: 214.161</em> <em><br></em>  <em>La distance entre le pixel n Â° 2 et le centre n Â° 2: 209,154</em> <em><br></em>  <em>Pixel # 2 le plus proche du centre # 0</em> <em><br></em>  <em>La distance du pixel n Â° 3 au centre # 0: 219.701</em> <em><br></em>  <em>Distance entre le pixel # 3 et le centre # 1: 3,27555</em> <em><br></em>  <em>La distance entre le pixel n Â° 3 et le centre n Â° 2: 171,288</em> <em><br></em>  <em>Pixel # 3 le plus proche du centre # 1</em> <em><br></em>  <em>La distance entre le pixel n Â° 4 et le centre # 0: 214.202</em> <em><br></em>  <em>La distance entre le pixel n Â° 4 et le centre n Â° 1: 168,566</em> <em><br></em>  <em>La distance entre le pixel n Â° 4 et le centre n Â° 2: 3,777142</em> <em><br></em>  <em>Pixel # 4 le plus proche du centre # 2</em> <em><br></em>  <em>La distance entre le pixel n Â° 5 et le centre # 0: 3,9863</em> <em><br></em>  <em>La distance entre le pixel n Â° 5 et le centre n Â° 1: 218,794</em> <em><br></em>  <em>La distance entre le pixel n Â° 5 et le centre n Â° 2: 218.805</em> <em><br></em>  <em>Pixel # 5 le plus proche du centre # 0</em> <em><br></em>  <em>La distance entre le pixel numÃ©ro 6 et le centre # 0: 216.415</em> <em><br></em>  <em>La distance entre le pixel n Â° 6 et le centre # 1: 3.09403</em> <em><br></em>  <em>La distance entre le pixel n Â° 6 et le centre n Â° 2: 171,842</em> <em><br></em>  <em>Pixel # 6 le plus proche du centre # 1</em> <em><br></em>  <em>La distance du pixel n Â° 7 au centre # 0: 215.118</em> <em><br></em>  <em>La distance entre le pixel n Â° 7 et le centre n Â° 1: 168,927</em> <em><br></em>  <em>La distance entre le pixel n Â° 7 et le centre n Â° 2: 2,27181</em> <em><br></em>  <em>Pixel # 7 le plus proche du centre # 2</em> <em><br><br></em>  <em>Un tableau de pixels et de centres correspondants:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>RÃ©sultat du clustering:</em> <em><br></em>  <em>Groupe # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Groupe # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Groupe # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Nouveaux centres:</em> <em><br></em>  <em>151,875 21,25 206,25 - # 0</em> <em><br></em>  <em>249.828 138.047 51.7969 - # 1</em> <em><br></em>  <em>101,688 71,9688 3,25 - # 2</em> <em><br><br></em>  <em>La fin du clustering.</em> <br></div></div><br>  Cet exemple est prÃ©vu Ã  l'avance, les pixels sont sÃ©lectionnÃ©s spÃ©cifiquement pour la dÃ©monstration.  Deux itÃ©rations suffisent pour que le programme regroupe les donnÃ©es en trois clusters.  En regardant les centres des deux derniÃ¨res itÃ©rations, vous pouvez voir qu'ils sont pratiquement restÃ©s en place. <br><br>  Plus intÃ©ressants sont les cas de pixels gÃ©nÃ©rÃ©s alÃ©atoirement.  Ayant gÃ©nÃ©rÃ© 50 points qui doivent Ãªtre divisÃ©s en 10 grappes, j'ai obtenu 5 itÃ©rations.  Ayant gÃ©nÃ©rÃ© 50 points qui doivent Ãªtre divisÃ©s en 3 clusters, j'ai obtenu les 100 itÃ©rations maximales autorisÃ©es.  Vous pouvez remarquer que plus il y a de clusters, plus il est facile pour le programme de trouver les pixels les plus similaires et de les combiner en petits groupes, et vice versa - s'il y a peu de clusters et qu'il y a beaucoup de points, l'algorithme se termine souvent uniquement lorsque le nombre maximum d'itÃ©rations est dÃ©passÃ©, car certains pixels sautent constamment d'un cluster Ã  l'autre.  Cependant, la majeure partie est encore complÃ¨tement dÃ©terminÃ©e dans leurs grappes. <br><br>  Eh bien, vÃ©rifions maintenant le rÃ©sultat du clustering.  En prenant le rÃ©sultat de certains clusters de l'exemple de 50 points pour 10 clusters, j'ai conduit le rÃ©sultat de ces donnÃ©es dans Illustrator et c'est ce qui s'est passÃ©: <br><br><img src="https://habrastorage.org/webt/b2/fl/me/b2flmelfv6bqxeautb8s4ywwstm.jpeg"><br><br>  On peut voir que dans chaque groupe, toutes les nuances de couleur prÃ©valent, et ici vous devez comprendre que les pixels ont Ã©tÃ© sÃ©lectionnÃ©s au hasard, l'analogue d'une telle image dans la vie rÃ©elle est une sorte d'image sur laquelle toutes les couleurs ont Ã©tÃ© accidentellement pulvÃ©risÃ©es et il est difficile de sÃ©lectionner des zones de couleurs similaires. <br><br>  Disons que nous avons une telle photo.  Nous pouvons dÃ©finir une Ã®le comme un seul cluster, mais avec une augmentation, nous voyons qu'elle se compose de diffÃ©rentes nuances de vert. <br><br><img src="https://habrastorage.org/webt/s8/qv/um/s8qvumchfqerkbdfo5gx7ijm4to.jpeg"><br><br>  Et c'est le cluster 8, mais dans une version plus petite, le rÃ©sultat est similaire: <br><br><img src="https://habrastorage.org/webt/dt/ia/eb/dtiaebsnf1uzpi69jqmbkvui5uo.jpeg"><br><br>  La version complÃ¨te du programme peut Ãªtre consultÃ©e sur mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427761/">https://habr.com/ru/post/fr427761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427749/index.html">Apple et Samsung pour la premiÃ¨re fois condamnÃ©s Ã  une amende pour avoir ralenti de vieux tÃ©lÃ©phones</a></li>
<li><a href="../fr427751/index.html">CudaText Sublime Ideas</a></li>
<li><a href="../fr427755/index.html">Nouvelle version de GitLab 11.4 avec examen par les pairs des demandes de fusion et des indicateurs de fonctionnalitÃ©</a></li>
<li><a href="../fr427757/index.html">Portes arriÃ¨re de microcode assemblÃ©es par processeur X86</a></li>
<li><a href="../fr427759/index.html">A propos de la solvabilitÃ© des problÃ¨mes de ceinture de circulation en temps polynomial</a></li>
<li><a href="../fr427763/index.html">Cours MIT "SÃ©curitÃ© des systÃ¨mes informatiques". ConfÃ©rence 13: Protocoles rÃ©seau, partie 1</a></li>
<li><a href="../fr427767/index.html">Situation: au Canada, ils ont proposÃ© d'introduire une taxe sur le streaming - nous discutons du problÃ¨me</a></li>
<li><a href="../fr427771/index.html">Cours MIT "SÃ©curitÃ© des systÃ¨mes informatiques". ConfÃ©rence 13: Network Protocols, Part 2</a></li>
<li><a href="../fr427773/index.html">J'ai Ã©crit une extension multi-navigateur pour les onglets, mais vous ne le faites pas</a></li>
<li><a href="../fr427775/index.html">Un bot dÃ©guisÃ© en programmeur corrige les erreurs de code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>