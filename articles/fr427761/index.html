<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïì üåø üÜò Impl√©mentation de l'algorithme k-means (k-means) en utilisant l'exemple du travail avec les pixels üèµÔ∏è ü§±üèæ üëàüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! R√©cemment, il a √©t√© n√©cessaire d'√©crire du code pour impl√©menter la segmentation d'image en utilisant la m√©thode k-means (anglais k-me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Impl√©mentation de l'algorithme k-means (k-means) en utilisant l'exemple du travail avec les pixels</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427761/">  Bonjour √† tous!  R√©cemment, il a √©t√© n√©cessaire d'√©crire du code pour impl√©menter la segmentation d'image en utilisant la m√©thode k-means (anglais k-means).  Eh bien, la premi√®re chose que Google fait est d'aider.  J'ai trouv√© beaucoup d'informations, comme d'un point de vue math√©matique (toutes sortes de gribouillis math√©matiques complexes l√†-bas, vous comprendrez ce que l'enfer y est √©crit), ainsi que certaines impl√©mentations logicielles qui sont sur Internet en anglais.  Ces codes sont certainement beaux - sans aucun doute, mais l'essence de l'id√©e est difficile √† saisir.  D'une mani√®re ou d'une autre, tout est compliqu√©, confus, et pourtant, √† la main, √† la main, vous n'√©crirez pas le code, vous ne comprendrez rien.  Dans cet article, je veux montrer une mise en ≈ìuvre simple, non productive, mais, je l'esp√®re, compr√©hensible de ce merveilleux algorithme.  D'accord, allons-y! <br><a name="habracut"></a><br>  Alors, qu'est-ce que le clustering en termes de nos perceptions?  Permettez-moi de vous donner un exemple, disons qu'il y a une belle photo avec des fleurs du chalet de votre grand-m√®re. <br><br><img src="https://habrastorage.org/webt/o2/0j/p5/o20jp5rx4sfpjieou7ipk8mfika.jpeg"><br><br>  La question est: pour d√©terminer combien de zones sur cette photo sont remplies d'environ la m√™me couleur.  Eh bien, ce n‚Äôest pas du tout difficile: des p√©tales blancs - un, des centres jaunes - deux (je ne suis pas biologiste, je ne sais pas comment on les appelle), trois verts.  Ces sections sont appel√©es clusters.  Un cluster est une combinaison de donn√©es ayant des caract√©ristiques communes (couleur, position, etc.).  Le processus de d√©termination et de placement de chaque composant des donn√©es dans de tels clusters - sections est appel√© clustering. <br><br>  Il existe de nombreux algorithmes de clustering, mais le plus simple d'entre eux est k-medium, qui sera discut√© plus tard.  K-means est un algorithme simple et efficace, facile √† mettre en ≈ìuvre √† l'aide d'une m√©thode logicielle.  Les donn√©es que nous distribuerons en grappes sont des pixels.  Comme vous le savez, un pixel de couleur a trois composants - rouge, vert et bleu.  L'imposition de ces composants cr√©e ainsi une palette de couleurs existantes. <br><br><img src="https://habrastorage.org/webt/gf/5u/b1/gf5ub1f-9xv56o7b86jsozumzlw.jpeg"><br><br>  Dans la m√©moire de l'ordinateur, chaque composante de couleur est caract√©ris√©e par un nombre compris entre 0 et 255. Autrement dit, en combinant diff√©rentes valeurs de rouge, vert et bleu, nous obtenons une palette de couleurs √† l'√©cran. <br><br>  En utilisant des pixels comme exemple, nous impl√©mentons notre algorithme.  K-means est un algorithme it√©ratif, c'est-√†-dire qu'il donnera le r√©sultat correct, apr√®s un certain nombre de r√©p√©titions de certains calculs math√©matiques. <br><br><h3>  Algorithme </h3><br><ol><li>  Vous devez savoir √† l'avance de combien de clusters vous avez besoin pour distribuer les donn√©es.  C'est un inconv√©nient important de cette m√©thode, mais ce probl√®me est r√©solu par des impl√©mentations am√©lior√©es de l'algorithme, mais cela, comme on dit, est une histoire compl√®tement diff√©rente. </li><li>  Nous devons choisir les centres initiaux de nos grappes.  Comment?  Oui au hasard.  Pourquoi?  Pour que vous puissiez accrocher chaque pixel au centre du cluster.  Le centre est comme le roi, autour duquel ses sujets sont rassembl√©s - les pixels.  C'est la ¬´distance¬ª du centre au pixel qui d√©termine √† qui chaque pixel ob√©ira. </li><li>  Nous calculons la distance de chaque centre √† chaque pixel.  Cette distance est consid√©r√©e comme la distance euclidienne entre les points dans l'espace, et dans notre cas, comme la distance entre les trois composantes de couleur: <p><math> </math> $$ affiche $$ \ sqrt {(R_ {2} -R_ {1}) ^ 2 + (G_ {2} -G_ {1}) ^ 2 + (B_ {2} -B_ {1}) ^ 2} . $$ afficher $$ </p>  Nous calculons la distance du premier pixel √† chaque centre et d√©terminons la plus petite distance entre ce pixel et les centres.  Pour le centre, dont la distance est la plus petite, nous recalculons les coordonn√©es comme moyenne arithm√©tique entre chaque composante du pixel - le roi et le pixel - du sujet.  Notre centre se d√©place dans l'espace selon les calculs. </li><li>  Apr√®s avoir recompt√© tous les centres, nous distribuons les pixels en grappes, en comparant la distance de chaque pixel aux centres.  Un pixel est plac√© dans un cluster, au centre duquel il est plus proche que les autres centres. </li><li>  Tout recommence, tant que les pixels restent dans les m√™mes grappes.  Souvent, cela peut ne pas se produire, car avec une grande quantit√© de donn√©es, les centres se d√©placent dans un petit rayon et les pixels le long des bords des clusters sautent dans l'un ou l'autre cluster.  Pour ce faire, d√©terminez le nombre maximal d'it√©rations. </li></ol><br><h3>  Impl√©mentation </h3><br>  Je vais impl√©menter ce projet en C ++.  Le premier fichier est ¬´k_means.h¬ª, dans lequel j'ai d√©fini les principaux types de donn√©es, les constantes et la classe principale pour travailler - ¬´K_means¬ª. <br>  Pour caract√©riser chaque pixel, cr√©ez une structure qui se compose de trois composants de pixel, pour lesquels j'ai choisi le type double pour des calculs plus pr√©cis, et d√©fini √©galement quelques constantes pour que le programme fonctionne: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> KK = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  const int max_iterations = 100; //   typedef struct { double r; double g; double b; } rgb;</span></span></code> </pre> <br>  K_means se classe: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K_means</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; pixcel; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q_klaster; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k_pixcel; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; centr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identify_centers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rgb k1, rgb k2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.r - k2.r),<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.g - k2.g), <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.b - k2.b), <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute_s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: K_means() : q_klaster(<span class="hljs-number"><span class="hljs-number">0</span></span>), k_pixcel(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}; K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb *mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster); K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clustering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream &amp; os)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ~K_means(); <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k); };</code> </pre><br>  Passons en revue les composants de la classe: <br><br>  vectorpixcel - un vecteur pour les pixels; <br>  q_klaster - nombre de clusters; <br>  k_pixcel - nombre de pixels; <br>  vectorcentr - un vecteur pour regrouper les centres, le nombre d'√©l√©ments qu'il contient est d√©termin√© par q_klaster; <br>  identifier_centers () - une m√©thode pour s√©lectionner al√©atoirement les centres initiaux parmi les pixels d'entr√©e; <br>  compute () et compute_s () sont des m√©thodes int√©gr√©es pour calculer la distance entre les pixels et les centres de recalcul, respectivement; <br>  trois constructeurs: le premier par d√©faut, le second pour initialiser les pixels du tableau, le troisi√®me pour initialiser les pixels d'un fichier texte (dans mon impl√©mentation, le fichier est d'abord accidentellement rempli de donn√©es, puis les pixels sont lus √† partir de ce fichier pour que le programme fonctionne, pourquoi pas directement dans le vecteur - juste n√©cessaire dans mon cas); <br>  clustering (std :: ostream &amp; os) - m√©thode de clustering; <br>  m√©thode et surcharge de l'instruction de sortie pour publier les r√©sultats. <br><br>  Impl√©mentation de la m√©thode: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::identify_centers() { srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)); rgb temp; rgb *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> rgb[q_klaster]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { temp = pixcel[<span class="hljs-number"><span class="hljs-number">0</span></span> + rand() % k_pixcel]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i; j &lt; q_klaster; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp.r != mas[j].r &amp;&amp; temp.g != mas[j].g &amp;&amp; temp.b != mas[j].b) { mas[j] = temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { centr.push_back(mas[i]); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> []mas; }</code> </pre><br>  Il s'agit d'une m√©thode pour s√©lectionner les centres de regroupement initiaux et les ajouter au vecteur central.  Une v√©rification est effectu√©e pour r√©p√©ter les centres et les remplacer dans ces cas. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb * mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { pixcel.push_back(*(mas + i)); } q_klaster = n_klaster; k_pixcel = n; identify_centers(); }</code> </pre><br>  Une impl√©mentation de constructeur pour initialiser des pixels √† partir d'un tableau. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os) : q_klaster(n_klaster) { rgb temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (os &gt;&gt; temp.r &amp;&amp; os &gt;&gt; temp.g &amp;&amp; os &gt;&gt; temp.b) { pixcel.push_back(temp); } k_pixcel = pixcel.size(); identify_centers(); }</code> </pre><br>  Nous passons un objet d'entr√©e √† ce constructeur pour pouvoir entrer des donn√©es √† la fois du fichier et de la console. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::clustering(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n :"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*             :        ,    -  ,    ,   ,        .*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_1(k_pixcel, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_2(k_pixcel, <span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n----------------  ‚Ññ"</span></span> &lt;&lt; iter &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ----------------\n\n"</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*  :          .      ,   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[j], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*     m_k      .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"    #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"  #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>; centr[m_k].r = compute_s(pixcel[j].r, centr[m_k].r); centr[m_k].g = compute_s(pixcel[j].g, centr[m_k].g); centr[m_k].b = compute_s(pixcel[j].b, centr[m_k].b); os &lt;&lt; centr[m_k].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mas; } <span class="hljs-comment"><span class="hljs-comment">/*   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *mass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[k_pixcel]; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n  : "</span></span>&lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; k_pixcel; k++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[k], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   ‚Ññ"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*  .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } mass[k] = m_k; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ‚Ññ"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"     #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*            .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n    : \n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k_pixcel; i++) { os &lt;&lt; mass[i] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; check_1[i] = *(mass + i); } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itr = KK + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mass[j] == i) { os &lt;&lt; pixcel[j].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; mass[j] = ++itr; } } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mass; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : \n"</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">/*         ‚Äì  .*/</span></span> iter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_1 == check_2 || iter &gt;= max_iterations) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } check_2 = check_1; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n ."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre>  La principale m√©thode de clustering. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.k_pixcel; i++) { os &lt;&lt; k.pixcel[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - ‚Ññ"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.q_klaster; i++) { os &lt;&lt; k.centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n : "</span></span> &lt;&lt; k.q_klaster &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; k.k_pixcel &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os; }</code> </pre><br>  La sortie des donn√©es initiales. <br><br><h4>  Exemple de sortie </h4><br><div class="spoiler">  <b class="spoiler_title">Exemple de sortie</b> <div class="spoiler_text">  <em>Pixels de d√©part:</em> <em><br></em>  <em>255 140 50 - n ¬∞ 0</em> <em><br></em>  <em>100 70 1 - n ¬∞ 1</em> <em><br></em>  <em>150 20 200 - n ¬∞ 2</em> <em><br></em>  <em>251 141 51 - n ¬∞ 3</em> <em><br></em>  <em>104 69 3 - n ¬∞ 4</em> <em><br></em>  <em>153 22 210 - n ¬∞ 5</em> <em><br></em>  <em>252 138 54 - n ¬∞ 6</em> <em><br></em>  <em>101 74 4 - n ¬∞ 7</em> <em><br><br></em>  <em>Centres de regroupement initial al√©atoires:</em> <em><br></em>  <em>150 20 200 - # 0</em> <em><br></em>  <em>104 69 3 - # 1</em> <em><br></em>  <em>100 70 1 - # 2</em> <em><br><br></em>  <em>Nombre de grappes: 3</em> <em><br></em>  <em>Nombre de pixels: 8</em> <em><br><br></em>  <em>D√©but du cluster:</em> <em><br><br></em>  <em>Num√©ro d'it√©ration 0</em> <em><br><br></em>  <em>Distance entre le pixel 0 et le centre # 0: 218.918</em> <em><br></em>  <em>Distance entre le pixel 0 et le centre # 1: 173,352</em> <em><br></em>  <em>Distance entre le pixel 0 et le centre # 2: 176,992</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Recalculer le centre n ¬∞ 1: 179,5 104,5 26,5</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 0: 211.189</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 1: 90,3369</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 2: 0</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Recalculer le centre # 2: 100 70 1</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 0: 0</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 1: 195.225</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 2: 211.189</em> <em><br></em>  <em>Distance centrale minimale # 0</em> <em><br></em>  <em>Compter le centre # 0: 150 20 200</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 0: 216.894</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 1: 83,933</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 2: 174,19</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Compter le centre # 1: 215,25 122,75 38,75</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 0: 208.149</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 1: 128,622</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 2: 4,58258</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Compter le centre # 2: 102 69,5 2</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 0: 10.6301</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 1: 208,212</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 2: 219,366</em> <em><br></em>  <em>Distance centrale minimale # 0</em> <em><br></em>  <em>Recalculer le centre # 0: 151,5 21 205</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 0: 215.848</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 1: 42.6109</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 2: 172.905</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Recalculer le centre n ¬∞ 1: 233,625 130,375 46,375</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 0: 213.916</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 1: 150,21</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 2: 5.02494</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Recalculer le centre n ¬∞ 2: 101,5 71,75 3</em> <em><br><br></em>  <em>Classons les pixels:</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 0 et le centre # 0: 221.129</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 0 et le centre n ¬∞ 1: 23,7207</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 0 et le centre n ¬∞ 2: 174,44</em> <em><br></em>  <em>Pixel # 0 le plus proche du centre # 1</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 1 et le centre # 0: 216.031</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 1 et le centre n ¬∞ 1: 153,492</em> <em><br></em>  <em>La distance du pixel n ¬∞ 1 au centre n ¬∞ 2: 3.05164</em> <em><br></em>  <em>Pixel # 1 le plus proche du centre # 2</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 2 et le centre # 0: 5.31507</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 2 et le centre n ¬∞ 1: 206,825</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 2 et le centre n ¬∞ 2: 209,378</em> <em><br></em>  <em>Pixel # 2 le plus proche du centre # 0</em> <em><br></em>  <em>La distance entre le pixel num√©ro 3 et le centre # 0: 219.126</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 3 et le centre n ¬∞ 1: 20,8847</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 3 et le centre n ¬∞ 2: 171,609</em> <em><br></em>  <em>Pixel # 3 le plus proche du centre # 1</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 4 et le centre # 0: 212,989</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 4 et le centre n ¬∞ 1: 149,836</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 4 et le centre n ¬∞ 2: 3,71652</em> <em><br></em>  <em>Pixel # 4 le plus proche du centre # 2</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 5 et le centre # 0: 5.31507</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 5 et le centre # 1: 212.176</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 5 et le centre n ¬∞ 2: 219.035</em> <em><br></em>  <em>Pixel # 5 le plus proche du centre # 0</em> <em><br></em>  <em>La distance entre le pixel num√©ro 6 et le centre # 0: 215.848</em> <em><br></em>  <em>La distance du pixel n ¬∞ 6 au centre # 1: 21.3054</em> <em><br></em>  <em>La distance du pixel num√©ro 6 au centre # 2: 172.164</em> <em><br></em>  <em>Pixel # 6 le plus proche du centre # 1</em> <em><br></em>  <em>La distance du pixel n ¬∞ 7 au centre # 0: 213.916</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 7 et le centre n ¬∞ 1: 150,21</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 7 et le centre n ¬∞ 2: 2,51247</em> <em><br></em>  <em>Pixel # 7 le plus proche du centre # 2</em> <em><br><br></em>  <em>Un tableau de pixels et de centres correspondants:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>R√©sultat du clustering:</em> <em><br></em>  <em>Groupe # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Groupe # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Groupe # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Nouveaux centres:</em> <em><br></em>  <em>151,5 21 205 - # 0</em> <em><br></em>  <em>233,625 130,375 46,375 - # 1</em> <em><br></em>  <em>101,5 71,75 3 - # 2</em> <em><br><br></em>  <em>Num√©ro d'it√©ration 1</em> <em><br><br></em>  <em>Distance entre le pixel 0 et le centre # 0: 221.129</em> <em><br></em>  <em>Distance entre le pixel 0 et le centre # 1: 23.7207</em> <em><br></em>  <em>Distance entre le pixel 0 et le centre # 2: 174,44</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Compter le centre # 1: 244.313 135.188 48.1875</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 0: 216.031</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 1: 165.234</em> <em><br></em>  <em>Distance entre le pixel 1 et le centre # 2: 3.05164</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Recalculer le centre n ¬∞ 2: 100,75 70,875 2</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 0: 5.31507</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 1: 212,627</em> <em><br></em>  <em>Distance entre le pixel 2 et le centre # 2: 210,28</em> <em><br></em>  <em>Distance centrale minimale # 0</em> <em><br></em>  <em>Recalculer le centre # 0: 150,75 20,5 202,5</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 0: 217.997</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 1: 9.29613</em> <em><br></em>  <em>Distance entre le pixel 3 et le centre # 2: 172.898</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Compter le centre # 1: 247.656 138.094 49.5938</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 0: 210.566</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 1: 166.078</em> <em><br></em>  <em>Distance entre le pixel 4 et le centre # 2: 3.88306</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Comptage du centre n ¬∞ 2: 102,375 69,9375 2,5</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 0: 7.97261</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 1: 219.471</em> <em><br></em>  <em>Distance entre le pixel 5 et le centre # 2: 218,9</em> <em><br></em>  <em>Distance centrale minimale # 0</em> <em><br></em>  <em>Compter le centre # 0: 151.875 21.25 206.25</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 0: 216.415</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 1: 6.18805</em> <em><br></em>  <em>Distance entre le pixel 6 et le centre # 2: 172.257</em> <em><br></em>  <em>Distance centrale minimale # 1</em> <em><br></em>  <em>Recalculer le centre # 1: 249.828 138.047 51.7969</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 0: 215.118</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 1: 168,927</em> <em><br></em>  <em>Distance entre le pixel 7 et le centre # 2: 4,54363</em> <em><br></em>  <em>Distance centrale minimale # 2</em> <em><br></em>  <em>Recalculer le centre n ¬∞ 2: 101,688 71,9688 3,25</em> <em><br><br></em>  <em>Classons les pixels:</em> <em><br></em>  <em>La distance du pixel n ¬∞ 0 au centre # 0: 221.699</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 0 et le centre # 1: 5.81307</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 0 et le centre n ¬∞ 2: 174,122</em> <em><br></em>  <em>Pixel # 0 le plus proche du centre # 1</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 1 et le centre # 0: 217.244</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 1 et le centre n ¬∞ 1: 172,218</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 1 et le centre n ¬∞ 2: 3,43309</em> <em><br></em>  <em>Pixel # 1 le plus proche du centre # 2</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 2 et le centre # 0: 6,64384</em> <em><br></em>  <em>La distance du pixel n ¬∞ 2 au centre # 1: 214.161</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 2 et le centre n ¬∞ 2: 209,154</em> <em><br></em>  <em>Pixel # 2 le plus proche du centre # 0</em> <em><br></em>  <em>La distance du pixel n ¬∞ 3 au centre # 0: 219.701</em> <em><br></em>  <em>Distance entre le pixel # 3 et le centre # 1: 3,27555</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 3 et le centre n ¬∞ 2: 171,288</em> <em><br></em>  <em>Pixel # 3 le plus proche du centre # 1</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 4 et le centre # 0: 214.202</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 4 et le centre n ¬∞ 1: 168,566</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 4 et le centre n ¬∞ 2: 3,777142</em> <em><br></em>  <em>Pixel # 4 le plus proche du centre # 2</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 5 et le centre # 0: 3,9863</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 5 et le centre n ¬∞ 1: 218,794</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 5 et le centre n ¬∞ 2: 218.805</em> <em><br></em>  <em>Pixel # 5 le plus proche du centre # 0</em> <em><br></em>  <em>La distance entre le pixel num√©ro 6 et le centre # 0: 216.415</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 6 et le centre # 1: 3.09403</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 6 et le centre n ¬∞ 2: 171,842</em> <em><br></em>  <em>Pixel # 6 le plus proche du centre # 1</em> <em><br></em>  <em>La distance du pixel n ¬∞ 7 au centre # 0: 215.118</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 7 et le centre n ¬∞ 1: 168,927</em> <em><br></em>  <em>La distance entre le pixel n ¬∞ 7 et le centre n ¬∞ 2: 2,27181</em> <em><br></em>  <em>Pixel # 7 le plus proche du centre # 2</em> <em><br><br></em>  <em>Un tableau de pixels et de centres correspondants:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>R√©sultat du clustering:</em> <em><br></em>  <em>Groupe # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Groupe # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Groupe # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Nouveaux centres:</em> <em><br></em>  <em>151,875 21,25 206,25 - # 0</em> <em><br></em>  <em>249.828 138.047 51.7969 - # 1</em> <em><br></em>  <em>101,688 71,9688 3,25 - # 2</em> <em><br><br></em>  <em>La fin du clustering.</em> <br></div></div><br>  Cet exemple est pr√©vu √† l'avance, les pixels sont s√©lectionn√©s sp√©cifiquement pour la d√©monstration.  Deux it√©rations suffisent pour que le programme regroupe les donn√©es en trois clusters.  En regardant les centres des deux derni√®res it√©rations, vous pouvez voir qu'ils sont pratiquement rest√©s en place. <br><br>  Plus int√©ressants sont les cas de pixels g√©n√©r√©s al√©atoirement.  Ayant g√©n√©r√© 50 points qui doivent √™tre divis√©s en 10 grappes, j'ai obtenu 5 it√©rations.  Ayant g√©n√©r√© 50 points qui doivent √™tre divis√©s en 3 clusters, j'ai obtenu les 100 it√©rations maximales autoris√©es.  Vous pouvez remarquer que plus il y a de clusters, plus il est facile pour le programme de trouver les pixels les plus similaires et de les combiner en petits groupes, et vice versa - s'il y a peu de clusters et qu'il y a beaucoup de points, l'algorithme se termine souvent uniquement lorsque le nombre maximum d'it√©rations est d√©pass√©, car certains pixels sautent constamment d'un cluster √† l'autre.  Cependant, la majeure partie est encore compl√®tement d√©termin√©e dans leurs grappes. <br><br>  Eh bien, v√©rifions maintenant le r√©sultat du clustering.  En prenant le r√©sultat de certains clusters de l'exemple de 50 points pour 10 clusters, j'ai conduit le r√©sultat de ces donn√©es dans Illustrator et c'est ce qui s'est pass√©: <br><br><img src="https://habrastorage.org/webt/b2/fl/me/b2flmelfv6bqxeautb8s4ywwstm.jpeg"><br><br>  On peut voir que dans chaque groupe, toutes les nuances de couleur pr√©valent, et ici vous devez comprendre que les pixels ont √©t√© s√©lectionn√©s au hasard, l'analogue d'une telle image dans la vie r√©elle est une sorte d'image sur laquelle toutes les couleurs ont √©t√© accidentellement pulv√©ris√©es et il est difficile de s√©lectionner des zones de couleurs similaires. <br><br>  Disons que nous avons une telle photo.  Nous pouvons d√©finir une √Æle comme un seul cluster, mais avec une augmentation, nous voyons qu'elle se compose de diff√©rentes nuances de vert. <br><br><img src="https://habrastorage.org/webt/s8/qv/um/s8qvumchfqerkbdfo5gx7ijm4to.jpeg"><br><br>  Et c'est le cluster 8, mais dans une version plus petite, le r√©sultat est similaire: <br><br><img src="https://habrastorage.org/webt/dt/ia/eb/dtiaebsnf1uzpi69jqmbkvui5uo.jpeg"><br><br>  La version compl√®te du programme peut √™tre consult√©e sur mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427761/">https://habr.com/ru/post/fr427761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427749/index.html">Apple et Samsung pour la premi√®re fois condamn√©s √† une amende pour avoir ralenti de vieux t√©l√©phones</a></li>
<li><a href="../fr427751/index.html">CudaText Sublime Ideas</a></li>
<li><a href="../fr427755/index.html">Nouvelle version de GitLab 11.4 avec examen par les pairs des demandes de fusion et des indicateurs de fonctionnalit√©</a></li>
<li><a href="../fr427757/index.html">Portes arri√®re de microcode assembl√©es par processeur X86</a></li>
<li><a href="../fr427759/index.html">A propos de la solvabilit√© des probl√®mes de ceinture de circulation en temps polynomial</a></li>
<li><a href="../fr427763/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 13: Protocoles r√©seau, partie 1</a></li>
<li><a href="../fr427767/index.html">Situation: au Canada, ils ont propos√© d'introduire une taxe sur le streaming - nous discutons du probl√®me</a></li>
<li><a href="../fr427771/index.html">Cours MIT "S√©curit√© des syst√®mes informatiques". Conf√©rence 13: Network Protocols, Part 2</a></li>
<li><a href="../fr427773/index.html">J'ai √©crit une extension multi-navigateur pour les onglets, mais vous ne le faites pas</a></li>
<li><a href="../fr427775/index.html">Un bot d√©guis√© en programmeur corrige les erreurs de code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>