<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕍 🤾🏾 🍖 Mengapa fisikawan masih menggunakan Fortran 👩‍❤️‍👩 👍 👨🏾‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya tidak tahu seperti apa bahasa pemrograman pada tahun 2000, tetapi saya tahu itu akan disebut FORTRAN. 
 - Charles Anthony Richard Hoar, kira-kira...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa fisikawan masih menggunakan Fortran</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/400523/"><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak tahu seperti apa bahasa pemrograman pada tahun 2000, tetapi saya tahu itu akan disebut FORTRAN. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - Charles Anthony Richard Hoar, kira-kira. </font><font style="vertical-align: inherit;">1982</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam industri ini, Fortran jarang digunakan saat ini - di salah satu daftar bahasa populer, ia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berada di posisi ke-28</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tetapi Fortran masih merupakan bahasa utama untuk simulasi sistem fisik skala besar - yaitu, untuk hal-hal seperti pemodelan astrofisika bintang dan galaksi (mis. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), dinamika molekul skala besar, kode penghitungan struktur elektronik ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIESTA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), model iklim, dll. Di bidang komputasi kinerja tinggi, subset yang merupakan simulasi numerik skala besar, saat ini hanya dua bahasa yang digunakan - C / C ++ dan "modern Fortran" (Fortran 90/95/03/08). Perpustakaan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">MPI Terbuka</font></a><font style="vertical-align: inherit;"> Populer</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alat paralelisasi kode telah dikembangkan untuk kedua bahasa ini. Secara umum, jika Anda memerlukan kode cepat yang berjalan pada banyak prosesor, Anda hanya memiliki dua opsi. Di Fortran modern ada fitur seperti " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coarray</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", yang memungkinkan bekerja secara langsung dengan bahasa dalam pemrograman paralel. Coarray muncul dalam ekstensi Fortran 95 dan kemudian dimasukkan ke dalam Fortran 2008. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penggunaan aktif Fortran oleh fisikawan sering membingungkan ilmuwan komputer dan orang lain yang tidak terkait dengan daerah ini yang menganggap Fortran adalah anakronisme sejarah.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya ingin menjelaskan mengapa Fortran masih berguna. Saya tidak mendorong siswa belajar fisika untuk mengajar Fortran - karena kebanyakan dari mereka akan melakukan penelitian, mereka harus belajar C / C ++ (atau berhenti di Matlab / Octave / Python). Saya ingin menjelaskan mengapa Fortran masih digunakan, dan untuk membuktikan bahwa ini bukan hanya karena fisikawan “ketinggalan zaman” (walaupun terkadang demikian - tahun lalu saya melihat seorang siswa fisika yang bekerja dengan kode Fortran 77, sementara dia maupun manajernya tidak mendengar apa pun tentang Fortran 90). Ilmuwan komputer harus melihat dominasi Fortran dalam komputasi numerik sebagai tantangan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum menggali topik, saya ingin membahas ceritanya, karena ketika orang mendengar kata "Fortran", mereka langsung membayangkan kartu punch dan kode dengan garis bernomor. Spesifikasi Fortran pertama ditulis pada tahun 1954. Fortran awal (kemudian namanya ditulis dengan huruf kapital, FORTRAN), menurut standar modern, adalah bahasa neraka, tetapi itu adalah langkah maju yang luar biasa dari pemrograman assembler sebelumnya. FORTRAN sering diprogram dengan kartu punch, seperti yang diingat Profesor Miriam Forman dari Stony Brook University tanpa kesenangan. Fortran memiliki banyak versi, yang paling terkenal adalah standar 66, 77, 90, 95, 03, dan 08. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sering dikatakan bahwa Fortran masih digunakan karena kecepatannya. Tapi apakah dia yang tercepat? Di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benchmarksgame.alioth.debian.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perbandingan C dan Fortran</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam beberapa tes di antara banyak bahasa. </font><font style="vertical-align: inherit;">Dalam kebanyakan kasus, Fortran dan C / C ++ adalah yang tercepat. </font><font style="vertical-align: inherit;">Pemrogram Python favorit sering tertinggal dalam kecepatan 100 kali, tetapi ini sesuai urutan untuk kode yang ditafsirkan. </font><font style="vertical-align: inherit;">Python tidak cocok untuk perhitungan numerik yang kompleks, tetapi cocok untuk yang lain. </font><font style="vertical-align: inherit;">Menariknya, C / C ++ mengungguli Fortran di semua kecuali dua tes, meskipun secara umum hasilnya sedikit berbeda. </font><font style="vertical-align: inherit;">Tes di mana Fortran menang, yang paling "fisik" adalah simulasi sistem n tubuh dan perhitungan spektrum. </font><font style="vertical-align: inherit;">Hasil tergantung pada jumlah core prosesor, misalnya, Fortran tertinggal C / C ++ pada quad core. </font><font style="vertical-align: inherit;">Tes, di mana Fortran tertinggal jauh di belakang C / C ++, membaca dan menulis data sebagian besar waktu, dan dalam hal ini kelambatan Fortran dikenal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi C / C ++ secepat Fortran, dan terkadang sedikit lebih cepat. </font><font style="vertical-align: inherit;">Kami tertarik pada, "mengapa profesor fisika terus menyarankan siswa mereka untuk menggunakan Fortran, bukan C / C ++?"</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortran memiliki kode warisan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berkat sejarah panjang Fortran, tidak mengherankan bahwa gunung kode fisika tertulis di sana. </font><font style="vertical-align: inherit;">Fisikawan berusaha meminimalkan waktu pemrograman, jadi jika mereka menemukan kode sebelumnya, mereka akan menggunakannya. </font><font style="vertical-align: inherit;">Bahkan jika kode lama tidak dapat dibaca, didokumentasikan dengan buruk, dan bukan yang paling efisien, lebih mungkin menggunakan kode yang sudah terbukti lama daripada menulis yang baru. </font><font style="vertical-align: inherit;">Tugas fisikawan bukanlah menulis kode, mereka mencoba memahami sifat realitas. </font><font style="vertical-align: inherit;">Para profesor selalu memiliki kode warisan di tangan (sering mereka menulis kode ini beberapa dekade yang lalu), dan mereka meneruskannya kepada siswa mereka. </font><font style="vertical-align: inherit;">Ini menghemat waktu mereka dan menghilangkan ketidakpastian dari proses koreksi kesalahan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siswa Fisika Belajar Fortran Lebih Mudah Daripada C / C ++</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya pikir Fortran lebih mudah dipelajari daripada C / C ++. Fortran 90 dan C sangat mirip, tetapi Fortran lebih mudah untuk ditulis. C adalah bahasa yang relatif primitif, sehingga fisikawan yang memilih C / C ++ terlibat dalam pemrograman berorientasi objek. OOP bisa bermanfaat, terutama dalam proyek perangkat lunak besar, tetapi pelajarilah lebih lama. Anda perlu mempelajari abstraksi seperti kelas dan pewarisan. Paradigma OOP sangat berbeda dengan paradigma prosedural yang digunakan oleh Fortran. Fortran didasarkan pada paradigma prosedural sederhana yang lebih dekat dengan apa yang terjadi di bawah tudung komputer. Ketika Anda mengoptimalkan / membuat vektor kode untuk meningkatkan kecepatan, paradigma prosedural lebih mudah digunakan. Fisikawan biasanya memahami cara kerja komputer, dan berpikir dalam hal proses fisik, misalnya, mentransfer data dari disk ke RAM, dan dari RAM ke cache prosesor.Mereka berbeda dari ahli matematika yang lebih suka berpikir dalam hal fungsi dan logika abstrak. Juga, pemikiran ini berbeda dari berorientasi objek. Optimalisasi kode OOP lebih rumit dari sudut pandang saya daripada prosedural. Objek adalah struktur yang sangat besar dibandingkan dengan struktur data yang disukai oleh fisikawan: array.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lightness One: Pekerjaan Fortran Array</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Array, atau, sebagaimana fisikawan menyebutnya, matriks, adalah jantung dari semua komputasi fisik. </font><font style="vertical-align: inherit;">Di Fortran 90+, Anda dapat menemukan banyak peluang untuk bekerja dengannya, mirip dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan Matlab / Oktaf. </font><font style="vertical-align: inherit;">Array dapat disalin, dikalikan dengan skalar, dikalikan di antara mereka dengan cara yang sangat intuitif:</font></font><br>
 <br>
<pre><code class="hljs lisp">A = B<font></font>
A = <span class="hljs-number"><span class="hljs-number">3.24</span></span>*B<font></font>
C = A*B<font></font>
B = exp(<span class="hljs-name"><span class="hljs-name">A</span></span>)<font></font>
norm = sqrt(<span class="hljs-name"><span class="hljs-name">sum</span></span>(<span class="hljs-name"><span class="hljs-name">A**2</span></span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, A, B, C adalah array dari beberapa dimensi (katakanlah, 10x10x10). C = A * B memberi kita perkalian matriks secara elemen jika A dan B memiliki ukuran yang sama. Untuk perkalian matriks, C = matmul (A, B) digunakan. Hampir semua fungsi internal Fortran (Sin (), Exp (), Abs (), Floor (), dll) mengambil array sebagai argumen, yang mengarah pada kode sederhana dan bersih. Tidak ada kode serupa di C / C ++. Dalam implementasi C / C ++ dasar, hanya menyalin array memerlukan berjalan untuk loop di semua elemen atau memanggil fungsi perpustakaan. Jika Anda memberi makan array fungsi pustaka yang salah di C, kesalahan akan terjadi. Kebutuhan untuk menggunakan perpustakaan alih-alih fungsi internal berarti bahwa kode yang dihasilkan tidak akan bersih dan portabel, atau mudah dipelajari.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Fortran, mengakses elemen array bekerja melalui sintaksis sederhana A [x, y, z], ketika di C / C ++ Anda perlu menulis A [x] [y] [z]. </font><font style="vertical-align: inherit;">Elemen array dimulai dengan 1, yang sesuai dengan pemahaman fisikawan tentang matriks, dan dalam array C / C ++, penomoran dimulai dari nol. </font><font style="vertical-align: inherit;">Berikut adalah beberapa fitur untuk bekerja dengan array di Fortran.</font></font><br>
 <br>
<pre><code class="hljs lisp">A = (<span class="hljs-name"><span class="hljs-name">/</span></span> i , i = <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> /)<font></font>
B = A(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>)<font></font>
C(<span class="hljs-number"><span class="hljs-number">10</span></span>:) = B</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, vektor A dibuat melalui loop tersirat tersirat, juga dikenal sebagai konstruktor array. </font><font style="vertical-align: inherit;">Kemudian vektor B dibuat, terdiri dari setiap elemen ke-10 A, menggunakan langkah 10. Dan, akhirnya, array B disalin ke array C, mulai dari elemen ke-10. </font><font style="vertical-align: inherit;">Fortran mendukung mendeklarasikan array dengan indeks nol atau negatif:</font></font><br>
 <br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, dimension(<span class="hljs-number"><span class="hljs-number">-1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) :: myArray</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indeks negatif pada awalnya terlihat konyol, tetapi saya mendengar tentang kegunaannya - misalnya, bayangkan ini adalah area tambahan untuk memposting klarifikasi. </font><font style="vertical-align: inherit;">Fortran juga mendukung </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indeks vektor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Misalnya, Anda dapat mentransfer elemen 1,5 dan 7 dari larik A dimensi N x 1 ke larik B dimensi 3 x 1:</font></font><br>
 <br>
<pre><code class="hljs lisp">subscripts = (<span class="hljs-name"><span class="hljs-name">/</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> /)<font></font>
B = A(<span class="hljs-name"><span class="hljs-name">subscripts</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran mendukung </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array di semua fungsi internal. </font><font style="vertical-align: inherit;">Misalnya, jika kita perlu menghitung logaritma semua elemen matriks yang lebih besar dari nol, kita menggunakan:</font></font><br>
 <br>
<pre><code class="hljs lisp">log_of_A = log(<span class="hljs-name"><span class="hljs-name">A</span></span>, mask= A .gt. <span class="hljs-number"><span class="hljs-number">0</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atau kita dapat membatalkan semua elemen negatif dari array dalam satu baris:</font></font><br>
 <br>
<pre><code class="hljs lisp">where(<span class="hljs-name"><span class="hljs-name">my_array</span></span> .lt. <span class="hljs-number"><span class="hljs-number">0.0</span></span>) my_array = <span class="hljs-number"><span class="hljs-number">0.0</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran membuatnya mudah untuk secara dinamis mengalokasikan dan membebaskan array. </font><font style="vertical-align: inherit;">Misalnya, untuk menempatkan array dua dimensi:</font></font><br>
 <br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">real</span></span>, dimension(:,:), allocatable :: name_of_array<font></font>
allocate(name_of_array(xdim, ydim))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam C / C ++, ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan entri berikut</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
 <br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>;
<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(nrows * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *));<font></font>
 <font></font>
<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){
     <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(ncolumns * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk membebaskan array di Fortran</font></font><br>
 <br>
<pre><code class="hljs lisp">deallocate(<span class="hljs-name"><span class="hljs-name">name_of_array</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam C / C ++ untuk ini</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){
    <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i]);<font></font>
}<font></font>
<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>);</code></pre><br>
<h2> :        </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam bahasa seperti C / C ++, semua variabel dilewatkan oleh nilai, dengan pengecualian array yang dilewatkan oleh referensi. Tetapi dalam banyak kasus, melewatkan array dengan nilai lebih masuk akal. Sebagai contoh, biarkan data terdiri dari posisi 100 molekul pada periode waktu yang berbeda. Kita perlu menganalisis pergerakan satu molekul. Kami mengambil sepotong array (subarray) yang sesuai dengan koordinat atom dalam molekul ini dan meneruskannya ke fungsi. Di dalamnya, kita akan berurusan dengan analisis kompleks dari subarray yang ditransmisikan. Jika kami melewatinya dengan referensi, data yang ditransfer tidak akan terletak di memori dalam satu baris. Karena sifat akses memori, bekerja dengan array seperti itu akan lambat. Jika kita berikan nilai, kita akan membuat array baru di memori yang disusun secara berurutan. Untuk menyenangkan fisikawan, kompiler mengambil semua pekerjaan kotor mengoptimalkan memori.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam Fortran, variabel biasanya dilewatkan dengan referensi, bukan oleh nilai. </font><font style="vertical-align: inherit;">Di bawah kap, kompiler Fortran secara otomatis mengoptimalkan transmisi mereka untuk meningkatkan efisiensi. </font><font style="vertical-align: inherit;">Dari sudut pandang profesor di bidang mengoptimalkan penggunaan memori, kompiler harus lebih dipercaya daripada siswa! </font><font style="vertical-align: inherit;">Akibatnya, fisikawan jarang menggunakan pointer, meskipun Fortran-90 + </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mereka memiliki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa contoh lagi perbedaan antara Fortran dan C</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran memiliki beberapa opsi untuk mengelola kompiler saat mengatasi masalah dan mengoptimalkan. </font><font style="vertical-align: inherit;">Kesalahan dalam kode dapat ditangkap pada tahap kompilasi, dan tidak selama eksekusi. </font><font style="vertical-align: inherit;">Misalnya, variabel apa pun dapat dideklarasikan sebagai parameter, yaitu konstanta.</font></font><br>
<br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, parameter :: hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika parameter dalam kode berubah, kompiler mengembalikan kesalahan. </font><font style="vertical-align: inherit;">Dalam C ini disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const</font></font></a><br>
<br>
<pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah bahwa real nyata berbeda dari real nyata. Jika suatu fungsi yang menerima nyata mendapat nyata, itu akan mengembalikan kesalahan. Sangat mudah untuk membayangkan bagaimana ini dapat menyebabkan masalah interoperabilitas dalam kode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran juga memiliki spesifikasi maksud yang memberi tahu kompiler apakah argumen yang dilewatkan ke fungsi adalah input, output, atau input dan parameter output. Ini membantu kompiler mengoptimalkan kode dan meningkatkan keterbacaan dan keandalannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran memiliki fitur lain yang digunakan pada frekuensi yang berbeda. </font><font style="vertical-align: inherit;">Misalnya, Fortran 95 memiliki kemampuan untuk mendeklarasikan fungsi dengan pengubah murni. </font><font style="vertical-align: inherit;">Fungsi seperti itu tidak memiliki efek samping - hanya mengubah argumennya, dan tidak mengubah variabel global. </font><font style="vertical-align: inherit;">Kasus khusus dari fungsi tersebut adalah fungsi elemen, yang menerima dan mengembalikan skalar. </font><font style="vertical-align: inherit;">Ini digunakan untuk memproses elemen array. </font><font style="vertical-align: inherit;">Informasi yang fungsinya murni atau unsur memungkinkan kompiler untuk melakukan optimasi tambahan, terutama ketika memparalelkan kode.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang diharapkan di masa depan?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam perhitungan ilmiah, Fortran tetap menjadi bahasa utama, dan tidak akan hilang dalam waktu dekat. </font><font style="vertical-align: inherit;">Dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">survei</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di antara pengunjung konferensi Konvensi Supercomputing 2014 menggunakan bahasa ini, 100% dari mereka mengatakan mereka akan menggunakannya dalam 5 tahun ke depan. Itu juga mengikuti dari survei bahwa 90% menggunakan campuran Fortran dan C. Mengantisipasi peningkatan dalam pencampuran bahasa-bahasa ini, pencipta spesifikasi Fortran 2015 mencakup lebih banyak fitur untuk interoperabilitas kode. Kode Fortran semakin banyak dipanggil dari kode Python. Ilmuwan komputer yang mengkritik penggunaan Fortran tidak mengerti bahwa bahasa ini tetap diadaptasi secara unik untuk apa yang dinamai setelah - TRAN inflasi, terjemahan rumus, yaitu, konversi formula fisik menjadi kode. Banyak dari mereka tidak menyadari bahwa bahasa tersebut berkembang dan secara konstan menyertakan fitur-fitur baru.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memanggil Fortran 90+ modern lama seperti memanggil C ++ lama karena C dikembangkan pada tahun 1973. Di sisi lain, bahkan standar Fortran 2008 terbaru memiliki kompatibilitas dengan Fortran 77 dan sebagian besar dari Fortran 66. Karena itu, perkembangan bahasa dikaitkan dengan kesulitan tertentu. </font><font style="vertical-align: inherit;">Baru-baru ini, peneliti di MIT memutuskan untuk mengatasi kesulitan ini dengan mengembangkan dari awal bahasa untuk HPC bernama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Julia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pertama kali dirilis pada 2012. </font><font style="vertical-align: inherit;">Apakah Julia menggantikan Fortran masih harus dilihat. </font><font style="vertical-align: inherit;">Bagaimanapun, saya menduga ini akan memakan waktu yang sangat lama.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id400523/">https://habr.com/ru/post/id400523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id400511/index.html">Tentang metode modern untuk menyimpan bahan bakar nuklir bekas</a></li>
<li><a href="../id400513/index.html">Teorema ketidaklengkapan Gödel dalam 20 menit</a></li>
<li><a href="../id400515/index.html">Blockchainer: manfaat blockchain bagi mereka yang tidak cocok untuk cryptocurrency</a></li>
<li><a href="../id400519/index.html">3D-Mulai printer 3D modular sebagai sumber yang menarik bagi kucing 3D</a></li>
<li><a href="../id400521/index.html">Apple memperbaiki bug dan menuduh Consumer Reports metodologi pengujian yang salah</a></li>
<li><a href="../id400525/index.html">Pengembangan sistem penghafalan angka mnemonik</a></li>
<li><a href="../id400527/index.html">Resampling II. Perbandingan pengoperasian filter tingkat tinggi digital dan analog di jalur suara dan jawaban atas pertanyaan</a></li>
<li><a href="../id400529/index.html">Peralatan ruang operasi untuk koreksi penglihatan</a></li>
<li><a href="../id400531/index.html">Комитет Госдумы одобрил законопроект о регулировании аудиовизуальных сервисов</a></li>
<li><a href="../id400533/index.html">Paradoks utama kesadaran. Mengapa menyalin otak atau kepribadian tidak masuk akal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>