<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏻 👰 🏴󠁧󠁢󠁷󠁬󠁳󠁿 Praktikum bei der Haxe Foundation 🚵🏿 🛸 👕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich präsentiere Ihnen die Übersetzung eines anderen Berichts von HaxeUp Sessions 2019 Linz . Ich glaube, dass er eine gute Ergänzung zum vorherigen is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Praktikum bei der Haxe Foundation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475226/"><p>  Ich präsentiere Ihnen die Übersetzung eines anderen Berichts von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HaxeUp Sessions 2019 Linz</a> . Ich glaube, dass er eine gute Ergänzung zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen ist</a> , weil  setzt das Thema der Änderungen in Haxe, die 2019 stattfanden, sowie ein kleines Gespräch über seine Zukunft fort. <br>  Ein wenig über den Autor des Berichts: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aurel Bili hat</a> sich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haxe getroffen</a> , der an verschiedenen Game Jams teilgenommen hat, und er nimmt weiterhin daran teil (zum Beispiel hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sein Spiel aus dem letzten Ludum Dare 45</a> ). </p><br><p><img src="https://habrastorage.org/webt/ad/lm/cg/adlmcgnsnfq_dtf9i0ouddgb1s4.png" alt="Bild"></p><a name="habracut"></a><br><p>  Aurel absolviert derzeit ein Studium am Imperial College London, das ein obligatorisches Praktikum vorsieht.  Das erste Praktikum, das er absolvierte, fand in einem abgelegenen Büro statt. Der Weg dorthin nahm viel Zeit in Anspruch.  Er hoffte daher, dass das nächste Training aus der Ferne durchgeführt werden könne. </p><br><p><img src="https://habrastorage.org/webt/ke/tq/ii/ketqiipd9nlnfto-m0aa9l9juoa.png" alt="Bild"></p><br><p>  So kam es, dass die Haxe Foundation lange Zeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keinen Mitarbeiter</a> für die Position des Compiler-Entwicklers finden konnte.  Aurel beschloss, sein Glück zu versuchen und sandte einen Brief mit der Bitte um Fernarbeit.  Er hatte Glück - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">er wurde für ein sechsmonatiges Praktikum</a> mit der Möglichkeit angenommen, von London aus zu arbeiten. </p><br><p><img src="https://habrastorage.org/webt/r7/ur/rp/r7urrpmlbvyzoqpz4funq_i7isq.png" alt="Bild"></p><br><p>  Bei der Einrichtung des Geräts wurde das Aufgabenspektrum vereinbart, mit dem Aurel beauftragt wird (obwohl nicht alles realisiert wurde). </p><br><p><img src="https://habrastorage.org/webt/nx/sp/ok/nxspokz8gogufn1xujawaocuvfg.png" alt="Bild"></p><br><p>  Was hat er gemacht </p><br><p>  Zunächst wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> , die sich in einem traurigen Zustand befand: Alle Änderungen in der Syntax, neue Funktionen der Sprache und des Compilers wurden beschrieben, Abschnitte über Strings, Literale und Konstanten wurden ergänzt. </p><br><p><img src="https://habrastorage.org/webt/5o/f8/0x/5of80xs7hqjc7br0o8wzdtvylfe.png" alt="Bild"></p><br><p>  Alle Dokumentationen wurden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von LaTeX nach Markdown übersetzt</a> ! </p><br><p><img src="https://habrastorage.org/webt/8h/8a/zi/8h8aziozlhimxivhbqe6eaen8nm.png" alt="Bild"></p><br><p>  Zweitens wurde die Formatierung des Standard-Bibliothekscodes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf einen einzigen Stil reduziert</a> (da verschiedene Personen mit unterschiedlichen Codestilen über 10 Jahre daran gearbeitet haben).  Somit belegte Aurel im Haxe-Compiler-Repository den siebten Platz in der Anzahl der hinzugefügten Codezeilen :) </p><br><p><img src="https://habrastorage.org/webt/_1/ue/dr/_1uedrmupcaktuprps7tozfstvc.png" alt="Bild"></p><br><p> Drittens arbeitete Aurel auch an der Standardbibliothek und am Compiler: <br>  Der <code>Map</code> Container verfügt beispielsweise über eine neue <code>clear()</code> -Methode, mit der alle gespeicherten Werte entfernt werden.  Dies wurde hauptsächlich durchgeführt, um die Arbeit mit Containern zu vereinfachen, die als <code>final</code> Variablen erstellt wurden (dh, ihnen kann kein neuer Wert zugewiesen, aber sie können geändert werden): </p><br><p><img src="https://habrastorage.org/webt/w4/im/py/w4impyixozfnotxgvysk9lmkg_g.png" alt="Bild"></p><br><p>  Für Objekte vom Typ <code>Date</code> wurden Methoden zum Arbeiten mit Datumsangaben im UTC-Format (Universal Universal Time) eingeführt.  Die Arbeit an ihnen hat gezeigt, wie schwierig es ist, eine einzige API zu implementieren, die auf allen 11 von Haxe unterstützten Sprachen / Plattformen gleichermaßen funktioniert. </p><br><p><img src="https://habrastorage.org/webt/sb/qy/xb/sbqyxbkfhn0u7okjsppcuvf4t8s.png" alt="Bild"></p><br><p>  Im alten Compiler wurden die Definitionen und Meta-Tags in OCaml definiert. Jetzt werden sie im JSON-Format beschrieben, wodurch das Parsen durch externe Dienstprogramme vereinfacht werden soll (z. B. um automatisch Dokumentation zu generieren): </p><br><p><img src="https://habrastorage.org/webt/ne/r4/eo/ner4eouacu_md7zihgqrz3uiqnm.png" alt="Bild"></p><br><p>  Möglicherweise stellen Sie auch fest, dass der Kompilierungsserver bei großen Projekten sehr viel Speicher belegt. </p><br><p><img src="https://habrastorage.org/webt/xq/q9/r_/xqq9r_cwnt_fzqrszdk5puijd64.png" alt="Bild"></p><br><p>  Um dieses Problem zu lösen, haben Simon Kraevsky und Aurel das Binärformat hxb entwickelt, mit dem der typisierte AST serialisiert wird.  Jetzt kann der Kompilierungsserver das Modul in den Arbeitsspeicher laden, damit arbeiten, bis es benötigt wird, und es dann aus dem Arbeitsspeicher in eine Datei im Format hxb entladen und den belegten Arbeitsspeicher freigeben. </p><br><p><img src="https://habrastorage.org/webt/4e/gm/9w/4egm9wqmkufwq98hkbav5h3sgqo.png" alt="Bild"></p><br><p>  Die hxb-Formatspezifikation ist <a href="">in einem separaten Repository</a> verfügbar, und ihre aktuelle Implementierung im Compiler (mit Serializer / Deserializer) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">liegt in einem separaten Haxe-Zweig</a> .  Die Arbeit an dieser Funktion ist noch nicht abgeschlossen und wird möglicherweise in Haxe 4.1 angezeigt. </p><br><p><img src="https://habrastorage.org/webt/fw/1k/cp/fw1kcp-bt-auctqpfstvjdjr_i0.png" alt="Bild"></p><br><p>  Der vierte und wichtigste Schwerpunkt der Arbeit von Aurel während des Praktikums war die Erstellung einer neuen asynchronen System-API - asys. </p><br><p><img src="https://habrastorage.org/webt/lk/vu/6k/lkvu6kx-jkyhsylbt-axraassom.png" alt="Bild"></p><br><p>  Die Notwendigkeit zu seiner Erstellung beruht auf der Tatsache, dass die vorhandene API keine einfachen Möglichkeiten zur asynchronen Ausführung von Systemoperationen bietet.  Um beispielsweise asynchron mit Dateien zu arbeiten, müssen Sie einen separaten Thread erstellen, in dem die erforderlichen Vorgänge ausgeführt werden, und dessen Status manuell steuern.  Darüber hinaus verfügt die aktuelle API nicht über alle Funktionen für die Arbeit mit UDP-Sockets, die sich in Standardbibliotheken in anderen Sprachen befinden. IPC-Sockets werden nicht unterstützt. </p><br><p><img src="https://habrastorage.org/webt/b0/ba/3o/b0ba3orzpj8i8ja2e3-p5enhbi8.png" alt="Bild"></p><br><p>  Beim Erstellen und Implementieren einer neuen API stellen sich viele Fragen: </p><br><p>  Wie entwerfe ich eine API?  Vielleicht lohnt es sich, ein bestehendes Beispiel zu nehmen?  Schließlich wollen wir nicht alles von Grund auf neu erstellen, weil  Es wird mehr Zeit in Anspruch nehmen und möglicherweise nicht dem Geschmack des restlichen Teams entsprechen und viel Debatte auslösen. </p><br><p>  Wie bereits erwähnt, besteht das eigentliche Problem für Haxe in der Implementierung einer einzigen API für alle unterstützten Plattformen. </p><br><p><img src="https://habrastorage.org/webt/nd/lk/gp/ndlkgpmojw_uhnil6kdnazwn-k8.png" alt="Bild"></p><br><p>  API Node.js. wurde als Beispiel ausgewählt.  Es ist durchdacht, unterstützt die notwendigen Systemfunktionen und eignet sich gut zum Erstellen von Serveranwendungen. </p><br><p><img src="https://habrastorage.org/webt/va/ih/0y/vaih0yr_x7telwmirbhputnxz7o.png" alt="Bild"></p><br><p>  Gleichzeitig ist die Node.js-API eine Javascript-API ohne starke Typisierung.  Beispielsweise können Funktionen des Moduls <code>fs</code> für die Arbeit mit dem Dateisystem als Pfade entweder Zeichenfolgen oder Objekte wie <code>Buffer</code> und sogar <code>URL</code> .  Und das ist nicht so gut für Haxe. </p><br><p><img src="https://habrastorage.org/webt/pa/xt/v4/paxtv4f4oiqri_gzpd4jrhyv_y8.png" alt="Bild"></p><br><p>  Node.js verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wiederum</a> die in C geschriebene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libuv-Bibliothek</a> . Das direkte Arbeiten mit der libuv-API von Haxe wäre nicht so praktisch: Um beispielsweise die Datei asynchron umzubenennen, müssten Sie zusätzlich Objekte wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>uv_loop_t</code></a> (Struktur für die Verwaltung) erstellen event loop in libuv) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>uv_fs_t</code></a> (Struktur zur Beschreibung einer Anfrage an das Dateisystem): </p><br><p><img src="https://habrastorage.org/webt/oe/7w/cs/oe7wcsi9ebwntb7g2hrzab4ognu.png" alt="Bild"></p><br><p>  Als Ergebnis wurden die APIs Node.js und libuv wie folgt integriert (am Beispiel der Methode eval macro interpreter and rename): </p><br><ul><li>  Sie haben die API-Methode von Node.js übernommen, in Haxe konvertiert und versucht, die Argumenttypen zu standardisieren und redundante Argumente für Haxe zu entfernen.  Zum Beispiel sind <code>FilePath</code> (vom Typ <code>FilePath</code> ) Abstracts über Strings: </li></ul><br><p><img src="https://habrastorage.org/webt/i-/-c/qb/i--cqbg076qynad4g4dfjhdupe8.png" alt="Bild"></p><br><ul><li>  Dann erstellte OCaml-Ordner für diese Methode: </li></ul><br><p><img src="https://habrastorage.org/webt/hh/zl/-9/hhzl-9gd0eqcqb1y3iw6sqghx1w.png" alt="Bild"></p><br><ul><li>  verknüpfte OCaml und C (unter Verwendung der CFFI-C-Fremdfunktionsschnittstelle): </li></ul><br><p><img src="https://habrastorage.org/webt/n4/ia/8c/n4ia8cqs9c4zhhsezhxyu_kdrcs.png" alt="Bild"></p><br><ul><li>  und schrieb schließlich C-Binder, um libuv C-Funktionen von OCaml aufzurufen: </li></ul><br><p><img src="https://habrastorage.org/webt/zx/gw/tn/zxgwtnacpaeyyik19zq6ijif4lo.png" alt="Bild"></p><br><p>  Ähnlich wurde es für HashLink und Neko gemacht (im Moment ist die asys API nur für diese drei Plattformen implementiert).  Wie Sie vielleicht erraten haben, hat es eine Menge Arbeit gekostet. </p><br><p>  Aurel zeigte einige kleine Anwendungen, die demonstrierten, wie die asys-API funktioniert. <br>  Das erste Beispiel ist eine Demonstration des asynchronen Lesens des Inhalts einer Datei.  Bisher werden im Code explizit Methoden zum Initialisieren von libuv ( <code>hl.Uv.init()</code> ) und Starten des Anwendungszyklus ( <code>hl.Uv.run()</code> ) <code>hl.Uv.run()</code> , da die Arbeit an der API noch nicht abgeschlossen wurde (aber in der Zukunft) sie werden automatisch hinzugefügt): </p><br><p><img src="https://habrastorage.org/webt/4o/sy/fn/4osyfne9qtpdb_mf1ukbwkoat6w.png" alt="Bild"></p><br><p>  Das Ergebnis des angezeigten Codes: </p><br><p><img src="https://habrastorage.org/webt/qj/_w/xa/qj_wxapicgolrogp5t9dkwg6yeq.png" alt="Bild"></p><br><p>  Wir sehen, dass die Ergebnisse der aufgerufenen <code>AsyncFileSystem.readFile()</code> -Methoden in der Konsole nach der <code>AsyncFileSystem.readFile()</code> angezeigt werden, die im Code aufgerufen wird, nachdem versucht wurde, den Inhalt der Dateien zu lesen. </p><br><p>  Das zweite Beispiel zeigt den asynchronen Betrieb mit DNS- und IP-Adressen. </p><br><p><img src="https://habrastorage.org/webt/o8/fj/98/o8fj98v5f9mi_r18b4om36bye5c.png" alt="Bild"></p><br><p>  In der neuen API wird es viel einfacher, den Hostnamen sowie Hilfsmethoden für die Arbeit mit IP-Adressen zu ermitteln. </p><br><p><img src="https://habrastorage.org/webt/ad/ok/u4/adoku4ngzznjwcuerfz7tq-wm60.png" alt="Bild"></p><br><p>  Das dritte Beispiel ist ein einfacher TCP-Echoserver, für dessen Erstellung nur drei Codezeilen erforderlich sind: </p><br><p><img src="https://habrastorage.org/webt/43/8c/-p/438c-pfd3o-s58ncrjwkoyvy_lk.png" alt="Bild"></p><br><p>  Ein viertes Beispiel ist eine Demonstration des Informationsaustauschs zwischen Prozessen: <br>  Die statische Methode <code>makeFrame()</code> in diesem Beispiel erstellt separate PNG-Bilder: </p><br><p><img src="https://habrastorage.org/webt/n8/-e/qw/n8-eqwrdqpzwha0k3i08hwnsdey.png" alt="Bild"></p><br><p>  und in der <code>main</code> starten wir den ffmpeg-Prozess, in den wir die in <code>makeFrame()</code> generierten Frames <code>makeFrame()</code> : </p><br><p><img src="https://habrastorage.org/webt/nq/ih/qn/nqihqnbutuomwmjp5spv7uy456q.png" alt="Bild"></p><br><p>  und die Ausgabe wird eine Videodatei sein: </p><br><p><img src="https://habrastorage.org/webt/vl/l1/af/vll1aftw7wbvvptcargllfzmngs.png" alt="Bild"></p><br><p>  Und das fünfte Beispiel ist UDP-Video-Stream.  Hier wird wie im vorherigen Beispiel der ffmpeg-Prozess gestartet, aber dieses Mal wird das Video abgespielt und die Daten werden an den Standardausgabestream ausgegeben.  Es wird auch ein UDP-Socket erstellt, der Daten aus dem ffmpeg-Prozess übersetzt. </p><br><p><img src="https://habrastorage.org/webt/rb/oz/79/rboz79aci2nd3npqbdn7lguqcuq.png" alt="Bild"></p><br><p>  Und schließlich teilen wir die von ffmpeg empfangenen Daten in kleinere "Teile" auf und übersetzen sie in den angegebenen Port: </p><br><p><img src="https://habrastorage.org/webt/9v/9_/e4/9v9_e4g_qs9ahrtkfwiewlfz0so.png" alt="Bild"></p><br><p>  Als Ergebnis erhalten wir einen funktionierenden Videostream: </p><br><p><img src="https://habrastorage.org/webt/q1/xd/e7/q1xde7iq24modwdqgpdwkzp4e4o.png" alt="Bild"></p><br><p>  Zusammenfassend beinhaltet die neue asys API: </p><br><ul><li>  Methoden für die Arbeit mit dem Dateisystem, einschließlich neuer Funktionen, die sich nicht in der Standardbibliothek befanden (z. B. zum Ändern von Berechtigungen), sowie asynchrone Versionen aller in der alten Standardbibliothek verfügbaren Funktionen </li><li>  Unterstützung für asynchronen Betrieb mit TCP / UDP / IPC-Sockets </li><li>  Methoden für die Arbeit mit DNS (bisher 2 Methoden: <code>lookup</code> und <code>reverse</code> ) </li><li>  sowie Methoden für das asynchrone Arbeiten mit Prozessen. </li></ul><br><p><img src="https://habrastorage.org/webt/va/xf/5j/vaxf5j-sza0yvdr0zbb3uoepizw.png" alt="Bild"></p><br><p>  Die Arbeiten an der asys-API sind noch nicht abgeschlossen, es gibt derzeit einige Probleme mit dem Garbage Collector, wenn Sie mit der libuv-Bibliothek arbeiten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pull Request</a> mit den entsprechenden Änderungen wurde noch nicht in den Hauptzweig von Haxe aufgenommen. Kommentare dazu begrüßen Meinungen zu den Namen der neuen Methoden, deren Signaturen und der Dokumentation. <br>  Wie bereits erwähnt, wird die Unterstützung der asys-API nur für HashLink, Eval und Neko (in Form von drei separaten Pull-Requests) implementiert.  Aurel hat bereits einen Plan für das Hinzufügen von Unterstützung für die neue API für C ++ und Lua erstellt.  Die Implementierung für andere Plattformen erfordert zusätzliche Forschung. </p><br><p><img src="https://habrastorage.org/webt/xe/vc/bl/xevcblkgoyvhwm2zbzbchdysoks.png" alt="Bild"></p><br><p>  Es ist möglich, dass die asys-API in Haxe 4.1 verfügbar wird (jedoch nur auf einigen Plattformen). </p><br><p>  Aurel sprach auch über sein Nebenprojekt - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Ammer-Bibliothek</a> (die dennoch mit seiner Arbeit bei der Haxe Foundation verbunden ist). </p><br><p><img src="https://habrastorage.org/webt/io/9w/fo/io9wfoogbdtulgmplmgfl0_lnde.png" alt="Bild"></p><br><p>  Ammers Ziel ist es, die Erstellung von Bindemitteln für C-Bibliotheken so zu automatisieren, dass sie sowohl in HashLink als auch in HXCPP verwendet werden können (im Oktober 2018 stellte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lars Duse eine Gebühr</a> für die Lösung dieses Problems fest). </p><br><p>  Warum war diese Aufgabe relevant?  Tatsache ist, dass das Erstellen von Bindemitteln für HashLink und HXCPP zwar ähnlich ist, Sie jedoch für jede Plattform Ihren eigenen Klebercode schreiben müssen. </p><br><p>  Aurel hat ungefähr dasselbe getan, als er die libuv-Bibliothek in Haxe integriert hat - für Eval, Neko und HashLink musste er denselben Code schreiben, der sich nur in Details unterschied (Funktionsaufrufe, Unterschiede in der Arbeit von FFI usw.): </p><br><p><img src="https://habrastorage.org/webt/b5/mr/h4/b5mrh4kfwydttjk5iz5vhlqxrhw.png" alt="Bild"></p><br><p>  Eine ähnliche Arbeit musste auf der Haxe-Seite ausgeführt werden, damit native Funktionen daraus aufgerufen werden konnten: </p><br><p><img src="https://habrastorage.org/webt/sm/oj/5z/smoj5ziapdbfupnznqm5tdzjxsy.png" alt="Bild"></p><br><p>  Und die Idee von ammer ist, die Haxe-Version der API zu verwenden, die nicht mit redundanten Informationen überladen ist, und diesen Code irgendwie für alle Plattformen funktionsfähig zu machen: </p><br><p><img src="https://habrastorage.org/webt/z7/qw/x3/z7qwx3d5tphczllt6lxxxsyjhuy.png" alt="Bild"></p><br><p>  Was ammer jetzt benötigt, um externe C-Bibliotheken zu verwenden: </p><br><ul><li>  Erstellen Sie die Haxe-Spezifikation für die Bibliothek, die im Wesentlichen außerhalb der verwendeten Bibliothek liegt </li><li>  Anwendungscode schreiben </li><li>  Kompilieren Sie das Projekt, indem Sie Pfade zu Headerdateien und C-Bibliotheksdateien angeben </li><li>  ... </li><li>  Gewinn </li></ul><br><p><img src="https://habrastorage.org/webt/bq/yg/tj/bqygtjjw4ike8exjibcpjjk_pg8.png" alt="Bild"></p><br><p>  Unter der Haube macht ammer Folgendes: </p><br><ul><li>  passt Typen abhängig von der Zielplattform an </li><li>  generiert automatisch C-Code zum Aufrufen nativer Funktionen </li><li>  generiert ein Makefile, das zum Erstellen von hdll- und ndll-Dateien verwendet wird </li></ul><br><p><img src="https://habrastorage.org/webt/lt/fa/yy/ltfayydbhqtof2itvy-hwmqo-ha.png" alt="Bild"></p><br><p>  Ammer unterstützt derzeit: </p><br><ul><li>  einfache funktionen </li><li>  definiere sie aus den Header-Dateien (im Hax-Code kann auf sie als Konstante zugegriffen werden) </li><li>  Zeiger </li></ul><br><p>  Unterstützung geplant: </p><br><ul><li>  Rückrufe (sie sind noch Mangelware) </li><li>  und Strukturen (sehr notwendig für die Arbeit mit der C-API) </li></ul><br><p><img src="https://habrastorage.org/webt/o3/n1/ul/o3n1ul7h6wyf2kwx1t1k8rfiluc.png" alt="Bild"></p><br><p>  Jetzt arbeitet ammer mit C ++, HashLink und Eval.  Und Aurel ist sicher, dass er Unterstützung für andere Systemplattformen hinzufügen kann. </p><br><p><img src="https://habrastorage.org/webt/12/ea/cq/12eacqp3bshywrwjg5a-9ufbtym.png" alt="Bild"></p><br><p>  Um die Fähigkeiten von ammer zu demonstrieren, zeigte Aurel eine kleine Anwendung, die den Lua-Interpreter ausführt: </p><br><p><img src="https://habrastorage.org/webt/5y/m-/t2/5ym-t2a72kbdezhqud58ao4vv8y.png" alt="Bild"></p><br><p>  Die darin verwendeten Bindemittel sind wie folgt: </p><br><p><img src="https://habrastorage.org/webt/ju/8j/to/ju8jtoyqggua_7h4xu6tt-9yy_i.png" alt="Bild"></p><br><p>  Wie Sie sehen, sind einige Methoden auskommentiert, weil  Sie verwenden Rückrufe, deren Unterstützung noch nicht realisiert wurde, aber Aurel hofft, dass er dies bald beheben kann. </p><br><p><img src="https://habrastorage.org/webt/04/8d/bu/048dbumtdbyuogq0mvgt_qlt5jc.png" alt="Bild"></p><br><p>  Wofür kann ammer verwendet werden: </p><br><ul><li>  Einbetten einer virtuellen Lua-Maschine </li><li>  Erstellen von Anwendungen in SDL </li><li>  Eine Automatisierung der Arbeit mit libuv ist möglich (wie bereits gezeigt, ist jetzt viel handgeschriebener Code erforderlich, um mit libuv zu arbeiten). </li><li>  und natürlich wird es die Verwendung vieler anderer nützlicher C-Bibliotheken (wie OpenAL, Dear-Imgui usw.) erheblich vereinfachen. </li></ul><br><p><img src="https://habrastorage.org/webt/al/xa/jq/alxajqjpsgyeyttibyyg232jhci.png" alt="Bild"></p><br><p>  Obwohl Aurels Praktikum bei der Haxe Foundation beendet ist, plant er, weiterhin mit Haxe, as zusammenzuarbeiten  Seine Hochschulausbildung ist noch nicht abgeschlossen und er muss noch seine Abschlussarbeit schreiben.  Aurel weiß bereits, wofür es gewidmet sein wird - die Arbeit des Garbage Collectors in HashLink zu verbessern.  Nun, es wird interessant sein! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475226/">https://habr.com/ru/post/de475226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475206/index.html">Quadroskop nach Kutters Schema 4 x 0,5 m für astronomische Hochgeschwindigkeitsmessungen</a></li>
<li><a href="../de475208/index.html">Umzug nach Europa: Abenteuer und Erkenntnisse</a></li>
<li><a href="../de475212/index.html">Suchen Sie mit dem kostenlosen Dienstprogramm dbForge Search nach Daten und Objekten in der MS SQL Server-Datenbank</a></li>
<li><a href="../de475214/index.html">Wenn ein Unternehmen stirbt: Wie überlebe ich den Bankrott?</a></li>
<li><a href="../de475218/index.html">Kryptografische Protokolle: Definitionen, Datensätze, Eigenschaften, Klassifizierung, Angriffe</a></li>
<li><a href="../de475228/index.html">Payroll Gabel. Du bist ein Programmierer für Mama</a></li>
<li><a href="../de475236/index.html">Ignoriere niemals wieder das Verstärkungstraining.</a></li>
<li><a href="../de475238/index.html">Blade Runner Timeline - November 2019. Hat sich die Prognose erfüllt?</a></li>
<li><a href="../de475240/index.html">Verwendung strenger Module in großen Python-Projekten: Instagram-Erfahrung. Teil 1</a></li>
<li><a href="../de475242/index.html">Verwendung strenger Module in großen Python-Projekten: Instagram-Erfahrung. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>