<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏾 💅🏾 🦇 Einige Fallstricke bei der statischen Eingabe in Python 👩🏽 👩🏽‍🎤 🈸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich denke, wir gewöhnen uns langsam an die Tatsache, dass Python Typanmerkungen hat: Sie wurden zwei Releases (3.5) in den Annotationen von Funktionen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einige Fallstricke bei der statischen Eingabe in Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437018/"><p><img src="https://habrastorage.org/webt/m1/ev/tt/m1evttq2r-l6boemxwxeyi6mify.png"></p><br><p>  Ich denke, wir gewöhnen uns langsam an die Tatsache, dass Python Typanmerkungen hat: Sie wurden zwei Releases (3.5) in den Annotationen von Funktionen und Methoden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP 484</a> ) und in der letzten Version (3.6) an Variablen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP 526</a> ) zurückgebracht. </p><br><p>  Da diese beiden PEPs von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MyPy</a> inspiriert wurden, werde ich Ihnen sagen, welche weltlichen Freuden und kognitiven Dissonanzen mich bei der Verwendung dieses statischen Analysators sowie des gesamten Typisierungssystems erwarteten. </p><br><blockquote>  Disclamer: Ich stelle nicht die Frage nach der Notwendigkeit oder Schädlichkeit der statischen Typisierung in Python.  Ich spreche nur von den Fallstricken, die mir bei der Arbeit in einem statisch typisierten Kontext begegnet sind. </blockquote><a name="habracut"></a><br><h1>  Generika (typing.Generic) </h1><br><p> Es ist schön, etwas wie <code>List[int]</code> , <code>Callable[[int, str], None]</code> in Anmerkungen zu verwenden. <br>  Es ist sehr schön, wenn der Analysator den folgenden Code hervorhebt: </p><br><pre> <code class="python hljs">T = ty.TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ty.Generic[T])</span></span></span><span class="hljs-class">:</span></span> value: T A[int]().value = <span class="hljs-string"><span class="hljs-string">'str'</span></span> <span class="hljs-comment"><span class="hljs-comment"># error: Incompatible types in assignment # (expression has type "str", variable has type "int")</span></span></code> </pre> <br><p>  Was ist jedoch, wenn wir eine Bibliothek schreiben und der Programmierer, der sie verwendet, keinen statischen Analysator verwendet? <br>  Den Benutzer zwingen, die Klasse mit einem Wert zu initialisieren und dann ihren Typ zu speichern? </p><br><pre> <code class="python hljs">T = ty.TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gen</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Generic[T])</span></span></span><span class="hljs-class">:</span></span> value: T ref: Type[T] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value: T)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self.value = value self.ref = type(value)</code> </pre> <br><p>  Irgendwie nicht benutzerfreundlich. <br>  Aber was ist, wenn Sie das wollen? </p><br><pre> <code class="python hljs">b = Gen[A](B())</code> </pre> <br><p>  Auf der Suche nach einer Antwort auf diese Frage ging ich ein wenig <code>typing</code> und tauchte in die Welt der Fabriken ein. <br><img src="https://habrastorage.org/getpro/habr/post_images/358/bc2/006/358bc200640a3a4b64c41d75b9b35af1.jpg"><br>  Tatsache ist, dass nach dem Initialisieren der Instanz der generischen Klasse das Attribut <code>__args__</code> Attribut <code>__args__</code> wird, bei dem es sich um ein Tupel von Typen handelt.  Der Zugriff von <code>__init__</code> sowie von <code>__new__</code> ist jedoch nicht möglich.  Es ist auch nicht in der Metaklasse <code>__call__</code> .  Der Trick besteht darin, dass zum Zeitpunkt der Initialisierung der Unterklasse von <code>Generic</code> andere Metaklasse <code>_GenericAlias</code> , die den endgültigen Typ festlegt, entweder nachdem das Objekt einschließlich aller Methoden seiner Metaklasse initialisiert wurde oder wenn <code>__getithem__</code> wird.  Daher gibt es beim Erstellen eines Objekts keine Möglichkeit, generische Typen abzurufen. </p><br><div class="spoiler">  <b class="spoiler_title">Wir werfen diesen Müll, versprachen eine universellere Lösung.</b> <div class="spoiler_text"><p>  Deshalb habe ich mir einen kleinen Deskriptor geschrieben, der dieses Problem löst: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_init_obj_ref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Gen[T]'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Set object ref attribute if not one to initialized arg."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> hasattr(obj, <span class="hljs-string"><span class="hljs-string">'ref'</span></span>): obj.ref = obj.__orig_class__.__args__[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment"># type: ignore class ValueHandler(Generic[T]): """Handle object _value attribute, asserting it's type.""" def __get__(self, obj: 'Gen[T]', cls: Type['Gen[T]'] ) -&gt; Union[T, 'ValueHandler[T]']: if not obj: return self _init_obj_ref(obj) if not obj._value: obj._value = obj.ref() return obj._value def __set__(self, obj: 'Gen[T]', val: T) -&gt; None: _init_obj_ref(obj) if not isinstance(val, obj.ref): raise TypeError(f'has to be of type {obj.ref}, pasted {val}') obj._value = val class Gen(Generic[T]): _value: T ref: Type[T] value = ValueHandler[T]() def __init__(self, value: T) -&gt; None: self._value = value class A: pass class B(A): pass b = Gen[A](B()) b.value = A() b.value = int() # TypeError: has to be of type &lt;class '__main__.A'&gt;, pasted 0</span></span></code> </pre> <br><p>  Infolgedessen wird es natürlich notwendig sein, für eine universellere Verwendung umzuschreiben, aber das Wesentliche ist klar. </p></div></div><br><p>  <strong>[UPD]:</strong> Am Morgen habe ich beschlossen, dasselbe wie im <code>typing</code> selbst zu versuchen, aber einfacher: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ty T = ty.TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ty.Generic[T])</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># __args are unique every instantiation __args: ty.Optional[ty.Tuple[ty.Type[T]]] = None value: T def __init__(self, value: ty.Optional[T]=None) -&gt; None: """Get actual type of generic and initizalize it's value.""" cls = ty.cast(A, self.__class__) if cls.__args: self.ref = cls.__args[0] else: self.ref = type(value) if value: self.value = value else: self.value = self.ref() cls.__args = None def __class_getitem__(cls, *args: ty.Union[ty.Type[int], ty.Type[str]] ) -&gt; ty.Type['A']: """Recive type args, if passed any before initialization.""" cls.__args = ty.cast(ty.Tuple[ty.Type[T]], args) return super().__class_getitem__(*args, **kwargs) # type: ignore a = A[int]() b = A(int()) c = A[str]() print([a.value, b.value, c.value]) # [0, 0, '']</span></span></code> </pre> <br><p>  <strong>[UPD]: Der</strong> <code>typing</code> Ivan Levinsky sagte, beide Optionen könnten unvorhersehbar brechen. </p><br><blockquote>  Wie auch immer, Sie können jeden Weg verwenden.  Vielleicht ist <code>__class_getitem__</code> sogar etwas besser, zumindest ist <code>__class_getitem__</code> eine dokumentierte Spezialmethode (obwohl dies bei Generika nicht der <code>__class_getitem__</code> ist). </blockquote><br><h2>  Funktionen und Aliase </h2><br><p>  Ja, Generika sind gar nicht so einfach: <br>  Wenn wir beispielsweise irgendwo eine Funktion als Argument akzeptieren, wechselt ihre Annotation automatisch von kovariant zu kontravariant: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'A'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   A  B ... def bar(f: Callable[['A'], None]): #       A ...</span></span></code> </pre> <br><p>  Und im Prinzip habe ich keine Beschwerden über Logik, nur muss dies durch generische Aliase gelöst werden: </p><br><pre> <code class="python hljs">TA = TypeVar(<span class="hljs-string"><span class="hljs-string">'TA'</span></span>, bound=<span class="hljs-string"><span class="hljs-string">'A'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'B'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   B   ... def bar(f: Callable[['TA'], None]): #     A  B ...</span></span></code> </pre> <br><p>  Im Allgemeinen muss der Abschnitt über die <abbr title="Typvarianz">Variabilität von Typen</abbr> sorgfältig und mehrmals gelesen werden. </p><br><h2>  Abwärtskompatibilität </h2><br><p>  Das ist nicht so heiß: Ab Version 3.7 ist <code>Generic</code> eine Unterklasse von <code>ABCMeta</code> , die sehr praktisch und gut ist.  Es ist schlecht, dass dies den Code bricht, wenn es auf 3.6 läuft. </p><br><h1>  Strukturelle Vererbung (Stuctural Suptyping) </h1><br><p>  Anfangs war ich sehr glücklich: Die Schnittstellen wurden geliefert!  Die Rolle der Schnittstellen wird von der <code>Protocol</code> aus dem Modul <code>@runtime</code> , mit der Sie in Kombination mit dem Dekorator <code>@runtime</code> überprüfen können, ob die Klasse die Schnittstelle ohne direkte Vererbung implementiert.  MyPy wird auch auf einer tieferen Ebene hervorgehoben. </p><br><p>  Allerdings habe ich in der Laufzeit im Vergleich zur Mehrfachvererbung keinen großen praktischen Nutzen festgestellt. <br>  Es scheint, dass der Dekorateur nur das Vorhandensein einer Methode mit dem erforderlichen Namen überprüft, ohne auch nur die Anzahl der Argumente zu überprüfen, ganz zu schweigen von der Eingabe: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ty <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typing_extensions <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> te @te.runtime <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntStackP</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(te.Protocol)</span></span></span><span class="hljs-class">:</span></span> _list: ty.List[int] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val: int)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntStack</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._list: ty.List[int] = list() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val: int)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(val, int): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> TypeError(<span class="hljs-string"><span class="hljs-string">'wrong pushued val type'</span></span>) self._list.append(val) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrStack</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._list: ty.List[str] = list() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val: str, weather: ty.Any=None)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(val, str): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> TypeError(<span class="hljs-string"><span class="hljs-string">'wrong pushued val type'</span></span>) self._list.append(val) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stack: IntStackP, value: int)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(stack, IntStackP): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> TypeError(<span class="hljs-string"><span class="hljs-string">'is not IntStackP'</span></span>) stack.push(value) a = IntStack() b = StrStack() c: ty.List[int] = list() push_func(a, <span class="hljs-number"><span class="hljs-number">1</span></span>) push_func(b, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment"># TypeError: wrong pushued val type push_func(c, 1) # TypeError: is not IntStackP</span></span></code> </pre> <br><p>  Auf der anderen Seite verhält sich MyPy wiederum intelligenter und hebt die Inkompatibilität von Typen hervor: </p><br><pre> <code class="python hljs">push_func(a, <span class="hljs-number"><span class="hljs-number">1</span></span>) push_func(b, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Argument 1 to "push_func" has incompatible type "StrStack"; # expected "IntStackP" # Following member(s) of "StrStack" have conflicts: # _list: expected "List[int]", got "List[str]" # Expected: # def push(self, val: int) -&gt; None # Got: # def push(self, val: str, weather: Optional[Any] = ...) -&gt; None</span></span></code> </pre> <br><h1>  Bedienerüberlastung </h1><br><p>  Ein sehr frisches Thema, weil  Wenn Bediener mit voller Sicherheit überlastet werden, verschwindet der ganze Spaß.  Diese Frage ist im MyPy-Bug-Tracker wiederholt aufgetaucht, schwört jedoch an einigen Stellen, und Sie können sie sicher deaktivieren. <br>  Ich erkläre die Situation: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__add__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, other)</span></span></span><span class="hljs-function"> -&gt; int:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__iadd__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, other)</span></span></span><span class="hljs-function"> -&gt; 'A':</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(other, int): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NotImplemented</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A() var = A() var += <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment"># Inferred type is 'A', but runtime type is 'int'?</span></span></code> </pre> <br><p>  Wenn die zusammengesetzte Zuweisungsmethode <code>NotImplemented</code> , sucht Python zuerst nach <code>__radd__</code> , verwendet dann <code>__add__</code> und voila. </p><br><p>  Gleiches gilt für das Überladen von Unterklassenmethoden des Formulars: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__add__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'A'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> -&gt; 'A':</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> @overload <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__add__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'A'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> -&gt; 'A':</span></span> ... @overload <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__add__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'B'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> -&gt; 'B' :</span></span> ...</code> </pre> <br><p>  An einigen Stellen wurden bereits Warnungen in die Dokumentation verschoben, an einigen Stellen arbeiten sie noch am Produkt.  Die allgemeine Schlussfolgerung der Mitwirkenden ist jedoch, solche Überlastungen akzeptabel zu lassen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437018/">https://habr.com/ru/post/de437018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437004/index.html">Träumen YML-Programmierer von ansiblen Tests?</a></li>
<li><a href="../de437006/index.html">Wanhao Duplicator 10 3D-Drucker Bewertung</a></li>
<li><a href="../de437008/index.html">NLP. Die Grundlagen. Techniken. Selbstentwicklung. Teil 1</a></li>
<li><a href="../de437010/index.html">Echos der Vergangenheit: Young's Erfahrung auf der Basis der neuen Röntgenspektroskopie-Methode</a></li>
<li><a href="../de437014/index.html">Die Aufgabe von N Körpern oder wie man eine Galaxie in die Luft jagt, ohne die Küche zu verlassen</a></li>
<li><a href="../de437020/index.html">Was ist falsch an Reinforcement Learning?</a></li>
<li><a href="../de437022/index.html">Noise Security Bit 0x22 (Fehlerinjektionsangriffe, 35C3 und Wallet.fail)</a></li>
<li><a href="../de437026/index.html">Google in Frankreich verurteilte die DSGVO wegen Missbrauchs personenbezogener Daten zu einer Geldstrafe von 50 Millionen Euro</a></li>
<li><a href="../de437030/index.html">Automatisierung der Infrastruktur eines Luxusbüros: wie es aussieht</a></li>
<li><a href="../de437032/index.html">Installationsanleitung für NGINX ModSecurity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>