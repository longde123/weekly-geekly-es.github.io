<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ğŸ¿ ğŸ‘©ğŸ½ ğŸ‘°ğŸ½ Prinsip PIM ğŸ¤±ğŸ½ ğŸ‘¨â€âš•ï¸ ğŸ›´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Protokol PIM adalah seperangkat protokol untuk mentransmisikan multicast pada jaringan antar router. Hubungan tetangga dibangun dengan cara yang sama ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prinsip PIM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450582/"> Protokol PIM adalah seperangkat protokol untuk mentransmisikan multicast pada jaringan antar router.  Hubungan tetangga dibangun dengan cara yang sama seperti dalam kasus protokol routing dinamis.  PIMv2 mengirimkan pesan Hello setiap 30 detik ke alamat multicast yang disediakan 224.0.0.13 (Semua-PIM-Router).  Pesan berisi Hold Timers - biasanya 3.5 * Hello Timer, yaitu 105 detik secara default. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e67/8a0/1fc/e678a01fc7879ecf22bc6f9a3825f9a6.jpg" alt="Gambar saya"></a> <br>  PIM menggunakan dua mode operasi utama - Mode padat dan Jarang.  Mari kita mulai dengan mode Dense. <a name="habracut"></a><br>  <b>Pohon Distribusi Berbasis Sumber.</b> <br>  Mode mode padat disarankan untuk digunakan jika ada banyak klien dari berbagai grup multicast.  Ketika router menerima lalu lintas multicast, hal pertama yang dilakukan adalah memeriksanya untuk aturan RPF.  RPF - aturan ini digunakan untuk memeriksa sumber multicast dengan tabel routing unicast.  Diperlukan kunjungan ke antarmuka tempat host ini disembunyikan sesuai dengan versi tabel routing unicast.  Mekanisme ini memecahkan masalah terjadinya loop selama transmisi multicast. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6cd/08c/fb6/6cd08cfb6842680447d56860334af52c.png" alt="Gambar saya"></a> <br>  R3 dari pesan multicast akan mengenali sumber multicast (Sumber IP) dan memeriksa dua aliran dari R1 dan R2 dari tabel unicastnya.  Aliran dari antarmuka yang ditunjukkan oleh tabel (R1 ke R3) akan ditransmisikan lebih lanjut, dan aliran dari R2 akan turun, karena untuk sampai ke sumber multicast, perlu mengirim paket melalui S0 / 1. <br>  Pertanyaannya adalah, apa yang terjadi jika Anda memiliki dua rute yang setara dengan metrik yang sama?  Dalam hal ini, router akan memilih next-hop untuk rute ini.  Siapa yang memiliki alamat ip lebih tinggi, ia menang.  Jika Anda perlu mengubah perilaku ini, Anda dapat menggunakan ECMP.  Lebih detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br>  Setelah memeriksa aturan RPF, router mengirim paket multicast ke semua tetangga PIM-nya, kecuali yang menerima paket tersebut.  Router PIM lain mengulangi proses ini.  Jalur yang paket multicast telah lulus dari sumber ke penerima akhir membentuk pohon yang disebut - pohon distribusi berbasis sumber, pohon jalur terpendek (SPT), pohon sumber.  Tiga nama berbeda, pilih salah satu. <br>  Cara mengatasi masalah dengan fakta bahwa beberapa router tidak melepaskan aliran multicast dan tidak ada yang mengirimnya, dan router tingkat yang lebih tinggi mengirimkannya.  Untuk ini, mekanisme Prune diciptakan. <br>  <b>Pesan Prune.</b> <br>  Sebagai contoh, R2 akan terus mengirim R3 multicast, meskipun R3 dengan aturan RPF menjatuhkannya.  Mengapa memuat saluran?  R3 mengirim Pesan PIM Prune dan R2, setelah menerima pesan ini, menghapus antarmuka S0 / 1 dari daftar antarmuka keluar untuk aliran ini, daftar antarmuka dari mana lalu lintas ini harus dikirim. <br><blockquote>  Berikut ini adalah definisi yang lebih formal dari pesan PIM Prune: <br>  Pesan PIM Prune dikirim oleh satu router ke router kedua untuk menyebabkan router kedua menghapus tautan yang menerima Prune dari SPT (S, G) tertentu. </blockquote><br>  Setelah menerima pesan Pangkas, R2 mengatur timer Pangkas menjadi 3 menit.  Setelah tiga menit, itu akan mulai mengirim lalu lintas lagi sampai menerima pesan Prune berikutnya.  Ini ada di PIMv1. <br>  Dan di PIMv2 timer State Refresh ditambahkan (secara default 60 detik).  Segera setelah pesan Pangkas dikirim dari R3, timer ini dimulai pada R3.  Setelah penghitung waktu ini berakhir, R3 akan mengirim pesan Refresh Negara yang akan mengatur ulang Prune Timer 3 menit ke R2 untuk grup ini. <br>  Alasan mengirim pesan Prune: <br><ul><li>  Ketika paket multicast gagal melakukan pemeriksaan RPF. </li><li>  Ketika tidak ada klien yang terhubung secara lokal yang meminta grup multicast (IGMP Bergabung) dan tidak ada tetangga PIM yang lalu lintas multicastnya dapat dikirim (Non-Prune Interface). </li></ul><br>  <b>Pesan Cangkok.</b> <br>  Bayangkan R3 tidak menginginkan lalu lintas dari R2, mengirim Prune dan menerima multicast dari R1.  Tapi tiba-tiba, saluran jatuh antara R1-R3 dan R3 dibiarkan tanpa multicast.  Anda dapat menunggu 3 menit hingga Prune Timer kedaluwarsa pada R2.  3 menit untuk menunggu lama, agar tidak menunggu, Anda perlu mengirim pesan yang langsung menampilkan antarmuka ini S0 / 1 pada R2 dari status pruned.  Pesan ini akan menjadi pesan Graft.  Setelah menerima pesan Graft, R2 akan mengirimkan Graft-ACK sebagai tanggapan. <br>  <b>Pangkas Override.</b> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/bc7/1d0/e9f/bc71d0e9f81b292e75d4a016a9b657ef.png" alt="Gambar saya"></a> <br>  Mari kita lihat skema ini.  R1 menyiarkan multicast di segmen dengan dua router.  R3 menerima dan menyiarkan lalu lintas, R2 menerima, tetapi tidak ada yang menyiarkan lalu lintas.  Ini mengirimkan pesan Prune ke R1 di segmen ini.  R1 harus menghapus Fa0 / 0 dari daftar dan berhenti siaran di segmen ini, tetapi apa yang akan terjadi pada R3?  Dan R3 berada di segmen yang sama, ia juga menerima pesan ini dari Prune dan menyadari tragedi situasinya.  Sebelum R1 berhenti siaran, ini mengatur timer ke 3 detik dan berhenti siaran setelah 3 detik.  3 detik - begitu banyak waktu untuk R3, agar tidak kehilangan multicast Anda.  Karenanya, R3, sesegera mungkin, mengirimkan pesan Pim Join untuk grup ini dan R1 tidak lagi berpikir untuk berhenti siaran.  Tentang Gabung posting di bawah ini. <br>  <b>Pesan tegas.</b> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f1d/9d1/d68/f1d9d1d6855fdc188deb28c75bde2d0d.png" alt="Gambar saya"></a> <br>  Bayangkan situasi ini: dua router disiarkan ke jaringan yang sama sekaligus.  Mereka menerima aliran yang sama dari sumbernya, dan keduanya menyiarkannya ke jaringan yang sama di belakang antarmuka e0.  Karena itu, mereka perlu menentukan siapa yang akan menjadi satu-satunya penyiar tunggal untuk jaringan ini.  Pesan tegas digunakan untuk ini.  Ketika R2 dan R3 mendeteksi duplikasi lalu lintas multicast, yaitu multicast yang mereka siarankan pada R2 dan R3, yang mereka broadcast sendiri, router mengerti bahwa ada sesuatu yang salah di sini.  Dalam hal ini, router mengirim pesan tegas, yang mencakup Jarak Administratif dan metrik rute dimana sumber multicast tercapai - 10.1.1.10.  Pemenang ditentukan sebagai berikut: <br><ol><li>  Yang dengan AD lebih rendah. </li><li>  Jika AD sama, maka siapa yang memiliki metrik lebih rendah. </li><li>  Jika ada kesetaraan, maka yang memiliki IP lebih tinggi dalam jaringan yang mereka tayangkan multicast ini. </li></ol><br>  Memenangkan suara ini, router menjadi Router yang Ditunjuk.  Pim Hello juga digunakan untuk memilih DR.  Di awal artikel, pesan Halo PIM ditampilkan, di sana Anda dapat melihat bidang DR.  Pemenangnya adalah yang memiliki alamat IP lebih tinggi pada tautan ini. <br>  Piring yang berguna: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3de/e1a/c84/3dee1ac8448b1fceaa9f1972eff802b7.png" alt="Gambar saya"></a> <br>  <b>Tabel MROUTE.</b> <br>  Setelah tinjauan awal operasi protokol PIM, kita perlu mencari cara untuk bekerja dengan tabel routing multicast.  Tabel mroute menyimpan informasi tentang aliran mana yang diminta oleh klien dan aliran mana yang mengalir dari server multicast. <br>  Misalnya, ketika menerima Laporan Keanggotaan IGMP atau PIM Bergabung pada beberapa antarmuka, entri tipe (*, G) ditambahkan ke tabel routing: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/afd/3ed/52c/afd3ed52cef0f9f105a0b58dff18edee.jpg" alt="Gambar saya"></a> <br>  Entri ini berarti bahwa permintaan lalu lintas diterima dengan alamat 238.38.38.38.  Bendera DC berarti multicast akan berfungsi dalam mode Dense dan C berarti bahwa penerima terhubung langsung ke router, yaitu, router menerima Laporan Keanggotaan IGMP, dan PIM Bergabung. <br>  Jika ada catatan seperti (S, G) berarti kami memiliki aliran multicast: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a78/cf2/332/a78cf23325ddc6e0c3d65322340d7ff6.jpg" alt="Gambar saya"></a> <br>  Di bidang S - 192.168.1.11, kami telah mendaftarkan alamat IP sumber multicast, itu akan diperiksa oleh aturan RPF.  Jika terjadi masalah, hal pertama yang harus dilakukan adalah memeriksa tabel Unicast untuk rute ke sumber.  Di bidang Antarmuka Masuk menunjukkan antarmuka tempat kedatangan multicast.  Di tabel perutean unicast, rute ke sumber harus merujuk ke antarmuka yang ditentukan di sini.  Outgoing Interface menunjukkan di mana multicast akan dialihkan.  Jika kosong, maka tidak ada permintaan untuk lalu lintas ini ke router.  Informasi lebih lanjut tentang semua bendera dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br>  <b>Mode PIM Jarang.</b> <br>  Strategi mode Jarang adalah kebalikan dari mode Padat.  Ketika mode Jarang menerima lalu lintas multicast, itu akan mengirimkan lalu lintas hanya melalui antarmuka di mana ada permintaan untuk aliran ini, misalnya, pesan Pim Bergabung atau Laporan IGMP yang meminta lalu lintas ini. <br>  Elemen serupa untuk SM dan DM: <br><ul><li>  Hubungan tetangga dibangun dengan cara yang sama seperti di PIM DM. </li><li>  Aturan RPF berfungsi. </li><li>  Pilihan DR serupa. </li><li>  Mesin Prune Overrides dan pesan Assert serupa. </li></ul><br>  Untuk mengontrol siapa yang membutuhkan di mana, di mana, dan lalu lintas multicast apa yang diperlukan di jaringan, diperlukan pusat informasi umum.  Pusat seperti itu kita akan memiliki Rendezvous Point (RP).  Siapa pun yang menginginkan semacam lalu lintas multicast atau seseorang mulai menerima lalu lintas multicast dari sumbernya, lalu ia mengirimkannya ke RP. <br>  Ketika RP menerima lalu lintas multicast, ia akan mengirimkannya ke router yang sebelumnya meminta lalu lintas ini. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/025/d45/651/025d4565117dce5f8da07609c823c63e.jpg" alt="Gambar saya"></a> <br>  Bayangkan topologi seperti itu di mana RP adalah R3.  Segera setelah R1 menerima lalu lintas dari S1, ia merangkum paket multicast ini dalam pesan PIM Register unicast dan mengirimkannya ke RP.  Bagaimana dia tahu siapa itu RP?  Dalam hal ini, ini dikonfigurasi secara statis, dan kita akan berbicara tentang penyetelan RP dinamis nanti. <br><blockquote>  ip pim rp-address 3.3.3.3 </blockquote><br>  RP akan terlihat - apakah ada informasi dari seseorang yang ingin menerima lalu lintas ini?  Misalkan tidak.  Kemudian RP akan mengirimkan R1 pesan PIM Register-Stop, yang berarti tidak ada yang membutuhkan multicast ini, pendaftaran ditolak.  R1 tidak akan mengirim multicast.  Tetapi sumber multicast akan mengirimkannya, jadi R1, setelah menerima Register-Stop, akan memulai timer Register-Suppression, yaitu 60 detik.  5 detik sebelum waktu ini berakhir, R1 akan mengirim pesan Register kosong dengan bit Null-Register (yaitu, tanpa paket multicast enkapsulasi) ke sisi RP.  RP pada gilirannya akan bertindak seperti ini: <br><ul><li>  Jika tidak ada dan tidak ada penerima, maka itu akan merespons dengan pesan Register-Stop. </li><li>  Jika penerima muncul, maka ia tidak akan menjawabnya dengan cara apa pun.  R1, setelah tidak menerima penolakan untuk pendaftarannya dalam waktu 5 detik, akan senang dan akan mengirim Daftarkan pesan dengan multicast yang dienkapsulasi ke RP. </li></ul><br>  Ketika multicast mencapai RP, sepertinya akan beres, sekarang mari kita coba menjawab pertanyaan tentang bagaimana RP membawa lalu lintas ke penerima.  Di sini Anda perlu memperkenalkan konsep baru - root-path tree (RPT).  RPT adalah pohon dengan akar dalam RP yang tumbuh ke arah penerima yang bercabang pada setiap router PIM-SM.  RP membuatnya dengan menerima pesan PIM Gabung dan menambahkan cabang baru ke struktur pohon.  Dan begitu pula setiap router hilir.  Aturan umum terlihat seperti ini: <br><ul><li>  Ketika perute PIM-SM menerima pesan Gabung PIM pada antarmuka apa pun, kecuali untuk antarmuka tempat RP disembunyikan, ia menambah cabang baru ke struktur pohon. </li><li>  Cabang juga ditambahkan ketika router PIM-SM menerima Laporan Keanggotaan IGMP dari host yang terhubung langsung. </li></ul><br>  Bayangkan kita memiliki klien multicast di router R5 untuk grup 228.8.8.8.  Segera setelah R5 menerima Laporan Keanggotaan IGMP dari tuan rumah, R5 mengirimkan PIM Bergabung ke arah RP, dan itu sendiri menambahkan antarmuka melihat host ke pohon.  Selanjutnya, R4 menerima Gabung PIM dari R5, menambahkan antarmuka Gi0 / 1 ke pohon, dan mengirimkan Gabung PIM ke arah RP.  Akhirnya, RP (R3) menerima PIM Bergabung dan menambahkan Gi0 / 0 ke pohon.  Dengan demikian, pendaftaran penerima multicast diperoleh.  Kami sedang membangun pohon dengan root R3-Gi0 / 0 â†’ R4-Gi0 / 1 â†’ R5-Gi0 / 0. <br>  Setelah itu, PIM Join akan dikirim ke R1 dan R1 akan mulai mengirimkan lalu lintas multicast.  Penting untuk dicatat bahwa jika tuan rumah meminta lalu lintas sebelum penyiaran multicast dimulai, maka RP tidak akan mengirim PIM Bergabung dan tidak akan mengirim apa pun ke sisi R1 sama sekali. <br>  Jika tiba-tiba ketika multicast dikirim, tuan rumah berhenti ingin menerimanya, segera setelah RP menerima PIM Prune pada antarmuka Gi0 / 0, maka ia segera mengirimkan PIM Register-Stop langsung ke R1, dan kemudian pesan PIM Prune melalui antarmuka Gi0 / 1.  Pemberhentian Pendaftaran PIM dikirim oleh Unicast ke alamat asal pendaftaran PIM. <br>  Seperti yang kami katakan sebelumnya, segera setelah router mengirim Gabung PIM ke yang lain, misalnya, R5 pada R4, maka sebuah entri ditambahkan ke R4: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9f7/730/678/9f7730678743efb4e9670d18fcd54525.jpg" alt="Gambar saya"></a> <br>  Dan penghitung waktu memulai untuk mengatur ulang penghitung waktu ini, R5 harus terus-menerus PIM Bergabung pesan, jika tidak R4 akan dikeluarkan dari daftar keluar.  R5 akan mengirim setiap 60 pesan PIM Gabung. <br>  <b>Peralihan Pohon Jalur Terpendek.</b> <br>  Kami akan menambahkan antarmuka antara R1 dan R5, lihat bagaimana lalu lintas akan mengalir dengan topologi ini. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/afd/113/eb0/afd113eb01e7deda4c389fbb1a02060a.jpg" alt="Gambar saya"></a> <br>  Katakanlah lalu lintas dikirim dan diterima sesuai dengan skema lama R1-R2-R3-R4-R5 dan di sini kita terhubung dan mengkonfigurasi antarmuka antara R1 dan R5. <br>  Pertama-tama, kita harus membangun kembali tabel routing unicast pada R5 dan sekarang jaringan 192.168.1.0/24 dicapai melalui antarmuka R5 Gi0 / 2.  Sekarang, ketika R5 menerima multicast pada antarmuka Gi0 / 1, ia memahami bahwa aturan RPF tidak puas dan akan lebih logis untuk menerima multicast pada Gi0 / 2.  Ini harus terputus dari RPT dan membangun pohon yang lebih pendek yang disebut Shortest-Path Tree (SPT).  Untuk melakukan ini, melalui Gi0 / 2, ia mengirim PIM Bergabung ke R1 dan R1 mulai mengirim multicast melalui Gi0 / 2 juga.  Sekarang R5 harus berhenti berlangganan dari RPT, agar tidak mendapatkan dua salinan.  Untuk melakukan ini, ia mengirim pesan Prune yang menunjukkan alamat ip sumber dan memasukkan bit khusus - RPT-bit.  Ini berarti bahwa saya tidak perlu mengirim traffic, saya punya pohon yang lebih baik di sini.  RP juga mengirim pesan ke sisi P1 PIM Prune, tetapi tidak mengirim pesan Register-Stop.  Fitur lain: R5 sekarang akan terus-menerus mengirim PIM Prune ke RP, karena R1 terus mengirim PIM Register ke RP setiap menit.  RP sampai ada orang baru yang berharap lalu lintas ini akan menolaknya.  R5 memberi tahu RP bahwa ia terus menerima multicast melalui SPT. <br>  <b>Pencarian RP dinamis.</b> <b><br></b>  <b>RP-Otomatis</b> <br>  Teknologi ini adalah milik dari Cisco dan tidak terlalu populer, tetapi masih hidup.  Auto-RP terdiri dari dua langkah utama: <br>  1) RP mengirim pesan RP-Umumkan ke alamat yang dipesan - 224.0.1.39, menyatakan dirinya RP baik untuk semua atau untuk grup tertentu.  Pesan ini dikirim setiap menit. <br>  2) Diperlukan agen pemetaan RP yang akan mengirim pesan RP-Discovery yang menunjukkan kelompok mana yang akan didengarkan RP.  Dari pesan ini bahwa router PIM biasa akan menentukan RP sendiri.  Agen Pemetaan dapat berupa router RP itu sendiri atau router PIM lainnya.  RP-Discovery dikirim ke alamat 224.0.1.40 dengan penghitung waktu satu menit. <br>  Mari kita lihat prosesnya secara lebih rinci: <br>  Setel R3 sebagai RP: <br><blockquote>  ip pim send-rp-announce loopback 0 scope 10 </blockquote><br>  R2 sebagai agen pemetaan: <br><blockquote>  ip pim send-rp-discovery loopback 0 lingkup 10 </blockquote><br>  Dan pada yang lainnya, kita akan mengharapkan RP melalui Auto-RP: <br><blockquote>  pendengar autop ip pim </blockquote><br>  Setelah kami mengkonfigurasi R3, itu akan mulai mengirim RP-Umumkan: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aae/ae2/565/aaeae25659fbacd4ba49ae4c5486f46f.jpg" alt="Gambar saya"></a> <br>  Dan R2, setelah menyiapkan agen pemetaan, itu akan menunggu pesan RP-Umumkan.  Hanya ketika dia menemukan setidaknya satu RP akan dia mulai mengirim RP-Discovery: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/fb8/e44/7c2/fb8e447c26e33ecda18cb82c5f05c938.jpg" alt="Gambar saya"></a> <br>  Dengan demikian, segera setelah router reguler (PIM RP Listener) menerima pesan ini, mereka akan tahu ke mana harus mencari RP. <br>  Salah satu masalah utama dari RP-Otomatis adalah bahwa untuk menerima pesan RP-Umumkan dan RP-Penemuan, Anda perlu mengirim PIM Gabung ke alamat 224.0.1.39-40, dan untuk mengirim, Anda perlu tahu di mana RP-nya.  Masalah klasik ayam dan telur.  Untuk mengatasi masalah ini, PIM Sparse-Dense-Mode diciptakan.  Jika router tidak tahu RP, maka itu bekerja dalam mode padat, jika tahu, maka dalam mode jarang.  Ketika PIM Sparse-mode dan perintah pendengar ip pim autorp dikonfigurasi pada antarmuka router biasa, router akan bekerja dalam mode padat hanya untuk multicast langsung protokol Auto-RP langsung (224.0.1.39-40). <br>  <b>BootStrap Router (BSR).</b> <br>  Fungsi ini berfungsi mirip dengan Auto-RP.  Setiap RP mengirim pesan agen pemetaan, yang mengumpulkan informasi pemetaan dan kemudian memberitahu semua router lainnya.  Kami menggambarkan proses yang mirip dengan Auto-RP: <br>  1) Setelah kami mengkonfigurasi R3 sebagai kandidat untuk menjadi RP, perintah: <br><blockquote>  ip pim rp-kandidat loopback 0 </blockquote><br>  R3 itu tidak akan melakukan apa pun, untuk mulai mengirim pesan khusus, ia, pada awalnya, perlu menemukan agen pemetaan.  Jadi, kita lolos ke langkah kedua. <br>  2) Konfigurasikan R2 sebagai agen pemetaan: <br><blockquote>  ip pim bsr-kandidat loopback 0 </blockquote><br>  R2 mulai mengirim pesan PIM Bootstrap, di mana ia mengindikasikan dirinya sebagai agen pemetaan: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/729/3a4/ad1/7293a4ad164ed8342ff42ceffee9a32b.jpg" alt="Gambar saya"></a> <br>  Pesan ini dikirim ke alamat 224.0.013, yang digunakan protokol PIM untuk pesan lainnya.  Dia mengirim mereka ke segala arah dan karena itu tidak ada masalah ayam dan telur, seperti yang terjadi di Auto-RP. <br>  3) Segera setelah RP menerima pesan dari BSR router, RP akan segera mengirim pesan unicast ke alamat BSR router: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5ed/217/8c1/5ed2178c151886f79c1e6197b9b5385b.jpg" alt="Gambar saya"></a> <br>  Setelah itu, ketika BSR menerima informasi tentang RP, ia akan mengirimkannya dengan multicast ke alamat 224.0.0.13, yang didengarkan oleh semua router PIM.  Oleh karena itu, tidak ada analog dari <i>perintah pendengar ip pim autorp</i> untuk router biasa di BSR. <br>  <b>Anycast RP dengan Multicast Source Discovery Protocol (MSDP).</b> <br>  Auto-RP dan BSR memungkinkan kita untuk mendistribusikan beban pada RP sebagai berikut: Setiap grup multicast hanya memiliki satu RP aktif.  Ini tidak akan berfungsi untuk membuat distribusi beban untuk satu grup multicast beberapa RP.  MSDP melakukan ini dengan mengeluarkan router RP alamat ip yang sama dengan mask dari 255.255.255.255.  MSDP mengenali informasi menggunakan salah satu metode: statis, Auto-RP, atau BSR. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/406/51a/032/40651a032dadaaf6e0c51cbf06c3fbf3.png" alt="Gambar saya"></a> <br>  Pada gambar kita memiliki konfigurasi Auto-RP dengan MSDP.  Kedua RP dikonfigurasikan dengan alamat ip 172.16.1.1/32 pada antarmuka Loopback 1 dan digunakan untuk semua grup.  Ketika RP-Umumkan, kedua router berbicara tentang diri mereka sendiri, merujuk ke alamat ini.  Setelah menerima informasi, agen pemetaan Auto-RP mengirim RP-Discovery tentang RP dengan alamat 172.16.1.1/32.  Tentang jaringan 172.16.1.1/32, kami memberitahu router menggunakan IGP dan, masing-masing.  Dengan demikian, router PIM meminta atau mendaftar aliran dari RP yang ditunjukkan sebagai hop berikutnya pada rute ke jaringan 172.16.1.1/32.  Protokol MSDP sendiri dirancang untuk RP sendiri untuk bertukar pesan informasi multicast. <br>  Pertimbangkan topologi berikut: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2ba/f2d/dc4/2baf2ddc4deb54ebb671a6fb52282a41.jpg" alt="Gambar saya"></a> <br>  Switch6 menyiarkan lalu lintas ke alamat 238.38.38.38 dan sejauh ini hanya RP-R1 yang mengetahuinya.  Di sini Switch7 dan Switch8 meminta grup ini.  Router R5 dan R4 akan mengirim PIM Gabung ke R1 dan R3, masing-masing.  Mengapa  Rute sampai 13.13.13.13 pada R5 akan merujuk ke R1 sesuai dengan metrik IGP, seperti pada R4. <br>  RP-R1 tahu tentang aliran dan mulai menyiarkannya ke arah R5, tetapi R4 tidak tahu apa-apa tentang itu, karena R1 tidak akan mengirimnya.  Karena itu, MSDP diperlukan.  Kami mengkonfigurasinya pada R1 dan R5: <br><blockquote>  ip msdp peer 3.3.3.3 Hubungkan-sumber Loopback1 pada R1 </blockquote><br><blockquote>  ip msdp peer 1.1.1.1 Hubungkan-sumber Loopback3 pada R3 </blockquote><br>  Mereka akan mengajukan sesi antara satu sama lain dan setelah menerima aliran apa pun akan melaporkannya ke tetangga RP mereka. <br>  RP-R1 segera setelah menerima aliran dari Switch6, ia akan segera mengirim Unicast MSDP Source-Active pesan yang berisi informasi seperti (S, G) - informasi tentang sumber dan tujuan multicast.  Sekarang, ketika RP-R3 tahu bahwa sumber seperti Switch6, ketika menerima permintaan dari R4 untuk aliran ini, itu akan mengirim ke Switch6 PIM Bergabung, dipandu oleh tabel routing.  Oleh karena itu, R1 yang telah menerima PIM Bergabung, akan mulai mengirim lalu lintas ke RP-R3. <br>  MSDP berjalan melalui TCP, RP mengirim pesan keepalive satu sama lain untuk memverifikasi kelayakan.  Pengatur waktunya 60 detik. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi membagi rekan-rekan MSDP ke dalam domain yang berbeda tetap tidak dapat dipahami, karena pesan Keepalive dan SA tidak mengindikasikan milik domain apa pun. </font><font style="vertical-align: inherit;">Juga, dalam topologi ini, konfigurasi diuji dengan indikasi berbagai domain - tidak ada perbedaan dalam operasi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika seseorang dapat mengklarifikasi, dengan senang hati baca di komentar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya pikir ini untuk menyelesaikan artikel. </font><font style="vertical-align: inherit;">Di bawah ini adalah bahan dan tautan berguna yang digunakan:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Routing dan Switching CCIE v5.0 Panduan Cert Resmi, Volume 2, Edisi Kelima, Narbik Kocharians, Terry Vinson. </font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jaringan untuk yang terkecil. </font><font style="vertical-align: inherit;">Bagian sembilan. </font><font style="vertical-align: inherit;">Multicast</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450582/">https://habr.com/ru/post/id450582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450568/index.html">Setiap racun memiliki penawarnya sendiri. Bagaimana cara menyimpan atau setidaknya mencoba (upd: tentang penangkal racun rumah tangga)</a></li>
<li><a href="../id450572/index.html">Samba DC sebagai pengontrol kedua di domain AD Windows 2012R2 dan folder roaming untuk klien di Windows dan Linux</a></li>
<li><a href="../id450574/index.html">Buat multiplayer .io web game</a></li>
<li><a href="../id450576/index.html">Aturan baru untuk anonimitas messenger</a></li>
<li><a href="../id450578/index.html">Apa yang terdengar di udara? Kami menerima dan mendekode sinyal yang paling menarik. Bagian 2, VHF</a></li>
<li><a href="../id450586/index.html">Fish Redux - Perpustakaan Redux Baru untuk Flutter</a></li>
<li><a href="../id450592/index.html">Di Jerman, biaya perjalanan dengan mobil listrik mungkin lebih tinggi daripada mobil diesel</a></li>
<li><a href="../id450594/index.html">Fibonacci genap angka</a></li>
<li><a href="../id450596/index.html">11. Titik Periksa Memulai R80.20. Kebijakan pencegahan ancaman</a></li>
<li><a href="../id450598/index.html">Tentang "hujan kuning" dan "agen oranye"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>