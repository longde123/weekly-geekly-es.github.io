<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏽 🤴🏿 📯 Serveur client transparent 💲 👩🏼‍🤝‍👩🏻 👩🏿‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout projet client-serveur implique une séparation claire de la base de code en 2 parties (parfois plus) - client et serveur. Souvent, chacune de ces ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serveur client transparent</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435494/"><img src="https://habrastorage.org/webt/rq/-9/mh/rq-9mhais2g6p5dd5tsfv8rllak.jpeg" align="left">  Tout projet client-serveur implique une séparation claire de la base de code en 2 parties (parfois plus) - client et serveur.  Souvent, chacune de ces parties est exécutée sous la forme d'un projet indépendant distinct, soutenu par sa propre équipe de développeurs. <br><br>  Dans cet article, je propose un regard critique sur la division matérielle standard du code en un backend et un frontend.  Et considérez une alternative où le code n'a pas de ligne claire entre le client et le serveur. <br><br><a name="habracut"></a><br><br><h3>  Inconvénients de l'approche standard </h3><br>  Le principal inconvénient de la séparation standard du projet en 2 parties est l'érosion de la logique métier entre le client et le serveur.  Nous modifions les données du formulaire dans le navigateur, les vérifions dans le code client et les envoyons au village du grand-père (au serveur).  Le serveur est déjà un autre projet.  Là, vous devez également vérifier l'exactitude des données reçues (c'est-à-dire dupliquer les fonctionnalités du client), effectuer des manipulations supplémentaires (enregistrer dans la base de données, envoyer des e-mails, etc.). <br><br>  Ainsi, afin de tracer tout le chemin des informations depuis le formulaire dans le navigateur jusqu'à la base de données sur le serveur, nous devons plonger dans deux systèmes différents.  Si les rôles sont divisés en équipe et que différents spécialistes sont responsables du backend et du frontend, des problèmes d'organisation supplémentaires surviennent liés à leur synchronisation. <br><br><h3>  Rêvons </h3><br>  Supposons que nous puissions décrire le chemin de données entier du formulaire sur le client à la base de données sur le serveur dans un modèle.  Dans le code, cela peut ressembler à ceci (le code ne fonctionne pas): <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyDataModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         verifyData(data) { //   .... return true; } //       client saveData(data) { if(this.verifyData(data)) this.writeDataToDb(data) else consol.log('error') } //  .     server writeDataToDb(data) { if(this.verifyData(data)) this.db.insert(data) else consol.log('error') } }</span></span></code> </pre> <br>  Ainsi, toute la logique métier du modèle est sous nos yeux.  La gestion d'un tel code est plus facile.  Voici les avantages que la combinaison de méthodes client-serveur dans un modèle peut apporter: <br><br><ol><li>  La logique métier est concentrée en un seul endroit, il n'est pas nécessaire de la partager entre le client et le serveur. </li><li>  Vous pouvez facilement transférer des fonctionnalités du serveur au client ou du client au serveur pendant le développement du projet. </li><li>  Il n'est pas nécessaire de dupliquer les mêmes méthodes pour le backend et le frontend. </li><li>  Un seul ensemble de tests pour toute la logique métier du projet. </li><li>  Remplacement des lignes horizontales de délimitation des responsabilités dans le projet par des lignes verticales. </li></ol><br>  Je vais révéler le dernier point plus en détail.  Imaginez une application client-serveur classique sous la forme d'un tel schéma: <br><br><img src="https://habrastorage.org/webt/8x/c9/de/8xc9degimzw-w-ln5w2ihiybi6w.jpeg" width="400"><br><br>  Vasya est responsable du frontend, Fedya - du backend.  La ligne de délimitation des responsabilités est horizontale.  Ce schéma présente les inconvénients de toute structure verticale - il est difficile à mettre à l'échelle et a une faible tolérance aux pannes.  Si le projet prend de l'ampleur, vous devrez faire un choix assez difficile: qui renforcer Vasya ou Fedya?  Ou si Fedya est tombé malade ou a démissionné, Vasya ne pourra pas le remplacer. <br><br>  L'approche proposée ici vous permet d'élargir la ligne de partage des responsabilités de 90 degrés et de transformer l'architecture verticale en horizontale. <br><br><img src="https://habrastorage.org/webt/v6/4m/9f/v64m9fuv5sonujosvh4yc4v8vbw.jpeg" width="400"><br><br>  Une telle architecture est beaucoup plus facile à mettre à l'échelle et plus tolérante aux pannes.  Vasya et Fedya deviennent interchangeables. <br><br>  En théorie, cela semble bon, essayons d'implémenter tout cela dans la pratique, sans perdre tout ce qui nous donne l'existence séparée du client et du serveur en cours de route. <br><br><h3>  Énoncé du problème </h3><br>  Nous n'avons absolument pas besoin d'avoir un serveur client intégré dans le produit.  Au contraire, une telle décision serait extrêmement préjudiciable à tous points de vue.  La tâche est que dans le processus de développement, nous aurions une base de code unique pour les modèles de données pour le backend et le frontend, mais la sortie serait un client et un serveur indépendants.  Dans ce cas, nous bénéficierons de tous les avantages de l'approche standard et bénéficierons des équipements listés ci-dessus pour le développement et l'accompagnement du projet. <br><br><h3>  Solution </h3><br>  J'expérimente avec l'intégration du client et du serveur dans un fichier depuis un certain temps.  Jusqu'à récemment, le problème principal était que dans JS standard, la connexion des modules tiers sur le client et le serveur était trop différente: nécessite (...) dans node.js, toute la magie AJAX sur le client.  Tout a changé avec l'avènement des modules ES.  Dans les navigateurs modernes, «l'importation» est prise en charge depuis longtemps.  Node.js est légèrement en retard à cet égard et les modules ES ne sont pris en charge qu'avec le drapeau "--experimental-modules" activé.  On espère que dans un avenir prévisible, les modules fonctionneront hors de la boîte dans node.js.  En outre, il est peu probable que quelque chose change beaucoup, car  dans les navigateurs, cette fonctionnalité fonctionne depuis longtemps par défaut.  Je pense que maintenant vous pouvez utiliser les modules ES non seulement côté client mais aussi côté serveur (si vous avez des contre-arguments à ce sujet, écrivez dans les commentaires). <br><br>  Le schéma de solution ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/xo/_a/vi/xo_avikvz1udp9-dwhxfe6ypt-q.png" width="600"><br><br>  Le projet contient trois catalogues principaux: <br><br>  <b>protégé</b> - backend; <br>  <b>public</b> - frontend; <br>  <b>shared</b> - modèles client-serveur partagés. <br><br>  Un processus d'observation distinct surveille les fichiers dans le répertoire partagé et, avec toutes les modifications, crée des versions du fichier modifié séparément pour le client et séparément pour le serveur (dans les répertoires protégé / partagé et public / partagé). <br><br><h3>  Implémentation </h3><br>  Prenons l'exemple d'un simple messager en temps réel.  Nous aurons besoin de nouveaux node.js (j'ai la version 11.0.0) et Redis (les installer n'est pas couvert ici). <br><br>  Clonez un exemple: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/Kolbaskin/both-example <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ./both-example npm i</code> </pre><br>  Installez et exécutez le processus d'observation (observateur dans le diagramme): <br><br><pre> <code class="bash hljs">npm i both-js -g both ./index.mjs</code> </pre><br>  Si tout est en ordre, l'observateur lance le serveur Web et commence à surveiller les modifications apportées aux fichiers dans les répertoires partagés et protégés.  Lorsque des modifications sont apportées au partage, les versions correspondantes des modèles de données pour le client et le serveur sont créées.  En cas de modification de la protection, l'observateur redémarre automatiquement le serveur Web. <br><br>  Vous pouvez voir les performances du messager dans le navigateur en cliquant sur le lien <br><br> <code>http://localhost:3000/index.html?token=123&amp;user=Vasya</code> <br> <br>  (le jeton et l'utilisateur sont arbitraires).  Pour émuler plusieurs utilisateurs, ouvrez la même page dans un autre navigateur en spécifiant un jeton et un utilisateur différents. <br><br>  Maintenant un petit code. <br><br><h4>  Serveur Web </h4><br>  protected / server.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'body-parser'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// -     //  -  import wsServer from './lib/wsServer.mjs'; const app = express(); //   - wsServer(app); //  mime  mjs express.static.mime.define({'application/javascript': ['js','mjs']}); app.use( bodyParser.json() ); app.use(bodyParser.urlencoded({ extended: true })); //      public app.use(express.static('public')); const server = app.listen(3000, () =&gt; { console.log('server is running at %s', server.address().port); });</span></span></code> </pre><br>  Il s'agit d'un serveur express régulier, il n'y a rien d'intéressant ici.  L'extension mjs est nécessaire pour les modules ES dans node.js.  Par souci de cohérence, nous utiliserons cette extension pour le client. <br><br><h4>  Client </h4><br>  public / index.html <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lang</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"en"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/main.mjs"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"users"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-for</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user in users"</span></span></span><span class="hljs-tag">&gt;</span></span> {{ user.name }} ({{user.id}}) <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"messages"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"msg"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sendMessage()"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-for</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"message in messages"</span></span></span><span class="hljs-tag">&gt;</span></span>[{{ message.date }}] <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>{{ message.text }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Par exemple, j'utilise Vue sur le client, mais cela ne change pas l'essence.  Au lieu de Vue, il peut y avoir n'importe quoi où vous pouvez séparer le modèle de données dans une classe distincte (knockout, angular). <br><br>  public / main.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      - import ws from "/lib/Ws.mjs"; //       import Messages from "./shared/messages/model/dataModel.mjs"; //    import Users from "./shared/users/model/dataModel.mjs"; //  - (     ) window.WS = new ws({ token: new URLSearchParams(document.location.search).get("token"), user: new URLSearchParams(document.location.search).get("user") }); //       new Messages({ el: '#messages' }) //       new Users({ el: '#users' })</span></span></code> </pre><br>  main.mjs est un script qui associe les modèles de données aux vues correspondantes.  Pour simplifier le code, des exemples de représentations pour la liste des utilisateurs actifs et les flux de messages sont intégrés directement dans index.html <br><br><h4>  Modèle de données </h4><br>  partagé / messages / model / dataModel.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    //          , //    import Base from '@root/lib/Base.mjs'; export default class dataModel extends Base { //!#client constructor(attr) { attr.data = { msg: '', messages: [] } super(attr); //     this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } //!#client async sendMessage(e) { //    await this.$sendMessage(this.msg); this.msg = ''; } //!#server async $sendMessage(text) { //   newmessage     this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } }</span></span></code> </pre><br>  Ces différentes méthodes implémentent toutes les fonctionnalités d'envoi et de réception de messages en temps réel.  Les directives! #Client et! #Server indiquent au processus d'observation quelle méthode pour quelle partie (client ou serveur) est destinée.  S'il n'y a pas ces directives avant de définir une méthode, une telle méthode est disponible à la fois sur le client et sur le serveur.  Les barres obliques de commentaire avant la directive sont facultatives et n'existent que pour empêcher l'IDE standard de jurer lors d'erreurs de syntaxe. <br><br>  La première ligne du chemin utilise la recherche &amp; root.  Lors de la génération des versions client et serveur, &amp; root sera remplacé par le chemin relatif vers les répertoires public et protégé, respectivement. <br><br>  Autre point important: à partir de la méthode client, vous ne pouvez appeler que la méthode serveur, dont le nom commence par "$": <br><br><pre> <code class="javascript hljs">... <span class="hljs-comment"><span class="hljs-comment">//    async sendMessage(e) { await this.$sendMessage(this.msg); &lt;-    this.msg = ''; } ...</span></span></code> </pre><br>  Cela se fait pour des raisons de sécurité: de l'extérieur, vous ne pouvez vous tourner que vers des méthodes spécialement conçues pour cela. <br><br>  Examinons les versions des modèles de données que l'observateur a générés pour le client et le serveur. <br><br>  <b>Client</b> (public / partagé / messages / modèle / dataModel.mjs) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/lib/Base.mjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dataModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ __getFilePath__() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"messages/model/dataModel.mjs"</span></span>} <span class="hljs-comment"><span class="hljs-comment">// constructor(attr) { attr.data = { msg: '', messages: [] } super(attr); //     this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } // async sendMessage(e) { //    await this.$sendMessage(this.msg); this.msg = ''; } // ... async $sendMessage() {return await this.__runSharedFunction("$sendMessage",arguments)} }</span></span></code> </pre><br>  Côté client, le modèle est un descendant de la classe Vue (via Base.mjs).  Ainsi, vous pouvez travailler avec lui comme avec un modèle de données Vue standard.  L'observateur a ajouté la méthode __getFilePath__ à la version client du modèle, qui renvoie le chemin d'accès au fichier de classe et remplace le code de méthode du serveur $ sendMessage par une construction qui, par essence, appellera la méthode dont nous avons besoin sur le serveur via le mécanisme rpc (__runSharedFunction est défini dans la classe parente). <br><br>  <b>Serveur</b> (protégé / partagé / messages / modèle / dataModel.mjs) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../lib/Base.mjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dataModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ __getFilePath__() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"messages/model/dataModel.mjs"</span></span>} ...       ... <span class="hljs-comment"><span class="hljs-comment">// async $sendMessage(text) { //   newmessage     this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } }</span></span></code> </pre><br>  Dans la version serveur, la méthode __getFilePath__ a également été ajoutée et les méthodes client marquées avec la directive ont été supprimées! #Client <br><br>  Dans les deux versions générées du modèle, toutes les lignes supprimées sont remplacées par des lignes vides.  Ceci est fait pour que le message d'erreur sur le débogueur puisse facilement trouver la ligne problématique dans le code source du modèle. <br><br><h4>  Interaction client-serveur </h4><br>  Lorsque nous devons appeler une méthode serveur sur le client, nous le faisons simplement. <br>  Si l'appel est dans le même modèle, alors tout est simple: <br><br><pre> <code class="javascript hljs">... !#client <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> sendMessage(e) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$sendMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.msg); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.msg = <span class="hljs-string"><span class="hljs-string">''</span></span>; } !#server <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> $sendMessage(msg) { <span class="hljs-comment"><span class="hljs-comment">// -    } ...</span></span></code> </pre><br>  Vous pouvez «tirer» un autre modèle: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"/shared/messages/model/dataModel.mjs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> dataModel(); msg.$sendMessage(<span class="hljs-string"><span class="hljs-string">'blah-blah-blah'</span></span>);</code> </pre><br>  Dans la direction opposée, c'est-à-dire  L'appel d'une méthode client sur le serveur ne fonctionne pas.  Techniquement, c'est faisable, mais d'un point de vue pratique, cela n'a aucun sens, car  le serveur est un, mais il y a beaucoup de clients.  Si nous devons lancer certaines actions sur le serveur sur le client, nous utilisons le mécanisme d'événement: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    ... //!#client constructor(attr) { .... //       "newmessage" this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } //!#server async $sendMessage(text) { //     newmessage     this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } ...</span></span></code> </pre><br>  La méthode fireEvent prend 3 paramètres: le nom de l'événement, à qui il est adressé et les données.  Vous pouvez définir le destinataire de plusieurs manières: mot-clé «tous» - l'événement sera envoyé à tous les utilisateurs ou dans le tableau pour répertorier les jetons de session des clients auxquels l'événement est adressé. <br><br>  L'événement n'est pas lié à une instance spécifique de la classe de modèle de données et les gestionnaires se déclencheront dans toutes les instances de la classe dans laquelle fireEvent a été appelé. <br><br><h4>  Mise à l'échelle horizontale du backend </h4><br>  La monolithicité des modèles client-serveur dans l'implémentation proposée, à première vue, devrait imposer des restrictions importantes sur la possibilité d'une mise à l'échelle horizontale de la partie serveur.  Mais ce n'est pas le cas: techniquement, le serveur est indépendant du client.  Vous pouvez copier le répertoire «public» n'importe où et donner son contenu via n'importe quel autre serveur Web (nginx, apache, etc.). <br><br>  Le côté serveur peut être facilement étendu en lançant de nouvelles instances backend.  Redis et le système de file d'attente Kue sont utilisés pour interagir avec des instances individuelles. <br><br><h4>  API et différents clients sur un seul backend </h4><br>  Dans les projets réels, divers clients serveurs peuvent utiliser une API serveur - sites Web, applications mobiles, services tiers.  Dans la solution proposée, tout cela est disponible sans aucune danse supplémentaire.  Sous le capot des méthodes de serveur d'appel se trouve le bon vieux rpc.  Le serveur Web lui-même est une application express classique.  Il suffit d'y ajouter un wrapper pour les routes avec appel des méthodes nécessaires des mêmes modèles de données. <br><br><h4>  Post scriptum </h4><br>  L'approche proposée dans l'article ne prétend aucun changement révolutionnaire dans les applications client-serveur.  Il ajoute seulement un peu de confort au processus de développement, vous permettant de vous concentrer sur une logique métier assemblée en un seul endroit. <br><br>  Ce projet est expérimental, écrivez dans les commentaires si, à votre avis, cela vaut la peine de poursuivre cette expérience. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435494/">https://habr.com/ru/post/fr435494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435480/index.html">Microsoft et Kroger vont combattre Amazon dans le domaine ... le commerce des aliments</a></li>
<li><a href="../fr435482/index.html">Zircon Highlight: vDSO (Virtual Dynamic Shared Object)</a></li>
<li><a href="../fr435484/index.html">Style de fuzz 1989</a></li>
<li><a href="../fr435488/index.html">Mocks, stubs and spies in the Spock Framework</a></li>
<li><a href="../fr435490/index.html">Modifications fiscales de Google en 2019</a></li>
<li><a href="../fr435496/index.html">Tesla poursuivi pour un accident dans lequel le conducteur et le passager de la Model S sont morts</a></li>
<li><a href="../fr435498/index.html">vCloud Director Extender: Migration</a></li>
<li><a href="../fr435500/index.html">Gants biométriques en sport automobile</a></li>
<li><a href="../fr435502/index.html">L'étude a révélé les avantages et les inconvénients du perfectionnisme</a></li>
<li><a href="../fr435504/index.html">Des monstres à la main dans la lutte pour la propreté: sélection d'un aspirateur manuel Xiaomi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>