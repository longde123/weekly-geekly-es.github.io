<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèø üîÉ üñêüèª Toute la v√©rit√© sur RTOS. Article # 28. Minuteries logicielles ü•ê üöî ‚õ∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'id√©e des minuteries logicielles a √©t√© pr√©sent√©e dans un article pr√©c√©dent . Ce sont des objets du noyau qui fournissent des t√¢ches avec un moyen sim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la v√©rit√© sur RTOS. Article # 28. Minuteries logicielles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455072/">  L'id√©e des minuteries logicielles a √©t√© pr√©sent√©e dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent</a> .  Ce sont des objets du noyau qui fournissent des t√¢ches avec un moyen simple de d√©clencher des √©v√©nements √† temps, ou, le plus souvent, un moyen d'effectuer des actions sur une base r√©guli√®re.  Tous les d√©tails de la fonctionnalit√© li√©e au temps (pr√©cision, gestion des interruptions, etc.) dans Nucleus SE ont √©t√© discut√©s dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent</a> . <br><br><img src="https://habrastorage.org/webt/xu/5v/_s/xu5v_sdm50mq9i1ywof_lgsvqkw.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Articles pr√©c√©dents de la s√©rie:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Heure syst√®me</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux: services auxiliaires et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Canaux de donn√©es: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: services auxiliaires et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Files d'attente: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bo√Ætes aux lettres: services auxiliaires et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bo√Ætes aux lettres: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S√©maphores: services auxiliaires et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S√©maphores: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes d'indicateurs d'√©v√©nements: services d'assistance et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Groupes de drapeaux d'√©v√©nements: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signaux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partitions de m√©moire: services et structures de donn√©es</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sections de m√©moire: introduction et services de base</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Structures de donn√©es de t√¢che et appels d'API non pris en charge</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Services pour travailler avec des t√¢ches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches: configuration et introduction √† l'API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: fonctionnalit√©s avanc√©es et pr√©servation du contexte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: impl√©mentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: conception interne et d√©ploiement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres services RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des t√¢ches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps r√©el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <br></div></div><br><h2>  Utilisation de minuteries </h2><br>  Les temporisateurs de programme peuvent √™tre configur√©s pour se d√©clencher une fois, c'est-√†-dire qu'ils d√©marrent, puis, apr√®s une p√©riode de temps sp√©cifi√©e, mettent simplement fin au cycle.  Ou la minuterie peut √™tre configur√©e pour red√©marrer: une fois le d√©compte termin√©, la minuterie red√©marre automatiquement.  La dur√©e de fonctionnement apr√®s un red√©marrage peut diff√©rer de la dur√©e de fonctionnement initiale.  De plus, la minuterie peut √©ventuellement √™tre configur√©e pour ex√©cuter une fonction de terminaison sp√©ciale, qui est ex√©cut√©e lorsque (ou chaque fois) la minuterie termine le cycle de travail. <br><br><h2>  Param√®tres de la minuterie </h2><br><h3>  Nombre de minuteries </h3><br>  Comme pour la plupart des aspects de Nucleus SE, les param√®tres du minuteur sont contr√¥l√©s par les directives <b>#define</b> dans <b>nuse_config.h</b> .  Le param√®tre principal est <b>NUSE_TIMER_NUMBER</b> , qui d√©finit les temporisateurs configur√©s dans l'application.  Par d√©faut, cette valeur est z√©ro (c'est-√†-dire que les minuteries ne sont pas utilis√©es dans l'application) et peut prendre des valeurs jusqu'√† 16. Une valeur incorrecte entra√Ænera une erreur de compilation, qui sera g√©n√©r√©e en <b>archivant le</b> fichier <b>nuse_config_check.h</b> (ce fichier est inclus dans <b>nuse_config.c</b> et compile avec elle), ce qui d√©clenchera la directive <b>#error</b> . <br><br>  La s√©lection d'une valeur diff√©rente de z√©ro est l'activateur principal du minuteur.  Ce param√®tre est utilis√© lors de la d√©finition des structures de donn√©es et leur taille d√©pend de sa valeur.  De plus, une valeur diff√©rente de z√©ro active les param√®tres de l'API. <br><br><h3>  Activation de la fonction d'ach√®vement </h3><br>  Dans Nucleus SE, j'ai essay√© de trouver l'opportunit√© de rendre la fonctionnalit√© facultative, o√π cela √©conomisera de la m√©moire.  Un bon exemple est la prise en charge des fonctions de fin de temporisation.  Outre le fait que cette fonctionnalit√© est facultative pour chaque temporisateur, le m√©canisme peut √™tre activ√© (ou non) pour l'ensemble de l'application √† l'aide du param√®tre <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> dans <b>nuse_config.h</b> .  La d√©finition de ce param√®tre sur <b>FALSE</b> bloque la d√©finition de deux structures de donn√©es dans la ROM, qui seront d√©crites en d√©tail dans cet article. <br><br><h3>  Activation de l'API </h3><br>  Chaque fonction API (appel d'utilitaire) dans Nucleus SE a la directive d'activation #define dans nuse_config.h.  Pour les minuteries, ces symboles incluent: <br>  <b>NUSE_TIMER_CONTROL</b> <b><br></b>  <b>NUSE_TIMER_GET_REMAINING</b> <b><br></b>  <b>NUSE_TIMER_RESET</b> <b><br></b>  <b>NUSE_TIMER_INFORMATION</b> <b><br></b>  <b>NUSE_TIMER_COUNT</b> <br><br>  Par d√©faut, tous les activateurs sont d√©finis sur <b>FALSE</b> , donc tous les appels de service sont d√©sactiv√©s, bloquant l'inclusion de code qui les impl√©mente.  Pour configurer des minuteurs dans l'application, vous devez s√©lectionner les appels de service API n√©cessaires et les d√©finir sur <b>VRAI</b> . <br><br>  Voici un extrait de code du fichier <b>nuse_config.h</b> par d√©faut. <br><br><pre><code class="plaintext hljs">#define NUSE_TIMER_NUMBER 0/*      0-16 */ /*    */ #define NUSE_TIMER_CONTROL FALSE #define NUSE_TIMER_GET_REMAINING FALSE #define NUSE_TIMER_RESET FALSE #define NUSE_TIMER_INFORMATION FALSE #define NUSE_TIMER_COUNT FALSE</code> </pre> <br>  Si la fonction API li√©e √† la minuterie est activ√©e et qu'il n'y a pas de temporisation configur√©e dans l'application (√† l'exception de la fonction <b>NUSE_Timer_Count ()</b> , qui est toujours activ√©e), une erreur de compilation se produit.  Si votre code utilise un appel d'API qui n'a pas √©t√© activ√©, une erreur de mise en page se produira car le code d'impl√©mentation n'√©tait pas inclus dans l'application. <br><br><h2>  Appels de service de minuterie </h2><br>  Nucleus RTOS prend en charge huit appels d'utilitaire li√©s √† la minuterie qui offrent les fonctionnalit√©s suivantes: <br><br><ul><li>  Minuterie de gestion (d√©marrage / arr√™t).  Nucleus SE est impl√©ment√© dans la fonction <b>NUSE_Timer_Control ()</b> . </li><li>  R√©cup√©ration du temps restant du minuteur.  Dans Nucleus SE, impl√©ment√© dans <b>NUSE_Timer_Get_Remaining ()</b> . </li><li>  Restauration de la minuterie √† son √©tat d'origine (r√©initialisation).  Nucleus SE impl√©ment√© dans <b>NUSE_Timer_Reset ()</b> . </li><li>  Fournir des informations sur une minuterie sp√©cifique.  Nucleus SE est impl√©ment√© dans <b>NUSE_Timer_Information ()</b> . </li><li>  Renvoie le nombre de temporisations configur√©es (actuellement) dans l'application.  Nucleus SE est impl√©ment√© dans <b>NUSE_Timer_Count ()</b> . </li><li>  Ajout d'un nouveau timer √† l'application (cr√©ation).  Nucleus SE n'est pas impl√©ment√©. </li><li>  Suppression d'une minuterie de l'application.  Nucleus SE n'est pas impl√©ment√©. </li><li>  Renvoyer des pointeurs √† tous les temporisateurs de l'application.  Nucleus SE n'est pas impl√©ment√©. </li></ul><br>  La mise en ≈ìuvre de chaque appel de service sera discut√©e en d√©tail ci-dessous. <br><br><h2>  Services de minuterie </h2><br>  Les op√©rations fondamentales qui peuvent √™tre effectu√©es avec une minuterie sont le contr√¥le (d√©marrage et arr√™t) et la lecture de la valeur actuelle.  Nucleus RTOS et Nucleus SE fournissent deux appels d'utilitaire API de base pour ces op√©rations. <br><br><h3>  Contr√¥le de la minuterie </h3><br>  Un appel utilitaire √† l'API Nucleus RTOS pour contr√¥ler la minuterie vous permet d'activer et de d√©sactiver la minuterie (d√©marrage et arr√™t).  Nucleus SE offre des fonctionnalit√©s similaires. <br><br>  <b><i>Timer Control Challenge dans Nucleus RTOS</i></b> <br>  Prototype d'appel de service: <br><br>  <b>STATUS NU_Control_Timer (minuterie NU_TIMER *, validation OPTION);</b> <br><br>  Param√®tres: <br>  <b>minuterie</b> - pointeur vers le bloc de commande de minuterie fourni par l'utilisateur; <br>  <b>enable</b> est la fonction requise; elle peut prendre les valeurs <b>NU_ENABLE_TIMER</b> ou <b>NU_DISABLE_TIMER</b> . <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INAVLID_TIMER</b> - pointeur de temporisateur invalide; <br>  <b>NU_INAVLID_ENABLE</b> - fonction non valide. <br><br>  <b><i>Timer Control Challenge dans Nucleus SE</i></b> <br>  Cet appel d'API prend en charge toutes les fonctionnalit√©s de l'API RTOS Nucleus. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NUSE_Timer_Control (temporisateur NUSE_TIMER, activation OPTION);</b> <br><br>  Param√®tres: <br>  <b>timer</b> - index (ID) du timer utilis√©; <br>  <b>enable</b> est la fonction requise; elle peut prendre les valeurs <b>NUSE_ENABLE_TIMER</b> ou <b>NUSE_DISABLE_TIMER</b> . <br><br>  Valeur de retour: <br>  <b>NUSE_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NUSE_INCALID_TIMER</b> - index de temporisateur invalide; <br>  <b>NUSE_INVALID_ENABLE</b> est une fonction non valide. <br><br>  <b><i>Impl√©menter la gestion du minuteur dans Nucleus SE</i></b> <br>  Le code de fonction API <b>NUSE_Timer_Control ()</b> (apr√®s v√©rification des param√®tres) est assez simple: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; if (NUSE_Timer_Expirations_Counter[timer] == 0) { NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; } else { NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } } else /* enable == NUSE_DISABLE_TIMER */ { NUSE_Timer_Status[timer] = FALSE; } NUSE_CS_Exit();</code> </pre><br>  Si la fonction <b>NUSE_DISABLE_TIMER a</b> √©t√© sp√©cifi√©e, l'√©tat du temporisateur (param√®tre <b>NUSE_Timer_Status []</b> ) est d√©fini sur <b>FALSE</b> , ce qui ignore le temporisateur par le gestionnaire d'interruption. <br><br>  Lorsque vous s√©lectionnez la fonction <b>NUSE_ENABLE_TIMER,</b> le compteur du minuteur ( <b>NUSE_Timer_Value []</b> ) est d√©fini sur <b>NUSE_Timer_initial_Time []</b> , √† condition que le minuteur ne se soit jamais arr√™t√© depuis la derni√®re r√©initialisation.  Sinon, la valeur <b>NUSE_Timer_Reschedule_Time []</b> lui est affect√©e.  Ensuite, l'√©tat du temporisateur (param√®tre <b>NUSE_Timer_Status []</b> ) est d√©fini sur <b>TRUE</b> , ce qui entra√Æne le traitement du temporisateur par le gestionnaire d'interruption. <br><br><h3>  Lecture programm√©e </h3><br>  Pour obtenir le temps de temporisation restant, l'appel de service API Nucleus RTOS renvoie le nombre de mesures jusqu'√† son expiration.  Nucleus SE offre des fonctionnalit√©s similaires. <br><br>  <b><i>Appelez pour obtenir le temps restant dans Nucleus RTOS</i></b> <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Get_Remaining_Time (minuterie NU_TIMER *, UNSIGNED * temps_reste);</b> <br><br>  Param√®tres: <br>  <b>minuterie</b> - pointeur vers le bloc de commande de minuterie fourni par l'utilisateur; <br>  <b>restant_heure</b> - un pointeur vers le stockage de la valeur de temps restant, qui est une variable de type <b>UNSIGNED</b> . <br><br>  Valeur de retour <br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_TIMER</b> - pointeur de temporisateur non valide. <br><br>  <b><i>Appelez pour obtenir le temps restant dans Nucleus SE</i></b> <br>  Cet appel d'API prend en charge toutes les fonctionnalit√©s de l'API RTOS Nucleus. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NUSE_Timer_Get_Remaining (temporisateur NUSE_TIMER, U16 * temps_ restant);</b> <br><br>  Param√®tres: <br>  <b>timer</b> - index (ID) du timer utilis√©; <br>  <b>reste_heure</b> - pointeur vers le stockage de la valeur de temps restant, qui est une variable de type <b>U16</b> . <br><br>  Valeur de retour: <br>  <b>NUSE_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NUSE_INVALID_TIMER</b> - index de temporisateur non valide; <br>  <b>NUSE_INVALID_POINTER</b> - pointeur nul sur le temps restant ( <b>NULL</b> ). <br><br>  <b><i>Impl√©mentation d'une lecture par minuterie dans Nucleus SE</i></b> <br>  La variante de code de fonction API <b>NUSE_Timer_Get_Remaining ()</b> (apr√®s v√©rification des param√®tres) est trivialement simple.  La valeur <b>NUSE_Timer_Value [] est</b> obtenue puis renvoy√©e dans la section critique. <br><br><h2>  Services de minuterie auxiliaire </h2><br>  Nucleus RTOS dispose de quatre appels d'API qui fournissent des fonctions auxiliaires li√©es aux temporisateurs: r√©initialiser un temporisateur, obtenir des informations sur le temporisateur, obtenir le nombre de temporisateurs dans une application et obtenir des pointeurs vers tous les temporisateurs d'une application.  Les trois premi√®res fonctions sont impl√©ment√©es dans Nucleus SE. <br><br><h3>  R√©initialisation de la minuterie </h3><br>  Cet appel API r√©initialise le temporisateur √† son √©tat d'origine non utilis√©.  La minuterie peut √™tre activ√©e ou d√©sactiv√©e apr√®s la fin de cet appel.  Il ne peut √™tre utilis√© qu'apr√®s la d√©sactivation du temporisateur (√† l'aide de <b>NUSE_Timer_Control ()</b> ).  La prochaine fois que le temporisateur sera activ√©, il sera initialis√© avec le param√®tre <b>NUSE_Timer_Initial_Time []</b> .  Nucleus RTOS vous permet de fournir un nouvel √©tat initial et une nouvelle heure de replanification, ainsi que de sp√©cifier la fonction d'ach√®vement lorsque la minuterie est r√©initialis√©e.  Dans Nucleus SE, ces valeurs sont d√©finies lors de la configuration et ne peuvent pas √™tre modifi√©es car elles sont stock√©es dans la ROM. <br><br>  <b><i>Appel pour r√©initialiser une minuterie dans Nucleus RTOS</i></b> <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Reset_Timer (NU_TIMER * timer, VOID (* expiration_routine) (UNSIGNED), UNSIGNED initial_time, UNSIGNED reschedule_time, OPTION enable);</b> <br><br>  Param√®tres: <br>  <b>minuterie</b> - un pointeur sur une minuterie r√©initialisable; <br>  <b>expiration_routine</b> - indique la fonction qui sera ex√©cut√©e √† la fin de la boucle; <br>  <b>initial_time</b> - le nombre initial de minuteries jusqu'√† la fin de la boucle; <br>  <b>reschedule_time</b> - le nombre de <b>tics</b> de temporisation jusqu'√† la fin du deuxi√®me cycle et des suivants; <br>  <b>enable</b> - l'√©tat requis du temporisateur apr√®s une r√©initialisation, peut prendre les valeurs <b>NU_ENABLE_TIMER</b> ou <b>NU_DISABLE_TIMER</b> . <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_TIMER</b> - pointeur non valide vers l'unit√© de commande de la minuterie; <br>  <b>NU_INVALID_FUNCTION</b> - pointeur nul vers la fonction d'ach√®vement ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> - l'√©tat sp√©cifi√© est incorrect; <br>  <b>NU_NOT_DISABLED</b> - le temporisateur est d√©j√† en cours d'ex√©cution (il doit √™tre arr√™t√© avant d'appeler cette fonction). <br><br>  <b><i>Appelez pour r√©initialiser la minuterie dans Nucleus SE</i></b> <br>  Cet appel de service API prend en charge une version simplifi√©e de la fonctionnalit√© principale de l'API Nucleus RTOS. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NUSE_Timer_Reset (temporisateur NUSE_TIMER, activation OPTION);</b> <br><br>  Param√®tres: <br>  <b>timer</b> - index (ID) du timer de r√©initialisation; <br>  <b>enable</b> - l'√©tat requis apr√®s la r√©initialisation, peut prendre les valeurs <b>NUSE_ENABLE_TIMER</b> ou <b>NUSE_DISABLE_TIMER</b> . <br><br>  Valeur de retour: <br>  <b>NUSE_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NUSE_INVALID_TIMER</b> - index de temporisateur non valide; <br>  <b>NUSE_INVALID_ENABLE</b> - l'√©tat sp√©cifi√© est incorrect; <br>  <b>NUSE_NOT_DISABLED</b> - le temporisateur est d√©j√† en cours d'ex√©cution (il doit √™tre arr√™t√© avant d'appeler cette fonction). <br><br>  <b><i>Impl√©mentation d'une r√©initialisation de la minuterie dans Nucleus SE</i></b> <br>  La version du code de fonction API <b>NUSE_Timer_Reset ()</b> (apr√®s v√©rification des param√®tres et de l'√©tat actuel) est assez simple: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); NUSE_Init_Timer(timer); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; } /*  enable == NUSE_DISABLE_TIMER    FALSE */ NUSE_CS_Exit();</code> </pre><br>  Un appel √† <b>NUSE_Init_Timer ()</b> initialise la valeur de temps et efface le compteur d'ach√®vement.  Apr√®s cela, si n√©cessaire, la valeur de l'√©tat requis est v√©rifi√©e et si le temporisateur est activ√©. <br><br><h3>  Informations sur la minuterie </h3><br>  Cet appel de service vous permet d'obtenir un ensemble d'informations sur la minuterie.  L'impl√©mentation de Nucleus SE diff√®re de Nucleus RTOS en ce qu'elle renvoie moins d'informations car la d√©nomination des objets n'est pas prise en charge. <br><br>  <b><i>Appelez les informations de la minuterie dans Nucleus RTOS</i></b> <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Timer_Information (NU_TIMER * timer, CHAR * name, OPTION * enable, UNSIGNED * expirations, UNSIGNED * id, UNSIGNED * initial_time, UNSIGNED * reschedule_time);</b> <br><br>  Param√®tres: <br>  <b>timer</b> - un pointeur sur un timer sur lequel des informations sont demand√©es; <br>  <b>nom</b> - pointeur vers la r√©gion √† 8 caract√®res pour le nom de la minuterie; <br>  <b>enable</b> - pointeur sur une variable qui prend l'√©tat actuel de l'activateur de temporisation: <b>NU_ENABLE_TIMER</b> ou <b>NU_DISABLE_TIMER</b> ; <br>  <b>expirations</b> - un pointeur sur une variable qui prend un compteur du nombre de fin du cycle de temporisation depuis sa derni√®re r√©initialisation; <br>  <b>id</b> - pointeur vers une variable qui prend la valeur du param√®tre pass√© √† la fonction de fin de cycle de temporisation; <br>  <b>initial_time</b> - un pointeur vers une variable qui prend une valeur dans laquelle le temporisateur sera initialis√© apr√®s une r√©initialisation; <br>  <b>reschedule_time</b> - un pointeur vers une variable qui prend une valeur dans laquelle le temporisateur sera initialis√© une fois termin√©. <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_TIMER</b> - pointeur de temporisateur non valide. <br><br>  <b><i>Appelez les informations de la minuterie dans Nucleus SE</i></b> <br>  Cet appel d'API prend en charge la fonctionnalit√© principale de l'API Nucleus RTOS. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NUSE_Timer_Information (NUSE_TIMER timer, OPTION * enable, U8 * expirations, U8 * id, U16 * initial_time, U16 * reschedule_time);</b> <br><br>  Param√®tres: <br>  <b>timer</b> - index du timer sur lequel des informations sont demand√©es; <br>  <b>enable</b> - un pointeur sur une variable qui prend la valeur <b>TRUE</b> ou <b>FALSE</b> , selon que le temporisateur est activ√© ou non; <br>  <b>expirations</b> - un pointeur vers une variable de type <b>U8</b> qui prend la valeur du nombre de fin de temporisation depuis sa derni√®re r√©initialisation; <br>  <b>id</b> - pointeur vers une variable de type <b>U8</b> qui prend la valeur du param√®tre pass√© √† la fonction de fin de temporisation (retournera une valeur vide si les fonctions de fin sont d√©sactiv√©es); <br>  <b>initial_time</b> - un pointeur vers une variable de type <b>U16</b> qui prend une valeur par laquelle le temporisateur sera initialis√© apr√®s une r√©initialisation; <br>  <b>reschedule_time</b> - un pointeur vers une variable de type <b>U16</b> , qui prend la valeur par laquelle le temporisateur sera initialis√© une fois termin√©. <br><br>  Valeur de retour: <br>  <b>NUSE_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NUSE_INVALID_TIMER</b> - index de temporisateur non valide; <br>  <b>NUSE_INVALID_POINTER</b> - un ou plusieurs param√®tres de pointeur sont incorrects. <br><br>  <b><i>Impl√©mentation des informations de minuterie dans Nucleus SE</i></b> <br>  L'impl√©mentation de cet appel d'API est assez simple: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (NUSE_Timer_Status[timer]) { *enable = NUSE_ENABLE_TIMER; } else { *enable = NUSE_DISABLE_TIMER; } *expirations = NUSE_Timer_Expirations_Counter[timer]; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT *id = NUSE_Timer_Expiration_Routine_Parameter[timer]; #endif *initial_time = NUSE_Timer_Initial_Time[timer]; *reschedule_time = NUSE_Timer_Reschedule_Time[timer]; NUSE_CS_Exit();</code> </pre><br>  La fonction renvoie l'√©tat de la minuterie.  La valeur du param√®tre de la fonction de terminaison n'est renvoy√©e que si leur prise en charge a √©t√© activ√©e dans l'application. <br><br><h3>  Obtenir le nombre de minuteries </h3><br>  Cet appel d'utilitaire renvoie le nombre de temporisations configur√©es dans l'application.  Dans Nucleus RTOS, cette valeur peut changer au fil du temps et la valeur de retour affichera le nombre actuel de temporisateurs.  Dans Nucleus SE, la valeur de retour est d√©finie pendant la phase d'assemblage et ne peut pas √™tre modifi√©e. <br><br>  <b><i>Appel √† un compteur de minuterie dans Nucleus RTOS</i></b> <br><br>  Prototype d'appel de service: <br>  <b>UNSIGNED NU_Established_Timers (VOID);</b> <br><br>  Param√®tres: aucun <br><br>  Valeur de retour: le nombre de temporisations cr√©√©es dans le syst√®me. <br><br>  <b><i>Appel du compteur de minuterie dans Nucleus SE</i></b> <br>  Cet appel d'API prend en charge la fonctionnalit√© principale de l'API Nucleus RTOS. <br><br>  Prototype d'appel de service: <br>  <b>U8 NUSE_Timer_Count (void);</b> <br><br>  Param√®tres: aucun <br><br>  Valeur de retour: <br>  le nombre de temporisations configur√©es dans l'application <br><br><h3>  Mise en ≈ìuvre du compteur de minuterie </h3><br>  L'impl√©mentation de cet appel API est assez simple: la valeur du symbole #define <b>NUSE_TIMER_NUMBER</b> est <b>retourn√©e</b> . <br><br><h2>  Structures de donn√©es </h2><br>  Les temporisateurs utilisent cinq ou sept structures de donn√©es (situ√©es dans la RAM ou la ROM) qui (comme les autres objets Nucleus SE) sont un ensemble de tables, dont la taille et le nombre correspondent au nombre de temporisateurs configur√©s et aux param√®tres s√©lectionn√©s. <br><br>  Je recommande fortement que le code d'application n'utilise pas un acc√®s direct √† ces structures de donn√©es, mais s'y r√©f√®re via les fonctions API fournies.  Cela √©vitera l'incompatibilit√© avec les futures versions de Nucleus SE et les effets secondaires ind√©sirables, ainsi que simplifiera le portage des applications vers Nucleus RTOS.  Ce qui suit est un aper√ßu d√©taill√© des structures pour simplifier la compr√©hension des appels de service et du code de d√©bogage. <br><br><h3>  Donn√©es RAM </h3><br>  Ces donn√©es ont la structure suivante: <br>  <b>NUSE_Timer_Status []</b> est un tableau de type <b>U8</b> qui a une entr√©e pour chaque temporisateur configur√© et stocke l'√©tat du temporisateur (en cours d'ex√©cution ou arr√™t√©: <b>TRUE</b> ou <b>FALSE</b> ). <br>  <b>NUSE_Timer_Value []</b> est un tableau de type <b>U16</b> qui a une entr√©e pour chaque temporisateur configur√© et stocke la valeur actuelle du compteur de temporisation. <br>  <b>NUSE_Timer_Expirations_Counter []</b> - un tableau de type <b>U8</b> , contenant un compteur du nombre de cas o√π les temporisateurs ont atteint la fin du cycle depuis leur derni√®re r√©initialisation. <br><br>  Toutes ces structures de donn√©es sont initialis√©es par la fonction <b>NUSE_Init_Timer () au</b> d√©marrage de Nucleus SE.  L'un des articles suivants contiendra une description compl√®te des proc√©dures de d√©marrage de Nucleus SE. <br><br>  Voici les d√©finitions de ces structures de donn√©es dans le fichier <b>nuse_init.c</b> : <br>  <b>RAM U8 Timer_Status [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U16 NUSE_Timer_Value [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U8 NUSE_Timer_Expirations_Counter [NUSE_TIMER_NUMBER];</b> <br><br><h3>  Donn√©es ROM </h3><br>  La structure de ces donn√©es: <br>  <b>NUSE_Timer_Initial_Time []</b> est un tableau de type <b>U16</b> qui a une entr√©e pour chaque temporisateur configur√© et stocke la valeur de chaque temporisateur. <br>  <b>NUSE_Timer_Reschedule_Time []</b> est un tableau de type <b>U16</b> qui a une entr√©e pour chaque temporisateur configur√© et stocke la valeur √† laquelle le temporisateur sera d√©fini une fois termin√©.  Une valeur de z√©ro indique que la minuterie est ¬´ponctuelle¬ª et ne doit pas red√©marrer automatiquement. <br>  <b>NUSE_Timer_Expiration_Routine_Address []</b> - un tableau de type <b>ADDR</b> contenant l'adresse des proc√©dures d'expiration du temporisateur.  Ce tableau existe uniquement si la prise en charge de la proc√©dure d'expiration du temporisateur a √©t√© activ√©e. <br>  <b>NUSE_Timer_Expiration_Routine_Parameter []</b> - un tableau de type <b>U8</b> contenant les valeurs du param√®tre qui est pass√© √† la fonction de fin de temporisation.  Ce tableau existe uniquement si la prise en charge des fonctions d'ach√®vement a √©t√© activ√©e. <br><br>  Ces structures de donn√©es sont d√©clar√©es et initialis√©es (statiquement) dans le fichier <b>nuse_config.c</b> , ainsi: <br><br><pre> <code class="plaintext hljs">ROM U16 NUSE_Timer_Initial_Time[NUSE_TIMER_NUMBER] = { /*   ------ */ }; ROM U16 NUSE_Timer_Reschedule_Time[NUSE_TIMER_NUMBER] = { /*      ------ */ }; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING /*    */ ROM ADDR NUSE_Timer_Expiration_Routine_Address[NUSE_TIMER_NUMBER] = { /*     ------ */ /*   NULL */ }; ROM U8 NUSE_Timer_Expiration_Routine_Parameter[NUSE_TIMER_NUMBER] = { /*     ------ */ }; #endif</code> </pre><br><h3>  La quantit√© de m√©moire pour la minuterie </h3><br>  Comme tous les autres objets Nucleus SE, la quantit√© de donn√©es n√©cessaires pour les temporisateurs est pr√©visible. <br><br>  La quantit√© de donn√©es dans la RAM (en octets) pour tous les temporisateurs de l'application peut √™tre calcul√©e comme suit: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  La quantit√© de donn√©es dans la ROM (en octets) pour tous les temporisateurs de l'application, si la prise en charge des fonctions d'ach√®vement est d√©sactiv√©e, peut √™tre calcul√©e comme suit: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  Sinon, il est √©gal √†: <br>  <b>NUSE_TIMER_NUMBER * (taille de (ADDR) + 5)</b> <br><br><h2>  Appels d'API non r√©alis√©s </h2><br>  Nucleus SE n'impl√©mente pas les trois appels d'API qui peuvent √™tre trouv√©s dans RTOS. <br><br><h3>  Cr√©ation de minuterie </h3><br>  Cet appel API cr√©e une minuterie.  Nucleus SE n'en a pas besoin, car les temporisateurs sont cr√©√©s statiquement. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Create_Timer (NU_TIMER * timer, CHAR * name, VOID (* expiration_routine) (UNSIGNED), UNSIGNED id, UNSIGNED initial_time, UNSIGNED reschedule_time, OPTION enable);</b> <br><br>  Param√®tres: <br>  <b>minuterie</b> - pointeur vers le bloc de commande de minuterie fourni par l'utilisateur;  il sera utilis√© pour contr√¥ler les temporisateurs dans d'autres appels d'API; <br>  <b>nom</b> - pointeur sur le <b>nom</b> √† 7 caract√®res du temporisateur avec un z√©ro de fin; <br>  <b>expiration_routine</b> - indique la fonction qui doit √™tre ex√©cut√©e apr√®s la fin du temporisateur; <br>  <b>id</b> - un √©l√©ment de donn√©es de type <b>UNSIGNED</b> transmis √† la fonction de terminaison: ce param√®tre peut √™tre utilis√© pour identifier des temporisateurs ayant la m√™me fonction de terminaison; <br>  <b>initial_time</b> - indique le nombre initial de tics du minuteur avant la fin du minuteur; <br>  <b>reschedule_time</b> - indique le nombre de <b>tics</b> de temporisation jusqu'√† la fin du deuxi√®me cycle et des suivants;  si ce param√®tre est √©gal √† z√©ro, le temporisateur ne s'arr√™te qu'une seule fois; <br>  <b>enable</b> - ce param√®tre peut prendre les valeurs <b>NU_ENABLE_TIMER</b> et <b>NU_DISABLE_TIMER</b> ;  <b>NU_ENABLE_TIMER</b> active un temporisateur apr√®s sa cr√©ation;  <b>NU_DISABLE_TIMER</b> laisse le temporisateur d√©sactiv√©;  les temporisateurs cr√©√©s avec le param√®tre <b>NU_DISABLE_TIMER</b> doivent √™tre activ√©s en appelant <b>NU_Control_Timer</b> . <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_TIMER</b> - un pointeur nul vers une unit√© de contr√¥le de minuterie ( <b>NULL</b> ), ou l'unit√© de contr√¥le est d√©j√† en cours d'utilisation; <br>  <b>NU_INVALID_FUNCTION</b> - pointeur nul vers le programme d'ach√®vement ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> - param√®tre d' <b>activation</b> non valide; <br>  <b>NU_INVALID_OPERATION</b> - le param√®tre <b>initial_time</b> √©tait z√©ro. <br><br><h3>  Supprimer la minuterie </h3><br>  Cet appel d'API supprime un minuteur cr√©√© pr√©c√©demment.  Nucleus SE n'en a pas besoin, car les temporisateurs sont cr√©√©s statiquement et ne peuvent pas √™tre supprim√©s. <br><br>  Prototype d'appel de service: <br>  <b>STATUS NU_Delete_Timer (NU_TIMER * timer);</b> <br><br>  Param√®tres: <br>  <b>timer</b> - pointeur sur le bloc de contr√¥le du timer. <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - l'appel s'est termin√© avec succ√®s; <br>  <b>NU_INVALID_TIMER</b> - pointeur de temporisateur invalide; <br>  <b>NU_NOT_DISABLED</b> - Le temporisateur sp√©cifi√© n'est pas d√©sactiv√©. <br><br><h3>  Pointeurs de minuterie </h3><br>  Cet appel d'API forme une liste s√©quentielle de pointeurs vers tous les temporisateurs du syst√®me.  Nucleus SE n'en a pas besoin, car les temporisateurs sont d√©termin√©s par un simple index, pas un pointeur. <br><br>  Prototype d'appel de service: <br>  <b>UNSIGNED NU_Timer_Pointers (NU_TIMER ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Param√®tres: <br>  <b>pointer_list</b> - pointeur vers un tableau de pointeurs <b>NU_TIMER</b> ;  il sera rempli de pointeurs vers des temporisateurs configur√©s dans le syst√®me; <br>  <b>maximum_pointers</b> - le nombre maximum de pointeurs dans le tableau. <br><br>  Valeur de retour: <br>  Le nombre de pointeurs <b>NU_TIMER</b> plac√©s dans le tableau. <br><br><h2>  Compatible avec Nucleus RTOS </h2><br>  Comme pour tous les autres objets Nucleus SE, mon objectif √©tait de maximiser la compatibilit√© du code d'application avec Nucleus RTOS.  Les temporisateurs ne font pas exception et, du point de vue de l'utilisateur, ils sont impl√©ment√©s de la m√™me mani√®re que dans Nucleus RTOS.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a aussi une certaine incompatibilit√©, que j'ai jug√©e acceptable, √©tant donn√© que le code deviendra ainsi plus compr√©hensible et plus efficace en termes de quantit√© de m√©moire requise. </font><font style="vertical-align: inherit;">Sinon, les appels d'API Nucleus RTOS peuvent √™tre port√©s presque directement vers Nucleus SE.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Identificateurs d'objet </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans Nucleus RTOS, tous les objets sont d√©crits par une structure de donn√©es - un bloc de contr√¥le qui a un type de donn√©es sp√©cifique. Un pointeur vers cette unit√© de commande est un identificateur de temporisateur. J'ai d√©cid√© que dans Nucleus SE, une approche diff√©rente est n√©cessaire pour une utilisation efficace de la m√©moire: tous les objets du noyau sont d√©crits par un ensemble de tables en RAM et / ou ROM. La taille de ces tables est d√©termin√©e par le nombre d'objets configur√©s de chaque type. L'identifiant d'un objet particulier est l'index dans ce tableau. J'ai donc d√©fini </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_TIMER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme l'√©quivalent de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, une variable (pas un pointeur) de ce type sert d'identifiant du temporisateur. </font><font style="vertical-align: inherit;">Cette l√©g√®re incompatibilit√© est facile √† g√©rer si le code est port√© de Nucleus SE vers Nucleus RTOS et vice versa. </font><font style="vertical-align: inherit;">En r√®gle g√©n√©rale, aucune op√©ration n'est effectu√©e sur les identificateurs d'objet autres que le d√©placement et le stockage. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus RTOS prend √©galement en charge les minuteries de d√©nomination. </font><font style="vertical-align: inherit;">Ces noms sont utilis√©s uniquement pour le d√©bogage. </font><font style="vertical-align: inherit;">Je les ai exclus de Nucleus SE pour √©conomiser de la m√©moire.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taille de la minuterie </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans Nucleus RTOS, les temporisateurs sont impl√©ment√©s √† l'aide de compteurs 32 bits. </font><font style="vertical-align: inherit;">J'ai d√©cid√© de r√©duire cette valeur √† 16 bits dans Nucleus SE. </font><font style="vertical-align: inherit;">Cela a conduit √† des am√©liorations significatives de l'efficacit√© de la m√©moire et de l'ex√©cution. </font><font style="vertical-align: inherit;">Nucleus SE peut √™tre modifi√© si l'application n√©cessite un temps d'ex√©cution plus long.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fonctions de compl√©tion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus SE impl√©mente les fonctions de terminaison d'une mani√®re similaire √† Nucleus RTOS, mais elles peuvent √™tre compl√®tement d√©sactiv√©es (ce qui vous permet d'√©conomiser de la m√©moire), et elles sont √©galement d√©termin√©es statiquement. </font><font style="vertical-align: inherit;">La fonction de fin ne peut pas √™tre modifi√©e lorsque la minuterie est r√©initialis√©e.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Appels d'API non r√©alis√©s </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus RTOS prend en charge huit appels de service de minuterie. </font><font style="vertical-align: inherit;">Parmi ceux-ci, trois ne sont pas impl√©ment√©s dans Nucleus SE. </font><font style="vertical-align: inherit;">Une description d√©taill√©e de ces appels, ainsi que les raisons de cette d√©cision, se trouvent plus haut dans cet article, dans la section ¬´Appels d'API non r√©alis√©s¬ª. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'article suivant examinera les interruptions.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455072/">https://habr.com/ru/post/fr455072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455062/index.html">Cas d'exp√©riences r√©ussies (et pas si) de Yandex.Navigator</a></li>
<li><a href="../fr455064/index.html">Talent contre chance: le r√¥le du hasard dans le succ√®s et l'√©chec</a></li>
<li><a href="../fr455066/index.html">Diffusion et pr√©sentations de l'analyse syst√®me MeetUp UPD2</a></li>
<li><a href="../fr455068/index.html">Politique z√©ro bug. Pas de bugs - pas de probl√®mes?</a></li>
<li><a href="../fr455070/index.html">Pourquoi les interviews sont-elles si souvent pos√©es sur les listes cha√Æn√©es</a></li>
<li><a href="../fr455076/index.html">GameDev TDD ou Rabbit Hell</a></li>
<li><a href="../fr455078/index.html">O√π parler d'Apache Ignite et des syst√®mes distribu√©s en √©t√©</a></li>
<li><a href="../fr455080/index.html">Les personnes √¢g√©es n'appartiennent pas ici? Programmable apr√®s trente-cinq</a></li>
<li><a href="../fr455082/index.html">Nous √©tudions MITRE ATT & CK. Matrices mobiles: acc√®s aux appareils. Partie 4</a></li>
<li><a href="../fr455088/index.html">Que testent les entretiens et les √©l√©ments de test</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>