<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•® üôèüèΩ üì¨ Dasar-Dasar RxVMS: RxCommand dan GetIt üë®üèª‚Äçüöí üë©üèª‚Äçüè´ ü§öüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian keempat dari seri arsitektur Flutter saya: 


- Pendahuluan 
- Dasar-Dasar Aliran Dart 
- RxDart: transformasi ajaib arus 
- Dasar-d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-Dasar RxVMS: RxCommand dan GetIt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449872/"><p>  Ini adalah bagian keempat dari seri arsitektur Flutter saya: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-Dasar Aliran Dart</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxDart: transformasi ajaib arus</a> </li><li>  <strong>Dasar-dasar RxVMS: RxCommand dan GetIt (posting ini)</strong> </li><li>  RxVMS: Layanan dan Manajer </li><li>  RxVMS: widget mandiri </li><li>  Otentikasi Pengguna dengan RxVMS </li></ul><br><p>  Meskipun 2 bagian sebelumnya jelas tidak terkait dengan pola RxVMS, mereka diperlukan untuk pemahaman yang jelas tentang pendekatan ini.  Sekarang kita beralih ke paket paling penting yang Anda perlukan untuk menggunakan RxVMS dalam aplikasi Anda. </p><a name="habracut"></a><br><h2 id="getit-bystryy-servicelocator">  GetIt: ServiceLocator Cepat </h2><br><p>  Saat Anda mengingat diagram yang menunjukkan berbagai elemen RxVMS dalam aplikasi ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9cf/f8a/7c1/9cff8a7c191e44a7f4f269c3b0ee97cd.png" alt="gambar"></p><br><p> ... mungkin Anda bertanya-tanya bagaimana berbagai pemetaan, manajer, dan layanan saling mengetahui.  Lebih penting lagi, Anda mungkin bertanya-tanya bagaimana satu elemen dapat mengakses fungsi yang lain. </p><br><p>  Dengan begitu banyak pendekatan berbeda (seperti Widget yang Diwarisi, wadah IoC, DI ...), saya pribadi lebih suka Service Locator.  Dalam hal ini, saya memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel khusus</a> tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GetIt</a> - implementasi saya dari pendekatan ini, tetapi di sini saya akan sedikit menyentuh topik ini.  Secara umum, Anda mendaftarkan objek dalam layanan ini satu kali, dan kemudian Anda memiliki akses ke sana di seluruh aplikasi.  Ini semacam singleton ... tetapi dengan lebih banyak fleksibilitas. </p><br><h2 id="ispolzovanie">  Gunakan </h2><br><p>  Menggunakan GetIt cukup jelas.  Di awal aplikasi, Anda mendaftarkan layanan dan / atau manajer yang Anda rencanakan untuk digunakan selanjutnya.  Di masa depan, panggil saja metode GetIt untuk mengakses instance kelas terdaftar. </p><br><p>  Fitur yang bagus adalah Anda dapat mendaftarkan antarmuka atau kelas abstrak seperti implementasi konkret.  Saat mengakses sebuah instance, cukup gunakan antarmuka / abstraksi, dengan mudah mengganti implementasi yang diperlukan selama pendaftaran.  Ini memungkinkan Anda untuk dengan mudah mengganti Layanan asli ke MockService. </p><br><h2 id="nemnogo-praktiki">  Sedikit latihan </h2><br><p>  Saya biasanya menginisialisasi SeviceLocator saya dalam file bernama service_locator.dart melalui variabel global.  Dengan demikian satu variabel global diperoleh untuk seluruh proyek. </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    GetIt sl = new GetIt(); void setUpServiceLocator(ErrorReporter reporter) { //  // [registerSingleton]  -  . //   . // sl.get&lt;ErrorReporter&gt;.get()    . sl.registerSingleton&lt;ErrorReporter&gt;(reporter); // [registerLazySingleton]   ,       // sl.get&lt;ImageService&gt;.get()            . sl.registerLazySingleton&lt;ImageService&gt;(() =&gt; new ImageServiceImplementation()); sl.registerLazySingleton&lt;MapService&gt;(() =&gt; new MapServiceImplementation()); //  sl.registerSingleton&lt;UserManager&gt;(new UserManagerImplementation()); sl.registerLazySingleton&lt;EventManager&gt;(() =&gt; new EvenManagerImplementation()); sl.registerLazySingleton&lt;ImageManager&gt;(() =&gt; new ImageManagerImplementation()); sl.registerLazySingleton&lt;AppManager&gt;(() =&gt; new AppManagerImplementation());</span></span></code> </pre> <br><p>  Kapan pun Anda ingin mengakses, panggil saja </p><br><pre> <code class="cpp hljs">RegistrationType object = sl.get&lt;RegistrationType&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  GetIt  `callable`,   : RegistrationType object2 = sl&lt;RegistrationType&gt;();</span></span></code> </pre> <br><p>  <strong>Catatan yang sangat penting:</strong> Saat menggunakan GetIt, SELALU menggunakan gaya yang sama saat mengimpor file - baik paket (disarankan) atau jalur relatif, tetapi tidak keduanya mendekati sekaligus.  Ini karena Dart memperlakukan file-file tersebut sebagai berbeda, terlepas dari identitasnya. </p><br><p>  Jika ini sulit bagi Anda, silakan kunjungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog saya</a> untuk detailnya. </p><br><h2 id="rxcommand">  Perintah </h2><br><p>  Sekarang kita menggunakan GetIt untuk mengakses objek kita di mana saja (termasuk antarmuka pengguna), saya ingin menjelaskan bagaimana kita dapat mengimplementasikan fungsi-fungsi handler untuk acara-acara UI.  Cara paling sederhana adalah menambahkan fungsi ke manajer dan memanggilnya di widget: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookUpZip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String zip)</span></span></span></span>; }</code> </pre> <br><p>  dan kemudian di UI </p><br><pre> <code class="cpp hljs">TextField(onChanged: sl.get&lt;SearchManager&gt;().lookUpZip,)</code> </pre> <br><p>  Ini akan <code>lookUpZip</code> pada setiap perubahan di <code>TextField</code> .  Tetapi bagaimana kita menyampaikan hasilnya kepada kita?  Karena kami ingin menjadi reaktif, kami akan menambahkan <code>StreamController</code> ke <code>SearchManager</code> kami: </p><br><pre> <code class="cpp hljs">abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManager</span></span></span><span class="hljs-class"> {</span></span> Stream&lt;String&gt; get nameOfCity; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookUpZip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String zip)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManagerImplementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManager</span></span></span><span class="hljs-class">{</span></span> @override Stream&lt;String&gt; get nameOfCity =&gt; cityController.stream; StreamController&lt;String&gt; cityController = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController(); @override Future&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; lookUpZip(String zip) async { var cityName = await sl.get&lt;ZipApiService&gt;().lookUpZip(zip); cityController.add(cityName); } }</code> </pre> <br><p>  dan di UI: </p><br><pre> <code class="cpp hljs">StreamBuilder&lt;String&gt;( initialData:<span class="hljs-string"><span class="hljs-string">'', stream: sl.get&lt;SearchManager&gt;().nameOfCity, builder: (context, snapshot) =&gt; Text(snapShot.data);</span></span></code> </pre> <br><p>  Meskipun pendekatan ini berhasil, itu tidak optimal.  Inilah masalahnya: </p><br><ul><li>  kode redundan - kita selalu harus membuat metode, StreamController, dan pengambil untuk alirannya, jika kita tidak ingin menampilkannya secara eksplisit di domain publik </li><li>  status sibuk - bagaimana jika kita ingin menampilkan Spinner saat fungsi melakukan tugasnya? </li><li>  penanganan kesalahan - apa yang terjadi jika suatu fungsi melempar pengecualian? </li></ul><br><p>  Tentu saja, kita bisa menambahkan lebih banyak StreamControllers untuk menangani status dan kesalahan ... tetapi segera itu membosankan, dan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rx_command</a> berguna di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  <code>RxCommand</code> menyelesaikan semua masalah di atas dan banyak lagi.  <code>RxCommand</code> merangkum fungsi (sinkron atau asinkron) dan secara otomatis memposting hasilnya ke aliran. </p><br><p>  Menggunakan RxCommand, kita dapat menulis ulang manajer kita seperti ini: </p><br><pre> <code class="cpp hljs">abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManager</span></span></span><span class="hljs-class"> {</span></span> RxCommand&lt;String,String&gt; lookUpZipCommand; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManagerImplementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchManager</span></span></span><span class="hljs-class">{</span></span> @override RxCommand&lt;String,String&gt; lookUpZipCommand; SearchManagerImplementation() { lookUpZipCommand = RxCommand.createAsync((zip) =&gt; sl.get&lt;ZipApiService&gt;().lookUpZip(zip)); } }</code> </pre> <br><p>  dan di UI: </p><br><pre> <code class="cpp hljs">TextField(onChanged: sl.get&lt;SearchManager&gt;().lookUpZipCommand,) ... StreamBuilder&lt;String&gt;( initialData:<span class="hljs-string"><span class="hljs-string">'', stream: sl.get&lt;SearchManager&gt;().lookUpZipCommand, builder: (context, snapshot) =&gt; Text(snapShot.data);</span></span></code> </pre> <br><p>  yang jauh lebih ringkas dan mudah dibaca. </p><br><h2 id="rxcommand-v-detalyah">  Perintah Rx secara detail </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0aa/485/a85/0aa485a85b55c760e32b482a6c00b758.png"></p><br><p>  RxCommand memiliki satu input dan lima output yang dapat diobservasi: </p><br><ul><li><p>  <strong>canExecuteInput</strong> adalah <code>Observable&lt;bool&gt;</code> opsional yang dapat Anda lewati ke fungsi pabrik saat membuat RxCommand.  Ini memberi sinyal kepada RxCommand apakah dapat dijalankan, tergantung pada nilai terakhir yang diterima. </p><br></li><li><p>  <strong>isExecuting</strong> adalah <code>Observable&lt;bool&gt;</code> yang memberi sinyal apakah perintah saat ini menjalankan fungsinya.  Ketika sebuah tim sibuk, itu tidak dapat dijalankan kembali.  Jika Anda ingin menampilkan Spinner saat runtime, dengarkan <code>isExecuting</code> </p><br></li><li><p>  <strong>canExecute</strong> adalah <code>Observable&lt;bool&gt;</code> yang memberi sinyal kemampuan untuk menjalankan perintah.  Ini, misalnya, berjalan baik dengan StreamBuilder untuk mengubah tampilan tombol antara kondisi on / off. <br>  <em>artinya adalah sebagai berikut:</em> </p><br><pre> <code class="cpp hljs">Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; canExecute = Observable.combineLatest2&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(canExecuteInput,isExecuting) =&gt; canExecuteInput &amp;&amp; !isExecuting).distinct.</code> </pre> <br><p>  <em>yang artinya</em> </p><br><ul><li>  akan <code>false</code> jika isExecuting mengembalikan <code>true</code> </li><li>  itu akan dikembalikan <code>true</code> hanya jika isExecuting mengembalikan <code>false</code> DAN canExecuteInput tidak mengembalikan <code>false</code> . </li></ul><br></li><li><p>  <strong>thrownExceptions</strong> adalah <code>Observable&lt;Exception&gt;</code> .  Semua pengecualian yang dapat dibuang oleh fungsi yang dikemas akan ditangkap dan dikirim ke Observable ini.  Lebih mudah untuk mendengarkannya dan menampilkan kotak dialog jika terjadi kesalahan. </p><br></li><li><p>  <strong>(tim itu sendiri)</strong> sebenarnya juga bisa diamati.  Nilai-nilai yang dikembalikan oleh fungsi kerja akan dikirim pada saluran ini, sehingga Anda bisa langsung meneruskan RxCommand ke StreamBuilder sebagai parameter aliran </p><br></li><li><p>  <strong>hasil</strong> berisi semua status perintah dalam satu <code>Observable&lt;CommandResult&gt;</code> , di mana <code>CommandResult</code> didefinisikan sebagai </p><br></li></ul><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Combined execution state of an `RxCommand` /// Will be issued for any state change of any of the fields /// During normal command execution, you will get this item's listening at the command's [.results] observable. /// 1. If the command was just newly created, you will get `null, false, false` (data, error, isExecuting) /// 2. When calling execute: `null, false, true` /// 3. When exceution finishes: `result, false, false` class CommandResult&lt;T&gt; { final T data; final Exception error; final bool isExecuting; const CommandResult(this.data, this.error, this.isExecuting); bool get hasData =&gt; data != null; bool get hasError =&gt; error != null; @override bool operator ==(Object other) =&gt; other is CommandResult&lt;T&gt; &amp;&amp; other.data == data &amp;&amp; other.error == error &amp;&amp; other.isExecuting == isExecuting; @override int get hashCode =&gt; hash3(data.hashCode, error.hashCode, isExecuting.hashCode); @override String toString() { return 'Data: $data - HasError: $hasError - IsExecuting: $isExecuting'; } }</span></span></code> </pre> <br><p>  <code>.results</code> Observable sangat berguna jika Anda ingin meneruskan hasil dari perintah langsung ke StreamBuilder.  Ini akan menampilkan konten yang berbeda tergantung pada status perintah, dan itu berfungsi dengan sangat baik dengan <code>RxLoader</code> dari paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rx_widgets</a> .  Berikut adalah contoh widget RxLoader yang menggunakan <code>.results</code> Observable: </p><br><pre> <code class="cpp hljs">Expanded( <span class="hljs-comment"><span class="hljs-comment">/// RxLoader      ///    Stream&lt;CommandResult&gt; child: RxLoader&lt;List&lt;WeatherEntry&gt;&gt;( spinnerKey: AppKeys.loadingSpinner, radius: 25.0, commandResults: sl.get&lt;AppManager&gt;().updateWeatherCommand.results, /// ,  .hasData == true dataBuilder: (context, data) =&gt; WeatherListView(data, key: AppKeys.weatherList), /// ,  .isExceuting == true placeHolderBuilder: (context) =&gt; Center( key: AppKeys.loaderPlaceHolder, child: Text("No Data")), /// ,  .hasError == true errorBuilder: (context, ex) =&gt; Center( key: AppKeys.loaderError, child: Text("Error: ${ex.toString()}")), ), ),</span></span></code> </pre><br><h2 id="sozdanie-rxcommands">  Membuat Perintah Rx </h2><br><p>  RxCommands dapat menggunakan fungsi sinkron dan asinkron yang: </p><br><ul><li>  Mereka tidak memiliki parameter dan tidak mengembalikan hasilnya; </li><li>  Mereka memiliki parameter dan tidak mengembalikan hasilnya; </li><li>  Mereka tidak memiliki parameter dan mengembalikan hasil; </li><li>  Mereka memiliki parameter dan mengembalikan hasilnya; </li></ul><br><p>  Untuk semua opsi, RxCommand menawarkan beberapa metode pabrik, dengan mempertimbangkan penangan yang sinkron dan asinkron: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;TParam, TResult&gt; createSync&lt;TParam, TResult&gt;(Func1&lt;TParam, TResult&gt; func,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, TResult&gt; createSyncNoParam&lt;TResult&gt;(Func&lt;TResult&gt; func,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;TParam, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; createSyncNoResult&lt;TParam&gt;(Action1&lt;TParam&gt; action,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; createSyncNoParamNoResult(Action action,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;TParam, TResult&gt; createAsync&lt;TParam, TResult&gt;(AsyncFunc1&lt;TParam, TResult&gt; func,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, TResult&gt; createAsyncNoParam&lt;TResult&gt;(AsyncFunc&lt;TResult&gt; func,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;TParam, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; createAsyncNoResult&lt;TParam&gt;(AsyncAction1&lt;TParam&gt; action,... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RxCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; createAsyncNoParamNoResult(AsyncAction action,...</code> </pre> <br><p>  <strong>Bahkan jika fungsi Anda yang dikemas tidak mengembalikan nilai, RxCommand akan mengembalikan nilai kosong setelah fungsi dijalankan.</strong>  <strong>Dengan demikian, Anda dapat mengatur pendengar untuk perintah seperti itu sehingga merespon penyelesaian fungsi.</strong> </p><br><h2 id="dostup-k-poslednemu-rezultatu">  Akses ke hasil terbaru </h2><br><p>  <code>RxCommand.lastResult</code> memberi Anda akses ke nilai sukses terakhir dari hasil eksekusi perintah, yang dapat digunakan sebagai <code>initialData</code> di StreamBuilder. </p><br><p>  Jika Anda ingin mendapatkan hasil terakhir yang termasuk dalam acara CommandResult pada saat run time atau jika terjadi kesalahan, Anda dapat mengirimkan <code>emitInitialCommandResult = true</code> saat membuat perintah. </p><br><p>  Jika Anda ingin menetapkan nilai awal ke <code>.lastResult</code> , misalnya, jika Anda menggunakannya sebagai <code>initialData</code> di StreamBuilder, Anda bisa meneruskannya dengan parameter <code>initialLastResult</code> saat membuat perintah. </p><br><h2 id="primer---delaem-flutter-reaktivnym">  Contoh - membuat Flutter reaktif </h2><br><p>  Versi terbaru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari contoh telah</a> <strong>diatur</strong> ulang untuk <strong>RxVMS</strong> , jadi sekarang Anda harus memiliki pilihan yang baik tentang cara menggunakannya. </p><br><p>  Karena ini adalah aplikasi yang sangat sederhana, kami hanya perlu satu manajer: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppManager</span></span></span><span class="hljs-class"> {</span></span> RxCommand&lt;String, List&lt;WeatherEntry&gt;&gt; updateWeatherCommand; RxCommand&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; switchChangedCommand; RxCommand&lt;String, String&gt; textChangedCommand; AppManager() { <span class="hljs-comment"><span class="hljs-comment">//    bool         //   Observable switchChangedCommand = RxCommand.createSync&lt;bool, bool&gt;((b) =&gt; b); //    switchChangedCommand  canExecute Observable  // updateWeatherCommand updateWeatherCommand = RxCommand.createAsync&lt;String, List&lt;WeatherEntry&gt;&gt;( sl.get&lt;WeatherService&gt;().getWeatherEntriesForCity, canExecute: switchChangedCommand, ); //         textChangedCommand = RxCommand.createSync&lt;String, String&gt;((s) =&gt; s); //    ... textChangedCommand //     500ms... .debounce(new Duration(milliseconds: 500)) // ...   updateWeatherCommand .listen(updateWeatherCommand); //     updateWeatherCommand(''); } }</span></span></code> </pre> <br><p>  Anda dapat menggabungkan Perintah Rx yang berbeda bersama-sama.  Perhatikan bahwa <code>switchedChangedCommand</code> sebenarnya adalah <strong>canExecute yang dapat diobservasi</strong> untuk <code>updateWeatherCommand</code> . </p><br><p>  Sekarang mari kita lihat bagaimana Manajer digunakan dalam antarmuka pengguna: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Scaffold( appBar: AppBar(title: Text(<span class="hljs-string"><span class="hljs-string">"WeatherDemo"</span></span>)), resizeToAvoidBottomPadding: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, body: Column( children: &lt;Widget&gt;[ Padding( padding: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">16.0</span></span>), child: TextField( key: AppKeys.textField, autocorrect: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, controller: _controller, decoration: InputDecoration( hintText: <span class="hljs-string"><span class="hljs-string">"Filter cities"</span></span>, ), style: TextStyle( fontSize: <span class="hljs-number"><span class="hljs-number">20.0</span></span>, ), <span class="hljs-comment"><span class="hljs-comment">//    textChangedCommand! onChanged: sl.get&lt;AppManager&gt;().textChangedCommand, ), ), Expanded( /// RxLoader   builders   ///   Stream&lt;CommandResult&gt; child: RxLoader&lt;List&lt;WeatherEntry&gt;&gt;( spinnerKey: AppKeys.loadingSpinner, radius: 25.0, commandResults: sl.get&lt;AppManager&gt;().updateWeatherCommand.results, dataBuilder: (context, data) =&gt; WeatherListView(data, key: AppKeys.weatherList), placeHolderBuilder: (context) =&gt; Center(key: AppKeys.loaderPlaceHolder, child: Text("No Data")), errorBuilder: (context, ex) =&gt; Center(key: AppKeys.loaderError, child: Text("Error: ${ex.toString()}")), ), ), Padding( padding: const EdgeInsets.all(8.0), child: Row( children: &lt;Widget&gt;[ ///  Updatebutton    updateWeatherCommand.canExecute Expanded( //        Streambuilder, //      WidgetSelector child: WidgetSelector( buildEvents: sl .get&lt;AppManager&gt;() .updateWeatherCommand .canExecute, onTrue: RaisedButton( key: AppKeys.updateButtonEnabled, child: Text("Update"), onPressed: () { _controller.clear(); sl.get&lt;AppManager&gt;().updateWeatherCommand(); }, ), onFalse: RaisedButton( key: AppKeys.updateButtonDisabled, child: Text("Please Wait"), onPressed: null, ), ), ), //    canExecuteInput StateFullSwitch( state: true, onChanged: sl.get&lt;AppManager&gt;().switchChangedCommand, ), ], ), ), ], ), );</span></span></code> </pre> <br><h2 id="tipovye-shablony-ispolzovaniya">  Pola Penggunaan Khas </h2><br><p>  Kami telah melihat satu cara untuk merespons berbagai status perintah menggunakan <strong>CommandResults</strong> .  Dalam kasus di mana kita ingin menampilkan apakah perintah itu berhasil (tetapi tidak menampilkan hasilnya), pola umum adalah mendengarkan perintah Observables di fungsi <code>initState</code> StatefulWidget.  Ini adalah contoh dari proyek nyata. </p><br><p>  Definisi untuk <code>createEventCommand</code> : </p><br><pre> <code class="cpp hljs"> RxCommand&lt;Event, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; createEventCommand;</code> </pre> <br><p>  Ini akan membuat objek <strong>Acara</strong> dalam database dan tidak akan mengembalikan nilai nyata apa pun.  Tetapi, seperti yang telah kita pelajari sebelumnya, bahkan perintah RxC dengan tipe pengembalian <code>void</code> akan mengembalikan item data tunggal saat selesai.  Dengan demikian, kita dapat menggunakan perilaku ini untuk memicu tindakan dalam aplikasi kita segera setelah perintah selesai: </p><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,        _eventCommandSubscription = _createCommand.listen((_) async { Navigator.pop(context); await showToast('Event saved'); }); //        _errorSubscription = _createEventCommand.thrownExceptions.listen((ex) async { await sl.get&lt;ErrorReporter&gt;().logException(ex); await showMessageDialog(context, 'There was a problem saving event', ex.toString()); }); }</span></span></code> </pre> <br><p>  <strong>Penting</strong> : jangan lupa untuk menyelesaikan langganan saat kami tidak lagi membutuhkannya: </p><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _eventCommandSubscription?.cancel(); _errorSubscription?.cancel(); super.dispose(); }</code> </pre> <br><p>  Selain itu, jika Anda ingin menggunakan layar penghitung yang sibuk, Anda dapat: </p><br><ul><li>  mendengarkan perintah <code>isExecuting</code> Observable dalam fungsi <code>initState</code> ; </li><li>  perlihatkan / sembunyikan konter dalam berlangganan;  juga </li><li>  gunakan Command itu sendiri sebagai sumber data untuk <strong>StreamBuilder</strong> </li></ul><br><h2 id="oblegchenie-zhizni-s-rxcommandlisteners">  Membuat hidup lebih mudah dengan RxCommandListeners </h2><br><p>  Jika Anda ingin menggunakan beberapa Observable, Anda mungkin harus mengelola beberapa langganan.  Kontrol langsung mendengarkan dan melepaskan sekelompok langganan bisa sulit, membuat kode kurang dibaca dan menempatkan Anda pada risiko kesalahan (misalnya, lupa <code>cancel</code> dalam proses penyelesaian). </p><br><p>  Versi terbaru dari <strong>rx_command</strong> menambahkan helper class <code>RxCommandListener</code> , yang dirancang untuk menyederhanakan pemrosesan ini.  Konstruktornya menerima perintah dan penangan untuk berbagai perubahan status: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RxCommandListener</span></span></span><span class="hljs-class">&lt;TParam, TResult&gt; {</span></span> final RxCommand&lt;TParam, TResult&gt; command; <span class="hljs-comment"><span class="hljs-comment">//       final void Function(TResult value) onValue; //    isExecuting final void Function(bool isBusy) onIsBusyChange; //       final void Function(Exception ex) onError; //    canExecute final void Function(bool state) onCanExecuteChange; //    .results Observable  final void Function(CommandResult&lt;TResult&gt; result) onResult; //     /  final void Function() onIsBusy; final void Function() onNotBusy; //     final Duration debounceDuration; RxCommandListener(this.command,{ this.onValue, this.onIsBusyChange, this.onIsBusy, this.onNotBusy, this.onError, this.onCanExecuteChange, this.onResult, this.debounceDuration,} ) void dispose();</span></span></code> </pre> <br><p>  Anda tidak perlu melewati semua fungsi handler.  Semuanya bersifat opsional, jadi Anda cukup mentransfer yang Anda butuhkan.  Anda hanya perlu memanggil <code>dispose</code> untuk <code>RxCommandListener</code> Anda dalam fungsi <code>dispose</code> Anda, dan itu akan membatalkan semua yang digunakan di dalam berlangganan. </p><br><p>  Mari kita bandingkan kode yang sama dengan dan tanpa <code>RxCommandListener</code> dalam contoh nyata lainnya.  Perintah <code>selectAndUploadImageCommand</code> digunakan di sini pada layar obrolan tempat pengguna dapat mengunggah gambar.  Ketika perintah dipanggil: </p><br><ul><li>  Dialog <strong>ImagePicker ditampilkan.</strong> </li><li>  Setelah memilih gambar dimuat </li><li>  Setelah unduhan selesai, perintah mengembalikan alamat penyimpanan gambar sehingga Anda dapat membuat entri obrolan baru. </li></ul><br><p>  Tanpa <strong>RxCommandListener</strong> : </p><br><pre> <code class="cpp hljs">_selectImageCommandSubscription = sl .get&lt;ImageManager&gt;() .selectAndUploadImageCommand .listen((imageLocation) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imageLocation == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    sl.get&lt;EventManager&gt;().createChatEntryCommand(new ChatEntry( event: widget.event, isImage: true, content: imageLocation.downloadUrl, )); }); _selectImageIsExecutingSubscription = sl .get&lt;ImageManager&gt;() .selectAndUploadImageCommand .isExecuting .listen((busy) { if (busy) { MySpinner.show(context); } else { MySpinner.hide(); } }); _selectImageErrorSubscription = sl .get&lt;ImageManager&gt;() .selectAndUploadImageCommand .thrownExceptions .listen((ex) =&gt; showMessageDialog(context, 'Upload problem', "We cannot upload your selected image at the moment. Please check your internet connection"));</span></span></code> </pre> <br><p>  Menggunakan <strong>RxCommandListener</strong> : </p><br><pre> <code class="cpp hljs">selectImageListener = RxCommandListener( command: sl.get&lt;ImageManager&gt;().selectAndUploadImageCommand, onValue: (imageLocation) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imageLocation == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; sl.get&lt;EventManager&gt;().createChatEntryCommand(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChatEntry( event: widget.event, isImage: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, content: imageLocation.downloadUrl, )); }, onIsBusy: () =&gt; MySpinner.show(context), onNotBusy: MySpinner.hide, onError: (ex) =&gt; showMessageDialog(context, <span class="hljs-string"><span class="hljs-string">'Upload problem'</span></span>, <span class="hljs-string"><span class="hljs-string">"We cannot upload your selected image at the moment. Please check your internet connection"</span></span>));</code> </pre> <br><p>  Secara umum, saya akan selalu menggunakan RxCommandListener jika ada lebih dari satu yang bisa diamati. </p><br><p>  Coba <strong>RxCommands</strong> dan lihat bagaimana hal itu dapat membuat hidup Anda lebih mudah. <br>  <em>Omong-omong, Anda tidak perlu menggunakan <strong>RxVMS</strong> untuk memanfaatkan <strong>RxCommands</strong> .</em> </p><br><p>  Untuk informasi lebih lanjut tentang <code>RxCommand</code> baca paket <code>RxCommand</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">readme</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449872/">https://habr.com/ru/post/id449872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449862/index.html">Intisari materi menarik untuk pengembang ponsel # 296 (pada 22 - 26 April)</a></li>
<li><a href="../id449864/index.html">ResNet50. Implementasi sendiri</a></li>
<li><a href="../id449866/index.html">Potensi serangan terhadap HTTPS dan cara mempertahankannya</a></li>
<li><a href="../id449868/index.html">Mekanisme kontrol versi database GIT (MySQL dump management)</a></li>
<li><a href="../id449870/index.html">Pembuat JSOND generik</a></li>
<li><a href="../id449876/index.html">Innovation SSI-2001: kisah salah satu kartu suara paling langka untuk IBM PC (dan tiruannya)</a></li>
<li><a href="../id449878/index.html">Penelitian paten di bidang TI. Kursus pejuang muda. Bagian I. Bagaimana memahami persyaratan pelanggan dan menyiapkan templat laporan</a></li>
<li><a href="../id449880/index.html">Agile Lite: Khusus Terhadap Burnout</a></li>
<li><a href="../id449884/index.html">8008 emulasi mikroprosesor pada ESP8266</a></li>
<li><a href="../id449886/index.html">Ini seperti mengendarai sepeda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>