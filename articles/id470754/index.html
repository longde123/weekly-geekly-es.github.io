<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â–¶ï¸ â˜€ï¸ ğŸ¥” RASA Chatbot: Parallels Experience ğŸ‘¨ ğŸŒœ ğŸ¯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Industri chatbot sedang booming. Pada awalnya mereka cukup bodoh dan bisa melakukan dialog dengan pengguna, memimpin dan menawarkan jawaban yang mungk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RASA Chatbot: Parallels Experience</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/parallels/blog/470754/"><img src="https://habrastorage.org/webt/v-/c5/a0/v-c5a0h7xtstdf2m4u5ivyr1gli.jpeg"><br><br>  Industri chatbot sedang booming.  Pada awalnya mereka cukup bodoh dan bisa melakukan dialog dengan pengguna, memimpin dan menawarkan jawaban yang mungkin.  Kemudian bot menjadi sedikit lebih pintar dan mulai meminta input teks dari pengguna untuk mendapatkan kata kunci dari jawaban.  Perkembangan pembelajaran mesin telah menyebabkan munculnya kemampuan untuk berkomunikasi dengan bot juga dalam suara.  Namun, sebagian besar solusi tidak jauh dari konstruksi grafik dialog yang sama dan transisi antara node-nya dengan kata kunci. <a name="habracut"></a><br><br>  Baru-baru ini, di Parallels, kami memutuskan untuk mengoptimalkan sejumlah proses internal dan membuat bot untuk kebutuhan kita sendiri sebagai percobaan.  Setelah pencarian singkat, kami memutuskan untuk mencoba keberuntungan kami pada proyek open source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RASA</a> .  Menurut pengembang sendiri, mereka membuat bot obrolan generasi ketiga.  Yaitu, bot ini tidak hanya berkeliling grafik negara, tetapi mampu menyimpan dan menggunakan konteks dialog sebelumnya.  Sampai saat ini, ilustrasi terbaik untuk bot obrolan modern terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/wi/d6/ks/wid6ksu-v47injjfrc2gvccl2uw.png"><br><br>  Yaitu, obrolan bot hanyalah seperangkat aturan terverifikasi untuk berpindah dari satu titik dalam grafik ke titik lainnya.  Jika Anda melihat solusi yang ada dari para raksasa pasar, sebenarnya tidak ada yang sangat berbeda dari sekumpulan aturan di sana.  Secara kasar, set ini terlihat seperti ini: <br><br>  Dialog di titik XXX. <br>  Jika pengguna memasukkan penawaran dengan kata-kata ['beli', 'tiket'], lanjutkan ke titik â€œASK WHEREâ€ <br>  Jika pengguna memasukkan penawaran dengan kata ['buy', 'cutlet'], lanjutkan ke poin â€œASK FROM WHATâ€ <br><br>  Segera jelas bahwa itu sampah di sini, jika pengguna memasukkan: "Saya ingin membeli tiket ke Porto," mereka akan tetap bertanya kepadanya, "Ke mana Anda ingin pergi?"  Untuk membuat dialog lebih manusiawi, Anda harus menambahkan aturan baru tentang apa yang harus dilakukan jika ada indikasi tempat. <br>  Kemudian tambahkan aturan tentang apa yang harus dilakukan jika ada indikasi tempat dan waktu, dan sebagainya. <br><br>  Seperangkat aturan ini akan tumbuh cukup cepat, tetapi itu bukan yang terburuk, semua cara yang "benar" dapat dijelaskan, diperbaiki, dan dijilat. <br><br>  Hal yang paling tidak menyenangkan adalah bahwa seseorang adalah makhluk yang tidak terduga, tidak seperti bot, dan dapat setiap saat mulai bertanya sama sekali berbeda.  Artinya, pada saat bot sudah siap memesan tiket, seseorang mungkin bertanya "Ngomong-ngomong, bagaimana dengan cuacanya?"  atau "walaupun tidak, saya ingin masuk ke mobil saya, berapa lama jalannya?" <br><br>  Namun, ia dapat menanyakan hal ini juga pada saat setelah memilih kota, tetapi sebelum memilih waktu keberangkatan atau bahkan memilih tempat di mana ia ingin pergi.  Bot, berdasarkan pada mesin negara, akan macet dan pseudopod mekanisnya akan berkedut dengan sedih, dan pengguna akan frustrasi. <br><br>  Di sini Anda dapat (dan harus) menggunakan pembelajaran mesin.  Tetapi kemudian muncul masalah baru: misalnya, jika Anda menggunakan pelatihan penguatan untuk memprediksi transisi ke titik grafik, muncul pertanyaan: di mana mendapatkan data untuk pelatihan ini, dan siapa yang akan menilai kualitas jawaban? <br><br>  Pengguna tidak mungkin setuju untuk mengajarkan bot Anda, dan, seperti yang diperlihatkan oleh praktik, komunitas pengguna dapat mengajarkan bot sama sekali bukan apa yang Anda inginkan dan apa yang dianggap layak oleh masyarakat.  Selain itu, bot pada tahap awal akan merespons sepenuhnya dari tempat, yang akan membuat pengguna gugup dan tidak mengacaukan dukungan tersebut pada prinsipnya. <br><br>  Setelah menganalisis dan memikirkan semua kekurangan bot yang ada, pengembang RASA mencoba memecahkan masalah sebagai berikut: <br><br><ul><li>  Setiap input dari pengguna melewati â€œpenentuan niatâ€, yaitu teks yang dimasukkan menggunakan pembelajaran mesin dipetakan ke satu (atau beberapa) niat.  Juga, jika perlu, entitas diisolasi dari teks dan ditambahkan ke memori bot. </li><li>  Proses ini mirip dengan bot lain, dengan pengecualian model penentuan niat yang digunakan. </li><li>  Tindakan bot berikutnya diprediksi menggunakan pembelajaran mesin berdasarkan konteks, yaitu tindakan sebelumnya, niat, dan status memori bot. </li><li>  Pada saat yang sama, tidak banyak data yang dibutuhkan untuk pelatihan awal, dan bot dapat memprediksi tindakan apa yang harus dilakukan bahkan tanpa contoh dan aturan khusus. </li></ul><br>  Pertimbangkan mekanisme kerja secara lebih rinci. <br><br><h3>  <font color="#cc0000">RASA NLU</font> </h3><br>  Mari kita mulai dengan paus pertama tempat bot diletakkan.  Ini adalah Pemahaman Bahasa Alami, yang terdiri dari dua bagian utama: penentuan niat dan pengakuan entitas. <br><br>  <b>Deteksi niat</b> <br>  Penentuan niat didasarkan pada algoritma yang dimodifikasi yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StarSpace</a> dari Facebook, diimplementasikan pada Tensorflow.  Dalam hal ini, model representasi kata vektor pra-terlatih tidak digunakan, yang memungkinkan Anda untuk menghindari keterbatasan representasi ini. <br><br>  Misalnya, menentukan niat dalam algoritma RASA akan bekerja dengan baik untuk bahasa apa pun, serta dengan kata-kata spesifik apa pun yang Anda tentukan dalam contoh pelatihan.  Ketika diimplementasikan melalui representasi vektor pra-terlatih seperti GloVe atau word2vec, pelokalan bot dan penerapannya di area yang sangat khusus akan membawa sakit kepala yang cukup. <br><br>  Algoritma ini bekerja berdasarkan vektorisasi kalimat melalui sekumpulan kata dan perbandingan â€œkesamaanâ€ mereka.  Contoh niat dan niat itu sendiri dikonversi menjadi vektor menggunakan kantong kata-kata dan dimasukkan ke input dari jaringan saraf yang sesuai.  Pada output dari jaringan saraf, vektor diperoleh untuk set kata-kata khusus ini (embedding yang sama). <br><br>  Pelatihan berlangsung sedemikian rupa untuk meminimalkan fungsi kerugian dalam bentuk jumlah jarak berpasangan (baik produk kosinus atau vektor) antara dua vektor yang sama dan yang berbeda k.  Dengan demikian, setelah pelatihan, vektor tertentu akan dikaitkan dengan setiap niat. <br><br>  Setelah menerima input pengguna, proposal tersebut juga dibuat vektor dan dijalankan melalui model yang terlatih.  Setelah itu, jarak dari vektor yang dihasilkan ke semua vektor niat dihitung.  Hasilnya diberi peringkat, menyoroti niat yang paling mungkin dan memotong nilai-nilai negatif, yaitu, sama sekali berbeda. <br><br>  Selain roti di atas, pendekatan ini memungkinkan Anda untuk secara otomatis membedakan lebih dari satu niat dari proposal.  Misalnya: â€œYa, saya mengerti itu.  Tapi bagaimana saya bisa pulang sekarang? "  Diakui sebagai "intent_confirm + intent_how_to_drive", yang memungkinkan Anda membangun dialog yang lebih manusiawi dengan bot. <br><br>  Ngomong-ngomong, sebelum pelatihan, Anda dapat membuat kalimat buatan dari contoh dengan mencampur yang sudah ada untuk menambah jumlah contoh pelatihan. <br><br><h3>  <font color="#cc0000">Pengakuan entitas RASA</font> </h3><br>  Bagian kedua dari NLU adalah ekstraksi entitas dari teks.  Sebagai contoh, seorang pengguna menulis, "Saya ingin pergi ke restoran Cina dengan dua teman," bot tidak hanya menyoroti niat, tetapi juga data yang sesuai dengannya.  Yaitu, isi ingatan Anda bahwa hidangan di restoran harus Cina, dan jumlah pengunjung adalah tiga. <br><br>  Untuk ini, pendekatan berdasarkan Conditional Random Fields digunakan, yang sudah dijelaskan di suatu tempat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HabrÃ©</a> , jadi saya tidak akan mengulanginya.  Mereka yang ingin dapat membaca tentang algoritma ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web Stanford</a> . <br><br>  Selain itu, saya perhatikan bahwa Anda dapat memperoleh entitas dari teks berdasarkan templat, teks (misalnya, nama kota), serta terhubung ke layanan Itik Facebook terpisah, yang juga baik untuk menulis tentang suatu hari nanti. <br><br><h3>  <font color="#cc0000">Cerita RASA</font> </h3><br>  Paus biru kedua yang menjadi dasar RASA Core adalah cerita.  Esensi umum dari cerita adalah contoh percakapan nyata dengan bot, diformat sebagai reaksi-niat.  Berdasarkan kisah-kisah ini, sebuah jaringan saraf berulang (LSTM) dilatih, yang memetakan riwayat pesan sebelumnya ke tindakan yang diinginkan.  Ini memungkinkan Anda untuk tidak mengatur grafik dialog secara kaku, serta tidak menentukan semua keadaan dan transisi yang mungkin di antara mereka. <br><br>  Dengan jumlah contoh yang cukup, jaringan akan cukup memprediksi keadaan selanjutnya untuk transisi, terlepas dari keberadaan contoh tertentu.  Sayangnya, jumlah persis cerita untuk ini tidak diketahui, dan yang bisa dipandu adalah frasa para pengembang: "semakin banyak, semakin baik." <br><br>  Untuk melatih sistem, tidak hanya merekam beberapa dialog yang dibuat di sana, Anda dapat menggunakan pelatihan interaktif. <br><br>  Ada dua opsi: <br>  1. Buat sejumlah insinyur terlibat dalam percakapan dengan bot, mengoreksi prediksi yang salah, definisi entitas yang salah dan busi dengan memprediksi tindakan pada cerita. <br><br>  2. Simpan percakapan ke database dan kemudian terus menggunakan insinyur yang terlatih khusus untuk melihat dialog-dialog di mana pengguna tidak bisa menyelesaikan masalahnya, yaitu, beralih ke seseorang, atau bot mengakui ketidakberdayaannya dan tidak bisa menjawab. <br><br>  Untuk memahami mekanisme cerita, paling mudah untuk menguraikan beberapa contoh sederhana.  Katakanlah reservasi meja di restoran, contoh yang disediakan oleh pengembang di bagian contoh kode sumber.  Pertama kita akan menentukan niat kita, dan kemudian kita akan membuat beberapa cerita. <br><br>  Niat dan contoh mereka: <br><br>  Intent_hello <br><ul><li>  Hai </li><li>  Halo </li><li>  Aloha </li><li>  Selamat pagi </li></ul><br>  ... <br>  Intent_thanks <br><ul><li>  Terima kasih </li><li>  Bagus </li><li>  Terima kasih </li></ul><br>  ... <br>  Intent_request <br><ul><li>  Sampai jumpa </li></ul><br>  Intent_information <br><ul><li>  Sampai jumpa </li></ul><br>  Selanjutnya, Anda perlu membuat memori bot, yaitu, menentukan slot di mana apa yang dibutuhkan pengguna akan direkam.  Tentukan slotnya: <br><br>  masakan: <br>  jenis: tidak jenuh <br>  auto_fill: false <br>  num_people: <br>  jenis: tidak jenuh <br>  auto_fill: false <br><br>  Dan sekarang kita akan menunjukkan contoh (sebagian kecil) untuk niat yang dihilangkan di atas.  Tanda kurung dalam contoh adalah data untuk pelatihan Ner_CRF, dalam format [entitas] (nama variabel untuk penyimpanan: apa yang kami simpan). <br><br>  intent_request_restaurant <br><ul><li>  Saya sedang mencari restoran </li><li>  bisakah saya mendapatkan makanan [masakan Swedia] untuk [enam orang] (num_people: 6) </li><li>  sebuah restoran yang menyajikan makanan [karibia] (masakan) </li><li>  id seperti restoran </li><li>  Saya sedang mencari restoran yang menyajikan makanan (masakan) Mediterania </li></ul><br>  intent_information <br><ul><li>  [2] (num_people) orang </li><li>  untuk [tiga] (num_people: 3) orang </li><li>  hanya [satu] (num_people: 1) orang </li><li>  bagaimana dengan [oriental asia] (masakan) </li><li>  bagaimana dengan makanan (India) </li><li>  eh bagaimana dengan jenis makanan [turki] (masakan) </li><li>  um [bahasa inggris] (masakan) </li></ul><br>  Sekarang kita menentukan sejarah jalur utama: <br><br>  * salam <br>  - utter_greet <br>  * Intent_request <br>  - restaurant_form <br>  - form {"name": "restaurant_form"} <br>  - form {"name": null} <br>  - action_book_restaurant <br>  * terima kasih <br>  - utter_noworries <br><br>  Itulah bot yang sempurna untuk dunia yang sempurna.  Jika pengguna segera menunjukkan semua data yang diperlukan dalam kalimat pertama, maka sebuah tabel akan disediakan.  Misalnya, ia menulis, "Aku ingin memesan meja di restoran Spanyol untuk lima orang."  Dalam hal ini, num_people akan berusia 5 tahun, dan masakan - Spanyol, yang cukup untuk bot untuk tindakan lebih lanjut pada pemesanan. <br><br>  Namun, jika Anda melihat contoh, Anda dapat melihat bahwa data tidak selalu hadir dalam jumlah yang diperlukan, dan kadang-kadang tidak sama sekali.  Maka muncul dialog non-inti. <br><br>  Misalkan tidak ada data tentang dapur dalam permintaan, yaitu, sesuatu seperti dialog ini: <br>  Halo <br>  Hai <br>  Saya ingin memesan restoran untuk lima orang <br>  ... <br><br>  Agar itu selesai dengan benar, Anda perlu menentukan riwayat formulir berikut: <br>  * salam <br>  - utter_greet <br>  * Intent_request <br>  - restaurant_form <br>  - form {"name": "restaurant_form"} <br>  - slot {"asked_slot": "num_people"} <br>  - utter_ask_coven <br>  * formulir: informasikan {"masakan": "meksiko"} <br>  - slot {"cuisine": "mexican"} <br>  - form: restaurant_form <br>  ... <br><br>  Dan bagian terbaiknya adalah bahwa jika Anda membuat cerita untuk beberapa dapur, maka, bertemu orang asing, bot akan memprediksi tindakan selanjutnya dengan sendirinya, meskipun itu tidak akan terlalu yakin.  Pada saat yang sama, jika Anda membuat cerita yang serupa, tetapi di mana slot "masakan" diisi, dan bukan slot "num_people", maka bot sama sekali tidak peduli dalam urutan apa informasi tentang parameter reservasi tabel akan diberikan. <br><br>  Ada dua cara untuk menghentikan upaya apa pun untuk mengarahkan bot dari jalan yang benar: untuk mengidentifikasi cerita yang mungkin untuk berbicara "tentang apa-apa", atau untuk semua upaya untuk memulai percakapan seperti itu - untuk menjawab bahwa ada baiknya kembali ke bisnis. <br><br>  Karena perusahaan kami pada awal perjalanan yang luar biasa ke dunia chatbots, ada kemungkinan bahwa akan ada artikel baru tentang apa yang kami kumpulkan dan apa yang kami lakukan.  Tetap disini! <br><br><img src="https://habrastorage.org/webt/23/uz/eq/23uzeqjeu53ummt2ywqdlaiubmi.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470754/">https://habr.com/ru/post/id470754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470742/index.html">Persamaan Navier-Stokes dan simulasi fluida pada CUDA</a></li>
<li><a href="../id470744/index.html">Matematika Mengungkap Rahasia Umpan Balik Sel Langsung</a></li>
<li><a href="../id470746/index.html">Facebook menjadikan percakapan sebagai antarmuka populer berikutnya</a></li>
<li><a href="../id470750/index.html">Amazon ketahuan menangkap produk unggulan</a></li>
<li><a href="../id470752/index.html">Parsing Pembayaran Weechat</a></li>
<li><a href="../id470756/index.html">Membuat aplikasi backend untuk obrolan online Apollo, Node.js</a></li>
<li><a href="../id470758/index.html">Tinjauan aktivitas viral pada September 2019</a></li>
<li><a href="../id470772/index.html">TON: rekomendasi dan praktik terbaik</a></li>
<li><a href="../id470774/index.html">Anotasi Jenis Baru di Python 3.8 (Protokol, Final, TypedDict, Literal)</a></li>
<li><a href="../id470778/index.html">Ulasan drive Seagate ST2000DM008: fast â€œtwoâ€ tanpa overprice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>