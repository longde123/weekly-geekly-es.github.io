<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚜️ 🍛 💅🏽 Jogo 3D Shaders para Iniciantes 💣 🐪 📒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Deseja aprender como adicionar texturas, iluminação, sombras, mapas normais, objetos brilhantes, oclusão do ambiente e outros efeitos ao seu jogo em 3...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jogo 3D Shaders para Iniciantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453300/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/494/983/ba2494983fe869e14d259f717aa8fc19.gif" alt="imagem"></div><br>  Deseja aprender como adicionar texturas, iluminação, sombras, mapas normais, objetos brilhantes, oclusão do ambiente e outros efeitos ao seu jogo em 3D?  Ótimo!  Este artigo apresenta um conjunto de técnicas de sombreamento que podem elevar o nível dos gráficos do seu jogo a novas alturas.  Explico cada técnica de forma que você possa aplicar / portar essas informações em qualquer pilha de ferramentas, seja Godot, Unity ou qualquer outra coisa. <br><br>  Como uma "cola" entre os shaders, decidi usar o magnífico motor de jogo Panda3D e o OpenGL Shading Language (GLSL).  Se você usar a mesma pilha, obterá uma vantagem adicional - aprenderá como usar técnicas de sombreamento especificamente no Panda3D e OpenGL. <br><a name="habracut"></a><br><h2>  Preparação </h2><br>  Abaixo está o sistema que eu usei para desenvolver e testar o código de exemplo. <br><br><h3>  Quarta-feira </h3><br>  O código de amostra foi desenvolvido e testado no seguinte ambiente: <br><br><ul><li>  Manjaro Linux 4.9.135-1-MANJARO </li><li>  Sequência do renderizador OpenGL: GeForce GTX 970 / PCIe / SSE2 </li><li>  Cadeia de versão do OpenGL: 4.6.0 NVIDIA 410.73 </li><li>  g ++ (GCC) 8.2.1 20180831 </li><li>  Panda3D 1.10.1-1 </li></ul><br><h3>  Materiais </h3><br>  Cada um dos materiais do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Blender</a> usados ​​para criar <code>mill-scene.egg</code> possui duas texturas. <br><br>  A primeira textura é um mapa normal, a segunda é um mapa difuso.  Se um objeto usa as normais de seus vértices, um mapa normal "azul claro" é usado.  Devido ao fato de todos os modelos terem os mesmos cartões nas mesmas posições, os shaders podem ser generalizados e aplicados ao nó raiz do gráfico de cena. <br><br>  Observe que o gráfico de cena é um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">recurso da implementação do</a> mecanismo Panda3D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/9c0/14f/19f9c014f06aee0e2204aa95f87c6306.png"></div><br>  Aqui está um mapa normal de uma cor contendo apenas a cor <code>[red = 128, green = 128, blue = 255]</code> . <br><br>  Esta cor indica a unidade normal, indicando na direção positiva do eixo z <code>[0, 0, 1]</code> . <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>] = [ round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br>  Aqui vemos a unidade normal <code>[0, 0, 1]</code> convertida em uma cor azul simples <code>[128, 128, 255]</code> e o azul sólido convertido em uma unidade normal. <br><br>  Isso é descrito com mais detalhes na seção sobre técnicas normais de sobreposição de mapas. <br><br><h3>  Panda3d </h3><br>  Neste exemplo de código, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D é</a> usado como a "cola" entre os shaders.  Isso não afeta as técnicas descritas abaixo, ou seja, você pode usar as informações estudadas aqui em qualquer pilha ou mecanismo de jogo selecionado.  O Panda3D oferece certas comodidades.  No artigo, falei sobre eles, para que você possa encontrar o correspondente na pilha ou recriá-lo você mesmo se não estiver na pilha. <br><br>  Vale considerar que o <code>gl-coordinate-system default</code> , <code>textures-power-2 down</code> e <code>textures-auto-power-2 1</code> foram adicionados ao <code>config.prc</code> .  Eles não estão contidos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">configuração</a> padrão do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D</a> . <br><br>  Por padrão, o Panda3D usa um sistema de coordenadas destro com um eixo z para cima, enquanto o OpenGL usa um sistema de coordenadas destro com um eixo y para cima. <br><br>  <code>gl-coordinate-system default</code> permite que você se livre das transformações entre dois sistemas de coordenadas dentro dos shaders. <br><br>  <code>textures-auto-power-2 1</code> nos permite usar tamanhos de textura que não são potências de dois, se o sistema os suportar. <br><br>  Isso é conveniente ao executar o SSAO ou implementar outras técnicas em uma tela / janela, porque o tamanho da tela / janela geralmente não é uma potência de duas. <br><br>  <code>textures-power-2 down</code> reduz o tamanho das texturas para uma potência de duas se o sistema suportar apenas texturas com tamanhos iguais à potência de duas. <br><br><h2>  Código de exemplo de compilação </h2><br>  Se você deseja executar o código de amostra, primeiro crie-o. <br><br>  O Panda3D é executado no Linux, Mac e Windows. <br><br><h3>  Linux </h3><br>  Comece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">instalando o</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D SDK</a> para sua distribuição. <br><br>  Descubra onde estão os cabeçalhos e bibliotecas do Panda3D.  Provavelmente, eles estão localizados em <code>/usr/include/panda3d/</code> e em <code>/usr/lib/panda3d/</code> . <br><br>  Em seguida, clone este repositório e navegue para seu diretório. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Agora compile o código fonte em um arquivo de saída. <br><br> <code>g++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/usr/include/panda3d/</code> <br> <br>  Após criar o arquivo de saída, crie um arquivo executável associando o arquivo de saída às suas dependências. <br><br> <code>g++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/usr/lib/panda3d \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">manual</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D para</a> mais informações. <br><br><h3>  Mac </h3><br>  Comece instalando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D SDK</a> para Mac. <br><br>  Descubra onde estão os cabeçalhos e as bibliotecas do Panda3D. <br><br>  Em seguida, clone o repositório e navegue para seu diretório. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Agora compile o código fonte em um arquivo de saída.  Você precisa descobrir onde estão os diretórios de inclusão no Python 2.7 e Panda3D. <br><br> <code>clang++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -g \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/Developer/Panda3D/include/</code> <br> <br>  Após criar o arquivo de saída, crie um arquivo executável associando o arquivo de saída às suas dependências. <br><br>  Você precisa descobrir onde as bibliotecas do Panda3D estão localizadas. <br><br> <code>clang++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/Developer/Panda3D/lib \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">manual</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D para</a> mais informações. <br><br><h3>  Windows </h3><br>  Comece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">instalando o</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">SDK</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">do</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D</a> para Windows. <br><br>  Descubra onde estão os cabeçalhos e bibliotecas do Panda3D. <br><br>  Clone este repositório e navegue para seu diretório. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">manual</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D para</a> mais informações. <br><br><h2>  Iniciar demonstração </h2><br>  Depois de criar o código de amostra, você pode executar o arquivo executável ou demonstração.  É assim que eles são executados no Linux ou Mac. <br><br> <code>./3d-game-shaders-for-beginners</code> <br> <br>  E assim eles rodam no Windows: <br><br> <code>3d-game-shaders-for-beginners.exe</code> <br> <br><h3>  Controle de teclado </h3><br>  A demonstração possui um controle de teclado que permite mover a câmera e mudar o estado de vários efeitos. <br><br><h3>  Movimento </h3><br><ul><li>  <code>w</code> - mova-se profundamente para a cena. </li><li>  <code>a</code> - gire a cena no sentido horário. </li><li>  <code>s</code> - afaste-se da cena. </li><li>  <code>d</code> - gire a cena no sentido anti-horário. </li></ul><br><h3>  Efeitos comutáveis </h3><br><ul><li>  <code>y</code> - ative o SSAO. </li><li>  <code>Shift</code> + <code>y</code> - desativa o SSAO. </li><li>  <code>u</code> - inclusão de circuitos. </li><li>  <code>Shift</code> + <code>u</code> - desativa contornos. </li><li>  <code>i</code> - ativar a floração. </li><li>  <code>Shift</code> + <code>i</code> - desativa o bloom. </li><li>  <code>o</code> - ativar mapas normais. </li><li>  <code>Shift</code> + <code>o</code> - desativa os mapas normais. </li><li>  <code>p</code> - inclusão de nevoeiro. </li><li>  <code>Shift</code> + <code>p</code> - desliga o nevoeiro. </li><li>  <code>h</code> - a inclusão da profundidade de campo. </li><li>  <code>Shift</code> + <code>h</code> - desativa a profundidade de campo. </li><li>  <code>j</code> - habilitar a posterização. </li><li>  <code>Shift</code> + <code>j</code> - desativar posterização </li><li>  <code>k</code> - ativar pixelização. </li><li>  <code>Shift</code> + <code>k</code> - desativa a pixelização. </li><li>  <code>l</code> - afiar. </li><li>  <code>Shift</code> + <code>l</code> - desativa a nitidez. </li><li>  <code>n</code> inclusão de grão de filme. </li><li>  <code>Shift</code> + <code>n</code> - desativa a granulação do filme. </li></ul><br><h2>  Sistema de referência </h2><br>  Antes de começar a escrever shaders, você precisa se familiarizar com os seguintes sistemas de referência ou sistemas de coordenadas.  Todos eles se resumem ao que as coordenadas atuais da origem da referência são obtidas <code>(0, 0, 0)</code> .  Assim que descobrimos, podemos transformá-los usando algum tipo de matriz ou outro espaço vetorial.  Normalmente, se a saída de um sombreador não parecer correta, a causa será confusa nos sistemas de coordenadas. <br><br><h3>  Modelo </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/9ce/863/e069ce863ffc7bd3b94394dc20b25687.gif"></div><br>  O sistema de coordenadas do modelo ou objeto é relativo à origem do modelo.  Nos programas de modelagem tridimensional, por exemplo, no Blender, ele geralmente é colocado no centro do modelo. <br><br><h3>  O mundo </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/9de/1f7/d0a9de1f741bb90174efd93d174ef1f9.gif"></div><br>  O espaço do mundo é relativo à origem da cena / nível / universo que você criou. <br><br><h3>  Revisão </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd2/15b/b6e/bd215bb6ee79a6904eba3f6ad4ff56d3.gif"></div><br>  O espaço de coordenadas da vista é relativo à posição da câmera ativa. <br><br><h3>  Clipping </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/505/a34/d77505a349f37a695f77625400857d58.png"></div><br>  Espaço de recorte relativo ao centro do quadro da câmera.  Todas as coordenadas nele são homogêneas e estão no intervalo <code>(-1, 1)</code> .  X e y são paralelos ao filme da câmera e a coordenada z é a profundidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/0be/d7c/dc70bed7ca78c39cc9f538b127d7176e.gif"></div><br>  Todos os vértices que não estão dentro dos limites da pirâmide de visibilidade ou do volume de visibilidade da câmera são cortados ou descartados.  Vemos como isso acontece com um cubo truncado para trás pelo plano mais distante da câmera e com um cubo localizado ao lado. <br><br><h3>  Ecrã </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/47d/336/e5b47d33660b9c1744faa12fec8ef256.png"></div><br>  O espaço da tela é (geralmente) relativo ao canto inferior esquerdo da tela.  X muda de zero para a largura da tela.  Y muda de zero para a altura da tela. <br><br><h2>  GLSL </h2><br>  Em vez de trabalhar com um pipeline de funções fixas, usaremos um pipeline de renderização de GPU programável.  Como é programável, nós mesmos devemos passar o código do programa na forma de shaders.  Um sombreador é um programa (geralmente pequeno) criado com sintaxe semelhante à linguagem C. Um pipeline de renderização de GPU programável consiste em várias etapas que podem ser programadas usando sombreadores.  Diferentes tipos de sombreadores incluem sombreadores de vértice, sombreamento de mosaico, sombreamento geométrico, de fragmento e computacional.  Para usar as técnicas descritas no artigo, basta usar vértice e fragmento <br>  estágios. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 void main() {}</span></span></code> </pre> <br>  Aqui está o shader GLSL mínimo, consistindo no número da versão do GLSL e na função principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec4 p3d_Vertex; void main() { gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Aqui está o sombreador de vértice truncado GLSL, que transforma o vértice de entrada em espaço de recorte e exibe essa nova posição como uma posição uniforme de vértice. <br><br>  O procedimento <code>main</code> não retorna nada, porque é <code>void</code> , e a variável <code>gl_Position</code> é a saída embutida. <br><br>  Duas palavras-chave que vale a pena mencionar são: <code>uniform</code> e <code>in</code> . <br><br>  A palavra-chave <code>uniform</code> significa que essa variável global é a mesma para todos os vértices.  O próprio Panda3D define <code>p3d_ModelViewProjectionMatrix</code> e, para cada vértice, é a mesma matriz. <br><br>  A palavra-chave <code>in</code> significa que essa variável global é passada para o shader.  Um shader de vértice obtém cada vértice em que a geometria consiste, ao qual um shader de vértice está anexado. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 out vec4 fragColor; void main() { fragColor = vec4(0, 1, 0, 1); }</span></span></code> </pre> <br>  Aqui está o shader de fragmento GLSL aparado, exibindo verde opaco como a cor do fragmento. <br><br>  Não esqueça que um fragmento afeta apenas um pixel da tela, mas vários fragmentos podem afetar um pixel. <br><br>  Preste atenção à palavra-chave out. <br><br>  A palavra <code>out</code> chave <code>out</code> significa que essa variável global é definida pelo shader. <br><br>  O nome <code>fragColor</code> opcional, para que você possa escolher outro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/276/b2d/8b4276b2d7e735cc05484e80e0c046e8.gif"></div><br>  Aqui está a saída dos dois shaders mostrados acima. <br><br><h2>  Renderização de textura </h2><br>  Em vez de renderizar / desenhar diretamente na tela, o código de exemplo usa uma técnica para <br>  o nome "renderizar para textura" (renderizar para textura).  Para renderizar em uma textura, você precisa configurar o buffer de quadro e vincular a textura a ele.  Você pode vincular várias texturas a um único buffer de quadro. <br><br>  As texturas vinculadas ao buffer do quadro armazenam os vetores retornados pelo sombreador de fragmento.  Geralmente esses vetores são vetores coloridos <code>(r, g, b, a)</code> , mas podem ser posições ou vetores normais <code>(x, y, z, w)</code> .  Para cada textura vinculada, um shader de fragmento pode gerar um vetor separado.  Por exemplo, podemos deduzir em uma passagem a posição e o normal do vértice. <br><br>  A maior parte do código de exemplo que funciona com o Panda3D está relacionada à configuração <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">das texturas do buffer de quadros</a> .  Para simplificar, cada sombreador de fragmento no código de exemplo tem apenas uma saída.  No entanto, para garantir uma alta taxa de quadros (FPS), precisamos gerar o máximo de informações possível em cada passo de renderização. <br><br>  Aqui estão duas estruturas de textura para o buffer de quadro do código de exemplo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/d2b/d50/ac9d2bd50cd1c0bc991ffe7569bf5432.gif"></div><br>  A primeira estrutura renderiza uma cena do moinho de água em uma textura de buffer de quadro usando uma variedade de shaders de vértice e fragmento.  Essa estrutura passa por cada um dos vértices do palco com o moinho e ao longo dos fragmentos correspondentes. <br><br>  Nessa estrutura, o código de exemplo funciona da seguinte maneira. <br><br><ul><li>  Salva os dados da geometria (por exemplo, posição ou vértice normal) para uso futuro. </li><li>  Salva dados do material (por exemplo, cores difusas) para uso futuro. </li><li>  Cria ligação UV de diferentes texturas (mapas difusos, normais, mapas de sombras, etc.). </li><li>  Calcula a iluminação ambiente, difusa, refletida e emitida. </li><li>  Torna neblina. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/554/0c2/7e55540c20fe190246f3180b3f06a731.png"></div><br>  A segunda estrutura é uma câmera ortogonal voltada para um retângulo no formato de uma tela. <br>  Essa estrutura percorre apenas quatro picos e seus fragmentos correspondentes. <br><br>  Na segunda estrutura, o código de amostra executa as seguintes ações: <br><br><ul><li>  Processa a saída de outra textura de buffer de quadro. </li><li>  Combina diferentes texturas de buffer de quadro em um. </li></ul><br>  No exemplo de código, podemos ver a saída de uma textura de buffer de quadro, configurando o quadro correspondente como true e false para todos os outros. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... bool showPositionBuffer = false; bool showNormalBuffer = false; bool showSsaoBuffer = false; bool showSsaoBlurBuffer = false; bool showMaterialDiffuseBuffer = false; bool showOutlineBuffer = false; bool showBaseBuffer = false; bool showSharpenBuffer = false; bool showBloomBuffer = false; bool showCombineBuffer = false; bool showCombineBlurBuffer = false; bool showDepthOfFieldBuffer = false; bool showPosterizeBuffer = false; bool showPixelizeBuffer = false; bool showFilmGrainBuffer = true; // ...</span></span></code> </pre> <br><h2>  Texturização </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/0eb/1c6/d1c0eb1c650b9b05e2372b33259ed8a6.gif"></div><br>  Texturização é a ligação de uma cor ou outro vetor a um fragmento usando coordenadas UV.  Os valores de U e V variam de zero a um.  Cada vértice recebe uma coordenada UV e é exibida no sombreador de vértices. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/487/fee/519487fee2bb16357b225ce32649fb91.png"></div><br>  O shader de fragmento obtém a coordenada UV interpolada.  Interpolação significa que a coordenada UV do fragmento está em algum lugar entre as coordenadas UV dos vértices que compõem a face do triângulo. <br><br><h3>  Sombreador de vértice </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec2 p3d_MultiTexCoord0; in vec4 p3d_Vertex; out vec2 texCoord; void main() { texCoord = p3d_MultiTexCoord0; gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Aqui vemos que o sombreador de vértice gera a coordenada da textura para o sombreador de fragmento.  Observe que este é um vetor bidimensional: um valor para U e outro para V. <br><br><h3>  Tonalizador de fragmentos </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D p3d_Texture0; in vec2 texCoord; out vec2 fragColor; void main() { texColor = texture(p3d_Texture0, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Aqui vemos que o sombreador do fragmento procura a cor em sua coordenada UV e a exibe como a cor do fragmento. <br><br><h4>  Textura de preenchimento de tela </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D screenSizedTexture; out vec2 fragColor; void main() { vec2 texSize = textureSize(texture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; texColor = texture(screenSizedTexture, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Ao renderizar em uma textura, a malha é um retângulo plano com a mesma proporção da tela.  Portanto, podemos calcular as coordenadas UV, sabendo apenas <br><br>  A) a largura e a altura da textura com o tamanho da tela sobreposta no retângulo usando coordenadas UV, e <br>  B) as coordenadas x e y do fragmento. <br><br>  Para vincular x a U, é necessário dividir x pela largura da textura recebida.  Da mesma forma, para vincular y a V, é necessário dividir y pela altura da textura recebida.  Você verá que essa técnica é usada no código de exemplo. <br><br><h2>  Iluminação </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/05e/0ca/f9805e0ca9717c961dd9618f49475381.gif"></div><br>  Para determinar a iluminação, é necessário calcular e combinar aspectos da iluminação ambiente, difusa, refletida e emitida.  O código de exemplo usa iluminação Phong. <br><br><h3>  Sombreador de vértice </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_LightSourceParameters { vec4 color ; vec4 ambient ; vec4 diffuse ; vec4 specular ; vec4 position ; vec3 spotDirection ; float spotExponent ; float spotCutoff ; float spotCosCutoff ; float constantAttenuation ; float linearAttenuation ; float quadraticAttenuation ; vec3 attenuation ; sampler2DShadow shadowMap ; mat4 shadowViewMatrix ; } p3d_LightSource[NUMBER_OF_LIGHTS]; // ...</span></span></code> </pre><br>  Para cada fonte de luz, com exceção da luz ambiente, o Panda3D nos fornece uma estrutura conveniente disponível para shaders de vértice e de fragmento.  O mais conveniente é um mapa de sombras e uma matriz para visualizar sombras para converter vértices em um espaço de sombras ou iluminação. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vertexPosition = p3d_ModelViewMatrix * p3d_Vertex; // ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { vertexInShadowSpaces[i] = p3d_LightSource[i].shadowViewMatrix * vertexPosition; } // ...</span></span></code> </pre> <br>  Começando com o sombreador de vértices, devemos transformar e remover o vértice do espaço de visualização na sombra ou no espaço de iluminação de cada fonte de luz na cena.  Isso será útil no futuro para o shader de fragmento renderizar sombras.  Um espaço de sombra ou iluminação é um espaço no qual cada coordenada é relativa à posição da fonte de luz (a origem é a fonte de luz). <br><br><h3>  Tonalizador de fragmentos </h3><br>  O sombreador de fragmento faz a maior parte do cálculo da iluminação. <br><br><h4>  Material </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct { vec4 ambient ; vec4 diffuse ; vec4 emission ; vec3 specular ; float shininess ; } p3d_Material; // ...</span></span></code> </pre> <br>  O Panda3D nos fornece material (na forma de uma estrutura) para a malha ou modelo que estamos processando atualmente. <br><br><h4>  Várias fontes de iluminação </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuseSpecular = vec4(0.0, 0.0, 0.0, 0.0); // ...</span></span></code> </pre> <br>  Antes de darmos uma olhada nas fontes de iluminação da cena, criaremos uma unidade que conterá cores difusas e refletidas. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { // ... } // ...</span></span></code> </pre> <br>  Agora podemos percorrer as fontes de luz em um ciclo, calculando as cores difusas e refletidas para cada uma. <br><br><h4>  Vetores relacionados de iluminação </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/035/ce7/307035ce7bf5a52b8f25c7aeb862b9d4.gif"></div><br>  Aqui estão quatro vetores básicos necessários para calcular as cores difusas e refletidas introduzidas por cada fonte de luz.  O vetor de direção da iluminação é uma seta azul apontando para a fonte de luz.  O vetor normal é uma seta verde apontando verticalmente para cima.  O vetor de reflexão é uma seta azul que reflete o vetor de direção da luz.  O vetor olho ou vista é a seta laranja apontando em direção à câmera. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lightDirection = p3d_LightSource[i].position.xyz - vertexPosition.xyz * p3d_LightSource[i].position.w; // ...</span></span></code> </pre> <br>  A direção da iluminação é o vetor da posição do vértice para a posição da fonte de luz. <br><br>  Se for uma iluminação direcional, o Panda3D definirá <code>p3d_LightSource[i].position.w</code> zero.  A iluminação direcional não tem posição, apenas direção.  Portanto, se essa é uma iluminação direcional, a direção da iluminação será uma direção negativa ou oposta à fonte, porque para iluminação direcional o Panda3D define <code>p3d_LightSource[i].position.xyz</code> como <code>p3d_LightSource[i].position.xyz</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... normal = normalize(vertexNormal); // ...</span></span></code> </pre> <br>  O normal para o vértice deve ser um vetor de unidade.  Os vetores unitários têm um valor igual a um. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 unitLightDirection = normalize(lightDirection); vec3 eyeDirection = normalize(-vertexPosition.xyz); vec3 reflectedDirection = normalize(-reflect(unitLightDirection, normal)); // ...</span></span></code> </pre> <br>  Em seguida, precisamos de mais três vetores. <br><br>  Precisamos de um produto escalar com a participação da direção da iluminação, por isso é melhor normalizá-lo.  Isso nos dá uma distância ou magnitude igual à unidade (vetor unitário). <br><br>  A direção da visão é oposta à posição do vértice / fragmento, porque a posição do vértice / fragmento é relativa à posição da câmera.  Não esqueça que a posição do vértice / fragmento está no espaço de visualização.  Portanto, em vez de passar da câmera (olho) para o vértice / fragmento, passamos do vértice / fragmento para a câmera (olho). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">O vetor de reflexão</a> é um reflexo da direção da iluminação normal da superfície.  Quando o "raio" da luz toca a superfície, é refletido no mesmo ângulo em que caiu.  O ângulo entre o vetor de direção da iluminação e o normal é chamado de "ângulo de incidência".  O ângulo entre o vetor de reflexão e o normal é chamado de "ângulo de reflexão". <br><br>  Você precisa alterar o sinal do vetor de luz refletida, porque ele deve apontar na mesma direção que o vetor do olho.  Não esqueça que a direção do olho vai do topo / fragmento para a posição da câmera.  Usaremos o vetor de reflexão para calcular o brilho da luz refletida. <br><br><h4>  Iluminação difusa </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float diffuseIntensity = max(dot(normal, unitLightDirection), 0.0); if (diffuseIntensity &gt; 0) { // ... } // ...</span></span></code> </pre> <br>  O brilho da iluminação difusa é o produto escalar do normal para a superfície e a direção da iluminação de um único vetor.  O produto escalar pode variar de menos um a um.  Se os dois vetores apontam na mesma direção, o brilho é a unidade.  Em todos os outros casos, será menor que a unidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/168/5bc/5e7/1685bc5e759e638b5c2bcc4a6c56bbd3.gif"></div><br>  Se o vetor de iluminação se aproximar da mesma direção que o normal, o brilho da iluminação difusa tende a se unir. <br><br>  Se o brilho da iluminação difusa for menor ou igual a zero, será necessário ir para a próxima fonte de luz. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuse = vec4 ( clamp ( diffuseTex.rgb * p3d_LightSource[i].diffuse.rgb * diffuseIntensity , 0 , 1 ) , 1 ); diffuse.r = clamp(diffuse.r, 0, diffuseTex.r); diffuse.g = clamp(diffuse.g, 0, diffuseTex.g); diffuse.b = clamp(diffuse.b, 0, diffuseTex.b); // ...</span></span></code> </pre> <br>  Agora podemos calcular a cor difusa introduzida por esta fonte.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o brilho da iluminação difusa for unificado, a cor difusa será uma mistura da cor da textura difusa e da cor da iluminação. </font><font style="vertical-align: inherit;">Em qualquer outro brilho, a cor difusa será mais escura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que limito a cor difusa para que não fique mais brilhante que a cor da textura difusa. </font><font style="vertical-align: inherit;">Isso evitará a superexposição da cena.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luz refletida </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Após a iluminação difusa, o refletido é calculado. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/ade/77c/989ade77c01b7137f437f97fe83ccd17.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 specular = clamp ( vec4(p3d_Material.specular, 1) * p3d_LightSource[i].specular * pow ( max(dot(reflectedDirection, eyeDirection), 0) , p3d_Material.shininess ) , 0 , 1 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O brilho da luz refletida é o produto escalar entre o vetor do olho e o vetor de reflexão. </font><font style="vertical-align: inherit;">Como no caso do brilho da iluminação difusa, se dois vetores estão apontando na mesma direção, o brilho da iluminação refletida é igual à unidade. </font><font style="vertical-align: inherit;">Qualquer outro brilho reduzirá a quantidade de cor refletida introduzida por esta fonte de luz.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/046/570/c2e046570e770e1804544d6ae67ae2f8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O brilho do material determina quanto a iluminação da luz refletida será dispersa. </font><font style="vertical-align: inherit;">Geralmente é definido em um programa de simulação, por exemplo no Blender. </font><font style="vertical-align: inherit;">No Blender, isso é chamado de dureza especular.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Holofotes </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float unitLightDirectionDelta = dot ( normalize(p3d_LightSource[i].spotDirection) , -unitLightDirection ); if (unitLightDirectionDelta &gt;= p3d_LightSource[i].spotCosCutoff) { // ... } // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este código não permite que a iluminação afete fragmentos fora do cone ou pirâmide do refletor. </font><font style="vertical-align: inherit;">Felizmente, Panda3D pode </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definir</font></font></a> <code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trabalhar com luzes direcionais e spot. </font><font style="vertical-align: inherit;">Os holofotes têm uma posição e uma direção. </font><font style="vertical-align: inherit;">No entanto, a iluminação direcional tem apenas direção e as fontes pontuais têm apenas posição. </font><font style="vertical-align: inherit;">No entanto, esse código funciona para todos os três tipos de iluminação sem a necessidade de declarações if confusas.</font></font><br><br><pre> <code class="cpp hljs">spotCosCutoff = cosine(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * spotlightLensFovAngle);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se no caso da projeção iluminar o produto escalar do vetor "fonte de iluminação de fragmento" e o vetor de direção do projetor for menor que o cosseno de metade do ângulo do campo de visão do </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projetor, o sombreador não leva em consideração a influência dessa fonte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que você deve alterar o sinal </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vai do fragmento para o holofote e precisamos passar do holofote para o fragmento, porque </font></font><code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vai diretamente para o centro da pirâmide do holofote a uma certa distância da posição do holofote. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso de iluminação direcional e pontual, o Panda3D define o </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor como -1. Lembre-se de que o produto escalar varia no intervalo de -1 a 1. Portanto, não importa qual será </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pois é sempre maior ou igual a -1.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuse *= pow(unitLightDirectionDelta, p3d_LightSource[i].spotExponent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o código </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, esse código também funciona para todos os três tipos de fontes de luz. </font><font style="vertical-align: inherit;">No caso dos refletores, os fragmentos ficam mais brilhantes à medida que se aproxima do centro da pirâmide dos refletores. </font><font style="vertical-align: inherit;">Para fontes direcionais e pontuais de luz </font></font><code>spotExponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é zero. </font><font style="vertical-align: inherit;">Lembre-se de que qualquer valor à potência de zero é igual à unidade, portanto a cor difusa é igual a si mesma, multiplicada por um, ou seja, não muda.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombras </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float shadow = textureProj ( p3d_LightSource[i].shadowMap , vertexInShadowSpaces[i] ); diffuse.rgb *= shadow; specular.rgb *= shadow; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Panda3D simplifica o uso de sombras porque cria um mapa de sombras e uma matriz de transformação de sombras para cada fonte de luz na cena. Para criar você mesmo uma matriz de transformação, colete uma matriz que converta as coordenadas do espaço de visualização no espaço de iluminação (as coordenadas são relativas à posição da fonte de luz). Para criar um mapa de sombras você mesmo, é necessário renderizar a cena do ponto de vista da fonte de luz na textura do buffer do quadro. A textura do buffer do quadro deve conter a distância da fonte de luz aos fragmentos. Isso é chamado de "mapa de profundidade". Finalmente, você precisa transferir manualmente para o shader seu mapa de profundidade caseiro como </font></font><code>uniform sampler2DShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a matriz de transformação de sombra como </font></font><code>uniform mat4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Então, vamos recriar o que o Panda3D faz automaticamente por nós.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O snippet de código mostrado é usado </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, diferente da função mostrada acima </font></font><code>texture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro divide </font></font><code>vertexInShadowSpaces[i].xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>vertexInShadowSpaces[i].w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ela então o usa </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para encontrar a profundidade armazenada no mapa de sombras. Então, ela usa </font></font><code>vertexInShadowSpaces[i].z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para comparar a profundidade do topo com a profundidade do mapa de sombras </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se a comparação for bem-sucedida, ela </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornará um. Caso contrário, ele retornará zero. Zero significa que esse vértice / fragmento está na sombra e um significa que o vértice / fragmento não está na sombra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele também pode retornar um valor de zero a um, dependendo de como o mapa de sombra está configurado. Neste exemplo</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Executa vários testes de profundidade com base em profundidades adjacentes e retorna uma média ponderada. </font><font style="vertical-align: inherit;">Essa média ponderada pode dar suavidade às sombras.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atenuação </font></font></h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/e8d/bfb/381e8dbfb118dac85b139d0c1ec41bad.png"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float lightDistance = length(lightDirection); float attenuation = 1 / ( p3d_LightSource[i].constantAttenuation + p3d_LightSource[i].linearAttenuation * lightDistance + p3d_LightSource[i].quadraticAttenuation * (lightDistance * lightDistance) ); diffuse.rgb *= attenuation; specular.rgb *= attenuation; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A distância para a fonte de luz é simplesmente a magnitude ou o comprimento do vetor de direção da iluminação. </font><font style="vertical-align: inherit;">Observe que não usamos a direção normal da iluminação, porque essa distância seria igual à unidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A distância da fonte de luz é necessária para calcular a atenuação. </font><font style="vertical-align: inherit;">Atenuação significa que o efeito da luz longe da fonte diminui. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parâmetros </font></font><code>constantAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>quadraticAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">você pode definir quaisquer valores. </font><font style="vertical-align: inherit;">Vale a pena começar com </font></font><code>constantAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>quadraticAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Com esses parâmetros, na posição da fonte de luz, é igual à unidade e tende a zero ao se afastar dela.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iluminação final a cores </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuseSpecular += (diffuse + specular); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular a cor final da iluminação, é necessário adicionar a cor difusa e refletida. </font><font style="vertical-align: inherit;">É necessário adicionar isso ao inversor em um ciclo de desvio das fontes de luz na cena.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambiente </font></font></h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture1; // ... uniform struct { vec4 ambient ; } p3d_LightModel; // ... in vec2 diffuseCoord; // ... vec4 diffuseTex = texture(p3d_Texture1, diffuseCoord); // ... vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O componente de iluminação ambiente no modelo de iluminação é baseado na cor ambiente do material, na cor da iluminação ambiente e na cor da textura difusa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nunca deve haver mais de uma fonte de luz ambiente; portanto, esse cálculo deve ser realizado apenas uma vez, em contraste com os cálculos de cores difusas e refletidas acumuladas para cada fonte de luz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que a cor da luz ambiente é útil ao executar o SSAO.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Juntando tudo </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 outputColor = ambient + diffuseSpecular + p3d_Material.emission; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A cor final é a soma da cor ambiente, cor difusa, cor refletida e cor emitida. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Código fonte </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mapas normais </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/6bb/9de/6d16bb9deae1520429083896b7492a3f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O uso de mapas normais permite adicionar novas peças à superfície sem geometria adicional. </font><font style="vertical-align: inherit;">Normalmente, ao trabalhar em um programa de modelagem 3D, são criadas versões alta e baixa poli da malha. </font><font style="vertical-align: inherit;">Em seguida, os normais dos vértices da malha poli alta são retirados e cozidos na textura. </font><font style="vertical-align: inherit;">Essa textura é um mapa normal. </font><font style="vertical-align: inherit;">Em seguida, dentro do shader de fragmento, substituímos as normais dos vértices da malha poli baixa pelas normais da malha poli alta inseridas no mapa normal. </font><font style="vertical-align: inherit;">Devido a isso, ao iluminar uma malha, parece que ela tem mais polígonos do que realmente é. </font><font style="vertical-align: inherit;">Isso permite que você mantenha alto FPS, enquanto transmite a maioria dos detalhes da versão high-poly.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/92b/4ae/8e192b4ae48d96a65b92456ba640c7d0.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui vemos a transição de um modelo de alto poli para um modelo de baixo poli e, em seguida, para um modelo de baixo poli com um mapa normal sobreposto. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/20d/ee1/98720dee1f77246721e1905abf2ebea4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, não esqueça que a sobreposição de um mapa normal é apenas uma ilusão. </font><font style="vertical-align: inherit;">Em um certo ângulo, a superfície começa a parecer plana novamente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombreador de vértice </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform mat3 p3d_NormalMatrix; // ... in vec3 p3d_Normal; // ... in vec3 p3d_Binormal; in vec3 p3d_Tangent; // ... vertexNormal = normalize(p3d_NormalMatrix * p3d_Normal); binormal = normalize(p3d_NormalMatrix * p3d_Binormal); tangent = normalize(p3d_NormalMatrix * p3d_Tangent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Começando com o vertex shader, precisamos gerar o vetor normal, o vetor binormal e o tangente para o fragment shader. </font><font style="vertical-align: inherit;">Esses vetores são usados ​​no sombreador de fragmentos para transformar o normal do mapa normal do espaço tangente para o espaço de visualização. </font></font><br><br> <code>p3d_NormalMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converte os vetores normais do vetor de vértice, binormal e tangente para o espaço de visualização. </font><font style="vertical-align: inherit;">Não esqueça que no espaço de visualização todas as coordenadas são relativas à posição da câmera.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[p3d_NormalMatrix] são os principais elementos de transposição reversa 3x3 do ModelViewMatrix. </font><font style="vertical-align: inherit;">Essa estrutura é usada para converter o vetor normal nas coordenadas do espaço de visualização.</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Fonte</a> </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... in vec2 p3d_MultiTexCoord0; // ... out vec2 normalCoord; // ... normalCoord = p3d_MultiTexCoord0; // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b40/f21/575/b40f21575482aa633de61643a1c497aa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Também precisamos enviar as coordenadas UV do mapa normal para o shader de fragmentos. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tonalizador de fragmentos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que o vértice normal foi usado para calcular a iluminação. </font><font style="vertical-align: inherit;">No entanto, para calcular a iluminação, o mapa normal nos dá outras normais. </font><font style="vertical-align: inherit;">No shader de fragmento, precisamos substituir as normais dos vértices pelas normais localizadas no mapa normal.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture0; // ... in vec2 normalCoord; // ... /* Find */ vec4 normalTex = texture(p3d_Texture0, normalCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando as coordenadas do mapa normal transferidas pelo shader de vértice, extraímos o normal correspondente do mapa. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 normal; // ... /* Unpack */ normal = normalize ( normalTex.rgb * 2.0 - 1.0 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acima, mostrei como as normais são convertidas em cores para criar mapas normais. </font><font style="vertical-align: inherit;">Agora precisamos reverter esse processo para que possamos obter os normais originais no mapa.</font></font><br><br><pre> <code class="cpp hljs">[ r, g, b] = [ r * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, g * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, b * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ x, y, z]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui está como é o processo de descompactar os normais do mapa normal. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... /* Transform */ normal = normalize ( mat3 ( tangent , binormal , vertexNormal ) * normal ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As normais obtidas no mapa normal geralmente estão no espaço tangente. </font><font style="vertical-align: inherit;">No entanto, eles podem estar em outro espaço. </font><font style="vertical-align: inherit;">Por exemplo, o Blender permite que você crie normais no espaço tangente, no espaço de objetos, no mundo e no espaço da câmera.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/009/cfc/62c/009cfc62c03b455a1e22b68e8636e735.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para transferir a normal do mapa normal do espaço tangente para o espaço de visualização, crie uma matriz 3x3 com base no vetor tangente, vetores binormais e vértice normal. </font><font style="vertical-align: inherit;">Multiplique o normal por esta matriz e normalize-o. </font><font style="vertical-align: inherit;">É aqui que acabamos com os normais. </font><font style="vertical-align: inherit;">Todos os outros cálculos de iluminação ainda são realizados.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Código fonte </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453300/">https://habr.com/ru/post/pt453300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453290/index.html">Data Science Digest (maio de 2019)</a></li>
<li><a href="../pt453292/index.html">"Um livrinho sobre buracos negros"</a></li>
<li><a href="../pt453294/index.html">Reagir Carregamento lento</a></li>
<li><a href="../pt453296/index.html">Gerenciando a assincronia no PHP: das promessas às corotinas</a></li>
<li><a href="../pt453298/index.html">Verão: hora de atualizar ... você mesmo</a></li>
<li><a href="../pt453302/index.html">A primeira hora de vida com Yandex.Module</a></li>
<li><a href="../pt453304/index.html">Principais benefícios do Zextras PowerStore</a></li>
<li><a href="../pt453306/index.html">Kubernetes vai dominar o mundo. Quando e como?</a></li>
<li><a href="../pt453310/index.html">Troque dados entre componentes do React usando a biblioteca RxJS</a></li>
<li><a href="../pt453312/index.html">Gerador de e-mail comercial em PDF com base em dados XML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>