<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öúÔ∏è üçõ üíÖüèΩ Jogo 3D Shaders para Iniciantes üí£ üê™ üìí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Deseja aprender como adicionar texturas, ilumina√ß√£o, sombras, mapas normais, objetos brilhantes, oclus√£o do ambiente e outros efeitos ao seu jogo em 3...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jogo 3D Shaders para Iniciantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453300/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/494/983/ba2494983fe869e14d259f717aa8fc19.gif" alt="imagem"></div><br>  Deseja aprender como adicionar texturas, ilumina√ß√£o, sombras, mapas normais, objetos brilhantes, oclus√£o do ambiente e outros efeitos ao seu jogo em 3D?  √ìtimo!  Este artigo apresenta um conjunto de t√©cnicas de sombreamento que podem elevar o n√≠vel dos gr√°ficos do seu jogo a novas alturas.  Explico cada t√©cnica de forma que voc√™ possa aplicar / portar essas informa√ß√µes em qualquer pilha de ferramentas, seja Godot, Unity ou qualquer outra coisa. <br><br>  Como uma "cola" entre os shaders, decidi usar o magn√≠fico motor de jogo Panda3D e o OpenGL Shading Language (GLSL).  Se voc√™ usar a mesma pilha, obter√° uma vantagem adicional - aprender√° como usar t√©cnicas de sombreamento especificamente no Panda3D e OpenGL. <br><a name="habracut"></a><br><h2>  Prepara√ß√£o </h2><br>  Abaixo est√° o sistema que eu usei para desenvolver e testar o c√≥digo de exemplo. <br><br><h3>  Quarta-feira </h3><br>  O c√≥digo de amostra foi desenvolvido e testado no seguinte ambiente: <br><br><ul><li>  Manjaro Linux 4.9.135-1-MANJARO </li><li>  Sequ√™ncia do renderizador OpenGL: GeForce GTX 970 / PCIe / SSE2 </li><li>  Cadeia de vers√£o do OpenGL: 4.6.0 NVIDIA 410.73 </li><li>  g ++ (GCC) 8.2.1 20180831 </li><li>  Panda3D 1.10.1-1 </li></ul><br><h3>  Materiais </h3><br>  Cada um dos materiais do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Blender</a> usados ‚Äã‚Äãpara criar <code>mill-scene.egg</code> possui duas texturas. <br><br>  A primeira textura √© um mapa normal, a segunda √© um mapa difuso.  Se um objeto usa as normais de seus v√©rtices, um mapa normal "azul claro" √© usado.  Devido ao fato de todos os modelos terem os mesmos cart√µes nas mesmas posi√ß√µes, os shaders podem ser generalizados e aplicados ao n√≥ raiz do gr√°fico de cena. <br><br>  Observe que o gr√°fico de cena √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">recurso da implementa√ß√£o do</a> mecanismo Panda3D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/9c0/14f/19f9c014f06aee0e2204aa95f87c6306.png"></div><br>  Aqui est√° um mapa normal de uma cor contendo apenas a cor <code>[red = 128, green = 128, blue = 255]</code> . <br><br>  Esta cor indica a unidade normal, indicando na dire√ß√£o positiva do eixo z <code>[0, 0, 1]</code> . <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>] = [ round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br>  Aqui vemos a unidade normal <code>[0, 0, 1]</code> convertida em uma cor azul simples <code>[128, 128, 255]</code> e o azul s√≥lido convertido em uma unidade normal. <br><br>  Isso √© descrito com mais detalhes na se√ß√£o sobre t√©cnicas normais de sobreposi√ß√£o de mapas. <br><br><h3>  Panda3d </h3><br>  Neste exemplo de c√≥digo, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D √©</a> usado como a "cola" entre os shaders.  Isso n√£o afeta as t√©cnicas descritas abaixo, ou seja, voc√™ pode usar as informa√ß√µes estudadas aqui em qualquer pilha ou mecanismo de jogo selecionado.  O Panda3D oferece certas comodidades.  No artigo, falei sobre eles, para que voc√™ possa encontrar o correspondente na pilha ou recri√°-lo voc√™ mesmo se n√£o estiver na pilha. <br><br>  Vale considerar que o <code>gl-coordinate-system default</code> , <code>textures-power-2 down</code> e <code>textures-auto-power-2 1</code> foram adicionados ao <code>config.prc</code> .  Eles n√£o est√£o contidos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">configura√ß√£o</a> padr√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D</a> . <br><br>  Por padr√£o, o Panda3D usa um sistema de coordenadas destro com um eixo z para cima, enquanto o OpenGL usa um sistema de coordenadas destro com um eixo y para cima. <br><br>  <code>gl-coordinate-system default</code> permite que voc√™ se livre das transforma√ß√µes entre dois sistemas de coordenadas dentro dos shaders. <br><br>  <code>textures-auto-power-2 1</code> nos permite usar tamanhos de textura que n√£o s√£o pot√™ncias de dois, se o sistema os suportar. <br><br>  Isso √© conveniente ao executar o SSAO ou implementar outras t√©cnicas em uma tela / janela, porque o tamanho da tela / janela geralmente n√£o √© uma pot√™ncia de duas. <br><br>  <code>textures-power-2 down</code> reduz o tamanho das texturas para uma pot√™ncia de duas se o sistema suportar apenas texturas com tamanhos iguais √† pot√™ncia de duas. <br><br><h2>  C√≥digo de exemplo de compila√ß√£o </h2><br>  Se voc√™ deseja executar o c√≥digo de amostra, primeiro crie-o. <br><br>  O Panda3D √© executado no Linux, Mac e Windows. <br><br><h3>  Linux </h3><br>  Comece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">instalando o</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D SDK</a> para sua distribui√ß√£o. <br><br>  Descubra onde est√£o os cabe√ßalhos e bibliotecas do Panda3D.  Provavelmente, eles est√£o localizados em <code>/usr/include/panda3d/</code> e em <code>/usr/lib/panda3d/</code> . <br><br>  Em seguida, clone este reposit√≥rio e navegue para seu diret√≥rio. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Agora compile o c√≥digo fonte em um arquivo de sa√≠da. <br><br> <code>g++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/usr/include/panda3d/</code> <br> <br>  Ap√≥s criar o arquivo de sa√≠da, crie um arquivo execut√°vel associando o arquivo de sa√≠da √†s suas depend√™ncias. <br><br> <code>g++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/usr/lib/panda3d \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">manual</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D para</a> mais informa√ß√µes. <br><br><h3>  Mac </h3><br>  Comece instalando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D SDK</a> para Mac. <br><br>  Descubra onde est√£o os cabe√ßalhos e as bibliotecas do Panda3D. <br><br>  Em seguida, clone o reposit√≥rio e navegue para seu diret√≥rio. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Agora compile o c√≥digo fonte em um arquivo de sa√≠da.  Voc√™ precisa descobrir onde est√£o os diret√≥rios de inclus√£o no Python 2.7 e Panda3D. <br><br> <code>clang++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -g \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/Developer/Panda3D/include/</code> <br> <br>  Ap√≥s criar o arquivo de sa√≠da, crie um arquivo execut√°vel associando o arquivo de sa√≠da √†s suas depend√™ncias. <br><br>  Voc√™ precisa descobrir onde as bibliotecas do Panda3D est√£o localizadas. <br><br> <code>clang++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/Developer/Panda3D/lib \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">manual</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D para</a> mais informa√ß√µes. <br><br><h3>  Windows </h3><br>  Comece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">instalando o</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">SDK</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">do</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D</a> para Windows. <br><br>  Descubra onde est√£o os cabe√ßalhos e bibliotecas do Panda3D. <br><br>  Clone este reposit√≥rio e navegue para seu diret√≥rio. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">manual</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Panda3D para</a> mais informa√ß√µes. <br><br><h2>  Iniciar demonstra√ß√£o </h2><br>  Depois de criar o c√≥digo de amostra, voc√™ pode executar o arquivo execut√°vel ou demonstra√ß√£o.  √â assim que eles s√£o executados no Linux ou Mac. <br><br> <code>./3d-game-shaders-for-beginners</code> <br> <br>  E assim eles rodam no Windows: <br><br> <code>3d-game-shaders-for-beginners.exe</code> <br> <br><h3>  Controle de teclado </h3><br>  A demonstra√ß√£o possui um controle de teclado que permite mover a c√¢mera e mudar o estado de v√°rios efeitos. <br><br><h3>  Movimento </h3><br><ul><li>  <code>w</code> - mova-se profundamente para a cena. </li><li>  <code>a</code> - gire a cena no sentido hor√°rio. </li><li>  <code>s</code> - afaste-se da cena. </li><li>  <code>d</code> - gire a cena no sentido anti-hor√°rio. </li></ul><br><h3>  Efeitos comut√°veis </h3><br><ul><li>  <code>y</code> - ative o SSAO. </li><li>  <code>Shift</code> + <code>y</code> - desativa o SSAO. </li><li>  <code>u</code> - inclus√£o de circuitos. </li><li>  <code>Shift</code> + <code>u</code> - desativa contornos. </li><li>  <code>i</code> - ativar a flora√ß√£o. </li><li>  <code>Shift</code> + <code>i</code> - desativa o bloom. </li><li>  <code>o</code> - ativar mapas normais. </li><li>  <code>Shift</code> + <code>o</code> - desativa os mapas normais. </li><li>  <code>p</code> - inclus√£o de nevoeiro. </li><li>  <code>Shift</code> + <code>p</code> - desliga o nevoeiro. </li><li>  <code>h</code> - a inclus√£o da profundidade de campo. </li><li>  <code>Shift</code> + <code>h</code> - desativa a profundidade de campo. </li><li>  <code>j</code> - habilitar a posteriza√ß√£o. </li><li>  <code>Shift</code> + <code>j</code> - desativar posteriza√ß√£o </li><li>  <code>k</code> - ativar pixeliza√ß√£o. </li><li>  <code>Shift</code> + <code>k</code> - desativa a pixeliza√ß√£o. </li><li>  <code>l</code> - afiar. </li><li>  <code>Shift</code> + <code>l</code> - desativa a nitidez. </li><li>  <code>n</code> inclus√£o de gr√£o de filme. </li><li>  <code>Shift</code> + <code>n</code> - desativa a granula√ß√£o do filme. </li></ul><br><h2>  Sistema de refer√™ncia </h2><br>  Antes de come√ßar a escrever shaders, voc√™ precisa se familiarizar com os seguintes sistemas de refer√™ncia ou sistemas de coordenadas.  Todos eles se resumem ao que as coordenadas atuais da origem da refer√™ncia s√£o obtidas <code>(0, 0, 0)</code> .  Assim que descobrimos, podemos transform√°-los usando algum tipo de matriz ou outro espa√ßo vetorial.  Normalmente, se a sa√≠da de um sombreador n√£o parecer correta, a causa ser√° confusa nos sistemas de coordenadas. <br><br><h3>  Modelo </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/9ce/863/e069ce863ffc7bd3b94394dc20b25687.gif"></div><br>  O sistema de coordenadas do modelo ou objeto √© relativo √† origem do modelo.  Nos programas de modelagem tridimensional, por exemplo, no Blender, ele geralmente √© colocado no centro do modelo. <br><br><h3>  O mundo </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/9de/1f7/d0a9de1f741bb90174efd93d174ef1f9.gif"></div><br>  O espa√ßo do mundo √© relativo √† origem da cena / n√≠vel / universo que voc√™ criou. <br><br><h3>  Revis√£o </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd2/15b/b6e/bd215bb6ee79a6904eba3f6ad4ff56d3.gif"></div><br>  O espa√ßo de coordenadas da vista √© relativo √† posi√ß√£o da c√¢mera ativa. <br><br><h3>  Clipping </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/505/a34/d77505a349f37a695f77625400857d58.png"></div><br>  Espa√ßo de recorte relativo ao centro do quadro da c√¢mera.  Todas as coordenadas nele s√£o homog√™neas e est√£o no intervalo <code>(-1, 1)</code> .  X e y s√£o paralelos ao filme da c√¢mera e a coordenada z √© a profundidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/0be/d7c/dc70bed7ca78c39cc9f538b127d7176e.gif"></div><br>  Todos os v√©rtices que n√£o est√£o dentro dos limites da pir√¢mide de visibilidade ou do volume de visibilidade da c√¢mera s√£o cortados ou descartados.  Vemos como isso acontece com um cubo truncado para tr√°s pelo plano mais distante da c√¢mera e com um cubo localizado ao lado. <br><br><h3>  Ecr√£ </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/47d/336/e5b47d33660b9c1744faa12fec8ef256.png"></div><br>  O espa√ßo da tela √© (geralmente) relativo ao canto inferior esquerdo da tela.  X muda de zero para a largura da tela.  Y muda de zero para a altura da tela. <br><br><h2>  GLSL </h2><br>  Em vez de trabalhar com um pipeline de fun√ß√µes fixas, usaremos um pipeline de renderiza√ß√£o de GPU program√°vel.  Como √© program√°vel, n√≥s mesmos devemos passar o c√≥digo do programa na forma de shaders.  Um sombreador √© um programa (geralmente pequeno) criado com sintaxe semelhante √† linguagem C. Um pipeline de renderiza√ß√£o de GPU program√°vel consiste em v√°rias etapas que podem ser programadas usando sombreadores.  Diferentes tipos de sombreadores incluem sombreadores de v√©rtice, sombreamento de mosaico, sombreamento geom√©trico, de fragmento e computacional.  Para usar as t√©cnicas descritas no artigo, basta usar v√©rtice e fragmento <br>  est√°gios. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 void main() {}</span></span></code> </pre> <br>  Aqui est√° o shader GLSL m√≠nimo, consistindo no n√∫mero da vers√£o do GLSL e na fun√ß√£o principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec4 p3d_Vertex; void main() { gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Aqui est√° o sombreador de v√©rtice truncado GLSL, que transforma o v√©rtice de entrada em espa√ßo de recorte e exibe essa nova posi√ß√£o como uma posi√ß√£o uniforme de v√©rtice. <br><br>  O procedimento <code>main</code> n√£o retorna nada, porque √© <code>void</code> , e a vari√°vel <code>gl_Position</code> √© a sa√≠da embutida. <br><br>  Duas palavras-chave que vale a pena mencionar s√£o: <code>uniform</code> e <code>in</code> . <br><br>  A palavra-chave <code>uniform</code> significa que essa vari√°vel global √© a mesma para todos os v√©rtices.  O pr√≥prio Panda3D define <code>p3d_ModelViewProjectionMatrix</code> e, para cada v√©rtice, √© a mesma matriz. <br><br>  A palavra-chave <code>in</code> significa que essa vari√°vel global √© passada para o shader.  Um shader de v√©rtice obt√©m cada v√©rtice em que a geometria consiste, ao qual um shader de v√©rtice est√° anexado. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 out vec4 fragColor; void main() { fragColor = vec4(0, 1, 0, 1); }</span></span></code> </pre> <br>  Aqui est√° o shader de fragmento GLSL aparado, exibindo verde opaco como a cor do fragmento. <br><br>  N√£o esque√ßa que um fragmento afeta apenas um pixel da tela, mas v√°rios fragmentos podem afetar um pixel. <br><br>  Preste aten√ß√£o √† palavra-chave out. <br><br>  A palavra <code>out</code> chave <code>out</code> significa que essa vari√°vel global √© definida pelo shader. <br><br>  O nome <code>fragColor</code> opcional, para que voc√™ possa escolher outro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/276/b2d/8b4276b2d7e735cc05484e80e0c046e8.gif"></div><br>  Aqui est√° a sa√≠da dos dois shaders mostrados acima. <br><br><h2>  Renderiza√ß√£o de textura </h2><br>  Em vez de renderizar / desenhar diretamente na tela, o c√≥digo de exemplo usa uma t√©cnica para <br>  o nome "renderizar para textura" (renderizar para textura).  Para renderizar em uma textura, voc√™ precisa configurar o buffer de quadro e vincular a textura a ele.  Voc√™ pode vincular v√°rias texturas a um √∫nico buffer de quadro. <br><br>  As texturas vinculadas ao buffer do quadro armazenam os vetores retornados pelo sombreador de fragmento.  Geralmente esses vetores s√£o vetores coloridos <code>(r, g, b, a)</code> , mas podem ser posi√ß√µes ou vetores normais <code>(x, y, z, w)</code> .  Para cada textura vinculada, um shader de fragmento pode gerar um vetor separado.  Por exemplo, podemos deduzir em uma passagem a posi√ß√£o e o normal do v√©rtice. <br><br>  A maior parte do c√≥digo de exemplo que funciona com o Panda3D est√° relacionada √† configura√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">das texturas do buffer de quadros</a> .  Para simplificar, cada sombreador de fragmento no c√≥digo de exemplo tem apenas uma sa√≠da.  No entanto, para garantir uma alta taxa de quadros (FPS), precisamos gerar o m√°ximo de informa√ß√µes poss√≠vel em cada passo de renderiza√ß√£o. <br><br>  Aqui est√£o duas estruturas de textura para o buffer de quadro do c√≥digo de exemplo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/d2b/d50/ac9d2bd50cd1c0bc991ffe7569bf5432.gif"></div><br>  A primeira estrutura renderiza uma cena do moinho de √°gua em uma textura de buffer de quadro usando uma variedade de shaders de v√©rtice e fragmento.  Essa estrutura passa por cada um dos v√©rtices do palco com o moinho e ao longo dos fragmentos correspondentes. <br><br>  Nessa estrutura, o c√≥digo de exemplo funciona da seguinte maneira. <br><br><ul><li>  Salva os dados da geometria (por exemplo, posi√ß√£o ou v√©rtice normal) para uso futuro. </li><li>  Salva dados do material (por exemplo, cores difusas) para uso futuro. </li><li>  Cria liga√ß√£o UV de diferentes texturas (mapas difusos, normais, mapas de sombras, etc.). </li><li>  Calcula a ilumina√ß√£o ambiente, difusa, refletida e emitida. </li><li>  Torna neblina. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/554/0c2/7e55540c20fe190246f3180b3f06a731.png"></div><br>  A segunda estrutura √© uma c√¢mera ortogonal voltada para um ret√¢ngulo no formato de uma tela. <br>  Essa estrutura percorre apenas quatro picos e seus fragmentos correspondentes. <br><br>  Na segunda estrutura, o c√≥digo de amostra executa as seguintes a√ß√µes: <br><br><ul><li>  Processa a sa√≠da de outra textura de buffer de quadro. </li><li>  Combina diferentes texturas de buffer de quadro em um. </li></ul><br>  No exemplo de c√≥digo, podemos ver a sa√≠da de uma textura de buffer de quadro, configurando o quadro correspondente como true e false para todos os outros. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... bool showPositionBuffer = false; bool showNormalBuffer = false; bool showSsaoBuffer = false; bool showSsaoBlurBuffer = false; bool showMaterialDiffuseBuffer = false; bool showOutlineBuffer = false; bool showBaseBuffer = false; bool showSharpenBuffer = false; bool showBloomBuffer = false; bool showCombineBuffer = false; bool showCombineBlurBuffer = false; bool showDepthOfFieldBuffer = false; bool showPosterizeBuffer = false; bool showPixelizeBuffer = false; bool showFilmGrainBuffer = true; // ...</span></span></code> </pre> <br><h2>  Texturiza√ß√£o </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/0eb/1c6/d1c0eb1c650b9b05e2372b33259ed8a6.gif"></div><br>  Texturiza√ß√£o √© a liga√ß√£o de uma cor ou outro vetor a um fragmento usando coordenadas UV.  Os valores de U e V variam de zero a um.  Cada v√©rtice recebe uma coordenada UV e √© exibida no sombreador de v√©rtices. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/487/fee/519487fee2bb16357b225ce32649fb91.png"></div><br>  O shader de fragmento obt√©m a coordenada UV interpolada.  Interpola√ß√£o significa que a coordenada UV do fragmento est√° em algum lugar entre as coordenadas UV dos v√©rtices que comp√µem a face do tri√¢ngulo. <br><br><h3>  Sombreador de v√©rtice </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec2 p3d_MultiTexCoord0; in vec4 p3d_Vertex; out vec2 texCoord; void main() { texCoord = p3d_MultiTexCoord0; gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Aqui vemos que o sombreador de v√©rtice gera a coordenada da textura para o sombreador de fragmento.  Observe que este √© um vetor bidimensional: um valor para U e outro para V. <br><br><h3>  Tonalizador de fragmentos </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D p3d_Texture0; in vec2 texCoord; out vec2 fragColor; void main() { texColor = texture(p3d_Texture0, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Aqui vemos que o sombreador do fragmento procura a cor em sua coordenada UV e a exibe como a cor do fragmento. <br><br><h4>  Textura de preenchimento de tela </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D screenSizedTexture; out vec2 fragColor; void main() { vec2 texSize = textureSize(texture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; texColor = texture(screenSizedTexture, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Ao renderizar em uma textura, a malha √© um ret√¢ngulo plano com a mesma propor√ß√£o da tela.  Portanto, podemos calcular as coordenadas UV, sabendo apenas <br><br>  A) a largura e a altura da textura com o tamanho da tela sobreposta no ret√¢ngulo usando coordenadas UV, e <br>  B) as coordenadas x e y do fragmento. <br><br>  Para vincular x a U, √© necess√°rio dividir x pela largura da textura recebida.  Da mesma forma, para vincular y a V, √© necess√°rio dividir y pela altura da textura recebida.  Voc√™ ver√° que essa t√©cnica √© usada no c√≥digo de exemplo. <br><br><h2>  Ilumina√ß√£o </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/05e/0ca/f9805e0ca9717c961dd9618f49475381.gif"></div><br>  Para determinar a ilumina√ß√£o, √© necess√°rio calcular e combinar aspectos da ilumina√ß√£o ambiente, difusa, refletida e emitida.  O c√≥digo de exemplo usa ilumina√ß√£o Phong. <br><br><h3>  Sombreador de v√©rtice </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_LightSourceParameters { vec4 color ; vec4 ambient ; vec4 diffuse ; vec4 specular ; vec4 position ; vec3 spotDirection ; float spotExponent ; float spotCutoff ; float spotCosCutoff ; float constantAttenuation ; float linearAttenuation ; float quadraticAttenuation ; vec3 attenuation ; sampler2DShadow shadowMap ; mat4 shadowViewMatrix ; } p3d_LightSource[NUMBER_OF_LIGHTS]; // ...</span></span></code> </pre><br>  Para cada fonte de luz, com exce√ß√£o da luz ambiente, o Panda3D nos fornece uma estrutura conveniente dispon√≠vel para shaders de v√©rtice e de fragmento.  O mais conveniente √© um mapa de sombras e uma matriz para visualizar sombras para converter v√©rtices em um espa√ßo de sombras ou ilumina√ß√£o. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vertexPosition = p3d_ModelViewMatrix * p3d_Vertex; // ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { vertexInShadowSpaces[i] = p3d_LightSource[i].shadowViewMatrix * vertexPosition; } // ...</span></span></code> </pre> <br>  Come√ßando com o sombreador de v√©rtices, devemos transformar e remover o v√©rtice do espa√ßo de visualiza√ß√£o na sombra ou no espa√ßo de ilumina√ß√£o de cada fonte de luz na cena.  Isso ser√° √∫til no futuro para o shader de fragmento renderizar sombras.  Um espa√ßo de sombra ou ilumina√ß√£o √© um espa√ßo no qual cada coordenada √© relativa √† posi√ß√£o da fonte de luz (a origem √© a fonte de luz). <br><br><h3>  Tonalizador de fragmentos </h3><br>  O sombreador de fragmento faz a maior parte do c√°lculo da ilumina√ß√£o. <br><br><h4>  Material </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct { vec4 ambient ; vec4 diffuse ; vec4 emission ; vec3 specular ; float shininess ; } p3d_Material; // ...</span></span></code> </pre> <br>  O Panda3D nos fornece material (na forma de uma estrutura) para a malha ou modelo que estamos processando atualmente. <br><br><h4>  V√°rias fontes de ilumina√ß√£o </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuseSpecular = vec4(0.0, 0.0, 0.0, 0.0); // ...</span></span></code> </pre> <br>  Antes de darmos uma olhada nas fontes de ilumina√ß√£o da cena, criaremos uma unidade que conter√° cores difusas e refletidas. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { // ... } // ...</span></span></code> </pre> <br>  Agora podemos percorrer as fontes de luz em um ciclo, calculando as cores difusas e refletidas para cada uma. <br><br><h4>  Vetores relacionados de ilumina√ß√£o </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/035/ce7/307035ce7bf5a52b8f25c7aeb862b9d4.gif"></div><br>  Aqui est√£o quatro vetores b√°sicos necess√°rios para calcular as cores difusas e refletidas introduzidas por cada fonte de luz.  O vetor de dire√ß√£o da ilumina√ß√£o √© uma seta azul apontando para a fonte de luz.  O vetor normal √© uma seta verde apontando verticalmente para cima.  O vetor de reflex√£o √© uma seta azul que reflete o vetor de dire√ß√£o da luz.  O vetor olho ou vista √© a seta laranja apontando em dire√ß√£o √† c√¢mera. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lightDirection = p3d_LightSource[i].position.xyz - vertexPosition.xyz * p3d_LightSource[i].position.w; // ...</span></span></code> </pre> <br>  A dire√ß√£o da ilumina√ß√£o √© o vetor da posi√ß√£o do v√©rtice para a posi√ß√£o da fonte de luz. <br><br>  Se for uma ilumina√ß√£o direcional, o Panda3D definir√° <code>p3d_LightSource[i].position.w</code> zero.  A ilumina√ß√£o direcional n√£o tem posi√ß√£o, apenas dire√ß√£o.  Portanto, se essa √© uma ilumina√ß√£o direcional, a dire√ß√£o da ilumina√ß√£o ser√° uma dire√ß√£o negativa ou oposta √† fonte, porque para ilumina√ß√£o direcional o Panda3D define <code>p3d_LightSource[i].position.xyz</code> como <code>p3d_LightSource[i].position.xyz</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... normal = normalize(vertexNormal); // ...</span></span></code> </pre> <br>  O normal para o v√©rtice deve ser um vetor de unidade.  Os vetores unit√°rios t√™m um valor igual a um. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 unitLightDirection = normalize(lightDirection); vec3 eyeDirection = normalize(-vertexPosition.xyz); vec3 reflectedDirection = normalize(-reflect(unitLightDirection, normal)); // ...</span></span></code> </pre> <br>  Em seguida, precisamos de mais tr√™s vetores. <br><br>  Precisamos de um produto escalar com a participa√ß√£o da dire√ß√£o da ilumina√ß√£o, por isso √© melhor normaliz√°-lo.  Isso nos d√° uma dist√¢ncia ou magnitude igual √† unidade (vetor unit√°rio). <br><br>  A dire√ß√£o da vis√£o √© oposta √† posi√ß√£o do v√©rtice / fragmento, porque a posi√ß√£o do v√©rtice / fragmento √© relativa √† posi√ß√£o da c√¢mera.  N√£o esque√ßa que a posi√ß√£o do v√©rtice / fragmento est√° no espa√ßo de visualiza√ß√£o.  Portanto, em vez de passar da c√¢mera (olho) para o v√©rtice / fragmento, passamos do v√©rtice / fragmento para a c√¢mera (olho). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">O vetor de reflex√£o</a> √© um reflexo da dire√ß√£o da ilumina√ß√£o normal da superf√≠cie.  Quando o "raio" da luz toca a superf√≠cie, √© refletido no mesmo √¢ngulo em que caiu.  O √¢ngulo entre o vetor de dire√ß√£o da ilumina√ß√£o e o normal √© chamado de "√¢ngulo de incid√™ncia".  O √¢ngulo entre o vetor de reflex√£o e o normal √© chamado de "√¢ngulo de reflex√£o". <br><br>  Voc√™ precisa alterar o sinal do vetor de luz refletida, porque ele deve apontar na mesma dire√ß√£o que o vetor do olho.  N√£o esque√ßa que a dire√ß√£o do olho vai do topo / fragmento para a posi√ß√£o da c√¢mera.  Usaremos o vetor de reflex√£o para calcular o brilho da luz refletida. <br><br><h4>  Ilumina√ß√£o difusa </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float diffuseIntensity = max(dot(normal, unitLightDirection), 0.0); if (diffuseIntensity &gt; 0) { // ... } // ...</span></span></code> </pre> <br>  O brilho da ilumina√ß√£o difusa √© o produto escalar do normal para a superf√≠cie e a dire√ß√£o da ilumina√ß√£o de um √∫nico vetor.  O produto escalar pode variar de menos um a um.  Se os dois vetores apontam na mesma dire√ß√£o, o brilho √© a unidade.  Em todos os outros casos, ser√° menor que a unidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/168/5bc/5e7/1685bc5e759e638b5c2bcc4a6c56bbd3.gif"></div><br>  Se o vetor de ilumina√ß√£o se aproximar da mesma dire√ß√£o que o normal, o brilho da ilumina√ß√£o difusa tende a se unir. <br><br>  Se o brilho da ilumina√ß√£o difusa for menor ou igual a zero, ser√° necess√°rio ir para a pr√≥xima fonte de luz. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuse = vec4 ( clamp ( diffuseTex.rgb * p3d_LightSource[i].diffuse.rgb * diffuseIntensity , 0 , 1 ) , 1 ); diffuse.r = clamp(diffuse.r, 0, diffuseTex.r); diffuse.g = clamp(diffuse.g, 0, diffuseTex.g); diffuse.b = clamp(diffuse.b, 0, diffuseTex.b); // ...</span></span></code> </pre> <br>  Agora podemos calcular a cor difusa introduzida por esta fonte.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o brilho da ilumina√ß√£o difusa for unificado, a cor difusa ser√° uma mistura da cor da textura difusa e da cor da ilumina√ß√£o. </font><font style="vertical-align: inherit;">Em qualquer outro brilho, a cor difusa ser√° mais escura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que limito a cor difusa para que n√£o fique mais brilhante que a cor da textura difusa. </font><font style="vertical-align: inherit;">Isso evitar√° a superexposi√ß√£o da cena.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luz refletida </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ap√≥s a ilumina√ß√£o difusa, o refletido √© calculado. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/ade/77c/989ade77c01b7137f437f97fe83ccd17.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 specular = clamp ( vec4(p3d_Material.specular, 1) * p3d_LightSource[i].specular * pow ( max(dot(reflectedDirection, eyeDirection), 0) , p3d_Material.shininess ) , 0 , 1 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O brilho da luz refletida √© o produto escalar entre o vetor do olho e o vetor de reflex√£o. </font><font style="vertical-align: inherit;">Como no caso do brilho da ilumina√ß√£o difusa, se dois vetores est√£o apontando na mesma dire√ß√£o, o brilho da ilumina√ß√£o refletida √© igual √† unidade. </font><font style="vertical-align: inherit;">Qualquer outro brilho reduzir√° a quantidade de cor refletida introduzida por esta fonte de luz.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/046/570/c2e046570e770e1804544d6ae67ae2f8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O brilho do material determina quanto a ilumina√ß√£o da luz refletida ser√° dispersa. </font><font style="vertical-align: inherit;">Geralmente √© definido em um programa de simula√ß√£o, por exemplo no Blender. </font><font style="vertical-align: inherit;">No Blender, isso √© chamado de dureza especular.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Holofotes </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float unitLightDirectionDelta = dot ( normalize(p3d_LightSource[i].spotDirection) , -unitLightDirection ); if (unitLightDirectionDelta &gt;= p3d_LightSource[i].spotCosCutoff) { // ... } // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este c√≥digo n√£o permite que a ilumina√ß√£o afete fragmentos fora do cone ou pir√¢mide do refletor. </font><font style="vertical-align: inherit;">Felizmente, Panda3D pode </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definir</font></font></a> <code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trabalhar com luzes direcionais e spot. </font><font style="vertical-align: inherit;">Os holofotes t√™m uma posi√ß√£o e uma dire√ß√£o. </font><font style="vertical-align: inherit;">No entanto, a ilumina√ß√£o direcional tem apenas dire√ß√£o e as fontes pontuais t√™m apenas posi√ß√£o. </font><font style="vertical-align: inherit;">No entanto, esse c√≥digo funciona para todos os tr√™s tipos de ilumina√ß√£o sem a necessidade de declara√ß√µes if confusas.</font></font><br><br><pre> <code class="cpp hljs">spotCosCutoff = cosine(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * spotlightLensFovAngle);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se no caso da proje√ß√£o iluminar o produto escalar do vetor "fonte de ilumina√ß√£o de fragmento" e o vetor de dire√ß√£o do projetor for menor que o cosseno de metade do √¢ngulo do campo de vis√£o do </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projetor, o sombreador n√£o leva em considera√ß√£o a influ√™ncia dessa fonte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que voc√™ deve alterar o sinal </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vai do fragmento para o holofote e precisamos passar do holofote para o fragmento, porque </font></font><code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vai diretamente para o centro da pir√¢mide do holofote a uma certa dist√¢ncia da posi√ß√£o do holofote. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso de ilumina√ß√£o direcional e pontual, o Panda3D define o </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor como -1. Lembre-se de que o produto escalar varia no intervalo de -1 a 1. Portanto, n√£o importa qual ser√° </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pois √© sempre maior ou igual a -1.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuse *= pow(unitLightDirectionDelta, p3d_LightSource[i].spotExponent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o c√≥digo </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, esse c√≥digo tamb√©m funciona para todos os tr√™s tipos de fontes de luz. </font><font style="vertical-align: inherit;">No caso dos refletores, os fragmentos ficam mais brilhantes √† medida que se aproxima do centro da pir√¢mide dos refletores. </font><font style="vertical-align: inherit;">Para fontes direcionais e pontuais de luz </font></font><code>spotExponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© zero. </font><font style="vertical-align: inherit;">Lembre-se de que qualquer valor √† pot√™ncia de zero √© igual √† unidade, portanto a cor difusa √© igual a si mesma, multiplicada por um, ou seja, n√£o muda.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombras </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float shadow = textureProj ( p3d_LightSource[i].shadowMap , vertexInShadowSpaces[i] ); diffuse.rgb *= shadow; specular.rgb *= shadow; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Panda3D simplifica o uso de sombras porque cria um mapa de sombras e uma matriz de transforma√ß√£o de sombras para cada fonte de luz na cena. Para criar voc√™ mesmo uma matriz de transforma√ß√£o, colete uma matriz que converta as coordenadas do espa√ßo de visualiza√ß√£o no espa√ßo de ilumina√ß√£o (as coordenadas s√£o relativas √† posi√ß√£o da fonte de luz). Para criar um mapa de sombras voc√™ mesmo, √© necess√°rio renderizar a cena do ponto de vista da fonte de luz na textura do buffer do quadro. A textura do buffer do quadro deve conter a dist√¢ncia da fonte de luz aos fragmentos. Isso √© chamado de "mapa de profundidade". Finalmente, voc√™ precisa transferir manualmente para o shader seu mapa de profundidade caseiro como </font></font><code>uniform sampler2DShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a matriz de transforma√ß√£o de sombra como </font></font><code>uniform mat4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ent√£o, vamos recriar o que o Panda3D faz automaticamente por n√≥s.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O snippet de c√≥digo mostrado √© usado </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, diferente da fun√ß√£o mostrada acima </font></font><code>texture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro divide </font></font><code>vertexInShadowSpaces[i].xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>vertexInShadowSpaces[i].w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ela ent√£o o usa </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para encontrar a profundidade armazenada no mapa de sombras. Ent√£o, ela usa </font></font><code>vertexInShadowSpaces[i].z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para comparar a profundidade do topo com a profundidade do mapa de sombras </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se a compara√ß√£o for bem-sucedida, ela </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornar√° um. Caso contr√°rio, ele retornar√° zero. Zero significa que esse v√©rtice / fragmento est√° na sombra e um significa que o v√©rtice / fragmento n√£o est√° na sombra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele tamb√©m pode retornar um valor de zero a um, dependendo de como o mapa de sombra est√° configurado. Neste exemplo</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Executa v√°rios testes de profundidade com base em profundidades adjacentes e retorna uma m√©dia ponderada. </font><font style="vertical-align: inherit;">Essa m√©dia ponderada pode dar suavidade √†s sombras.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atenua√ß√£o </font></font></h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/e8d/bfb/381e8dbfb118dac85b139d0c1ec41bad.png"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float lightDistance = length(lightDirection); float attenuation = 1 / ( p3d_LightSource[i].constantAttenuation + p3d_LightSource[i].linearAttenuation * lightDistance + p3d_LightSource[i].quadraticAttenuation * (lightDistance * lightDistance) ); diffuse.rgb *= attenuation; specular.rgb *= attenuation; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A dist√¢ncia para a fonte de luz √© simplesmente a magnitude ou o comprimento do vetor de dire√ß√£o da ilumina√ß√£o. </font><font style="vertical-align: inherit;">Observe que n√£o usamos a dire√ß√£o normal da ilumina√ß√£o, porque essa dist√¢ncia seria igual √† unidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A dist√¢ncia da fonte de luz √© necess√°ria para calcular a atenua√ß√£o. </font><font style="vertical-align: inherit;">Atenua√ß√£o significa que o efeito da luz longe da fonte diminui. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par√¢metros </font></font><code>constantAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>quadraticAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voc√™ pode definir quaisquer valores. </font><font style="vertical-align: inherit;">Vale a pena come√ßar com </font></font><code>constantAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>quadraticAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Com esses par√¢metros, na posi√ß√£o da fonte de luz, √© igual √† unidade e tende a zero ao se afastar dela.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ilumina√ß√£o final a cores </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuseSpecular += (diffuse + specular); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular a cor final da ilumina√ß√£o, √© necess√°rio adicionar a cor difusa e refletida. </font><font style="vertical-align: inherit;">√â necess√°rio adicionar isso ao inversor em um ciclo de desvio das fontes de luz na cena.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambiente </font></font></h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture1; // ... uniform struct { vec4 ambient ; } p3d_LightModel; // ... in vec2 diffuseCoord; // ... vec4 diffuseTex = texture(p3d_Texture1, diffuseCoord); // ... vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O componente de ilumina√ß√£o ambiente no modelo de ilumina√ß√£o √© baseado na cor ambiente do material, na cor da ilumina√ß√£o ambiente e na cor da textura difusa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nunca deve haver mais de uma fonte de luz ambiente; portanto, esse c√°lculo deve ser realizado apenas uma vez, em contraste com os c√°lculos de cores difusas e refletidas acumuladas para cada fonte de luz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que a cor da luz ambiente √© √∫til ao executar o SSAO.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Juntando tudo </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 outputColor = ambient + diffuseSpecular + p3d_Material.emission; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A cor final √© a soma da cor ambiente, cor difusa, cor refletida e cor emitida. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fonte </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mapas normais </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/6bb/9de/6d16bb9deae1520429083896b7492a3f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O uso de mapas normais permite adicionar novas pe√ßas √† superf√≠cie sem geometria adicional. </font><font style="vertical-align: inherit;">Normalmente, ao trabalhar em um programa de modelagem 3D, s√£o criadas vers√µes alta e baixa poli da malha. </font><font style="vertical-align: inherit;">Em seguida, os normais dos v√©rtices da malha poli alta s√£o retirados e cozidos na textura. </font><font style="vertical-align: inherit;">Essa textura √© um mapa normal. </font><font style="vertical-align: inherit;">Em seguida, dentro do shader de fragmento, substitu√≠mos as normais dos v√©rtices da malha poli baixa pelas normais da malha poli alta inseridas no mapa normal. </font><font style="vertical-align: inherit;">Devido a isso, ao iluminar uma malha, parece que ela tem mais pol√≠gonos do que realmente √©. </font><font style="vertical-align: inherit;">Isso permite que voc√™ mantenha alto FPS, enquanto transmite a maioria dos detalhes da vers√£o high-poly.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/92b/4ae/8e192b4ae48d96a65b92456ba640c7d0.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui vemos a transi√ß√£o de um modelo de alto poli para um modelo de baixo poli e, em seguida, para um modelo de baixo poli com um mapa normal sobreposto. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/20d/ee1/98720dee1f77246721e1905abf2ebea4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, n√£o esque√ßa que a sobreposi√ß√£o de um mapa normal √© apenas uma ilus√£o. </font><font style="vertical-align: inherit;">Em um certo √¢ngulo, a superf√≠cie come√ßa a parecer plana novamente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombreador de v√©rtice </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform mat3 p3d_NormalMatrix; // ... in vec3 p3d_Normal; // ... in vec3 p3d_Binormal; in vec3 p3d_Tangent; // ... vertexNormal = normalize(p3d_NormalMatrix * p3d_Normal); binormal = normalize(p3d_NormalMatrix * p3d_Binormal); tangent = normalize(p3d_NormalMatrix * p3d_Tangent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Come√ßando com o vertex shader, precisamos gerar o vetor normal, o vetor binormal e o tangente para o fragment shader. </font><font style="vertical-align: inherit;">Esses vetores s√£o usados ‚Äã‚Äãno sombreador de fragmentos para transformar o normal do mapa normal do espa√ßo tangente para o espa√ßo de visualiza√ß√£o. </font></font><br><br> <code>p3d_NormalMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converte os vetores normais do vetor de v√©rtice, binormal e tangente para o espa√ßo de visualiza√ß√£o. </font><font style="vertical-align: inherit;">N√£o esque√ßa que no espa√ßo de visualiza√ß√£o todas as coordenadas s√£o relativas √† posi√ß√£o da c√¢mera.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[p3d_NormalMatrix] s√£o os principais elementos de transposi√ß√£o reversa 3x3 do ModelViewMatrix. </font><font style="vertical-align: inherit;">Essa estrutura √© usada para converter o vetor normal nas coordenadas do espa√ßo de visualiza√ß√£o.</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">Fonte</a> </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... in vec2 p3d_MultiTexCoord0; // ... out vec2 normalCoord; // ... normalCoord = p3d_MultiTexCoord0; // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b40/f21/575/b40f21575482aa633de61643a1c497aa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamb√©m precisamos enviar as coordenadas UV do mapa normal para o shader de fragmentos. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tonalizador de fragmentos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que o v√©rtice normal foi usado para calcular a ilumina√ß√£o. </font><font style="vertical-align: inherit;">No entanto, para calcular a ilumina√ß√£o, o mapa normal nos d√° outras normais. </font><font style="vertical-align: inherit;">No shader de fragmento, precisamos substituir as normais dos v√©rtices pelas normais localizadas no mapa normal.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture0; // ... in vec2 normalCoord; // ... /* Find */ vec4 normalTex = texture(p3d_Texture0, normalCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando as coordenadas do mapa normal transferidas pelo shader de v√©rtice, extra√≠mos o normal correspondente do mapa. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 normal; // ... /* Unpack */ normal = normalize ( normalTex.rgb * 2.0 - 1.0 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acima, mostrei como as normais s√£o convertidas em cores para criar mapas normais. </font><font style="vertical-align: inherit;">Agora precisamos reverter esse processo para que possamos obter os normais originais no mapa.</font></font><br><br><pre> <code class="cpp hljs">[ r, g, b] = [ r * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, g * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, b * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ x, y, z]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui est√° como √© o processo de descompactar os normais do mapa normal. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... /* Transform */ normal = normalize ( mat3 ( tangent , binormal , vertexNormal ) * normal ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As normais obtidas no mapa normal geralmente est√£o no espa√ßo tangente. </font><font style="vertical-align: inherit;">No entanto, eles podem estar em outro espa√ßo. </font><font style="vertical-align: inherit;">Por exemplo, o Blender permite que voc√™ crie normais no espa√ßo tangente, no espa√ßo de objetos, no mundo e no espa√ßo da c√¢mera.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/009/cfc/62c/009cfc62c03b455a1e22b68e8636e735.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para transferir a normal do mapa normal do espa√ßo tangente para o espa√ßo de visualiza√ß√£o, crie uma matriz 3x3 com base no vetor tangente, vetores binormais e v√©rtice normal. </font><font style="vertical-align: inherit;">Multiplique o normal por esta matriz e normalize-o. </font><font style="vertical-align: inherit;">√â aqui que acabamos com os normais. </font><font style="vertical-align: inherit;">Todos os outros c√°lculos de ilumina√ß√£o ainda s√£o realizados.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fonte </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453300/">https://habr.com/ru/post/pt453300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453290/index.html">Data Science Digest (maio de 2019)</a></li>
<li><a href="../pt453292/index.html">"Um livrinho sobre buracos negros"</a></li>
<li><a href="../pt453294/index.html">Reagir Carregamento lento</a></li>
<li><a href="../pt453296/index.html">Gerenciando a assincronia no PHP: das promessas √†s corotinas</a></li>
<li><a href="../pt453298/index.html">Ver√£o: hora de atualizar ... voc√™ mesmo</a></li>
<li><a href="../pt453302/index.html">A primeira hora de vida com Yandex.Module</a></li>
<li><a href="../pt453304/index.html">Principais benef√≠cios do Zextras PowerStore</a></li>
<li><a href="../pt453306/index.html">Kubernetes vai dominar o mundo. Quando e como?</a></li>
<li><a href="../pt453310/index.html">Troque dados entre componentes do React usando a biblioteca RxJS</a></li>
<li><a href="../pt453312/index.html">Gerador de e-mail comercial em PDF com base em dados XML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>