<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔬 🏟️ 💕 Apa itu Misra dan bagaimana cara memasaknya 🌨️ 👩🏾‍🎓 🐽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mungkin setiap pengembang perangkat lunak mikrokontroler telah mendengar tentang standar pengkodean khusus untuk membantu meningkatkan keamanan dan po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa itu Misra dan bagaimana cara memasaknya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/482486/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/5bc/021/cf95bc0219fd9e34f03d5cfc316f7e71.png" alt="Gambar 2"></div><br>  Mungkin setiap pengembang perangkat lunak mikrokontroler telah mendengar tentang standar pengkodean khusus untuk membantu meningkatkan keamanan dan portabilitas kode.  Salah satu standar tersebut adalah MISRA.  Pada artikel ini, kita akan melihat lebih dekat apa standar ini, konsepnya dan bagaimana menggunakannya dalam proyek Anda. <br><a name="habracut"></a><br>  Banyak pembaca kami telah mendengar bahwa PVS-Studio mendukung klasifikasi peringatannya sesuai dengan standar MISRA.  Saat ini, PVS-Studio <a href="https://www.viva64.com/en/misra/">mencakup</a> lebih dari 100 aturan MISRA C: 2012 dan MISRA C ++: 2008. <br><br>  Artikel ini bertujuan untuk membunuh tiga burung dengan satu batu: <br><br><ol><li>  Katakan apa MISRA untuk mereka yang belum terbiasa dengan standar ini; </li><li>  Ingatkan dunia pengembangan tertanam apa yang bisa kita lakukan; </li><li>  Bantu karyawan baru di perusahaan kami, yang juga akan mengembangkan alat analisa MISRA kami di masa depan, untuk sepenuhnya mengenalnya. </li></ol><br>  Saya harap saya bisa membuatnya menarik.  Jadi ayo pergi! <br><br><h2>  Sejarah misra </h2><br>  Sejarah MISRA dimulai sejak lama.  Saat itu di awal 1990-an, program "TI Aman" pemerintah Inggris menyediakan dana untuk berbagai proyek yang entah bagaimana terkait dengan keamanan sistem elektronik.  Proyek MISRA (Asosiasi Keandalan Perangkat Lunak Industri Sepeda Motor) sendiri didirikan untuk membuat panduan untuk mengembangkan perangkat lunak mikrokontroler di kendaraan darat - di mobil, sebagian besar. <br><br>  Setelah menerima dana dari negara, tim MISRA mulai bekerja, dan pada November 1994 merilis panduan pertama mereka: " <a href="https://pdfs.semanticscholar.org/f7ab/6319c0ab1fb546e406a3f65463cd0e5d2f0c.pdf">Pedoman pengembangan perangkat lunak berbasis kendaraan</a> ".  Panduan ini belum dikaitkan dengan bahasa tertentu, tetapi saya harus mengakui bahwa pekerjaan telah dilakukan secara mengesankan dan telah memperhatikan, mungkin, semua aspek yang mungkin dari pengembangan perangkat lunak tertanam.  Ngomong-ngomong, baru-baru ini para pengembang panduan ini <a href="https://www.misra.org.uk/LinkClick.aspx%3Ffileticket%3DpHorDgiWiPs%253D%26amp%3Btabid%3D59">telah merayakan ulang tahun ke 25</a> dari tanggal yang begitu penting bagi mereka. <br><br>  Ketika dana dari negara berakhir, anggota MISRA memutuskan untuk terus bekerja bersama secara informal, seperti yang berlanjut hingga hari ini.  Secara umum, MISRA (sebagai organisasi) adalah komunitas pemangku kepentingan dari berbagai industri otomotif dan pesawat terbang.  Sekarang pihak-pihak ini adalah: <br><br><ul><li>  Mobil motor Bentley </li><li>  Ford Motor Company </li><li>  Jaguar land rover </li><li>  Sistem diesel delphi </li><li>  HORIBA MIRA </li><li>  Listrik protein </li><li>  Layanan teknik Visteon </li><li>  Universitas leeds </li><li>  Ricardo uk </li><li>  ZF TRW </li></ul><br>  Pelaku pasar yang sangat kuat, bukan?  Tidak mengherankan, standar terkait bahasa pertama mereka, MISRA C, telah menjadi biasa di kalangan pengembang sistem tertanam kritis.  Beberapa saat kemudian, MISRA C ++ muncul.  Secara bertahap, versi standar telah diperbarui dan disempurnakan untuk mencakup fitur bahasa baru.  Pada tulisan ini, versi saat ini adalah MISRA C: 2012 dan MISRA C ++: 2008. <br><br><h2>  Konsep utama dan contoh aturan </h2><br>  Fitur MISRA yang paling khas adalah perhatiannya yang luar biasa terhadap detail dan ketelitian ekstrem dalam memastikan keselamatan dan keamanan.  Tidak hanya penulis mengumpulkan semua kekurangan C dan C ++ di satu tempat (seperti misalnya, penulis CERT) - mereka juga dengan hati-hati menyusun standar internasional bahasa-bahasa ini dan menulis segala cara untuk membuat kesalahan.  Setelah itu, mereka menambahkan aturan tentang keterbacaan kode untuk memastikan kode bersih terhadap kesalahan baru. <br><br>  Untuk memahami skala keseriusan, mari kita lihat beberapa aturan yang diambil dari standar. <br><br>  Di satu sisi, ada aturan yang layak dan bermanfaat yang harus selalu diikuti, apa pun tujuan proyek Anda.  Sebagian besar, mereka dirancang untuk menghilangkan perilaku yang tidak ditentukan / tidak ditentukan / implementasi-didefinisikan.  Sebagai contoh: <br><br><ul><li> Jangan gunakan nilai variabel yang tidak diinisialisasi </li><li>  Jangan gunakan pointer ke FILE setelah aliran ditutup </li><li>  Semua fungsi non-batal harus mengembalikan nilai </li><li>  Counter loop tidak boleh dari tipe floating-point </li><li>  dan lainnya. </li></ul><br>  Di sisi lain, ada aturan, manfaat yang tidak sulit untuk diselami, tetapi yang (dari sudut pandang proyek biasa) dapat sesekali dilanggar: <br><br><ul><li>  Jangan gunakan goto dan longjmp </li><li>  Setiap peralihan harus diakhiri dengan label default </li><li>  Jangan menulis kode yang tidak terjangkau </li><li>  Jangan gunakan fungsi variadic </li><li>  Jangan gunakan aritmatika alamat (kecuali <i>[]</i> dan <i>++</i> ) </li><li>  ... </li></ul><br>  Aturan seperti itu juga tidak buruk, dan dikombinasikan dengan yang sebelumnya, mereka sudah memberikan peningkatan nyata pada keamanan, tetapi apakah ini cukup untuk sistem embedded yang sangat andal?  Mereka digunakan tidak hanya dalam industri otomotif, tetapi juga dalam industri penerbangan, kedirgantaraan, militer dan kedokteran. <br><br>  Kami tidak ingin mesin sinar-X untuk <a href="https://www.viva64.com/en/b/0438/">menyinari pasien dengan dosis 20.000 rad</a> karena kesalahan perangkat lunak, sehingga aturan "sehari-hari" yang biasa tidak cukup.  Dengan nyawa manusia dan uang dalam jumlah besar, ketelitian sangat diperlukan.  Di sinilah aturan MISRA lainnya ikut berperan: <br><br><ul><li>  Sufiks 'L' dalam literal harus selalu berupa kapital (huruf kecil 'l' dapat dikacaukan dengan 1) </li><li>  Jangan gunakan operator "koma" (ini meningkatkan kemungkinan melakukan kesalahan) </li><li>  Jangan gunakan rekursi (setumpuk mikrokontroler kecil dapat dengan mudah meluap) </li><li>  Badan pernyataan <i>jika</i> , <i>jika</i> <i>lain</i> , <i>untuk</i> , <i>sementara</i> , <i>lakukan</i> , <i>sakelar</i> harus dibungkus dengan kurung keriting (berpotensi Anda dapat membuat kesalahan ketika kode <a href="https://www.viva64.com/en/w/v2507/">disejajarkan secara salah</a> ) </li><li>  Jangan gunakan memori dinamis (karena ada kemungkinan tidak melepaskannya dari tumpukan, terutama di mikrokontroler) </li><li>  ... dan banyak, banyak dari aturan ini. </li></ul><br>  Sering terjadi, bahwa orang yang pertama kali bertemu MISRA mendapatkan kesan bahwa tujuan standar adalah untuk "melarang ini dan melarang itu."  Sebenarnya, memang demikian, tetapi hanya sampai batas tertentu. <br><br>  Di satu sisi, standar memang memiliki banyak aturan seperti itu, tetapi itu tidak dimaksudkan untuk melarang semuanya, tetapi di sisi lain, standar ini mencantumkan seluruh cara yang entah bagaimana melanggar keamanan kode.  Untuk sebagian besar aturan, Anda memilih sendiri apakah perlu mengikuti atau tidak.  Saya akan menjelaskan kasus ini secara lebih rinci. <br><br>  Dalam MISRA C, aturan dibagi menjadi tiga kategori utama: Mandatory, Required, and Advisory.  Wajib adalah aturan yang tidak bisa dilanggar dengan dalih apa pun.  Misalnya, bagian ini mencakup aturan: "jangan gunakan nilai variabel yang belum diinisiasi."  Aturan yang diperlukan kurang ketat: mereka memungkinkan untuk kemungkinan penolakan, tetapi hanya jika penyimpangan ini didokumentasikan dan dibuktikan secara tertulis.  Sisa aturan termasuk dalam kategori Penasihat, yang tidak wajib. <br><br>  MISRA C ++ memiliki beberapa perbedaan: tidak ada kategori Wajib, dan sebagian besar aturan termasuk dalam kategori Wajib.  Karena itu, pada kenyataannya, Anda memiliki hak untuk melanggar aturan apa pun - jangan lupa untuk berkomentar semua penyimpangan.  Ada juga kategori Dokumen - ini adalah aturan wajib (penyimpangan tidak diizinkan) terkait dengan praktik umum seperti "Setiap penggunaan assembler harus didokumentasikan" atau "Perpustakaan yang disertakan harus mematuhi MISRA C ++". <br><br><h2>  Masalah lainnya </h2><br>  Faktanya, MISRA bukan hanya tentang seperangkat aturan.  Bahkan, itu adalah pedoman untuk menulis kode aman untuk mikrokontroler, dan itu penuh dengan barang.  Mari kita lihat lebih dalam. <br><br>  Pertama-tama, standar berisi deskripsi latar belakang yang cukup menyeluruh: mengapa standar dibuat, mengapa C atau C ++ dipilih, pro dan kontra dari bahasa-bahasa ini. <br><br>  Kita semua tahu manfaat dari bahasa-bahasa ini dengan sangat baik.  Selain kami juga menyadari kekurangan mereka :) Tingkat kerumitan yang tinggi, spesifikasi standar yang tidak lengkap, dan sintaks yang memungkinkan untuk dengan mudah membuat kesalahan dan kemudian mencarinya untuk waktu yang lama - semua ini tidak bisa tidak disebutkan.  Misalnya, Anda mungkin secara tidak sengaja menulis ini: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i); { do_something(); }</code> </pre> <br>  Lagipula, ada kemungkinan seseorang tidak akan melihat <a href="https://www.viva64.com/en/w/v529/">titik koma tambahan</a> , kan?  Pilihan lain adalah menulis kode <a href="https://www.viva64.com/en/w/v559/">sebagai berikut</a> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpendTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> doWantToKillPeople)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doWantToKillPeople = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { StartNuclearWar(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { PlayComputerGames(); } }</code> </pre> <br>  Baik bahwa kasus <a href="https://www.viva64.com/en/w/v2507/">pertama</a> dan <a href="https://www.viva64.com/en/w/v2561/">kedua</a> dapat dengan mudah ditangkap oleh aturan MISRA (1 - MISRA C: 13.4 / MISRA C ++: 6.2.1; 2 - MISRA C: 13.4 / MISRA C ++: 6.2.1). <br><br>  Standar ini berisi deskripsi masalah masalah dan tip tentang apa yang harus diketahui sebelum mengambil tugas tertentu: bagaimana mengatur proses pengembangan sesuai dengan MISRA;  cara menggunakan analisis statis untuk memeriksa kepatuhan kode;  dokumen apa yang harus dipelihara, bagaimana mengisinya, dan sebagainya. <br><br>  Lampiran pada bagian akhir juga mencakup: daftar pendek dan ringkasan aturan, daftar kecil kerentanan C / C ++, contoh dokumentasi penyimpangan aturan, dan beberapa daftar periksa yang membantu memilah semua birokrasi ini. <br><br>  Seperti yang Anda lihat, MISRA bukan hanya seperangkat aturan, tetapi hampir seluruh infrastruktur untuk menulis kode aman untuk sistem tertanam. <br><br><h2>  Penggunaan dalam proyek Anda </h2><br>  Bayangkan pemandangannya: Anda akan menulis sebuah program untuk sistem embedded yang sangat dibutuhkan dan bertanggung jawab.  Atau Anda sudah memiliki program, tetapi Anda perlu "port" ke MISRA.  Jadi, bagaimana Anda memeriksa kode Anda untuk kepatuhannya terhadap standar?  Apakah Anda benar-benar harus melakukannya secara manual? <br><br>  Verifikasi kode manual adalah tugas yang tidak mudah dan bahkan berpotensi tidak mungkin.  Tidak hanya setiap reviewer harus hati-hati memeriksa setiap baris kode, tetapi juga kita harus tahu standarnya.  Gila! <br><br>  Oleh karena itu, pengembang MISRA sendiri menyarankan untuk menggunakan analisis statis untuk menguji kode Anda.  Setelah semua, pada kenyataannya, analisis statis adalah proses tinjauan kode otomatis.  Anda cukup menjalankan analisa pada program Anda dan dalam beberapa menit, Anda mendapatkan laporan tentang kemungkinan pelanggaran standar.  Itu yang Anda butuhkan, bukan?  Yang harus Anda lakukan adalah meninjau log dan memperbaiki peringatan. <br><br>  Pertanyaan selanjutnya adalah - pada titik mana kita harus mulai menggunakan MISRA?  Jawabannya sederhana: semakin cepat semakin baik.  Idealnya - sebelum Anda mulai menulis kode sama sekali, karena MISRA mengasumsikan bahwa Anda mengikuti standar untuk seluruh siklus hidup kode Anda. <br><br>  Yah tidak selalu mungkin untuk menulis sesuai dengan MISRA dari awal.  Misalnya, sering kali proyek telah dilaksanakan sebagian atau seluruhnya, tetapi kemudian pelanggan menginginkan proyek memenuhi standar.  Dalam hal ini, Anda harus berurusan dengan refactoring menyeluruh dari kode yang ada. <br><br>  Di situlah perangkap muncul.  Saya bahkan akan mengatakan batu bawah air muncul.  Apa yang terjadi jika Anda mengambil analisa statis dan memeriksa proyek "biasa" untuk memenuhi standar MISRA?  Spoiler: Anda mungkin takut. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44e/2b7/7d9/44e2b77d90cd9804e1ec0a5a38f166a2.png" alt="Gambar 5"></div><br><br>  Benar, contoh dalam gambar ini dilebih-lebihkan.  Ini menunjukkan hasil memeriksa proyek yang cukup besar yang sebenarnya tidak dimaksudkan untuk bekerja pada mikrokontroler.  Namun, saat memeriksa kode yang sudah ada, Anda mungkin mendapatkan satu, dua, tiga, atau bahkan sepuluh ribu peringatan penganalisa.  Peringatan baru, dikeluarkan untuk kode baru atau modifikasi, hanya akan hilang dalam banyak peringatan ini. <br><br>  Jadi, apa yang dapat Anda lakukan?  Apakah Anda benar-benar harus menunda semua tugas dan berusaha memperbaiki peringatan lama? <br><br>  Sebagai pengembang penganalisa statis, kita tahu bahwa begitu banyak peringatan muncul setelah pemeriksaan.  Oleh karena itu, kami mengembangkan solusi, yang dapat membantu digunakan langsung dari penganalisa tanpa menghentikan pekerjaan.  Solusi ini disebut "basis penekan". <br><br>  Basis penekan mewakili mekanisme PVS-Studio yang memungkinkan Anda untuk secara besar-besaran menekan pesan penganalisa.  Jika Anda memeriksa proyek untuk pertama kalinya dan mendapatkan beberapa ribu peringatan - Anda hanya perlu menambahkannya dalam basis penekan dan proses berikutnya akan memberi Anda nol peringatan. <br><br>  Dengan cara ini, Anda dapat terus menulis dan mengubah kode seperti biasa, dan dengan melakukan itu, Anda hanya akan menerima pesan tentang bug yang baru saja dibuat di proyek.  Jadi, Anda akan mendapatkan manfaat terbesar dari penganalisis di sini dan sekarang, tanpa terganggu oleh penyadap bug lama.  Beberapa klik - dan penganalisa diadopsi ke dalam pengembangan Anda!  Anda dapat membaca petunjuk terperinci tentang melakukan ini di <a href="https://www.viva64.com/en/m/0032/">sini</a> . <br><br>  Anda mungkin bertanya-tanya: "Tunggu, bagaimana dengan peringatan yang disembunyikan?" Jawabannya cukup sederhana: jangan lupakan dan perbaiki secara bertahap.  Misalnya, Anda dapat memuat basis penekan dalam sistem kontrol versi dan hanya memperbolehkan komit yang tidak menambah jumlah peringatan.  Dengan demikian, secara bertahap "batu bawah air" Anda cepat atau lambat akan menggiling tanpa meninggalkan bekas. <br><br>  Oke, analisa sekarang berhasil diadopsi dan kami siap untuk melanjutkan.  Apa yang harus dilakukan selanjutnya?  Jawabannya jelas - bekerja dengan kode!  Tapi apa yang diperlukan untuk bisa menyatakan kepatuhan dengan standar?  Bagaimana Anda membuktikan bahwa proyek Anda sesuai dengan MISRA? <br><br>  Faktanya, tidak ada "sertifikat" khusus yang sesuai dengan kode Anda dengan MISRA.  Seperti yang ditentukan standar, pelacakan kepatuhan harus dilakukan oleh dua pihak: pelanggan perangkat lunak dan vendor perangkat lunak.  Vendor mengembangkan perangkat lunak yang memenuhi standar dan mengisi dokumen yang diperlukan.  Pelanggan, pada gilirannya, harus memastikan bahwa data dari dokumen-dokumen ini benar. <br><br>  Jika Anda mengembangkan perangkat lunak untuk diri Anda sendiri, maka tanggung jawab untuk memenuhi standar hanya akan berada di pundak Anda :) <br><br>  Secara umum, untuk membuktikan kepatuhan proyek Anda, Anda akan memerlukan dokumen pendukung.  Daftar dokumen yang harus disiapkan oleh pengembang proyek mungkin beragam, tetapi MISRA menawarkan beberapa set sebagai referensi.  Mari kita lihat lebih dekat set ini. <br><br>  Anda membutuhkan hal-hal ini untuk mengajukan kepatuhan standar: <br><br><ul><li>  Proyek itu sendiri, yang kodenya mematuhi aturan Wajib dan Diperlukan </li><li>  Panduan rencana penegakan </li><li>  Dokumentasi tentang semua peringatan pengumpul dan penganalisa statis </li><li>  Dokumentasi untuk semua penyimpangan dari Aturan yang Diperlukan </li><li>  Ringkasan pedoman kepatuhan </li></ul><br>  Yang pertama adalah rencana penegakan panduan.  Ini adalah tabel Anda yang paling penting, dan berisi referensi ke semua dokumen lainnya.  Di kolom pertama adalah daftar aturan MISRA, sisanya, dicatat apakah ada penyimpangan dari aturan tersebut.  Tabel ini terlihat seperti ini: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/bba/a3f/7bcbbaa3f6e9115e55b721ec99c5f763.png" alt="Gambar 1"></div><br>  Standar merekomendasikan membangun proyek Anda dengan beberapa kompiler, serta menggunakan dua atau lebih analisa statis untuk menguji kode Anda untuk kepatuhan.  Jika kompiler atau penganalisa mengeluarkan peringatan terkait aturan, Anda harus mencatatnya dalam tabel dan mendokumentasikan poin-poin berikut: mengapa peringatan tidak dapat diperbaiki, apakah itu salah atau tidak, dll. <br><br>  Jika salah satu aturan tidak dapat diperiksa oleh penganalisa statis, Anda harus melakukan tinjauan kode manual.  Prosedur ini juga harus didokumentasikan, setelah itu tautan ke dokumentasi itu harus ditambahkan ke rencana kepatuhan. <br><br>  Jika kompilator atau penganalisa statis ternyata benar, atau jika ada pelanggaran aturan yang valid selama proses peninjauan kode, Anda harus memperbaikinya atau mendokumentasikannya.  Sekali lagi, dengan melampirkan tautan ke dokumentasi di tabel. <br><br>  Dengan demikian, rencana kepatuhan adalah dokumen yang akan menyediakan dokumentasi untuk setiap penyimpangan yang diidentifikasi dalam kode Anda. <br><br>  Mari kita secara singkat menyentuh secara langsung mendokumentasikan penyimpangan dari aturan.  Seperti yang saya sebutkan, dokumentasi semacam itu hanya diperlukan untuk Aturan yang Diperlukan, karena aturan Wajib tidak dapat dilanggar, dan aturan Penasihat dapat dilanggar tanpa dokumentasi apa pun. <br><br>  Jika Anda memilih untuk menyimpang dari aturan, dokumentasi harus mencakup: <br><br><ul><li>  Jumlah aturan yang dilanggar </li><li>  Lokasi pasti dari penyimpangan </li><li>  Validitas penyimpangan </li><li>  Bukti bahwa penyimpangan tidak membahayakan keamanan </li><li>  Konsekuensi potensial bagi pengguna </li></ul><br>  Seperti yang Anda lihat, pendekatan dokumentasi seperti itu membuat Anda benar-benar bertanya-tanya apakah pelanggaran itu sepadan.  Ini dilakukan secara khusus untuk merasakan tidak ada keinginan untuk melanggar aturan yang diperlukan :) <br><br>  Sekarang tentang ringkasan kepatuhan dengan aturan.  Makalah ini, mungkin, akan menjadi yang paling mudah untuk diisi: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b06/c76/3a8/b06c763a8c54330152d00006f25f0778.png" alt="Gambar 3"></div><br>  Kolom pusat diisi sebelum Anda mulai bekerja dengan kode, dan yang tepat - setelah proyek Anda siap. <br><br>  Inilah pertanyaan yang masuk akal: mengapa kategori aturan harus ditentukan, jika sudah ditentukan dalam standar itu sendiri?  Faktanya adalah bahwa standar memungkinkan "mempromosikan" aturan ke dalam kategori yang lebih ketat.  Misalnya, pelanggan mungkin meminta Anda untuk mengkategorikan aturan Penasihat.  "Promosi" seperti itu harus dibuat sebelum bekerja dengan kode, dan ringkasan kepatuhan dengan aturan memungkinkan Anda untuk secara eksplisit mencatatnya. <br><br>  Sedangkan untuk kolom terakhir, ini cukup sederhana: Anda hanya perlu mencatat apakah aturan itu digunakan, dan jika demikian, apakah ada penyimpangan dari itu. <br><br>  Seluruh tabel ini diperlukan agar Anda dapat dengan cepat melihat apa yang diprioritaskan oleh aturan dan apakah kode tersebut mematuhinya.  Jika Anda tiba-tiba tertarik untuk mengetahui penyebab pasti dari penyimpangan tersebut, Anda selalu dapat beralih ke rencana kepatuhan dan menemukan dokumentasi yang Anda butuhkan. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b4/c84/ca8/5b4c84ca873358cbb9b5dd6349330da4.png" alt="Gambar 6"></div><br>  Jadi, Anda menulis kode dengan cermat mengikuti aturan MISRA.  Anda telah membuat rencana kepatuhan dan mendokumentasikan segala sesuatu yang dapat didokumentasikan, dan Anda telah mengisi resume kepatuhan Anda.  Jika memang demikian halnya, maka Anda telah mendapatkan kode yang sangat bersih, sangat mudah dibaca, dan sangat andal yang sekarang Anda benci :) <br><br>  Di mana program Anda akan tinggal sekarang?  Di perangkat MRI?  Dalam sensor kecepatan biasa atau dalam sistem kontrol beberapa satelit luar angkasa?  Ya, Anda sudah melalui jalur birokrasi yang serius, tapi itu bukan masalah besar.  Ketika datang ke kehidupan manusia yang nyata, Anda harus selalu teliti. <br><br>  Jika Anda telah mengatasi dan berhasil mencapai kemenangan, maka saya dengan tulus mengucapkan selamat kepada Anda: Anda menulis kode aman berkualitas tinggi.  Terima kasih <br><br><h2>  Masa depan standar </h2><br>  Untuk penutup, saya ingin memikirkan masa depan standar. <br><br>  Sekarang Misra hidup dan berkembang.  Misalnya, "MISRA C: 2012 Edisi Ketiga (Revisi Pertama)" adalah revisi dan diperbesar dengan edisi peraturan baru yang diumumkan pada awal 2019. Pada saat yang sama, rilis mendatang "MISRA C: 2012 Amendemen 2 - C11 Core ”, yang merupakan standar revisi tahun 2012, diumumkan.  Dokumen ini akan mencakup aturan yang untuk pertama kalinya mencakup versi bahasa C 2011 dan 2018 tahun. <br><br>  MISRA C ++ terus berkembang juga.  Seperti yang Anda ketahui, standar terakhir MISRA C ++ bertanggal 2008, jadi versi tertua bahasa yang dicakupnya adalah C ++ 03.  Karena itu, ada standar lain yang mirip dengan MISRA, dan itu disebut AUTOSAR C ++.  Ini awalnya dimaksudkan sebagai kelanjutan dari MISRA C ++ dan dimaksudkan untuk mencakup versi bahasa selanjutnya.  Tidak seperti dalangnya, AUTOSAR C ++ diperbarui dua kali setahun dan saat ini mendukung C ++ 14.  Pembaruan C ++ 17 baru dan kemudian C ++ 20 belum datang. <br><br>  Mengapa saya mulai berbicara tentang standar lain?  Faktanya adalah bahwa kurang dari setahun yang lalu, kedua organisasi mengumumkan bahwa mereka akan menggabungkan standar mereka menjadi satu.  MISRA C ++ dan AUTOSAR C ++ akan menjadi standar tunggal, dan mulai sekarang mereka akan berevolusi bersama.  Saya pikir itu berita bagus untuk pengembang yang menulis untuk mikrokontroler di C ++, dan tidak kurang berita bagus untuk pengembang penganalisa statis.  Masih banyak yang harus dilakukan!  :) <br><br><h2>  Kesimpulan </h2><br>  Mudah-mudahan hari ini Anda belajar banyak tentang MISRA: membaca sejarah asalnya, mempelajari contoh aturan dan konsep standar, mempertimbangkan semua yang Anda perlukan untuk menggunakan MISRA dalam proyek Anda, dan bahkan melihat sekilas masa depan.  Saya harap sekarang Anda memiliki pemahaman yang lebih baik tentang apa MISRA itu dan bagaimana cara memasaknya! <br><br>  Dalam tradisi lama, saya akan meninggalkan di sini tautan ke penganalisa statis PVS-Studio kami.  Ia dapat menemukan tidak hanya penyimpangan dari standar MISRA, tetapi juga <a href="https://www.viva64.com/en/examples/">sejumlah besar</a> kesalahan dan kerentanan.  Jika Anda tertarik untuk mencoba PVS-Studio sendiri, <a href="https://www.viva64.com/en/pvs-studio-download/">unduh</a> versi demo dan periksa proyek Anda. <br><br>  Di situlah artikel saya berakhir.  Saya berharap semua pembaca selamat Natal dan selamat liburan Tahun Baru! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482486/">https://habr.com/ru/post/id482486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482474/index.html">"Bagaimana aku menghabiskan musim panas"</a></li>
<li><a href="../id482478/index.html">Iteraptor: perpustakaan untuk redus peta transparan dalam</a></li>
<li><a href="../id482480/index.html">Sentuhan kosmik dari tahun keluar</a></li>
<li><a href="../id482482/index.html">Bermain peran</a></li>
<li><a href="../id482484/index.html">Cara meningkatkan efisiensi pengembangan menggunakan teori kendala</a></li>
<li><a href="../id482490/index.html">Apa itu MISRA dan cara memasaknya</a></li>
<li><a href="../id482492/index.html">Emisi pencairan permafrost dan gas rumah kaca</a></li>
<li><a href="../id482494/index.html">Perbarui Hasil Survei</a></li>
<li><a href="../id482496/index.html">Hasil: 9 terobosan teknologi utama tahun 2019</a></li>
<li><a href="../id482498/index.html">Sejarah evolusi antarmuka di Jawa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>