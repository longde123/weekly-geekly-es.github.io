<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏿 👣 🍾 Contrabando de solicitudes HTTP: nuevos enfoques ⚛️ 🙇🏾 🧖🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El 7 de octubre de 2019, el Director de Investigación de PortSwigger (fabricante de BurpSuite) publicó un estudio sobre nuevos enfoques para el contra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contrabando de solicitudes HTTP: nuevos enfoques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468489/"><p>  El 7 de octubre de 2019, el Director de Investigación de PortSwigger (fabricante de BurpSuite) publicó un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://portswigger.net/blog/">estudio</a> sobre nuevos enfoques para el contrabando de solicitudes HTTP.  Con su ayuda, ganó alrededor de $ 70,000 en bugbounty.  En este artículo, descubrimos brevemente la esencia del ataque, las herramientas y también los métodos de investigación de servidores web que son vulnerables a esta vulnerabilidad. </p><a name="habracut"></a><br><h4 id="chto-takoe-http-request-smuggling">  ¿Qué es el contrabando de solicitudes HTTP? </h4><br><p>  Contrabando de solicitudes HTTP: un ataque destinado a desincronizar el frontend del servidor web y el back-end del servidor web, como resultado de lo cual el atacante podría pasar de contrabando una solicitud HTTP más allá del servidor frontend.  La imagen del artículo original sirve como una buena demostración: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/747/263/e2d/747263e2d0149330227e70267106fffc.svg" alt="imagen"></p><br><p>  Tal ataque puede llevar a una variedad de consecuencias: la introducción de XSS en la sesión de otros usuarios, redirigiendo a los usuarios a recursos de terceros, envenenando la caché del servidor, similitud con SSRF y muchos otros. </p><br><p>  En la Encarnación de contrabando de 2019 de 2019, James Kettle explotó el procesamiento incorrecto del encabezado del servidor web </p><br><pre><code class="plaintext hljs">Transfer-Encoding: chunked</code> </pre> <br><p>  indicando que el cuerpo del mensaje se transmitirá en partes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RFC</a> ).  Debido al hecho de que algunos servidores web no son compatibles con la transmisión fragmentada, o manejan el encabezado de manera diferente, el frontend "verá" solo una solicitud, y el backend la reconocerá como dos.  Puede encontrar más detalles sobre los detalles del ataque en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://portswigger.net/blog/">artículo original</a> , también hay una tarea práctica en la que puede practicar para encontrar la vulnerabilidad manualmente. </p><br><p>  Para una búsqueda rápida, James desarrolló un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/portswigger/">complemento</a> para BurpSuit, que recibe una solicitud de entrada y crea una nota sobre la vulnerabilidad del servicio (si existe) en la salida. </p><br><h4 id="primery-uyazvimyh-veb-serverov">  Ejemplos de servidores web vulnerables </h4><br><p>  Debo decir que el problema del contrabando y otras vulnerabilidades relacionadas con el funcionamiento de los servidores web ha sido tratado por otro investigador bajo el apodo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regilero</a> .  En los últimos tres años, ha publicado tres artículos que describen las vulnerabilidades que encontró en los servidores web populares, la mayoría de los cuales tienen asignados CVE de crítica media y alta.  Entre los servidores vulnerables se encuentran Apache Traffic Server, Jetty, Apsis. </p><br><p>  A raíz del interés en el problema, otro investigador, Nathan Davison, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://nathandavison.com/blog/haproxy-">descubrió una</a> vulnerabilidad en HAProxy, que ignoró un encabezado formado incorrectamente. </p><br><pre> <code class="plaintext hljs">Transfer-Encoding:[\x0b]chunked</code> </pre> <br><p>  y lo convirtió a la siguiente forma: </p><br><pre> <code class="plaintext hljs">Transfer-Encoding: chunked</code> </pre> <br><p>  Pero el servidor de fondo: gunicorn, que representa la aplicación en Flask, leyó el encabezado, lo que provocó la vulnerabilidad. </p><br><p>  Un poco más tarde, varios otros investigadores descubrieron una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vulnerabilidad</a> (asignada CVE-2019-16276) en la implementación del servidor http golang: el servidor normalizaba el encabezado si había un espacio antes del prelet. <br>  Solicitud: </p><br><p><img src="https://habrastorage.org/webt/6o/xo/9s/6oxo9supeccvs3tjbzs2gjuiyfa.png" alt="imagen"></p><br><p>  Después de procesar por el servidor: </p><br><p><img src="https://habrastorage.org/webt/-3/uv/5-/-3uv5-g2-druizng90mzidgvqyw.png" alt="imagen"></p><br><p>  La vulnerabilidad podría explotarse si el servidor frontend ignora el encabezado con un espacio y usa Content-Length para calcular el tamaño de la solicitud. </p><br><p>  El servidor web Caddy escrito en Go también era vulnerable porque usaba la misma biblioteca net / http.  Los desarrolladores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">confirmaron</a> que después de actualizar GO y reconstruir el paquete, el problema desaparece. </p><br><p>  El autor de este artículo encontró un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://redmine.lig">problema</a> similar en el servidor lighthttpd (no se asignó CVE).  La captura de pantalla muestra que el servidor acepta y procesa el encabezado que contiene un espacio: </p><br><p><img src="https://habrastorage.org/webt/v7/gy/67/v7gy67qzws5izqqsavhl78qusim.png" alt="imagen"></p><br><p>  Los desarrolladores no están del todo de acuerdo con RFC 7230 (y el autor también), y creen que la responsabilidad del procesamiento incorrecto de los encabezados recae en los proxies que envían las solicitudes sin normalizarlas y verificarlas.  Sin embargo, el error se solucionará en la nueva versión: </p><br><blockquote>  De forma predeterminada, lighttpd analiza (y normaliza) las solicitudes antes de enviarlas por proxy a los backends.  Hacerlo frustra los ataques mencionados en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://portswigger.net/research/">https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn</a> a los servidores aguas arriba de lighttpd. <br>  Sin embargo, como mencionó anteriormente stbuehler, los servidores proxy posteriores a lighttpd podrían pasar cualquier cosa a lighttpd. <br>  El cambio que se realizará en la próxima versión de lighttpd será rechazar las solicitudes con espacio o tabulación después del nombre del campo y antes de los dos puntos, pero solo cuando lighttpd esté configurado en el modo (predeterminado) del análisis estricto del encabezado http. </blockquote><p>  Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontró el</a> mismo error en el servidor web cheroot utilizado por el framework cherrypy.  Este mini-framework se encuentra en startups, a menudo se usa para escribir API.  El informe de error se cuelga en el estado abierto. </p><br><h4 id="neobhodimye-i-dostatochnye-usloviya-dlya-uyazvimosti">  Condiciones necesarias y suficientes para la vulnerabilidad. </h4><br><p>  Entonces, ¿cuáles son las condiciones necesarias para verificar y explotar la vulnerabilidad? </p><br><ul><li>  Solicitud POST.  Aunque el RFC no prohíbe explícitamente el uso de encabezados Content-Length y Transfer-Encoding para solicitudes GET, de hecho, solo se usan en solicitudes POST. </li><li>  La presencia de servidores frontend y backend: si no hay ninguno, no habrá nada que sincronizar. </li><li>  Los servidores web deben analizar el encabezado Transfer-Encoding de manera diferente, es decir, uno debe "leerlo" y el segundo debe ignorarse. </li></ul><br><h3 id="testirovanie-v-laboratornyh-usloviyah">  Pruebas de laboratorio </h3><br><p>  Para una mejor comprensión y resolución de problemas en servidores web y servidores proxy existentes, es aconsejable implementar un entorno de prueba localmente con Docker. </p><br><p>  Un ejemplo de un diagrama de entorno de prueba: </p><br><p><img src="https://habrastorage.org/webt/vw/ta/al/vwtaalo8yv5w_aecwkxjygplca8.png" alt="imagen"></p><br><p>  Código de aplicación: </p><br><pre> <code class="plaintext hljs">from flask import Flask, request, jsonify app = Flask(__name__) @app.route('/', methods=['GET', 'POST']) def main(): # the next line is required for Transfer-Encoding support in the request request.environ['wsgi.input_terminated'] = True headers = {} for header in request.headers: headers[header[0]] = header[1] print (request.data) print (headers) return jsonify(body=str(request.data), headers=headers)</code> </pre> <br><p>  Archivo con configuraciones frontend, por ejemplo, caddy: </p><br><pre> <code class="plaintext hljs">localhost:80 log ../access.log proxy / host.docker.internal:8888</code> </pre> <br><p>  Entonces todo es simple, ejecuta la aplicación: </p><br><pre> <code class="plaintext hljs">gunicorn --keep-alive 10 -k gevent --bind 0.0.0.0:8888 -w 4 backend:app</code> </pre> <br><p>  Y contenedor: </p><br><pre> <code class="plaintext hljs">docker run -d -t --name caddy -p 80:80 -p 443:443 -v /Users/sun/work/caddyfile:/etc/Caddyfile abiosoft/caddy:latest</code> </pre> <br><p>  Desde la tienda Burp, instalamos HTTP Request Smuggler y Logger ++ para facilitar la depuración.  A continuación en Repeater formamos una solicitud simple, por ejemplo esto: </p><br><pre> <code class="plaintext hljs">POST / HTTP/1.1 Host: localhost Content-Length: 8 Connection: close body=123</code> </pre> <br><p>  Y envíelo para verificar que todo esté configurado correctamente: </p><br><pre> <code class="plaintext hljs">HTTP/1.1 200 OK Content-Length: 202 Content-Type: application/json Date: Mon, 07 Oct 2019 13:17:18 GMT Server: Caddy Server: gunicorn/19.9.0 Connection: close {"body":"b'body=123'","headers":{"Accept-Encoding":"gzip","Connection":"close","Content-Length":"8","Host":"host.docker.internal:8888","User-Agent":"Go-http-client/1.1","X-Forwarded-For":"172.17.0.1"}}</code> </pre> <br><p>  Ahora inicie Launch Smuggle Probe y mire las respuestas. </p><br><p><img src="https://habrastorage.org/webt/27/y4/_p/27y4_p-eozetpwnyp3wd4_tuzj0.gif" alt="imagen"></p><br><p>  Lo más interesante comienza en este momento.  Es necesario analizar las solicitudes y respuestas para comprender si los servicios son vulnerables o no.  Esta parte se deja para el lector curioso. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468489/">https://habr.com/ru/post/468489/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468465/index.html">Opinión del abogado: cómo pueden las empresas de TI rescindir un contrato con un cliente gubernamental tóxico</a></li>
<li><a href="../468471/index.html">Descripción general de AngularConnect 2019. Parte 1</a></li>
<li><a href="../468479/index.html">“La gente piensa que lo gratuito no vale nada. Me pareció que podía convencerlos "- Yuri Yartsev sobre la escuela Russol</a></li>
<li><a href="../468485/index.html">Cuando quieres una GUI hermosa, pero gpu no es</a></li>
<li><a href="../468487/index.html">Qué puede suceder (vectores de ataque típicos)</a></li>
<li><a href="../468491/index.html">La maldición kármica de Habra</a></li>
<li><a href="../468493/index.html">La estructura de la vista aérea del proyecto Data Science</a></li>
<li><a href="../468497/index.html">Temporizador de cepillado temporizado de 3 minutos</a></li>
<li><a href="../468501/index.html">Cómo creé un filtro que no corrompe la imagen incluso después de un millón de ejecuciones</a></li>
<li><a href="../468503/index.html">El correo no va más allá de 500 millas - Preguntas frecuentes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>