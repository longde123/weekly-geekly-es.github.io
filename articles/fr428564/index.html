<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆒 👋 🏫 Recherche MapKit: Trucs et astuces 👷🏼 🔺 😪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="MapKit est une bibliothèque de logiciels qui vous permet d'utiliser les données cartographiques et les technologies Yandex dans des applications mobil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recherche MapKit: Trucs et astuces</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428564/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/dq/_i/jl/dq_ijlbhgproad1ydyfpsill35e.png" width="480"></div><br><p>  MapKit est une bibliothèque de logiciels qui vous permet d'utiliser les données cartographiques et les technologies Yandex dans des applications mobiles.  Elle a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une documentation officielle</a> qui contient déjà une description détaillée des méthodes de l'API, donc aujourd'hui nous allons parler d'autre chose. </p><br><p>  Dans cet article, je parlerai aux lecteurs Habr des caractéristiques de la recherche dans MapKit et partagerai des recommandations et des astuces qui pourraient vous être utiles. </p><br><p>  <strong>TL; DR</strong> Si vous ne souhaitez pas lire l'intégralité de l'article, voici deux des points les plus utiles pour compenser la lecture de l'avant-propos: </p><br><ul><li>  N'oubliez pas de sauvegarder les sessions, sinon la recherche ne fonctionnera pas. </li><li>  Toutes les informations les plus intéressantes sont stockées dans les métadonnées de l'objet.  Si vous souhaitez connaître l'adresse complète, les heures d'ouverture ou le prix d'une tasse de cappuccino dans un café particulier, vous avez besoin de métadonnées. </li></ul><br><p>  Les liens vers la documentation dans le texte seront pour Android, les classes et méthodes pour iOS sont appelées de la même manière. </p><a name="habracut"></a><br><h2 id="chto-umeet-poisk">  Que peut rechercher </h2><br><p>  Tout d'abord, parlons de ce que la recherche dans MapKit peut faire.  La recherche peut faire ce que vous attendez d'une application cartographique lorsque vous souhaitez y trouver quelque chose. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/1g/wv/m01gwvpktgpsipyacy4rj5pi3yw.jpeg" width="720"></div><br><p>  Lorsque vous tapez dans la barre de recherche «café», «rue Lev Tolstoï, 16» ou «tram 3», la <strong>recherche de texte</strong> fonctionne.  Il s'agit du type de recherche le plus sophistiqué.  Entassé en ce sens qu'il prend en charge l'ensemble maximal de paramètres pour la personnalisation.  Vous pouvez essayer immédiatement de rechercher le long d'un itinéraire ou d'une rue qui vous intéresse, clarifier le nombre de résultats souhaité, définir la position de l'utilisateur, etc.  Si après la première recherche vous souhaitez déplacer la carte ou appliquer des filtres à la demande («pharmacies avec piscine»), il s'agit de <strong>nouvelles demandes</strong> . </p><br><p>  <strong>La recherche inversée est</strong> familière à la plupart des utilisateurs sur la question «Qu'est-ce qui est ici?».  Il vous permet de cliquer sur la carte pour déterminer quelle rue ou maison est "sous le curseur" ou quelles organisations sont proches de ce point.  <strong>La recherche par URI est</strong> nécessaire lorsque vous souhaitez trouver un objet spécifique.  Il peut être utilisé, par exemple, pour créer des signets dans une application.  Nous avons trouvé notre café préféré, marqué d'un astérisque - la prochaine fois, il sera possible de trouver exactement cette organisation par URI, où que se trouve la fenêtre de la carte.  Ni la recherche inversée ni les recherches d'URI ne prennent en charge les demandes supplémentaires, car il n'y a rien à spécifier pour elles. </p><br><p>  Une autre possibilité qui réside dans la recherche est <strong>les indices de recherche</strong> , qui vous permettent de compléter automatiquement la requête pendant que vous la tapez.  Mais nous reporterons une histoire détaillée à leur sujet pour une autre fois. </p><br><h2 id="kak-ustroen-zapros">  Organisation de la demande </h2><br><p> La recherche, comme de nombreuses parties de MapKit, fonctionne de manière asynchrone.  L'objet principal pour travailler avec cette asynchronie est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">session de recherche</a> .  Regardons un petit exemple. </p><br><div class="spoiler">  <b class="spoiler_title">Un peu d'exemples</b> <div class="spoiler_text"><p> Les exemples de l'article seront sur Kotlin pour faciliter le travail avec des valeurs optionnelles et moins de code passe-partout.  MapKit a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application de démonstration</a> .  Il peut être utilisé pour tester des exemples, mais pour cela, <a href=""><code>SearchActivity</code></a> doit être converti de Java en Kotlin.  <code>showMessage</code> , qui apparaît de temps en temps dans le code, est un moyen pratique pour vous d'afficher une ligne de texte à l'écran ou dans le journal. </p></div></div><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// `searchManager`  `searchSession` –  .    //    ,     . searchManager = SearchFactory.getInstance().createSearchManager( SearchManagerType.ONLINE ) val point = Geometry.fromPoint(Point(59.95, 30.32)) searchSession = searchManager!!.submit("", point, SearchOptions(), object: Session.SearchListener { override fun onSearchError(p0: Error) { showMessage("Error") } override fun onSearchResponse(p0: Response) { showMessage("Success") } } )</span></span></code> </pre> <br><p>  Immédiatement après avoir appelé <code>submit</code> contrôle reviendra à votre code et lorsque MapKit recevra une réponse du serveur, SearchListener sera appelé. </p><br><p>  La session de recherche vous permet de: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Annuler la demande</a> .  Par exemple, si l'utilisateur ferme l'écran de recherche. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Répétez la demande</a> en cas d'erreur.  Par exemple, en cas de problème avec le réseau. </li><li>  Poursuivez l'interaction avec la recherche une fois la réponse reçue.  <strong>Les nouvelles demandes</strong> sont faites pendant la session. </li></ul><br><p>  Une session lors de l'annulation est automatiquement annulée.  Cela signifie que s'il n'est pas enregistré du côté du code client, la recherche ne fonctionnera pas. <br>  <strong>N'oubliez pas de sauvegarder la session, la session est votre amie!</strong> </p><br><h3 id="search-options">  Options de recherche </h3><br><p>  Une manière générale de configurer les requêtes de recherche consiste à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>SearchOptions</code></a> classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>SearchOptions</code></a> , qui vous permet de modifier les paramètres de requête. </p><br><ul><li>  Le principal de ces paramètres est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>SearchType</code></a> .  Il vous permet de spécifier si vous voulez voir des toponymes, des organisations ou des transports dans la réponse (vous n'aurez probablement pas besoin d'autres types). </li><li>  Un autre paramètre de requête important est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extrait de code</a> .  Nous en parlerons plus en détail dans la section sur le dispositif de réponse. </li><li>  Si vous souhaitez obtenir la géométrie du toponyme (par exemple, les rues ou les zones), vous devez le commander via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>setGeometry(true)</code></a> .  Gardez à l'esprit que la géométrie est assez "lourde" en termes de données transmises. </li><li>  Par défaut, la recherche ne renvoie pas les organisations fermées (temporairement ou définitivement), mais si vous en avez besoin, vous devez définir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>setSearchClosed(true)</code></a> . </li></ul><br><p>  En plus des paramètres répertoriés, il y en a d'autres qui peuvent vous être utiles, ils peuvent être trouvés dans la documentation de la classe.  Notez que toutes les requêtes ne prennent pas en charge toutes les combinaisons de paramètres.  La documentation de chaque méthode <code>SearchOptions</code> ou <code>Session</code> indique les paramètres de <code>SearchOptions</code> qu'il comprend. </p><br><h2 id="kak-ustroen-otvet">  Comment est arrangée la réponse </h2><br><p>  À en juger par les questions à l'appui, la plupart des utilisateurs sont confus par le format de la réponse de recherche.  Si vous regardez la classe de réponse, elle semble assez simple (au moins, la partie intéressante pour nous): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> SearchMetadata </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> GeoObjectCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCollection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Ici, <code>getCollection()</code> renvoie les objets dans la réponse, et <code>getMetadata()</code> est quelques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">données supplémentaires</a> qui contiennent, par exemple, des informations sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la fenêtre de réponse</a> , le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">type de classement</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombre de résultats trouvés</a> .  Si vous regardez à l'intérieur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>GeoObjectCollection</code></a> vous pouvez voir qu'il contient des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Item</code></a> qui peuvent être d'autres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>GeoObjectCollection</code></a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>GeoObject</code></a> . </p><br><p>  Il n'y a pas de collections à l'intérieur des collections dans la recherche (du moins pas encore), alors jetons un coup d'œil à <code>GeoObject</code> .  À l'intérieur de l'objet, il y a un nom ( <code>getName()</code> ), une description ( <code>getDescriptionText()</code> ), un cadre ( <code>getBoundingBox()</code> ), un ensemble de géométries ( <code>getGeometry()</code> ) et quelques autres méthodes pas très claires.  Où sont les numéros de téléphone de l'organisation?  Comment comprendre à quelle ville le toponyme fait référence? </p><br><p>  Selon les méthodes de l'objet, ce n'est pas très clair. </p><br><h3 id="geoobject">  Geoobject </h3><br><p>  Il est temps de parler davantage de <code>GeoObject</code> . </p><br><p>  <code>GeoObject</code> est un objet "carte" de base.  À l'intérieur, il peut y avoir un événement routier, un objet distinct du résultat de la recherche, une manœuvre sur l'itinéraire ou un objet sur la carte (POI), tel qu'un monument ou une organisation notable. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_l/ut/15/_lut15ur4w70yz88v1127swd6wg.png"></div><br><p>  Tout ce qui est le plus intéressant sur l'objet est stocké dans des métadonnées.  Ils sont accessibles à l'aide de la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>getMetadataContainer()</code></a> .  La clé de ce conteneur est le type de métadonnées.  Si vous voyez quelque chose dans la documentation qui se termine par le mot <code>Metadata</code> , vous êtes probablement ici.  A la recherche de différents morceaux de "métadonnées" 15. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gd/we/00/gdwe00tnfbshuzugslvjssupja4.png"></div><br><p>  Les métadonnées peuvent être divisées en plusieurs types.  Le premier type est des métadonnées qui déterminent le type auquel appartient l'objet: toponymes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>ToponymObjectMetadata</code></a> ), organisations ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>BusinessObjectMetadata</code></a> ) ou transport ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>TransitObjectMetadata</code></a> ).  Dans les métadonnées du toponyme, vous pouvez trouver une adresse structurée et une géométrie détaillée.  Les métadonnées de l'organisation sont les heures d'ouverture ou le site de l'entreprise.  Ces métadonnées sont déterminées par le type de recherche dans la demande - si vous avez recherché uniquement des toponymes, chaque objet de la réponse doit avoir des métadonnées correspondantes.  Si vous cherchiez des noms de lieux ou des organisations, alors chaque objet aura au moins une des deux "métadonnées". </p><br><p>  Voici comment trouver les numéros de téléphone de l'entreprise: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> phones = response.collection.children.firstOrNull()?.obj ?.metadataContainer ?.getItem(<span class="hljs-type"><span class="hljs-type">BusinessObjectMetadata</span></span>::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">?</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">phones</span></span></span></span></code> </pre> <br><p>  Et voici comment trouver la ville dans une adresse structurée: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> city = response.collection.children.firstOrNull()?.obj ?.metadataContainer ?.getItem(<span class="hljs-type"><span class="hljs-type">ToponymObjectMetadata</span></span>::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">?</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">address</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">?</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">components</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">?</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">firstOrNull</span></span></span><span class="hljs-class"> </span></span>{ it.kinds.contains(<span class="hljs-type"><span class="hljs-type">Address</span></span>.<span class="hljs-type"><span class="hljs-type">Component</span></span>.<span class="hljs-type"><span class="hljs-type">Kind</span></span>.<span class="hljs-type"><span class="hljs-type">LOCALITY</span></span>) } ?.name</code> </pre> <br><p>  Le deuxième type est celui des métadonnées fournies avec l'objet, bien que vous n'en ayez pas posé la question.  Le type principal que vous devez connaître est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>URIObjectMetadata</code></a> .  À l'intérieur de <code>URIObjectMetadata</code> l'identifiant unique de l'objet est stocké, qui doit être transmis dans la <strong>recherche par URI</strong> . </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//       «»,     //     val uri = response.collection.children.firstOrNull()?.obj ?.metadataContainer ?.getItem(UriObjectMetadata::class.java) ?.uris ?.firstOrNull() ?.value</span></span></code> </pre> <br><p>  Et le troisième type est les métadonnées, qui n'entreront dans la réponse que si vous demandez spécifiquement une recherche à ce sujet.  D'une manière différente, ces métadonnées sont appelées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extraits</a> .  Les extraits de code sont de petits éléments de données supplémentaires qui changent plus souvent que les données de référence de base, ou dont tout le monde n'a pas besoin.  Cela peut être une note, un lien vers des photos ou des panoramas, le taux de change ou le prix du carburant dans une station-service.  La liste des extraits doit être définie à l'aide des options de recherche.  Si le serveur a un extrait commandé, il l'ajoutera à l'objet correspondant. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> point = <span class="hljs-type"><span class="hljs-type">Geometry</span></span>.fromPoint(<span class="hljs-type"><span class="hljs-type">Point</span></span>(<span class="hljs-number"><span class="hljs-number">59.95</span></span>, <span class="hljs-number"><span class="hljs-number">30.32</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> options = <span class="hljs-type"><span class="hljs-type">SearchOptions</span></span>() options.snippets = <span class="hljs-type"><span class="hljs-type">Snippet</span></span>.<span class="hljs-type"><span class="hljs-type">FUEL</span></span>.value searchSession = searchManager!!.submit(<span class="hljs-string"><span class="hljs-string">""</span></span>, point, options, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> fun onSearchResponse(response: <span class="hljs-type"><span class="hljs-type">Response</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//         showMessage(response.collection.children.firstOrNull()?.obj ?.metadataContainer ?.getItem(FuelMetadata::class.java) ?.fuels ?.joinToString("\n") { "Fuel(name=${it.name}, price=${it.price?.text})" } ?: "No fuel" ) }</span></span></code> </pre> <br><p>  Toutes les métadonnées répertoriées ci-dessus sont ajoutées aux objets individuels dans la réponse.  Il existe également des métadonnées qui sont ajoutées à l'ensemble de la réponse.  Mais ils sont mis en évidence dans les méthodes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>SearchMetadata</code></a> et ils n'ont pas besoin d'être extraits d'une collection spéciale. </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//            response.metadata.businessResultMetadata?.categories //     (  )     response.metadata.toponymResultMetadata?.responseInfo?.mode</span></span></code> </pre> <br><h2 id="primery-ispolzovaniya">  Exemples d'utilisation </h2><br><p>  Passons maintenant en revue les principales méthodes des classes de recherche, examinons des exemples d'utilisation et certains points non évidents qui leur sont associés. </p><br><h3 id="poisk-po-tekstu">  Recherche de texte </h3><br><p>  La méthode principale pour la recherche de texte (et pour la recherche entière, probablement) est de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>submit</code></a> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Session </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( String text, Geometry geometry, SearchOptions searchOptions, SearchListener searchListener )</span></span></span></span>;</code> </pre> <br><ul><li>  Le paramètre <code>text</code> devrait contenir le texte que vous souhaitez rechercher. </li><li>  Le paramètre de <code>geometry</code> est un peu plus délicat.  Selon le type de géométrie transféré, la recherche se comportera différemment: <br><ul><li>  Si vous passez un point, la recherche sera effectuée dans une petite fenêtre à côté de ce point. </li><li>  Si vous passez une fenêtre rectangulaire ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>BoundingBox</code></a> ) ou un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polygone</a> de quatre points, il sera utilisé comme champ de recherche.  Un exemple simple d'une telle fenêtre est la zone visible de la carte. </li><li>  Enfin, si vous passez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyligne</a> , alors la fenêtre la décrivant sera utilisée comme fenêtre de recherche, et le classement sera effectué en tenant compte de cette polyligne. </li></ul></li><li>  Nous avons déjà parlé de <code>SearchOptions</code> et <code>SearchListener</code> ci-dessus. </li></ul><br><p>  Le serveur peut considérer que la bonne réponse ne se trouve pas dans la fenêtre dans laquelle la recherche initiale a été effectuée («café à Vladivostok» lorsque la fenêtre de recherche est à Moscou).  Dans ce cas, vous devrez prendre la fenêtre de réponse et y déplacer la carte pour que les résultats soient visibles à l'écran (les nouvelles demandes ne se permettent pas de le faire et ne demandent pas de déplacer la carte). </p><br><p>  La méthode d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>submit</code></a> a un jumelage d'envoi: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Session </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( String text, Polyline polyline, Geometry geometry, SearchOptions searchOptions, SearchListener searchListener )</span></span></span></span>;</code> </pre> <br><p>  avec un paramètre supplémentaire.  Ce paramètre peut être utilisé pour transférer une grande polyligne (par exemple, un itinéraire vers une autre ville) et une petite fenêtre de recherche.  Ensuite, la recherche elle-même supprimera la partie nécessaire de la polyligne transférée et l'utilisera uniquement pour la requête. </p><br><h3 id="perezaprosy">  Re-demandes </h3><br><p>  Contrairement aux autres types de demandes, les nouvelles demandes sont effectuées à l'aide d'une session de recherche, qui renvoie le même <code>submit</code> et son frère jumeau.  Certaines des méthodes de session sont simples et directes: </p><br><ul><li>  vous pouvez modifier la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fenêtre de demande</a> (lorsque l'utilisateur, par exemple, a déplacé la carte) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les options de recherche</a> peuvent être mises à jour (par exemple, pour mettre à jour la position de l'utilisateur) </li><li>  Vous pouvez changer le type de classement - par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">distance</a> ou par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">note</a> . </li></ul><br><p>  Pour effectuer une recherche affinée, vous devez utiliser la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>resubmit</code></a> .  Il accepte le même <code>SearchListener</code> qu'une recherche régulière.  Avant de l'appeler, vous pouvez modifier plusieurs paramètres de session.  Par exemple, modifiez simultanément le type de classement et appliquez des filtres. </p><br><h4 id="filtry">  Filtres </h4><br><p>  Puisque nous parlons de filtres.  Les filtres sont lorsque le Wi-Fi et la cuisine italienne.  Ils ont probablement la syntaxe la plus déroutante de toutes les interfaces de recherche dans MapKit.  Cela est dû au fait que les mêmes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structures de données sont</a> utilisées pour obtenir des filtres à partir de la réponse de recherche et pour spécifier des filtres dans la nouvelle demande. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7m/51/ky/7m51ky9gytyd1rlubljviboun5k.jpeg" width="360"></div><br><p>  Les filtres sont de deux types.  Les filtres booléens supposent seulement deux valeurs mutuellement exclusives - oui ou non.  Cela peut être la présence d'une connexion Wi-Fi dans un café, des toilettes dans une station-service ou un parking à proximité de l'organisation.  Les filtres d'énumération supposent de nombreuses valeurs qui peuvent être demandées ensemble.  C'est, par exemple, le type de cuisine pour un café ou les types de carburant dans une station-service. </p><br><p>  Voyons d'abord comment obtenir les filtres disponibles pour le redémarrage en cours: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> fun filters(response: <span class="hljs-type"><span class="hljs-type">Response</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span>? { fun enumValues(filter: <span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>) = filter .values .enums ?.joinToString(prefix = <span class="hljs-string"><span class="hljs-string">" -&gt; "</span></span>) { e -&gt; e.value.id } ?: <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response .metadata .businessResultMetadata ?.businessFilters ?.joinToString(separator = <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) { f -&gt; <span class="hljs-string"><span class="hljs-string">"${f.id}${enumValues(f)}"</span></span> } }</code> </pre> <br><p>  Dans la ligne résultante, pour les filtres booléens, seul l'identifiant sera affiché, et pour les filtres enum, l'identifiant du filtre lui-même et les identifiants des valeurs disponibles.  Maintenant, armés de la connaissance des identifiants disponibles, nous chercherons les cafés de la cuisine italienne qui ont le Wi-Fi.  Ajoutez d'abord un filtre booléen: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boolFilter = <span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* id= */</span></span> <span class="hljs-string"><span class="hljs-string">"wi_fi"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* name= */</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* disabled= */</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* values= */</span></span> <span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>.<span class="hljs-type"><span class="hljs-type">Values</span></span>.fromBooleans( listOf(<span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>.<span class="hljs-type"><span class="hljs-type">BooleanValue</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ) )</code> </pre> <br><p>  Maintenant, le filtre enum: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enumFilter = <span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* id= */</span></span> <span class="hljs-string"><span class="hljs-string">"type_cuisine"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* name= */</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* disabled= */</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* values= */</span></span> <span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>.<span class="hljs-type"><span class="hljs-type">Values</span></span>.fromEnums( listOf(<span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>.<span class="hljs-type"><span class="hljs-type">EnumValue</span></span>( <span class="hljs-type"><span class="hljs-type">Feature</span></span>.<span class="hljs-type"><span class="hljs-type">FeatureEnumValue</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* id= */</span></span> <span class="hljs-string"><span class="hljs-string">"italian_cuisine"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* name= */</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* imageUrlTemplate= */</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> ), <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> )) ) )</code> </pre> <br><p>  Enfin, vous pouvez ajouter des filtres à la session et appeler <code>resubmit()</code> : </p><br><pre> <code class="scala hljs">searchSession!!.setFilters(listOf(boolFilter, enumFilter)) searchSession!!.resubmit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre> <br><p>  Veuillez noter que vous ne pouvez pas définir de filtres pour la première requête.  Vous devez d'abord obtenir une réponse de recherche qui répertorie les filtres disponibles.  Et seulement alors pour former un redémarrage. </p><br><h5 id="dopolnitelnye-rezultaty">  Résultats supplémentaires </h5><br><p>  Une autre session vous permet de vérifier s'il existe des résultats de recherche supplémentaires pour votre demande.  Et, si c'est le cas, prenez-les.  Par exemple, lorsque vous recherchez un café dans votre ville, il est fort probable que tous ne tiennent pas sur une seule page de la réponse de recherche.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>fetchNextPage</code></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>hasNextPage</code></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>fetchNextPage</code></a> nécessaires pour afficher les pages suivantes de la liste.  Ici, vous devez savoir que, tout d'abord, l'appel à <code>fetchNextPage</code> une exception si la méthode <code>hasNextPage</code> renvoie <code>false</code> .  Et deuxièmement, l'utilisation de ces méthodes implique que les paramètres restants ne changent pas.  Autrement dit, la session est utilisée soit pour affiner la demande ( <code>resubmit()</code> ), soit pour récupérer les pages suivantes ( <code>fetchNextPage()</code> ).  La combinaison de ces modes n'est pas nécessaire. </p><br><h4 id="obratnyy-poisk">  Recherche inversée </h4><br><p>  La recherche inversée pour plus de commodité est également appelée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>submit</code></a> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Session </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Point point, Integer zoom, SearchOptions searchOptions, SearchListener searchListener )</span></span></span></span></code> </pre> <br><p>  Il diffère des autres types de requêtes en ce qu'il ne <em>nécessite</em> qu'un seul type de recherche pour entrer.  Vous passez soit le type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>GEO</code></a> et recherchez des noms de lieux, soit le type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>BIZ</code></a> et recherchez des organisations.  Il n'y en a pas de troisième. </p><br><p>  Lorsque vous effectuez une recherche avec un type <code>GEO</code> , certains points doivent être clarifiés.  Veuillez noter que la réponse contiendra plusieurs objets dans la hiérarchie (c'est-à-dire qu'elle comprendra une maison, une rue, une ville, etc.).  Dans les cas simples, vous pouvez prendre uniquement le premier objet.  Dans les plus complexes, recherchez dans la hiérarchie souhaitée. </p><br><p>  Le niveau de zoom est nécessaire pour produire des résultats adéquats en fonction de ce que l'utilisateur voit sur la carte.  Imaginez un utilisateur regardant une carte à l'échelle nationale.  Ensuite, il sera étrange pour lui de cliquer sur une rue ou une maison séparée si l'utilisateur a accidentellement réussi à y pénétrer.  Assez de villes.  C'est à cela que sert le paramètre de <code>zoom</code> . </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(<span class="hljs-number"><span class="hljs-number">55.734</span></span>, <span class="hljs-number"><span class="hljs-number">37.588</span></span>) <span class="hljs-comment"><span class="hljs-comment">//         «  , 16» searchSession = searchManager!!.submit(point, 16, SearchOptions(), this) //    –  " " searchSession = searchManager!!.submit(point, 14, SearchOptions(), this)</span></span></code> </pre> <br><h4 id="poisk-po-uri">  Recherche par URI </h4><br><p>  Tout est assez clair ici - nous prenons l'URI des <code>URIObjectMetadata</code> , souvenez-vous-en, après un certain temps nous <code>URIObjectMetadata</code> dans la recherche et par cet URI nous obtenons exactement l'objet dont nous nous sommes souvenus. </p><br><pre> <code class="scala hljs">searchSession = searchManager!!.resolveURI(uri, <span class="hljs-type"><span class="hljs-type">SearchOptions</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre> <br><p>  D'une certaine façon, même ennuyeux. </p><br><h2 id="poiskovyy-sloy-i-svetloe-buduschee">  Couche de recherche et avenir brillant </h2><br><p>  À côté de <code>SearchManager</code> il existe toujours une chose appelée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">couche de recherche</a> .  La couche a été conçue pour combiner la recherche avec la carte.  Il sait lui-même comment y ajouter des résultats, déplacer la carte pour que ces résultats s'affichent et faire des requêtes lorsque l'utilisateur déplace la carte.  À bien des égards, il est similaire au <code>SearchManager</code> et à la <code>Session</code> combinés, mais le travail intégré avec la carte ajoute de nouvelles fonctionnalités.  Et en parler dépasse le cadre de cet article.  Au moment de la sortie de MapKit 3.1, nous avions déjà parcouru la couche de recherche dans les applications réelles, vous pouvez donc essayer de l'utiliser dans votre maison.  Cela facilitera peut-être votre recherche. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/tg/g4/cttgg4rh3iffabd5xfm8fc6s_ha.jpeg" width="480"></div><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  J'espère qu'après avoir lu l'article, vous comprendrez comment travailler avec la recherche dans MapKit en force.  Certes, il y avait encore des moments subtils et non triviaux (par exemple, nous n'avons presque pas parlé des conseils et de la couche de recherche).  Quelque chose peut être trouvé dans la documentation, quelque chose à clarifier dans les projets sur GitHub ou demandez notre support. </p><br><p>  Essayez MapKit, utilisez la recherche et accédez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">à Maps</a> pour les rendre encore meilleurs! </p><br><p>  <strong>PS</strong> Et venez également nous rendre visite le 29 novembre pour écouter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment le backend de routage automobile est organisé</a> .  Qui, soit dit en passant, peut également être utilisé dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MapKit</a> , mais c'est une histoire complètement différente. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428564/">https://habr.com/ru/post/fr428564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428552/index.html">Algorithme: comment trouver la prochaine permutation lexicographique</a></li>
<li><a href="../fr428556/index.html">«L'environnement de production est hors de votre contrôle»: Rian Lewis sur les tests de projets de blockchain</a></li>
<li><a href="../fr428558/index.html">Comment j'ai créé un assistant pour WordPress à partir de ma profonde paresse</a></li>
<li><a href="../fr428560/index.html">Annonce imprévue de vendredi</a></li>
<li><a href="../fr428562/index.html">Droidcon Londres. Comment c'était</a></li>
<li><a href="../fr428566/index.html">Fonctions flèches JavaScript: pourquoi elles sont nécessaires, comment les gérer, quand les utiliser et quand elles ne le sont pas</a></li>
<li><a href="../fr428568/index.html">Guide de développement d'applications Web natives React</a></li>
<li><a href="../fr428570/index.html">Fonctions d'ordre supérieur en JavaScript</a></li>
<li><a href="../fr428572/index.html">Composants d'ordre supérieur dans React</a></li>
<li><a href="../fr428574/index.html">Faites passer la communication d'entreprise au niveau supérieur avec Zextras Chat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>