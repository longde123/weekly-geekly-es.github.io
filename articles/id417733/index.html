<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍡 👃🏻 👨🏾‍🤝‍👨🏼 Tutorial Java 9 untuk mereka yang harus bekerja dengan kode lawas 🍥 🎪 👊🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat sore, kolega. Tepat sebulan yang lalu, kami menerima kontrak untuk terjemahan Jawa Modern dari Manning, yang seharusnya menjadi salah satu pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tutorial Java 9 untuk mereka yang harus bekerja dengan kode lawas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/417733/"> Selamat sore, kolega.  Tepat sebulan yang lalu, kami menerima kontrak untuk terjemahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jawa Modern</a> dari Manning, yang seharusnya menjadi salah satu produk baru kami yang paling menonjol tahun depan.  Masalah "Modern" dan "Legacy" di Jawa begitu akut sehingga kebutuhan akan buku semacam itu sudah cukup matang.  Skala bencana dan cara mengatasi masalah di Jawa 9 dijelaskan secara singkat dalam sebuah artikel oleh Wayne Citrin, terjemahan yang ingin kami tawarkan kepada Anda hari ini. <br><a name="habracut"></a><br>  Setiap beberapa tahun, dengan merilis versi baru Java, penutur di JavaOne mulai menikmati konstruksi bahasa dan API baru, dan memuji kebajikan mereka.  Dan pengembang yang bersemangat, sementara itu, bersemangat untuk memperkenalkan fitur-fitur baru.  Gambaran seperti itu jauh dari kenyataan - sama sekali tidak memperhitungkan bahwa sebagian besar programmer sibuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendukung dan menyelesaikan aplikasi yang sudah ada</a> , dan tidak menulis aplikasi baru dari awal. <br><br>  Sebagian besar aplikasi - terutama yang komersial - harus kompatibel dengan versi Java sebelumnya yang tidak mendukung semua fitur super-duper baru ini.  Akhirnya, sebagian besar pelanggan dan pengguna akhir, terutama di segmen perusahaan besar, waspada terhadap peningkatan radikal ke platform Java, lebih memilih untuk menunggu sampai semakin kuat. <br><br>  Karena itu, begitu pengembang akan mencoba peluang baru, ia dihadapkan dengan masalah.  Apakah Anda menggunakan metode antarmuka default dalam kode Anda?  Mungkin - jika Anda beruntung dan aplikasi Anda tidak perlu berinteraksi dengan Java 7 atau lebih rendah.  Ingin menggunakan kelas <code>java.util.concurrent.ThreadLocalRandom</code> untuk menghasilkan angka pseudo-acak dalam aplikasi multi-utas?  Ini tidak akan berfungsi jika aplikasi Anda harus dijalankan pada Java 6, 7, 8 atau 9 secara bersamaan. <br><br>  Dengan rilis rilis baru, pengembang yang mendukung kode warisan merasa seperti anak-anak dipaksa untuk menatap jendela toko kue.  Mereka tidak diizinkan masuk, jadi nasib mereka adalah kekecewaan dan frustrasi. <br><br>  Jadi, apakah ada sesuatu dalam rilis baru Java 9 untuk programmer yang terlibat dalam dukungan kode lama?  Sesuatu yang bisa membuat hidup mereka lebih mudah?  Untungnya ya. <br><br>  <b>Apa yang harus dilakukan dengan dukungan kode legacy adalah penampilan Java 9</b> <br><br>  Tentu saja, Anda dapat mendorong kemampuan platform baru ke dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi lawas</a> di mana Anda harus mematuhi kompatibilitas ke belakang.  Secara khusus, selalu ada peluang untuk memanfaatkan API baru.  Namun, itu mungkin menjadi sedikit jelek. <br><br>  Misalnya, Anda dapat menerapkan pengikatan yang terlambat jika Anda ingin mengakses API baru ketika aplikasi Anda juga perlu bekerja dengan versi Java yang lebih lama yang tidak mendukung API ini.  Misalkan Anda ingin menggunakan kelas <code>java.util.stream.LongStream</code> , diperkenalkan di Java 8, dan Anda ingin menggunakan metode <code>anyMatch(LongPredicate)</code> dari kelas ini, tetapi aplikasi tersebut harus kompatibel dengan Java 7. Anda dapat membuat kelas pembantu, seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> classLongStreamHelper { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Class longStreamClass; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Class longPredicateClass; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Method anyMatchMethod; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { longStreamClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"java.util.stream.LongStream"</span></span>); longPredicateClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"java.util.function.LongPredicate"</span></span>); anyMatchMethod = longStreamClass.getMethod(<span class="hljs-string"><span class="hljs-string">"anyMatch"</span></span>, longPredicateClass): } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassNotFoundException e) { longStreamClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; longPredicateClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; anyMatchMethod = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NoSuchMethodException e) { longStreamClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; longPredicateClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; anyMatchMethod = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object theLongStream, Object thePredicate)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NotImplementedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (longStreamClass == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Boolean result = (Boolean) anyMatchMethod.invoke(theLongStream, thePredicate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.booleanValue(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { <span class="hljs-comment"><span class="hljs-comment">// lots of potential exceptions to handle. Let's simplify. throw new NotImplementedException(); } } }</span></span></code> </pre> <br>  Ada cara untuk menyederhanakan operasi ini, atau membuatnya lebih umum, atau lebih efektif - Anda dapat ide. <br><br>  Alih-alih memanggil <code>theLongStream.anyMatch(thePredicate)</code> , seperti yang Anda lakukan di Java 8, Anda bisa memanggil <code>LongStreamHelper.anyMatch(theLongStream, thePredicate)</code> di semua versi Java.  Jika Anda berurusan dengan Java 8, ini akan berhasil, tetapi jika dengan Java 7, program akan melempar <code>NotImplementedException</code> . <br><br>  Kenapa ini jelek?  Karena kode dapat menjadi terlalu rumit jika Anda perlu mengakses banyak API (pada kenyataannya, bahkan sekarang, dengan satu API, ini sudah merepotkan).  Selain itu, praktik ini bukan tipe-aman, karena kode tidak dapat secara langsung menyebutkan <code>LongStream</code> atau <code>LongPredicate</code> .  Akhirnya, praktik ini jauh kurang efisien, karena overhead refleksi, serta tambahan blok <code>try-catch</code> .  Karena itu, walaupun bisa dilakukan dengan cara ini, itu tidak terlalu menarik, dan penuh dengan kesalahan karena kecerobohan. <br><br>  Ya, Anda dapat mengakses API baru, dan kode Anda pada saat yang sama menjaga kompatibilitas, tetapi Anda tidak akan berhasil dengan konstruksi bahasa baru.  Sebagai contoh, misalkan kita perlu menggunakan ekspresi lambda dalam kode yang harus tetap kompatibel dan bekerja di Jawa 7. Anda kurang beruntung.  Kompiler Java tidak akan memungkinkan Anda menentukan versi kode sumber di atas target.  Jadi, jika Anda mengatur tingkat kepatuhan kode sumber ke 1,8 (mis., Java 8), dan tingkat kepatuhan target adalah 1,7 (Java 7), maka kompiler tidak akan mengizinkan Anda. <br><br>  <b>File JAR multi-versi akan membantu Anda</b> <br><br>  Baru-baru ini, peluang besar lain muncul untuk menggunakan fitur Java terbaru, sementara memungkinkan aplikasi untuk bekerja dengan versi Java yang lebih lama, di mana aplikasi tersebut tidak didukung.  Di Java 9, fitur ini disediakan untuk API baru dan konstruksi bahasa Java baru: kita berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file JAR multi-versi</a> . <br><br>  File JAR multi-versi hampir tidak berbeda dari file JAR lama yang baik, tetapi dengan satu peringatan penting: "ceruk" baru telah muncul di file JAR baru, di mana Anda dapat menulis kelas yang menggunakan fitur Java 9 terbaru. Jika Anda bekerja dengan Java 9, maka JVM akan menemukan "ceruk" ini, akan menggunakan kelas-kelas dari itu dan mengabaikan kelas-kelas dengan nama yang sama dari bagian utama dari file JAR. <br><br>  Namun, ketika bekerja dengan Java 8 atau lebih rendah, JVM tidak menyadari keberadaan "ceruk" ini.  Dia mengabaikannya dan menggunakan kelas dari bagian utama file JAR.  Dengan dirilisnya Java 10, “ceruk” serupa yang baru akan muncul untuk kelas yang menggunakan fitur Java 10 yang paling relevan dan seterusnya. <br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 238</a> , proposal untuk pengembangan Java, yang menjelaskan file JAR yang ravenous, contoh sederhana diberikan.  Katakanlah kita memiliki file JAR dengan empat kelas yang berjalan di Java 8 atau lebih rendah: <br><br><pre> <code class="java hljs">JAR root - A.class - B.class - C.class - D.class</code> </pre> <br>  Sekarang bayangkan bahwa setelah rilis Java 9, kami menulis ulang kelas A dan B sehingga mereka dapat menggunakan fitur-fitur baru khusus untuk Java 9. Kemudian Java 10 keluar, dan kami menulis ulang kelas A sehingga dapat menggunakan fitur-fitur baru Java 10. , aplikasi harus tetap berfungsi baik dengan Java 8. File JAR multi-versi yang baru terlihat seperti ini: <br><br><pre> <code class="java hljs">JAR root - A.class - B.class - C.class - D.class - META-INF Versions - <span class="hljs-number"><span class="hljs-number">9</span></span> - A.class - B.class - <span class="hljs-number"><span class="hljs-number">10</span></span> - A.class</code> </pre> <br>  File JAR tidak hanya memperoleh struktur baru;  sekarang dalam manifesnya ditunjukkan bahwa file ini multi-versi. <br><br>  Ketika Anda menjalankan file JAR ini di Java 8 JVM, ia mengabaikan bagian <code>\META-INF\Versions</code> karena ia bahkan tidak mencurigainya atau mencarinya.  Hanya kelas asli A, B, C, dan D yang digunakan. <br><br>  Saat berjalan di bawah Java 9, kelas-kelas yang terletak di <code>\META-INF\Versions\9</code> digunakan, apalagi, mereka digunakan sebagai pengganti kelas A dan B asli, tetapi kelas-kelas di <code>\META-INF\Versions\10</code> diabaikan. <br><br>  Saat berjalan di bawah Java 10, kedua cabang <code>\META-INF\Versions</code> ;  khususnya, versi A dari Java 10, versi B dari Java 9, dan versi default C dan D. <br><br>  Jadi, jika dalam aplikasi Anda, Anda memerlukan API ProcessBuilder baru dari Java 9, tetapi Anda perlu memastikan bahwa aplikasi terus bekerja di bawah Java 8, cukup tulis versi baru dari kelas Anda menggunakan ProcessBuilder di bagian <code>\META-INF\Versions\9</code> dari file JAR , dan meninggalkan kelas lama di bagian utama arsip, digunakan secara default.  Ini adalah cara termudah untuk menggunakan fitur-fitur baru Java 9 tanpa mengorbankan kompatibilitas ke belakang. <br><br>  Java 9 JDK memiliki versi alat jar.exe yang mendukung pembuatan file JAR multi-versi.  Alat non-JDK lainnya juga menyediakan dukungan ini. <br><br>  <b>Java 9: ​​modul, modul di mana-mana</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem modul Java 9</a> (juga dikenal sebagai Project Jigsaw) tidak diragukan lagi merupakan perubahan terbesar di Jawa 9. Salah satu tujuan modularisasi adalah untuk memperkuat mekanisme enkapsulasi Jawa sehingga pengembang dapat menentukan API mana yang disediakan untuk komponen lain dan dapat menghitung, bahwa JVM akan memberlakukan enkapsulasi.  Enkapsulasi lebih kuat dengan modularisasi daripada dengan pengubah akses <code>public/protected/private</code> untuk kelas atau anggota kelas. <br><br>  Tujuan kedua dari modularisasi adalah untuk menunjukkan modul mana yang memerlukan modul lain untuk bekerja, dan sebelum memulai aplikasi, pastikan bahwa semua modul yang diperlukan sudah ada.  Dalam hal ini, modul lebih kuat daripada mekanisme classpath tradisional, karena jalur classpath tidak diperiksa terlebih dahulu, dan kesalahan mungkin terjadi karena kurangnya kelas yang diperlukan.  Dengan demikian, classpath yang salah dapat dideteksi ketika aplikasi memiliki waktu untuk bekerja cukup lama, atau setelah diluncurkan berkali-kali. <br>  Seluruh sistem modul besar dan kompleks, dan diskusi terperinci tentang hal itu berada di luar cakupan artikel ini (Berikut ini penjelasan yang bagus dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terperinci</a> ).  Di sini saya akan memperhatikan aspek-aspek modularisasi yang membantu pengembang dengan dukungan aplikasi warisan. <br><br>  Modularisasi adalah hal yang baik, dan pengembang harus mencoba memecah kode baru ke dalam modul bila memungkinkan, bahkan jika aplikasi lainnya (belum) termodulasi.  Untungnya, ini mudah dilakukan berkat spesifikasi untuk bekerja dengan modul. <br><br>  Pertama, file JAR menjadi termodulasi (dan berubah menjadi modul) dengan tampilan file module-info.class (dikompilasi dari module-info.java) di akar file JAR.  <code>module-info.java</code> berisi metadata, khususnya, nama modul yang paketnya diekspor (yaitu menjadi terlihat dari luar), yang memerlukan modul modul ini, dan beberapa informasi lainnya. <br><br>  Informasi dalam <code>module-info.class</code> hanya terlihat ketika JVM mencarinya - yaitu, sistem memperlakukan file JAR yang termodulasi seperti biasa jika bekerja dengan versi Java yang lebih lama (diasumsikan bahwa kode tersebut dikompilasi untuk bekerja dengan versi Java yang lebih lama Sebenarnya, dibutuhkan sedikit chemistry, dan masih Java 9 yang ditetapkan sebagai versi target module-info.class, tetapi ini nyata). <br><br>  Dengan demikian, Anda harus dapat menjalankan file JAR termodulasi dengan Java 8 dan di bawah, asalkan dalam hal lain mereka juga kompatibel dengan versi Java sebelumnya.  Juga perhatikan bahwa <code>module-info.class</code> dapat, dengan reservasi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditempatkan di area berversi dari file JAR multi-versi</a> . <br><br>  Di Java 9, ada classpath dan path modul.  dan jalur modul.  Classpath berfungsi seperti biasa.  Jika Anda meletakkan file JAR termodulasi dalam classpath, itu terbuang seperti file JAR lainnya.  Artinya, jika Anda memodulasi file JAR, dan aplikasi Anda belum siap untuk memperlakukannya sebagai modul, Anda dapat meletakkannya di classpath, itu akan berfungsi seperti biasa.  Kode lawas Anda harus menanganinya dengan cukup sukses. <br><br>  Juga perhatikan bahwa koleksi semua file JAR di classpath dianggap sebagai bagian dari modul tunggal yang tidak disebutkan namanya.  Modul semacam itu dianggap yang paling umum, namun, ia mengekspor semua informasi ke modul lain, dan dapat merujuk ke modul lain mana pun.  Jadi, jika Anda belum memiliki aplikasi Java termodulasi, tetapi ada beberapa pustaka lama yang juga tidak termodulasi (dan mungkin tidak akan pernah) - Anda cukup meletakkan semua pustaka ini di classpath, dan seluruh sistem akan berfungsi dengan baik. <br><br>  Java 9 memiliki lintasan modul yang bekerja bersama dengan classpath.  Saat menggunakan modul dari jalur ini, JVM dapat memeriksa (baik pada waktu kompilasi dan pada saat run time) apakah semua modul yang diperlukan sudah ada dan melaporkan kesalahan jika ada modul yang hilang.  Semua file JAR di classpath, sebagai anggota modul yang tidak disebutkan namanya, dapat diakses oleh modul yang terdaftar di jalur modular - dan sebaliknya. <br><br>  Tidaklah sulit untuk mentransfer file JAR dari classpath ke jalur modul - dan mengambil keuntungan penuh dari modularisasi.  Pertama, Anda bisa menambahkan file <code>module-info.class</code> ke file JAR, dan kemudian meletakkan file JAR yang termodulasiasi di lintasan modul.  Modul yang baru dibuat tersebut masih akan dapat mengakses semua file JAR yang tersisa di classpath JAR, karena mereka memasukkan modul yang tidak disebutkan namanya dan tetap dalam akses. <br><br>  Mungkin juga Anda tidak ingin memodulasi file JAR, atau bahwa file JAR bukan milik Anda, tetapi milik orang lain, jadi Anda tidak dapat memodulasinya sendiri.  Dalam hal ini, file JAR masih dapat diletakkan di jalur modul, itu akan menjadi modul otomatis. <br><br>  Modul otomatis dianggap sebagai modul, meskipun tidak memiliki file <code>module-info.class</code> .  Modul ini adalah nama yang sama dengan file JAR yang dikandungnya, dan modul lain dapat secara eksplisit memintanya.  Secara otomatis mengekspor semua API yang tersedia untuk umum dan membaca (mis., Mensyaratkan) semua modul bernama lainnya serta modul tanpa nama. <br><br>  Dengan demikian, file JAR yang tidak dimodifikasi dari classpath dapat diubah menjadi modul tanpa melakukan apa pun.  File JAR yang diwarisi secara otomatis dikonversi ke modul, mereka hanya kekurangan beberapa informasi yang akan menentukan apakah semua modul yang diperlukan sudah ada, atau menentukan apa yang hilang. <br><br>  Tidak semua file JAR yang tidak dimodifikasi dapat dipindahkan ke jalur modul dan diubah menjadi modul otomatis.  Ada aturannya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket bisa menjadi bagian dari hanya satu modul bernama</a> .  Artinya, jika sebuah paket terletak di lebih dari satu file JAR, maka hanya satu file JAR dengan paket ini dalam komposisi yang dapat diubah menjadi modul otomatis.  Sisanya dapat tetap berada di classpath dan bergabung dengan modul yang tidak disebutkan namanya. <br><br>  Sepintas, mekanisme yang dijelaskan di sini tampak rumit, tetapi dalam praktiknya sangat sederhana.  Faktanya, dalam hal ini hanya Anda dapat meninggalkan file JAR lama di classpath atau memindahkannya ke jalur modul.  Anda dapat memecahnya menjadi modul atau tidak.  Dan ketika file JAR lama Anda termodulasi, Anda bisa membiarkannya di classpath atau memindahkannya ke jalur modul. <br><br>  Dalam kebanyakan kasus, semuanya harus berfungsi, seperti sebelumnya.  File JAR Anda yang diwarisi harus berakar di sistem modular baru.  Semakin Anda memodulasi kode, semakin banyak informasi dependensi yang perlu Anda periksa, dan modul dan API yang hilang akan terdeteksi pada tahap pengembangan lebih awal dan mungkin akan menghemat banyak pekerjaan. <br><br>  <b>Java 9 "lakukan sendiri": Modular JDK dan Jlink</b> <br><br>  Salah satu masalah dengan aplikasi Java lawas adalah bahwa pengguna akhir mungkin tidak bekerja dengan lingkungan Java yang sesuai.  Salah satu cara untuk menjamin kesehatan aplikasi Java adalah dengan menyediakan runtime dengan aplikasi tersebut.  Java memungkinkan Anda membuat JRE pribadi (dapat didistribusikan) yang dapat didistribusikan dalam aplikasi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inilah</a> cara membuat JRE pribadi.  Sebagai aturan, hierarki file JRE diambil, yang diinstal dengan JDK, file yang diperlukan disimpan, dan file opsional dengan fungsi yang mungkin diperlukan dalam aplikasi Anda disimpan. <br><br>  Prosesnya agak merepotkan: Anda harus menjaga hierarki file instalasi, sambil berhati-hati, sehingga Anda tidak ketinggalan satu file, bukan direktori tunggal.  Ini dengan sendirinya tidak ada salahnya, namun, Anda masih ingin menyingkirkan semua yang berlebihan, karena file-file ini memakan ruang.  Ya, mudah untuk menyerah dan membuat kesalahan seperti itu. <br><br>  Jadi mengapa tidak mendelegasikan pekerjaan ini ke JDK? <br><br>  Di Java 9, Anda dapat membuat lingkungan mandiri yang ditambahkan ke aplikasi - dan di lingkungan ini akan ada semua yang diperlukan agar aplikasi berfungsi.  Anda tidak perlu khawatir lagi bahwa komputer pengguna akan memiliki lingkungan yang salah untuk mengeksekusi Java, Anda tidak perlu khawatir bahwa Anda sendiri membangun JRE pribadi secara tidak tepat. <br><br>  Sumber daya utama untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gambar yang dapat dieksekusi mandiri</a> seperti itu adalah sistem modular.  Sekarang Anda dapat memodulasi tidak hanya kode Anda sendiri, tetapi juga Java 9 JDK itu sendiri.  Sekarang perpustakaan kelas Java adalah kumpulan modul, dan alat JDK juga terdiri dari modul.  Sistem modul mengharuskan Anda untuk menentukan modul kelas dasar yang diperlukan dalam kode Anda, dan Anda menentukan elemen JDK yang diperlukan. <br><br>  Untuk menyatukan semuanya, Java 9 menyediakan alat baru khusus yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jlink</a> .  Dengan meluncurkan jlink, Anda mendapatkan hierarki file - persis yang Anda perlukan untuk menjalankan aplikasi Anda, tidak lebih, tidak kurang.  Perangkat seperti itu akan jauh lebih kecil daripada JRE standar, apalagi, itu akan menjadi platform-spesifik (yaitu, dipilih untuk sistem operasi dan mesin tertentu).  Oleh karena itu, jika Anda ingin membuat gambar yang dapat dieksekusi seperti itu untuk platform lain, Anda harus menjalankan jlink dalam konteks instalasi pada setiap platform tertentu yang Anda butuhkan gambar tersebut. <br><br>  Perhatikan juga: jika Anda menjalankan jlink dengan aplikasi di mana tidak ada yang termodulasi, alat tersebut tidak memiliki informasi yang diperlukan untuk menekan JRE, jadi jlink tidak akan memiliki apa pun selain mengemas seluruh JRE.  Bahkan dalam kasus ini, itu akan sedikit lebih nyaman bagi Anda: jlink akan mengemas JRE untuk Anda, jadi Anda tidak bisa khawatir tentang cara menyalin hierarki file dengan benar. <br><br>  Dengan jlink, menjadi mudah untuk mengemas aplikasi dan semua yang Anda butuhkan untuk menjalankannya - dan Anda tidak perlu khawatir bahwa Anda akan melakukan sesuatu yang salah.  Alat hanya akan mengemas bagian runtime yang diperlukan agar aplikasi berfungsi.  Artinya, aplikasi Java warisan dijamin untuk menerima lingkungan di mana ia akan beroperasi. <br><br>  <b>Pertemuan yang lama dan yang baru</b> <br><br>   ,     Java-   ,      ,     .  Java 9,     ,      API   ,   (  )  ,      ,         Java. <br><br>     Java 9: -,      ,        ,      Java. <br><br>  JAR-      Java 9       JAR-,     Java   .  ,      Java 9,     Java 8        –     . <br><br>   Java,    ,     JAR-   ,     .   ,             ,  «  »   . <br><br>   JDK  jlink,             ,       .       ,    Java    –    . <br><br>      Java,  Java 9       ,             –       ,   ,          Java. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417733/">https://habr.com/ru/post/id417733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417721/index.html">GPU dalam memecahkan masalah TI modern</a></li>
<li><a href="../id417723/index.html">Bekerja dengan API KOMPAS-3D → Pelajaran 11 → Label teks sederhana</a></li>
<li><a href="../id417725/index.html">Bagaimana Flant Mempekerjakan Karyawan</a></li>
<li><a href="../id417729/index.html">Intel Core i7-8086K (bagian 2)</a></li>
<li><a href="../id417731/index.html">Kisah satu T61</a></li>
<li><a href="../id417735/index.html">Infrastruktur Kunci Publik: Token GnuPG / SMIME dan PKCS # 11 dengan Dukungan untuk Kriptografi Rusia</a></li>
<li><a href="../id417737/index.html">Ini dia, musim panas kita</a></li>
<li><a href="../id417739/index.html">Pembelajaran Mesin Terhadap Risiko Kredit, atau "Ayo, Gini, Ayo"</a></li>
<li><a href="../id417741/index.html">27 Juli 2018 - gerhana bulan total dan konfrontasi hebat Mars</a></li>
<li><a href="../id417743/index.html">Amplifier Legendaris - Anatomi Tren Historis: Suara Transistor Dingin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>