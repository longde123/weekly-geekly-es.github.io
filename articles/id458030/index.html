<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏽 🚥 🤘 JavaScript Fungsional: lima cara untuk menemukan rata-rata aritmatika elemen array dan metode .reduce () 🙅🏾 🏴‍☠️ ✊🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Metode iterasi array mirip dengan "obat permulaan" (tentu saja, itu bukan narkoba; dan saya tidak mengatakan bahwa obat itu baik; mereka hanya kiasan)...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript Fungsional: lima cara untuk menemukan rata-rata aritmatika elemen array dan metode .reduce ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/458030/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode iterasi array</a> mirip dengan "obat permulaan" (tentu saja, itu bukan narkoba; dan saya tidak mengatakan bahwa obat itu baik; mereka hanya kiasan).  Karena mereka, banyak "duduk" pada pemrograman fungsional.  Masalahnya adalah mereka sangat nyaman.  Selain itu, sebagian besar metode ini sangat mudah dipahami.  Metode seperti <code>.map()</code> dan <code>.filter()</code> menerima hanya satu argumen panggilan balik dan memungkinkan Anda untuk memecahkan masalah sederhana.  Tetapi ada perasaan bahwa metode <code>.reduce()</code> menyebabkan beberapa kesulitan bagi banyak orang.  Untuk memahaminya sedikit lebih sulit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/zd/ig/jp/zdigjpelbgmyf4qdprvkrxo5bu4.png"></a> <br><a name="habracut"></a><br>  Saya sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis</a> tentang mengapa saya pikir <code>.reduce()</code> menciptakan banyak masalah.  Ini sebagian disebabkan oleh kenyataan bahwa banyak manual menunjukkan penggunaan <code>.reduce()</code> hanya ketika menangani angka.  Oleh karena itu, saya menulis tentang berapa banyak tugas yang tidak menyiratkan operasi aritmatika dapat diselesaikan menggunakan <code>.reduce()</code> .  Tetapi bagaimana jika Anda benar-benar perlu bekerja dengan angka? <br><br>  Penggunaan khas <code>.reduce()</code> tampak seperti perhitungan rata-rata aritmatika dari elemen-elemen array.  Sekilas, tampaknya tidak ada yang istimewa dalam tugas ini.  Tapi dia tidak sesederhana itu.  Faktanya adalah bahwa sebelum menghitung rata-rata, Anda perlu menemukan indikator berikut: <br><br><ol><li>  Jumlah total nilai elemen array. </li><li>  Panjang array. </li></ol><br>  Mengetahui semua ini cukup sederhana.  Dan perhitungan nilai rata-rata untuk array numerik juga bukan operasi yang sulit.  Ini adalah contoh dasar: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nums</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nums.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> (a + b)) / nums.length; }</code> </pre> <br>  Seperti yang Anda lihat, tidak ada ketidakpahaman khusus di sini.  Tetapi tugas menjadi lebih sulit jika Anda harus bekerja dengan struktur data yang lebih kompleks.  Bagaimana jika kita memiliki berbagai objek?  Bagaimana jika beberapa objek dari array ini perlu disaring?  Apa yang harus dilakukan jika Anda perlu mengekstraksi nilai numerik tertentu dari objek?  Dalam situasi ini, menghitung nilai rata-rata untuk elemen array sudah tugas yang sedikit lebih rumit. <br><br>  Untuk mengatasi ini, kami akan menyelesaikan masalah pelatihan (ini didasarkan pada tugas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> dengan FreeCodeCamp).  Kami akan menyelesaikannya dengan lima cara berbeda.  Masing-masing dari mereka memiliki kelebihan dan kekurangan.  Analisis dari lima pendekatan ini untuk menyelesaikan masalah ini akan menunjukkan seberapa fleksibelnya JavaScript.  Dan saya berharap bahwa analisis solusi akan memberi Anda makanan untuk dipikirkan tentang cara menggunakan <code>.reduce()</code> dalam proyek nyata. <br><br><h2>  <font color="#3AC1EF">Ikhtisar Tugas</font> </h2><br>  Misalkan kita memiliki berbagai objek yang menggambarkan ekspresi bahasa gaul Victoria.  Anda perlu memfilter ekspresi yang tidak ditemukan di Google Buku (properti yang <code>found</code> dari objek yang sesuai adalah <code>false</code> ), dan menemukan peringkat rata-rata untuk popularitas ekspresi.  Seperti apa data tersebut nantinya (diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> victorianSlang = [           term: <span class="hljs-string"><span class="hljs-string">'doing the bear'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">108</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'katterzem'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'bone shaker'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">609</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'smothering a parrot'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'damfino'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">232</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'rain napper'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'donkey'</span></span>s breakfast<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 787,    },           term: '</span></span>rational costume<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 513,    },           term: '</span></span>mind the grease<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 154,    }, ];</span></span></code> </pre> <br>  Pertimbangkan 5 cara untuk menemukan nilai rata-rata estimasi popularitas ekspresi dari array ini. <br><br><h2>  <font color="#3AC1EF">1. Memecahkan masalah tanpa menggunakan .reduce () (loop wajib)</font> </h2><br>  Dalam pendekatan pertama kami untuk memecahkan masalah, metode <code>.reduce()</code> tidak akan digunakan.  Jika Anda belum menemukan metode untuk mengulangi array sebelumnya, maka saya berharap bahwa menguraikan contoh ini akan sedikit memperjelas situasinya untuk Anda. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popularitySum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> itemsFound = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> len = victorianSlang.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) {    item = victorianSlang[i];    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.found) {        popularitySum = item.popularity + popularitySum;        itemsFound = itemsFound + <span class="hljs-number"><span class="hljs-number">1</span></span>;   } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> averagePopularity = popularitySum / itemsFound; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Average popularity:"</span></span>, averagePopularity);</code> </pre> <br>  Jika Anda terbiasa dengan JavaScript, maka Anda akan dengan mudah memahami contoh ini.  Faktanya, hal berikut terjadi di sini: <br><br><ol><li>  Kami menginisialisasi variabel <code>popularitySum</code> dan <code>itemsFound</code> .  Variabel pertama, <code>popularitySum</code> , menyimpan peringkat keseluruhan popularitas ekspresi.  Dan variabel kedua, <code>itemsFound</code> , (itu kejutan) menyimpan jumlah ekspresi yang ditemukan. </li><li>  Kemudian kita menginisialisasi <code>len</code> konstan dan <code>item</code> variabel, yang berguna bagi kita ketika melintasi array. </li><li>  Dalam <code>for</code> , counter <code>i</code> bertambah sampai nilainya mencapai nilai indeks elemen terakhir dari array. </li><li>  Di dalam loop, kita mengambil elemen array yang ingin kita jelajahi.  Kami mengakses elemen menggunakan konstruk <code>victorianSlang[i]</code> . </li><li>  Kemudian kami mencari tahu apakah ungkapan ini ditemukan dalam koleksi buku. </li><li>  Jika sebuah ekspresi muncul di buku, kami mengambil nilai peringkat popularitasnya dan menambah nilai dari variabel <code>popularitySum</code> . </li><li>  Pada saat yang sama, kami juga meningkatkan counter dari ekspresi yang ditemukan - <code>itemsFound</code> . </li><li>  Dan akhirnya, kami menemukan rata-rata dengan membagi <code>popularitySum</code> per <code>itemsFound</code> . </li></ol><br>  Jadi, kami mengatasi tugas itu.  Mungkin keputusan kami tidak terlalu indah, tetapi melakukan tugasnya.  Menggunakan metode untuk beralih melalui array akan membuatnya sedikit lebih bersih.  Mari kita lihat apakah kita berhasil, dan kebenarannya adalah "membersihkan" keputusan ini. <br><br><h2>  <font color="#3AC1EF">2. Solusi sederhana # 1: .filter (), .map () dan menemukan jumlah menggunakan .reduce ()</font> </h2><br>  Mari, sebelum upaya pertama untuk menggunakan metode array untuk menyelesaikan masalah, kami memecahnya menjadi bagian-bagian kecil.  Yaitu, inilah yang perlu kita lakukan: <br><br><ol><li>  Pilih objek yang mewakili ekspresi yang ada di koleksi Google Buku.  Di sini Anda dapat menggunakan metode <code>.filter()</code> . </li><li>  Ekstrak dari objek evaluasi popularitas ekspresi.  Untuk mengatasi subtugas ini, metode <code>.map()</code> cocok. </li><li>  Hitung jumlah peringkat.  Di sini kita dapat menggunakan bantuan teman lama kita <code>.reduce()</code> . </li><li>  Dan akhirnya, temukan nilai rata-rata estimasi. </li></ol><br>  Begini tampilannya dalam kode: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } function addScores(runningTotal, popularity) {    return runningTotal + popularity; } //  // ---------------------------------------------------------------------------- //  ,      . const foundSlangTerms = victorianSlang.filter(isFound); //   ,   . const popularityScores = foundSlangTerms.map(getPopularity); //     .    ,    //   ,  reduce     ,  0. const scoresTotal = popularityScores.reduce(addScores, 0); //       . const averagePopularity = scoresTotal / popularityScores.length; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  <code>addScore</code> fungsi <code>addScore</code> , dan baris tempat <code>.reduce()</code> dipanggil.  Perhatikan bahwa <code>addScore</code> menerima dua parameter.  Yang pertama, <code>runningTotal</code> , dikenal sebagai baterai.  Ini menyimpan jumlah nilai.  Nilainya berubah setiap kali ketika kami mengulangi array dan menjalankan <code>return</code> .  Parameter kedua, <code>popularity</code> , adalah elemen terpisah dari array yang sedang kami proses.  Pada awal <code>addScore</code> atas array, <code>return</code> <code>addScore</code> di <code>addScore</code> belum pernah dieksekusi.  Ini berarti <code>runningTotal</code> belum diatur secara otomatis.  Oleh karena itu, dengan memanggil <code>.reduce()</code> , kami meneruskan ke metode ini nilai yang perlu ditulis untuk <code>runningTotal</code> di awal.  Ini adalah parameter kedua yang dilewatkan ke <code>.reduce()</code> . <br><br>  Jadi, kami menerapkan metode iterating array untuk menyelesaikan masalah.  Versi baru dari solusi ini ternyata jauh lebih bersih daripada yang sebelumnya.  Dengan kata lain, keputusan itu ternyata lebih bersifat deklaratif.  Kami tidak memberi tahu JavaScript tentang cara mengeksekusi loop secara tepat; kami tidak mengikuti indeks elemen-elemen array.  Sebagai gantinya, kami mendeklarasikan fungsi pembantu sederhana berukuran kecil dan menggabungkannya.  Semua kerja keras dilakukan untuk kita dengan metode array <code>.filter()</code> , <code>.map()</code> dan <code>.reduce()</code> .  Pendekatan untuk memecahkan masalah seperti ini lebih ekspresif.  Metode array ini jauh lebih lengkap daripada yang bisa dilakukan loop, mereka memberi tahu kami tentang maksud yang ditetapkan dalam kode. <br><br><h2>  <font color="#3AC1EF">3. Solusi Mudah # 2: Menggunakan Banyak Baterai</font> </h2><br>  Dalam versi sebelumnya dari solusi, kami menciptakan sejumlah variabel menengah.  Misalnya, <code>foundSlangTerms</code> dan <code>foundSlangTerms</code> .  Dalam kasus kami, solusi semacam itu cukup dapat diterima.  Tetapi bagaimana jika kita menetapkan tujuan yang lebih kompleks tentang desain kode?  Alangkah baiknya jika kita bisa menggunakan pola desain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka yang lancar</a> dalam program ini.  Dengan pendekatan ini, kita akan dapat mengaitkan panggilan semua fungsi dan dapat melakukannya tanpa variabel perantara.  Namun, satu masalah menunggu kita di sini.  Perhatikan bahwa kita perlu mendapatkan nilai <code>popularityScores.length</code> .  Jika kita akan mengaitkan semuanya, maka kita perlu cara lain untuk menemukan jumlah elemen dalam array.  Jumlah elemen dalam array memainkan peran pembagi dalam menghitung nilai rata-rata.  Mari kita lihat apakah kita bisa mengubah pendekatan untuk memecahkan masalah sehingga semuanya bisa dilakukan dengan menggabungkan pemanggilan metode dalam sebuah rantai.  Kami akan melakukan ini dengan melacak dua nilai ketika mengulangi elemen array, yaitu menggunakan "baterai ganda". <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // --------------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } //    ,  return,   . function addScores({totalPopularity, itemCount}, popularity) {    return {        totalPopularity: totalPopularity + popularity,        itemCount:    itemCount + 1,    }; } //  // --------------------------------------------------------------------------------- const initialInfo  = {totalPopularity: 0, itemCount: 0}; const popularityInfo = victorianSlang.filter(isFound)    .map(getPopularity)    .reduce(addScores, initialInfo); //       . const {totalPopularity, itemCount} = popularityInfo; const averagePopularity = totalPopularity / itemCount; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Di sini, untuk bekerja dengan dua nilai, kami menggunakan objek dalam fungsi peredam.  Setiap melewati array yang dilakukan menggunakan <code>addScrores</code> , kami memperbarui nilai total peringkat popularitas dan jumlah elemen.  Penting untuk dicatat bahwa kedua nilai ini direpresentasikan sebagai objek tunggal.  Dengan pendekatan ini, kita dapat "menipu" sistem dan menyimpan dua entitas dalam nilai pengembalian yang sama. <br><br>  Fungsi <code>addScrores</code> sedikit lebih rumit daripada fungsi dengan nama yang sama pada contoh sebelumnya.  Tapi sekarang ternyata kita bisa menggunakan satu rantai pemanggilan metode untuk melakukan semua operasi dengan array.  Sebagai hasil dari pemrosesan array, kami mendapatkan objek popularInfo, yang menyimpan semua yang Anda butuhkan untuk menemukan rata-rata.  Ini membuat rantai panggilan rapi dan sederhana. <br><br>  Jika Anda merasakan keinginan untuk meningkatkan kode ini, maka Anda dapat mencobanya.  Misalnya - Anda dapat mengulanginya untuk menghilangkan banyak variabel perantara.  Anda bahkan dapat mencoba meletakkan kode ini pada satu baris. <br><br><h2>  <font color="#3AC1EF">4. Komposisi fungsi tanpa menggunakan notasi titik</font> </h2><br>  Jika Anda baru mengenal pemrograman fungsional, atau jika Anda merasa pemrograman fungsional terlalu rumit, Anda dapat melewati bagian ini.  Mem-parsing akan menguntungkan Anda jika Anda sudah terbiasa dengan <code>curry()</code> dan <code>compose()</code> .  Jika Anda ingin mempelajari topik ini, lihat materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> tentang pemrograman fungsional dalam JavaScript, dan, khususnya, pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketiga</a> dari seri yang disertakan. <br><br>  Kami adalah programmer yang mengambil pendekatan fungsional.  Ini berarti bahwa kami berusaha keras untuk membangun fungsi kompleks dari fungsi lain - kecil dan sederhana.  Sejauh ini, dalam mempertimbangkan berbagai opsi untuk menyelesaikan masalah, kami telah mengurangi jumlah variabel perantara.  Akibatnya, kode solusi menjadi lebih sederhana dan lebih mudah.  Tetapi bagaimana jika ide ini dianggap ekstrem?  Bagaimana jika Anda mencoba untuk menyingkirkan semua variabel perantara?  Dan bahkan mencoba untuk menjauh dari beberapa parameter? <br><br>  Anda bisa membuat fungsi untuk menghitung rata-rata menggunakan fungsi <code>compose()</code> saja, tanpa menggunakan variabel.  Kami menyebutnya "pemrograman tanpa menggunakan notasi berbutir halus" atau "pemrograman implisit".  Untuk menulis program seperti itu, Anda akan memerlukan banyak fungsi tambahan. <br><br>  Terkadang kode seperti itu mengejutkan orang.  Ini disebabkan oleh kenyataan bahwa pendekatan semacam itu sangat berbeda dengan pendekatan yang diterima secara umum.  Tetapi saya menemukan bahwa menulis kode dengan gaya pemrograman implisit adalah salah satu cara tercepat untuk memahami esensi pemrograman fungsional.  Karena itu, saya dapat menyarankan Anda untuk mencoba teknik ini di beberapa proyek pribadi.  Tetapi saya ingin mengatakan bahwa mungkin Anda tidak boleh menulis dengan gaya pemrograman implisit kode yang harus dibaca orang lain. <br><br>  Jadi, kembali ke tugas kita membangun sistem untuk menghitung rata-rata.  Demi menghemat ruang, kami akan pindah ke sini untuk menggunakan fungsi panah.  Biasanya, sebagai aturan, lebih baik menggunakan fungsi bernama.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inilah</a> artikel bagus tentang topik ini.  Ini memungkinkan Anda untuk mendapatkan hasil penelusuran jejak yang lebih baik jika terjadi kesalahan. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- const filter = p =&gt; a =&gt; a.filter(p); const map   = f =&gt; a =&gt; a.map(f); const prop  = k =&gt; x =&gt; x[k]; const reduce = r =&gt; i =&gt; a =&gt; a.reduce(r, i); const compose = (...fns) =&gt; (arg) =&gt; fns.reduceRight((arg, fn) =&gt; fn(arg), arg); //  -   "blackbird combinator". //     : https://jrsinclair.com/articles/2019/compose-js-functions-multiple-parameters/ const B1 = f =&gt; g =&gt; h =&gt; x =&gt; f(g(x))(h(x)); //  // ---------------------------------------------------------------------------- //   sum,    . const sum = reduce((a, i) =&gt; a + i)(0); //     . const length = a =&gt; a.length; //       . const div = a =&gt; b =&gt; a / b; //   compose()        . //    compose()     . const calcPopularity = compose(    B1(div)(sum)(length),    map(prop('popularity')),    filter(prop('found')), ); const averagePopularity = calcPopularity(victorianSlang); console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Jika semua kode ini menurut Anda benar-benar omong kosong - jangan khawatir tentang hal itu.  Saya memasukkannya di sini sebagai latihan intelektual, dan tidak mengecewakan Anda. <br><br>  Dalam hal ini, pekerjaan utama adalah fungsi <code>compose()</code> .  Jika Anda membaca kontennya dari bawah ke atas, ternyata perhitungan dimulai dengan memfilter array berdasarkan properti elemen yang <code>found</code> .  Lalu kami mengambil properti elemen <code>popularity</code> menggunakan <code>map()</code> .  Setelah itu kami menggunakan apa yang disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blackbird combinator</a> ".  Entitas ini direpresentasikan sebagai fungsi <code>B1</code> , yang digunakan untuk melakukan dua lintasan perhitungan pada satu set data input.  Untuk lebih memahami hal ini, lihat contoh berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  , : const avg1 = B1(div)(sum)(length); const avg2 = arr =&gt; div(sum(arr))(length(arr)); const avg3 = arr =&gt; ( sum(arr) / length(arr) ); const avg4 = arr =&gt; arr.reduce((a, x) =&gt; a + x, 0) / arr.length;</span></span></code> </pre> <br>  Sekali lagi, jika Anda tidak mengerti apa-apa lagi - jangan khawatir.  Ini hanya demonstrasi bahwa JavaScript dapat ditulis dengan cara yang sangat berbeda.  Dari fitur-fitur ini, ini adalah keindahan bahasa ini. <br><br><h2>  <font color="#3AC1EF">5. Memecahkan masalah dalam satu lulus dengan perhitungan nilai rata-rata kumulatif</font> </h2><br>  Semua konstruksi perangkat lunak di atas melakukan pekerjaan dengan baik untuk menyelesaikan masalah kita (termasuk siklus imperatif).  Mereka yang menggunakan metode <code>.reduce()</code> memiliki kesamaan.  Mereka didasarkan pada pemecahan masalah menjadi fragmen kecil.  Fragmen-fragmen ini kemudian dirakit dengan berbagai cara.  Dengan menganalisis solusi ini, Anda mungkin memperhatikan bahwa di dalamnya kita berkeliling array tiga kali.  Ada perasaan bahwa itu tidak efektif.  Alangkah baiknya jika ada cara untuk memproses array dan mengembalikan hasilnya dalam satu pass.  Metode ini ada, tetapi aplikasinya akan membutuhkan menggunakan matematika. <br><br>  Untuk menghitung nilai rata-rata elemen array dalam satu pass, kita membutuhkan metode baru.  Anda perlu menemukan cara untuk menghitung rata-rata menggunakan rata-rata yang dihitung sebelumnya dan nilai baru.  Kami mencari metode ini menggunakan aljabar. <br><br>  Nilai rata-rata dari <code>n</code> angka dapat ditemukan menggunakan rumus ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/922/a8a/ea8922a8ad59e55aa604bf01c72b55e4.png"></div><br>  Untuk mengetahui angka rata-rata <code>n + 1</code> , rumus yang sama akan berlaku, tetapi dalam entri yang berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77c/ee8/a1f/77cee8a1fe717b88a55b2f2af6f222e2.png"></div><br>  Rumus ini sama dengan ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/b3a/0ca/651b3a0caa501b140e23cbce68a96720.png"></div><br>  Dan hal yang sama seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e1b/da4/f7be1bda4b12343eee3dde51d80f95c0.png"></div><br>  Jika Anda mengonversi ini sedikit, Anda mendapatkan yang berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/038/165/1b5/0381651b520c5136458129c1882a44af.png"></div><br>  Jika Anda tidak melihat intinya dalam semua ini, maka tidak apa-apa.  Hasil dari semua transformasi ini adalah bahwa dengan bantuan rumus terakhir kita dapat menghitung nilai rata-rata selama satu traversal array.  Untuk melakukan ini, Anda perlu mengetahui nilai elemen saat ini, nilai rata-rata yang dihitung pada langkah sebelumnya, dan jumlah elemen.  Selain itu, sebagian besar perhitungan dapat dilakukan dalam fungsi peredam: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      // ---------------------------------------------------------------------------- function averageScores({avg, n}, slangTermInfo) {    if (!slangTermInfo.found) {        return {avg, n};       return {        avg: (slangTermInfo.popularity + n * avg) / (n + 1),        n:  n + 1,    }; } //  // ---------------------------------------------------------------------------- //       . const initialVals    = {avg: 0, n: 0}; const averagePopularity = victorianSlang.reduce(averageScores, initialVals).avg; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Berkat pendekatan ini, nilai yang diperlukan dapat ditemukan melewati array hanya sekali.  Pendekatan lain menggunakan satu pass untuk memfilter array, yang lain untuk mengekstrak data yang diperlukan dari itu, dan yang lain untuk menemukan jumlah nilai-nilai elemen.  Di sini, semuanya cocok menjadi satu pass melalui array. <br><br>  Harap dicatat bahwa ini tidak selalu membuat perhitungan lebih efisien.  Dengan pendekatan ini, lebih banyak perhitungan harus dilakukan.  Ketika setiap nilai baru tiba, kami melakukan operasi penggandaan dan pembagian, melakukan ini untuk mempertahankan nilai rata-rata saat ini dalam keadaan saat ini.  Dalam solusi lain untuk masalah ini, kami membagi satu nomor menjadi yang lain hanya sekali - di akhir program.  Tetapi pendekatan ini jauh lebih efisien dalam hal penggunaan memori.  Array perantara tidak digunakan di sini, akibatnya kita harus menyimpan dalam memori hanya objek dengan dua nilai. <br><br>         .        .     ,     .   .  ,   ,      . <br><br><h2> <font color="#3AC1EF"> ?</font> </h2><br>              ?   ,     . ,    -  . , ,      ,       .         ,       .       ,           .          ,      ,       . <br><br> ,  -     ,           .       ,         ?   .      .  —   . <br><br><h2> <font color="#3AC1EF"></font> </h2><br>         : <br><br><ol><li>   <code>.reduce()</code> . </li><li>    <code>.filter()</code>  <code>.map()</code> ,   —  <code>.reduce()</code>       . </li><li>   ,      . </li><li>     . </li><li>         . </li></ol><br>  , -,     ?    —  .      -  —     ,          : <br><br><ol><li>    ,     .      —   . </li><li>    ,    ,    —     . </li><li> , ,        —   ,     . </li></ol><br> <b> !</b>        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458030/">https://habr.com/ru/post/id458030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458014/index.html">Robot FEDOR - pelatihan dengan kru ISS baru dan tugas luar angkasa pertama</a></li>
<li><a href="../id458018/index.html">composer vs npm: pengembangan multi-modul</a></li>
<li><a href="../id458020/index.html">Juli Acara IT Digest</a></li>
<li><a href="../id458022/index.html">Sidik jari melalui iklan spanduk? Sekarang ini sudah biasa</a></li>
<li><a href="../id458026/index.html">Perbandingan Format Serialisasi</a></li>
<li><a href="../id458040/index.html">Dari Moskow ke Tomsk. Kisah satu langkah</a></li>
<li><a href="../id458042/index.html">Bagaimana saya mengatur pelatihan pembelajaran mesin di NSU</a></li>
<li><a href="../id458044/index.html">Keamanan informasi provinsi - stagnasi atau pembangunan?</a></li>
<li><a href="../id458046/index.html">Lembar Curang Gradle</a></li>
<li><a href="../id458048/index.html">Delegasi sebagai alat manajer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>