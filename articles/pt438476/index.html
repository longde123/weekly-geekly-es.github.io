<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêä ü§§ üîá Para a quest√£o dos amortecedores (anel) üë©üèΩ‚Äçüíª üëâüèΩ üßëüèº‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Se voc√™ achar os custos de desenvolvimento da arquitetura excessivos, considere quanto a arquitetura errada pode custar" 
 - N√£o me lembro exatamente...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Para a quest√£o dos amortecedores (anel)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438476/"><h3>  "Se voc√™ achar os custos de desenvolvimento da arquitetura excessivos, considere quanto a arquitetura errada pode custar" </h3><br>  - N√£o me lembro exatamente a fonte <br><br>  Certa vez, "h√° muito tempo, em uma gal√°xia distante", comprei o maravilhoso livro de Charles Weatherly, Etudes for Programmers, na introdu√ß√£o em que o autor comprovou a necessidade de estudar exemplos e tarefas educacionais antes de iniciar a programa√ß√£o independente.  Eu recomendo fortemente que voc√™ encontre este livro, leia o pref√°cio (e sem parar, leia o resto e resolva os problemas nele contidos), pois n√£o posso comprovar melhor a necessidade de tal pr√°tica.  Mesmo se voc√™ seguir minha recomenda√ß√£o e adquirir muito conhecimento e habilidades pr√°ticas ao ler o livro, poder√° voltar e ler este post, pois ele √© dedicado a v√°rias outras quest√µes.  E se voc√™ n√£o seguir minhas recomenda√ß√µes, tanto mais voc√™ deve ir para baixo do gato. <br><a name="habracut"></a><br>  H√° pouco tempo, em um post em que repreendi, expressei minha opini√£o sobre um RTOS dom√©stico, mencionei que a implementa√ß√£o do buffer de anel na conhecida biblioteca mcucpp (e em certos aspectos, absolutamente maravilhoso) n√£o pode ser considerada ideal.  Vou tentar explicar meu ponto de vista e imaginar a implementa√ß√£o ideal (tanto quanto poss√≠vel no mundo real).  Nota - o texto oferecido a sua aten√ß√£o fica no "inacabado" por algum tempo e, em seguida, aparece um caso t√£o conveniente. <br><br>  Continuamos a desenvolver uma biblioteca para trabalhar com um dispositivo perif√©rico e somos os pr√≥ximos na fila para gerenciamento de mem√≥ria e buffer (sim, ainda estamos continuando as opera√ß√µes preparat√≥rias, mas sem elas de forma alguma).  De onde vem a necessidade de organiza√ß√£o dos buffers e que tipo de animal √© esse?  O fato √© que uma parte significativa da periferia possui velocidade limitada e o processo de transmiss√£o, iniciado de uma maneira ou de outra, leva um certo tempo, e √†s vezes muito significativo, em compara√ß√£o com a cria√ß√£o de outra por√ß√£o de informa√ß√µes para transmiss√£o.  Obviamente, antes que esse tempo tenha passado, a pr√≥xima transmiss√£o n√£o poder√° ser realizada e, portanto, n√£o poder√° ser iniciada. <br><br>  Temos um caso cl√°ssico de um par escritor-leitor com velocidades diferentes.  √â simplesmente imposs√≠vel resolver esse problema de uma maneira geral, j√° que ‚Äúcom um excesso arbitrariamente pequeno, mas n√£o zero, do fluxo de solicita√ß√µes sobre o fluxo de servi√ßo, o tamanho da fila tende ao infinito‚Äù e o infinito √© fundamentalmente imposs√≠vel.  Mas um caso especial do problema, quando temos explos√µes locais de solicita√ß√µes, mas, em m√©dia, o fluxo de servi√ßo √© capaz de lidar com a carga, uma mem√≥ria buffer de capacidade suficiente pode ser resolvida.  Vamos prestar aten√ß√£o √† frase ‚Äúcapacidade suficiente‚Äù; aprenderemos mais tarde como calcul√°-la, desde que o fato de que isso seja fundamentalmente poss√≠vel seja suficiente para n√≥s. <br><br>  Se a mem√≥ria buffer √© um requisito absoluto, √© claro que n√£o.  Para as informa√ß√µes transmitidas, voc√™ pode usar um registro de bloqueio, mas com as informa√ß√µes recebidas √© um pouco pior, ser√° necess√°rio adicion√°-lo em algum lugar antes do processamento, se voc√™ n√£o tomar as medidas apropriadas no protocolo de n√≠vel superior (a express√£o m√°gica xon / xoff n√£o nasceu do zero), o que nem sempre √© poss√≠vel e, em qualquer caso, geralmente leva a uma limita√ß√£o significativa da taxa de transmiss√£o.  H√° tamb√©m uma implementa√ß√£o de hardware de buffers internos em dispositivos perif√©ricos (pelo menos para um elemento), mas isso nem sempre √© feito e o tamanho do buffer √© estritamente limitado a partir de cima. <br><br>  Portanto, ainda implementaremos o buffer do programa, para o qual seria natural usar o m√©todo FIFO (isto √©, a fila) para organizar esse buffer, e a fila, por sua vez, √© melhor implementada em um buffer circular com dois ponteiros.  Quando escrevo ‚Äúbest‚Äù, isso n√£o significa que outras implementa√ß√µes (por exemplo, uma fila de refer√™ncia) sejam imposs√≠veis ou tenham falhas fatais que n√£o sejam fatais.  Essa express√£o significa apenas que a implementa√ß√£o n√£o ser√° muito complicada e muito eficaz, embora outros possam ter vantagens ineg√°veis ‚Äã‚Äãsobre ela, pelas quais ter√£o que pagar por algo, porque DarZaNeBy. <br><br>  Como √© altamente improv√°vel que o seu modelo MK tenha uma implementa√ß√£o de hardware de um dispositivo de uso geral (m√≥dulos perif√©ricos individuais podem ter seus pr√≥prios buffers de anel, mas eles n√£o t√™m nada a ver com o t√≥pico desta postagem), teremos que criar um buffer de anel na mem√≥ria linear (implemente no vetor, esse √©, em geral, o √∫nico objeto natural na mem√≥ria endere√ß√°vel) e, para isso, ser√° necess√°rio um √≠ndice de buffer (ou talvez at√© dois √≠ndices, mas mais sobre isso posteriormente).  Na minha opini√£o, um buffer circular com dois ponteiros (√≠ndices) √© a √∫nica maneira aceit√°vel de implementar uma fila em um vetor, mas existem pontos de vista diferentes sobre esse problema e vi com meus pr√≥prios olhos uma implementa√ß√£o no estilo ‚Äúx1 = x2;  x2 = x3; ... x8 = novo s√≠mbolo ", se preferir, n√£o considerarei t√£o ex√≥tico.  O fato de que o fragmento dado possa ter o direito de existir em uma situa√ß√£o espec√≠fica e muito limitada n√£o o torna aceit√°vel em geral. <br><br>  Consideraremos a implementa√ß√£o correta do m√≥dulo de programa para organizar o ponteiro e, para come√ßar, preste aten√ß√£o √† primeira palavra na defini√ß√£o.  A diferen√ßa entre um c√≥digo correto e um errado n√£o √© apenas porque o c√≥digo correto n√£o cont√©m erros, embora esse seja um requisito absoluto.  Mesmo o c√≥digo que executa totalmente suas fun√ß√µes pode estar incorreto se for incompreens√≠vel ou se houver uma op√ß√£o que n√£o seja menos clara, mas que seja executada mais rapidamente ou que seja executada com a mesma rapidez, mas com mais clareza, para que o conceito de corre√ß√£o seja um tanto relativo.  Continuamos nossa considera√ß√£o de nosso exemplo de implementa√ß√£o de buffer, o que nos permitir√° demonstrar a diferen√ßa entre diferentes graus de corre√ß√£o. <br><br>  Antes de voltar √† ess√™ncia, um ponto importante sobre a discuss√£o adicional.  Quero dizer que seu compilador est√° sempre ativado em um n√≠vel de otimiza√ß√£o diferente de zero (-O2), portanto, n√£o precisamos pensar em pequenas melhorias, como 1) modifica√ß√£o de prefixo versus postfix, ou 2) usar os resultados da opera√ß√£o anterior ou 3) a diferen√ßa entre incremento e adi√ß√£o unidades e assim por diante - assumimos que o compilador far√° muito por n√≥s.  Obviamente, essa n√£o √© uma suposi√ß√£o estrita, mas, caso contr√°rio, teremos que mergulhar nas entranhas da montadora, que em nosso tempo n√£o √© a corrente principal. <br><br>  Deixe-me lembr√°-lo de que fomos instru√≠dos a implementar o √≠ndice (ponteiro) do buffer de anel, ou seja, precisamos criar o comportamento de uma vari√°vel que <b>executa sequencialmente uma s√©rie de valores, de alguns iniciais a outros finais</b> .  Suponha imediatamente que o valor inicial ser√° zero; caso contr√°rio, teremos que escrever imediatamente um c√≥digo mais ou menos correto, e isso √© contr√°rio aos objetivos educacionais e n√£o temos pressa, e o final √© Max. <br><br>  Esse comportamento da vari√°vel pode ser implementado usando a seguinte constru√ß√£o: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; Counter = (++Counter) % (Max+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  e √© precisamente esse c√≥digo que podemos ver em muitos casos (isto √©, com muita frequ√™ncia).  O que h√° de errado - bem, primeiro, por algum tempo (da execu√ß√£o da opera√ß√£o de incremento √† atribui√ß√£o do resultado), nossa vari√°vel ser√° maior que o valor m√°ximo permitido e, se nesse momento ocorrer uma interrup√ß√£o que precise levar em considera√ß√£o o valor dessa vari√°vel, eu pessoalmente prevejo Eu n√£o presumo os resultados.  Portanto, reescrevemos o programa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter=<span class="hljs-number"><span class="hljs-number">0</span></span>; Counter = (Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) % (Max + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  N√≥s eliminamos um erro, e o c√≥digo (a seguir, quero dizer que o c√≥digo "execut√°vel" significa o c√≥digo execut√°vel gerado pelo compilador) n√£o se tornou mais longo e n√£o √© mais executado (na verdade, √© executado mais rapidamente, mas apenas porque na primeira vers√£o a palavra vol√°til √© usada completamente redundante nesse caso) e n√£o se tornou menos clara (e at√© mais clara, mas √© uma quest√£o de gosto). <br><br>  Nota necess√°ria sobre vol√°til - essa diretiva √© necess√°ria se queremos evitar a otimiza√ß√£o de c√≥digo que leva √† execu√ß√£o incorreta e, neste caso espec√≠fico (quando o valor da vari√°vel n√£o muda fora do escopo do m√≥dulo e n√£o h√° entradas sequenciais), ela (diretiva ) completamente redundante.  Eu recomendo fortemente que voc√™ observe o c√≥digo gerado para as duas op√ß√µes no godbolt.org.  Por que voc√™ n√£o deve abusar da diretiva vol√°til, diferentemente da palavra-chave est√°tica, que √© recomendada para uso sempre que poss√≠vel.  Bem, em primeiro lugar, proibimos a otimiza√ß√£o, ou seja, o c√≥digo definitivamente n√£o se tornar√° mais r√°pido (provavelmente, ele ser√° maior e mais lento, mas preferimos formula√ß√µes estritas).  E segundo, neste caso em particular, essa palavra √© enganosa, pois em rela√ß√£o ao nosso programa o valor do contador n√£o pode mudar de maneira alguma fora do nosso controle.  Em um programa que l√™ seu valor - ou seja, na implementa√ß√£o do pr√≥prio buffer de anel, voc√™ pode considerar o contador mut√°vel fora do m√≥dulo, e √© question√°vel; portanto, esse atributo simplesmente n√£o √© aplic√°vel ao contador.  Se uma vari√°vel deve ser interpretada de maneira diferente em m√≥dulos diferentes, nossos servi√ßos devem ser combinados; se estamos falando de organizar uma se√ß√£o cr√≠tica, por exemplo, ao implementar uma transa√ß√£o ou opera√ß√µes at√¥micas, essa diretiva n√£o fornece nada. <br><br>  Voltamos ao c√≥digo e vemos que o programa ainda est√° errado - qual √© o problema - e o fato √© que ele n√£o faz o que precisamos (veja a descri√ß√£o da tarefa), mas outra coisa (calcula o restante da divis√£o), apenas os resultados combinar.  Bem, achamos que sim (acho que n√£o, mas os autores do c√≥digo certamente), que os resultados coincidem; de fato, no caso geral, eles n√£o coincidem, tivemos sorte com o intervalo da vari√°vel (valores positivos).  Al√©m disso, o processo de execu√ß√£o do c√≥digo √© mais longo do que poderia ser feito, uma vez que, na melhor das hip√≥teses, temos a opera√ß√£o de divis√£o inteira (se faz parte dos comandos de nossa arquitetura) e n√£o √© realizada de forma alguma em um ciclo do processador (um valor caracter√≠stico de 10 ciclos). para arquitetura de 8 bits) e, na pior das hip√≥teses, veremos o procedimento de divis√£o chamado da biblioteca padr√£o (e bem, se divis√£o curta), o tempo de execu√ß√£o ser√° dezenas de ciclos de clock. <br><br>  Ent√£o, por que uma abordagem completamente errada ainda √© poss√≠vel de ser encontrada com muita frequ√™ncia.  Aqui, da plat√©ia, eles me dizem que, com o valor de Max + 1, que √© uma pot√™ncia de dois, o compilador adivinhar√°, em vez da opera√ß√£o de divis√£o, colocar a opera√ß√£o de multiplica√ß√£o bit a bit na m√°scara correspondente (igual a Max), que ser√° executada muito rapidamente e tudo ficar√° bem. <br><br>  Eu concordaria com esta afirma√ß√£o e adotaria essa abordagem, se n√£o pelas seguintes circunst√¢ncias: <br><br><ul><li>  isso s√≥ √© poss√≠vel para Mach definido estaticamente na fase de compila√ß√£o, </li><li>  isso s√≥ acontece quando a otimiza√ß√£o est√° ativada, </li><li>  isso s√≥ acontece quando Mach atende a essa condi√ß√£o, </li><li>  isso n√£o ocorre para todos os tipos de cardeais. </li></ul><br>  Al√©m disso, √© neste caso particular (quando a vari√°vel √© definida como um sinal), al√©m do comando de multiplicar (l√≥gico) pela m√°scara, um comando de compara√ß√£o com zero e um ramo para valores negativos ser√° gerado, e embora esse ramo nunca seja do nosso alcance ser√° executado, ocupar√° espa√ßo na mem√≥ria (e, no caso de uma fun√ß√£o substitu√≠vel, levar√° v√°rias vezes) e levar√° tempo para executar a opera√ß√£o de compara√ß√£o, se voc√™ n√£o acreditar, novamente vamos ao site especificado e veremos por si mesmo.  Outro argumento a favor dos cardeais n√£o assinados, aos quais dediquei recentemente um post inteiro. <br><br>  Portanto, se queremos usar a multiplica√ß√£o l√≥gica com uma m√°scara (obtida otimizando o c√°lculo do restante), devemos reescrever o m√≥dulo de acordo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Counter_t; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> sCounter_t; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> IS_POWER2(Max + 1) return (Counter + 1) &amp; Max #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return (Counter + 1) % (Max + 1); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br>  Nesta vers√£o, tudo √© perfeitamente claro e control√°vel e tudo √© verdade (embora v√°rias defici√™ncias tenham permanecido, mas agora s√£o √≥bvias e n√£o mascaradas), portanto, est√° correto, embora esteja mais correto e agora vamos procur√°-las.  A principal desvantagem, na minha opini√£o, √© uma viola√ß√£o do princ√≠pio KISS, uma vez que o uso da opera√ß√£o restante por divis√£o negligencia completamente esse princ√≠pio.  Portanto, agora destruiremos todas as defici√™ncias de uma s√≥ vez (n√£o se preocupe com o destino delas, elas renascer√£o 100.500 vezes, porque nem todos os programadores do Arduino leem minhas postagens). <br><br>  Mas primeiro, um ligeiro desvio para o lado.  Como podemos implementar uma verifica√ß√£o da pot√™ncia de dois (um n√∫mero bin√°rio pode ser representado como {0} 1 {0}) que acabamos de usar <br><br><div class="spoiler">  <b class="spoiler_title">n√£o espie</b> <div class="spoiler_text">  #define IS_POWER2 (N) (((((N) - 1) &amp; (N)) == 0) <br></div></div><br>  E como podemos implementar a verifica√ß√£o de que um n√∫mero √© uma sequ√™ncia correta de unidades {0} 1 {1} em nota√ß√£o bin√°ria - uma op√ß√£o √© √≥bvia <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) IsPower2 ((N) + 1)</span></span></code> </pre> <br>  e o segundo √© trivial <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) ( (((N) + 1) &amp; (N)) == 0)</span></span></code> </pre> <br>  Nota: n√£o consigo deixar de lembrar o magn√≠fico teorema: "Um n√∫mero transcendental em um grau transcendental √© sempre transcendental, a menos que o inverso seja √≥bvio ou trivial". <br><br>  E como podemos verificar se um n√∫mero √© uma sequ√™ncia de unidades {0} 1 {1} {0} <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsSequence(N) IsPower2( (N) ^ ((N) &lt;&lt; 1))</span></span></code> </pre> <br>  E finalmente - como selecionar o n√∫mero menos significativo (n√£o sei por que isso pode ser necess√°rio, mas ser√° √∫til) <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LowerBit(N) ((((N) - 1) ^ (N)) &amp; (N)).</span></span></code> </pre> <br><br>  Mas ele veio com o que pode ser √∫til <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) (IsSequence(N) &amp;&amp; (LowerBit(N) == 1))</span></span></code> </pre> <br>  Uma observa√ß√£o curiosa - essas macros n√£o s√£o muito corretas; verifica-se que 0 √© uma pot√™ncia de dois e uma sequ√™ncia correta (√© claro, tamb√©m √© uma sequ√™ncia), o que √© um pouco estranho.  Mas 1 √© todos esses objetos com toda a raz√£o; portanto, parece que zero precisa ser considerado separadamente.  Outra propriedade interessante dessas macros √© que n√£o fazemos suposi√ß√µes sobre o tamanho do argumento, ou seja, elas funcionam corretamente com qualquer tipo de cardeal. <br><br>  H√° um livro maravilhoso, "Truques para programadores", onde voc√™ pode encontrar as macros mencionadas e muitas outras tarefas igualmente divertidas e instrutivas, recomendo a leitura, especialmente porque n√£o h√° muitas letras nele. <br><br>  Mas voltando ao nosso √≠ndice de buffer de anel.  Demos a solu√ß√£o certa, mas prometemos ainda mais corretamente, o que significa que nossa √∫ltima solu√ß√£o tem falhas (quem duvidaria).  Um deles - o tamanho do buffer deve ser estaticamente determinado no est√°gio de compila√ß√£o, o segundo - no caso de um comprimento sem √™xito, o tempo de execu√ß√£o √© muito longo e ainda h√° um certo n√∫mero de erros em um peda√ßo relativamente pequeno do programa, o que nos faz lembrar de uma piada sobre 4 erros ao escrever a palavra "mais".  Eliminaremos todos eles (alguns ser√£o deixados para mais tarde) e imediatamente, para os quais, finalmente, escreveremos a solu√ß√£o para o problema original como ele √©: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; Max) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; };</code> </pre> <br>  (Como voc√™ j√° entendeu, sou um defensor dos colchetes eg√≠pcios e n√£o h√° nada a ser feito sobre isso). <br><br>  Vamos prestar aten√ß√£o ao fato de que simplesmente reescrevemos a condi√ß√£o do problema a partir de uma linguagem natural na linguagem de programa√ß√£o escolhida, para que se torne extremamente claro e compreens√≠vel.  √â poss√≠vel melhor√°-lo - sem d√∫vida, mas apenas do ponto de vista da velocidade do c√≥digo, j√° que simplesmente n√£o h√° outras defici√™ncias para esta solu√ß√£o (n√£o existem defici√™ncias √≥bvias, na verdade elas existem e as eliminaremos com √™xito). <br><br>  Vamos avaliar a complexidade computacional dessa solu√ß√£o - adi√ß√£o com unidade (1) e compara√ß√£o (2) sempre, atribuindo zero (1) (raramente) ou adicionando (1) (quase sempre) - o que fornece 1 + 2 + 1 + Œî ~ 4 elementar opera√ß√µes e mem√≥ria zero.  √â poss√≠vel que um bom compilador no modo correto fa√ßa certas otimiza√ß√µes e reduza o tempo de execu√ß√£o do c√≥digo, mas √© melhor faz√™-lo explicitamente.  Aqui est√° a seguinte op√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCouner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> sCounter_t Tmp; Tmp = (Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tmp &gt; Max) { Tmp = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tmp; };</code> </pre> <br>  Avaliamos a complexidade - adi√ß√£o e compara√ß√£o sempre, atribuindo zero (raramente) - aproximadamente 3 opera√ß√µes e um elemento de mem√≥ria.  De fato, a vers√£o anterior tamb√©m tinha um elemento de mem√≥ria (impl√≠cito), portanto, temos um ganho l√≠quido em uma opera√ß√£o elementar.  Al√©m disso, a vers√£o anterior apresentava mais duas desvantagens - 1) violava o princ√≠pio DRY (calculava o aumento em uma vez duas vezes) e 2) apresentava mais de um ponto de sa√≠da, o que n√£o √© bom.  Tamb√©m n√£o perdemos o entendimento, ou seja, conseguimos matar um bando de coelhos com um tiro e tamb√©m n√£o gastamos cartuchos - √© apenas uma hist√≥ria no estilo do Bar√£o Munchausen. <br><br>  Observe que eu n√£o usei a constru√ß√£o <code>if ( (Tmp = Counter + 1) &gt; Max)</code> , embora contenha uma instru√ß√£o expl√≠cita para o compilador para tentar n√£o fazer transfer√™ncias redundantes.  Isso √© saboroso da forma mais flagrante, simplesmente n√£o gosto do valor retornado pelo operador de atribui√ß√£o e tento evitar us√°-lo.  N√£o sei explicar o motivo desse forte sentimento, segundo Freud, que √© provavelmente um trauma psicol√≥gico na inf√¢ncia.  Compiladores modernos s√£o capazes de realizar otimiza√ß√µes simples por conta pr√≥pria e, al√©m disso, tamb√©m adicionei um qualificador de registro, para que o c√≥digo da minha vers√£o e o correto (do ponto de vista da linguagem C) sejam compat√≠veis.  N√£o obstante, n√£o limitei sua liberdade de usar o m√©todo que lhe parece prefer√≠vel. <br><br>  Continuamos a melhorar, porque n√£o h√° limite para a perfei√ß√£o, e ainda n√£o o alcan√ßamos.  Para alcan√ß√°-lo, reformulamos um pouco o problema original e deixamos apenas o requisito da vari√°vel no intervalo de valores, sem indicar a dire√ß√£o da mudan√ßa.  Essa abordagem permite reescrever o programa da seguinte maneira <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCouner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> Counter_t Tmp; Tmp = (Counter - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tmp &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Tmp = ; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tmp; };</code> </pre> <br>  √Ä primeira vista, nada mudou muito, mas, no entanto, obtemos um ganho de tempo.  Obviamente, n√£o devido ao fato de que a opera√ß√£o de diminuir por um funciona mais r√°pido do que a opera√ß√£o de aumentar por ele (embora eu tenha ouvido uma vers√£o semelhante), mas devido √†s peculiaridades da compara√ß√£o.  Se nas vers√µes anteriores eu contei a compara√ß√£o como duas opera√ß√µes elementares (primeiro subtra√≠mos e depois tomamos uma decis√£o), nesse caso o resultado da opera√ß√£o anterior √© usado para tomar uma decis√£o diretamente e a compara√ß√£o leva uma opera√ß√£o elementar, o que leva a duas opera√ß√µes sempre e uma atribui√ß√£o (raramente) e salvamos uma opera√ß√£o (sem perder nada), como diz o ditado, "um pouco, mas legal".  A solu√ß√£o resultante √© ideal - infelizmente n√£o.  √â um pouco inferior √† solu√ß√£o com uma m√°scara (que requer exatamente 2 opera√ß√µes elementares) em termos de velocidade e talvez essa seja sua √∫nica desvantagem. <br><br>  Existe uma solu√ß√£o ainda mais r√°pida - basta aumentar (diminuir) o valor do contador e n√£o fazer mais nada, mas isso s√≥ √© poss√≠vel no √∫nico caso em que o valor m√°ximo coincide com o valor mais representativo no tipo aceito.  Para um contador de 8 bits (ou seja, do tipo uint8_t), ser√° 255, basta escrevermos Counter = Counter + 1 e acreditarmos que escrever Counter + = 1 ou ++ Counter √© completamente opcional, embora muitos sejam e eles escrever√£o e estar√£o absolutamente certos.  Se n√£o considerarmos seriamente a vers√£o sobre a necessidade de salvar caracteres (j√° que a primeira op√ß√£o √© a mais longa), isso n√£o faz sentido, pelo menos se estivermos escrevendo um programa para a arquitetura ARM ou AVR (para outras que eu n√£o verifiquei, suspeito que o resultado ser√° o mesmo) no compilador GCC (o autor entende que est√° escrevendo um programa no editor do ambiente de programa√ß√£o integrado, isso √© apenas uma revolu√ß√£o de fala do passado quando os computadores eram grandes e a mem√≥ria pequena) e com a otimiza√ß√£o ativada em qualquer n√≠vel, porque  o c√≥digo fornecido ser√° absolutamente id√™ntico. <br><br>  Os compiladores modernos s√£o muito, muito avan√ßados em termos de otimiza√ß√£o e geram um c√≥digo realmente muito bom, √© claro, se voc√™ tiver ativado o modo correspondente.  Embora eu esteja pronto para concordar que essas constru√ß√µes de linguagem n√£o causam danos e podem ser √∫teis sob certas condi√ß√µes, a √∫nica coisa que observo √© que as express√µes do Counter ++ (nesse caso em particular, √© claro) devem ser evitadas sem ambiguidade, pois s√£o destinadas a situa√ß√µes completamente diferentes e podem dar origem a c√≥digo mais lento, embora opcional. <br><br>  Outra quest√£o √© que um buffer de 256 elementos nem sempre √© aceit√°vel, mas se voc√™ tiver mem√≥ria suficiente, por que n√£o?  Com esta implementa√ß√£o, se voc√™ pode alinhar o buffer com a borda da p√°gina, o acesso aos elementos pode ser feito muito rapidamente, eliminando a opera√ß√£o de passar de √≠ndice para √≠ndice (a palavra-chave union informar√° a implementa√ß√£o de um recurso desse tipo, n√£o o trarei para n√£o aprender ruim), mas essa j√° √© uma decis√£o muito, muito espec√≠fica, com forte apego √† arquitetura, que √© perigosamente pr√≥ximo de truques no pior sentido da palavra, e esse n√£o √© o nosso estilo. <br><br>  Obviamente, ningu√©m nos pro√≠be escrever um inv√≥lucro que chamar√° este ou aquele m√©todo, dependendo do valor dos valores m√°ximos (e m√≠nimos, j√° que muitos m√©todos simplesmente n√£o funcionam com valores m√≠nimos diferentes de zero), eu j√° propus os princ√≠pios b√°sicos de uma solu√ß√£o, portanto vamos oferecer isso como um exerc√≠cio. <br><br>  Bem, em conclus√£o, para resumir - reuniremos diferentes implementa√ß√µes de trabalho com um √≠ndice de anel e avaliaremos suas propriedades. <br><div class="scrollable-table"><table><tbody><tr><th>  M√©todo </th><th>  Versatilidade </th><th>  Prazo de execu√ß√£o </th></tr><tr><td>  ¬± </td><td>  0 (1) </td><td>  1 </td></tr><tr><td>  ¬±% </td><td>  1 (7) </td><td>  2 </td></tr><tr><td>  + se </td><td>  3 (qualquer) </td><td>  3.x </td></tr><tr><td>  - se </td><td>  3 (qualquer) </td><td>  2.x </td></tr></tbody></table></div><br>  A segunda linha entre par√™nteses mostra o n√∫mero de valores de tamanho do buffer (n√£o excedendo 256) para os quais essa implementa√ß√£o est√° dispon√≠vel, mas queremos dizer que um buffer de tamanho 0 n√£o nos interessa. <br><br>  Como voc√™ pode ver nesta tabela, DarZaNeBy (minha express√£o favorita, como voc√™ deve ter notado) e vantagens s√£o compradas √† custa de desvantagens, a √∫nica coisa que pode ser declarada inequivocamente √© que o incremento na verifica√ß√£o tem um concorrente mais bem-sucedido na forma de decr√©scimo na verifica√ß√£o e n√£o passa para a pr√≥xima rodada sob nenhuma circunst√¢ncia. <br><br>  Uma observa√ß√£o necess√°ria - existem linguagens de programa√ß√£o nas quais n√£o ter√≠amos que pensar na implementa√ß√£o do √≠ndice, mas simplesmente poder√≠amos usar o tipo de intervalo.  Infelizmente, n√£o posso chamar a implementa√ß√£o dessas constru√ß√µes no c√≥digo como ideal, pois essas constru√ß√µes (e essas linguagens) n√£o se destinam √† otimiza√ß√£o em tempo de execu√ß√£o, mas √© uma pena. <br><br>  Ent√£o, criamos o m√≥dulo certo (que nome forte para a fun√ß√£o embutida) funcionava com o √≠ndice e agora estamos prontos para come√ßar a implementar o pr√≥prio buffer de anel. <br><br>  E para iniciantes, devemos decidir o que exatamente queremos desse objeto de programa.  √â absolutamente necess√°rio poder colocar um elemento de dados em um buffer e extra√≠-lo - dois m√©todos principais, um tipo de getter e setter.  √â teoricamente poss√≠vel imaginar um buffer sem um desses m√©todos, ou mesmo sem os dois (pouco se pode imaginar puramente teoricamente), mas o valor pr√°tico dessa implementa√ß√£o √© uma grande quest√£o.  A pr√≥xima funcionalidade necess√°ria - verifica√ß√£o de informa√ß√µes - pode ser implementada como um m√©todo separado ou como um valor (ou atributo) especial retornado pela leitura.  Geralmente eles preferem o primeiro m√©todo, pois √© mais compreens√≠vel e n√£o muito caro. <br>  Mas verificar a integridade do buffer j√° √© uma grande quest√£o - essa opera√ß√£o exigir√° tempo adicional, que sempre ser√° gasto na grava√ß√£o, embora ningu√©m nos obriga a us√°-lo - que assim seja.  N√£o precisamos de mais nada do buffer, vamos lembrar esta frase para o futuro. <br><br>  Voltar para a implementa√ß√£o.  Precisamos de um local para armazenar os elementos da fila e dois √≠ndices - um para gravar no buffer e outro para ler a partir dele.  Como exatamente conseguiremos esse lugar (e esses indicadores) √© um t√≥pico para uma discuss√£o separada, por enquanto, vamos deixar esse momento entre par√™nteses e acreditar que simplesmente os temos.  Alguns (incluindo os autores do livro "Programa√ß√£o para matem√°ticos", que eu respeito, recomendo a leitura) tamb√©m usam o contador de locais preenchidos, mas n√£o faremos isso e tentarei mostrar por que isso √© ruim. <br><br>  Primeiro, sobre os √≠ndices - notamos imediatamente que esses s√£o √≠ndices, n√£o indicadores, embora √†s vezes eu me permitisse ser assim.    (     ),    (       )-   ,  ,   ,      .       (  256    ),     ,       ,       (         ,     8     , ,     4-  ),  ,       ,     ( ,      ). <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"> ,       51 (   )    2 (    )   3  ( ),   ,             ,      . ,   ,  GCC     x51,       AVR  . <br></div></div><br>  ,  ,          .     ,       ( ,      ,   ),    ‚Äî . <br><br>        ‚Äî           (   ),        .      : 1)   ,       2)   ,     .          ,   ,  ,        .     ,     ,      .     (  )  ,     ‚Äî   .     ‚Äî        ,             . <br><br>     (¬´,      ¬ª)             ,      .       ‚Äî  1)    , 2)       ( ,  ) 3)        ,     , 4)       256            , 5)     ( ),    .    ,     ,   ,   ,     . <br><br>       ,        (,      , ),             1  .   : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NeedOverflowControl YES typedef uint8_t Data_t; static Data_t BufferData[Max]; static Counter_t BufferWriteCounter=0, BufferReadCounter=BufferWriteCounter; void BufferWrite(const data_t Data) { BufferData[BuffWriteCounter] = Data; register counter_t Tmp = NextCount(BufferWriteCounter); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (NeedOverflowControl == YES) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Tmp == BufferReadCounter) {BufferOverflow();} </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> { BufferWriteCounter = Tmp; } };</span></span></code> </pre> <br>      ,      , ‚Ä¶   ,  : <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( BufferReadCounter == BufferWriteCounter ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsFull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( BufferReadCounter == NextCounter(BufferWriteCounter) ); }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DataSizeIsSmaller (sizeof(data_t) &lt; sizeof(counter_t)) data_t BufferRead(void) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DataSizeIsSmaller register data_t Tmp = BufferData[BufferReadCounter]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> register counter_t Tmp = BufferReadCounter; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> BufferReadCounter = NextCount(BufferReadCounter); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DataSizeIsSmaller return Tmp; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return BufferData[Tmp]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br>    ,        (     ) ‚Äî        ,        , ,      ‚Äî    ,         .  ,        ,        ,         . <br><br> ,     ,     ‚Äî  ,         ,         ,       . <br><br>  , (  )   <br><br> 1)            (    ‚Äî     ,        ,      ‚Äî      ,  ,        ). <br>   (,  ,    )  <br><br> 2)            ‚Äî    ,     . <br><br>         : <br><br> 3)  4)      ,    (¬´  ¬ª).    ‚Äî      ,   ,      (  N   N+1 )       ,    ?    <br><br> 3)     ,   <br><br> 4)       . <br><br>      ‚Äî ¬´ ¬ª,     -      ,     ‚Äî    .      3,     (      ),       ,    . <br><br>      ‚Äî    , (      ,      ),    <br><br> 5)      ‚Äî       ,    ,       ,      ,       ‚Äî   ,     . <br><br>   ‚Äî             ,      ,     . <br><br>    ,  ,     ,    , ,   , ,    , ,   ,      ,     .        ,      4       ,    ,  .        MRSW (Multi-Reader Single-Writer)   ¬´The Art of Mulpiprocessor Programming¬ª (   ,   )        (  )      .      ‚Äî           ,               ,   . <br><br>       MRMW        ,   ¬´¬ª (, ,      ¬´ ¬ª ).     ,         , ,       ,      .  , ,     ,           (,   ,      ‚Äî    ,     ,   ,  ),     . <br><br>  ,    (   )      ,       .     ,     ,         ,     ,  ,         ,      ,        . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span> BufferData[Max]; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">counter_t</span></span> BufferWriteCounter=<span class="hljs-number"><span class="hljs-number">0</span></span>, BufferReadCounter=WriteCounter; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> BufferHaveData = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((BufferWriteCounter == BufferReadCounter) &amp;&amp; (BufferHaveDataFlag == <span class="hljs-number"><span class="hljs-number">1</span></span>)) {BufferOverflow();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { BufferData[BufferWriteCounter] = Data; BufferHaveDataFlag = <span class="hljs-number"><span class="hljs-number">1</span></span>; BufferWriteCounter = NextCounter(BufferWriteCounter); }; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((BufferReadCounter==BufferWriteCounter) &amp;&amp; (BufferHaveDataFlag == <span class="hljs-number"><span class="hljs-number">0</span></span>));}; <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span> BufferRead(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">counter_t</span></span> Tmp; Tmp = BufferReadCounter; BufferReadCounter = NextCount(BufferReadCounter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BufferReadCount == BufferWriteCounter) { BufferHaveDataFlag = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BufferData[Tmp]; };</code> </pre> <br>   ,        ,    ,       ,    ,                   . <br><br>  ,         (    0  1,   ,     ,   ),      ,    ,      ,  ,  ,         (  ),  ,      , <br><br><div class="spoiler"> <b class="spoiler_title"> - </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> (NoBufferHaveData= <span class="hljs-number"><span class="hljs-number">0</span></span>, BufferHaveData =<span class="hljs-number"><span class="hljs-number">1</span></span>) BufferHave DataFlag_t; BufferHaveData_t BufferYaveDataFlag; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{BufferHaveDataFlag = NoBufferHaveData;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagClr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{BufferHaveDataFlag = BufferHaveData;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagIsSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(BufferHaveDataFlag == BufferHaveData);};</code> </pre> <br></div></div><br>  ,        ,      0  1,             . ,     ,        ,        0  1.   , ,    ,      ,    BufferFullFlag      ,          BufferIsNotEmptyFlag         .   ,  KISS      ,   ,   ,        ,    , ¬´   ¬ª. <br><br>   ,       ,                    . <br><br>          ,         ,      . <br><br> PS    ,        ,                 : <br><br><ol><li>     ‚Äî      (,  ,     ),  ‚Äî   ,     , ,   ,  . </li><li>               . </li><li>      . </li><li>    2    . </li><li>       </li><li>     ,     (  )   ,       ,       . </li><li>    ,   <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((_writeCount - Atomic::Fetch(&amp;_readCount)) &amp; (size_type)~(_mask)) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>     ‚Äî    ,    ,     ,         <br><br><pre> <code class="cpp hljs">size_type(~(_mask))</code> </pre> <br>     . </li></ol><br> PPS ,           . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438476/">https://habr.com/ru/post/pt438476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438466/index.html">Muleta para um laser chin√™s</a></li>
<li><a href="../pt438468/index.html">Col√¥nia. Cap√≠tulo 23: Test Drive</a></li>
<li><a href="../pt438470/index.html">Vendas mundiais em dezembro e 2018: 2 milh√µes de ve√≠culos el√©tricos plug-in vendidos</a></li>
<li><a href="../pt438472/index.html">Ambiente arquitet√¥nico modular sofisticado no UE4</a></li>
<li><a href="../pt438474/index.html">Correio: migra√ß√£o do Dropbox para o gRPC</a></li>
<li><a href="../pt438478/index.html">GitLab 11.7 lan√ßado com lan√ßamentos, √©picos aninhados em v√°rios n√≠veis e o registro de pacotes NPM</a></li>
<li><a href="../pt438480/index.html">Coloque da maneira certa: 7 lugares ideais para colocar conte√∫do de v√≠deo</a></li>
<li><a href="../pt438482/index.html">Reputa√ß√£o, trabalho e emigra√ß√£o: como usar as ferramentas de promo√ß√£o da empresa para resolver problemas pessoais</a></li>
<li><a href="../pt438486/index.html">Cart√£o de mem√≥ria impenetr√°vel - afogue, congele e atire na Kingston microSD High Endurance</a></li>
<li><a href="../pt438490/index.html">Vers√£o beta do Unity 2019.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>