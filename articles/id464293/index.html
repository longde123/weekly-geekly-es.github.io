<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜½ ğŸ‘©ğŸ¾â€ğŸ¨ ğŸ˜ï¸ Apakah kait diganti dalam React Redux? ğŸ‘¨â€âš–ï¸ ğŸˆ¹ ğŸ‘ˆğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejak kait muncul di Bereaksi, ada banyak pertanyaan tentang apakah mereka dapat menggantikan Redux. 

 Saya percaya bahwa kait dan Redux memiliki sed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apakah kait diganti dalam React Redux?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/464293/">  Sejak kait muncul di Bereaksi, ada banyak pertanyaan tentang apakah mereka dapat menggantikan Redux. <br><br>  Saya percaya bahwa kait dan Redux memiliki sedikit kesamaan.  Hooks tidak memberi kita beberapa peluang luar biasa baru untuk bekerja dengan negara.  Sebagai gantinya, mereka memperluas API sehingga mereka dapat melakukan dalam Bereaksi apa yang sudah mungkin ada di dalamnya.  Namun, hook API telah membuat bekerja dengan kapabilitas manajemen negara React jauh lebih nyaman.  Ternyata lebih mudah untuk menggunakan kemampuan baru untuk bekerja dengan negara daripada yang lama yang tersedia dalam komponen berdasarkan kelas.  Sekarang saya menggunakan alat untuk bekerja dengan keadaan komponen lebih sering daripada sebelumnya.  Secara alami, saya melakukan ini hanya jika sesuai. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/3l/la/tr/3llatro-chokmu9rdtwtga0l1sc.jpeg"></a> <br><br>  Untuk menjelaskan sikap saya terhadap React hooks dan Redux, saya ingin berbicara tentang situasi di mana Redux biasanya digunakan. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Apa itu Redux?</font> </h2><br>  Redux adalah perpustakaan yang mengimplementasikan penyimpanan keadaan aplikasi yang dapat diprediksi.  Ini juga merupakan arsitektur yang diintegrasikan dengan React. <br><br>  Berikut adalah kekuatan utama Redux: <br><br><ul><li>  Representasi negara deterministik (dalam kombinasi dengan komponen murni, ini memungkinkan untuk membentuk elemen visual deterministik). </li><li>  Dukungan untuk perubahan status transaksional. </li><li>  Isolasi manajemen negara dari mekanisme I / O dan efek samping. </li><li>  Kehadiran satu sumber data andal untuk negara. </li><li>  Organisasi mudah berkolaborasi dengan negara dalam berbagai komponen. </li><li>  Alat analisis transaksional (pencatatan otomatis objek aksi). </li><li>  Debugging dengan kemampuan untuk merekam dan memainkan proses pelaksanaan program (Time Travel Debugging, TTD). </li></ul><br>  Dengan kata lain, Redux memungkinkan Anda untuk mengatur kode Anda dengan baik dan memungkinkan Anda untuk debug itu dengan mudah.  Redux membantu mengembangkan aplikasi yang mudah dirawat.  Menggunakan perpustakaan ini memudahkan untuk menemukan sumber masalah yang muncul dalam program. <br><br><h2>  <font color="#3AC1EF">Apa itu React hooks?</font> </h2><br>  React hooks memungkinkan, ketika bekerja dengan komponen fungsional, untuk menggunakan analog dari keadaan komponen berdasarkan kelas dan analog dari metode siklus hidup mereka.  Kait muncul di Bereaksi 16.8. <br><br>  Di antara kekuatan utama kait adalah sebagai berikut: <br><br><ul><li>  Kemampuan untuk menggunakan keadaan dan menangani peristiwa siklus hidup komponen tanpa menggunakan komponen berbasis kelas. </li><li>  Penyimpanan gabungan dari logika terkait di lokasi komponen yang sama dan bukannya pemisahan logika yang sama antara beberapa metode siklus hidup. </li><li>  Mekanisme berbagi terlepas dari implementasi komponen (ini mirip dengan templat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prop render</a> ). </li></ul><br>  Perhatikan bahwa fitur-fitur hebat ini, pada kenyataannya, tidak melebihi Redux.  React hooks dapat dan harus digunakan untuk melakukan pembaruan keadaan deterministik, tetapi ini selalu menjadi salah satu fitur Bereaksi, dan model keadaan deterministik Redux bergabung dengan baik dengan fitur ini.  Inilah cara React mencapai determinisme dalam output elemen visual, dan inilah, tanpa berlebihan, salah satu motif penggerak untuk menciptakan React. <br><br>  Jika Anda menggunakan alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API reaksi-redux dengan kait</a> , atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kait</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React useReducer</a> , Anda akan menemukan bahwa tidak ada alasan untuk bertanya apa yang harus dipilih - kait atau Redux.  Anda dapat menggunakan keduanya, menggabungkan dan menggabungkan teknologi ini. <br><br><h2>  <font color="#3AC1EF">Apa yang menggantikan kait?</font> </h2><br>  Setelah API hook muncul, saya berhenti menggunakan teknologi berikut: <br><br><ul><li>  Komponen berbasis kelas. </li><li>  Pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">render-prop</a> . </li></ul><br><h2>  <font color="#3AC1EF">Apa yang tidak menggantikan kait?</font> </h2><br>  Saya masih sering menggunakan teknologi berikut: <br><br><ul><li>  Redux - untuk semua alasan di atas. </li><li>  Komponen dengan urutan lebih tinggi - untuk tujuan melakukan komposisi komponen jika saya harus menerapkan fungsionalitas ujung ke ujung yang dibagikan oleh semua atau beberapa komponen visual aplikasi.  Fungsionalitas tersebut termasuk penyedia Redux, sistem tata letak halaman, sistem pendukung pengaturan aplikasi, alat otentikasi dan otorisasi, alat internasionalisasi aplikasi, dan sebagainya. </li><li>  Pemisahan antara komponen wadah dan komponen yang memiliki representasi visual.  Ini memungkinkan Anda untuk meningkatkan modularitas dan testabilitas aplikasi, lebih baik memisahkan efek dan logika murni. </li></ul><br><h2>  <font color="#3AC1EF">Kapan harus menggunakan kait?</font> </h2><br>  Tidak perlu berusaha untuk menggunakan Redux di setiap aplikasi dan di setiap komponen.  Jika proyek Anda terdiri dari satu komponen visual, jika tidak menyimpan data dan tidak memuat data dari sana, jika operasi I / O asinkron tidak dilakukan di dalamnya, maka saya tidak dapat menemukan alasan yang layak untuk mempersulit proyek ini dengan menggunakan Redux di dalamnya. <br><br>  Hal yang sama dapat dikatakan tentang komponen yang memiliki fitur berikut: <br><br><ul><li>  Mereka tidak menggunakan sumber daya jaringan. </li><li>  Mereka tidak menyimpan data dalam keadaan dan tidak memuatnya dari sana. </li><li>  Mereka tidak berbagi negara dengan komponen lain yang bukan keturunan mereka. </li><li>  Mereka tidak memiliki keadaan tertentu sendiri, digunakan untuk penyimpanan data jangka pendek. </li></ul><br>  Anda mungkin memiliki alasan kuat untuk menggunakan model status komponen Bereaksi standar dalam situasi tertentu.  Dalam situasi seperti ini, Bereaksi kait akan melakukan pekerjaan Anda dengan baik.  Misalnya, formulir yang dijelaskan di bawah ini menggunakan status lokal komponen menggunakan hook React <code>useState</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'prop-types'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextField, { Input } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@material/react-text-field'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> noop = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Holder = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{  itemPrice = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">175</span></span></span></span><span class="hljs-function"><span class="hljs-params">,  name = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">,  email = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">,  id = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">,  removeHolder = noop,  showRemoveButton = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">, }</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [nameInput, setName] = useState(name);  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [emailInput, setEmail] = useState(email); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> setter = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">set</span></span></span><span class="hljs-function"> =&gt;</span></span> e =&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { target } = e;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { value } = target;    set(value);  }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (    &lt;div className="row"&gt;      &lt;div className="holder"&gt;        &lt;div className="holder-name"&gt;          &lt;TextField label="Name"&gt;            &lt;Input value={nameInput} onChange={setter(setName)} required /&gt;          &lt;/TextField&gt;        &lt;/div&gt;        &lt;div className="holder-email"&gt;          &lt;TextField label="Email"&gt;            &lt;Input              value={emailInput}              onChange={setter(setEmail)}              type="email"              required            /&gt;          &lt;/TextField&gt;        &lt;/div&gt;        {showRemoveButton &amp;&amp; (          &lt;button            className="remove-holder"            aria-label="Remove membership"            onClick={e =&gt; {              e.preventDefault();              removeHolder(id);            }}          &gt;            Ã—          &lt;/button&gt;        )}      &lt;/div&gt;      &lt;div className="line-item-price"&gt;${itemPrice}&lt;/div&gt;      &lt;style jsx&gt;{cssHere}&lt;/style&gt;    &lt;/div&gt;  ); }; Holder.propTypes = {  name: t.string,  email: t.string,  itemPrice: t.number,  id: t.string,  removeHolder: t.func,  showRemoveButton: t.bool, }; export default Holder;</code> </pre> <br>  Di sini <code>useState</code> digunakan untuk mengontrol keadaan singkat yang digunakan dari bidang input <code>name</code> dan <code>email</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [nameInput, setName] = useState(name); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [emailInput, setEmail] = useState(email);</code> </pre> <br>  Anda mungkin memperhatikan bahwa masih ada pembuat tindakan <code>removeHolder</code> masuk ke properti dari Redux.  Seperti yang telah disebutkan, kombinasi dan kombinasi teknologi sepenuhnya normal. <br><br>  Menggunakan status komponen lokal untuk menyelesaikan masalah seperti itu selalu tampak bagus, tetapi sebelum React hooks, saya ingin menyimpan data komponen dalam penyimpanan Redux dan mendapatkan status dari properti. <br><br>  Sebelumnya, bekerja dengan keadaan komponen yang terlibat menggunakan komponen berbasis kelas, menulis data awal ke negara menggunakan mekanisme untuk mendeklarasikan properti kelas (atau dalam konstruktor kelas), dan sebagainya.  Akibatnya, ternyata untuk menghindari penggunaan Redux, komponen harus terlalu rumit.  Redux juga berbicara mendukung keberadaan alat yang mudah digunakan untuk mengelola keadaan formulir menggunakan Redux.  Akibatnya, sebelumnya, saya tidak akan khawatir bahwa keadaan sementara formulir disimpan di tempat yang sama dengan data dengan masa pakai yang lebih lama. <br><br>  Karena saya sudah menggunakan Redux dalam semua aplikasi saya yang kurang lebih kompleks, pilihan teknologi untuk menyimpan keadaan komponen komponen tidak membuat saya banyak berpikir.  Saya baru saja menggunakan Redux di hampir semua kasus. <br><br>  Dalam kondisi modern, membuat pilihan juga mudah: bekerja dengan keadaan komponen diatur menggunakan mekanisme Bereaksi standar, dan mengelola keadaan aplikasi menggunakan Redux. <br><br><h2>  <font color="#3AC1EF">Kapan harus menggunakan Redux?</font> </h2><br>  Pertanyaan umum lain mengenai manajemen negara adalah: â€œApakah saya harus meletakkan semuanya dalam repositori Redux?  Jika saya tidak melakukannya, apakah itu akan melanggar kemampuan untuk men-debug aplikasi menggunakan mekanisme TTD? " <br><br>  Tidak perlu untuk meng-host semuanya di repositori Redux.  Faktanya adalah bahwa aplikasi menggunakan banyak data sementara yang terlalu tersebar di sekitarnya untuk memberikan beberapa informasi yang, direkam dalam log atau digunakan selama debugging, dapat memberikan pengembang bantuan yang signifikan dalam menemukan masalah.  Mungkin Anda, kecuali jika Anda menulis aplikasi editor real-time, Anda tidak perlu menulis ke negara setiap gerakan mouse atau setiap keystroke.  Ketika Anda meletakkan sesuatu dalam status Redux, Anda menambahkan tingkat abstraksi tambahan ke aplikasi, serta tingkat kerumitan tambahan yang menyertainya. <br><br>  Dengan kata lain, Anda dapat menggunakan Redux dengan aman, tetapi harus ada alasan untuk ini.  Penggunaan fitur Redux dalam komponen dapat dibenarkan jika komponennya berbeda dalam fitur berikut: <br><br><ul><li>  Mereka menggunakan I / O.  Misalnya, mereka bekerja dengan jaringan atau dengan perangkat tertentu. </li><li>  Mereka menyimpan data ke atau memuat data dari itu. </li><li>  Mereka bekerja dengan negara mereka dalam hubungannya dengan komponen-komponen yang bukan keturunan mereka. </li><li>  Mereka berurusan dengan logika bisnis yang digunakan bagian lain dari aplikasi, - mereka memproses data yang digunakan di bagian lain aplikasi. </li></ul><br>  Berikut adalah contoh lain yang diambil dari aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TDDDay</a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { useDispatch, useSelector } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { compose } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ramda'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> page <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../hocs/page.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Purchase <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./purchase-component.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { addHolder, removeHolder, getHolders } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./purchase-reducer.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PurchasePage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {  <span class="hljs-comment"><span class="hljs-comment">//      // mapStateToProps  mapDispatchToProps  const dispatch = useDispatch();  const holders = useSelector(getHolders); const props = {    //           //    dispatch.    addHolder: compose(      dispatch,      addHolder    ),    removeHolder: compose(      dispatch,      removeHolder    ),    holders,  }; return &lt;Purchase {...props} /&gt;; }; // `page` -    ,    //        . export default page(PurchasePage);</span></span></code> </pre> <br>  Dokumen ini tidak berurusan dengan DOM.  Ini adalah komponen presentasi.  Terhubung ke Redux menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API reaksi-redux dengan dukungan hook</a> . <br><br>  Redux digunakan di sini karena kami membutuhkan data yang ditangani oleh formulir ini untuk digunakan di bagian lain dari antarmuka pengguna.  Dan setelah operasi pembelian selesai, kita perlu menyimpan informasi yang relevan dalam database. <br><br>  Fragmen status yang digunakan oleh kode ini digunakan oleh berbagai komponen, tidak diproses hanya oleh satu komponen.  Ini bukan data, hanya ada waktu singkat.  Data ini dapat dianggap permanen, dapat digunakan pada berbagai layar aplikasi dan dalam beberapa sesi.  Semua ini adalah skenario di mana keadaan komponen untuk menyimpan data tidak dapat diterapkan.  Benar, ini masih mungkin, tetapi hanya jika pembuat aplikasi menulis, berdasarkan React API, perpustakaannya sendiri untuk mengelola keadaan.  Ini jauh lebih sulit dilakukan daripada hanya menggunakan Redux. <br><br>  React <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Suspense</a> API, di masa depan, mungkin berguna ketika menyimpan data dalam keadaan dan memuatnya.  Kita perlu menunggu rilisnya dan melihat apakah ia dapat mengganti templat untuk menyimpan dan memuat data Redux.  Redux memungkinkan kita untuk dengan jelas memisahkan efek samping dari sisa komponen logika, sementara kita tidak perlu bekerja dengan layanan I / O dengan cara khusus.  (Alasan saya lebih suka pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">redux-saga</a> ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">middleware redux-thunk</a> adalah efek isolasi).  Untuk bersaing dengan Redux dalam skenario ini, React API perlu memberikan efek isolasi. <br><br><h2>  <font color="#3AC1EF">Redux adalah arsitektur</font> </h2><br>  Redux jauh lebih (dan sering jauh lebih sedikit) daripada perpustakaan manajemen negara.  Ini juga merupakan bagian dari arsitektur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flux</a> , yang jauh lebih ketat mendefinisikan bagaimana perubahan negara diimplementasikan.  Baca lebih lanjut tentang arsitektur Redux di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Saya sering menggunakan reduksi yang dibuat dalam gaya Redux dalam kasus-kasus ketika saya perlu mempertahankan keadaan kompleks komponen, tetapi tidak perlu menggunakan perpustakaan Redux.  Selain itu, saya menggunakan tindakan yang dibuat dalam semangat Redux (dan bahkan alat Redux seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Autodux</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">redux</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-saga</a> ) untuk mengirim tindakan dalam aplikasi Node.js.  Namun, saya bahkan tidak mengimpor Redux ke aplikasi semacam itu. <br><br>  Proyek Redux selalu lebih merupakan arsitektur dan seperangkat perjanjian sukarela daripada perpustakaan.  Bahkan, implementasi dasar Redux dapat ditata secara harfiah dalam beberapa lusin baris kode. <br><br>  Ini akan menjadi berita baik bagi mereka yang ingin menggunakan komponen lokal dengan kait lebih sering dan tidak mengikat semuanya ke Redux. <br><br>  Bereaksi mendukung hook <code>useReducer</code> , yang dapat bekerja dengan reduksi gaya Redux.  Ini bagus untuk mengimplementasikan logika non-sepele bekerja dengan negara, untuk bekerja dengan fragmen negara yang tergantung, dan sebagainya.  Jika Anda menemukan masalah yang cocok untuk kondisi sementara komponen individual, maka Anda dapat menggunakan arsitektur Redux untuk bekerja dengan kondisi ini, tetapi alih-alih menggunakan pustaka Redux, Anda bisa menggunakan hook <code>useReducer</code> untuk mengelola keadaan. <br><br>  Jika nanti Anda perlu membuat penyimpanan data permanen yang sebelumnya hanya sementara disimpan, maka Anda akan siap 90% untuk perubahan seperti itu.  Yang harus Anda lakukan adalah menghubungkan komponen ke repositori Redux dan menambahkan peredam yang sesuai di sana. <br><br><h2>  <font color="#3AC1EF">Tanya Jawab</font> </h2><br><h3>  <font color="#3AC1EF"> Apakah determinisme rusak jika Redux tidak mengelola semua data aplikasi?</font> </h3><br>  Tidak, tidak rusak.  Bahkan, menggunakan Redux tidak membuat proyek menjadi deterministik.  Tetapi perjanjian itu.  Jika Anda ingin kondisi Redux Anda menjadi deterministik, gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi murni</a> .  Hal yang sama berlaku untuk situasi di mana perlu bahwa keadaan sementara komponen lokal harus ditentukan. <br><br><h3>  <font color="#3AC1EF">â– Haruskah pustaka Redux memainkan peran sebagai sumber tunggal data yang andal?</font> </h3><br>  Prinsip satu sumber data yang dapat diandalkan tidak menunjukkan bahwa semua data yang termasuk dalam status aplikasi perlu disimpan di satu tempat.  Arti dari prinsip ini adalah bahwa setiap fragmen negara seharusnya hanya memiliki satu sumber data yang dapat diandalkan.  Akibatnya, kita dapat memiliki banyak fragmen negara, yang masing-masing memiliki sumber data andal sendiri. <br><br>  Ini berarti bahwa pemrogram dapat memutuskan apa yang ditransfer ke Redux dan apa yang ditransfer ke keadaan komponen.  Data penentuan negara juga dapat diambil dari sumber lain.  Misalnya, dari API peramban yang memungkinkan Anda bekerja dengan informasi tentang alamat halaman yang Anda lihat. <br><br>  Redux adalah alat yang hebat untuk mendukung satu sumber data yang dapat diandalkan untuk keadaan aplikasi.  Tetapi jika keadaan komponen terletak dan digunakan secara eksklusif dalam komponen ini, maka, menurut definisi, keadaan ini sudah memiliki satu sumber data yang dapat diandalkan - keadaan komponen Bereaksi. <br><br>  Jika Anda memasukkan beberapa data dalam kondisi Redux, Anda harus selalu membaca data ini dari kondisi Redux.  Untuk semua yang ada di repositori Redux, repositori ini harus menjadi satu-satunya sumber data yang dapat diandalkan. <br><br>  Menempatkan semuanya dalam kondisi Redux, jika perlu, adalah hal yang normal.  Mungkin ini akan mempengaruhi kinerja jika Anda menggunakan fragmen status yang perlu sering diperbarui, atau jika Anda berbicara tentang menyimpan status komponen di mana fragmen keadaan dependen banyak digunakan.  Anda tidak perlu khawatir tentang kinerja sampai ada masalah dengan kinerja.  Tetapi jika Anda khawatir tentang masalah kinerja, cobalah kedua cara bekerja dengan negara dan mengevaluasi dampaknya terhadap kinerja.  Profil proyek Anda dan ingat model kinerja RAIL. <br><br><h3>  <font color="#3AC1EF">â– Apakah saya perlu menggunakan fungsi koneksi dari react-redux, atau lebih baik menggunakan kait?</font> </h3><br>  Itu tergantung banyak.  Fungsi <code>connect</code> membuat komponen tingkat tinggi yang cocok untuk penggunaan berulang, dan kait dioptimalkan untuk integrasi dengan satu komponen. <br><br>  Apakah saya perlu menghubungkan properti yang sama ke komponen yang berbeda?  Jika demikian, gunakan <code>connect</code> .  Kalau tidak, saya lebih suka memilih kait.  Misalnya, bayangkan Anda memiliki komponen yang bertanggung jawab untuk mengotorisasi izin untuk tindakan pengguna: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { connect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RequiresPermission <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./requires-permission-component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { userHasPermission } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../features/user-profile/user-profile-reducer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> curry <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash/fp/curry'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> requiresPermission = curry(  <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NotPermittedComponent, { permission }, PermittedComponent</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> ({      NotPermittedComponent,      PermittedComponent,      <span class="hljs-attr"><span class="hljs-attr">isPermitted</span></span>: userHasPermission(state, permission),    });    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connect(mapStateToProps)(RequiresPermission);  }, ); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> requiresPermission;</code> </pre> <br>  Sekarang, jika seorang administrator bekerja secara intensif dengan aplikasi, semua tindakannya memerlukan izin khusus, Anda dapat membuat komponen tingkat tinggi yang menggabungkan semua izin ini dengan semua fungsi ujung ke ujung yang diperlukan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> NextError <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'next/error'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> compose <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash/fp/compose'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requiresPermission <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../requires-permission'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> withFeatures <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../with-features'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> withAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../with-auth'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> withEnv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../with-env'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> withLoader <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../with-loader'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> withLayout <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../with-layout'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> compose(  withEnv,  withAuth,  withLoader,  withLayout(),  withFeatures,  requiresPermission(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;NextError statusCode={<span class="hljs-number"><span class="hljs-number">404</span></span>} /&gt;, {    <span class="hljs-attr"><span class="hljs-attr">permission</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span>,  }), );</code> </pre> <br>  Berikut cara menggunakannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> compose <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash/fp/compose'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> adminPage <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../HOCs/admin-page'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AdminIndex <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../features/admin-index/admin-index-component.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> adminPage(AdminIndex);</code> </pre> <br>  API komponen tingkat tinggi nyaman untuk tugas ini.  Ini memungkinkan Anda untuk menyelesaikannya dengan lebih ringkas, menggunakan lebih sedikit kode daripada menggunakan kait.  Tetapi untuk menggunakan fungsi <code>connect</code> , Anda harus ingat bahwa dibutuhkan <code>mapStateToProps</code> sebagai argumen pertama, dan <code>mapStateToProps</code> sebagai argumen kedua.  Kita tidak boleh lupa bahwa fungsi ini dapat mengambil fungsi atau objek literal.  Anda perlu tahu bagaimana perbedaan penggunaan <code>connect</code> , dan bahwa ini adalah fungsi kari, tetapi karinya tidak dilakukan secara otomatis. <br><br>  Dengan kata lain, saya dapat mengatakan bahwa saya percaya bahwa selama pengembangan <code>connect</code> banyak pekerjaan dilakukan ke arah keringkasan kode, tetapi kode yang dihasilkan tidak terlalu mudah dibaca, juga tidak terlalu nyaman.  Jika saya tidak perlu bekerja dengan beberapa komponen, maka saya ingin memilih API <code>connect</code> tidak nyaman dengan API pengait yang jauh lebih nyaman, bahkan mengingat hal ini akan mengarah pada peningkatan jumlah kode. <br><br><h3>  <font color="#3AC1EF">â– Jika singleton dianggap sebagai anti-pola dan Redux adalah singleton, apakah ini berarti bahwa Redux adalah anti-pola?</font> </h3><br>  Tidak, tidak.  Menggunakan singleton dalam kode mengisyaratkan kualitas kode ini yang meragukan, yang menunjukkan keberadaan keadaan yang dapat diubah bersama di dalamnya.  Ini adalah pola anti nyata.  Redux, di sisi lain, mencegah mutasi status bersama melalui enkapsulasi (Anda tidak boleh mengubah status aplikasi secara langsung, di luar reduksi; Redux memecahkan masalah mengubah keadaan) dan dengan mengirim pesan (hanya objek acara yang dikirim yang dapat menyebabkan perubahan status). <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Apakah Redux mengganti React hooks?  Kait memang bagus, tetapi mereka tidak menggantikan Redux. <br><br>  Kami berharap materi ini akan membantu Anda dalam memilih model manajemen negara bagian untuk proyek Bereaksi Anda. <br><br>  <b>Pembaca yang budiman!</b>  Pernahkah Anda mengalami situasi di mana React hooks dapat menggantikan Redux? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464293/">https://habr.com/ru/post/id464293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464283/index.html">Aplikasi untuk e-book di sistem operasi Android. Bagian 3. Kamus dan catatan</a></li>
<li><a href="../id464285/index.html">Perbarui foto profil Vkontakte secara otomatis</a></li>
<li><a href="../id464287/index.html">Bagian dari mesin laboratorium untuk "Hackthebox - Friendzone" yang terbaik</a></li>
<li><a href="../id464289/index.html">Cara menulis paket Go</a></li>
<li><a href="../id464291/index.html">10 bahasa pemrograman paling berpengaruh dalam 50 tahun terakhir dan penciptanya</a></li>
<li><a href="../id464295/index.html">Contoh menggunakan beberapa fitur JavaScript baru</a></li>
<li><a href="../id464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../id464303/index.html">Data deret waktu dalam DBMS relasional. Ekstensi TimescaleDB dan PipelineDB untuk PostgreSQL</a></li>
<li><a href="../id464305/index.html">Kecil ya. Membuka kotak microvirtual Firecracker</a></li>
<li><a href="../id464307/index.html">Pengujian integrasi layanan microser di Scala</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>