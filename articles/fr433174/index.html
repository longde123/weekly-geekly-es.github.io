<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🍳 🕡 🧝 Tous les correctifs ne sont pas également utiles. 👩🏽‍💼 🧗🏼 🛀🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article poursuit la discussion sur les améliorations de performances qui pourraient se réaliser sans les différents mais. La partie précédente sur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tous les correctifs ne sont pas également utiles.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433174/"><p> Cet article poursuit la discussion sur les améliorations de performances qui pourraient se réaliser sans les différents mais.  La partie précédente sur <code>StringBuilder</code> est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Nous examinons ici quelques «améliorations» rejetées en raison d'un manque de compréhension des subtilités de la spécification du langage, des cas d'angle non évidents et d'autres raisons.  C'est parti! </p><a name="habracut"></a><br><h4 id="kogda-nichto-ne-predveschaet-bedy">  Quand rien n'annonce des ennuis </h4><br><p>  Je pense que chacun de nous a travaillé avec les méthodes <code>Collections.emptySet()</code> / <code>Collections.emptyList()</code> .  Ce sont des méthodes très utiles qui vous permettent de renvoyer une collection immuable vide sans créer de nouvel objet.  En regardant à l'intérieur de la classe <code>EmptyList</code> nous allons voir ceci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Iterator&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emptyIterator(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object[] toArray() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } }</code> </pre> <br><p>  Vous voyez un fort potentiel d'amélioration?  La méthode <code>EmptyList.iterator()</code> renvoie un itérateur vide de la présence, pourquoi ne pas faire la même feinte avec vos oreilles pour le tableau retourné par la méthode <code>toArray()</code> ? </p><br><div class="spoiler">  <b class="spoiler_title">Il y en a un, mais c'est la documentation</b> <div class="spoiler_text"><blockquote>  Le tableau retourné sera "sûr" dans la mesure où aucune référence ne sera conservée dans cette liste.  (En d'autres termes, cette méthode doit allouer un nouveau tableau même si cette liste est sauvegardée par un tableau).  L'appelant est ainsi libre de modifier le tableau retourné. </blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2017-September/049170.html</a> <br>  <a href="" rel="nofollow">http://hg.openjdk.java.net/jdk/jdk12/file/ffac5eabbf28/src/java.base/share/classes/java/util/List.java#l185</a> </p></div></div><br><p>  En d'autres termes, la méthode doit toujours renvoyer un <strong>nouveau</strong> tableau. </p><br><p>  Vous direz: "Il est immuable! Qu'est-ce qui peut mal tourner!?" </p><br><p>  Seuls des experts expérimentés peuvent répondre à cette question: </p><br><blockquote>  - Qui est responsable? <br>  - Experts responsables Paul Sandoz et Tagir Valeev </blockquote><br><div class="spoiler">  <b class="spoiler_title">La réponse des experts</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2017-September/049171.html</a> </p><br><blockquote>  Notez également que cela modifie le comportement visible.  E. g.  quelqu'un peut se synchroniser sur l'objet tableau renvoyé par l'appel toArray, donc cette modification peut provoquer un <strong>partage de verrou</strong> indésirable. <br><br>  Une fois, j'ai suggéré une amélioration similaire: renvoyer EMPTY_LIST de Arrays.asList () lorsque le tableau fourni a une longueur nulle.  Il a été refusé pour la même raison [1]. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-September/035197.html</a> <br><br>  Au fait, il est probablement raisonnable pour Arrays.asList de vérifier la longueur du tableau comme: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T... a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyList(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(a); }</code> </pre> <br><br>  Cela semble raisonnable, non?  Pourquoi créer une nouvelle liste pour un tableau vide si vous pouvez en prendre un tout prêt gratuitement? <br>  Il y a une raison de ne pas le faire.  Pour le moment, Arrays.asList ne spécifie aucune contrainte sur l'identité de la liste renvoyée.  L'ajout de la micro-optimisation changera cela.  C'est un cas de bord et un cas d'utilisation douteux aussi, mais étant donné que je laisserais les choses telles quelles. </blockquote></div></div><br><p>  Cette déclaration va probablement vous dérouter: </p><br><blockquote>  E. g.  quelqu'un peut se synchroniser sur l'objet tableau renvoyé par l'appel toArray, donc cette modification peut provoquer un partage de verrou indésirable. </blockquote><p>  Vous direz: "Qui dans leur bon sens sera synchronisé sur la baie (!) Renvoyé (!!!) de la collection!?" </p><br><p>  Cela ne semble pas très crédible, mais le langage offre une telle opportunité, ce qui signifie qu'il est possible qu'un certain utilisateur le fasse (ou l'ait déjà fait).  Ensuite, le changement proposé modifiera au mieux le comportement du code, et au pire, il entraînera une panne de synchronisation (allez plus tard, rattrapez-le).  Le risque est tellement injustifié et le gain escompté est si insignifiant qu'il vaut mieux tout laisser tel quel. </p><br><p>  En général, la possibilité de synchroniser sur n'importe quel objet, kmk, était l'erreur des développeurs de langage.  Premièrement, l'en-tête de chaque objet contient une structure responsable de la synchronisation, et deuxièmement, nous nous trouvons dans la situation décrite ci-dessus lorsqu'un objet apparemment immuable ne peut pas être retourné plusieurs fois, car il peut être synchronisé sur lui. </p><br><p>  La morale de cette fable est la suivante: la spécification et la compatibilité descendante sont des vaches sacrées de Java.  N'essayez même pas de les empiéter: le gardien tire sans prévenir. </p><br><h4 id="staraeshsya-staraeshsya">  Essayer, essayer ... </h4><br><p>  Il existe plusieurs classes basées sur des tableaux dans le JDK à la fois, et toutes implémentent les méthodes <code>List.indexOf()</code> et <code>List.lastIndexOf()</code> : </p><br><ul><li>  java.util.ArrayList </li><li>  java.util.Arrays $ ArrayList </li><li>  java.util.Vector </li><li>  java.util.concurrent.CopyOnWriteArrayList </li></ul><br><p>  Le code de ces méthodes dans ces classes est répété presque un à un.  De nombreuses applications et frameworks proposent également leurs solutions pour le même problème: </p><br><ul><li>  <a href="" rel="nofollow">org.hibernate.bytecode.enhance.internal.tracker.SimpleFieldTracker</a> </li><li>  <a href="" rel="nofollow">com.intellij.util.ArrayUtil</a> </li><li>  <a href="" rel="nofollow">com.intellij.util.ArrayUtilRt</a> </li><li>  <a href="" rel="nofollow">org.springframework.oxm.jibx.JibxMarshaller</a> </li></ul><br><p>  En conséquence, nous avons du code erroné qui doit être compilé (parfois parfois plusieurs fois), qui a lieu dans ReserverCodeCache, qui doit être testé, et qui se promène simplement de classe en classe avec presque aucun changement. </p><br><p>  Les développeurs, à leur tour, aiment beaucoup écrire quelque chose comme </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Arrays.asList(array).indexOf(obj); <span class="hljs-comment"><span class="hljs-comment">//  boolean contains = Arrays.asList(array).contains(obj); //    boolean contains = Arrays.stream(names).anyMatch(nm -&gt; nm.equals(name));</span></span></code> </pre> <br><p>  Je voudrais introduire des méthodes utilitaires généralisées dans le JDK et les utiliser partout, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">suggéré</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Le patch est</a> aussi simple que deux sous: </p><br><p>  1) les implémentations de <code>List.indexOf()</code> et <code>List.lastIndexOf()</code> déplacent vers <code>java.util.Arrays</code> <br>  2) à la place, <code>Arrays.indexOf()</code> et <code>Arrays.lastIndexOf()</code> sont appelés, respectivement </p><br><p>  Il semblerait que ce qui pourrait mal tourner?  Le gain de cette approche est [apparemment] évident.  Mais l'article concerne les échecs, alors pensez à ce qui pourrait mal tourner. </p><br><blockquote>  - Qui est responsable? <br>  - Experts responsables Martin Buchholz et Paul Sandoz </blockquote><br><div class="spoiler">  <b class="spoiler_title">À mon humble avis, un peu tendu, mais néanmoins</b> <div class="spoiler_text"><p>  Martin Buchholz: </p><br><blockquote>  Sergey, je suis en quelque sorte en train de maintenir toutes ces classes de collection, et j'ai parfois voulu également avoir des méthodes indexOf dans Array.java.  Mais: <br><br>  Les tableaux sont généralement déconseillés.  Toutes les nouvelles méthodes statiques sur les tableaux (ou, là où je le souhaite, sur l'objet tableau lui-même! Nécessite un changement de langage java!) Rencontreront une résistance. <br><br>  Nous en sommes venus à regretter de prendre en charge les valeurs null dans les collections, donc les classes de collection plus récentes comme ArrayDeque ne les prennent pas en charge. <br><br>  Une autre variante que les utilisateurs pourraient souhaiter est le type de comparaison d'égalité à utiliser. <br><br>  Nous en sommes venus à regretter d'avoir ArrayList avec un index de départ basé sur zéro - il aurait été préférable d'avoir le comportement de tableau circulaire d'ArrayDeque dès le premier jour. <br><br>  Le code de recherche des tranches de tableau est très petit, vous n'économisez donc pas beaucoup.  Il est facile de faire une erreur au coup par coup, mais cela est également vrai pour une API de tableaux. </blockquote><p>  Paul Sandoz: </p><br><blockquote>  Je n'irais pas jusqu'à dire que les tableaux sont découragés, je le tournerais positivement comme "à utiliser avec soin" car ils sont épineux, par exemple toujours modifiables. Ils pourraient certainement être améliorés. Je serais très heureux de voir des tableaux implémenter un tableau commun 'interface ish, nous pourrions être en mesure de faire des progrès après les types de valeur sédiment. <br><br>  Tout nouvel ajout à Arrays se heurterait à une certaine résistance, du moins pour moi :-) Il n'ajoute jamais qu'une ou deux méthodes, beaucoup d'autres veulent également venir pour le trajet (toutes les primitives plus les variantes de gamme).  Donc, toute nouvelle fonctionnalité doit être suffisamment bénéfique et dans ce cas, je ne pense pas que les avantages soient suffisamment forts (comme une éventuelle pression de cache du code de réduction). </blockquote><p>  Paul. </p></div></div><br><p>  Correspondance: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-March/051968.html</a> </p><br><p>  La morale de cette fable est la suivante: votre ingénieux patch peut être abattu pour examen simplement parce qu'il n'y verra aucune valeur particulière.  Eh bien, oui, il y a du code en double, mais cela ne dérange personne, alors laissez-le vivre. </p><br><h4 id="uluchsheniya-dlya-arraylist-a-ih-est-u-menya">  Des améliorations pour ArrayList?  Je les ai </h4><br><p><del>  Cyclomoteur </del>  le patch n'est pas le mien, je vais le poster pour que vous y réfléchissiez.  La proposition elle-même a été exprimée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> et elle semble très attrayante.  Voyez par vous-même: </p><br><div class="spoiler">  <b class="spoiler_title">Changement proposé</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Lien</a> </p></div></div><br><p>  A l'oeil nu, la proposition est très, très logique.  Vous pouvez mesurer les performances à l'aide d'un simple <a href="" rel="nofollow">benchmark</a> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Benchmark) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayListBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Benchmark) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"100"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>, <span class="hljs-string"><span class="hljs-string">"10000"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; ArrayList&lt;Integer&gt; arrayRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(size); <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span>(Level.Invocation) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initArrayList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Random rand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); rand.setSeed(System.currentTimeMillis()); <span class="hljs-comment"><span class="hljs-comment">// Populate the ArrayList with size-5 elements for (int i = 0; i &lt; size - 5; i++) { Integer r = rand.nextInt() % 256; arrayRandom.add(r); } } } @Benchmark public ArrayList construct_new_array_list(Data d) { ArrayList al = new ArrayList(d.arrayRandom); // once a new ArrayList is created add a new element al.add(new Integer(900)); return al; } }</span></span></code> </pre> <br><p>  Résumé: </p><br><pre> <code class="plaintext hljs">Benchmark (size) Mode Cnt Score Error Units  construct_new_array_list 10 thrpt 25 388.212 ± 23.110 ops/s construct_new_array_list 100 thrpt 25 90.208 ± 7.995 ops/s construct_new_array_list 1000 thrpt 25 23.289 ± 1.687 ops/s construct_new_array_list 10000 thrpt 25 7.659 ± 0.560 ops/s  construct_new_array_list 10 thrpt 25 562.678 ± 37.370 ops/s construct_new_array_list 100 thrpt 25 119.791 ± 13.232 ops/s construct_new_array_list 1000 thrpt 25 33.811 ± 3.812 ops/s construct_new_array_list 10000 thrpt 25 10.889 ± 0.564 ops/s</code> </pre> <br><p>  Pas mal du tout pour un changement aussi simple.  L'essentiel est qu'il ne semble pas y avoir de prise.  Créez honnêtement un tableau, copiez honnêtement les données et n'oubliez pas la taille.  Maintenant, ils doivent définitivement accepter le patch! </p><br><div class="spoiler">  <b class="spoiler_title">Mais c'était là</b> <div class="spoiler_text"><p>  Martin Buchholz: </p><br><blockquote>  Il ne fait aucun doute que nous pouvons optimiser le cas d'ArrayList -&gt; ArrayList, mais qu'en est-il de toutes les autres implémentations de Collection?  ArrayDeque et CopyOnWriteArrayList me viennent à l'esprit. <br>  ArrayList est une classe populaire à utiliser pour faire des copies de collections.  Où vous arrêtez-vous? <br><br>  Une sous-classe pathologique d'ArrayList pourrait décider de ne pas stocker d'éléments dans le tableau de support, avec une rupture qui s'ensuit. <br><br>  La solution bénie au problème de copie de liste est probablement List.copyOf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html#copyOf(java .util.Collection</a> ) qui pourrait faire l'optimisation que vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">espérez</a> . </blockquote><p>  Alan Bateman </p><br><blockquote>  ArrayList n'est pas final, il est donc possible que quelqu'un l'ait étendu pour utiliser autre chose que elementData.  Il pourrait être plus sûr d'utiliser l'identité de classe plutôt que instanceof. </blockquote></div></div><br><p>  Rien ne m'interdit de me dissocier d' <code>ArrayList</code> et de stocker des données dans une liste chaînée.  Ensuite, <code>c instanceof ArrayList</code> retournera la vérité, nous arriverons dans la zone de copie et tomberons en toute sécurité. </p><br><p>  La morale de cette fable est la suivante: un <em>éventuel</em> changement de comportement peut être la cause de l'échec.  En d'autres termes, il faut garder à l'esprit la probabilité d'un changement, même le plus absurde, s'il est permis par le langage.  Et oui, cela aurait pu fonctionner si <code>ArrayList</code> avait déclaré la <code>final</code> depuis le début. </p><br><h4 id="snova-specifikaciya">  Spécifications à nouveau </h4><br><p>  Lors du débogage de mon application, je suis accidentellement tombé dans les tripes de Spring et j'ai trouvé le <a href="" rel="nofollow">code</a> suivant: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      paramTypes for (Constructor&lt;?&gt; candidate : candidates) { Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes(); if (constructorToUse != null &amp;&amp; argsToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) { // Already found greedy constructor that can be satisfied -&gt; // do not look any further, there are only less greedy constructors left. break; } if (paramTypes.length &lt; minNrOfArgs) { continue; }</span></span></code> </pre> <br><p>  Heureusement, en entrant dans <code>java.lang.reflect.Constructor.getParameterTypes()</code> j'ai fait défiler le code un peu plus bas et en ai trouvé un magnifique: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;?&gt;[] getParameterTypes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parameterTypes.clone(); } <span class="hljs-comment"><span class="hljs-comment">/** * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@inheritDoc</span></span></span><span class="hljs-comment">} * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 1.8 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParameterCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parameterTypes.length; }</code> </pre> <br><p>  Tu vois, oui?  Si nous devons trouver le nombre d'arguments constructeur / méthode, il suffit d'appeler <code>java.lang.reflect.Method.getParameterCount()</code> et de ne pas copier le tableau.  Vérifiez si le jeu en vaut la chandelle dans le cas le plus simple, dans lequel la méthode n'a pas de paramètres: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodToStringBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Method method; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ method = getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"toString"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParameterCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> method.getParameterCount(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParameterTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> method.getParameterTypes().length; } }</code> </pre> <br><p>  Sur ma machine et avec JDK 11, cela se présente comme suit: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units getParameterCount avgt 25 2,528 ± 0,085 ns/op getParameterCount:·gc.alloc.rate avgt 25 ≈ 10⁻⁴ MB/sec getParameterCount:·gc.alloc.rate.norm avgt 25 ≈ 10⁻⁷ B/op getParameterCount:·gc.count avgt 25 ≈ 0 counts getParameterTypes avgt 25 7,299 ± 0,410 ns/op getParameterTypes:·gc.alloc.rate avgt 25 1999,454 ± 89,929 MB/sec getParameterTypes:·gc.alloc.rate.norm avgt 25 16,000 ± 0,001 B/op getParameterTypes:·gc.churn.G1_Eden_Space avgt 25 2003,360 ± 91,537 MB/sec getParameterTypes:·gc.churn.G1_Eden_Space.norm avgt 25 16,030 ± 0,045 B/op getParameterTypes:·gc.churn.G1_Old_Gen avgt 25 0,004 ± 0,001 MB/sec getParameterTypes:·gc.churn.G1_Old_Gen.norm avgt 25 ≈ 10⁻⁵ B/op getParameterTypes:·gc.count avgt 25 2380,000 counts getParameterTypes:·gc.time avgt 25 1325,000 ms</code> </pre> <br><p>  Que pouvons-nous y faire?  Nous pouvons rechercher l'utilisation de l'antipattern <code>Method.getParameterTypes().length</code> dans le JDK (au moins dans <code>java.base</code> ) et le remplacer là où cela a du sens: </p><br><p> <code>java.lang.invoke.MethodHandleProxies</code> </p> <br><p><img src="https://habrastorage.org/webt/l_/3j/h1/l_3jh1hu3swdedxqktlxboz0tu0.png"></p><br><p> <code>java.util.concurrent.ForkJoinTask</code> </p> <br><p><img src="https://habrastorage.org/webt/0o/rt/q7/0ortq71mnf3-bwsa4wyi-jmzf5y.png"></p><br><p> <code>java.lang.reflect.Executable</code> </p> <br><p><img src="https://habrastorage.org/webt/sm/_h/pm/sm_hpm8eahlmqavobjqg9gejvse.png"></p><br><p> <code>sun.reflect.annotation.AnnotationType</code> </p> <br><p><img src="https://habrastorage.org/webt/yw/bv/il/ywbvil_doi3fzy6uzkpcm42g6zu.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Le patch a</a> été envoyé avec une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">lettre de motivation</a> . </p><br><p>  Du coup, il s'est avéré que, depuis plusieurs années <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">, la tâche était similaire,</a> et même des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">changements y étaient</a> préparés.  Les commentaires ont noté une augmentation des performances assez décente pour de tels changements simples.  Cependant, eux et mon patch sont nettoyés jusqu'à présent et restent immobiles.  Pourquoi?  Probablement parce que les développeurs sont trop occupés par des choses plus nécessaires et qu'ils n'y mettent bêtement pas la main. </p><br><p>  La morale de cette fable est la suivante: vos changements ingénieux peuvent geler simplement par manque de travailleurs. </p><br><p>  Mais ce n'est pas la fin!  Au cours de la discussion sur la rationalité du remplacement décrit dans d'autres projets, des camarades plus expérimentés ont avancé une contre-proposition: peut-être que vous ne devriez pas faire le remplacement de <code>Method.getParameterTypes().length -&gt; Method.getParameterCount()</code> avec vos mains, mais confier cela au compilateur?  Est-ce possible et sera-t-il "légal"? </p><br><p>  Essayons de vérifier en utilisant le test: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arrayClone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object[] objects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[<span class="hljs-number"><span class="hljs-number">3</span></span>]; objects[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"azaza"</span></span>; objects[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">365</span></span>; objects[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">9876L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object[] clone = objects.clone(); assertEquals(objects.length, clone.length); assertSame(objects[<span class="hljs-number"><span class="hljs-number">0</span></span>], clone[<span class="hljs-number"><span class="hljs-number">0</span></span>]); assertSame(objects[<span class="hljs-number"><span class="hljs-number">1</span></span>], clone[<span class="hljs-number"><span class="hljs-number">1</span></span>]); assertSame(objects[<span class="hljs-number"><span class="hljs-number">2</span></span>], clone[<span class="hljs-number"><span class="hljs-number">2</span></span>]); }</code> </pre> <br><p>  qui passe, et qui montre que si le tableau cloné ne quitte pas la portée, alors il peut être supprimé, car l'accès à n'importe quel élément depuis ses cellules ou le champ de <code>length</code> peut être obtenu à partir de l'original. </p><br><p>  Le JDK peut-il faire cela?  Nous vérifions: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayAllocationEliminationBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baseline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[length].length; } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baselineClone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[length].clone().length; } }</code> </pre> <br><p>  Sortie pour JDK 13: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units baseline avgt 50 6,135 ± 0,140 ns/op baseline:·gc.alloc.rate.norm avgt 50 56,000 ± 0,001 B/op clone avgt 50 18,359 ± 0,619 ns/op clone:·gc.alloc.rate.norm avgt 50 112,000 ± 0,001 B/op</code> </pre> <br><p>  Il s'avère que openjdk ne sait pas lancer de <code>new int[length]</code> , contrairement au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Graal</a> , hehe: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units baseline avgt 25 2,470 ± 0,156 ns/op baseline:·gc.alloc.rate.norm avgt 25 0,005 ± 0,008 B/op lone avgt 25 13,086 ± 1,059 ns/op lone:·gc.alloc.rate.norm avgt 25 112,113 ± 0,115 B/op</code> </pre> <br><p>  Il s'avère que vous pouvez modifier un peu le compilateur d'optimisation openjdk afin qu'il puisse faire ce que le Graal peut faire.  Étant donné que non seulement tout le monde peut entrer dans une annonce positive dans le code VM et déposer quelque chose de significatif, je me suis limité à une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">lettre</a> dans laquelle j'exprimais mes observations. </p><br><p>  Il s'est avéré, et il y a plusieurs subtilités.  Vladimir Ivanov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">indique</a> que: </p><br><blockquote>  Étant donné qu'il n'y a aucun moyen de développer / réduire les tableaux Java, <br>  La transformation "cloned_array.length =&gt; original_array.length" est correcte <br>  indépendamment du fait que la variante clonée s'échappe ou non. <br><br>  De plus, la transformation est déjà là: <br><br>  <a href="" rel="nofollow">http://hg.openjdk.java.net/jdk/jdk/file/tip/src/hotspot/share/opto/memnode.cpp#l2388</a> <br><br>  Je n'ai pas examiné les références que vous avez mentionnées, mais il semble que <br>  L'accès cloned_array.length n'est pas la raison pour laquelle le tableau cloné est toujours <br>  là. <br><br>  Concernant vos autres idées, rediriger les accès de l'instance clonée vers <br>  l'original est problématique (dans le cas général) car le compilateur doit prouver <br>  il n'y a eu aucun changement dans les deux versions et les accès indexés rendent même <br>  plus dur.  Et les points de sécurité causent également des problèmes (pour la rematérialisation). <br><br>  Mais je conviens qu'il serait intéressant de couvrir (au moins) des cas simples de <br>  copie défensive. </blockquote><p>  Autrement dit, frapper un clone semble être possible et pas particulièrement difficile.  Mais avec la conversion </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[arrayLength].length;</code> </pre> <br><p>  -&gt; </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = arrayLength;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">des difficultés</a> surviennent: </p><br><blockquote>  Nous n'éliminons pas les allocations de tableaux qui n'ont pas une longueur connue <br>  car ils peuvent provoquer une exception NegativeArraySize.  Dans ce cas, nous <br>  devrait être en mesure de prouver que la longueur est positive. <br><br>  Quoi qu'il en soit - j'ai un patch presque terminé qui remplace le tableau inutilisé <br>  allocations avec un gardien approprié. </blockquote><p>  En d'autres termes, vous ne pouvez pas simplement prendre et supprimer la création d'un tableau, car selon la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">spécification, l'</a> exécution <em>doit</em> lever une <code>NegativeArraySizeException</code> et nous ne pouvons rien y faire: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arrayWithNwgativeSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLen = -<span class="hljs-number"><span class="hljs-number">3</span></span>; length = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[newLen].length; <span class="hljs-comment"><span class="hljs-comment">//  new Object[newLen]  fail(); } catch (NegativeArraySizeException e) { assert length == 0; } }</span></span></code> </pre> <br><p>  Pourquoi le Graal a-t-il pu?  Je pense que la raison en est que la valeur du champ de <code>length</code> dans le benchmark ci-dessus était constante et toujours égale à 10, ce qui a permis au profileur de conclure que la vérification d'une valeur négative n'est pas nécessaire, ce qui signifie qu'elle peut être supprimée avec la création du tableau lui-même.  Correct dans les commentaires si j'ai fait une erreur. </p><br><p>  C'est tout pour aujourd'hui :) Ajoutez vos exemples dans les commentaires, nous comprendrons. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433174/">https://habr.com/ru/post/fr433174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433158/index.html">Parodies musicales de SUSE sur Kubernetes, Linus Torvalds et autres</a></li>
<li><a href="../fr433164/index.html">Rapide et furieux: Forza Horizon 4 accélère avec les shaders de fenêtre</a></li>
<li><a href="../fr433166/index.html">Prédire le temps de solution de ticket à l'aide du Machine Learning</a></li>
<li><a href="../fr433168/index.html">Pourquoi un programmeur fait-il un stage en cuisine - une conversation avec Dodo Pizza sur le gemba, .NET et l'ouverture</a></li>
<li><a href="../fr433172/index.html">Nous attachons le multijoueur au jeu mobile "Make words from words" sur iOS et Android, écrit en C ++</a></li>
<li><a href="../fr433178/index.html">Comment nous avons restauré un fichier .wav endommagé</a></li>
<li><a href="../fr433180/index.html">Résolution des problèmes de type de données dans Ruby ou Fiabilisation des données</a></li>
<li><a href="../fr433182/index.html">Est-il possible de former un agent pour la négociation en bourse avec des renforts? Implémentation du langage R</a></li>
<li><a href="../fr433184/index.html">ASP.NET Core 2.2 est sorti. Quoi de neuf (2 sur 3)</a></li>
<li><a href="../fr433186/index.html">Il ne suffit pas de compter les polygones pour optimiser les modèles 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>