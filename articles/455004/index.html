<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüåæ üêµ üìÜ Unidad: una ciudad interminable generada por procedimientos obtenida utilizando el algoritmo WFC (colapso de la funci√≥n de onda) üéÑ üêΩ üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 

 Como legisladores de Unity en el mercado ruso, les ofrecemos leer un estudio interesante sobre el uso pr√°ctico del algoritmo WFC (Wave F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unidad: una ciudad interminable generada por procedimientos obtenida utilizando el algoritmo WFC (colapso de la funci√≥n de onda)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/455004/">  Hola Habr! <br><br>  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">legisladores</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unity</a> en el mercado ruso, les ofrecemos leer un estudio interesante sobre el uso pr√°ctico del algoritmo WFC (Wave Function Collapse), construido a imagen y semejanza del conocido principio de la mec√°nica cu√°ntica y muy conveniente para la generaci√≥n de niveles de procedimientos en juegos.  Anteriormente en Habr√©, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">historia detallada</a> sobre este algoritmo ya estaba publicada.  La autora del art√≠culo de hoy, Marian Kleineberg, considera el algoritmo en el contexto de los gr√°ficos tridimensionales y la generaci√≥n de una ciudad sin fin.  Que tengas una buena lectura! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4b/e7/af/4be7afzttmmd9g8y2snj_pnxpns.jpeg"></div><a name="habracut"></a><br>  Hablaremos de un juego en el que caminas por una ciudad interminable que se genera procesalmente a medida que te mueves.  Una ciudad se construye a partir de un conjunto de bloques utilizando el algoritmo WFC (colapso de la funci√≥n de onda). <br><br>  El ensamblaje jugable est√° disponible para su descarga en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio</a> web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">itch.io.</a>  Tambi√©n puede tomar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo fuente en github</a> .  Finalmente, propongo un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">video</a> en el que camino por la ciudad as√≠ generada. <br><br><h3>  Algoritmo </h3><br>  Llamar√© a la palabra "celda" un elemento de malla 3D voxel que puede contener un bloque o estar vac√≠o.  La palabra "m√≥dulo" llamar√© un bloque que puede ocupar dicha celda. <br><br>  El algoritmo decide qu√© m√≥dulos seleccionar en cada celda del mundo del juego.  Una matriz de celdas se considera una funci√≥n de onda en una forma no observable.  Por lo tanto, cada celda corresponde a muchos m√≥dulos que pueden aparecer en ella.  En t√©rminos de mec√°nica cu√°ntica, se podr√≠a decir, "la c√©lula est√° en una superposici√≥n de todos los m√≥dulos".  La existencia del mundo comienza en una forma completamente inobservable, donde cualquier m√≥dulo puede estar en cada celda.  Adem√°s, todas las c√©lulas colapsan, una tras otra.  Esto significa que para cada celda se selecciona aleatoriamente un m√≥dulo de todos los posibles. <br><br>  El siguiente paso es la propagaci√≥n de restricciones.  Para cada m√≥dulo, se selecciona un subconjunto de m√≥dulos que pueden estar adyacentes a √©l.  Cada vez que un m√≥dulo colapsa, se actualizan los subconjuntos de otros m√≥dulos, que a√∫n se permiten como adyacentes.  La etapa de propagaci√≥n de restricciones es la parte del algoritmo que consume m√°s recursos en t√©rminos de potencia inform√°tica. <br><br>  Un aspecto importante del algoritmo es determinar qu√© c√©lula colapsar.  El algoritmo siempre colapsa la celda con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">entrop√≠a m√°s peque√±a</a> .  Esta es una celda que permite un n√∫mero m√≠nimo de opciones (es decir, una celda con la menor aleatoriedad).  Si la probabilidad de colapso es la misma para todos los m√≥dulos, entonces la celda con el n√∫mero m√≠nimo de m√≥dulos posibles tendr√° la entrop√≠a m√°s baja.  Como regla general, las probabilidades de ser seleccionado son diferentes para los distintos m√≥dulos disponibles.  Una celda con dos m√≥dulos posibles que tienen la misma probabilidad proporciona una opci√≥n m√°s amplia (mayor entrop√≠a) que la que tiene dos m√≥dulos, y para uno de ellos la probabilidad de caer bajo la opci√≥n es muy alta, y para el otro es muy peque√±a. <br><br><img src="https://habrastorage.org/webt/dp/kw/z-/dpkwz-w1fr5-xxrw_flqyt_mtou.gif"><br><br>  (Gif publicado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExUtumno</a> en Github) <br><br>  Aqu√≠ se puede encontrar informaci√≥n m√°s detallada sobre el algoritmo de colapso de la funci√≥n de onda, as√≠ como una serie de hermosos ejemplos.  Inicialmente, este algoritmo fue propuesto para generar texturas 2D basadas en una sola muestra.  En este caso, los indicadores probabil√≠sticos de los m√≥dulos y las reglas de adyacencia se determinan seg√∫n su ocurrencia en el ejemplo.  Este art√≠culo proporciona esta informaci√≥n manualmente. <br><br>  Aqu√≠ hay un <a href="">video que</a> demuestra este algoritmo en acci√≥n. <br><br><h3>  Sobre bloques, prototipos y m√≥dulos </h3><br>  El mundo se genera a partir de un conjunto en el que unos 100 bloques.  Los cre√© usando Blender.  Al principio, ten√≠a muy pocos bloques, y los agregu√© poco a poco cuando lo consider√© necesario. <br><br><img src="https://habrastorage.org/webt/yj/26/sn/yj26snwykmonhpvoy9mvv_bnsq8.png"><br><br>  El algoritmo necesita saber qu√© m√≥dulos se pueden ubicar uno al lado del otro.  Para cada m√≥dulo, hay 6 listas de posibles vecinos, una en cada una de las direcciones.  Sin embargo, quer√≠a evitar tener que crear dicha lista manualmente.  Adem√°s, quer√≠a generar autom√°ticamente opciones rotadas para cada uno de mis bloques. <br><br>  Ambas tareas se resuelven utilizando los llamados m√≥dulos prototipo.  En esencia, este es <code>MonoBehaviour</code> , con el cual es conveniente trabajar en el editor de Unity.  Los m√≥dulos junto con las listas de elementos vecinos v√°lidos y las opciones rotadas se crean autom√°ticamente en funci√≥n de dichos prototipos. <br><br>  Surgi√≥ un problema complejo con el modelado de informaci√≥n de adyacencia, por lo que este proceso autom√°tico funcion√≥.  Esto es lo que obtuve: <br><br><img src="https://habrastorage.org/webt/ym/cj/ke/ymcjkeehpahvovwxbpl7kma28bs.png"><br><br>  Cada bloque tiene 6 contactos, uno para cada cara.  El contacto tiene un n√∫mero.  Adem√°s, los contactos horizontales pueden estar invertidos, no invertidos o sim√©tricos.  Los contactos verticales tienen un √≠ndice de rotaci√≥n en el rango de 0 a 3 o est√°n marcados como <i>rotacionalmente invariantes</i> . <br><br>  En base a esto, puedo verificar autom√°ticamente qu√© m√≥dulos pueden encajar juntos.  Los m√≥dulos adyacentes deben tener los mismos n√∫meros de pin.  Su simetr√≠a tambi√©n debe coincidir (el mismo √≠ndice de rotaci√≥n vertical, un par de contactos horizontales invertidos y no invertidos), o los m√≥dulos deben ser sim√©tricos / invariantes. <br><br><img src="https://habrastorage.org/webt/zk/-3/lo/zk-3looqprzz5upxpuavvmkccbu.png"><br><br>  Existen reglas de exclusi√≥n por las cuales puedo prohibir las opciones de vecindario que se permitir√≠an por defecto.  Algunos bloques con contactos coincidentes simplemente se ven feos cerca.  Aqu√≠ hay un ejemplo de un mapa generado sin aplicar reglas de excepci√≥n: <br><br><img src="https://habrastorage.org/webt/md/od/0f/mdod0f_xkotiz9sc7tigjres6ia.jpeg"><br><br><h3>  Camino al infinito </h3><br>  El algoritmo original de colapso de la funci√≥n de onda genera mapas de tama√±o finito.  Quer√≠a construir un mundo que se expanda y se expanda a medida que avanzas. <br><br>  Al principio intent√© generar fragmentos de tama√±o finito y usar los contactos de fragmentos adyacentes como restricciones.  Si se genera un fragmento, y tambi√©n se genera un fragmento adyacente a √©l, entonces solo se permiten los m√≥dulos que quepan junto a los m√≥dulos existentes.  Con este enfoque, surge el siguiente problema: cada vez que una celda colapsa, la propagaci√≥n de restricciones reducir√° las oportunidades incluso a una distancia de varias celdas.  La siguiente imagen muestra los efectos de colapsar una sola celda: <br><br><img src="https://habrastorage.org/webt/ex/yj/rv/exyjrvgb7tciaf1skkzgndnvpd0.png"><br><br>  Si en cada paso del algoritmo solo se genera un fragmento, las restricciones no se aplican a los fragmentos adyacentes.  En este caso, dichos m√≥dulos se seleccionaron dentro del fragmento que ser√≠a inaceptable si se tienen en cuenta otros fragmentos.  Como resultado, cuando el algoritmo intent√≥ generar el siguiente fragmento, no pudo encontrar una soluci√≥n √∫nica. <br><br>  Ahora ya no uso fragmentos, pero almaceno el mapa en un diccionario que muestra la posici√≥n de una celda en una celda.  La celda se llena solo si es necesario.  Algunos elementos del algoritmo deben ajustarse teniendo esto en cuenta.  Al elegir una celda que deber√≠a colapsar, es imposible tener en cuenta todas las celdas si su n√∫mero es infinito.  En cambio, solo generamos una peque√±a porci√≥n del mapa a la vez, una vez que el jugador lo alcanza.  Fuera de esta √°rea, las restricciones contin√∫an extendi√©ndose. <br><br>  En algunos casos, este enfoque no funciona.  Considere un conjunto de m√≥dulos para una secci√≥n recta de un t√∫nel de la figura anterior: no hay entrada al t√∫nel.  Si el algoritmo elige dicho m√≥dulo de t√∫nel, entonces el t√∫nel ser√° infinito por definici√≥n.  En la etapa de distribuci√≥n de restricciones, el programa intentar√° asignar un n√∫mero infinito de celdas.  Desarroll√© un conjunto especial de m√≥dulos para solucionar este problema. <br><br><h3>  Condiciones de contorno </h3><br>  Hay dos condiciones l√≠mite importantes.  Todas las caras en el nivel superior del mapa deben tener contactos "a√©reos".  Todas las caras en la base del mapa deben tener contactos "s√≥lidos".  Si no se cumplen estas condiciones, en el mapa habr√° agujeros en el suelo y algunos edificios estar√°n sin techo. <br><br>  En un mapa de tama√±o finito, este problema se resolver√≠a f√°cilmente.  Para todas las celdas en el nivel m√°s alto y m√°s bajo, ser√≠a necesario eliminar todos los m√≥dulos con contactos inapropiados.  Luego comience la distribuci√≥n de restricciones y elimine los m√≥dulos restantes que ya no nos convienen. <br><br>  En un mapa de tama√±o infinito, esto no funcionar√°, porque tanto en el nivel m√°s alto como en el m√°s bajo, tenemos un n√∫mero infinito de celdas.  La soluci√≥n m√°s ingenua es eliminar todas las celdas inapropiadas inmediatamente a medida que surjan.  Sin embargo, cuando se elimina un m√≥dulo en el nivel superior, se aplican restricciones a las celdas adyacentes.  Hay un efecto de avalancha, que nuevamente conduce a una selecci√≥n infinita de celdas. <br><br>  Resolv√≠ este problema creando un mapa 1 √ó n √ó 1, donde n es la altura.  Este mapa utiliza la envoltura mundial para distribuir las restricciones.  El mecanismo funciona como en el juego Pacman: yendo m√°s all√° del borde derecho del mapa, el personaje vuelve a √©l debido al borde izquierdo.  Ahora puedo aplicar cualquier restricci√≥n a mi mapa.  Cada vez que crea una nueva celda en un mapa infinito, esta celda se inicializa con un conjunto de m√≥dulos que corresponden a una posici√≥n espec√≠fica en el mapa. <br><br><h3>  Condiciones de error y b√∫squeda de retorno </h3><br>  A veces, el algoritmo WFC alcanza un estado en el que la celda no corresponde a ning√∫n m√≥dulo posible.  En las aplicaciones en las que estamos lidiando con un mundo de tama√±o finito, simplemente puede restablecer el resultado y comenzar de nuevo.  En un mundo infinito, esto no funcionar√°, ya que parte del mundo ya se muestra al jugador.  Primero, me decid√≠ por una soluci√≥n en la que los lugares donde ocurr√≠an los errores estaban llenos de bloques blancos. <br><br>  Actualmente estoy usando la b√∫squeda de retorno.  El orden del colapso de las celdas y cierta informaci√≥n sobre la distribuci√≥n de restricciones se almacena en forma de historial.  Si el algoritmo WFC falla, se cancela parte del historial.  Como regla, esto funciona, pero a veces los errores pueden reconocerse demasiado tarde, y una b√∫squeda de retorno cubre muchos pasos.  En casos raros, la celda en la que se encuentra el jugador se regenera. <br><br>  En mi opini√≥n, debido a esta limitaci√≥n, la aplicaci√≥n del algoritmo WFC con mundos infinitos no es adecuada para juegos comerciales. <br><br><h3>  Antecedentes </h3><br>  Comenc√© a trabajar en esta tarea despu√©s de ver una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conferencia de Oscar Stelberg que</a> dec√≠a c√≥mo usa el algoritmo para generar niveles en el juego Bad North.  En general, mi algoritmo se implement√≥ durante la semana de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">procjam</a> . <br><br>  Tengo algunas ideas para un mayor refinamiento de este algoritmo, pero no estoy seguro de que alg√∫n d√≠a voy a agregarle jugabilidad.  Y si me re√∫no, seguro que no ser√° una estrategia tan √©pica como ya la hab√≠as imaginado.  Sin embargo, si quieres comprobar c√≥mo funciona tu mec√°nica de juego favorita con este algoritmo, ¬°pru√©balo t√∫ mismo!  Al final, el c√≥digo fuente est√° disponible p√∫blicamente y tiene licencia del MIT. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455004/">https://habr.com/ru/post/455004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454990/index.html">‚ÄúEs recomendable que tengas un gato‚Äù: c√≥mo una startup puede disparar a Product Hunt</a></li>
<li><a href="../454994/index.html">¬øCu√°les son las ventajas de la carga inal√°mbrica y por qu√© est√° detr√°s el futuro? Experiencia personal para 2019</a></li>
<li><a href="../454996/index.html">El Centro de Entrenamiento de Cosmonautas lleva el nombre de Yu.A. Gagarin y Roscosmos comenzaron el reclutamiento abierto en el escuadr√≥n de cosmonautas</a></li>
<li><a href="../454998/index.html">Julia y la computaci√≥n paralela</a></li>
<li><a href="../455000/index.html">Cuidado de mudarse a los Pa√≠ses Bajos con su esposa. Parte 3: trabajo, colegas y otra vida.</a></li>
<li><a href="../455006/index.html">Control remoto de tres comandos con un programa de 290 palabras de 16 bits.</a></li>
<li><a href="../455008/index.html">Web sem√°ntica y datos vinculados. Correcciones y adiciones</a></li>
<li><a href="../455010/index.html">Scripts de usuario asincr√≥nicos en Rust puro sin marcos y SMS</a></li>
<li><a href="../455012/index.html">Preguntas frecuentes sobre intercepci√≥n celular: ¬øQu√© son los interceptores / SCAT IMSI y puedo proteger contra ellos?</a></li>
<li><a href="../455016/index.html">Creamos el sitio m√°s inaccesible con una calificaci√≥n ideal Faro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>