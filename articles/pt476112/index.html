<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòî üëãüèº üíé Elixir como objetivo de desenvolvimento para python ass√≠ncrono üïå üé° üåµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No livro ‚ÄúPython. Para as alturas da excel√™ncia ‚ÄùLuciano Ramallo descreve uma hist√≥ria. Em 2000, Luciano fez cursos e, uma vez que Guido van Rossum ol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elixir como objetivo de desenvolvimento para python ass√≠ncrono</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476112/">  No livro ‚ÄúPython.  Para as alturas da excel√™ncia ‚ÄùLuciano Ramallo descreve uma hist√≥ria.  Em 2000, Luciano fez cursos e, uma vez que Guido van Rossum olhou para a plat√©ia.  Quando esse evento apareceu, todos come√ßaram a fazer perguntas.  Quando perguntado sobre quais fun√ß√µes o Python emprestou de outras linguagens, Guido respondeu: "Tudo o que √© bom no Python √© roubado de outras linguagens". <br><br>  √â mesmo.  O Python vive h√° muito tempo no contexto de outras linguagens de programa√ß√£o e absorve conceitos de seu ambiente: o ass√≠ncio √© emprestado, gra√ßas ao surgimento de express√µes lambp do Lisp, e o Tornado foi copiado do libevent.  Mas se algu√©m empresta id√©ias, s√£o as de Erlang.  Ele foi criado h√° 30 anos e todos os conceitos em Python que est√£o sendo implementados ou est√£o apenas esbo√ßados est√£o trabalhando em Erlang h√° muito tempo: v√°rios n√∫cleos, mensagens como base de comunica√ß√£o, chamadas de m√©todo e introspec√ß√£o dentro de um sistema de produ√ß√£o ao vivo.  Essas id√©ias, de uma forma ou de outra, encontram sua express√£o em sistemas como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seastar.io</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/0x/mf/fb0xmfg8afpsrhs7js423v4bvjy.jpeg" width="500"></div><br>  Se voc√™ n√£o levar em considera√ß√£o a Data Science, na qual o Python est√° fora de competi√ß√£o, tudo o mais j√° est√° implementado no Erlang: trabalhando com uma rede, lidando com HTTP e soquetes da web, trabalhando com bancos de dados.  Portanto, √© importante que os desenvolvedores de Python entendam para onde a linguagem se mover√°: ao longo de uma estrada que j√° passou h√° 30 anos. <br><br>  Para entender a hist√≥ria do desenvolvimento de outras linguagens e entender onde o progresso est√° progredindo, convidamos <strong>Maxim Lapshin</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">erlyvideo</a> ), autor do projeto Erlyvideo.ru, para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Moscow Python Conf ++</a> . <br><br>  Sob o corte est√° a vers√£o em texto deste relat√≥rio, a saber: em que dire√ß√£o o sistema √© for√ßado a se desenvolver, que continua a migrar do c√≥digo linear simples para o libevent e al√©m, o que √© comum e quais s√£o as diferen√ßas entre o Elixir e o Python.  Prestaremos aten√ß√£o especial em como gerenciar soquetes, threads e dados em diferentes linguagens e plataformas de programa√ß√£o. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RAZ0sHpPrZE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  O Erlyvideo.ru possui um sistema de vigil√¢ncia por v√≠deo no qual o controle de acesso para c√¢meras √© escrito em Python.  Essa √© uma tarefa cl√°ssica para esse idioma.  Existem usu√°rios e c√¢meras, v√≠deos nos quais eles podem assistir: algu√©m v√™ algumas c√¢meras, enquanto outros veem um site comum. <br><br>  O Python foi escolhido porque √© conveniente escrever um servi√ßo assim: afinal, existem frameworks, ORMs, programadores.  O software desenvolvido √© empacotado e vendido aos usu√°rios.  Erlyvideo.ru √© uma empresa que vende software e n√£o apenas fornece servi√ßos. <br><br>  Quais problemas com Python eu quero resolver. <br><br>  <strong>Por que existem tais problemas com multicore?</strong>  Rodamos o Flussonic em computadores est√°dios antes mesmo da Intel.  Mas o Python tem dificuldades com isso: por que ainda n√£o est√° usando todos os 80 n√∫cleos de nossos servidores para funcionar? <br><br>  <strong>Como n√£o sofrer soquetes abertos?</strong>  Monitorar o n√∫mero de soquetes abertos √© um grande problema.  Quando atingir o limite, feche e evite vazamentos tamb√©m. <br><br>  <strong>As vari√°veis ‚Äã‚Äãglobais esquecidas t√™m uma solu√ß√£o?</strong>  Vazar vari√°veis ‚Äã‚Äãglobais √© um inferno para qualquer linguagem de coleta de lixo como Java ou C #. <br><br>  <strong>Como usar o ferro sem desperdi√ßar recursos?</strong>  Como sobreviver sem executar 40 trabalhadores Jung e 64 GB de RAM, se quisermos usar servidores com efici√™ncia e n√£o gastar centenas de milhares de d√≥lares por m√™s em hardware desnecess√°rio? <br><br><h3>  Por que o multicore √© necess√°rio </h3><br>  <strong>Para que todos os n√∫cleos sejam totalmente utilizados,</strong> s√£o necess√°rios muito mais trabalhadores do que n√∫cleos.  Por exemplo, para 40 n√∫cleos de processador, s√£o necess√°rios 100 trabalhadores: um trabalhador foi ao banco de dados e o outro est√° ocupado com outra coisa. <br><br>  <strong>Um trabalhador pode consumir 300-400 MB</strong> .  Ainda estamos escrevendo isso em Python, e n√£o em Ruby on Rails, que pode consumir v√°rias vezes mais e 40 GB de RAM ser√£o desperdi√ßados com facilidade e facilidade.  N√£o √© muito caro, mas por que comprar mem√≥ria onde voc√™ n√£o pode comprar. <br><br>  <strong>O multi-core ajuda a atrapalhar os dados compartilhados e a reduzir o consumo de mem√≥ria</strong> , executando de maneira conveniente e segura muitos processos independentes.  √â muito mais f√°cil programar, mas mais caro da mem√≥ria. <br><br><h3>  Gerenciamento de soquete </h3><br>  No soquete da web, pesquisamos os dados de tempo de execu√ß√£o das c√¢meras a partir do back-end.  O software Python se conecta √† Flussonic e pesquisa os dados de status das c√¢meras: funcionem ou n√£o, existem novos eventos. <br><br>  Por outro lado, o cliente se conecta e, atrav√©s do soquete da Web, enviamos esses dados para o navegador.  Queremos transferir dados do cliente em tempo real: a c√¢mera ligou e desligou, o gato comeu, dormiu, rasgou um sof√°, apertou o bot√£o e afastou o gato. <br><br>  Mas, por exemplo, ocorreu algum tipo de problema: o banco de dados n√£o respondeu √† solicita√ß√£o, todo o c√≥digo caiu, havia dois soquetes abertos.  Come√ßamos a recarregar, fizemos alguma coisa, mais uma vez esse problema - havia dois soquetes.  O erro do banco de dados foi processado incorretamente e duas conex√µes abertas travaram.  Com o tempo, isso leva a vazamentos de soquetes. <br><br><h3>  Vari√°veis ‚Äã‚Äãglobais esquecidas </h3><br>  Criou um ditado global para a lista de navegadores conectados via soquete da web.  Uma pessoa faz login no site, abrimos um soquete da web para ele.  Em seguida, colocamos o soquete da web com seu identificador em algum tipo de ditado global e acontece que ocorre algum tipo de erro. <br><br>  Por exemplo, eles gravaram um link de conex√£o no dict para enviar dados.  <strong>Uma exce√ß√£o funcionou, esqueci de excluir o link e os dados travaram</strong> .  Ent√£o, depois de algum tempo, 64 GB est√£o come√ßando a ser perdidos e quero dobrar a mem√≥ria no servidor.  Esta n√£o √© uma solu√ß√£o, porque os dados vazam de qualquer maneira. <br><blockquote>  Sempre cometemos erros - somos pessoas e n√£o podemos acompanhar tudo. </blockquote>  A quest√£o √© que alguns erros ocorrem, mesmo aqueles que n√£o esper√°vamos ver. <br><br><h2>  Excurs√£o hist√≥rica </h2><br>  Para chegar ao t√≥pico principal, vamos nos aprofundar na hist√≥ria.  Tudo o que estamos falando sobre Python, Go e Erlang agora, outras pessoas seguiram esse caminho cerca de 30 anos atr√°s.  N√≥s, em Python, percorremos um longo caminho e preenchemos os obst√°culos que j√° foram ultrapassados ‚Äã‚Äãd√©cadas atr√°s.  O caminho se repete de uma maneira incr√≠vel. <br><br><h3>  Dos </h3><br>  Primeiro, vamos ao DOS, √© o mais pr√≥ximo.  Antes dele, havia coisas completamente diferentes e nem todo mundo est√° vivo que se lembra de computadores antes do DOS. <br><br>  <strong>O programa DOS ocupava o computador (quase) exclusivamente</strong> .  Enquanto um jogo, por exemplo, est√° sendo executado, nada mais √© executado.  Voc√™ n√£o acessa a Internet - ainda n√£o est√° l√° e nem chega a lugar algum.  Foi triste, mas as lembran√ßas s√£o quentes, porque est√£o associadas √† juventude. <br><br><h3>  Multitarefa cooperativa </h3><br>  Como foi realmente doloroso com o DOS, novos desafios surgiram, os computadores se tornaram mais poderosos.  <strong>D√©cadas atr√°s, eles desenvolveram o conceito de multitarefa cooperativa</strong> , mesmo antes do Windows 3.11. <br><br>  <strong>Os dados s√£o separados por processos e cada processo √© executado separadamente:</strong> eles s√£o de alguma forma protegidos um do outro.  Um c√≥digo incorreto em um processo n√£o poder√° estragar o c√≥digo no navegador (os primeiros navegadores j√° apareceram). <br><br>  A pr√≥xima pergunta √©: como o tempo de computa√ß√£o ser√° distribu√≠do entre diferentes processos?  Depois, n√£o havia mais do que um n√∫cleo; um sistema com processador duplo era uma raridade.  O esquema era o seguinte: enquanto um processo foi, por exemplo, para um disco para dados, o segundo processo recebe controle do sistema operacional.  O primeiro ser√° capaz de obter o controle quando o segundo for voluntariamente.  Simplifico bastante a situa√ß√£o, mas o <strong>processo de alguma forma permitiu voluntariamente remov√™-la do processador</strong> . <br><br><h3>  Multitarefa preemptiva </h3><br>  A multitarefa cooperativa levou ao seguinte problema: o processo pode travar porque est√° mal escrito.  <strong>Se o processador demorar muito para processar, ele bloqueia o restante</strong> .  Nesse caso, o computador travou e nada p√¥de ser feito com ele, por exemplo, alternando a janela. <br><br>  Em resposta a esse problema, a multitarefa preventiva foi inventada.  O pr√≥prio sistema operacional agora dirige estritamente: remove processos da execu√ß√£o, separa completamente seus dados, protege a mem√≥ria do processo e proporciona a todos uma certa quantidade de tempo computacional.  <strong>O sistema operacional aloca os mesmos intervalos de tempo para cada processo</strong> . <br><br>  A quest√£o do prazo ainda est√° em aberto.  Hoje, os desenvolvedores de sistemas operacionais ainda est√£o apresentando o que √© certo, em que ordem, para quem e quanto tempo dar para o gerenciamento.  Hoje vemos o desenvolvimento dessas id√©ias. <br><br><h3>  Streams </h3><br>  Mas isso n√£o foi suficiente.  Os processos precisam trocar dados: atrav√©s da rede √© caro, de alguma forma ainda complicado.  Portanto, o <strong>conceito de fluxos</strong> foi inventado. <br><blockquote>  Threads s√£o processos leves que compartilham uma mem√≥ria comum. <br></blockquote>  Os fluxos foram criados com a esperan√ßa de que tudo seja f√°cil, simples e divertido.  Agora <strong>a programa√ß√£o multithread √© considerada antipadr√£o</strong> .  Se a l√≥gica de neg√≥cios estiver escrita em threads, √© prov√°vel que esse c√≥digo seja descartado, porque provavelmente h√° erros nele.  Se parece que n√£o h√° erros, voc√™ simplesmente ainda n√£o os encontrou. <br><br>  A programa√ß√£o multithread √© uma coisa extremamente complexa.  Existem poucas pessoas que realmente se dedicaram √† capacidade de escrever em t√≥picos e obtiveram algo realmente funcionando. <br><br>  Enquanto isso, <strong>computadores com v√°rios n√∫cleos</strong> apareceram.  Eles trouxeram coisas terr√≠veis com eles.  Foi adotada uma abordagem completamente diferente dos dados, surgiram perguntas com a localidade dos dados, agora voc√™ precisa entender a partir de qual kernel voc√™ acessa quais dados. <br><br>  Um n√∫cleo precisa colocar os dados aqui, o outro ali, e em nenhum caso confundir essas coisas, porque os clusters realmente apareceram dentro do computador.  Dentro de um computador moderno, existe um cluster quando parte da mem√≥ria √© soldada em um n√∫cleo e a outra em outro.  O tempo de tr√¢nsito entre esses dados pode variar em ordens de magnitude. <br><br><h2>  Exemplos de Python </h2><br>  Considere um exemplo simples de "Servi√ßo para ajudar o cliente".  Ele seleciona o melhor pre√ßo para a mercadoria em v√°rias plataformas: dirigimos em nome da mercadoria e procuramos preg√µes com um pre√ßo m√≠nimo. <br><br>  Este √© o c√≥digo no antigo Django, Python 2. Hoje n√£o √© muito popular, poucas pessoas iniciam projetos nele. <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view(['GET']) def best_price(request): name = request.GET['name'] price1 = http_fetch_price('market.yandex.ru', name) price2 = http_fetch_price('ebay.com', name) price3 = http_fetch_price('taobao.com', name) return Response(min([price1,price2,price3]))</span></span></code> </pre> <br>  Uma solicita√ß√£o chega, vamos para um back-end e depois para outro.  Nos locais em que <code>http_fetch_price</code> √© <code>http_fetch_price</code> , os threads s√£o bloqueados.  Neste momento, todo o trabalhador embarca em uma viagem ao Yandex.Market, depois ao eBay, at√© um tempo limite em Taobao e, no final, d√° uma resposta.  <strong>Todo esse tempo todo o trabalhador est√° de p√©</strong> . <br><br>  √â muito dif√≠cil pesquisar v√°rios back-ends ao mesmo tempo.  Essa √© uma situa√ß√£o ruim: a mem√≥ria √© consumida, √© necess√°rio o lan√ßamento de um grande n√∫mero de trabalhadores e o monitoramento de todo o servi√ßo.  √â necess√°rio analisar a frequ√™ncia com que essas solicita√ß√µes s√£o necess√°rias, voc√™ ainda precisa executar trabalhadores ou existem outras extras novamente.  Esses s√£o os mesmos problemas de que falei.  <strong>√â necess√°rio interrogar v√°rios back-ends, por sua vez</strong> . <br><br>  O que vemos no Python?  <strong>Um processo por tarefa,</strong> no Python ainda n√£o h√° multicore.  A situa√ß√£o √© clara: nos idiomas desta classe, √© dif√≠cil criar um multicore simples e seguro, porque isso <strong>prejudica o desempenho</strong> . <br><br>  Se voc√™ usar o dict a partir de threads diferentes, o acesso aos dados poder√° ser escrito assim: cole duas inst√¢ncias do Python na mem√≥ria para que eles removem os dados - eles simplesmente os quebram.  Por exemplo, para ditar e n√£o quebrar nada, voc√™ precisa colocar mutexes na frente dele.  Se houver um mutex antes de cada ditado, o sistema diminuir√° a velocidade cerca de 1000 vezes - ser√° simplesmente inconveniente.  √â dif√≠cil arrast√°-lo para um multicore. <br><br>  Temos <strong>apenas um segmento de execu√ß√£o</strong> e <strong>apenas processos podem ser escalados</strong> .  De fato, reinventamos o DOS dentro do processo - a linguagem de script de 2010.  Dentro do processo, h√° algo que se assemelha ao DOS: enquanto estamos fazendo algo, todos os outros processos n√£o funcionam.  Ningu√©m gostou do enorme aumento de custos e da resposta lenta. <br><br>  <b>Os reatores Socket</b> apareceram em Python h√° algum tempo, embora o pr√≥prio conceito tenha nascido h√° muito tempo.  Agora voc√™ pode esperar a disponibilidade de v√°rios soquetes de uma s√≥ vez. <br><br>  A princ√≠pio, o reator ficou em demanda em servidores como o nginx.  Inclusive devido ao uso correto dessa tecnologia, ela se tornou popular.  Em seguida, o conceito entrou nas linguagens de script como Python e Ruby. <br><blockquote>  A id√©ia do reator √© que passamos √† programa√ß√£o orientada a eventos. </blockquote><br><h2>  Programa√ß√£o Orientada a Eventos </h2><br>  Um contexto de execu√ß√£o produz uma solicita√ß√£o.  Enquanto aguarda uma resposta, um contexto diferente est√° sendo executado.  Vale ressaltar que quase passamos pelo mesmo est√°gio de evolu√ß√£o que a transi√ß√£o do DOS para o Windows 3.11.  Somente pessoas fizeram isso 20 anos antes, e em Python e Ruby apareceu 10 anos atr√°s. <br><br><h3>  Torcido </h3><br>  Essa √© uma estrutura de rede orientada a eventos.  Apareceu em 2002 e est√° escrito em Python.  Peguei o exemplo acima e o reescrevi no Twisted. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_GET</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> price1 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) dl = defer.DeferredList([price1,price2,price3]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prices)</span></span></span><span class="hljs-function">:</span></span> request.write(<span class="hljs-string"><span class="hljs-string">'%d'</span></span>.format(min(prices))) request.finish() dl.addCallback(reply) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.NOT_DONE_YET</code> </pre> <br>  Pode haver erros, imprecis√µes e a manipula√ß√£o not√≥ria de erros n√£o √© suficiente.  Mas o esquema aproximado √© o seguinte: n√£o fazemos uma solicita√ß√£o, mas pedimos que a solicite algum tempo depois, quando houver tempo.  Na linha com <code>defer.DeferredList</code> , queremos coletar as respostas de v√°rias consultas. <br><br>  De fato, o c√≥digo consiste em duas partes.  Na primeira parte, o que aconteceu antes da solicita√ß√£o e na segunda, o que foi depois. <br><blockquote>  Toda a hist√≥ria da programa√ß√£o orientada a eventos est√° saturada com a dor de quebrar o c√≥digo linear em "antes da solicita√ß√£o" e "ap√≥s a solicita√ß√£o". </blockquote>  Isso d√≥i porque os trechos de c√≥digo s√£o misturados: as √∫ltimas linhas ainda s√£o executadas na solicita√ß√£o original e a fun√ß√£o de <code>reply</code> ser√° chamada depois. <br><br>  N√£o √© f√°cil ter em mente exatamente porque quebramos o c√≥digo linear, mas tinha que ser feito.  Sem entrar em detalhes, o c√≥digo que foi reescrito do Django para o Twisted <strong>produzir√° uma pseudo-acelera√ß√£o completamente incr√≠vel</strong> . <br><br><h3>  Id√©ia torcida </h3><blockquote>  Um objeto pode ser ativado quando o soquete estiver pronto. </blockquote>  Pegamos objetos nos quais coletamos os dados necess√°rios do contexto e vinculamos sua ativa√ß√£o ao soquete.  A disponibilidade do soquete √© agora um dos controles mais importantes para todo o sistema.  Objetos ser√£o nossos contextos. <br><br>  Mas, ao mesmo tempo, a linguagem ainda separa o pr√≥prio conceito do contexto de execu√ß√£o no qual vivem as exce√ß√µes.  <strong>O contexto de execu√ß√£o vive separadamente dos objetos e √© vagamente conectado a eles</strong> .  Aqui, o problema surge com o fato de estarmos tentando coletar dados dentro de objetos: n√£o h√° como ficar sem eles, mas a linguagem n√£o o suporta. <br><br>  Tudo isso leva a um inferno cl√°ssico de retorno de chamada.  Por que, por exemplo, eles amam o Node.js - at√© recentemente, n√£o havia outros m√©todos, mas ele ainda aparecia no Python.  O problema √© que h√° <strong>quebras de c√≥digo nos pontos de E / S externas</strong> que levam ao retorno de chamada. <br><br>  H√° muitas perguntas.  √â poss√≠vel "colar" as bordas da lacuna no c√≥digo?  √â poss√≠vel voltar ao c√≥digo humano normal?  O que fazer se um objeto l√≥gico funcionar com dois soquetes e um deles estiver fechado?  Como n√£o esquecer de fechar o segundo?  √â poss√≠vel usar de alguma forma todos os n√∫cleos? <br><br><h3>  Async io </h3><br>  Uma boa resposta para essas perguntas √© E / S ass√≠ncrona.  Este √© um passo √≠ngreme para a frente, embora n√£o seja f√°cil.  OI ass√≠ncrono √© uma coisa complicada, sob o cap√¥ do qual existem muitas nuances dolorosas. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> name = request.GET[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] price1 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) prices = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait([price1,price2,price3]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(prices)</code> </pre> <br>  A diferen√ßa de c√≥digo est√° oculta na sintaxe <code>async/await</code> .  Pegamos tudo o que era antes, mas n√£o fomos para a rede nesse c√≥digo.  Removemos o <code>Callback(reply)</code> , que estava no exemplo anterior, e o escondemos atr√°s de <code>await</code> - o local onde o c√≥digo ser√° cortado com uma tesoura.  Ele ser√° dividido em duas partes: a parte de chamada e a parte de retorno de chamada, que processa os resultados. <br><br>  Este √© um <strong>√≥timo a√ß√∫car sint√°tico</strong> .  Existem m√©todos para colar v√°rias expectativas em uma.  Isso √© legal, mas h√° uma nuance: <strong>tudo pode ser quebrado por um soquete "cl√°ssico"</strong> .  No Python, ainda h√° um grande n√∫mero de bibliotecas que acessam o soquete de forma s√≠ncrona, criam uma <code>timer library</code> e estragam tudo para voc√™.  Como depurar isso, eu n√£o sei. <br><br>  Mas o <strong>ass√≠ncio n√£o ajuda com vazamentos e multicore</strong> .  Portanto, n√£o h√° mudan√ßas fundamentais, embora tenha se tornado melhor. <br><br>  Ainda temos todos os problemas sobre os quais falamos no in√≠cio: <br><br><ul><li>  f√°cil vazar com soquetes; </li><li>  f√°cil deixar links em vari√°veis ‚Äã‚Äãglobais; </li><li>  tratamento de erros muito meticuloso; </li><li>  ainda √© dif√≠cil fazer multi-core. </li></ul><br><h3>  O que fazer </h3><br>  Se tudo isso vai evoluir, eu n√£o sei, mas mostrarei a implementa√ß√£o em outros idiomas e plataformas. <br><br>  <strong>Contextos de execu√ß√£o isolados.</strong>  Nos contextos de execu√ß√£o, os resultados s√£o acumulados, os soquetes s√£o mantidos: objetos l√≥gicos nos quais geralmente armazenamos todos os dados sobre retornos de chamada e soquetes.  Um conceito: pegue contextos de execu√ß√£o, cole-os em segmentos de execu√ß√£o e isole-os completamente um do outro. <br><br>  <strong>Mudan√ßa de paradigma de objetos.</strong>  Vamos conectar o contexto ao segmento de execu√ß√£o.  Existem an√°logos, isso n√£o √© algo novo.  Se algu√©m tentou editar o c√≥digo-fonte do Apache e escrever m√≥dulos para eles, ele sabe que existe um pool de Apache.  <strong>N√£o s√£o permitidos links</strong> entre os pools do Apache.  Os dados de um pool do Apache - o pool associado √†s solicita√ß√µes, est√£o localizados dentro dele e voc√™ n√£o pode obter nada com isso. <br><br>  Teoricamente, √© poss√≠vel, mas se voc√™ fizer isso, algu√©m repreender√° ou n√£o aceitar√° o patch ou ter√° uma depura√ß√£o longa e dolorosa na produ√ß√£o.  Depois disso, ningu√©m far√° isso e permitir√° que outros fa√ßam essas coisas.  √â simplesmente imposs√≠vel se referir a dados entre contextos, √© necess√°rio isolamento completo. <br><br>  Como trocar atividades?  O que √© necess√°rio n√£o s√£o pequenas m√¥nadas, que s√£o fechadas entre si e n√£o se comunicam.  Precisamos que eles se comuniquem.  Uma abordagem √© a troca de mensagens.  Esse √© aproximadamente o caminho que o Windows seguiu ao trocar mensagens entre processos.  Em um sistema operacional normal, voc√™ n√£o pode fornecer um link para a mem√≥ria de outro processo, mas pode sinalizar pela rede, como no UNIX, ou atrav√©s de mensagens, como no Windows. <br><br>  <strong>Todos os recursos dentro do processo e do contexto se tornam um encadeamento de execu√ß√£o</strong> .  Colamos juntos: <br><br><ul><li>  dados de tempo de execu√ß√£o em uma m√°quina virtual na qual ocorrem exce√ß√µes; </li><li>  o segmento de execu√ß√£o, como o que est√° sendo executado no processador; </li><li>  Um objeto no qual todos os dados s√£o coletados logicamente. </li></ul><br>  Parab√©ns - n√≥s inventamos o UNIX dentro de uma linguagem de programa√ß√£o!  Esta ideia foi inventada por volta de 1969.  At√© o momento, ele ainda n√£o est√° em Python, mas √© prov√°vel que o Python chegue a isso.  E talvez ela n√£o venha - eu n√£o sei. <br><br><h3>  O que isso d√° </h3><br>  Primeiro de tudo, <strong>controle autom√°tico sobre recursos</strong> .  No Moscow Python Conf ++ 2019, eles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disseram</a> que voc√™ pode escrever um programa no Go e processar todos os erros.  O programa permanecer√° como uma luva e funcionar√° por meses.  Isso √© verdade, mas n√£o lidamos com todos os erros. <br><br>  Somos pessoas vivas, sempre temos prazos, o desejo de fazer algo √∫til e n√£o lidar com o 535¬∫ erro de hoje.  C√≥digo espalhado pelo tratamento de erros nunca causa sentimentos quentes em ningu√©m. <br><br>  Portanto, todos escrevemos ‚Äúcaminho feliz‚Äù e depois descobrimos isso na produ√ß√£o.  Sejamos honestos: somente quando voc√™ precisar processar algo, come√ßamos a processar.  A programa√ß√£o defensiva √© um pouco diferente e n√£o √© um desenvolvimento comercial. <br><br>  Portanto, <strong>quando temos autocontrole para erros - tudo bem</strong> .  Mas os sistemas operacionais o criaram h√° 50 anos: se algum processo morrer, tudo o que abrir ser√° fechado automaticamente.  Hoje ningu√©m precisa escrever um c√≥digo que limpe os arquivos por tr√°s do processo finalizado.  Isso n√£o existe h√° 50 anos em nenhum sistema operacional, mas no Python voc√™ ainda precisa seguir isso com cuidado e cuidado com as m√£os.  Isso √© estranho. <br><br>  <strong>Voc√™ pode levar a computa√ß√£o pesada para um contexto diferente</strong> , mas j√° pode ir para outro n√∫cleo.  N√≥s compartilhamos os dados, n√£o precisamos mais de mutexes.  Voc√™ pode enviar os dados em um contexto diferente, dizer: "Voc√™ far√° isso em algum lugar e, em seguida, deixe-me saber que voc√™ terminou e fez alguma coisa". <br><br>  <strong>Uma implementa√ß√£o ass√≠ncrona sem as palavras "async / waitit"</strong> .  Mais uma pequena ajuda da m√°quina virtual, do tempo de execu√ß√£o.  √â sobre isso que conversamos com <code>async/await</code> : voc√™ tamb√©m pode converter em mensagens, remover <code>async/await</code> e obt√™-lo no n√≠vel da m√°quina virtual. <br><br><h2>  Processos Erlang </h2><br>  Erlang foi inventado h√° 30 anos.  Os caras barbudos, que n√£o estavam muito barbudos na √©poca, olharam para o UNIX e transferiram todos os conceitos para a linguagem de programa√ß√£o.  Eles decidiram que agora teriam suas pr√≥prias coisas para dormir √† noite e silenciosamente iriam pescar sem um computador.  Ainda n√£o havia laptops, mas os caras barbudos j√° sabiam que isso deveria ser pensado com anteced√™ncia. <br><br>  <strong>Temos Erlang (Elixir) - contextos ativos que se executam</strong> .  Al√©m disso, meu exemplo sobre Erlang.  No Elixir, parece o mesmo, com algumas varia√ß√µes. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Name)</span></span></span><span class="hljs-function"> -&gt;</span></span> Price1 = spawn_price_fetcher('market.yandex.ru', Name), Price2 = spawn_price_fetcher('ebay.com', Name), Price3 = spawn_price_fetcher('taobao.com', Name), lists:min(wait4([Price1,Price2,Price3])).</code> </pre> <br>  Lan√ßamos v√°rios buscadores - esses s√£o v√°rios novos contextos separados que estamos esperando.  Eles esperaram, coletaram os dados e retornaram o resultado como o pre√ßo m√≠nimo.  Tudo isso √© semelhante ao <code>async/await</code> , mas sem as palavras "ass√≠ncrono / espera". <br><br><h3>  Recursos do Elixir </h3><br>  O Elixir est√° localizado na base de Erlang, e todos os conceitos de linguagem s√£o portados silenciosamente para o Elixir.  Quais s√£o as suas caracter√≠sticas? <br><br>  <strong>Proibi√ß√£o de links entre processadores.</strong>  Por processo, quero dizer um processo leve dentro de uma m√°quina virtual - contexto.  Simplificado, se portado para Python, links de dados dentro de outro objeto s√£o proibidos em Erlang.  Voc√™ pode ter um link para o objeto inteiro como uma caixa fechada, mas n√£o pode fazer refer√™ncia aos dados dentro dele.  Voc√™ n√£o pode nem sintaticamente obter um ponteiro para dados que est√£o dentro de outro objeto.  Voc√™ s√≥ pode saber sobre o pr√≥prio objeto. <br><br>  <strong>N√£o h√° mutexes dentro de processos (objetos).</strong>  Isso √© importante - pessoalmente, nunca quero interpor minha hist√≥ria com a hist√≥ria da depura√ß√£o de voos multithread para produ√ß√£o.  Eu n√£o desejo isso para ningu√©m. <br><br>  <strong>Os processos podem se mover pelos n√∫cleos, √© seguro.</strong>  N√£o precisamos mais ignorar, como em Java, v√°rios outros <code>pointer</code> e reescrev√™-los ao mover dados de um lugar para outro: n√£o temos dados e links internos comuns.  Por exemplo, de onde vem o problema da escassez de quadril?  Devido ao fato de algu√©m se referir a esses dados. <br><br>  Se transferirmos dados dentro do heap para outro local para compacta√ß√£o, precisamos percorrer todo o sistema.  Ele pode ocupar dezenas de gigabytes e atualizar todos os ponteiros - isso √© loucura. <br><br>  <strong>Seguran√ßa total do thread</strong> , devido ao fato de toda a comunica√ß√£o passar por mensagens.  Com a rendi√ß√£o de tudo isso, tivemos um <strong>processo de exclus√£o</strong> .  Ele entendeu f√°cil e barato. <br><br>  <strong>Mensagens como base da comunica√ß√£o.</strong>  Objetos internos, chamadas de fun√ß√µes comuns e entre objetos de mensagens.  A chegada de dados da rede √© uma mensagem, a resposta de outro objeto √© uma mensagem, outra coisa fora tamb√©m √© uma mensagem em uma fila de entrada.  Isso n√£o est√° no UNIX porque n√£o foi criado. <br><br>  <strong>Chamadas de m√©todo.</strong>  Temos objetos que chamamos de processos.  M√©todos em processos s√£o chamados por meio de mensagens. <br><br>  <strong>Os m√©todos de chamada tamb√©m est√£o enviando uma mensagem.</strong>  √â √≥timo que agora isso possa ser feito com um tempo limite.  Se algo nos responde lentamente, chamamos o m√©todo em outro objeto.  Mas, ao mesmo tempo, dizemos que estamos prontos para esperar n√£o mais de 60 s, porque eu tenho um cliente com um tempo limite de 70 s.  Vou precisar dizer a ele "503" - venha amanh√£, agora eles n√£o est√£o esperando por voc√™. <br><br>  Al√©m disso, a <strong>resposta para a liga√ß√£o pode ser adiada</strong> .  Dentro do objeto, voc√™ pode aceitar a solicita√ß√£o para chamar o m√©todo e dizer: "Sim, sim, eu vou te largar agora, volte em meia hora, eu responderei."  Voc√™ n√£o pode falar, mas silenciosamente reserve.  √Äs vezes usamos. <br><br><h3>  Como trabalhar com uma rede? </h3><br>  Voc√™ pode escrever c√≥digo linear, retornos de chamada ou no estilo de <code>asyncio.gather</code> .  Um exemplo de como isso ficar√°. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([ ])</span></span></span><span class="hljs-function"> -&gt;</span></span> [ ]; wait4(List) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">receive</span></span> {reply, Pid, Price} -&gt; [Price] ++ wait4(List -- [Pid]) <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">60000</span></span> -&gt; [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br>  Na fun√ß√£o <code>wait4</code> do exemplo anterior, <code>wait4</code> sobre a lista daqueles de quem ainda estamos esperando respostas.  Se, usando o m√©todo de <code>receive</code> , <code>receive</code> uma mensagem desse processo, escrevemos na lista.  Se a lista terminar, retornamos tudo o que havia e acumulamos a lista.  Pedimos ao mesmo tempo tr√™s objetos para nos conduzir os dados.  Se eles n√£o conseguiram gerenciar juntos em 60 segundos e pelo menos um deles n√£o respondeu OK, teremos uma lista vazia.  Mas √© importante que tenhamos um tempo limite geral para uma solicita√ß√£o imediatamente para um monte de objetos. <br><br>  Algu√©m pode dizer: "Pense, libcurl tem a mesma coisa."  Mas aqui √© importante que, por outro lado, possa haver n√£o apenas uma viagem HTTP, mas tamb√©m uma viagem ao banco de dados, bem como alguns c√°lculos, por exemplo, calculando algum tipo de n√∫mero ideal para o cliente. <br><br><h3>  Tratamento de erros </h3><br>  <strong>Os erros foram transmitidos do fluxo para o objeto, que agora s√£o o mesmo</strong> .  Agora, o pr√≥prio erro fica anexado n√£o ao encadeamento, mas ao objeto em que foi executado. <br><br>  Isso √© muito mais l√≥gico.  Geralmente, quando desenhamos todos os tipos de pequenos quadrados e c√≠rculos no quadro, na esperan√ßa de que eles ganhem vida e tragam resultados e dinheiro, geralmente desenhamos objetos, n√£o os fluxos nos quais esses objetos ser√£o executados.  Por exemplo, na entrega, podemos receber uma <strong>mensagem</strong> autom√°tica <strong>sobre a morte de outro objeto</strong> . <br><br><h3>  Introspec√ß√£o ou depura√ß√£o na produ√ß√£o </h3><br>  O que poderia ser melhor do que ir ao produto e debitar, especialmente se o erro ocorrer apenas sob carga durante o hor√°rio de pico.  Na hora do rush, dizemos: <br><br>  <em>- Vamos l√°, vou reiniciar agora!</em> <br>  <em>- Saia pela porta e reinicie outra pessoa!</em> <br><br>  Aqui podemos entrar em um sistema vivo que est√° sendo executado no momento e n√£o est√° especialmente preparado para isso.  Para fazer isso, voc√™ n√£o precisa reinici√°-lo com o criador de perfil, com o depurador, reconstru√≠do. <br><br>  <strong>Sem qualquer perda de desempenho em um sistema de produ√ß√£o ao vivo,</strong> podemos olhar para uma lista de processos: o que h√° dentro deles, como tudo funciona, jog√°-los no lixo, verificar o que acontece com eles.  Tudo isso √© gratuito fora da caixa. <br><br><h3>  B√≥nus </h3><br>  <strong>O c√≥digo √© super confi√°vel.</strong>  Por exemplo, o Python tem fragilidade com o <code>old vs async</code> e permanecer√° por cinco anos, nada menos.  Considerando a velocidade com que o Python 3 foi implementado, voc√™ n√£o deve esperar que seja r√°pido. <br><br>  <strong>Ler e rastrear mensagens √© mais f√°cil do que depurar retornos de chamada</strong> .  Isso √© importante.  Parece que, se ainda temos retornos de chamada para processar mensagens que podemos ver, o que √© melhor?  Pelo fato de as mensagens serem um dado na mem√≥ria.  Voc√™ pode olhar com os olhos e entender o que veio aqui.  Pode ser adicionado ao rastreador, obter uma lista de mensagens em um arquivo de texto.  Isso √© mais conveniente do que retornos de chamada. <br><br>  Gerenciamento de <strong>introspec√ß√£o</strong> e <strong>m√∫ltiplos n√∫cleos deslumbrante</strong> <strong>dentro de um sistema de</strong> produ√ß√£o <strong>ao vivo</strong> . <br><br><h3>  Os problemas </h3><br>  Naturalmente, Erlang tamb√©m tem problemas. <br><br>  <strong>Perda do desempenho m√°ximo</strong> devido ao fato de n√£o podermos mais nos referir a dados em outro processo ou objeto.  Temos que mov√™-los, mas isso n√£o √© gratuito. <br><br>  <strong>A sobrecarga de copiar dados entre processos.</strong>  Podemos escrever um programa em C que ser√° executado em todos os 80 n√∫cleos e processar uma matriz de dados, e assumiremos que o faz corretamente e corretamente.  Em Erlang, voc√™ n√£o pode fazer isso: voc√™ precisa cortar os dados com cuidado, distribu√≠-los por v√°rios processos, acompanhar tudo.  Essa comunica√ß√£o custa recursos - ciclos do processador. <br><br>  <strong>Qu√£o r√°pido ou lento √©?</strong>  Estamos escrevendo o c√≥digo Erlang h√° 10 anos.  O √∫nico concorrente que sobreviveu a esses 10 anos √© escrito em Java.  Com ele, temos uma paridade de desempenho quase completa: algu√©m diz que somos piores, algu√©m que eles s√£o.  Mas eles t√™m Java com todos os seus problemas, come√ßando com o JIT. <br><br>  Estamos escrevendo um programa que atende dezenas de milhares de soquetes e bombeia dezenas de GB de dados por si pr√≥prio.  De repente, verifica-se que, neste caso, a <strong>corre√ß√£o dos algoritmos e a capacidade de depurar tudo isso na produ√ß√£o s√£o mais importantes do que os poss√≠veis Java buns</strong> .  Bilh√µes de d√≥lares foram investidos nele, mas isso n√£o d√° ao Java JIT nenhuma vantagem m√°gica. <br><br>  Mas se quisermos medir benchmarks est√∫pidos e sem sentido, como "calcular os n√∫meros de Fibonacci", ent√£o aqui Erlang provavelmente ser√° ainda pior que Python ou compar√°vel. <br><br>  <strong>A sobrecarga da aloca√ß√£o de mensagens.</strong>  √Äs vezes d√≥i.  Por exemplo, temos algumas partes em C no c√≥digo e, nesses lugares, n√£o funcionou com Erlang.     ,      ,   . <br><br>    Erlang <strong>     </strong> ,   ,     .  ,    ,   <code>receive</code>  <code>send receive</code> .     ‚Äî   ,   .   <strong> ,   ,    </strong> . <br><br><h2>      Python </h2><br> <strong>   </strong> .        .       ,       Python  -     . <br><br> ,  <strong>   </strong> .  -     Python,      ,    20 ,   40. <br><br> , <strong>   </strong>  . - , ,     Elixir,   ,      . <br><br><blockquote>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Moscow Python Conf++</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  ,         6      4   .  ,   ,  )     ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>  . Call for Papers   13 ,     27 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt476112/">https://habr.com/ru/post/pt476112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt476102/index.html">Digite seguro trabalhando com matrizes PHP</a></li>
<li><a href="../pt476104/index.html">N√£o use MTProxy gratuito e outros tipos de proxies gratuitos ...</a></li>
<li><a href="../pt476106/index.html">‚ÄúProtocolos de sistemas de criptografia‚Äù: Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../pt476108/index.html">C√©rebro mut√°vel</a></li>
<li><a href="../pt476110/index.html">Por que a TI precisa de uma marca pessoal</a></li>
<li><a href="../pt476114/index.html">E se sem o Python? Julia para aprendizado de m√°quina e geralmente</a></li>
<li><a href="../pt476118/index.html">Design de interface para o jogo, desenhe um anel Havel de Dark Souls 3</a></li>
<li><a href="../pt476122/index.html">‚ÄúOu√ßa‚Äù o cosmos: da mat√©ria escura ao cometa Churyumov - Gerasimenko</a></li>
<li><a href="../pt476126/index.html">Como testar o desempenho do servidor: uma sele√ß√£o de v√°rios benchmarks de c√≥digo aberto</a></li>
<li><a href="../pt476128/index.html">Ivan Osipov e Yuri Artamonov sobre Kotlin e plugins para o IntelliJ IDEA na reuni√£o jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>