<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’™ âœŠğŸ¼ ğŸ§–ğŸ¾ Cadangan yang andal, aman, dan serbaguna untuk U2F ğŸ° ğŸˆ¸ ğŸ‘©ğŸ¾â€âš–ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya sangat suka tingkat keamanan yang disediakan oleh U2F, tetapi seiring dengan keamanan, Anda perlu mempertimbangkan rencana pemulihan. Kehilangan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cadangan yang andal, aman, dan serbaguna untuk U2F</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474300/">  Saya sangat suka tingkat keamanan yang disediakan oleh U2F, tetapi seiring dengan keamanan, Anda perlu mempertimbangkan rencana pemulihan.  Kehilangan akses ke akun terpenting Anda, jika terjadi sesuatu dengan token U2F utama, adalah masalah serius.  Pada saat yang sama, saya ingin menghindari menggunakan cadangan yang membahayakan keamanan yang disediakan oleh U2F. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/ae9/0a7/edeae90a73189ed879d63056d56afda5.jpg" alt="yubikey"></div><br><h2>  Metode pencadangan populer </h2><br>  Sampai saat ini, sudah merupakan praktik yang baik untuk memegang token U2F independen kedua untuk cadangan;  token ini harus ditambahkan secara manual ke setiap layanan dan disimpan di tempat "aman".  Praktik umum lainnya adalah menggunakan metode non-U2F sebagai cadangan (OTP, kode pemulihan).  Sejujurnya, kedua metode ini meninggalkan banyak yang harus diinginkan. <br><a name="habracut"></a><br><h3>  Token U2F Independen </h3><br>  Ini berarti bahwa setiap kali saya mendaftar pada beberapa layanan baru, saya perlu menambahkan kedua token saya.  Fakta ini menimbulkan sejumlah masalah: <br><br><ul><li>  Token cadangan harus cukup mudah diakses.  Terlepas dari kenyataan bahwa saya tidak akan membawanya dengan saya di gantungan kunci, saya harus dapat dengan cepat mendapatkannya, jadi saya hampir tidak dapat menghasilkan sesuatu yang lebih baik daripada menyimpannya di rumah.  Betapa nyata itu aman, bahkan jika brankas digunakan, Anda dapat berbicara untuk waktu yang lama; </li><li>  Ketika saya harus mendaftar untuk layanan saat jauh dari rumah, saya tidak dapat menambahkan token cadangan.  Jadi, Anda perlu mencoba mengingat bahwa Anda perlu menambahkannya nanti, dan sampai ini terjadi, tidak ada cadangan.  Dalam kasus terburuk, saya benar-benar bisa melupakannya; </li><li>  Ketika saya di rumah, kedua token saya berada di tempat yang sama.  Metode cadangan ini jauh dari ideal: kedua token mungkin tidak tersedia karena satu insiden (dihancurkan atau dicuri); </li><li>  Fakta bahwa token cadangan disimpan di rumah benar-benar jelas.  Jika seseorang benar-benar ingin mendapatkan token saya, dia sudah tahu di mana mencarinya; </li><li>  Metode non-universal: tidak semua layanan memungkinkan Anda untuk menambahkan lebih dari satu kunci ke akun Anda. </li></ul><br>  Menurut pendapat saya, "praktik teladan" ini tidak terlalu bisa diandalkan, dan agak memberatkan.  Mari kita lihat praktik umum lainnya. <br><br><h3>  Metode Non-U2F sebagai cadangan </h3><br>  OTP: <br><br><ul><li>  Menggunakan OTP sebagai cadangan lebih baik daripada menggunakannya sebagai metode 2FA utama, tetapi fakta memiliki OTP entah bagaimana membuka vektor serangan tambahan; </li><li>  Ponsel rusak, hilang dan dicuri, dan jika setelah kehilangan ada kemungkinan ponsel itu akan berada di tangan orang asing, maka Anda perlu mengingat cadangan ini secara manual di semua akun; </li><li>  Saya selalu membawa telepon <b>dan</b> token U2F, jadi sekali lagi, metode cadangan seperti itu jauh dari ideal: probabilitas kehilangan keduanya segera jauh lebih tinggi daripada jika cadangan disimpan secara terpisah.  Tetapi item ini dapat sedikit dikompensasi dengan menggunakan, misalnya, Authy, yang menyimpan cadangan terenkripsi di servernya; </li><li>  Metode non-universal: sayangnya, ada sejumlah layanan yang menawarkan hanya aplikasi khusus dan tidak mendukung TOTP standar. </li></ul><br>  Kode Pemulihan: <br><br><ul><li>  Kode pemulihan harus disimpan di tempat yang aman.  Sekali lagi, "tempat aman" ini kemungkinan besar akan menjadi rumah saya, dengan masalah yang hampir sama dengan token U2F yang terpisah; </li><li>  Sekali lagi, metode non-universal: setiap layanan memiliki pendekatan sendiri untuk cadangan </li></ul><br>  Jadi, untuk meringkas, semua metode ini tidak universal, memberatkan dan tidak terlalu aman. <br><br><h2>  Metode cadangan terbaik </h2><br>  Sekarang, setelah saya cukup mengkritik keadaan saat ini, saya akhirnya akan mengatakan apa yang sebenarnya saya inginkan.  Saya benar-benar ingin memiliki dua token U2F: primer dan cadangan, tetapi mereka harus dikonfigurasi dengan cara tertentu: <br><br><ul><li>  Ketika saya mendaftarkan token utama pada perangkat apa pun, token cadangan secara otomatis menjadi operasional untuk layanan ini; </li><li>  Segera setelah saya menggunakan token cadangan pada layanan apa pun, token utama tidak valid untuk layanan ini. </li></ul><br>  Sebelum kita membahas kelayakan teknis ini dalam U2F, saya akan menjelaskan mengapa ini bagus dan bagaimana saya menggunakannya. <br><br><h3>  Kenapa ini bagus? </h3><br>  Jika kita melihat kritik terhadap token cadangan independen yang dijelaskan di atas, kita dapat melihat bahwa semua kekurangan dari metode ini dihilangkan: <br><br><ul><li>  Token cadangan seharusnya tidak lagi mudah diakses.  Contoh ekstrem dapat berupa: memasang token di dalam dinding bata, atau mengubur satu setengah meter di taman atau di tempat lain.  Tidak bercanda, saya cukup siap untuk melakukannya; </li><li>  Di mana pun saya berada, jika saya mendaftar untuk layanan apa pun, saya tidak perlu melakukan apa pun untuk menambahkan token cadangan ke layanan ini.  Saya hanya menggunakan token utama saya, dan saya merasa tenang, mengetahui bahwa saya memiliki cadangan; </li><li>  Untuk orang luar, sama sekali tidak jelas di mana token cadangan saya berada.  Bahkan mengetahui bahwa itu ada, berusaha menemukannya sendiri hampir tidak masuk akal; </li><li>  Cukup aman.  Bahkan jika sesuatu yang buruk terjadi pada token utama saya, sangat tidak mungkin bahwa kejadian yang sama akan mempengaruhi token cadangan; </li><li>  Itu universal.  Metode cadangan ini akan berfungsi pada layanan apa pun yang mendukung U2F, apa pun yang didukung layanan ini. </li></ul><br>  Dan jika sesuatu yang buruk benar-benar terjadi dengan token utama, maka saya melakukan hal berikut: <br><br><ul><li>  Saya menggali / tidak jelas token cadangan; </li><li>  Otentikasi pada semua layanan saya dengan U2F, dengan demikian membatalkan token utama; </li><li>  Saya memesan sepasang token baru, dan setelah diterima, menambahkan token utama baru di semua layanan, dan mencabut yang lama. </li></ul><br>  Setidaknya bagi saya pribadi, strategi ini adalah kompromi yang bagus untuk tingkat keamanan yang tinggi dan beban cadangan yang mudah.  Ini lebih aman dan lebih dapat diandalkan daripada metode lainnya. <br><br><h2>  Implementasi </h2><br><h3>  Ikhtisar Protokol U2F </h3><br>  Sebelum kita dapat berbicara tentang implementasi, kita perlu memahami pada tingkat tertentu bagaimana U2F bekerja.  Sebagian besar pabrikan mengimplementasikannya sebagai berikut (tidak semua yang berikut ada dalam standar; beberapa hal adalah detail implementasi, tetapi sebagian besar implementasi yang ada, sejauh yang saya tahu, bekerja seperti itu): <br><br>  <code>device_secret</code> diprogram dalam token U2F, bersama dengan <code>counter</code> 32-bit, yang hanya dapat ditingkatkan.  Ketika kami mendaftarkan token U2F pada layanan, berikut ini terjadi: <br><br><ul><li>  Browser mengirim <code>AppID</code> (sebenarnya, nama domain) ke perangkat U2F; </li><li>  Perangkat menghasilkan angka acak ( <code>nonce</code> ), menggabungkannya dengan itu dengan <code>AppID</code> , melewati semuanya melalui HMAC-SHA256 menggunakan <code>device_secret</code> sebagai kunci, dan hash yang dihasilkan menjadi kunci pribadi untuk layanan khusus ini: <code>service_private_key</code> ; </li><li>  Dari <code>service_private_key</code> , kunci publik <code>service_public_key</code> dihasilkan; </li><li>  Perangkat mengambil <code>AppID</code> lagi, menggabungkannya dengan <code>service_private_key</code> , dan meneruskannya melalui HMAC-SHA256 lagi menggunakan kunci <code>device_secret</code> .  Hasilnya ( <code>MAC</code> ), bersama dengan <code>nonce</code> yang dihasilkan sebelumnya, menjadi <code>key_handle</code> ; </li><li>  Perangkat mengirim <code>key_handle</code> dan <code>service_public_key</code> kembali ke browser, dan browser beralih ke layanan, yang menyimpan data ini untuk otentikasi berikutnya. </li></ul><br>  Otentikasi selanjutnya dilanjutkan sebagai berikut: <br><br><ul><li>  Layanan menghasilkan <code>challenge</code> (data yang dihasilkan secara acak) dan mengirimkannya ke browser bersama dengan <code>key_handle</code> (yang terdiri dari <code>nonce</code> dan <code>MAC</code> ).  Browser meneruskan semua ini ke perangkat, bersama dengan <code>AppID</code> (yaitu nama domain); </li><li>  Perangkat, yang memiliki <code>nonce</code> dan <code>AppID</code> , menghasilkan <code>service_private_key</code> dengan cara yang sama seperti yang dihasilkan saat pendaftaran; </li><li>  Perangkat menghasilkan <code>MAC</code> dengan cara yang sama seperti saat registrasi, dan membandingkannya dengan <code>MAC</code> diterima dari browser, memastikan bahwa <code>nonce</code> tidak diganti, dan oleh karena itu, <code>service_private_key</code> diandalkan; </li><li>  <code>counter</code> kenaikan perangkat; </li><li>  Perangkat menandatangani <code>challenge</code> , <code>AppID</code> dan <code>counter</code> menggunakan <code>service_private_key</code> , dan mengirimkan tanda tangan yang dihasilkan ( <code>signature</code> ) dan <code>counter</code> browser, yang mentransfer data ini lebih jauh ke layanan; </li><li>  Layanan memeriksa <code>signature</code> menggunakan <code>service_public_key</code> yang dimilikinya setelah pendaftaran.  Juga, sebagian besar layanan memverifikasi bahwa <code>counter</code> lebih besar dari nilai sebelumnya (jika ini bukan otentikasi pertama).  Tujuan dari tes ini adalah untuk membuat kloning perangkat U2F tidak dapat diakses.  Akibatnya, jika pencocokan <code>signature</code> dan <code>counter</code> lebih besar dari nilai sebelumnya, otentikasi dianggap berhasil diselesaikan, dan layanan menyimpan nilai <code>counter</code> baru. </li></ul><br>  Sekarang mari kita uraikan detail yang berhubungan langsung dengan diskusi. <br><br><h3>  Rincian bunga </h3><br>  Yang pertama adalah bahwa perangkat tidak menyimpan <code>service_private_key</code> untuk setiap layanan: sebagai gantinya, itu menampilkan <code>service_private_key</code> setiap kali menggunakan HMAC-SHA256.  Ini sangat penting bagi kami: jelas bahwa jika setiap perangkat akan menyimpan kunci unik secara terpisah untuk setiap layanan, maka hanya perangkat ini yang dapat mengautentikasi selanjutnya. <br><br>  <i>Omong-omong, ini bukan persyaratan U2F: U2F tidak menunjukkan bagaimana kunci harus disimpan, dan beberapa implementasi awal U2F memang, pada kenyataannya, menyimpan kunci untuk setiap layanan secara terpisah.</i>  <i>Pendekatan ini memiliki kelemahan bahwa jumlah layanan yang dapat digunakan perangkat terbatas.</i>  <i>Derivasi dari <code>service_private_key</code> menghilangkan kelemahan ini.</i> <br><br>  Dan kedua, perangkat memiliki <code>counter</code> untuk mencegah kloning. <br><br>  Pada pandangan pertama, tampaknya <code>counter</code> ini tidak memungkinkan kami untuk menerapkan strategi cadangan yang dibahas (setidaknya bagi saya ketika saya mencoba menemukan solusi), tetapi kenyataannya, itu hanya membantu kami!  Saya akan jelaskan sekarang. <br><br><h3>  Ide utama </h3><br>  Idenya adalah ini: pada tahap produksi, program dua token sedemikian rupa sehingga mereka berdua memiliki <code>device_secret</code> sama, tetapi token cadangan perlu beberapa koreksi: daripada menggunakan <code>counter</code> dalam bentuk murni (seperti token biasa), itu harus menambahkan beberapa konstanta besar untuk <code>counter</code> .  Misalnya, setengah dari kisaran 32-bit, mis.  kira-kira <code>2 000 000 000</code> , kelihatannya masuk akal: Saya tidak mungkin menghabiskan begitu banyak autentikasi sepanjang hidup saya. <br><br>  Faktanya, itu saja.  Sederhana dan efektif. <br><br>  Setelah dua token diprogram dengan cara ini, saya menyembunyikan token cadangan di tempat yang <i>sangat</i> sulit dijangkau, dan tidak pernah menyentuhnya.  Jika sesuatu yang buruk terjadi dan saya kehilangan akses ke token utama, saya masih mendapatkan token cadangan, dan saya dapat segera menggunakannya pada semua layanan di mana saya mendaftarkan token utama, karena  Cadangan memiliki <code>device_secret</code> sama, dan <code>counter</code> dimulai dengan jumlah yang sangat besar, yang tidak akan saya dapatkan selama sisa hidup saya. <br><br>  Juga, saya menarik perhatian pada fakta bahwa <b>saya tidak mengusulkan membuat token yang dikloning</b> .  Dua token, meskipun mereka memiliki <code>device_secret</code> sama, memiliki penghitung yang berbeda, dan setelah memprogram <code>device_secret</code> seharusnya tidak ada cara untuk mendapatkannya kembali dari perangkat atau membuat klon dengan cara lain. <br><br><h3>  Catatan Tentang Penghitung </h3><br>  Pembaca yang penuh perhatian mungkin memperhatikan bahwa ada masalah keamanan berikut: bagaimana jika seorang penyerang mendapatkan akses ke token utama dan entah bagaimana memulai 2.000.000.000 otentikasi?  Kemudian dia mendapatkan akses ke layanan bahkan setelah token cadangan telah digunakan pada layanan ini. <br><br>  Untungnya, masalah ini memiliki solusi sederhana.  Bagaimanapun, penghitung harus diimplementasikan dalam perangkat keras (mungkin pada beberapa prosesor kripto), dan untuk implementasi yang aman, penghitung perangkat keras ini harus memiliki kisaran kurang dari 32 bit.  Misalnya, pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ATECC508A,</a> penghitung hanya dapat menghitung hingga 2097151, jadi dengan menetapkan konstanta yang ditambahkan ke penghitung ke nilai yang lebih besar dari nilai maksimum penghitung, kita dapat memastikan bahwa token utama tidak pernah dapat dihitung ke penghitung di token cadangan. <br><br>  Untuk memperjelas: katakanlah token U2F kami menggunakan ATECC508A, dan menunjukkan penghitung di dalam ATECC508A sebagai <code>hw_counter</code> .  Lalu: <br><br><ul><li>  Dalam token utama, kami menggunakan untuk perhitungan: <code>hw_counter</code> ; </li><li>  Dalam token cadangan, kami menggunakan untuk perhitungan: <code>hw_counter + 2000000000</code> . </li></ul><br>  Harap dicatat bahwa kami tidak mengubah <code>hw_counter</code> di dalam prosesor crypto;  masih akan dihitung dari 0 hingga 2097151. Sebaliknya, setiap kali kita perlu mendapatkan nilai penghitung, kita membaca <code>hw_counter</code> dari ATECC508A, lalu kita tambahkan konstanta dan mengembalikannya (untuk perhitungan lebih lanjut untuk U2F). <br><br>  Dengan demikian, kisaran nilai penghitung dalam token utama adalah [0, 2097151], sedangkan rentang nilai penghitung dalam token cadangan adalah [2000000000, 2002097151].  Fakta bahwa rentang ini tidak tumpang tindih memastikan pembatalan token utama saat menggunakan cadangan (jika layanan menggunakan <code>counter</code> ; layanan utama yang saya periksa menggunakannya). <br><br><h3>  Implementasi aktual </h3><br>  Tak satu pun dari produsen token U2F yang saya tahu tentang mendukung penyesuaian yang diperlukan hari ini.  Tapi untungnya, ada implementasi open-source token <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">U2F</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SoloKeys</a> . <br><br>  Saya menulis artikel asli saya (dalam bahasa Inggris) setahun yang lalu, dan bagian ini sedikit ketinggalan jaman: kemudian SoloKeys berada pada tahap prototyping, dan saya menggunakan iterasi proyek sebelumnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">u2f-zero</a> .  Oleh karena itu, saya tidak akan menerjemahkan bagian ini sekarang, karena satu-satunya cara untuk mendapatkan perangkat u2f-zero adalah menyoldernya sendiri, dan hampir tidak disarankan untuk melakukan ini (walaupun ada instruksi pada github). <br><br>  Namun demikian, semua detail modifikasi yang diperlukan u2f-nol diberikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel asli</a> . <br><br>  Ketika tangan saya mencapai solokeys, saya akan menulis instruksi untuk modifikasi. <br><br>  Dengan satu atau lain cara, ini adalah satu-satunya cara yang saya tahu hari ini untuk mendapatkan token U2F yang berfungsi dengan cadangan yang dapat diandalkan.  Memeriksa beberapa layanan (setidaknya google dan github) menunjukkan bahwa ia berfungsi: dengan mendaftarkan token utama pada layanan, kami juga dapat menggunakan cadangan, dan setelah penggunaan pertama cadangan, token utama berhenti berfungsi.  Awwwwwww.  &lt;3 <br><br><h3>  Peringatan </h3><br>  Terlepas dari kenyataan bahwa strategi cadangan ini keren, saya tidak begitu yakin implementasi spesifiknya melalui u2f-zero atau solokey.  Jalan ini adalah satu-satunya cara untuk mendapatkan apa yang Anda inginkan, jadi saya pergi ke sana;  tetapi dengan asumsi bahwa penyerang mendapatkan akses fisik ke perangkat U2F, saya tidak yakin bahwa meretas perangkat (mis. mendapatkan <code>device_secret</code> darinya) akan sesulit seperti pada Yubikey atau produsen besar lainnya.  Para penulis solokey mengklaim bahwa "tingkat keamanannya sama dengan kunci mobil modern," tetapi saya tidak melakukan pemeriksaan apa pun untuk mengonfirmasi hal ini. <br><br>  Namun, jujur â€‹â€‹saja, saya tidak terlalu khawatir tentang ini.  Jika seorang penyerang hanya mencuri token tanpa niat mengembalikannya, maka kompleksitas mematahkannya tidak masalah, karena  seorang penyerang bisa menggunakan token ini untuk mengakses akun dan, misalnya, cukup mencabut token ini dan menambahkan yang lain.  Namun, untuk ini saya harus memiliki masalah keamanan serius lainnya juga.  Token U2F hanyalah faktor kedua. <br><br>  Jadi, satu-satunya skenario di mana solokey mungkin kurang aman daripada sesuatu yang lain adalah ketika seorang penyerang mencoba mengakses perangkat untuk waktu yang singkat, dapatkan <code>device_secret</code> darinya, dan mengembalikan perangkat itu kembali, tanpa terlihat oleh saya.  Untuk melakukan ini, ia perlu membaca isi mikrokontroler flash (atau RAM pada waktu yang tepat), dan ini tidak terlalu sepele. <br><br>  Mempertimbangkan semua faktor, saya percaya bahwa bagi saya pribadi untuk memiliki cadangan yang andal jauh lebih penting daripada memiliki implementasi perangkat keras yang sangat aman dari perangkat U2F.  Kemungkinan masalah dengan implementasi yang aman dan kurangnya cadangan yang baik lebih tinggi daripada kemungkinan masalah dengan u2f-zero (solokey) dan cadangan. <br><br><h2>  Kesimpulan </h2><br>  Strategi cadangan yang dipertimbangkan mengungguli alternatif di semua dimensi: itu universal, lebih aman dan lebih dapat diandalkan daripada metode lainnya. <br><br>  Saya akan senang jika setidaknya salah satu produsen utama menerapkan ini dalam produk mereka, tetapi belum ada kepastian.  Seorang pria dari dukungan Yubico, James A., bahkan mengatakan kepada saya bahwa untuk mengimplementasikan cadangan yang saya butuhkan, tidak mungkin dengan cara U2F dirancang, dan setelah saya menetapkan rincian implementasi, itu hanya berhenti merespons. <br><br>  Untungnya, ini tidak mustahil seperti yang Yubico yakini. <br><br><hr><br>  <i>Artikel asli saya dalam bahasa Inggris: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cadangan yang Andal, Aman, dan Universal untuk Token U2F</a> .</i>  <i>Karena</i>  <i>penulis artikel asli adalah diri saya sendiri, maka, dengan izin Anda, saya tidak memasukkan artikel ini ke dalam kategori â€œterjemahanâ€</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474300/">https://habr.com/ru/post/id474300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474284/index.html">Bukan hanya berjangka dan opsi: apa instrumen keuangan sekunder lainnya yang ada di bursa dan tidak hanya</a></li>
<li><a href="../id474286/index.html">Analisis terperinci dari metode simpleks</a></li>
<li><a href="../id474292/index.html">Tutorial JavaFX: Memulai</a></li>
<li><a href="../id474294/index.html">Kompatibilitas biner: sekarang atau tidak sama sekali</a></li>
<li><a href="../id474298/index.html">Menerapkan Operasi Transfer Kartu-ke-Kartu P2P Gateway</a></li>
<li><a href="../id474302/index.html">Cara menulis skrip uji kegunaan aplikasi yang efektif</a></li>
<li><a href="../id474306/index.html">Buat gaya penunjuk, fokus, dan status aktif berbeda.</a></li>
<li><a href="../id474308/index.html">Jenis untuk HTTP API yang ditulis dalam Python: pengalaman Instagram</a></li>
<li><a href="../id474310/index.html">Apakah ada angka acak di CSS?</a></li>
<li><a href="../id474312/index.html">Menginstal GUI pada Windows Server Core</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>