<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ß üíº üé° Ref√©ns COBOL e Matem√°tica. Parte 1 ü§∏üèø üïù ‚öîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vamos ser sinceros: ningu√©m gosta de n√∫meros fracion√°rios - nem mesmo de computadores. 

 Quando se trata da linguagem de programa√ß√£o COBOL, a primeir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ref√©ns COBOL e Matem√°tica. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467251/">  Vamos ser sinceros: ningu√©m gosta de n√∫meros fracion√°rios - nem mesmo de computadores. <br><br>  Quando se trata da linguagem de programa√ß√£o COBOL, a primeira pergunta que surge na cabe√ßa de todos sempre se parece com: "Por que a humanidade ainda usa essa linguagem em muitas √°reas vitais?"  Os bancos ainda est√£o usando COBOL.  Cerca de 7% do PIB dos EUA depende de COBOL no processamento de pagamentos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CMS</a> .  O Internal Revenue Service (IRS) dos Estados Unidos, como todos sabem, ainda usa COBOL.  Essa linguagem tamb√©m √© usada na avia√ß√£o (a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">partir daqui</a> , aprendi uma coisa interessante sobre esse t√≥pico: o n√∫mero da reserva de passagens a√©reas costumava ser um indicador usual).  Pode-se dizer que muitas organiza√ß√µes muito s√©rias, seja um setor p√∫blico ou privado, ainda est√£o usando o COBOL. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/q1/m_/gs/q1m_gsyxbbwdk32ng3w1foeckgc.jpeg"></a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A segunda parte</a> <br><br>  O autor do material, a primeira parte da tradu√ß√£o que publicamos hoje, encontrar√° uma resposta para a pergunta de por que o COBOL, o idioma que surgiu em 1959, ainda √© t√£o difundido. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Por que COBOL ainda est√° vivo?</font> </h2><br>  A resposta tradicional a essa pergunta √© profundamente c√≠nica.  As organiza√ß√µes s√£o pregui√ßa, incompet√™ncia e estupidez.  Eles est√£o buscando pre√ßos baixos e n√£o est√£o dispostos a investir na reescrita de seus sistemas de software em algo moderno.  Em geral, pode-se supor que o motivo pelo qual o trabalho de um n√∫mero t√£o significativo de organiza√ß√µes dependa do COBOL seja uma combina√ß√£o de in√©rcia e miopia.  E nisso, √© claro, h√° alguma verdade.  Reescrever grandes quantidades de c√≥digo confuso √© uma tarefa enorme.  √â caro  Isso √© complicado.  E se o software existente parecer funcionar bem, a organiza√ß√£o n√£o ter√° uma motiva√ß√£o particularmente forte para investir em um projeto para atualizar esse software. <br><br>  Tudo isso √© verdade.  Mas quando eu trabalhei no IRS, os veteranos do COBOL falaram sobre como eles tentaram reescrever o c√≥digo em Java e verificou-se que o Java n√£o p√¥de executar os c√°lculos corretamente. <br><br>  Pareceu-me extremamente estranho.  √â t√£o estranho que imediatamente entendi o pensamento alarmista: "Senhor, isso significa que o IRS vem arredondando os pagamentos de impostos a todos h√° 50 anos !!!"  Eu simplesmente n√£o podia acreditar que o COBOL √© capaz de contornar o Java em termos dos c√°lculos matem√°ticos necess√°rios ao IRS.  No final, eles n√£o lan√ßaram as pessoas para o espa√ßo. <br><br>  Um dos efeitos colaterais interessantes de aprender COBOL no ver√£o √© que comecei a entender o seguinte.  A quest√£o n√£o √© que Java n√£o possa executar corretamente c√°lculos matem√°ticos.  O ponto √© exatamente como o Java faz os c√°lculos corretos.  E quando voc√™ entende como os c√°lculos s√£o executados em Java e como a mesma coisa √© feita no COBOL, voc√™ come√ßa a entender por que muitas organiza√ß√µes acham t√£o dif√≠cil se livrar do legado de seus computadores. <br><br><h2>  <font color="#3AC1EF">O que "i" deve ser pontilhado?</font> </h2><br>  Vou me afastar um pouco da hist√≥ria do COBOL e falar sobre como os computadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">armazenavam informa√ß√µes</a> antes que a representa√ß√£o bin√°ria de dados se tornasse o padr√£o de fato (mas o material sobre como usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a interface do</a> z / OS; isso √© algo especial).  Penso que, ao considerar nossa quest√£o, ser√° √∫til desviar-nos do tema principal nessa dire√ß√£o.  No material acima, falei sobre v√°rias maneiras de usar comutadores bin√°rios para armazenar n√∫meros em sistemas bin√°rios, tern√°rios e decimais, para armazenar n√∫meros negativos - e assim por diante.  A √∫nica coisa em que n√£o prestei aten√ß√£o suficiente foi como os n√∫meros decimais s√£o armazenados. <br><br>  Se voc√™ projetou seu pr√≥prio computador bin√°rio, poder√° come√ßar decidindo que usar√° o sistema de n√∫meros bin√°rios.  Os bits √† esquerda do ponto representam n√∫meros inteiros - 1, 2, 4, 8. E os bits √† direita - n√∫meros fracion√°rios - 1/2, 1/4, 1/8 ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/2eb/182/c872eb1825dc1d6b456ae11cbcc3325d.png"></div><br>  <i><font color="#999999">2,75 na representa√ß√£o bin√°ria</font></i> <br><br>  O problema aqui √© entender como armazenar o pr√≥prio ponto decimal (de fato - devo dizer ‚Äúponto bin√°rio‚Äù - porque, afinal, estamos falando de n√∫meros bin√°rios).  Isso n√£o √© algum tipo de "alquimia do computador", ent√£o voc√™ pode adivinhar o que estou falando sobre n√∫meros de ponto flutuante e de ponto fixo.  Nos n√∫meros de ponto flutuante, um ponto bin√°rio pode ser colocado em qualquer lugar (ou seja, pode "flutuar").  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A posi√ß√£o do</a> ponto √© armazenada como um expoente.  A capacidade de mover um ponto torna poss√≠vel armazenar um n√∫mero maior de n√∫meros do que o dispon√≠vel na aus√™ncia dessa oportunidade.  O ponto decimal pode ser movido para a parte traseira do n√∫mero e selecionar todos os bits para armazenar valores inteiros, representando n√∫meros muito grandes.  O ponto pode ser deslocado para a frente do n√∫mero e expressar valores muito pequenos.  Mas essa liberdade tem um pre√ßo de precis√£o.  Vamos dar uma outra olhada na representa√ß√£o bin√°ria de 2.75 do exemplo anterior.  Uma transi√ß√£o de quatro para oito √© muito mais do que uma transi√ß√£o de um quarto para um oitavo.  Pode ser mais f√°cil imaginar isso se reescrevermos o exemplo, como mostrado abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/894/ec9/8aa/894ec98aa1715609e45d95ede3b865b1.png"></div><br>  <i><font color="#999999">Escolhi a dist√¢ncia entre os n√∫meros a olho nu - apenas para demonstrar minha ideia</font></i> <br><br>  A diferen√ßa entre os n√∫meros √© f√°cil de calcular por conta pr√≥pria.  Por exemplo, a dist√¢ncia entre 1/16 e 1/32 √© 0,03125, mas a dist√¢ncia entre 1/2 e 1/4 j√° √© 0,25. <br><br>  Por que isso √© importante?  No caso de uma representa√ß√£o bin√°ria de n√∫meros inteiros, isso n√£o importa - a dist√¢ncia entre n√∫meros adjacentes de um registro bin√°rio pode ser facilmente compensada preenchendo-os com as combina√ß√µes apropriadas de bits e sem perder a precis√£o.  Mas no caso da representa√ß√£o de n√∫meros fracion√°rios, n√£o √© t√£o simples.  Se voc√™ tentar "preencher" os "buracos" entre n√∫meros adjacentes - algo pode "cair" (e realmente cair) nesses buracos.  Isso leva ao fato de que, no formato bin√°rio, n√£o √© poss√≠vel obter representa√ß√µes exatas de n√∫meros fracion√°rios. <br><br>  Isso √© ilustrado pelo exemplo cl√°ssico do n√∫mero 0,1 (um d√©cimo).  Como representar esse n√∫mero em formato bin√°rio?  2 <sup>-1</sup> √© 1/2 ou 0,5.  Isso √© demais.  1/16 √© 0,0635.  Isso √© muito pouco.  1/16 + 1/32 j√° est√° mais pr√≥ximo (0,09375), mas 1/16 + 1/32 + 1/64 j√° √© mais do que precisamos (0,109375). <br><br>  Se voc√™ acredita que esse racioc√≠nio pode ser continuado indefinidamente - ent√£o voc√™ est√° certo - do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jeito que √©</a> . <br><br>  Aqui voc√™ pode dizer para si mesmo: ‚ÄúPor que n√£o salvamos 0,1 da mesma maneira que armazenamos o n√∫mero 1?  Podemos salvar o n√∫mero 1 sem problemas - ent√£o, basta remover o ponto decimal e armazenar qualquer n√∫mero da mesma maneira que armazenamos n√∫meros inteiros. " <br><br>  Essa √© uma excelente solu√ß√£o para esse problema, exceto pelo fato de exigir a corre√ß√£o do ponto bin√°rio / decimal em algum local predeterminado.  Caso contr√°rio, os n√∫meros 10.00001 e 100000.1 ser√£o exatamente iguais.  Mas se o ponto for fixo, de modo que, digamos, dois d√≠gitos sejam alocados para a parte fracion√°ria do n√∫mero, podemos arredondar 10.00001 para 10.00 e 100000.1 girar√° 100000.10. <br><br>  Acabamos de "inventar" os n√∫meros de ponto fixo. <br><br>  Com a representa√ß√£o de diferentes valores usando n√∫meros de pontos fixos, acabamos de descobrir.  √â f√°cil de fazer.  √â poss√≠vel, usando n√∫meros de ponto fixo, facilitar a solu√ß√£o de outros problemas?  Lembremos aqui sobre nossos bons amigos - sobre n√∫meros decimais bin√°rios (decimal codificado em bin√°rio, BCD).  A prop√≥sito, para que voc√™ saiba, esses n√∫meros s√£o usados ‚Äã‚Äãna maioria das calculadoras cient√≠ficas e gr√°ficas.  A partir desses dispositivos, o que √© bastante claro, eles esperam os resultados corretos dos c√°lculos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/102/020/d31/102020d313c5627bb37fc6dee57954a4.jpg"></div><br>  <i><font color="#999999">Calculadora TI-84 Plus</font></i> <br><br><h2>  <font color="#3AC1EF">Taxa de recorr√™ncia de Muller e Python</font> </h2><br>  Os n√∫meros de ponto fixo s√£o considerados mais precisos devido ao fato de que os "orif√≠cios" entre os n√∫meros s√£o constantes e porque o arredondamento ocorre apenas quando voc√™ precisa imaginar um n√∫mero para o qual simplesmente n√£o h√° espa√ßo suficiente.  Por√©m, ao usar n√∫meros de ponto flutuante, podemos representar n√∫meros muito grandes e muito pequenos usando a mesma quantidade de mem√≥ria.  √â verdade que, com a ajuda deles, √© imposs√≠vel representar todos os n√∫meros na faixa acess√≠vel com precis√£o e somos for√ßados a recorrer ao arredondamento para preencher os ‚Äúburacos‚Äù. <br><br>  COBOL foi criado como um idioma no qual, por padr√£o, n√∫meros de ponto fixo s√£o usados.  Mas isso significa que o COBOL √© melhor do que as linguagens modernas para realizar c√°lculos matem√°ticos?  Se pegarmos um problema como o resultado do c√°lculo do valor 0.1 + 0.2, pode parecer que a pergunta anterior deve ser respondida ‚Äúsim‚Äù.  Mas ser√° chato.  Ent√£o vamos seguir em frente. <br><br>  Vamos experimentar o COBOL usando o chamado relacionamento de Recorr√™ncia de Muller.  Jean-Michel Muller √© um cientista franc√™s que pode ter feito uma grande descoberta cient√≠fica no campo da tecnologia da informa√ß√£o.  Ele encontrou uma maneira de interromper o funcionamento correto dos computadores usando a matem√°tica.  Tenho certeza de que ele diria que estuda os problemas de confiabilidade e precis√£o, mas nunca mais: cria problemas matem√°ticos que ‚Äúquebram‚Äù os computadores.  Uma dessas tarefas √© sua f√≥rmula de recorr√™ncia.  √â assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fa/1d8/56c/8fa1d856cfe581c272fc25a8c55e8938.png"></div><br>  <i><font color="#999999">Este exemplo √© retirado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui.</a></font></i> <br><br>  A f√≥rmula n√£o parece assustadora.  Certo?  Esta tarefa √© adequada para nossos prop√≥sitos, pelos seguintes motivos: <br><br><ul><li>  Apenas regras simples de matem√°tica s√£o usadas aqui - sem f√≥rmulas complicadas ou id√©ias profundas. </li><li>  Come√ßamos com um n√∫mero que tem dois d√≠gitos ap√≥s o ponto decimal.  Como resultado, √© f√°cil imaginar que estamos trabalhando com valores que representam certas quantias de dinheiro. </li><li>  O erro resultante dos c√°lculos n√£o √© um pequeno erro de arredondamento.  Este √© um desvio do resultado correto por ordens inteiras de magnitude. </li></ul><br>  Aqui est√° um pequeno script Python que calcula os resultados da rela√ß√£o de recorr√™ncia de Mueller usando n√∫meros de ponto flutuante e ponto fixo: <br><br><pre><code class="plaintext hljs">from decimal import Decimal def rec(y, z):  return 108 - ((815-1500/z)/y)  def floatpt(N):  x = [4, 4.25]  for i in range(2, N+1):   x.append(rec(x[i-1], x[i-2]))  return x  def fixedpt(N):  x = [Decimal(4), Decimal(17)/Decimal(4)]  for i in range(2, N+1):   x.append(rec(x[i-1], x[i-2]))  return x N = 20 flt = floatpt(N) fxd = fixedpt(N) for i in range(N):  print str(i) + ' | '+str(flt[i])+' | '+str(fxd[i])</code> </pre> <br>  Aqui est√° o resultado desse script: <br><br><pre> <code class="plaintext hljs">i | floating pt  | fixed pt -- | -------------- | --------------------------- 0 | 4       | 4 1 | 4.25      | 4.25 2 | 4.47058823529 | 4.4705882352941176470588235 3 | 4.64473684211 | 4.6447368421052631578947362 4 | 4.77053824363 | 4.7705382436260623229461618 5 | 4.85570071257 | 4.8557007125890736342039857 6 | 4.91084749866 | 4.9108474990827932004342938 7 | 4.94553739553 | 4.9455374041239167246519529 8 | 4.96696240804 | 4.9669625817627005962571288 9 | 4.98004220429 | 4.9800457013556311118526582 10 | 4.9879092328  | 4.9879794484783912679439415 11 | 4.99136264131 | 4.9927702880620482067468253 12 | 4.96745509555 | 4.9956558915062356478184985 13 | 4.42969049831 | 4.9973912683733697540253088 14 | -7.81723657846 | 4.9984339437852482376781601 15 | 168.939167671 | 4.9990600687785413938424188 16 | 102.039963152 | 4.9994358732880376990501184 17 | 100.099947516 | 4.9996602467866575821700634 18 | 100.004992041 | 4.9997713526716167817979714 19 | 100.000249579 | 4.9993671517118171375788238</code> </pre> <br>  At√© a itera√ß√£o 12, o erro de arredondamento parece mais ou menos insignificante, mas ent√£o o verdadeiro inferno come√ßa.  Os c√°lculos de ponto flutuante convergem para um n√∫mero vinte vezes maior do que o resultado dos c√°lculos de ponto fixo. <br><br>  Talvez voc√™ pense que √© improv√°vel que algu√©m realize c√°lculos recursivos em larga escala.  Mas foi exatamente isso que causou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o desastre de</a> 1991, que levou √† morte de 28 pessoas, quando o sistema de controle de m√≠sseis Patriot calculou incorretamente o tempo.  Acontece que os c√°lculos de ponto flutuante causaram muitos danos acidentalmente.  Aqui est√£o algumas √≥timas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coisas</a> que talvez a computa√ß√£o de alto desempenho seja apenas uma maneira mais r√°pida de obter respostas erradas.  Leia este trabalho se desejar obter mais informa√ß√µes sobre o problema discutido aqui e ver mais exemplos. <br><br>  O problema √© que a quantidade de RAM que os computadores possuem n√£o √© infinita.  Portanto, √© imposs√≠vel armazenar um n√∫mero infinito de posi√ß√µes decimais (ou bin√°rias).  Os c√°lculos de ponto fixo podem ser mais precisos que os de ponto flutuante se houver confian√ßa de que √© menos prov√°vel que sejam necess√°rios mais n√∫meros ap√≥s o ponto do que o formato usado.  Se o n√∫mero n√£o couber neste formato, ser√° arredondado.  Deve-se notar que nem os c√°lculos de ponto fixo nem os de ponto flutuante s√£o protegidos do problema demonstrado pela rela√ß√£o de recorr√™ncia de Mueller.  Isso e outros como resultado d√£o resultados incorretos.  A quest√£o √© quando isso acontece.  Se voc√™ aumentar o n√∫mero de itera√ß√µes em um script Python, por exemplo, de 20 para 22, o n√∫mero final obtido nos c√°lculos com um ponto fixo ser√° 0,728107.  23 itera√ß√µes?  -501.7081261.  24?  105.8598187. <br><br>  Em diferentes idiomas, esse problema se manifesta de maneiras diferentes.  Alguns, como COBOL, permitem que voc√™ trabalhe com n√∫meros cujos par√¢metros est√£o bem definidos.  E no Python, por exemplo, existem valores padr√£o que podem ser configurados se o computador tiver mem√≥ria suficiente.  Se adicionarmos a linha <code>getcontext().prec = 60</code> ao nosso programa, informando ao m√≥dulo decimal do Python que usaria 60 posi√ß√µes ap√≥s o per√≠odo, e n√£o 28, como √© feito por padr√£o, o programa poder√° executar 40 itera√ß√µes da rela√ß√£o de recorr√™ncia sem erros Mueller. <br><br>  Para continuar ... <br><br>  <b>Caros leitores!</b>  Voc√™ encontrou problemas s√©rios decorrentes da natureza dos c√°lculos de ponto flutuante? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467251/">https://habr.com/ru/post/pt467251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467239/index.html">A diferen√ßa entre o cientista de dados e um adolescente em um carro esportivo</a></li>
<li><a href="../pt467241/index.html">Carrinho de caminh√£o ROS. Parte 4. Criando uma simula√ß√£o de rob√¥ usando os editores rviz e gazebo</a></li>
<li><a href="../pt467245/index.html">Dmitry Matskevich, Dbrain: sobre o empreendedorismo como defici√™ncia mental, IA e seguran√ßa emocional</a></li>
<li><a href="../pt467247/index.html">Uma hist√≥ria sobre V8, React e uma queda no desempenho. Parte 1</a></li>
<li><a href="../pt467249/index.html">Uma hist√≥ria sobre V8, React e uma queda no desempenho. Parte 2</a></li>
<li><a href="../pt467253/index.html">Ref√©ns COBOL e Matem√°tica. Parte 2</a></li>
<li><a href="../pt467255/index.html">Tr√™s erros comuns de seguran√ßa que todo desenvolvedor de reagentes deve conhecer</a></li>
<li><a href="../pt467257/index.html">N√£o guarde todos os seus ovos em uma cesta de uma s√≥ vez</a></li>
<li><a href="../pt467259/index.html">O DPI (inspe√ß√£o SSL) contradiz o significado da criptografia, mas as empresas o implementam</a></li>
<li><a href="../pt467261/index.html">Rosqueamento adequado no Qt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>