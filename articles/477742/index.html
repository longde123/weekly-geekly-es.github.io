<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëå üë©‚Äçüç≥ ‚è∫Ô∏è "¬°Hola, Checkmarx!" C√≥mo escribir una solicitud para Checkmarx SAST y encontrar vulnerabilidades interesantes ‚öæÔ∏è ‚óΩÔ∏è ü•ê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 

 En el art√≠culo quiero hablar sobre nuestra experiencia en la creaci√≥n de mis consultas en Checkmarx SAST. 

 Cuando se familiarice por p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"¬°Hola, Checkmarx!" C√≥mo escribir una solicitud para Checkmarx SAST y encontrar vulnerabilidades interesantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/477742/"><img src="https://habrastorage.org/webt/sh/ll/ln/shlllnc6iduoendolw26rabdugk.jpeg"><br><br>  Hola Habr! <br><br>  En el art√≠culo quiero hablar sobre nuestra experiencia en la creaci√≥n de mis consultas en Checkmarx SAST. <br><br>  Cuando se familiarice por primera vez con este analizador, puede tener la impresi√≥n de que, adem√°s de buscar algoritmos de cifrado / hashing d√©biles y un mont√≥n de falsos positivos, no devuelve nada m√°s.  Pero cuando se configura correctamente, es una herramienta s√∫per poderosa que puede buscar errores graves. <br><br>  Entenderemos las complejidades del lenguaje de consulta Checkmarx SAST y escribiremos 2 consultas para buscar inyecciones SQL y referencias directas a objetos inseguros. <br><a name="habracut"></a><br><br><h2>  Entrada </h2><br>  Despu√©s de una larga b√∫squeda de gu√≠as o art√≠culos sobre Checkmarx, me qued√≥ claro que, adem√°s de la documentaci√≥n oficial, no hab√≠a suficiente informaci√≥n √∫til.  Y la documentaci√≥n oficial no dice que todo se est√° volviendo muy claro y comprensible.  Por ejemplo, no pude encontrar las mejores pr√°cticas, c√≥mo organizar las consultas de anulaci√≥n correctamente, c√≥mo escribir consultas "para tontos", etc. S√≠, hay documentaci√≥n sobre las funciones del lenguaje de consulta CMx, pero aqu√≠ se explica c√≥mo combinar estas funciones en una sola consulta, La documentaci√≥n no est√° escrita. <br><br>  Quiz√°s la falta de art√≠culos y gu√≠as de la comunidad de Checkmarx est√© asociada con el alto costo de la herramienta y, como resultado, con una peque√±a audiencia.  O tal vez solo algunas personas se molestan con el ajuste fino y usan la soluci√≥n tal como est√°, lista para usar. <br><br>  En mi experiencia, veo m√°s que SAST se usa m√°s para cumplir con las formalidades relacionadas con diversos requisitos por parte de los clientes que para buscar errores reales.  Con este enfoque, como resultado, tenemos, en el mejor de los casos, un n√∫mero relativamente peque√±o de "vulnerabilidades", que casi autom√°ticamente se conocen como "no explotables" (porque lo son en el 99.9% de los casos). <br><br>  Cabe se√±alar que Checkmarx est√° tratando de actualizar sus consultas para obtener el mejor resultado de forma inmediata.  Pero las consultas de CMx Query Language se adaptan al "caso general".  La b√∫squeda inicial de tokens se basa en el nombre.  Por ejemplo, CMx SAST supone que todas las consultas a la base de datos se ver√°n as√≠: * createQuery * o * createSQLQuery *.  Pero si se utiliza el desarrollo interno para trabajar con la base de datos, y el m√©todo para consultar la base de datos se llama de manera diferente, por ejemplo * driveMyQuery *, entonces se omitir√°n todos los m√©todos SQL.  Por ejemplo, nuestro cliente usa ORM personalizado para SQL DB.  En este caso, las consultas CMx listas para usar omitieron todas las inyecciones de SQL. <br><br><h4>  Abreviaturas y Definiciones </h4><br>  <b>CMx</b> - Checkmarx SAST. <br>  <b>CMxQL</b> - lenguaje de consulta Checkmarx SAST <br>  <b>Token</b> : una cadena con cierto valor es el resultado del trabajo del analizador l√©xico (que tambi√©n se denomina tokenizaci√≥n) <br><br><h3>  Aplicaci√≥n de prueba </h3><br>  Para escribir un art√≠culo, dibuj√© un c√≥digo Java, una peque√±a aplicaci√≥n de prueba.  Este c√≥digo es una copia aproximada de una peque√±a parte del sistema real.  Aunque, en general, el c√≥digo de la aplicaci√≥n de prueba no es muy diferente de cualquier otro c√≥digo de back-end HTTP.  Las secciones clave del c√≥digo de la aplicaci√≥n de prueba ser√°n visibles en las capturas de pantalla. <br><br><h4>  La aplicaci√≥n de prueba tiene la siguiente estructura </h4><br>  Clase <i>WebRouter</i> para procesar solicitudes HTTP entrantes; 4 m√©todos para procesar URL dentro: <br><ul><li>  <i>/ getTransaction</i> : acepta el <i>ID de</i> la transacci√≥n en la entrada <i>y devuelve la informaci√≥n</i> que <i>contiene</i> , el <i>ID lo</i> toma como una cadena y lo pasa a <i>getTransactionInfo (transacci√≥nId)</i> =&gt; <i>getTransactionInfo (transactoinId)</i> : hace que el <i>ID de</i> transacci√≥n se concatene con la consulta SQL (es decir, se obtiene la inyecci√≥n SQL); </li><li>  <i>/ getSecureTransaction</i> : acepta el <i>ID de</i> la transacci√≥n como entrada <i>y devuelve la informaci√≥n</i> que <i>contiene</i> , el <i>id lo</i> toma como una cadena y lo pasa <i>getTransactionInfoSecured ()</i> =&gt; <i>getTransactionInfoSecured (transactoinId)</i> : primero <i>emite el</i> string <i>ID de</i> <i>transacci√≥n</i> para escribir Long y luego lo concatena en una consulta SQL caso la inyecci√≥n no se explota); </li><li>  <i>/ getSettings</i> : acepta el <i>ID de usuario</i> y el <i>ID de buz√≥n como entrada</i> , y emite la configuraci√≥n del buz√≥n.  No verifica que el <i>buz√≥n de correo</i> pertenece al usuario; </li><li>  <i>/ getSecureSettings</i> : tambi√©n acepta el <i>ID de usuario</i> y el <i>ID de buz√≥n en la entrada</i> y muestra la configuraci√≥n del buz√≥n.  PERO comprueba que el <i>buz√≥n de correo</i> pertenece al usuario. </li></ul><br><br><h2>  CMx: informaci√≥n general y definiciones b√°sicas </h2><br><h3>  Antes de comenzar a desarrollar consultas </h3><br>  El desarrollo de consultas se lleva a cabo en un programa separado CxAuditor.  En CxAuditor necesita escanear todo el c√≥digo (crear un proyecto local), para lo cual escribiremos consultas.  Despu√©s de eso, puede escribir y ejecutar nuevas consultas.  Con una base de c√≥digo grande, el escaneo primario puede tomar horas de tiempo y gigabytes de memoria.  Despu√©s de eso, cada solicitud no se ejecutar√° lo suficientemente r√°pido.  Esto es completamente inadecuado para el desarrollo. <br><br>  Por lo tanto, puede tomar un peque√±o conjunto de archivos del proyecto, idealmente con un error encontrado en el c√≥digo antes del tipo bajo el cual estamos escribiendo la solicitud (o colocar el error all√≠ manualmente) y escanear solo este conjunto de archivos.  No es necesario cumplir con la estructura de archivos del proyecto.  Es decir, si tiene el paquete A y B de Java, y las clases en el paquete B usan las clases y los m√©todos del paquete A, puede poner todo esto en un solo directorio, y CMx a√∫n entender√° las relaciones y crear√° cadenas de llamadas entre archivos correctamente (bueno, o casi siempre correcto, aunque los errores apenas est√°n relacionados con la estructura de archivos del proyecto). <br><br><h3>  Definiciones b√°sicas </h3><br><h4>  Cxlist </h4><br>  El tipo de datos principal en CMx.  El resultado de casi todas las funciones CMxQL ser√° <i>CxList</i> .  Estos son muchos elementos con ciertas propiedades.  Las propiedades que son m√°s √∫tiles para el desarrollo se considerar√°n a continuaci√≥n. <br><br><h4>  resultado </h4><br>  CMxQL tiene un <i>resultado</i> variable incorporado.  El conjunto que contiene la variable de <i>resultado</i> , despu√©s de ejecutar la consulta completa, se mostrar√° como resultado. <br><br>  Es decir, la operaci√≥n final de cualquier consulta debe ser el <i>resultado de</i> la cadena <i>= LO QUE SEA</i> , por ejemplo: <br><pre><code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"anyname"</span></span>);</code> </pre> <br><h4>  elemento de flujo y c√≥digo </h4><br>  La mayor√≠a de las funciones CMxQL por tipo de valores devueltos se dividen en 2, las que devuelven "elementos de c√≥digo" y las que devuelven Flow.  En ambos casos, el resultado es una <i>CxList</i> .  Pero su contenido ser√° ligeramente diferente para los elementos de flujo y c√≥digo. <br><ul><li>  <b>Elemento de c√≥digo</b> - token - por ejemplo, una variable, llamada a m√©todo, asignaci√≥n, etc. </li><li>  <b>Flujo</b> : la relaci√≥n entre los tokens dados. </li></ul><br><br><h4>  Todos y "sub" Todos </h4><br>  Cada funci√≥n CMxQL se puede realizar en el conjunto <i>Todos</i> (contiene todos los tokens de todo el c√≥digo escaneado, ya vimos un ejemplo con <i>resultado</i> ) o en el conjunto <i>CxList</i> , que a su vez se obtuvo como resultado de algunas operaciones en la consulta, por ejemplo, la consulta: <br><pre> <code class="actionscript hljs">CxList newList = CxList.New();</code> </pre> <br>  crear√° un conjunto vac√≠o, que luego podemos llenar con elementos usando el m√©todo <i>Add ()</i> , y luego buscar ya por los elementos del nuevo conjunto: <br><pre> <code class="actionscript hljs">CxList newFind = newList.FindByName(<span class="hljs-string"><span class="hljs-string">"narrowedScope"</span></span>);</code> </pre> <br><h4>  Propiedades de los elementos encontrados. </h4><br>  Cada elemento del conjunto CxList tiene varias propiedades.  Al analizar los resultados para escribir consultas, los m√°s √∫tiles son: <br><br><ul><li>  <b>SourceFile</b> : el nombre del archivo que contiene este elemento; </li><li>  <b>L√≠nea de origen</b> : n√∫mero de l√≠nea con token; </li><li>  <b>Nombre de origen</b> : el nombre del token.  Equivalente al token, es decir, si la variable se llama var1, entonces Nombre de origen = var1; </li><li>  <b>Tipo de origen</b> : el tipo de token.  Por ejemplo, si es una cadena, ser√° StringLiteral, si se llama al m√©todo, luego MethodInvokeExpr y muchos otros; </li><li>  <b>Archivo de destino</b> </li><li>  <b>L√≠nea de destino;</b> </li><li>  <b>Nombre del destino;</b> </li><li>  <b>Tipo de destino</b> </li></ul><br><br>  Origen y Destino ser√°n diferentes si los elementos del conjunto de resultados son Flujo, y viceversa, coincidir√°n si el resultado son elementos de c√≥digo. <br><br><h2>  Comience a crear consultas </h2><br>  Todas las funciones CMxQL se pueden dividir en varios tipos.  Aqu√≠, en mi opini√≥n, se puede observar el principal inconveniente de la documentaci√≥n de CMxQL, todas las funciones en el dock se describen simplemente en orden alfab√©tico, mientras que ser√≠a mucho m√°s conveniente estructurarlas de acuerdo con la funcionalidad y solo alfab√©ticamente. <br><br><ul><li>  Funciones de b√∫squeda: casi todas las funciones CMxQL con el nombre <b>FindBy *</b> y <b>GetBy *</b> ; </li><li>  Las funciones de las operaciones en conjuntos son suma, resta, intersecci√≥n, iteraci√≥n sobre elementos, etc. </li><li>  Funciones de an√°lisis: estas son b√°sicamente funciones <b>* InfluencedBy *</b> <b>* InfluencingOn *</b> . </li></ul><br><br>  El principio b√°sico de las consultas es la alternancia de este tipo de funciones.  Primero, usando las funciones de b√∫squeda, seleccionamos solo los tokens que nos interesan por ciertas propiedades.  Usando operaciones en conjuntos, podemos combinar diferentes conjuntos con diferentes propiedades de token en uno, o viceversa, restar el otro de uno.  Luego, utilizando las funciones de an√°lisis, creamos Code Flow e intentamos comprender si las vulnerabilidades potenciales dependen de los par√°metros en los puntos de entrada. <br><br>  La elecci√≥n del lugar desde el que comenzar a buscar y, en general, la ruta de b√∫squeda completa, depende del c√≥digo espec√≠fico y, m√°s precisamente, incluso del "texto".  En algunos casos, es conveniente buscar consultas de los usuarios desde el punto de entrada, en algunos casos es m√°s conveniente comenzar desde el "final" o incluso desde el medio.  Todo depende del c√≥digo espec√≠fico y debe acercarse individualmente a cada repositorio. <br><br><h2>  Ejemplo: Buscar inyecci√≥n SQL </h2><br>  Plan de b√∫squeda, entre par√©ntesis indiqu√© el nombre de los conjuntos (variables en la consulta): <br><br><ol><li>  Definir excepciones: tokens que pueden eliminarse inmediatamente de los √°mbitos de b√∫squeda ( <i>exclusionList</i> ); </li><li>  Determinar la ubicaci√≥n de los controles de seguridad / <i>desinfecci√≥n</i> ( <i>desinfecci√≥n</i> ); </li><li>  Encuentre todos los lugares de bajo nivel con ejecuci√≥n de consultas en la base de datos ( <i>runSuperSecureSQLQuery</i> ); </li><li>  Encuentre todos los par√°metros de los m√©todos llamados <i>runSuperSecureSQLQuery</i> ( <i>runSSSQParams</i> ); </li><li>  Encuentre puntos de entrada (m√©todos principales y sus par√°metros) para los lugares de ejecuci√≥n de consultas en la base de datos ( <i>entryPointsParameters</i> ); </li><li>  Encuentre las dependencias de los par√°metros <i>runSSSQParams</i> en <i>entryPoints</i> , mientras que solo aquellos lugares donde no hay <i>desinfecci√≥n de la desinfecci√≥n de</i> entrada. </li></ol><br><br>  Como resultado, obtenemos m√©todos de bajo nivel con consultas SQL, donde los par√°metros de la consulta SQL: <br><br><ul><li>  depender√° de los par√°metros del m√©todo; </li><li>  los par√°metros se aceptan como cadenas; </li><li>  los par√°metros se concatenan a la solicitud. </li></ul><br>  No comprobaremos si podemos controlar estos par√°metros, como  creemos que existe un mecanismo para mapear variables en una consulta y hay una conversi√≥n a un tipo num√©rico para n√∫meros, y la concatenaci√≥n de cadenas siempre se considera peligrosa.  Incluso si no hay control sobre la l√≠nea ahora, bien puede aparecer en la nueva versi√≥n. <br><br><h3>  SQLi: Paso 1. Definici√≥n de excepciones </h3><br>  En excepciones, debe agregar aquellas clases o archivos donde los nombres de token puedan coincidir con los que est√° buscando, porque  Estos tokens conducir√°n a entradas no v√°lidas. <br><br>  Por ejemplo, un m√©todo para acceder a una base de datos se llama <i>runSuperSecureSQLquery</i> .  Suponemos que el m√©todo <i>runSuperSecureSQLquery</i> dentro se implementa de manera segura.  Y nuestra tarea es encontrar lugares donde no sea seguro usar el m√©todo en s√≠.  Para la inyecci√≥n SQL, los lugares de concatenaci√≥n de par√°metros controlados por el usuario no ser√°n lugares seguros.  Y seguro: lugares para mapear par√°metros en la estructura ORM o, por ejemplo, para par√°metros num√©ricos, esto es una conversi√≥n al tipo correspondiente.  No necesitamos escanear todo el c√≥digo que se encuentra "m√°s profundo" que <i>runSuperSecureSQLquery</i> , lo que significa que es mejor excluirlo para evitar hallazgos in√∫tiles. <br><br>  Para buscar tales excepciones, es conveniente utilizar las funciones CMxQL: <br><ul><li>  <b>FindByFileName ()</b> : encontrar√° el conjunto de todos los tokens en un archivo en particular; </li><li>  <b>GetByClass ()</b> : encontrar√° el conjunto de todos los tokens en la clase con el nombre dado. </li></ul><br><br>  Para una aplicaci√≥n de prueba, esta excepci√≥n es la clase <i>Session</i> , que contiene la implementaci√≥n del m√©todo <i>runSuperSecureSQLquery</i> . <br>  Un ejemplo de una solicitud para excluir c√≥digo en la clase <i>Session</i> (el m√©todo <i>GetByClass ()</i> verificar√° cu√°l de los tokens pasados ‚Äã‚Äãa la entrada tiene un tipo <i>CMx</i> de <i>ClassDecl</i> y emitir√° muchos tokens de esta clase) <br><br><pre> <code class="java hljs">CxList exclusionList = All.GetByClass(All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Session*"</span></span>)); result = exclusionList;</code> </pre> <br><br>  O otra forma es lanzar c√≥digo en todo el archivo <i>Session.java</i> : <br><br><pre> <code class="java hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*Session.java"</span></span>); result = exclusionList;</code> </pre> <br><br>  El asterisco antes del nombre es importante, porque el nombre del archivo incluye la ruta completa. <br>  Ahora tenemos muchos tokens que se pueden restar en los pr√≥ximos pasos del √°mbito de b√∫squeda. <br><br>  El resultado de buscar tokens dentro de la clase <i>Session</i> : <br><br><img src="https://habrastorage.org/webt/x3/gz/vx/x3gzvxxumbbu-th01llyjbymkoo.png"><br><br><h3>  SQLi: Paso 2. Determinar lugares de desinfecci√≥n </h3><br>  Hay 2 m√©todos API en la aplicaci√≥n de prueba (consulte una breve descripci√≥n de la aplicaci√≥n de prueba).  La diferencia entre los dos m√©todos de API es que <i>getTransactionInfo ()</i> concatena el par√°metro transacci√≥nId en la consulta SQL, y <i>getTransactionInfoSecured ()</i> primero <i>convierte</i> transacci√≥nId a Largo, y luego lo pasa como una cadena.  La vulnerabilidad (concatenaci√≥n de par√°metros) est√° integrada en ambos m√©todos.  Pero gracias a la conversi√≥n a Long en <i>getTransactionInfoSecured ()</i> , el √∫ltimo m√©todo no es vulnerable a la inyecci√≥n, porque cuando intentamos pasar una inyecci√≥n (cadena) obtenemos una excepci√≥n Java. <br><br>  En este ejemplo, consideraremos el reparto a Long como el sitio de saneamiento.  Para encontrar estos tokens: <br><br><pre> <code class="java hljs">CxList sanitization = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Long*"</span></span>); result = sanitization;</code> </pre> <br><br>  Resultado de ejemplo: <br><br><img src="https://habrastorage.org/webt/hb/ms/vx/hbmsvxmjwynfncf96eyclx2ey8y.png"><br><br>  El resultado inclu√≠a tokens con los m√©todos YP tipo <i>Long</i> y <i>getValueAsLong</i> , que internamente <i>convierten el</i> valor en tipo <i>Long</i> .  Debe revisar cuidadosamente el resultado para asegurarse de que no haya nada extra. <br><br><h3>  SQLi: Paso 3. Encuentre todos los lugares de bajo nivel con ejecuci√≥n de consultas en la base de datos </h3><br>  La siguiente consulta encontrar√° todos los lugares utilizando el token runSuperSecureSQLQuery (que se utiliza para acceder a la base de datos): <br><br><pre> <code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>)</code> </pre> <br>  Resultado de b√∫squeda por nombre de token runSuperSecureSQLQuery: <br><img src="https://habrastorage.org/webt/qm/bh/ci/qmbhci6ucl_wx3sb_9zqfkkpim8.png"><br><br>  Adem√°s, para los lugares donde se llama a este m√©todo (la clase <i>Billing</i> ), solo se encontrar√°n tokens de invocaci√≥n del m√©todo (tipo <i>MethodInvokeExpr</i> ), y para la ubicaci√≥n de declaraci√≥n del m√©todo (clase <i>Session</i> ), se encontrar√°n todos los tokens - variables. <br><br>  Filtramos solo los tokens de llamada al m√©todo: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery;</code> </pre> <br>  Resultado: <br><img src="https://habrastorage.org/webt/or/82/dw/or82dwxfoze-fcbko2b2mljfyus.png"><br><br>  Como resultado, obtuvimos 7 lugares, 4 de ellos las llamadas requeridas al m√©todo <i>runSuperSecureSQLQuery ()</i> (clases de <i>facturaci√≥n</i> y <i>usuario</i> ).  2: llamadas al m√©todo interno runSuperSecureSQLQuery () dentro de la clase <i>Session</i> , y uno m√°s es el m√©todo <i>add</i> , que es m√°s bien una especie de rareza de b√∫squeda CMxQL.  Digamos que no esperaba que estuviera en la lista =) Los tokens en la clase <i>Session</i> , como descubrimos en el paso 1, no son interesantes para nosotros, por lo que simplemente los restaremos del resultado: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery - exclusionList;</code> </pre> <br>  Obtenemos una lista v√°lida de llamadas al m√©todo requerido: <br><br><img src="https://habrastorage.org/webt/sh/c8/ix/shc8ixcpk9wrkmdv_vzqfz5wj80.png"><br><br>  Tenga en cuenta las <i>funciones FindByType ()</i> y <i>typeof ()</i> en la consulta anterior.  Si queremos buscar por tipo CMx, es decir, por la propiedad <i>CxList</i> "Tipo de fuente", entonces usamos <i>typeof (Tipo de fuente)</i> .  Si queremos hacer una b√∫squeda por tipo de datos, entonces debemos pasar el par√°metro solo como una cadena.  Por ejemplo: <br><br><pre> <code class="java hljs">result = All.FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre><br>  encontrar√° todos los tokens java con tipo String. <br><br><h3>  SQLi: Paso 4. Encuentre todos los par√°metros de los m√©todos llamados runSuperSecureSQLQuery </h3><br>  Para buscar par√°metros de m√©todo, se utiliza la funci√≥n <i>CMxQL GetParameters ()</i> : <br><br><pre> <code class="actionscript hljs">CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); result = runSSSQParams;</code> </pre> <br>  Resultado: <br><br><img src="https://habrastorage.org/webt/s4/4h/id/s44hidweor1j61xs1dkwbewrpja.png"><br><br><h3>  SQLi: Paso 5. Encuentre puntos de entrada para ubicaciones de ejecuci√≥n de consultas en la base de datos </h3><br>  Para hacer esto, primero obtenemos los nombres de los m√©todos principales, dentro de los cuales se encuentran las llamadas a la <i>base de</i> datos <i>runSuperSecureSQLQuery</i> , y luego obtenemos sus par√°metros.  Para buscar tokens primarios, se utiliza la funci√≥n <i>CMAXQL GetAncOfType ()</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MethodDecl)); result = entryPoints;</code> </pre> <br><br>  En esta consulta, para el conjunto runSuperSecureSQLQuery, devuelva todos los tokens primarios del tipo MethodDecl; este es el m√©todo anterior en la pila de llamadas: <br><br><img src="https://habrastorage.org/webt/we/8w/7u/we8w7ucxjxvtgzerknbgjxir8fa.png"><br><br>  Para buscar par√°metros de m√©todos, tambi√©n utilizamos <i>GetParameters ()</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre> <br><br>  La consulta devolver√° los par√°metros de un subconjunto de <i>entryPoints</i> con el tipo Java String: <br><br><img src="https://habrastorage.org/webt/7y/mw/tf/7ymwtfxg94oxlwggez3zhpfvcko.png"><br><br><h3>  SQLi: Paso 6. Encuentre las dependencias de los par√°metros runSSSQParams en entryPointsParameters, mientras que solo aquellos lugares donde no hay entrada de entrada de desinfecci√≥n </h3><br>  En este paso, usamos las funciones de an√°lisis.  Las siguientes funciones se utilizan para analizar el c√≥digo de flujo: <br><br><ul><li>  InfluencedBy () </li><li>  InfluencedByAndNotSanitized () </li><li>  InfluencingOn () </li><li>  InfluencingOnAndNotSanitized () </li><li>  NotInfluencedBy () </li><li>  NotInfluencingOn () </li></ul><br><br>  Para encontrar el flujo de los par√°metros de solicitud <i>runSSSQParams</i> en funci√≥n de los par√°metros del m√©todo padre <i>entryPointsParameters</i> y excluir los tokens de saneamiento: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization);</code> </pre> <br><br>  Sin embargo, no estoy seguro de si las funciones <i>* AndNotSanitized</i> dentro hacen algo de magia, y parece que el m√©todo simplemente resta el conjunto desinfectado de su resultado.  Es decir, si haces: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedBy(entryPointsParameters) - sanitization;</code> </pre> <br><br>  Resulta lo mismo.  Aunque tal vez simplemente no encontr√© una opci√≥n cuando todav√≠a hay diferencias. <br><br>  El resultado de la consulta nos da un flujo correctamente construido: <br><br><img src="https://habrastorage.org/webt/ru/hs/2d/ruhs2dlh7alil7njbzsf2jke9qw.png"><br><br>  Got Flow con potencial inyecci√≥n de SQL.  Como se puede ver en la captura de pantalla, Checkmarx devolvi√≥ 3 Flow.  El flujo en la captura de pantalla es el m√°s corto, comienza y termina en un archivo y un m√©todo.  El siguiente flujo ya sale en la clase Session.  Presta atenci√≥n a la fuente / destino.  Y el √∫ltimo es otro m√©todo en la clase Session.  El flujo dentro de la <i>sesi√≥n</i> se ver√° as√≠: <br><br><img src="https://habrastorage.org/webt/mv/o7/uu/mvo7uuu6wp_dq-ggltm8lb5m5p0.png"><br><br>  Para seleccionar un flujo, se <i>utiliza el</i> m√©todo <i>ReduceFlow (CxList.ReduceFlowType flowType)</i> , donde flowType puede ser: <br><br><ul><li>  <i>CxList.ReduceFlowType.ReduceBigFlow</i> : seleccione el flujo m√°s corto </li><li>  <i>CxList.ReduceFlowType.ReduceSmallFlow</i> : seleccione el flujo m√°s largo </li></ul><br><br><h3>  SQLi: consulta final para encontrar inyecci√≥n SQL </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.GetByClass(All.FindByName("*Session*")); // 2.    CxList sanitization = All.FindByName("*Long*"); // 3.    runSuperSecureSQLQuery() CxList runSuperSecureSQLQuery = All.FindByName("*runSuperSecureSQLQuery*").FindByType(typeof(MethodInvokeExpr)); runSuperSecureSQLQuery -= exclusionList; // 4.     runSuperSecureSQLQuery() CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); // 5.   ,     runSuperSecureSQLQuery() CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(typeof(MethodDecl)); CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType("String"); // 6.       (runSuperSecureSQLQuery)     CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization); // 7.   result = dataInflOnTable.ReduceFlow(CxList.ReduceFlowType.ReduceBigFlow);</span></span></code> </pre> <br><br><h2>  Ejemplo 2: b√∫squeda de referencias directas inseguras a objetos </h2><br>  En esta solicitud, buscaremos todos los lugares donde se trabaje con objetos sin verificar el propietario del objeto.  En este caso, se pueden usar diferentes nombres de par√°metros HTTP para el buz√≥n de correo (suponemos que es Legacy), y la verificaci√≥n en s√≠ misma puede ocurrir en diferentes etapas: en alg√∫n lugar justo en el punto API de entrada HTTP, en alg√∫n lugar antes de la solicitud a la base de datos, y a veces en m√©todos intermedios <br><br>  Plan de b√∫squeda <br><ol><li>  Definir excepciones ( <i>exclusionList</i> ); </li><li>  Identificar lugares para verificaciones de autorizaci√≥n ( <i>idorSanitizer</i> ); </li><li>  Encuentre puntos de entrada: lugares para el procesamiento primario de solicitudes HTTP ( <i>webRemoteMethods</i> ); </li><li>  Solo mediante tokens de punto de entrada para encontrar la ubicaci√≥n de extracci√≥n del par√°metro HTTP <i>buz√≥nid</i> ( <i>buz√≥nidInit</i> ); </li><li>  Encuentre todas las llamadas desde webRemoteMethods a m√©todos y par√°metros de <i>middleware</i> de estas llamadas ( <i>middlewareMethods</i> ); </li><li>  Encuentra m√©todos de middleware que dependen del buz√≥n de correo ( <i>apiPotentialIDOR</i> ); </li><li>  Encuentre todos los lugares donde se definen los m√©todos de <i>middleware</i> ( <i>middlewareDecl</i> ); </li><li>  <i>Revise</i> todos los <i>apiPotentialIDOR</i> y seleccione solo aquellos <i>middlewareDecl</i> en los que no haya verificaci√≥n del propietario del objeto de <i>buz√≥n</i> . </li></ol><br><br><h3>  IDOR: Paso 1. Identificar excepciones </h3><br>  En este caso, excluya todos los tokens en un archivo espec√≠fico: <br><br><pre> <code class="actionscript hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*WebMethodContext.java"</span></span>); result = exclusionList;</code> </pre> <br>  <i>WebMethodContext.java</i> contiene una implementaci√≥n de m√©todos como <i>getMailboxId</i> y <i>getUserId</i> , as√≠ como la cadena "buz√≥nid".  Dado que el nombre de los tokens coincidir√° con los que necesitamos para buscar vulnerabilidades, este archivo emitir√° resultados falsos. <br><br><h3>  IDOR: Paso 2. Localizar comprobaciones de autorizaci√≥n </h3><br>  En la aplicaci√≥n de prueba, el m√©todo <i>validateMailbox ()</i> se usa para determinar si el objeto solicitado pertenece al usuario: <br><br><pre> <code class="actionscript hljs">CxList idorSanitizer = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*validateMailbox*"</span></span>); result = idorSanitizer;</code> </pre><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/a7/jx/3e/a7jx3eqcxzb5pwgzze9yuqbysos.png"><br><br><h3>  IDOR: Paso 3. Encuentre puntos de entrada para solicitudes de API HTTP personalizadas </h3><br>  Los manejadores de solicitudes HTTP tienen una anotaci√≥n especial que los hace f√°ciles de encontrar.  En mi caso, esto es "WebRemote", la funci√≥n <i>CMxQL FindByCustomAttribute () se</i> usa para buscar anotaciones.  Para <i>FindByCustomAttribute ()</i> , la funci√≥n de b√∫squeda del token principal <i>GetAncOfType ()</i> devolver√° el m√©todo bajo la anotaci√≥n: <br><br><pre> <code class="java hljs">CxList webRemoteMethods = All.FindByCustomAttribute(<span class="hljs-string"><span class="hljs-string">"WebRemote"</span></span>) .GetAncOfType(typeof(MethodDecl)); result = webRemoteMethods;</code> </pre> <br><br>  Resultado de la solicitud: <br><br><img src="https://habrastorage.org/webt/rc/xt/q_/rcxtq_rfostgwmdtmwrfyg-9ly4.png"><br><br><h3>  IDOR: Paso 4. Usando solo tokens de punto de entrada, encuentre las ubicaciones de extracci√≥n HTTP para el par√°metro del buz√≥n </h3><br>  Para buscar tokens relacionados con el procesamiento del par√°metro de buz√≥n HTTP: <br><br><pre> <code class="java hljs">CxList getMailboxId = All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxId\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxId;</code> </pre> <br>  agregamos 3 juegos con 3 l√≠neas diferentes, porque  Seg√∫n la leyenda, el nombre del par√°metro HTTP puede diferir en diferentes partes del sistema. <br><br>  La consulta encontrar√° todos los lugares en los que se <i>escribe boxid / mid / boxid</i> como una cadena (entre comillas dobles).  Pero esta consulta devolver√° muchos hallazgos, tk.  dicha cadena se puede encontrar no solo en lugares donde se extraen par√°metros HTTP.  Si continuamos trabajando con este conjunto, obtendremos una gran cantidad de hallazgos falsos. <br><br>  Por lo tanto, solo buscaremos tokens de puntos de entrada ( <i>webRemoteMethods</i> ).  Para encontrar todos los tokens secundarios, se utiliza la funci√≥n <i>CMBQL GetByAncs ()</i> : <br><br><pre> <code class="java hljs">result = All.GetByAncs(webRemoteMethods);</code> </pre> <br>  La solicitud devolver√° todos los tokens que pertenecen a m√©todos anotados como <i>WebRemote</i> .  Ya en esta etapa, podemos filtrar los tokens de aquellos m√©todos en los que se verifica el propietario del objeto.  Por lo tanto, reescribimos la consulta anterior para buscar tokens secundarios de tal manera que seleccione solo los tokens secundarios de los m√©todos <i>WebRemote</i> , donde no hay verificaci√≥n de seguridad para el propietario del objeto.  Para hacer esto, use un bucle con la condici√≥n: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//          CxList entry_point_tokens = All.NewCxList(); //      webRemoteMethods foreach (CxList method in webRemoteMethods) { //        CxList method_tokens = All.GetByAncs(method); // ,       ,    owner if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { //  ,     , ,     } else { //  ,         entry_point_tokens.Add(method_tokens); } }</span></span></code> </pre><br>  Ahora podemos hacer una selecci√≥n m√°s precisa utilizando los par√°metros de la <i>casilla de correo</i> HTTP: <br><br><pre> <code class="java hljs">CxList getMailboxHTTPParams = entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxHTTPParams;</code> </pre> <br>  Pero no nos interesan los lugares donde se recuperan los par√°metros HTTP, sino las variables a las que finalmente se les asignan los valores de los par√°metros HTTP.  Dado que es m√°s confiable buscar Flow precisamente por tokens de variables. <br><br>  La funci√≥n <i>CMxQL FindByInitialization ()</i> encontrar√° los lugares de inicializaci√≥n variable para los tokens dados: <br><br><pre> <code class="java hljs">CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); result = mailboxidInit;</code> </pre> <br>  Resultado: <br><br><img src="https://habrastorage.org/webt/cp/e7/5q/cpe75qru5pcwzikvaona3h7w67c.png"><br><br><h3>  IDOR: Paso 5. Encuentre todas las llamadas desde webRemoteMethods a m√©todos y par√°metros de middleware de estas llamadas </h3><br>  Por middleware, me refiero a un c√≥digo que es m√°s profundo que los m√©todos de procesamiento de las solicitudes HTTP API, es decir, m√°s profundo que los puntos de entrada de las solicitudes de los usuarios.  Por ejemplo, para la captura de pantalla anterior, estos son m√©todos de la clase <i>Usuario</i> , llamadas a <i>user.getSettings ()</i> y <i>user.getSecureSettings ()</i> : <br><br><pre> <code class="java hljs">CxList middlewareMethods = All.FindByShortName(<span class="hljs-string"><span class="hljs-string">"user"</span></span>).GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); result = middlewareMethodsParams;</code> </pre> <br>  Primero, seleccionamos todos los tokens con el nombre de usuario, y luego usando <i>GetRightmostMember ()</i> seleccionamos los tokens de llamada para middleware.  <i>GetRightmostMember ()</i> en la cadena de llamadas a m√©todos devolver√° el m√°s a la derecha.  Luego derivamos los par√°metros del m√©todo encontrado usando <i>GetParameters ()</i> . <br><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/8b/mm/2a/8bmm2ad7zg-xwponufdxuocn-t0.png"><br><br><h3>  IDOR: Paso 6. Encuentre m√©todos de middleware que dependan del buz√≥n </h3><br>  El an√°lisis de flujo utiliza los <i>m√©todos</i> <i>* InfluencedBy *</i> e <i>* InfluncingOn *</i> .  La diferencia entre ellos es clara por su nombre. <br><br>  Por ejemplo: <br><br><pre> <code class="java hljs">All.InfluencedBy(getMailboxHTTPParams)</code> </pre> <br>  ir√° a trav√©s del conjunto All y encontrar√° todos los tokens que dependen de <i>getMailboxHTTPParams</i> . <br><br>  Lo mismo se puede escribir de otra manera: <br><br><pre> <code class="java hljs">getMailboxHTTPParams.InfluencingOn(All)</code> </pre> <br><br>  Para buscar tokens dependientes de <i>buz√≥nidInit</i> : <br><br><pre> <code class="java hljs">CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); result = apiPotentialIDOR;</code> </pre><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/xl/wa/rq/xlwarqf4bvr96xchztinpiua7h4.png"><br><br><h3>  IDOR: Paso 7. Encuentre todos los lugares para definir m√©todos de middleware </h3><br>  Encontremos las definiciones de todos los m√©todos intermedios que se pueden usar en lugares donde se procesan las solicitudes de los usuarios.  Para hacer esto, destacamos su propiedad com√∫n, por ejemplo, en todos estos m√©todos existe la creaci√≥n de un objeto <i>Request ()</i> , la creaci√≥n de un objeto es de tipo <i>CMx ObjectCreateExpr</i> : <br><br><pre> <code class="java hljs">CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName(<span class="hljs-string"><span class="hljs-string">"*Request*"</span></span>); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); result = middlewareDecl;</code> </pre> <br><br>  <i>(All - exclusionList)</i> : puede hacer esta sustracci√≥n de conjuntos y luego llamar a la funci√≥n CMxQL deseada del resultado.  <i>Solicitudes</i> ahora contiene todos los tokens con el nombre <i>Solicitud</i> y el tipo correspondiente a la creaci√≥n del objeto. <br><br>  Luego, usando el conocido <i>GetAncOfType (),</i> encontramos el token padre de tipo <i>MethodDecl</i> . <br><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/pp/ie/21/ppie21nmruhnqfekmune0fa5ytu.png"><br><br><h3>  IDOR: Paso 8. Revise todos los apiPotentialIDOR y seleccione solo aquellos middlewareDecl en los que no haya verificaci√≥n del propietario del objeto de buz√≥n </h3><br>  En la parte final de la solicitud, determinaremos a cu√°l de los m√©todos de middleware se llama directamente desde los m√©todos del punto de entrada y no verificaremos a qui√©n pertenece el <i>buz√≥n</i> .  Luego combine Flow para un an√°lisis m√°s conveniente de los resultados. <br><br>  Nuevas caracter√≠sticas que a√∫n no hemos utilizado: <br>  <i>GetCxListByPath ()</i> : esta funci√≥n es necesaria para iterar sobre Flow, si NO se usa, CMx comprimir√° Flow en el elemento de c√≥digo (en el primer nodo de flujo) <br>  <i>Concatenate * ()</i> : una serie de funciones necesarias para combinar varios flujos en uno <br>  <i>FindByParameters ()</i> : busca un m√©todo por un token de par√°metro espec√≠fico <br>  <i>GetName ()</i> : devolver√° una cadena con el nombre del token; si hay m√°s de un elemento en CxList, devolver√° el primero.  El m√©todo se usa solo cuando se itera sobre elementos de un conjunto. <br><br>  La parte final de la solicitud: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    CxList vulns = All.NewCxList(); //   Flow  apiPotentialIDOR foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { //    Flow CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); //       flow (mailboxid) CxList method_call = entry_point_tokens.FindByParameters(endNode); //     CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); //     if (method_decl.Count &gt; 0) { //       CxList _all = (All - exclusionList).GetByAncs(method_decl); //       if (_all.FindByName(idorSanitizer).Count &gt; 0) { //  ,       cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); //  ,   Flow     vulns } else { //     Flow       vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } }</span></span></code> </pre> <br><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/_z/qs/rj/_zqsrju8bqoni7u0ksolmokizhe.png"><br><br> <i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizamos </font><i><font style="vertical-align: inherit;">CocatenatePath</font></i><font style="vertical-align: inherit;"> para que al analizar todas las ubicaciones sea conveniente navegar a trav√©s del c√≥digo. </font><font style="vertical-align: inherit;">Este m√©todo adjunta un elemento de c√≥digo al flujo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IDOR: b√∫squeda final de IDOR </font></font></h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.FindByFileName("*WebMethodContext.java"); // 2.     CxList idorSanitizer = All.FindByName("*validateMailbox*"); // 3.    ‚Äì    HTTP  CxList webRemoteMethods = All.FindByCustomAttribute("WebRemote").GetAncOfType(typeof(MethodDecl)); // 4.         HTTP  mailboxid //     CxList entry_point_tokens = All.NewCxList(); foreach (CxList method in webRemoteMethods) { CxList method_tokens = All.GetByAncs(method); if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { } else { entry_point_tokens.Add(method_tokens); } } //    HTTP    -  CxList getMailboxHTTPParams = entry_point_tokens.FindByName("\"mailboxId\"") + entry_point_tokens.FindByName("\"mid\"") + entry_point_tokens.FindByName("\"boxid\""); CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); // 5.      middleware     CxList middlewareMethods = All.FindByShortName("user").GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); // 6.  middleware ,     mailboxid CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); // 7.      middleware      CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName("*Request*"); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); // 8.    apiPotentialIDOR     middlewareDecl,      CxList vulns = All.NewCxList(); foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); CxList method_call = entry_point_tokens.FindByParameters(endNode); CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); if (method_decl.Count &gt; 0) { CxList _all = (All - exclusionList).GetByAncs(method_decl); if (_all.FindByName(idorSanitizer).Count &gt; 0) { cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); } else { vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } } result = vulns;</span></span></code> </pre><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checkmarx analiza f√°cilmente el c√≥digo en tokens, mientras determina sus tipos. </font><font style="vertical-align: inherit;">Adem√°s, el analizador est√°tico realiza bien una b√∫squeda simple de tokens, por ejemplo, encuentra el token padre para el actual, encuentra la inicializaci√≥n de la variable, encuentra los par√°metros de los m√©todos, etc. </font><font style="vertical-align: inherit;">El flujo es casi tan bueno en la construcci√≥n (pero a veces todav√≠a falla). </font><font style="vertical-align: inherit;">Todo esto hace posible trabajar con el c√≥digo como con cualquier base de datos, con la diferencia de que la estructura del c√≥digo no est√° predefinida, y usted tiene que "personalizarlo" usted mismo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para reducir en gran medida la cantidad de falsos positivos, debe prestar atenci√≥n a lo siguiente:</font></font><br><ul><li>     ,       (   ). </li><li>     ,    (  ). ,     ¬´Privacy Violation¬ª,   ,         ,    Web UI.    , ..       UI    .       TLS        XSS     . </li><li>  -    ,           (,   ). ,   XXE  ,   , -    ,   . </li><li>   false positive,   ,           CMxQL   FindBy/GetBy.         ,     (        SQL). </li><li>   false positives,    ,      ,   ,       ,   CMx,      . ,       LDAP ,      .       c LDAP-   ,   ,      . </li></ul><br><br>   how-to     ¬´hello world¬ª  ,        Checkmarx. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477742/">https://habr.com/ru/post/477742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477732/index.html">Clasificaci√≥n incorrecta de los dedos de los sistemas de navegaci√≥n subacu√°tica</a></li>
<li><a href="../477734/index.html">Comprensi√≥n de UICollectionViewLayout con la aplicaci√≥n Fotos</a></li>
<li><a href="../477736/index.html">El camino del probador: del "freno de mano" a la automatizaci√≥n</a></li>
<li><a href="../477738/index.html">iKassa o c√≥mo domesticamos al "cajero digital"</a></li>
<li><a href="../477740/index.html">¬øY d√≥nde mirar este telescopio con tu ojo?</a></li>
<li><a href="../477744/index.html">¬øPor qu√© los profesionales a veces crean malas aplicaciones?</a></li>
<li><a href="../477746/index.html">Dise√±ador de monetizaci√≥n: qui√©n es y c√≥mo convertirse en uno</a></li>
<li><a href="../477752/index.html">Backend United # 5: Shawarma: microservicios, sistemas distribuidos y Kafka</a></li>
<li><a href="../477754/index.html">Compare micro: bit con Arduino. ¬øY c√≥mo obtener micro: bit gratis si no eres un estudiante de ingl√©s?</a></li>
<li><a href="../477756/index.html">C√≥mo nos casamos con dos sistemas bancarios de CRM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>