<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçï üë©üèª‚Äçü§ù‚Äçüë®üèø üî∏ Unit Testing und Python üë®üèº‚Äçüíª ‚õ©Ô∏è ü•£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Vadim, ich bin ein f√ºhrender Entwickler bei Mail.Ru Search. Ich werde unsere Erfahrungen mit Unit-Tests teilen. Der Artikel besteht aus ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unit Testing und Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/418929/"><img src="https://habrastorage.org/webt/vw/s_/rj/vws_rjpt_tkcghfjw_emwmzdakc.jpeg"><br><br>  Mein Name ist Vadim, ich bin ein f√ºhrender Entwickler bei Mail.Ru Search.  Ich werde unsere Erfahrungen mit Unit-Tests teilen.  Der Artikel besteht aus drei Teilen: Im ersten Teil werde ich Ihnen sagen, was wir im Allgemeinen mit Hilfe von Unit-Tests erreichen.  Der zweite Teil beschreibt die Prinzipien, denen wir folgen.  Im dritten Teil erfahren Sie, wie die genannten Prinzipien in Python implementiert werden. <br><a name="habracut"></a><br><h1>  Ziele </h1><br>  Es ist sehr wichtig zu verstehen, warum Sie Unit-Tests anwenden.  Konkrete Ma√ünahmen werden davon abh√§ngen.  Wenn Sie die Komponententests falsch verwenden oder mit ihrer Hilfe nicht das tun, was Sie wollten, wird nichts Gutes daraus.  Daher ist es sehr wichtig, im Voraus zu verstehen, welche Ziele Sie verfolgen. <br><br>  In unseren Projekten verfolgen wir mehrere Ziele. <br><br>  Die erste ist die banale <b>Regression</b> : Um etwas im Code zu reparieren, f√ºhren Sie die Tests aus und stellen Sie fest, dass nichts kaputt gegangen ist.  Obwohl es in der Tat nicht so einfach ist, wie es sich anh√∂rt. <br><br>  Das zweite Ziel besteht <b>darin, die Auswirkungen der Architektur zu bewerten</b> .  Wenn Sie im Projekt obligatorische Komponententests einf√ºhren oder sich einfach mit den Entwicklern auf die Verwendung von Komponententests einigen, wirkt sich dies sofort auf den Schreibstil des Codes aus.  Es ist unm√∂glich, Funktionen in 300 Zeilen mit 50 lokalen Variablen und 15 Parametern zu schreiben, wenn diese Funktionen einem Komponententest unterzogen werden.  Dank dieser Tests werden die Schnittstellen au√üerdem verst√§ndlicher und es treten einige Problembereiche auf.  Wenn der Code nicht so hei√ü ist, ist der Test eine Kurve und f√§llt sofort auf. <br><br>  Das dritte Ziel ist <b>es, den Code klarer zu machen</b> .  Angenommen, Sie sind zu einem neuen Projekt gekommen und haben 50 MB Quellcode erhalten.  M√∂glicherweise k√∂nnen Sie sie einfach nicht herausfinden.  Wenn es keine Komponententests gibt, ist die einzige M√∂glichkeit, sich neben dem Lesen der Quelle mit der Arbeit des Codes vertraut zu machen, die ‚ÄûPoke-Methode‚Äú.  Wenn das System jedoch recht kompliziert ist, kann es viel Zeit in Anspruch nehmen, √ºber die Schnittstelle zu den erforderlichen Codeteilen zu gelangen.  Und dank Unit-Tests k√∂nnen Sie sehen, wie der Code von √ºberall ausgef√ºhrt wird. <br><br>  Das vierte Ziel besteht darin <b>, das Debuggen zu vereinfachen</b> .  Sie haben beispielsweise eine Klasse gefunden und m√∂chten diese debuggen.  Wenn es anstelle von Komponententests nur Systemtests oder gar keine Tests gibt, bleibt es nur, √ºber die Schnittstelle an den richtigen Ort zu gelangen.  Ich habe zuf√§llig an einem Projekt teilgenommen, bei dem es zum Testen einiger Funktionen eine halbe Stunde gedauert hat, einen Benutzer zu erstellen, ihm Geld in Rechnung zu stellen, seinen Status zu √§ndern, eine Art Cron zu starten, sodass dieser Status an einen anderen Ort √ºbertragen wurde, dann auf etwas in der Benutzeroberfl√§che zu klicken und etwas zu starten ein anderes cron ... Nach einer halben Stunde erschien endlich ein Bonusprogramm f√ºr diesen Benutzer.  Und wenn ich Unit-Tests h√§tte, k√∂nnte ich sofort an den richtigen Ort kommen. <br><br>  Schlie√ülich ist <b>Komfort</b> das wichtigste und sehr abstrakte Ziel, das alle vorherigen verbindet.  Wenn ich Unit-Tests habe, habe ich weniger Stress beim Arbeiten mit Code, weil ich verstehe, was passiert.  Ich kann eine unbekannte Quelle verwenden, drei Zeilen korrigieren, Tests ausf√ºhren und sicherstellen, dass der Code wie beabsichtigt funktioniert.  Und es ist nicht einmal so, dass die Tests gr√ºn sind: Sie k√∂nnen rot sein, aber genau dort, wo ich es erwarte.  Das hei√üt, ich verstehe, wie der Code funktioniert. <br><br><h1>  Prinzipien </h1><br>  Wenn Sie Ihre Ziele verstehen, k√∂nnen Sie verstehen, was getan werden muss, um sie zu erreichen.  Und hier beginnen die Probleme.  Tatsache ist, dass viele B√ºcher und Artikel √ºber Unit-Tests geschrieben wurden, aber die Theorie ist noch sehr unausgereift. <br><br>  Wenn Sie jemals Artikel √ºber Komponententests gelesen haben, versucht haben, die beschriebenen anzuwenden, und es Ihnen nicht gelungen ist, ist es sehr wahrscheinlich, dass der Grund die Unvollkommenheit der Theorie ist.  Das passiert die ganze Zeit.  Ich habe, wie alle Entwickler, einmal gedacht, dass das Problem in mir liegt.  Und dann wurde ihm klar: Es kann nicht sein, dass ich mich so oft geirrt habe.  Und er entschied, dass es beim Testen von Einheiten notwendig war, von seinen eigenen √úberlegungen auszugehen, um vern√ºnftiger zu handeln. <br><br>  Der Standard-Ratschlag, den Sie in allen B√ºchern und Artikeln finden: ‚ÄûSie sollten nicht die Implementierung, sondern die Benutzeroberfl√§che testen‚Äú.  Schlie√ülich kann sich die Implementierung √§ndern, die Schnittstelle jedoch nicht.  Lassen Sie es uns testen, damit die Tests nicht immer bei jeder Gelegenheit fallen.  Der Rat scheint nicht schlecht zu sein, und alles scheint logisch.  Aber wir wissen es sehr gut: Um etwas zu testen, m√ºssen Sie einige Testwerte ausw√§hlen.  Normalerweise werden beim Testen von Funktionen die sogenannten √Ñquivalenzklassen unterschieden: die Menge von Werten, bei denen sich die Funktion gleichm√§√üig verh√§lt.  Grob gesagt ist der Test f√ºr jeden wenn.  Um zu wissen, welche √Ñquivalenzklassen wir haben, ist eine Implementierung erforderlich.  Sie testen es nicht, aber Sie brauchen es. Sie sollten es untersuchen, um zu wissen, welche Testwerte Sie ausw√§hlen m√ºssen. <br><br>  Sprechen Sie mit jedem Tester: Er wird Ihnen sagen, dass er sich beim manuellen Testen immer eine Implementierung vorstellt.  Aus seiner Erfahrung versteht er perfekt, wo Programmierer normalerweise Fehler machen.  Der Tester √ºberpr√ºft nicht alles, indem er zuerst 5, dann 6 und dann 7 eingibt. Er √ºberpr√ºft 5, abc, ‚Äì7 und die Zahl besteht aus 100 Zeichen, da er wei√ü, dass die Implementierung f√ºr diese Werte unterschiedlich sein kann, f√ºr 6 und 7 jedoch unwahrscheinlich ist . <br><br>  Es ist also nicht klar, wie man dem Prinzip "Testen der Schnittstelle, nicht der Implementierung" folgt.  Sie k√∂nnen nicht einfach nehmen, die Augen schlie√üen und einen Test schreiben.  TDD versucht, dieses Problem teilweise zu l√∂sen.  Die Theorie schl√§gt vor, √Ñquivalenzklassen einzeln einzuf√ºhren und Tests f√ºr sie zu schreiben.  Ich habe viele B√ºcher und Artikel zu diesem Thema gelesen, aber irgendwie bleibt es nicht h√§ngen.  Ich stimme jedoch der These zu, dass Tests zuerst geschrieben werden sollten.  Wir nennen diesen Haupttest zuerst.  Wir haben kein TDD, und im Zusammenhang mit dem oben Gesagten werden Tests nicht geschrieben, bevor der Code erstellt wird, sondern parallel dazu. <br><br>  Ich empfehle definitiv nicht, Tests r√ºckwirkend zu schreiben.  Schlie√ülich beeinflussen sie die Architektur, und wenn sie sich bereits niedergelassen hat, ist es zu sp√§t, sie zu beeinflussen - alles muss neu geschrieben werden.  Mit anderen Worten, die Codetestbarkeit ist eine separate Eigenschaft, die der Code <b>verleihen muss</b> , und wird nicht zu einer solchen.  Daher versuchen wir, Tests zusammen mit Code zu schreiben.  Glauben Sie nicht an Geschichten wie ‚ÄûLassen Sie uns in drei Monaten ein Projekt schreiben und dann in einer Woche alles mit Tests abdecken‚Äú, dies wird niemals passieren. <br><br>  Das Wichtigste, was Sie verstehen sollten: Unit-Tests sind keine M√∂glichkeit, den Code zu √ºberpr√ºfen, und keine M√∂glichkeit, seine Richtigkeit zu √ºberpr√ºfen.  Dies ist Teil Ihrer Architektur, des Designs Ihrer Anwendung.  Wenn Sie mit Unit-Tests arbeiten, √§ndern Sie Ihre Gewohnheiten.  Tests, die nur die Richtigkeit √ºberpr√ºfen, sind eher Abnahmetests.  Es ist ein Fehler zu glauben, dass Sie dann etwas mit Unit-Tests abdecken k√∂nnen oder dass dann der Code nicht √ºberpr√ºft werden muss. <br><br><h1>  Python-Implementierung </h1><br>  Wir verwenden die Standard-Unittest-Bibliothek aus der xUnit-Familie.  Die Geschichte ist folgende: Es gab die SmallTalk-Sprache und darin die SUnit-Bibliothek.  Jeder mochte es, sie fingen an, es zu kopieren.  Die Bibliothek wurde unter dem Namen Junit nach Java importiert, von dort in C ++ unter dem Namen CppUnit und unter dem Namen RUnit in Ruby (dann wurde sie in RSpec umbenannt).  Schlie√ülich wurde die Bibliothek von Java unter dem Namen unittest nach Python ‚Äûverschoben‚Äú.  Und sie importierten es so w√∂rtlich, dass sogar CamelCase √ºbrig blieb, obwohl dies nicht PEP 8 entspricht. <br><br>  √úber xUnit gibt es ein wundervolles Buch, "xUnit Test Patterns".  Es beschreibt, wie man mit den Rahmenbedingungen dieser Familie arbeitet.  Der einzige Nachteil des Buches ist seine Gr√∂√üe: Es ist riesig, aber ungef√§hr 2/3 des Inhalts sind ein Katalog von Mustern.  Und das erste Drittel des Buches ist einfach wunderbar, dies ist eines der besten B√ºcher √ºber IT, die ich getroffen habe. <br><br>  Ein Unit-Test ist ein regul√§rer Code mit einer bestimmten Standardarchitektur.  Alle Unit-Tests bestehen aus drei Phasen: Einrichtung, √úbung und √úberpr√ºfung.  Sie bereiten die Daten vor, f√ºhren die Tests durch und pr√ºfen, ob alles im richtigen Zustand ist. <br><br><img src="https://habrastorage.org/webt/mi/ph/la/miphla26gfglcsjvog2giitgrko.jpeg"><br><br><h3>  Setup </h3><br>  Die schwierigste und interessanteste Etappe.  Es kann sehr schwierig sein, das System in den urspr√ºnglichen Zustand zu versetzen, von dem aus Sie es testen m√∂chten.  Und der Zustand des Systems kann beliebig komplex sein. <br><br>  Bis zum Aufruf Ihrer Funktion k√∂nnten viele Ereignisse eingetreten sein, eine Million Objekte k√∂nnten im Speicher erstellt worden sein.  In allen mit Ihrer Software verkn√ºpften Komponenten - im Dateisystem, in der Datenbank, in den Caches - befindet sich bereits etwas, und die Funktion kann nur in dieser Umgebung ausgef√ºhrt werden.  Und wenn die Umgebung nicht vorbereitet ist, sind die Aktionen der Funktion bedeutungslos. <br><br>  Normalerweise behauptet jeder, dass Sie in keinem Fall Dateisysteme, Datenbanken oder andere separate Komponenten verwenden k√∂nnen, da dies Ihren Test nicht modular, sondern integrativ macht.  Meiner Meinung nach ist dies nicht der Fall, da der Integrationstest durch den Integrationstest durchgef√ºhrt wird.  Wenn Sie einige Komponenten nicht zur √úberpr√ºfung verwenden, sondern nur, damit das System funktioniert, ist daran nichts auszusetzen.  Ihr Code interagiert mit vielen Komponenten des Computers und des Betriebssystems.  Das einzige Problem bei der Verwendung eines Dateisystems oder einer Datenbank ist die Geschwindigkeit. <br><br>  Direkt im Code verwenden wir die <b>Abh√§ngigkeitsinjektion</b> .  Sie k√∂nnen Parameter anstelle der Standardparameter in die Funktion einf√ºgen.  Sie k√∂nnen sogar Links zu Bibliotheken weiterleiten.  Oder Sie k√∂nnen einen Stub anstelle einer Anforderung verschieben, damit der Code aus den Tests nicht auf das Netzwerk zugreift.  Sie k√∂nnen benutzerdefinierte Protokollierer in den Klassenattributen speichern, um nicht auf die Festplatte zu schreiben und Zeit zu sparen. <br><br>  F√ºr Stubs verwenden wir das √ºbliche Mock von Unittest.  Es gibt auch eine Patch-Funktion, die, anstatt Abh√§ngigkeiten ehrlich zu implementieren, einfach sagt: "In diesem Paket ist dieser Import ein Ersatz f√ºr einen anderen."  Dies ist praktisch, da Sie nirgendwo etwas werfen m√ºssen.  Stimmt, dann ist nicht klar, wer was ersetzt hat, also gehen Sie vorsichtig damit um. <br><br>  Was das Dateisystem betrifft, so ist das F√§lschen ganz einfach.  Es gibt ein io-Modul mit <code>io.StringIO</code> und <code>io.BytesIO</code> .  Sie k√∂nnen datei√§hnliche Objekte erstellen, die nicht auf die Festplatte zugreifen.  Aber wenn Ihnen dies pl√∂tzlich nicht mehr ausreicht, gibt es ein wunderbares Tempfile-Modul mit Kontextmanagern f√ºr tempor√§re Dateien, Verzeichnisse, benannte Dateien usw.  Tempfile ist ein Supermodul, wenn IO aus irgendeinem Grund nicht zu Ihnen passt. <br><br>  Mit einer Datenbank ist alles komplizierter.  Es gibt eine Standardempfehlung: "Verwenden Sie keine echte, sondern eine gef√§lschte Basis."  Ich wei√ü nichts √ºber dich, aber in meinem Leben habe ich keine einzige gef√§lschte und ausreichend funktionierende Basis gesehen.  Jedes Mal, wenn ich um Rat gefragt wurde, was speziell unter Python oder Perl zu tun ist, antworteten sie, dass niemand etwas bereit wusste, und boten an, etwas Eigenes zu schreiben.  Ich kann mir nicht vorstellen, wie man einen Emulator schreiben kann, zum Beispiel PostgreSQL.  Ein weiterer Tipp: "Dann holen Sie sich SQLite."  Dies wird jedoch die Isolation aufheben, da SQLite mit dem Dateisystem zusammenarbeitet.  Wenn Sie beispielsweise MySQL oder PostgreSQL verwenden, funktioniert SQLite wahrscheinlich nicht.  Wenn Sie den Eindruck haben, dass Sie die spezifischen Funktionen bestimmter Produkte nicht nutzen, irren Sie sich h√∂chstwahrscheinlich.  Selbst f√ºr allt√§gliche Dinge wie das Arbeiten mit Datumsangaben verwenden Sie bestimmte Funktionen, die nur von Ihrem DBMS unterst√ºtzt werden. <br><br>  Infolgedessen verwenden sie normalerweise eine echte Basis.  Die L√∂sung ist nicht schlecht, nur m√ºssen wir ein gewisses Ma√ü an Genauigkeit zeigen.  Verwenden Sie keine zentralisierte Datenbank, da Tests untereinander unterbrochen werden k√∂nnen.  Idealerweise sollte die Basis selbst w√§hrend der Tests ansteigen und nach dem Test selbst anhalten. <br><br>  Eine etwas schlimmere Situation ist, wenn Sie eine lokale Datenbank ausf√ºhren m√ºssen, die verwendet wird.  Aber die Frage ist, wie werden die Daten dorthin gelangen?  Wir haben bereits gesagt, dass es einen Anfangszustand des Systems geben muss, es m√ºssen einige Daten in der Datenbank sein.  Woher sie kommen, ist keine leichte Frage. <br><br>  Der naivste Ansatz, auf den ich gesto√üen bin, ist die Verwendung einer Kopie einer echten Datenbank.  Es wurde regelm√§√üig eine Kopie entnommen, aus der vertrauliche Daten gel√∂scht wurden.  Die Autoren argumentierten, dass reale Daten am besten zum Testen geeignet sind.  Au√üerdem ist das Schreiben von Tests f√ºr eine Kopie einer realen Datenbank eine Qual.  Sie wissen nicht, welche Daten vorhanden sind.  Sie m√ºssen zuerst herausfinden, worauf Sie testen m√∂chten.  Wenn diese Informationen nicht vorhanden sind, ist unklar, was zu tun ist.  Es endete damit, dass sie in diesem Projekt beschlossen, Tests f√ºr das Konto der Betriebsabteilung zu schreiben, die sich ‚Äûniemals √§ndern werden‚Äú.  Nat√ºrlich hat sie sich nach einiger Zeit ver√§ndert. <br><br>  Darauf folgt normalerweise die Entscheidung: ‚ÄûMachen wir eine Besetzung der realen Basis, kopieren Sie sie und synchronisieren Sie nicht mehr.  Dann ist es m√∂glich, an ein bestimmtes Objekt gebunden zu werden, zu beobachten, was dort passiert, und Tests zu schreiben. ‚Äú  Es stellt sich sofort die Frage: Was passiert, wenn der Datenbank neue Tabellen hinzugef√ºgt werden?  Anscheinend m√ºssen Sie gef√§lschte Daten manuell eingeben. <br><br>  Da wir dies jedoch trotzdem tun, bereiten wir die Grundbesetzung sofort manuell vor.  Diese Option ist der in Django normalerweise als Fixtures bezeichneten Option sehr √§hnlich: Sie erstellen riesige JSON-Dateien, laden Testf√§lle f√ºr alle Gelegenheiten hoch, senden sie zu Beginn des Tests an die Datenbank, und bei uns ist alles in Ordnung.  Dieser Ansatz hat auch viele Nachteile.  Die Daten sind auf einem Haufen gestapelt, es ist nicht klar, auf welchen Test sie sich beziehen.  Niemand kann verstehen, ob die Daten gel√∂scht wurden oder nicht.  Und es gibt inkompatible Zust√§nde der Datenbank: Zum Beispiel muss ein Test keine Benutzer in der Datenbank haben und der andere, um sie zu haben.  Diese beiden Bedingungen k√∂nnen nicht gleichzeitig in derselben Form gelagert werden.  In diesem Fall muss einer der Tests die Datenbank √§ndern.  Und da Sie sich sowieso noch damit befassen m√ºssen, ist es am einfachsten, von einer leeren Datenbank auszugehen, sodass bei jedem Test die erforderlichen Daten dort abgelegt werden und am Ende des Tests die Datenbank gel√∂scht wird.  Der einzige Nachteil dieses Ansatzes ist die Schwierigkeit, Daten in jedem Test zu erstellen.  In einem der Projekte, in denen ich gearbeitet habe, war es zum Erstellen eines Dienstes erforderlich, 8 Entit√§ten in verschiedenen Tabellen zu generieren: einen Dienst auf einem pers√∂nlichen Konto, ein pers√∂nliches Konto auf einem Kunden, einen Kunden auf einer juristischen Person, eine juristische Person in einer Stadt, einen Kunden in einer Stadt usw.  Bis Sie dies alles in einer Kette erstellen, werden Sie keinen Fremdschl√ºssel erf√ºllen, nichts funktioniert. <br><br>  F√ºr solche Situationen gibt es spezielle Bibliotheken, die das Leben erheblich erleichtern.  Sie k√∂nnen Hilfswerkzeuge schreiben, die normalerweise als Fabriken bezeichnet werden (nicht mit dem Entwurfsmuster verwechseln).  Zum Beispiel haben wir die factory_boy-Bibliothek verwendet, die f√ºr Django geeignet ist.  Dies ist ein Klon der Bibliothek factory_girl, die letztes Jahr aus Gr√ºnden der politischen Korrektheit in factory_bot umbenannt wurde.  Das Schreiben einer solchen Bibliothek f√ºr Ihr eigenes Framework kostet nichts.  Es basiert auf einer sehr wichtigen Idee: Sie erstellen einmal eine Factory f√ºr die Objekte, die Sie erzeugen m√∂chten, stellen Verbindungen daf√ºr her und teilen dem Benutzer dann mit: ‚ÄûWenn Sie erstellt sind, nehmen Sie Ihren n√§chsten Namen und generieren Sie die Gruppe selbst mithilfe der Gruppenfactory.‚Äú  Und in der Fabrik ist alles genau gleich: Generieren Sie den Namen so, verwandte Entit√§ten so und so. <br><br>  Infolgedessen bleibt nur eine letzte Zeile im Code: <code>user = UserFactory()</code> .  Der Benutzer wurde erstellt, und Sie k√∂nnen mit ihm arbeiten, da er unter der Haube alles generiert hat, was ben√∂tigt wird.  Wenn Sie m√∂chten, k√∂nnen Sie etwas manuell konfigurieren. <br><br>  Um die Daten nach dem Testen zu bereinigen, verwenden wir triviale Transaktionen.  Zu Beginn jedes Tests wird BEGIN durchgef√ºhrt, der Test macht etwas mit der Basis und nach dem Test wird ROLLBACK durchgef√ºhrt.  Wenn im Test selbst Transaktionen erforderlich sind - zum Beispiel, weil sie etwas <code>break_db</code> f√ºr die Datenbank <code>break_db</code> -, ruft sie die von uns aufgerufene Methode <code>break_db</code> , teilt dem Framework mit, dass die Datenbank <code>break_db</code> wurde, und das Framework rollt sie erneut.  Es stellt sich langsam heraus, aber da es normalerweise nur sehr wenige Tests gibt, die Transaktionen erfordern, ist alles in Ordnung. <br><br><h3>  √úbung </h3><br>  √úber diese Etappe gibt es nichts Besonderes zu erz√§hlen.  Das Einzige, was hier schief gehen kann, ist, sich beispielsweise dem Internet zuzuwenden.  Einige Zeit hatten wir administrativ damit zu k√§mpfen: Wir sagten den Programmierern, wir m√ºssten entweder Funktionen eintauchen, die irgendwohin gehen, oder spezielle Flags werfen, damit die Funktionen dies nicht tun.  Wenn der Test auf Corporate etcd zugreift, ist dies nicht gut.  Als Ergebnis kamen wir zu dem Schluss, dass alles verschwendet wurde: Wir selbst vergessen st√§ndig, dass eine Funktion eine Funktion aufruft, die eine Funktion aufruft, die zu etcd geht.  Daher haben wir im setUp der Basisklasse das Moki aller Aufrufe hinzugef√ºgt, dh mit Hilfe von Stubs alle Aufrufe blockiert, wo sie nicht platziert wurden. <br><br>  Stubs k√∂nnen einfach mit Patchern erstellt, Patcher in ein separates W√∂rterbuch gestellt und Zugriff auf alle Tests gew√§hrt werden.  Standardm√§√üig k√∂nnen Tests nirgendwo hingehen. Wenn Sie f√ºr einige noch Open Access ben√∂tigen, k√∂nnen Sie sie umleiten.  Sehr bequem.  Jenkins sendet nachts keine SMS mehr an Ihre Kunden :) <br><br><h3>  √úberpr√ºfen Sie </h3><br>  In dieser Phase verwenden wir aktiv selbstgeschriebene Aussagen, auch einzeilige.  Wenn Sie die Existenz einer Datei im Test testen, empfehle <code>self.assertTrue(file_exists(f))</code> , anstelle von assert <code>self.assertTrue(file_exists(f))</code> schreiben, dass assert <code>not file exists</code> .  Holivar ist damit verbunden: Soll ich CamelCase weiterhin in Namen verwenden, wie in unittest, oder sollte ich PEP 8 folgen?  Ich habe keine Antwort.  Wenn Sie PEP 8 folgen, gibt es im Testcode ein Durcheinander von CamelCase und snake_case.  Und wenn Sie CamelCase verwenden, entspricht dies nicht PEP 8. <br><br>  Und der letzte.  Angenommen, Sie haben einen Code, der etwas testet, und es gibt viele Datenoptionen, auf denen dieser Code ausgef√ºhrt werden muss.  Wenn Sie py.test verwenden, k√∂nnen Sie dort denselben Test mit unterschiedlichen Eingabedaten ausf√ºhren.  Wenn Sie nicht √ºber py.test verf√ºgen, k√∂nnen Sie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solchen Dekorator verwenden</a> .  Ein Tisch wird an den Dekorateur √ºbergeben, und aus einem Test werden mehrere andere, von denen jeder einen der F√§lle testet. <br><br><h1>  Fazit </h1><br>  Vertrauen Sie Artikeln und B√ºchern nicht unbedingt.  Wenn Sie denken, dass sie falsch sind, ist es m√∂glich, dass dies tats√§chlich so ist. <br><br>  F√ºhlen Sie sich frei, Abh√§ngigkeitstests zu verwenden.  Daran ist nichts auszusetzen.  Wenn Sie memcached ausgel√∂st haben, weil Ihr Code ohne memcached nicht normal funktioniert, ist das in Ordnung.  Aber es ist besser, wenn m√∂glich darauf zu verzichten. <br><br>  Achten Sie auf die Fabriken.  Dies ist ein sehr interessantes Muster. <br><br>  PS Ich lade Sie zum Programmieren in Python auf den Telegrammkanal meines Autors ein - @pythonetc. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418929/">https://habr.com/ru/post/de418929/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418919/index.html">√úber das berufliche Wachstum des Designers und die Arbeit mit Stress. Und wie man in den schwierigsten Zeiten Kraft findet</a></li>
<li><a href="../de418921/index.html">4 Bibliotheken erleichtern einem React-Entwickler das Leben</a></li>
<li><a href="../de418923/index.html">PWA ist gerecht</a></li>
<li><a href="../de418925/index.html">Big Data - Bruder oder nicht Bruder</a></li>
<li><a href="../de418927/index.html">Amazon Dark Patterns</a></li>
<li><a href="../de418931/index.html">RubyMine 2018.2: Anh√§ngen eines Debuggers an Remote-Prozesse, Chruby, verbesserte Code-Analyse und vieles mehr</a></li>
<li><a href="../de418933/index.html">OnePlus Review 6. Als die Chinesen alles genauso machten wie beim letzten Mal</a></li>
<li><a href="../de418935/index.html">DZ Online Tech: ABBYY. Wie kann man in neuronalen Netzen nicht verwirrt werden?</a></li>
<li><a href="../de418937/index.html">Wir feiern das 8-j√§hrige Jubil√§um mit der ersten Ver√∂ffentlichung an der GeekUniversity</a></li>
<li><a href="../de418941/index.html">Keine Angst vor Microservice: Alexey Baitov √ºber den Einsatz von Microservice-Architektur in der Praxis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>