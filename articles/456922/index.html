<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游깴 游뱣 游땢 C칩mo se dise침an y fabrican los procesadores: los fundamentos de la arquitectura inform치tica 游쓇릞 游떁 游땕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Percibimos el procesador central como el "cerebro" de una computadora, pero 쯤u칠 significa realmente? 쯈u칠 sucede exactamente dentro de los miles de m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C칩mo se dise침an y fabrican los procesadores: los fundamentos de la arquitectura inform치tica</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456922/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/772/582/2e1/7725822e1e2ef8975b16770b48a0e199.jpg" alt="imagen"></div><br>  Percibimos el procesador central como el "cerebro" de una computadora, pero 쯤u칠 significa realmente?  쯈u칠 sucede exactamente dentro de los miles de millones de transistores que hacen que una computadora funcione?  En nuestra nueva miniserie de cuatro art칤culos, consideraremos el proceso de creaci칩n de la arquitectura de los equipos inform치ticos y hablaremos sobre los principios de su funcionamiento. <br><br>  En esta serie hablaremos sobre arquitectura de computadoras, dise침o de placas de procesador, VLSI (integraci칩n a gran escala), fabricaci칩n de chips y tendencias futuras en el campo de la tecnolog칤a inform치tica.  Si estaba interesado en comprender los detalles de los procesadores, entonces es mejor comenzar el estudio con esta serie de art칤culos. <br><br>  Comenzaremos con una explicaci칩n de muy alto nivel de lo que hace el procesador y c칩mo los bloques de construcci칩n se conectan en una estructura funcional.  En particular, consideraremos los n칰cleos de procesador, la jerarqu칤a de memoria, la predicci칩n de ramificaci칩n y m치s.  Primero, necesitamos dar una definici칩n simple de lo que hace la CPU.  La explicaci칩n m치s simple: el procesador sigue un conjunto de instrucciones para realizar una determinada operaci칩n en muchos datos entrantes.  Por ejemplo, puede leer un valor de la memoria, luego agregarlo a otro valor y finalmente guardar el resultado en la memoria en una direcci칩n diferente.  Puede ser algo m치s complicado, por ejemplo, la divisi칩n de dos n칰meros, si el resultado del c치lculo anterior es mayor que cero. <br><br>  Los programas, como un sistema operativo o un juego, son secuencias de instrucciones que la CPU debe ejecutar.  Estas instrucciones se cargan desde la memoria y se ejecutan en un procesador simple uno tras otro hasta que el programa finaliza.  Los desarrolladores de software escriben programas en lenguajes de alto nivel, como C ++ o Python, pero el procesador no puede entenderlos.  칄l entiende solo unos y ceros, por lo que debemos representar de alguna manera el c칩digo en este formato. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/9ea/109/0959ea1090226766b43f20c46c8ed6d1.png"></div><br>  Los programas se compilan en un conjunto de instrucciones de bajo nivel llamado <em>lenguaje ensamblador</em> , que forma parte de la arquitectura del conjunto de instrucciones (ISA).  Este es un conjunto de instrucciones que la CPU debe comprender y ejecutar.  Algunos de los ISA m치s comunes son x86, MIPS, ARM, RISC-V y PowerPC.  De la misma manera que la sintaxis para escribir una funci칩n en C ++ difiere de la funci칩n que realiza la misma acci칩n en Python, cada ISA tiene su propia sintaxis diferente. <br><br>  Estas NIA se pueden dividir en dos categor칤as principales: longitud fija y variable.  ISA RISC-V utiliza instrucciones de longitud fija, lo que significa que un n칰mero predeterminado de bits en cada instrucci칩n determina de qu칠 tipo es la instrucci칩n.  En x86, todo es diferente, usa instrucciones de longitud variable.  En x86, las instrucciones se pueden codificar de diferentes maneras con diferentes n칰meros de bits para diferentes partes.  Debido a esta complejidad, el decodificador de instrucciones en el procesador x86 suele ser la parte m치s compleja de todo el dispositivo. <br><br>  Las instrucciones de longitud fija proporcionan una decodificaci칩n simple debido a una estructura constante, pero limitan el n칰mero total de instrucciones que puede admitir ISA.  Si bien las versiones populares de la arquitectura RISC-V tienen aproximadamente 100 instrucciones y todas ellas son de c칩digo abierto, la arquitectura x86 es propietaria y nadie sabe cu치ntas instrucciones contiene.  En general, se cree que hay varios miles de instrucciones x86, pero nadie publica el n칰mero exacto.  A pesar de las diferencias entre los ISA, de hecho, todos tienen la misma funcionalidad b치sica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/0a8/074/acc0a807407b41b94459d8202b0c6b4e.png"></div><br>  <i>Un ejemplo de algunas instrucciones RISC-V.</i>  <i>El c칩digo de operaci칩n a la derecha tiene 7 bits de longitud y determina el tipo de instrucci칩n.</i>  <i>Adem치s, cada instrucci칩n contiene bits que definen los registros utilizados y las funciones realizadas.</i>  <i>Entonces, las instrucciones del ensamblador se dividen en c칩digo binario para que el procesador lo entienda.</i> <br><br>  Ahora estamos listos para encender la computadora y comenzar a ejecutar programas.  La ejecuci칩n de la instrucci칩n tiene varias partes b치sicas, que se dividen en muchas etapas del procesador. <br><br>  La primera etapa es la transferencia de instrucciones desde la memoria al procesador para comenzar la ejecuci칩n.  En el segundo paso, la instrucci칩n se decodifica para que la CPU pueda entender qu칠 tipo de instrucci칩n es.  Existen muchos tipos, incluidas las instrucciones aritm칠ticas, las instrucciones de bifurcaci칩n y las instrucciones de memoria.  Despu칠s de que la CPU descubre qu칠 tipo de instrucci칩n est치 ejecutando, los operandos para la instrucci칩n se toman de la memoria o de los registros internos de la CPU.  Si desea agregar el n칰mero A y el n칰mero B, no puede agregar hasta que sepa los valores de A y B. La mayor칤a de los procesadores modernos son de 64 bits, es decir, el tama침o de cada valor de datos es de 64 bits. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/105/5cd/f55/1055cdf5560f78a1bbe61b6acbfb4d4d.png"></div><br>  <i>64 bits es el ancho del registro del procesador, el canal de datos y / o la direcci칩n de memoria.</i>  <i>Para los usuarios comunes, esto significa cu치nta informaci칩n puede procesar una computadora a la vez, y esto se entiende mejor en comparaci칩n con un pariente de arquitectura m치s joven: un procesador de 32 bits.</i>  <i>La arquitectura de 64 bits puede procesar el doble de bits de informaci칩n a la vez (64 bits frente a 32).</i> <br><br>  Habiendo recibido los operandos para la instrucci칩n, el procesador los transfiere a la etapa de ejecuci칩n, donde la operaci칩n se realiza en los datos entrantes.  Esto puede sumar n칰meros, realizar manipulaciones l칩gicas con n칰meros o simplemente pasar n칰meros sin cambiarlos.  Despu칠s de calcular el resultado, se puede requerir acceso a la memoria para almacenarlo, o el procesador simplemente puede almacenar el valor en uno de sus registros internos.  Despu칠s de guardar el resultado, la CPU actualiza el estado de los diversos elementos y pasa a la siguiente instrucci칩n. <br><br>  Esta explicaci칩n, por supuesto, se simplifica enormemente, y la mayor칤a de los procesadores modernos dividen estas varias etapas en 20 o incluso m치s etapas peque침as para aumentar la eficiencia.  Esto significa que aunque el procesador comienza y termina con varias instrucciones en cada ciclo, puede llevar 20 o m치s ciclos ejecutar una instrucci칩n de principio a fin.  Tal modelo generalmente se llama tuber칤a ("tuber칤a", generalmente traducida al ruso como "transportador"), porque lleva tiempo llenar la tuber칤a con l칤quido y completarla, pero despu칠s de llenar el flujo (salida de datos) ser치 constante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f4/94c/b7f/5f494cb7fea80ae36c741da698beb07c.png"></div><br>  <i>Un ejemplo de un transportador de 4 etapas.</i>  <i>Los rect치ngulos multicolores indican instrucciones que son independientes entre s칤.</i> <br><br>  El ciclo completo por el que pasa la instrucci칩n es un proceso coordinado con mucho cuidado, pero no todas las instrucciones pueden completarse al mismo tiempo.  Por ejemplo, la adici칩n es muy r치pida, y dividir o cargar desde la memoria puede tomar miles de ciclos.  En lugar de detener todo el procesador hasta completar una instrucci칩n lenta, la mayor칤a de los procesadores modernos los ejecutan con un cambio de orden.  Es decir, determinan cu치l de las instrucciones es m치s ventajosa ejecutar en este momento y almacenan otras instrucciones que a칰n no est치n listas.  Si la instrucci칩n actual a칰n no est치 lista, entonces el procesador puede avanzar en el c칩digo para ver si hay algo m치s listo. <br><br>  Adem치s de ejecutar con una secuencia de cambios, los procesadores modernos usan una tecnolog칤a llamada <em>arquitectura superescalar</em> .  Esto significa que en cualquier momento, el procesador ejecuta simult치neamente muchas instrucciones en cada etapa de la tuber칤a.  Tambi칠n puede esperar que cientos m치s comiencen su ejecuci칩n, y para poder ejecutar varias instrucciones simult치neamente dentro de los procesadores, hay varias copias de cada etapa de la tuber칤a.  Si el procesador ve que dos instrucciones est치n listas para la ejecuci칩n, y no hay dependencia entre ellas, entonces no espera hasta que se completen por separado, sino que las ejecuta simult치neamente.  Una implementaci칩n popular de esta arquitectura se llama Multithreading simult치neo (SMT) y tambi칠n se conoce como Hyper-Threading.  Los procesadores Intel y AMD ahora admiten SMT de doble cara, mientras que IBM ha desarrollado chips que admiten hasta ocho SMT. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/279/f3d/7ff/279f3d7fffe891e166b1a4547223363c.png"></div><br>  Para completar esta ejecuci칩n cuidadosamente coordinada, el procesador, adem치s del n칰cleo base, tiene muchos elementos adicionales.  El procesador tiene cientos de m칩dulos separados, cada uno de los cuales tiene una funci칩n espec칤fica, pero solo consideraremos los conceptos b치sicos.  Los m치s importantes y rentables son los cach칠s y el predictor de transiciones.  Hay otras estructuras adicionales que no consideraremos: reordenar los b칰feres, registrar tablas de cambio de nombre y estaciones de respaldo. <br><br>  La necesidad de cach칠s a veces puede ser confusa, ya que almacenan datos, como RAM o SSD.  Pero los cach칠s difieren en latencia y velocidad de acceso.  Aunque la memoria RAM es extremadamente r치pida, es mucho m치s lenta de lo que necesita la CPU.  Se pueden requerir cientos de ciclos para responder con la transferencia de datos de RAM, y el procesador no tendr치 nada que hacer en este momento.  Y si no hay datos en la RAM, puede tomar decenas de miles de ciclos para acceder a ellos desde el SSD.  Sin cach칠s, los procesadores se detendr칤an constantemente. <br><br>  Los procesadores suelen tener tres niveles de cach칠 que conforman la denominada <em>jerarqu칤a de memoria</em> .  El cach칠 L1 es el m치s peque침o y m치s r치pido, L2 est치 en el medio y L3 es el m치s grande y m치s lento de todos los cach칠s.  Por encima de los cach칠s en la jerarqu칤a hay peque침os registros que almacenan el 칰nico valor de datos durante los c치lculos.  En orden de magnitud, estos registros son los dispositivos de almacenamiento m치s r치pidos del sistema.  Cuando el compilador convierte un programa de alto nivel en lenguaje ensamblador, determina la mejor manera de usar estos registros. <br><br>  Cuando la CPU solicita datos de la memoria, primero verifica si estos datos ya est치n almacenados en el cach칠 L1.  Si es as칤, puede acceder a ellos en solo un par de ciclos.  Si no est치n all칤, el procesador verifica L2 y luego el cach칠 L3.  Los cach칠s se implementan de tal manera que, en general, son transparentes para el n칰cleo.  El n칰cleo simplemente solicita datos en la direcci칩n de memoria especificada, y el nivel en la jerarqu칤a en el que existe los responde.  Al pasar a niveles posteriores en la jerarqu칤a de memoria, el tama침o y los retrasos generalmente aumentan en 칩rdenes de magnitud.  Al final, si la CPU no encuentra datos en ninguna de las memorias cach칠, accede a la memoria principal (RAM). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/bfa/d08/36abfad0814a507d82b857f0de29b96e.png"></div><br>  En un procesador normal, cada n칰cleo tiene dos cach칠s L1: uno para datos y otro para instrucciones.  Los cach칠s L1 generalmente tienen una capacidad total de aproximadamente 100 kilobytes y el tama침o var칤a mucho seg칰n el chip y la generaci칩n del procesador.  Adem치s, generalmente cada n칰cleo tiene su propio cach칠 L2, aunque en algunas arquitecturas puede ser com칰n a dos n칰cleos.  Los cach칠s L2 son t칤picamente de varios cientos de kilobytes de tama침o.  Finalmente, hay un 칰nico cach칠 L3 com칰n a todos los n칰cleos, con un tama침o del orden de decenas de megabytes. <br><br>  Cuando el procesador ejecuta el c칩digo, se almacenan en cach칠 las instrucciones y los valores de datos m치s utilizados.  Esto acelera significativamente la ejecuci칩n, ya que el procesador no necesita ir constantemente a la memoria principal para obtener los datos necesarios.  En la segunda y tercera parte de la serie, hablaremos m치s sobre c칩mo se implementan estos sistemas de memoria. <br><br>  Adem치s de los cach칠s, uno de los bloques de construcci칩n m치s importantes de un procesador moderno es un <em>predictor de transici칩n</em> preciso.  Las instrucciones de transici칩n (ramificaci칩n) son similares a las construcciones if para el procesador.  Un conjunto de instrucciones se ejecuta si la condici칩n es verdadera y la otra si es falsa.  Por ejemplo, necesitamos comparar dos n칰meros, y si son iguales, realice una funci칩n, y si no son iguales, realice otra.  Estas instrucciones de bifurcaci칩n son extremadamente comunes y pueden representar aproximadamente el 20% de todas las instrucciones en un programa. <br><br>  A primera vista, parece que estas instrucciones de ramificaci칩n no deber칤an causar problemas, pero su ejecuci칩n adecuada puede ser muy dif칤cil para el procesador.  En cualquier momento, el procesador puede estar ejecutando simult치neamente diez o veinte instrucciones, por lo que es muy importante saber <em>qu칠</em> instrucciones ejecutar.  Puede tomar 5 ciclos para determinar que la instrucci칩n actual es una transici칩n, y otros 10 ciclos para determinar si la condici칩n es verdadera.  En este momento, el procesador ya puede comenzar a ejecutar docenas de instrucciones adicionales, sin siquiera saber si estas instrucciones son realmente adecuadas para la ejecuci칩n. <br><br>  Para solucionar este problema, todos los procesadores modernos de alto rendimiento utilizan una t칠cnica llamada especulaci칩n.  Esto significa que el procesador realiza un seguimiento de las instrucciones de la rama y se pregunta si la rama condicional se ejecutar치 o no.  Si la predicci칩n es correcta, el procesador ya ha comenzado a ejecutar las siguientes instrucciones, y esto proporciona un aumento en el rendimiento.  Si la predicci칩n es incorrecta, el procesador detiene la ejecuci칩n, elimina todas las instrucciones incorrectas que comenz칩 a ejecutar y comienza de nuevo desde el punto correcto. <br><br>  Tales predictores de rama son algunos de los tipos m치s simples de aprendizaje autom치tico porque el predictor estudia el comportamiento de las ramas durante la ejecuci칩n.  Si predice incorrectamente con demasiada frecuencia, comienza a aprender el comportamiento correcto.  D칠cadas de investigaci칩n en t칠cnicas de predicci칩n de transici칩n han dado como resultado una precisi칩n de predicci칩n de m치s del 90% en los procesadores modernos. <br><br>  Aunque la anticipaci칩n proporciona un gran aumento en el rendimiento, ya que el procesador puede ejecutar instrucciones que ya est치n listas, en lugar de esperar en la cola para que se complete la ejecuci칩n, tambi칠n crea vulnerabilidades de seguridad.  El famoso ataque Spectre explota errores en la predicci칩n y anticipaci칩n de las transiciones.  El atacante usa un c칩digo especialmente seleccionado para forzar al procesador a ejecutar el c칩digo de manera proactiva, lo que resulta en una p칠rdida de valores de la memoria.  Para evitar la fuga de datos, fue necesario rehacer el dise침o de ciertos aspectos de anticipaci칩n, lo que condujo a una ligera ca칤da en el rendimiento. <br><br>  En las 칰ltimas d칠cadas, la arquitectura utilizada en los procesadores modernos ha recorrido un largo camino.  La innovaci칩n y el desarrollo de una estructura bien pensada han llevado a una mayor productividad y un uso m치s 칩ptimo del hardware.  Sin embargo, los desarrolladores de los procesadores centrales guardan cuidadosamente los secretos de sus tecnolog칤as, por lo que no podemos descubrir exactamente qu칠 sucede dentro de ellos.  Sin embargo, los principios fundamentales de los procesadores est치n estandarizados para todas las arquitecturas y modelos.  Intel puede agregar sus ingredientes secretos para aumentar la proporci칩n de aciertos de cach칠, y AMD puede agregar un predictor de transici칩n mejorado, pero los procesadores de ambas compa침칤as realizan la misma tarea. <br><br>  En este primer vistazo y revisi칩n, cubrimos los conceptos b치sicos de c칩mo funcionan los procesadores.  En la siguiente parte, le diremos c칩mo desarrollar los componentes que componen los procesadores, hablaremos sobre elementos l칩gicos, frecuencias de reloj, administraci칩n de energ칤a, circuitos y m치s. <br><br><h5>  Lectura recomendada </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La historia del microprocesador y la computadora personal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tecnolog칤a de pantalla comparada: TN vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VA vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IPS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Batalla de CPU de 4 GHz: AMD 2nd-Gen Ryzen vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intel Core de 8.a generaci칩n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">쯈u칠 es la regulaci칩n t칠rmica y c칩mo prevenirla?</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456922/">https://habr.com/ru/post/456922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456908/index.html">C칩mo Telegram te fusiona con Rostelecom</a></li>
<li><a href="../456910/index.html">Internet project security.txt - conociendo otro archivo .well conocido</a></li>
<li><a href="../456912/index.html">C칩mo hacer sitios en 2019</a></li>
<li><a href="../456916/index.html">Compilaci칩n cruzada en docker. Por que no</a></li>
<li><a href="../456920/index.html">Sony Xperia 1 en Rusia - bonificaciones de precio y pre-pedido</a></li>
<li><a href="../456926/index.html">쮺칩mo hacemos Sportmaster?</a></li>
<li><a href="../456928/index.html">JMeter - Cuchillo suizo de prueba (Parte 1)</a></li>
<li><a href="../456930/index.html">Trayendo IoT a las masas: resultados del primer hackathon IoT de GeekBrains y Rostelecom</a></li>
<li><a href="../456932/index.html">OpenGL ultramoderno. Parte 1</a></li>
<li><a href="../456938/index.html">Lanzamiento de una aplicaci칩n de taxis en Tokio: 쮺칩mo lo hace Sony con S. Ride?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>