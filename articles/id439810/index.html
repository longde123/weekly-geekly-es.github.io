<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍈 📗 👖 Mengenal kerangka kerja perangkat Moleculer 👘 🚨 👩🏼‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai% habrauser%! 

 Hari ini saya ingin memberi tahu Anda tentang satu kerangka kerja perangkat lunak molekuler yang bagus menurut saya. 



 Awalnya,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengenal kerangka kerja perangkat Moleculer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439810/"> Hai% habrauser%! <br><br>  Hari ini saya ingin memberi tahu Anda tentang satu kerangka kerja perangkat lunak molekuler yang bagus menurut saya. <br><br><img src="https://habrastorage.org/webt/n1/8a/ew/n18aewfs_oj6ndbonuakkyjfwte.png"><br><br>  Awalnya, kerangka kerja ini ditulis dalam Node.js, tetapi kemudian muncul pada port dalam bahasa lain seperti Java, Go, Python, dan .NET dan, kemungkinan besar, implementasi lain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan muncul</a> dalam waktu dekat.  Kami telah menggunakannya dalam produksi dalam beberapa produk selama sekitar satu tahun dan sulit untuk menggambarkan dengan kata-kata betapa diberkatinya dia bagi kami setelah menggunakan Seneca dan sepeda kami.  Kami mendapatkan semua yang kami butuhkan: mengumpulkan metrik, caching, menyeimbangkan, toleransi kesalahan, pilih transport, validasi parameter, logging, deklarasi metode ringkas, beberapa cara interaksi antar-layanan, mixin, dan banyak lagi.  Dan sekarang dalam rangka. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Kerangka kerja ini, pada kenyataannya, terdiri dari tiga komponen (pada kenyataannya, tidak, tetapi Anda akan belajar lebih banyak tentang ini di bawah). <br><br><h4>  Transporter </h4><br>  Bertanggung jawab untuk menemukan layanan dan komunikasi di antara mereka.  Ini adalah antarmuka yang dapat Anda implementasikan sendiri jika diinginkan, atau Anda dapat menggunakan implementasi siap pakai yang merupakan bagian dari kerangka itu sendiri.  7 transport tersedia dari kotak: TCP, Redis, AMQP, MQTT, NATS, Streaming NATS, Kafka.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat melihat lebih banyak.  Kami menggunakan transportasi Redis, tetapi kami berencana untuk beralih ke TCP dengan keluarnya dari keadaan eksperimental. <br><br>  Dalam praktiknya, saat menulis kode, kami tidak berinteraksi dengan komponen ini.  Anda hanya perlu tahu siapa dia.  Transport yang digunakan ditentukan dalam konfigurasi.  Jadi, untuk beralih dari satu transportasi ke yang lain, cukup ubah konfigurasi.  Itu saja.  Sesuatu seperti ini: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ./moleculer.config.js module.exports = { transporter: 'redis://:pa$$w0rd@127.0.0.1:6379', // ...   }</span></span></code> </pre> <br>  Data, secara default, datang dalam format JSON.  Tetapi Anda dapat menggunakan apa saja: Avro, MsgPack, Notepack, ProtoBuf, Thrift, dll. <br><br><h4>  Layanan </h4><br>  Kelas tempat kami mewarisi dari saat menulis layanan microser kami. <br><br>  Berikut adalah layanan paling sederhana tanpa metode, yang, bagaimanapun, akan terdeteksi oleh layanan lain: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ./services/telemetry/telemetry.service.js const { Service } = require('moleculer'); module.exports = class TelemetryService extends Service { constructor(broker) { super(broker); this.parseServiceSchema({ name: 'telemetry', }); } };</span></span></code> </pre><br><br><h4>  Pialang layanan </h4><br>  Inti dari kerangka kerja. <br><br><img src="https://habrastorage.org/webt/t7/wp/qo/t7wpqorpz4zhmczcvir_fs9cems.png"><br><br>  Membesar-besarkan, kita dapat mengatakan bahwa ini adalah lapisan antara transportasi dan layanan.  Ketika suatu layanan ingin berinteraksi dengan layanan lain, layanan itu melakukannya melalui broker (contoh akan diberikan di bawah).  Pialang terlibat dalam load balancing (mendukung beberapa strategi, termasuk yang khusus, secara default - round-robin), dengan mempertimbangkan layanan langsung, metode yang tersedia dalam layanan ini, dll.  Untuk ini, ServiceBroker menggunakan komponen lain di bawah tenda - Registry, tapi saya tidak akan memikirkannya, kita tidak akan membutuhkannya untuk berkenalan. <br><br>  Memiliki broker memberi kita hal yang sangat nyaman.  Sekarang saya akan mencoba mengklarifikasi, tetapi harus minggir sedikit.  Dalam konteks kerangka kerja ada yang namanya simpul.  Dalam istilah sederhana, sebuah simpul adalah proses dalam sistem operasi (yaitu, apa yang terjadi ketika kita memasukkan "node index.js" di konsol, misalnya).  Setiap node adalah ServiceBroker dengan satu set atau lebih layanan microser.  Ya, Anda dengar benar.  Kita dapat membangun tumpukan layanan sesuai keinginan kita.  Kenapa ini nyaman?  Untuk pengembangan, kami memulai satu simpul di mana semua layanan Microsoft diluncurkan sekaligus (masing-masing 1), hanya satu proses dalam sistem dengan kemampuan untuk menghubungkan dengan mudah hotreload, misalnya.  Dalam produksi - simpul terpisah untuk setiap instance layanan.  Baik, atau campuran, ketika bagian dari layanan di satu node, bagian lain, dan sebagainya (meskipun saya tidak tahu mengapa melakukan ini, hanya untuk memahami bahwa Anda juga bisa melakukan ini). <br><br><div class="spoiler">  <b class="spoiler_title">Inilah yang terlihat seperti index.js kami</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { resolve } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ServiceBroker } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'moleculer'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./moleculer.config.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { SERVICES, NODE_ENV, } = process.env; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> broker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServiceBroker(config); broker.loadServices( resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'services'</span></span>), SERVICES ? <span class="hljs-string"><span class="hljs-string">`*/@(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVICES.split(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">','</span></span></span></span><span class="hljs-string"><span class="hljs-subst">).map(i =&gt; i.trim()).join(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'|'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">).service.js`</span></span> : <span class="hljs-string"><span class="hljs-string">'*/*.service.js'</span></span>, ); broker.start().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NODE_ENV === <span class="hljs-string"><span class="hljs-string">'development'</span></span>) { broker.repl(); } });</code> </pre><br></div></div><br>  Dengan tidak adanya variabel lingkungan, semua layanan dari direktori dimuat, jika tidak oleh mask.  Omong-omong, broker.repl () adalah fitur lain yang mudah digunakan dari framework.  Ketika memulai dalam mode pengembangan, kami di sana, di konsol, memiliki antarmuka untuk memanggil metode (apa yang akan Anda lakukan, misalnya, melalui tukang pos di layanan mikro Anda yang berkomunikasi melalui http), hanya di sini jauh lebih nyaman: antarmuka berada di konsol yang sama di mana mereka mulai npm. <br><br><h2>  Interaksi antar layanan </h2><br>  Itu dilakukan dalam tiga cara: <br><br><h4>  panggilan </h4><br>  Paling umum digunakan.  Membuat permintaan, menerima tanggapan (atau kesalahan). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   "report",     "csv". async getCsvReport({ jobId }) { const rows = []; // ... return this.broker.call('csv.stringify', { rows }); }</span></span></code> </pre><br>  Seperti disebutkan di atas, panggilan secara otomatis seimbang.  Kami hanya meningkatkan jumlah instance layanan yang diperlukan, dan kerangka itu sendiri akan melakukan penyeimbangan. <br><br><img src="https://habrastorage.org/webt/jl/nj/r4/jlnjr4zxz943pfzpc9epoxpbgw8.gif"><br><br><h4>  memancarkan </h4><br>  Digunakan ketika kami hanya ingin memberi tahu layanan lain tentang suatu acara, tetapi kami tidak membutuhkan hasilnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   "user"    . async registerUser({ email, password }) { // ... this.broker.emit('user_registered', { email }); return true; }</span></span></code> </pre><br>  Layanan lain dapat berlangganan acara ini, dan merespons sesuai.  Secara opsional, argumen ketiga, Anda dapat secara eksplisit mengatur layanan yang tersedia untuk menerima acara ini. <br><br>  Poin penting adalah bahwa acara tersebut hanya akan menerima satu contoh dari setiap jenis layanan, yaitu  jika kita memiliki 10 layanan "surat" dan 5 "berlangganan" yang berlangganan acara ini, maka pada kenyataannya hanya 2 salinan yang akan menerimanya - satu "surat" dan satu "berlangganan".  Secara skematis terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/yf/fg/oj/yffgoj5ce8pzhcfdl_rdian6hpg.gif"><br><br><h4>  disiarkan </h4><br>  Sama seperti memancarkan, tetapi tanpa batasan.  Semua 10 surat dan 5 layanan berlangganan akan menangkap acara ini. <br><br><h2>  Validasi parameter </h2><br>  Secara default, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">validator tercepat</a> digunakan untuk memvalidasi parameter, tampaknya sangat cepat.  Tetapi tidak ada yang mencegah menggunakan yang lain, misalnya, joi yang sama, jika Anda memerlukan validasi yang lebih maju. <br><br>  Ketika kami menulis layanan, kami mewarisi dari Layanan kelas dasar, mendeklarasikan metode dengan logika bisnis di dalamnya, tetapi metode ini adalah "pribadi", mereka tidak dapat dipanggil dari luar (dari layanan lain) sampai kami secara eksplisit ingin, mendeklarasikannya dalam bagian tindakan khusus selama inisialisasi layanan (metode layanan publik dalam konteks kerangka kerja disebut tindakan). <br><br><div class="spoiler">  <b class="spoiler_title">Contoh deklarasi metode dengan validasi</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(broker) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(broker); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseServiceSchema({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'job'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actions</span></span>: { <span class="hljs-attr"><span class="hljs-attr">update</span></span>: { <span class="hljs-attr"><span class="hljs-attr">params</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">convert</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">empty</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">optional</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'object'</span></span>, <span class="hljs-attr"><span class="hljs-attr">optional</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.update(ctx.params); }, }, }, }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> update({ id, name, data }) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br></div></div><br><h2>  Mixin </h2><br>  Digunakan, misalnya, untuk menginisialisasi koneksi basis data.  Hindari duplikasi kode dari layanan ke layanan. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh mixin untuk menginisialisasi koneksi ke Redis</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Redis = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ioredis'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ key = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'redis'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, options } = {}</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">settings</span></span>: { [key]: options, }, created() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[key] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Redis(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.settings[key]); }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> started() { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[key].connect(); }, stopped() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[key].disconnect(); }, });</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Menggunakan mixin dalam layanan</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Service, Errors } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'moleculer'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redis = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../mixins/redis'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../mixins/server'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./router'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { REDIS_HOST, REDIS_PORT, REDIS_PASSWORD, } = process.env; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redisOpts = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: REDIS_HOST, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: REDIS_PORT, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: REDIS_PASSWORD, <span class="hljs-attr"><span class="hljs-attr">lazyConnect</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(broker) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(broker); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseServiceSchema({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'auth'</span></span>, <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [redis({ <span class="hljs-attr"><span class="hljs-attr">options</span></span>: redisOpts }), server({ router })], }); } }</code> </pre> <br></div></div><br><h2>  Caching </h2><br>  Metode panggilan (tindakan) dapat di-cache dalam beberapa cara: LRU, Memory, Redis.  Secara opsional, Anda dapat menentukan dengan mana panggilan kunci akan di-cache (secara default, objek hash digunakan sebagai kunci caching) dan dengan TTL yang mana. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh Pernyataan Metode Cached</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InventoryService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(broker) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(broker); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseServiceSchema({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'inventory'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actions</span></span>: { <span class="hljs-attr"><span class="hljs-attr">getInventory</span></span>: { <span class="hljs-attr"><span class="hljs-attr">params</span></span>: { <span class="hljs-attr"><span class="hljs-attr">steamId</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">pattern</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/^76\d{15}$/</span></span> }, <span class="hljs-attr"><span class="hljs-attr">appId</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">integer</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">contextId</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">integer</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, }, <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [<span class="hljs-string"><span class="hljs-string">'steamId'</span></span>, <span class="hljs-string"><span class="hljs-string">'appId'</span></span>, <span class="hljs-string"><span class="hljs-string">'contextId'</span></span>], <span class="hljs-attr"><span class="hljs-attr">ttl</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(ctx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }, }, }, }); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br></div></div><br>  Metode caching diatur melalui konfigurasi ServiceBroker. <br><br><h2>  Penebangan </h2><br>  Di sini, bagaimanapun, semuanya juga cukup sederhana.  Ada built-in logger yang cukup bagus yang menulis ke konsol, dimungkinkan untuk menentukan pemformatan kustom.  Tidak ada yang mencegah untuk mencuri logger populer lainnya, baik itu winston atau bunyan.  Manual terperinci ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Secara pribadi, kami menggunakan built-in logger, formatter khusus untuk beberapa baris kode yang spam ke konsol JSON hanya dipotong di prod, setelah itu mereka masuk ke graylog menggunakan driver log buruh pelabuhan. <br><br><h2>  Metrik </h2><br>  Jika diinginkan, Anda dapat mengumpulkan metrik untuk setiap metode dan melacak semuanya di beberapa zipkin.  Berikut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah</a> daftar lengkap eksportir yang tersedia.  Saat ini ada lima di antaranya: Zipkin, Jaeger, Prometheus, Elastic, Console.  Ini dikonfigurasi, seperti caching, ketika mendeklarasikan metode (aksi). <br><br>  Contoh visualisasi untuk bundel elasticsearch + kibana menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elastic-apm-node</a> dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ini</a> di Github. <br><br>  Cara termudah, tentu saja, adalah dengan menggunakan opsi konsol.  Ini terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/eu/dq/20/eudq20mgo7wtbqmstlp_aiidicy.png"><br><br><h2>  Toleransi kesalahan </h2><br>  Kerangka kerja ini memiliki pemutus arus bawaan, yang dikendalikan melalui pengaturan ServiceBroker.  Jika ada layanan gagal dan jumlah kegagalan ini melebihi batas tertentu, maka itu akan ditandai sebagai tidak sehat, permintaan untuk itu akan sangat terbatas sampai berhenti membuat kesalahan. <br><br>  Sebagai bonus, ada juga fallback yang dapat disesuaikan secara individual untuk setiap metode (tindakan), jika kami berasumsi bahwa metode tersebut mungkin gagal dan, misalnya, mengirim data cache atau sebuah rintisan. <br><br><h2>  Kesimpulan </h2><br>  Pengenalan kerangka kerja ini bagi saya menjadi menghirup udara segar, yang menyelamatkan sejumlah besar bunts (kecuali kenyataan bahwa arsitektur microservice adalah salah satu bunt besar) dan bersepeda, membuat penulisan microservice berikutnya sederhana dan transparan.  Tidak ada yang berlebihan di dalamnya, itu sederhana dan sangat fleksibel, dan Anda dapat menulis layanan pertama dalam satu atau dua jam setelah membaca dokumentasi.  Saya akan senang jika materi ini bermanfaat bagi Anda dan dalam proyek Anda berikutnya, Anda akan ingin mencoba keajaiban ini, seperti yang kami lakukan (dan belum menyesalinya).  Baik untuk semua! <br><br>  Juga, jika Anda tertarik dengan kerangka kerja ini, maka bergabunglah dengan obrolan di Telegram - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@moleculerchat</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439810/">https://habr.com/ru/post/id439810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439794/index.html">Nyeri punggung - pemahaman dari perspektif kedokteran modern</a></li>
<li><a href="../id439796/index.html">Spring Boot 2: apa yang tidak mereka tulis dalam catatan rilis</a></li>
<li><a href="../id439804/index.html">Zen dari Unit Testing</a></li>
<li><a href="../id439806/index.html">Nama Domain SSL Valid untuk Wadah Docker Lokal</a></li>
<li><a href="../id439808/index.html">Teleskop terbesar. Dari notebook dan mata ke kamera 340 megapiksel dan pusat data. Bagian 1</a></li>
<li><a href="../id439812/index.html">Pendekatan kaggle untuk CV dalam produk: Anda tidak dapat menerapkan untuk memotong</a></li>
<li><a href="../id439818/index.html">Fitur pendekatan desain di sektor manufaktur nyata</a></li>
<li><a href="../id439822/index.html">Membuat tampilan alternatif untuk Ensoniq EPS16 + dan ASR10 synthesizer / sampler</a></li>
<li><a href="../id439824/index.html">Kapan kerangka kerja JavaScript akan hilang?</a></li>
<li><a href="../id439826/index.html">Menonaktifkan analog. Apa yang akan terjadi pada televisi?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>