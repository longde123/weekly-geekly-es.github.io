<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📠 🐎 👩‍👩‍👧 Vektormittelungsverfahren zum Messen der Windrichtung 🌬️ 👨🏼‍🎨 🙎🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einem Jahr habe ich eine Wetterstation mit einem Messgerät für Windrichtung und Geschwindigkeit beschrieben. Basierend auf den Erfahrungen aus zwe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vektormittelungsverfahren zum Messen der Windrichtung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423243/"> Vor einem Jahr habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> Wetterstation mit einem Messgerät für Windrichtung und Geschwindigkeit beschrieben.  Basierend auf den Erfahrungen aus zwei Betriebszeiten wurden einige Änderungen und Verbesserungen vorgenommen, die dort teilweise in Ergänzungen zum Haupttext beschrieben werden. <br><br>  Eine dieser Änderungen betrifft die Berechnung der durchschnittlichen Windrichtung.  Zu meinem Erstaunen fand ich zu diesem Thema im Web nichts Sinnvolles, nur in einem der Foren haben die Leute selbst fast an die Methode der Vektormittelung gedacht (aber nur fast, sie haben das Problem nicht allgemein gelöst).  Daher fand ich es nützlich, dieses Thema in einer separaten Publikation zu veröffentlichen - plötzlich wird sich jemand anderes als nützlich erweisen.  Die Methode kann verwendet werden, um beliebige Vektorgrößen zu mitteln, nicht nur Wind oder Strömung. <br><a name="habracut"></a><br>  Beachten Sie, dass die kanonische Methode zur Durchführung meteorologischer Windmessungen wie folgt lautet: Durchschnitt des Vektors (d. H. Sowohl Geschwindigkeit als auch Richtung) über 10 Minuten (in Russland und den meisten Ländern der Welt wird dies in den USA und einigen anderen Ländern anders akzeptiert).  In diesem Fall werden Messungen in einer Höhe von 10 m von der Erdoberfläche durchgeführt.  All dies unter Kniebedingungen zu gewährleisten ist ziemlich schwierig: Man kann im offenen Raum keine Höhe von 10 m erreichen (baue keinen speziellen Turm, weit entfernt von Häusern und Bäumen, die den Windfluss verzerren), und die Temperatur mit Feuchtigkeit sollte im Gegenteil im Schatten und in der Nähe gemessen werden von der Oberfläche.  Der tragbare Sensor wird von einem kompakten Gerät in ein komplettes Messsystem umgewandelt (siehe Foto des Territoriums einer Wetterstation in der Stadt Kirov). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/704/b2b/b03704b2bd492c4455aae265a659d489.jpg" alt="Wetterstation in Kirov"><br><br>  Und das Ergebnis - durchschnittlich 10 Minuten - wird wenig informativ sein.  In der Nähe der Oberfläche ist der Wind viel böiger als in der Höhe, in 10 Minuten kann er Geschwindigkeit und Richtung zwanzigmal ändern, und Informationen über diese Böen sind für den Durchschnittsmenschen viel informativer als der Durchschnittswert.  Ich möchte Sie daran erinnern, dass der Geschwindigkeitssensor hier den Maximalwert von vier Messungen pro 8-Sekunden-Zyklus anzeigt, und dies stellte sich als die richtige Wahl heraus (tatsächlich haben wir einen Welligkeitssensor anstelle des Durchschnittsgeschwindigkeitssensors). <br><br>  Die Wetterfahne erwies sich jedoch als launischer als der Geschwindigkeitssensor.  Nach dem anfänglichen Algorithmus meiner Wetterstation (der auf der Grundlage der maximal möglichen Energieeinsparung ausgewählt wurde) wurde die Richtung einmal pro Zyklus gemessen, dh sogar Pulsationen funktionierten nicht: Es gab Zufallsstichproben aus dem kontinuierlichen Prozess des Hin- und Herhängens der Wetterfahne mit einer Frequenz, die viel größer war als alle 8 und mehr als 16 Sekunden. <br><br>  Daher wurde beschlossen, die Richtung des Geschwindigkeitsvektors pro Zyklus zu mitteln, alle zwei Sekunden zu messen und den Durchschnitt zu berechnen.  Und die Sache ist nicht so, dass es mit einem halben Tritt gelöst werden kann - die Richtungswerte bilden kein gleichmäßiges Array von Zahlen, die direkt addiert und geteilt werden können (ein Wort ist ein Vektor, kein Bullshit-Skalar).  Normalerweise wird ein Beispiel mit Werten von 1 Grad und 359 Grad angegeben: Es ist leicht herauszufinden, dass es im Durchschnitt genau 360 (oder 0, kein Unterschied) ist, aber gewöhnliche Arithmetik gibt die Zahl 180 Grad aus. <br><br>  Sie müssen nichts erfinden - alles wurde bereits vor Ihnen erfunden.  Das Problem wird durch die Methode der Vektormittelung gelöst, die denjenigen bekannt ist, die sich mit Messungen von Winden oder Strömungen befassen.  Die Methode ist im Wesentlichen sehr einfach: Da wir die Winkel nicht direkt mitteln können, mitteln wir die Projektionen des Vektors auf der Koordinatenachse, die per Definition ein Skalarwert ist, dh ohne Frage einer gewöhnlichen Arithmetik unterzogen werden kann. <br><br>  Die Projektionen des aktuellen Windvektors W '(der Apostroph spielt die Rolle eines hochgestellten Zeichens) auf der X- und Y-Achse sind wx = Wa · cos (α) und wy = Wa · sin (α), wobei Wa der Modul des Vektors (Geschwindigkeitswert) und α ist - der Wert des Winkels zwischen dem Vektor und der Nullkoordinatenachse.  Wenn wir diese Werte der Projektionen mitteln und dann die Mittelwerte wieder in einen Vektor umwandeln, erhalten wir den wahren Wert der Durchschnittsgeschwindigkeit und -richtung des Windes. <br><br><div class="spoiler">  <b class="spoiler_title">Hinweis für besonders ätzend</b> <div class="spoiler_text">  Für eine vollständig korrekte Mittelung auf diese Weise ist es erforderlich, dass der Wert von Wa (Geschwindigkeitswert) streng gleichzeitig mit dem Winkelwert gemessen wird.  In der Praxis sollte dies nur überwacht werden, wenn die Perioden signifikanter Schwankungen der Durchflussamplitude kleiner oder vergleichbar mit dem Zeitpunkt der Messungen sind.  Für den Wind (und für fast alle Fälle des natürlichen Wasserflusses) ist eine Überwachung normalerweise nicht erforderlich, da die Messzeit für uns maximal einen Sekundenbruchteil beträgt und signifikante Windpulsationen natürlich länger anhalten.  Wir können die hochfrequenten Inhomogenitäten des Flusses vernachlässigen, weil sie nichts beeinflussen: Die Trägheit realer physischer Körper (einschließlich Sensoren) ist viel größer als diese Inhomogenitäten, und wir werden sie einfach nicht spüren - ein Stück Papier wird zittern, aber nichts weiter.  In extremen Fällen treten sie als kleines zufälliges Rauschen auf, das die Qualität der Messungen nicht wesentlich beeinflusst. <br></div></div><br>  Diese wunderbare Methode (nennen wir sie vollständige Vektormittelung) hat aus praktischer Sicht einen entscheidenden Nachteil: Wenn kein Messobjekt vorhanden ist (dh wenn es völlig ruhig ist, was durchaus üblich ist), ergibt sich ein mathematisch falsches Ergebnis: Da die Windgeschwindigkeit dann Null ist und beide Projektionen sind gleich Null, was nicht sein kann (da sin und cos komplementäre Funktionen sind).  Genauer gesagt mag es sein, aber es ist grundsätzlich unmöglich, Informationen aus einer solchen Situation zu extrahieren.  Was möchten Sie auf dem Display anzeigen?  Um ehrlich zu sein, weiß ich immer noch nicht, wie ich diese Situation richtig umgehen kann (in den Durchflussmessern, die ich einmal entworfen habe, waren die Mittelungszyklen Stunden, und es wurde angenommen, dass zumindest etwas Rühren auftreten würde). <br><br>  In unserem Fall ist die Aufgabe glücklicherweise einfacher - wir müssen die Geschwindigkeit nicht mitteln und können mit einzelnen Projektionen des Vektors arbeiten, ohne die Größe seines Moduls zu berücksichtigen.  Mit anderen Worten, man kann mit reinen Sinus- und Cosinuswerten arbeiten, die niemals beide gleichzeitig Null nehmen: Selbst wenn kein Wind weht, zeigt eine in Immobilien gefrorene Wetterfahne eine Richtung.  Wir nennen eine solche Methode eine vereinfachte Vektormittelung einer Richtung (vielleicht hat sie einen offiziellen Namen, aber mir ist das nicht bekannt). <br><br>  Jetzt gab es nur noch eine Schwierigkeit: Die berechneten durchschnittlichen Projektionswerte wieder in den Winkelwert umwandeln.  Hierzu wird normalerweise die Funktion α = Arctan (sin (α) / cos (α)) verwendet. Wenn wir jedoch durch die inversen trigonometrischen Funktionen berechnen, ist es einfacher, einfach Arcos (cos (α)) (oder Arcsin (sin (α)) zu nehmen. ohnehin) und um dieses Ergebnis zu ergänzen, um einen vollen Kreis (d. h. von 0 bis 359 Grad) zu erhalten, der die Vorzeichen der Projektionen analysiert, müssen Sie auf jeden Fall noch: Alle Umkehrfunktionen geben das Ergebnis innerhalb eines Halbkreises (von 0 bis 180 oder von) -90 bis +90).  (Siehe UPD dazu am Ende des Artikels.) <br><br>  Wir formalisieren all das in einen realen Algorithmus (unter Bezugnahme auf Arduino).  Zunächst lesen wir die Richtungsangaben nicht bei jedem Zyklus, sondern bei jeder Messung (nach dem Wert der Frequenz des Windmessers).  Wir werden das Ergebnis in Gray-Code (in unserem Land wurde es als wind_Gray vom Typ Byte bezeichnet, siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Veröffentlichung</a> ) in einen regulären Binärcode konvertieren und es wie die Frequenz des Anemometers in ein globales Array einfügen, das wir als wDirAvr [4] deklarieren werden. Dabei ist 4 die Anzahl der Messungen im Zyklus.  Wir werden die Konvertierung des vierstelligen Gray-Codes in Binärcode nicht malen - dies kann nach Ermessen des Programmierers auf verschiedene Arten erfolgen und wird in jeder Referenz beschrieben. <br><br>  Dieser Binärcode nimmt Werte von 0 bis 15 an und wir sind uns einig, dass wir die Winkel nicht als verschobene Geographen / Topographen / Navigatoren zählen, sondern als normale Menschen, die in der Schule Trigonometrie studiert haben - gegen den Uhrzeigersinn.  Das heißt, wenn der Norden dem Nullwert entspricht, sind 90 Grad nicht der Osten wie bei den „verschobenen“, sondern der Westen.  Da wir 16 Richtungsabstufungen haben, müssen wir den Codewert mit 22,5 (360/16) multiplizieren, um die Richtung in gewöhnlichen Bogengraden zu erhalten. <br><br>  Nun der eigentliche Algorithmus der vereinfachten Vektormittelung der Richtung aus 4 Codewerten: <br><br><pre><code class="plaintext hljs">. . . . . float wSin=0; // sin float wCos=0; // cos float wind_Rad; //   for (byte i=0; i&lt;4; i++){ wind_Rad= ((float(wDirAvr[i])*22.5)*M_PI/180); //   wSin=wSin+sin(wind_Rad);//    sin wCos=wCos+cos(wind_Rad);//    cos } // wSin=wSin/4;// sin –    ,   wCos=wCos/4; // cos wind_Rad = acos(wCos); //     arccos if (wSin&lt;0) wind_Rad=2*M_PI-wind_Rad; //   sin int wind_G = round ((wind_Rad*180/M_PI)/22.5); //    0-15 . . . . .</code> </pre> <br>  In der letzten Zeile konvertieren wir den Durchschnitt im Bogenmaß in den Durchschnitt in unserem Code von 0 bis 15. Sie können ihn dann wieder in Grau-Code konvertieren. Dann müssen Sie nicht einmal das Programm im Hauptmodul ändern, um die Richtung anzuzeigen. <br><br>  Hier ist in der Tat der gesamte Algorithmus.  Ich hatte Angst, dass die Berechnung von Cosinus-Arcsines den schwachen (bis zum heutigen 32-Bit-Zeitpunkt) Arduino-Controller verlangsamen wird, aber es ist nichts passiert: Er hat den Code verschluckt, ohne zu blinken ... wahrscheinlich eine LED. <br><br>  <b>UPD</b> : Für den Autor arbeitet der Algorithmus mehrere Monate in dieser Form ohne Fehler.  Die Kommentatoren führten mich jedoch zu einem möglichen, in der Praxis äußerst unwahrscheinlichen Fehler: Wenn die Daten zwei Gruppen von Messungen enthalten, die in der Nähe des Kosinuswerts Null (d. H. Ungefähr 90 und 270 Grad) ungefähr 180 Grad voneinander entfernt sind, erzeugt der Algorithmus einen Fehler Wert.  Um dies zu vermeiden, verwenden Sie anstelle von acos () die Funktion atan2 (wSin, wCos), die unter Berücksichtigung der Sinus- und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cosinuszeichen</a> sofort das richtige Ergebnis liefert (danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aamonster</a> für die Hilfe).  Die Zeile, in der der durchschnittliche wSin-Wert berechnet wird, sollte nicht kommentiert werden, und die für das wSin-Vorzeichen angepasste Zeile wird nicht benötigt.  Stattdessen müssen Sie die Umwandlung in positive Werte des Winkels einfügen (da atan2 Werte von pi bis -pi liefert): <br><pre> <code class="plaintext hljs">if (wind_Rad&lt;0) wind_Rad=2*M_PI+wind_Rad;</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423243/">https://habr.com/ru/post/de423243/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423233/index.html">Künstliche Intelligenz in der realen Welt</a></li>
<li><a href="../de423235/index.html">Von Dribbble zu Android Motion</a></li>
<li><a href="../de423237/index.html">Ein einfacher, aber raffinierter Roboterarm</a></li>
<li><a href="../de423239/index.html">Erstellen Sie Pakete für Kubernetes mit Helm: Diagrammstruktur und Vorlagen</a></li>
<li><a href="../de423241/index.html">Übersicht über Digip A20- und A25-SIP-Telefone</a></li>
<li><a href="../de423247/index.html">Was ist Intelligenz?</a></li>
<li><a href="../de423249/index.html">Rust 1.29 Release</a></li>
<li><a href="../de423251/index.html">Mein Konto von Megafail</a></li>
<li><a href="../de423253/index.html">Inländische CAD-Plattform nanoCAD Plus 10: Ein universeller Komplex für diejenigen, die entwerfen</a></li>
<li><a href="../de423257/index.html">Funktionsargumente als Bitkonstanten in PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>