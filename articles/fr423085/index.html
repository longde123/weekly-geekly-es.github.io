<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌳 🦌 👨🏾‍🏭 Équilibrage précis de la charge 👊🏿 🧘🏻 👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article se concentrera sur l'équilibrage de charge dans les projets Web. Beaucoup croient que la solution à ce problème dans la répartition de la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Équilibrage précis de la charge</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/423085/">  Cet article se concentrera sur l'équilibrage de charge dans les projets Web.  Beaucoup croient que la solution à ce problème dans la répartition de la charge entre les serveurs - le plus précis, le mieux.  Mais nous savons que ce n'est pas entièrement vrai.  <strong>La stabilité du système est beaucoup plus importante d'un point de vue commercial</strong> . <br><br><img src="https://habrastorage.org/webt/6i/vb/-w/6ivb-w0bzdgl_oa-hkep6luitfi.png"><br><br>  Le petit pic minute à 84 RPS de «cinq cents» est cinq mille erreurs que les vrais utilisateurs ont reçues.  C'est beaucoup et c'est très important.  Il faut rechercher les raisons, travailler sur les erreurs et essayer de continuer à éviter de telles situations. <br><br>  <strong>Nikolay Sivko</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">NikolaySivko</a> ) dans son rapport sur RootConf 2018 a parlé des aspects subtils et pas encore très populaires de l'équilibrage de charge: <br><br><ul><li>  quand répéter la demande (nouvelles tentatives); </li><li>  comment sélectionner des valeurs pour les délais d'expiration; </li><li>  comment ne pas tuer les serveurs sous-jacents au moment de l'accident / de la congestion; </li><li>  si des contrôles de santé sont nécessaires; </li><li>  comment gérer les problèmes de scintillement. </li></ul><br>  Sous décodage chat de ce rapport. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2-j2ADWFkkE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>À propos de l'orateur:</strong> Nikolay Sivko co-fondateur de okmeter.io.  Il a travaillé en tant qu'administrateur système et chef d'un groupe d'administrateurs.  Opération supervisée à hh.ru.  Il a fondé le service de surveillance okmeter.io.  Dans le cadre de ce rapport, le suivi de l'expérience en développement est la principale source de cas. <br><br><h2>  De quoi allons-nous parler? <br></h2><br>  Cet article parlera de projets Web.  Voici un exemple de production en direct: le graphique montre les demandes par seconde pour un certain service Web. <br><br><img src="https://habrastorage.org/webt/oy/5c/qt/oy5cqtlz-halhw7y5ayuz6xl9lm.png"><br><br>  Quand je parle d'équilibrage, beaucoup le perçoivent comme "nous devons répartir la charge entre les serveurs - le plus précis, le mieux." <br><br><img src="https://habrastorage.org/webt/pm/g2/sp/pmg2spartsnxrxcyhzi_4-ui64g.png"><br><br>  En fait, ce n'est pas entièrement vrai.  Ce problème concerne un très petit nombre d'entreprises.  Le plus souvent, les entreprises s'inquiètent des erreurs et de la stabilité du système. <br><br><img src="https://habrastorage.org/webt/6i/vb/-w/6ivb-w0bzdgl_oa-hkep6luitfi.png"><br><br>  Le petit pic sur le graphique est «cinq cents», que le serveur a renvoyé en une minute, puis arrêté.  Du point de vue d'une entreprise, comme une boutique en ligne, ce petit pic à 84 RPS de «cinq cents» représente 5040 erreurs pour les utilisateurs réels.  Certains n'ont pas trouvé quelque chose dans votre catalogue, d'autres n'ont pas pu mettre la marchandise dans le panier.  Et c'est très important.  Bien que ce pic ne semble pas très grand sur le graphique, <strong>il l'est beaucoup chez les vrais utilisateurs</strong> . <br><br>  En règle générale, tout le monde a de tels pics, et les administrateurs n'y répondent pas toujours.  Très souvent, lorsqu'une entreprise demande ce que c'était, ils lui répondent: <br><br><ul><li>  "Ceci est une courte rafale!" </li><li>  "C'est juste une version qui sort." </li><li>  "Le serveur est mort, mais tout est déjà en ordre." </li><li>  "Vasya a changé le réseau de l'un des backends." </li></ul><br>  Souvent, les gens <strong>n'essaient même pas de comprendre les raisons</strong> pour lesquelles cela s'est produit et ne font aucun post-travail pour que cela ne se reproduise plus. <br><br><h2>  Affiner <br></h2><br>  J'ai appelé le rapport "Fine tuning" (Eng. Fine tuning), parce que je pensais que tout le monde ne se mettait pas à cette tâche, mais cela en valait la peine.  Pourquoi n'y arrivent-ils pas? <br><br><ul><li>  <strong>Tout le monde ne parvient pas à cette tâche,</strong> car lorsque tout fonctionne, ce n'est pas visible.  Ceci est très important pour les problèmes.  Le Fakapa n'arrive pas tous les jours, et un si petit problème nécessite des efforts très sérieux pour le résoudre. </li><li>  <strong>Vous devez réfléchir beaucoup.</strong>  Très souvent, l'administrateur - la personne qui ajuste la balance - n'est pas en mesure de résoudre ce problème de manière indépendante.  Ensuite, nous verrons pourquoi. </li><li>  <strong>Il capture les niveaux sous-jacents.</strong>  Cette tâche est très étroitement liée au développement, à l'adoption de décisions qui affectent votre produit et vos utilisateurs. </li></ul><br>  <strong>J'affirme qu'il est temps de faire cette tâche pour plusieurs raisons:</strong> <br><br><ul><li>  Le monde change, devient plus dynamique, il existe de nombreuses versions.  Ils disent que maintenant il est correct de sortir 100 fois par jour, et la sortie est le futur fakap avec une probabilité de 50 à 50 (tout comme la probabilité de rencontrer un dinosaure) </li><li>  Du point de vue de la technologie, tout est également très dynamique.  Kubernetes et d'autres orchestrateurs sont apparus.  Il n'y a pas de bon vieux déploiement, lorsqu'un backend sur une IP est désactivé, une mise à jour est lancée et le service augmente.  Maintenant, dans le processus de déploiement dans k8s, la liste des IP en amont change complètement. </li><li>  Microservices: maintenant tout le monde communique via le réseau, ce qui signifie que vous devez le faire de manière fiable.  L'équilibrage joue un rôle important. </li></ul><br><h2>  Banc d'essai <br></h2><br>  Commençons par des cas simples et évidents.  Pour plus de clarté, je vais utiliser un banc d'essai.  Il s'agit d'une application Golang qui donne http-200, ou vous pouvez la passer en mode "donner http-503". <br><br>  Nous commençons 3 instances: <br><br><ul><li>  127.0.0.1:20001 </li><li>  127.0.0.1:20002 </li><li>  127.0.0.1:20003 </li></ul><br>  Nous servons 100rps via yandex.tank via nginx. <br><br>  Nginx hors de la boîte: <br><br><pre><code class="plaintext hljs">upstream backends { server 127.0.0.1:20001; server 127.0.0.1:20002; server 127.0.0.1:20003; } server { listen 127.0.0.1:30000; location / { proxy_pass http://backends; } }</code> </pre> <br><h3>  Scénario primitif </h3><br>  À un moment donné, activez l'un des backends dans le mode Give 503, et nous obtenons exactement un tiers des erreurs. <br><br><img src="https://habrastorage.org/webt/qp/m1/ro/qpm1rolcydmcpwpvule4pw97b-o.png"><br><br>  Il est clair que rien ne sort de la boîte: nginx ne réessaye pas de la boîte s'il a reçu <strong>une réponse</strong> du serveur. <br><br><pre> <code class="plaintext hljs">Nginx default: proxy_next_upstream error timeout;</code> </pre><br>  En fait, c'est assez logique du côté des développeurs de nginx: nginx n'a pas le droit de décider pour vous ce que vous voulez retravailler et ce qui ne l'est pas. <br><br>  Par conséquent, nous avons besoin de nouvelles tentatives - de nouvelles tentatives, et nous commençons à en parler. <br><br><h2>  Réessais <br></h2><br>  Il faut trouver un compromis entre: <br><br><ul><li>  La demande de l'utilisateur est sainte, se blesse, mais répondez.  Nous voulons répondre à tout prix à l'utilisateur, l'utilisateur est le plus important. </li><li>  Mieux vaut répondre avec une erreur que de surcharger les serveurs. </li><li>  Intégrité des données (pour les demandes non idempotentes), c'est-à-dire qu'il est impossible de répéter certains types de demandes. </li></ul><br>  <strong>La vérité, comme d'habitude, se situe quelque part entre -</strong> nous sommes obligés d'équilibrer entre ces trois points.  Essayons de comprendre quoi et comment. <br><br>  J'ai divisé les tentatives infructueuses en 3 catégories: <br><br>  1. <strong>Erreur de transport</strong> <br>  Pour le transport HTTP, il s'agit de TCP et, en règle générale, nous parlons ici d'erreurs de configuration de connexion et de délais d'expiration de configuration de connexion.  Dans mon rapport, je mentionnerai 3 équilibreurs courants (nous parlerons un peu d'Envoy): <br><br><ul><li>  <strong>nginx</strong> : erreurs + timeout (proxy_connect_timeout); </li><li>  <strong>HAProxy</strong> : connexion timeout; </li><li>  <strong>Envoyé</strong> : échec de connexion + flux refusé. </li></ul><br>  Nginx a la possibilité de dire qu'une tentative ayant échoué est une erreur de connexion et un délai d'expiration de connexion;  HAProxy a un délai de connexion, Envoy a également tout ce qui est standard et normal. <br><br>  2. <strong>Délai de demande:</strong> <br>  Supposons que nous ayons envoyé une requête au serveur, connecté avec succès, mais que la réponse ne nous vienne pas, nous l'avons attendue et nous comprenons qu'il ne sert à rien d'attendre plus longtemps.  C'est ce qu'on appelle le délai d'expiration de la demande: <br><br><ul><li>  <strong>Nginx</strong> a: timeout (prox_send_timeout * + proxy_read_timeout *); </li><li>  <strong>HAProxy a</strong> <strong>OOPS :(</strong> - il n'existe pas en principe. Beaucoup de gens ne savent pas que HAProxy, s'il a réussi à établir une connexion, n'essaiera jamais de renvoyer la demande. </li><li>  <strong>L'envoyé</strong> peut tout faire: délai d'expiration ||  per_try_timeout. </li></ul><br>  3. <strong>Statut HTTP</strong> <br>  Tous les équilibreurs, à l'exception de HAProxy, sont capables de traiter, si néanmoins le backend vous a répondu, mais avec une sorte de code erroné. <br><br><ul><li>  <strong>nginx</strong> : http_ * </li><li>  <strong>HAProxy</strong> : <strong>OOPS :(</strong> </li><li>  <strong>Envoy</strong> : 5xx, erreur de passerelle (502, 503, 504), récupérable-4xx (409) </li></ul><br><h3>  Délais <br></h3><br>  Parlons maintenant en détail des délais d'attente, il me semble qu'il vaut la peine d'y prêter attention.  Il n'y aura plus de fusée scientifique - il s'agit simplement d'informations structurées sur ce qui se passe généralement et sur la manière dont elles s'y rapportent. <br><br><h4>  Délai d'expiration de connexion <br></h4><br>  Le délai de connexion est le temps pour établir une connexion.  Ceci est une caractéristique de votre réseau et de votre serveur spécifique et ne dépend pas de la demande.  Habituellement, la valeur par défaut pour le délai de connexion est définie sur petite.  Dans tous les proxys, la valeur par défaut est suffisamment grande, et c'est faux - ce devrait être des <strong>unités, parfois des dizaines de millisecondes</strong> (si nous parlons d'un réseau à l'intérieur d'un DC). <br><br>  Si vous souhaitez identifier les serveurs problématiques un peu plus rapidement que ces unités-dizaines de millisecondes, vous pouvez ajuster la charge sur le backend en définissant un petit backlog pour recevoir les connexions TCP.  Dans ce cas, vous pouvez, lorsque le backlog de l'application est plein, demander à Linux de le réinitialiser pour déborder le backlog.  Ensuite, vous pourrez filmer le "mauvais" backend surchargé un peu plus tôt que le délai de connexion: <br><br><pre> <code class="plaintext hljs">fail fast: listen backlog + net.ipv4.tcp_abort_on_overflow</code> </pre> <br><h4>  Délai d'expiration de la demande <br></h4><br>  Le délai d'expiration des demandes n'est pas une caractéristique du réseau, mais une <strong>caractéristique d'un groupe de demandes</strong> (gestionnaire).  Il existe différentes demandes - leur gravité est différente, leur logique interne est complètement différente, elles doivent accéder à des référentiels complètement différents. <br><br>  Nginx lui <strong>-</strong> même <strong>n'a pas de délai d'expiration pour la demande entière.</strong>  Il a: <br><br><ul><li>  proxy_send_timeout: temps entre deux opérations d'écriture réussies write (); </li><li>  proxy_read_timeout: temps entre deux lectures réussies (). </li></ul><br>  Autrement dit, si vous avez un backend lentement, un octet de fois, donne quelque chose dans un délai d'attente, alors tout va bien.  En tant que tel, nginx n'a pas request_timeout.  Mais nous parlons en amont.  Dans notre centre de données, ils sont contrôlés par nous, par conséquent, en supposant que le réseau n'a pas de loris lent, alors, en principe, read_timeout peut être utilisé comme request_timeout. <br><br>  Envoy a tout pour lui: timeout ||  per_try_timeout. <br><br><h4>  Sélectionnez le délai d'expiration de la demande <br></h4><br>  Maintenant, la chose la plus importante, à mon avis, est de savoir quel request_timeout mettre.  Nous partons de combien il est permis à l'utilisateur d'attendre - c'est un certain maximum.  Il est clair que l'utilisateur n'attendra pas plus de 10 s, vous devez donc lui répondre plus rapidement. <br><br><ul><li>  Si nous voulons gérer la défaillance d'un seul serveur, le délai d'expiration doit être inférieur au délai maximal autorisé: <strong>request_timeout &lt;max.</strong> </li><li>  Si vous voulez avoir <strong>2 tentatives garanties d'</strong> envoyer une demande à deux backends différents, le délai d'expiration pour une tentative est égal à la moitié de cet intervalle autorisé: <strong>per_try_timeout = 0,5 * max.</strong> </li><li>  Il existe également une option intermédiaire - <strong>2 tentatives optimistes</strong> dans le cas où le premier backend s'est "émoussé", mais le second répondra rapidement: <strong>per_try_timeout = k * max (où k&gt; 0,5).</strong> </li></ul><br>  Il existe différentes approches, mais en général, le <strong>choix d'un délai d'attente est difficile</strong> .  Il y aura toujours des cas limites, par exemple, le même gestionnaire dans 99% des cas est traité en 10 ms, mais il y a 1% des cas quand on attend 500 ms, et c'est normal.  Cela devra être résolu. <br><br>  Avec ce 1%, quelque chose doit être fait, car l'ensemble du groupe de demandes doit, par exemple, se conformer au SLA et tenir en 100 ms.  Très souvent, à ces moments, la demande est traitée: <br><br><ul><li>  La pagination apparaît aux endroits où il est impossible de renvoyer toutes les données dans un délai d'attente. </li><li>  Les administrateurs / rapports sont séparés dans un groupe distinct d'URL afin d'augmenter le délai d'attente pour eux, et oui pour réduire les demandes des utilisateurs. </li><li>  Nous réparons / optimisons les demandes qui ne correspondent pas à notre délai d'expiration. </li></ul><br>  Ici, nous devons prendre une décision, ce qui n'est pas très simple d'un point de vue psychologique, que si nous n'avons pas le temps de répondre à l'utilisateur dans le temps imparti, nous donnerons une erreur (c'est comme dans un ancien dicton chinois: "Si la jument est morte, descendez!") <strong>.</strong> <br><br>  Après cela, le processus de surveillance de votre service du point de vue de l'utilisateur est simplifié: <br><br><ul><li>  S'il y a des erreurs, tout est mauvais, il faut le réparer. </li><li>  S'il n'y a pas d'erreurs, nous nous adaptons au bon temps de réponse, alors tout va bien. </li></ul><br><h3>  Tentatives spéculatives # nifig <br></h3><br>  Nous nous sommes assurés que le choix d'une valeur de timeout est assez difficile.  Comme vous le savez, pour simplifier quelque chose, vous devez compliquer quelque chose :) <br><br>  <strong>Nouvelle spéculation</strong> - une demande répétée à un autre serveur, qui est lancée par une condition, mais la première demande n'est pas interrompue.  Nous prenons la réponse du serveur qui a répondu plus rapidement. <br><br>  Je n'ai pas vu cette fonctionnalité dans les équilibreurs que je connais, mais il y a un excellent exemple avec Cassandra (protection en lecture rapide): <br><br>  spéculative_retry = N ms |  <strong>M <sup>e</sup> centile</strong> <br><br>  De cette façon, vous <strong>n'avez pas à expirer</strong> .  Vous pouvez le laisser à un niveau acceptable et en tout cas avoir une deuxième tentative pour obtenir une réponse à la demande. <br><br>  Cassandra a une opportunité intéressante de définir une dynamique spéculative_retry ou dynamique, puis la deuxième tentative sera effectuée à travers le centile du temps de réponse.  Cassandra accumule des statistiques sur les temps de réponse des demandes précédentes et adapte une valeur de timeout spécifique.  Cela fonctionne plutôt bien. <br><br>  Dans cette approche, tout repose sur l'équilibre entre la fiabilité et la charge parasite. Pas les serveurs. Vous fournissez la fiabilité, mais parfois vous obtenez des demandes supplémentaires au serveur.  Si vous étiez pressé quelque part et avez envoyé une deuxième demande, mais que la première a quand même répondu, le serveur a reçu un peu plus de charge.  Dans un seul cas, c'est un petit problème. <br><br><img src="https://habrastorage.org/webt/uv/7c/bs/uv7cbswancegyh5vc8t7mwvr8uy.png"><br><br>  La cohérence du timeout est un autre aspect important.  Nous parlerons davantage de l'annulation de la demande, mais en général, si le délai d'expiration de la demande utilisateur entière est de 100 ms, il est inutile de définir le délai d'expiration de la demande dans la base de données pendant 1 s.  Il existe des systèmes qui vous permettent de le faire de manière dynamique: service à service transfère le reste du temps que vous attendez une réponse à cette demande.  C'est compliqué, mais si vous en avez soudainement besoin, vous pouvez facilement découvrir comment le faire dans le même Envoy. <br><br>  Que devez-vous savoir d'autre sur la nouvelle tentative? <br><br><h3>  Point de non retour (V1) <br></h3><br>  Ici, V1 n'est pas la version 1. Dans l'aviation, il existe un tel concept - la vitesse V1.  Il s'agit de la vitesse après laquelle il est impossible de ralentir lors de l'accélération sur la piste.  Il est nécessaire de décoller, puis de décider quoi faire ensuite. <br><br>  Le même point de non-retour se trouve dans les équilibreurs de charge: <strong>lorsque vous avez transmis 1 octet de la réponse à votre client, aucune erreur ne peut être corrigée</strong> .  Si le backend meurt à ce stade, aucune nouvelle tentative ne sera utile.  Vous ne pouvez que réduire la probabilité qu'un tel scénario se déclenche, effectuer un arrêt progressif, c'est-à-dire dire à votre application: «Vous n'acceptez pas de nouvelles demandes maintenant, mais modifiez les anciennes!» Et alors seulement, éteignez-la. <br><br>  Si vous contrôlez le client, il s'agit d'une application Ajax ou mobile délicate, il peut essayer de répéter la demande, puis vous pouvez sortir de cette situation. <br><br><h3>  Point de non-retour [Envoyé] <br></h3><br>  L'envoyé a eu un truc si étrange.  Il y a per_try_timeout - il limite le temps que chaque tentative pour obtenir une réponse à une demande peut prendre.  Si ce délai a fonctionné, mais que le backend a déjà commencé à répondre au client, alors tout a été interrompu, le client a reçu une erreur. <br><br>  Mon collègue Pavel Trukhanov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">tru_pablo</a> ) a fait un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch</a> , qui est déjà dans master Envoy et sera en 1.7.  Maintenant, cela fonctionne comme il se doit: si la réponse a commencé à être transmise, seul le délai global fonctionnera. <br><br><h3>  Nouvelles tentatives: nécessité de limiter <br></h3><br>  Les nouvelles tentatives sont bonnes, mais il existe des demandes dites tueuses: les requêtes lourdes qui exécutent une logique très complexe accèdent beaucoup à la base de données et ne correspondent souvent pas à per_try_timeout.  Si nous envoyons encore et encore des tentatives, nous tuons notre base.  Parce que <strong>dans la plupart des services de base de données (99,9%), il n'y a pas d'annulation de demande</strong> . <br><br>  La demande d'annulation signifie que le client a décroché, vous devez arrêter tout travail maintenant.  Golang promeut activement cette approche, mais malheureusement, elle se termine par un backend, et de nombreux référentiels de base de données ne le prennent pas en charge. <br><br>  En conséquence, les tentatives doivent être limitées, ce qui permet à presque tous les équilibreurs (nous cessons désormais de considérer HAProxy). <br><br>  <strong>Nginx:</strong> <br><br><ul><li>  proxy_next_upstream_timeout (global) </li><li>  proxt_read_timeout ** comme per_try_timeout </li><li>  proxy_next_upstream_tries </li></ul><br>  <strong>Envoyé:</strong> <br><br><ul><li>  délai d'attente (global) </li><li>  per_try_timeout </li><li>  num_retries </li></ul><br>  Dans Nginx, nous pouvons dire que nous essayons de faire des tentatives à travers la fenêtre X, c'est-à-dire qu'à un intervalle de temps donné, par exemple 500 ms, nous faisons autant de tentatives que bon.  Ou il existe un paramètre qui limite le nombre d'échantillons répétés.  Dans <strong>Envoy</strong> , la même chose est la quantité ou le délai d'expiration (global). <br><br><h4>  Nouvelle tentative: appliquer [nginx] <br></h4><br>  Prenons un exemple: nous définissons des tentatives de relance dans nginx 2 - en conséquence, après avoir reçu HTTP 503, nous essayons d'envoyer à nouveau une demande au serveur.  Désactivez ensuite les <strong>deux</strong> backends. <br><br><pre> <code class="plaintext hljs">upstream backends { server 127.0.0.1:20001; server 127.0.0.1:20002; server 127.0.0.1:20003; } server { listen 127.0.0.1:30000; proxy_next_upstream error timeout http_503; proxy_next_upstream_tries 2; location / { proxy_pass http://backends; } }</code> </pre><br>  Voici les graphiques de notre banc d'essai.  Il n'y a aucune erreur sur le graphique supérieur, car il y en a très peu.  Si vous ne laissez que des erreurs, il est clair qu'elles le sont. <br><br><img src="https://habrastorage.org/webt/3h/sx/aq/3hsxaq8qyifcoyq3mvcyzmxm_cc.png"><br><br><img src="https://habrastorage.org/webt/sc/f_/2w/scf_2wz9tctmouvrs9hpqtpmau0.png"><br><br>  <strong>Qu'est-il arrivé?</strong> <br><br><ul><li>  proxy_next_upstream_tries = <strong>2.</strong> </li><li>  Dans le cas où vous effectuez la première tentative sur le serveur "mort" et la seconde - sur l'autre "mort", vous obtenez HTTP-503 en cas de <strong>deux</strong> tentatives sur les "mauvais" serveurs. </li><li>  Il y a peu d'erreurs, car nginx "interdit" un mauvais serveur.  Autrement dit, si dans nginx certaines erreurs sont retournées par le backend, il cesse de faire les tentatives suivantes pour lui envoyer une demande.  Ceci est régi par la variable <strong>fail_timeout.</strong> </li></ul><br>  Mais il y a des erreurs, et cela ne nous convient pas. <br><br>  <strong>Que faire à ce sujet?</strong> <br><br>  Nous pouvons soit augmenter le nombre de nouvelles tentatives (mais revenir ensuite au problème des «demandes de tueur»), soit réduire la probabilité qu'une demande atteigne des backends «morts».  Cela peut être fait avec <strong>des bilans de santé.</strong> <br><br><h2>  Contrôles de santé <br></h2><br>  Je suggère de considérer les bilans de santé comme une optimisation du processus de choix d'un serveur «live».  <strong>Cela ne donne aucune garantie.</strong>  Par conséquent, lors de l'exécution d'une demande d'utilisateur, nous sommes plus susceptibles d'accéder uniquement aux serveurs «en direct».  L'équilibreur accède régulièrement à une URL spécifique, le serveur lui répond: "Je suis vivant et prêt". <br><br><h4>  Contrôles d'intégrité: en termes de backend <br></h4><br>  Du point de vue du backend, vous pouvez faire des choses intéressantes: <br><br><ul><li>  Vérifiez l'état de préparation pour le fonctionnement de tous les sous-systèmes sous-jacents dont dépend le backend: le nombre nécessaire de connexions à la base de données est établi, le pool a des connexions libres, etc., etc. </li><li>  Vous pouvez accrocher votre propre logique sur l'URL des contrôles d'intégrité si l'équilibreur utilisé n'est pas très intelligent (par exemple, vous prenez l'équilibreur de charge de l'hôte).  Le serveur peut se rappeler que "dans la dernière minute, j'ai donné tant d'erreurs - je suis probablement une sorte de" mauvais "serveur, et pendant les 2 prochaines minutes, je répondrai avec" cinq cents "aux contrôles de santé.  Je vais donc m'interdire! "  Cela aide parfois beaucoup lorsque vous avez un équilibreur de charge non contrôlé. </li><li>  En règle générale, l'intervalle de vérification est d'environ une seconde et vous avez besoin du gestionnaire de vérification d'intégrité pour ne pas tuer votre serveur.  Ça devrait être léger. </li></ul><br><h4>  Contrôles d'intégrité: implémentations <br></h4><br>  En règle générale, tout ici est le même pour tout le monde: <br><br><ul><li>  Demande; </li><li>  Timeout dessus; </li><li>  Intervalle pendant lequel nous effectuons les vérifications.  Les proxys trompés ont une <strong>gigue</strong> , c'est-à-dire une certaine randomisation afin que tous les contrôles de santé ne parviennent pas au backend en même temps et ne le tuent pas. </li><li>  <strong>Seuil malsain</strong> - seuil du nombre de contrôles d'intégrité ayant échoué pour que le service le marque comme malsain. </li><li>  <strong>Seuil sain</strong> - au contraire, combien de tentatives réussies doivent passer pour que le serveur puisse retourner en fonctionnement. </li><li>  Logique supplémentaire.  Vous pouvez analyser l'état de vérification + le corps, etc. </li></ul><br>  Nginx implémente les fonctions de vérification d'intégrité uniquement dans la version payante de nginx +. <br><br>  Je note une fonctionnalité d' <strong>Envoy</strong> , il a un <strong>mode panique de</strong> contrôle de santé <strong>.</strong>  Lorsque nous avons interdit, comme "malsain", plus de N% des hôtes (disons 70%), il pense que tous nos bilans de santé mentent, et tous les hôtes sont en fait vivants.  Dans un très mauvais cas, cela vous aidera à ne pas vous retrouver dans une situation où vous vous êtes tiré une balle dans la jambe et avez banni tous les serveurs.  C'est une façon d'être à nouveau en sécurité. <br><br><h2>  Tout mettre ensemble <br></h2><br>  Généralement pour les contrôles de santé définis: <br><br><ul><li>  Ou nginx +; </li><li>  Ou nginx + autre chose :) </li></ul><br>  Dans notre pays, il y a une tendance à définir nginx + HAProxy, car la version gratuite de nginx n'a pas de contrôle de santé et jusqu'au 1.11.5 il n'y avait pas de limite sur le nombre de connexions au backend.  Mais cette option est mauvaise car HAProxy ne sait pas comment se retirer après avoir établi une connexion.  Beaucoup de gens pensent que si HAProxy renvoie une erreur sur les tentatives de nginx et nginx, alors tout ira bien.  Pas vraiment.  Vous pouvez accéder à un autre HAProxy et au même backend, car les pools de backend sont les mêmes.  Vous introduisez donc un niveau d'abstraction supplémentaire pour vous-même, ce qui réduit la précision de votre équilibrage et, par conséquent, la disponibilité du service. <br><br>  Nous avons nginx + Envoy, mais si vous êtes confus, vous pouvez vous limiter à Envoy uniquement. <br><br><h2>  Quel genre d'envoyé? <br></h2><br>  Envoy est un équilibreur de charge pour les jeunes à la mode, développé à l'origine en Lyft, écrit en C ++.  <strong>Hors de la boîte, il peut faire un tas de petits pains sur notre sujet aujourd'hui.</strong>  Vous l'avez probablement vu comme un maillage de service pour Kubernetes.  En règle générale, Envoy agit comme un plan de données, c'est-à-dire qu'il équilibre directement le trafic, et il existe également un plan de contrôle qui fournit des informations sur ce dont vous avez besoin pour répartir la charge entre (découverte de service, etc.). <br><br>  Je vais vous dire quelques mots sur ses petits pains. <br><br>  Pour augmenter les chances de réussite d'une nouvelle tentative de réponse la prochaine fois que vous essayez, vous pouvez dormir un peu et attendre que les backends reprennent leurs esprits.  De cette façon, nous traiterons les problèmes de base de données courts.  Envoy a un <strong>délai d'attente pour les relances</strong> - fait une pause entre les relances.  De plus, l'intervalle de retard entre les tentatives augmente de façon exponentielle.  La première nouvelle tentative se produit après 0-24 ms, la seconde après 0-74 ms, puis pour chaque tentative suivante, l'intervalle augmente et le retard spécifique est sélectionné de manière aléatoire dans cet intervalle. <br><br>  La seconde approche n'est pas spécifique à l'Envoy, mais un modèle appelé <strong>Circuit breaking</strong> (disjoncteur ou fusible).  Lorsque notre backend s'émousse, en fait, nous essayons de le terminer à chaque fois.  En effet, les utilisateurs dans une situation incompréhensible cliquent sur la page d'actualisation, vous envoyant de plus en plus de nouvelles demandes.  Vos équilibreurs deviennent nerveux, envoient de nouvelles tentatives, le nombre de demandes augmente - la charge augmente, et dans cette situation, ce serait bien de ne pas envoyer de demandes. <br><br>  Le disjoncteur vous permet simplement de déterminer que nous sommes dans cet état, de tirer rapidement l'erreur et de donner aux backends «le souffle coupé». <br><br><img src="https://habrastorage.org/webt/xb/mm/i8/xbmmi88cqacoqvkzdmujynq6da0.gif"><br>  <em>Disjoncteur (hystrix like libs),</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>original</em></a> <em>sur le blog d'ebay.</em> <br><br>  Ci-dessus, le circuit du disjoncteur Hystrix.  Hystrix est la bibliothèque Java de Netflix conçue pour implémenter des modèles de tolérance aux pannes. <br><br><ul><li>  Le «fusible» peut être à l'état «fermé» lorsque toutes les demandes sont envoyées au backend et qu'il n'y a aucune erreur. </li><li>  Lorsqu'un certain seuil de défaillance est déclenché, c'est-à-dire que certaines erreurs se sont produites, le disjoncteur passe à l'état «Ouvert».  Il renvoie rapidement une erreur au client et les demandes ne parviennent pas au backend. </li><li>  Une fois dans un certain laps de temps, une petite partie des demandes est toujours envoyée au backend.  Si une erreur est déclenchée, l'état reste "Ouvert".  Si tout commence à bien fonctionner et à répondre, le «fusible» se ferme et le travail continue. </li></ul><br>  Dans Envoy, en tant que tel, ce n'est pas tout.  Il existe des limites de niveau supérieur sur le fait qu'il ne peut y avoir plus de N demandes pour un groupe en amont spécifique.  Si plus, quelque chose ne va pas ici - nous retournons une erreur.  Il ne peut plus y avoir N de nouvelles tentatives actives (c'est-à-dire des tentatives qui se produisent actuellement). <br><br>  Vous n'avez pas eu de nouvelles tentatives, quelque chose a explosé - envoyez des nouvelles tentatives.  Envoy comprend que plus de N est anormal et toutes les demandes doivent être traitées avec une erreur. <br><br>  <strong>Disjoncteur [Envoyé]</strong> <br><br><ul><li>  Nombre maximal de connexions de cluster (groupe en amont) </li><li>  Nombre maximal de demandes en attente du cluster </li><li>  Nombre maximal de demandes de cluster </li><li>  Nouvelles tentatives actives du cluster </li></ul><br>  Cette chose simple fonctionne bien, elle est configurable, vous n'avez pas à proposer de paramètres spéciaux et les paramètres par défaut sont assez bons. <br><br><h4>  Disjoncteur: notre expérience <br></h4><br>  Auparavant, nous avions un collecteur de métriques HTTP, c'est-à-dire que les agents installés sur les serveurs de nos clients envoyaient des métriques à notre cloud via HTTP.  Si nous rencontrons des problèmes dans l'infrastructure, l'agent écrit les métriques sur son disque puis essaie de nous les envoyer. <br><br>  Et les agents tentent constamment de nous envoyer des données, ils ne sont pas fâchés que nous répondions de manière incorrecte et ne partons pas. <br><br>         (       ,      )  ,     ,           . <br><br>            nginx limit req.    ,    , , 200 RPS.       ,   ,          ,   limit req. <br><br>           TCP     HTTP (  nginx limit req).            .      limit req . <br><br>     ,      ,  .   <strong> </strong>  Circuit breaker,  ,     N  ,   ,   - ,   ,  .   ,    ,      spool  . <br><br>  <strong></strong>   Circuit breaker       + request cancellation ( ).  ,    N   Cassandra, N   Elastic,  ,    —   ,         .      — ,   . <br><br><img src="https://habrastorage.org/webt/jo/l2/jk/jol2jk44vlcmz3twgvr0jgtpbii.png"><br><br><img src="https://habrastorage.org/webt/1a/7b/x4/1a7bx4yq20uehqoagd4tutqxgmw.png"><br><br>    ,         (:  —  «»,  — «»). ,      800 RPS    20-30.     «», ,    . <br><br><h2>    <br></h2><br>    —  ,  . <br><br>         ,   ,        —      .    . <br><br>  ,       , ,      ,   Health checks — HTTP 200. <br><br>    . <br><br><img src="https://habrastorage.org/webt/yu/cy/9s/yucy9sofdr-z7brvjedmnxt4_gc.png"><br><br>     Load Balancer, 3 ,         Cassandra.      Cassandra,   Cassandra   ,    Cassandra     data noda. <br><br>   —    : <strong>kernel: NETDEV WATCHDOG: eth0 (ixgbe): transmit queue 3 timed out.</strong> <br><br>   :     (    ),    64     . , 1/64   .     reboot,    . <br><br> ,  ,    ,      .  , ,        ,            .   ,    ,   .     ,   . <br><br> <strong>Cassandra: coordinator -&gt; nodes</strong> <br><br>  Cassandra,      (speculative retries),      .    latency  99 ,         . <br><br> <strong>App -&gt; cassandra coordinator</strong> <br><br>     .     Cassandra      «» ,    ,  ,  latency  .. <br><br>      gocql —   cassandra client.       .   HostSelectionPolicy,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bitly/go-hostpool</a> .    Epsilon greedy  ,       . <br><br>     ,    <strong>Epsilon-greedy</strong> . <br><br>      (multi-armed bandit):       ,     ,     N     . <br><br>    : <br><br><ol><li>  « <strong>explore»</strong> —   : 10    ,  ,   . <br></li><li>  « <strong>exploit»</strong> —      . <br></li></ol><br> ,    (10 — 30%)   <strong>round</strong> - <strong>robin</strong>    ,  ,  ,  .  70 — 90%        . <br><br> Host-pool          .         .        (    — ,    ,  ).      .      ,     , ,       . <br><br><h2>   </h2><br>   «» ()   —Cassandra  Cassandra coordinator-data.     (nginx, Envoy —  )    «» Application,     Cassandra  ,       ,      . <br><br>  Envoy    <strong>Outlier detection</strong> : <br><br><ul><li> Consecutive http-5xx. </li><li> Consecutive gateway errors (502,503,504). </li><li> Success rate. </li></ul><br>   «»  ,    -  ,   .   ,    .        —    ,   ,     .  ,    ,          . <br><br>   ,       «»,   max_ejection_percent.    ,      outlier,     .  ,    70%  —  ,   — , ! <br><br>      ,       — ! <br><br><h2>  <br></h2><br> ,     ,      .  ,       latency    , : <br><br><ul><li>  ,        .. </li><li>    ,      -,       . </li></ul><br> ,  <strong>    </strong> ,   .  ,      ,     ,         —  ,    . <br><br> <strong>      </strong> .  99%     nginx/ <s>HAProxy</s> /Envoy.   proxy ,           «». <br><br> <strong>    proxy</strong> (   HAProxy:)), <strong>  ,    .</strong> <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevOpsConf Russia</a>      Kubernetes         .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>    ,       — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>      DevOps. <br><br>    ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YouTube-</a> —              . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423085/">https://habr.com/ru/post/fr423085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423073/index.html">Système de fichiers interplanétaire - hachage trivial (identité), bloc DAG et tampons de protocole</a></li>
<li><a href="../fr423075/index.html">Pourquoi les directeurs financiers sont-ils si désireux de traduire les dépenses d'investissement en informatique en opérations</a></li>
<li><a href="../fr423077/index.html">Guide de l'assembleur X86 pour les débutants</a></li>
<li><a href="../fr423079/index.html">Points clés d'une entrevue avec Elon Musk chez Joe Rogan</a></li>
<li><a href="../fr423083/index.html">Comment je suis devenu développeur chez ABBYY</a></li>
<li><a href="../fr423087/index.html">Ne me pousse pas dans les yeux</a></li>
<li><a href="../fr423089/index.html">Programmeurs à MBLT DEV 2018</a></li>
<li><a href="../fr423091/index.html">Flutter pour les développeurs Android. Comment créer une interface utilisateur pour une activité à l'aide de Flutter</a></li>
<li><a href="../fr423093/index.html">Nous augmentons le caractère aléatoire du fait que [probablement] [presque] par accident</a></li>
<li><a href="../fr423095/index.html">Nouveautés d'Apple Presentation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>