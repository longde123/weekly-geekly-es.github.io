<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèº üçä üö™ Empaquetado de aplicaciones principales de ASP.NET con Docker üîê üë∏üèæ ‚õÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las aplicaciones ASP.NET Core son verdaderamente multiplataforma y pueden ejecutarse en nixes y, en consecuencia, en Docker. Veamos c√≥mo pueden empaqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Empaquetado de aplicaciones principales de ASP.NET con Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/435914/"><p>  Las aplicaciones ASP.NET Core son verdaderamente multiplataforma y pueden ejecutarse en nixes y, en consecuencia, en Docker.  Veamos c√≥mo pueden empaquetarse para implementarse en Linux y usarse junto con Nginx.  Detalles debajo del corte! </p><br><p><img src="https://habrastorage.org/webt/rv/zy/xx/rvzyxxq8mg8yreoka2rkkukpr3i.jpeg"><a name="habracut"></a></p><br><p>  <em>Nota: continuamos la serie de publicaciones de versiones completas de art√≠culos de la revista Hacker.</em>  <em>Ortograf√≠a y puntuaci√≥n del autor guardado.</em> </p><br><h2>  Sobre Docker </h2><br><p>  Casi todos han escuchado sobre la arquitectura de microservicios.  El concepto de dividir la aplicaci√≥n en partes no quiere decir que sea nueva.  Pero, lo nuevo es lo viejo olvidado y reciclado. </p><br><p>  Si intenta hablar de arquitectura en pocas palabras, la aplicaci√≥n web se divide en partes unitarias separadas: servicios.  Los servicios no interact√∫an directamente entre s√≠ y no tienen bases de datos comunes.  Esto se hace para poder cambiar cada servicio sin consecuencias para los dem√°s.  Los servicios se empaquetan en contenedores.  Entre los contenedores, Docker gobierna la pelota. </p><br><p>  Para describir qu√© Docker se simplifica muy a menudo, use el t√©rmino "m√°quina virtual".  Definitivamente hay una similitud, pero es un error decirlo.  La forma m√°s f√°cil de comprender esta diferencia es mirar las siguientes im√°genes de la documentaci√≥n oficial de la ventana acoplable: </p><br><p><img src="https://habrastorage.org/webt/xf/os/nu/xfosnujlxyttzdhimiuzf8tmcd8.png"></p><br><p><img src="https://habrastorage.org/webt/w4/y4/6e/w4y46e4boi3u-l8pwo70rs-7xmm.png"></p><br><p>  Los contenedores utilizan el n√∫cleo del sistema operativo actual y lo dividen entre ellos.  Mientras que las m√°quinas virtuales que usan hipervisor usan recursos de hardware. <br>  Docker Image es un objeto de solo lectura que esencialmente almacena una plantilla para construir un contenedor.  Un contenedor es un entorno en el que se ejecuta el c√≥digo.  Las im√°genes se almacenan en repositorios.  Por ejemplo, el repositorio oficial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker Hub le</a> permite almacenar solo una imagen de forma privada.  Sin embargo, es gratis, as√≠ que incluso por esto debes agradecerles. </p><br><h1>  INFORMACI√ìN </h1><br><p>  Docker no es el √∫nico representante de la contenedorizaci√≥n.  Adem√°s de eso, hay otras tecnolog√≠as.  Por ejemplo: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rkt</a> (pronunciado 'cohete') por CoreOS </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LXD</a> (pronunciado 'lexdi') por Ubuntu </p><br><p>  Contenedores de Windows: nunca lo adivinar√° nadie. </p><br><p>  Ahora que nos hemos familiarizado con la teor√≠a, pasemos a la pr√°ctica. </p><br><p>  No tiene sentido desmontar la instalaci√≥n de la ventana acoplable, ya que se puede instalar en muchos sistemas operativos.  Solo le indicar√© que puede descargarlo para su plataforma desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker Store</a> .  Si instala Docker en Windows, la virtualizaci√≥n debe estar habilitada en el BIOS y el sistema operativo.  Puede leer sobre c√≥mo habilitarlo en 10-ke en el siguiente art√≠culo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instalaci√≥n de Hyper-V en Windows10</a> </p><br><h2>  Crear un proyecto habilitado para Docker </h2><br><p> Docker es, por supuesto, un producto Linux, pero si es necesario, puede usarlo cuando desarrolle para Mac o Windows.  Al crear un proyecto en Visual Studio, para agregar compatibilidad con Docker, simplemente seleccione la casilla de verificaci√≥n Habilitar compatibilidad con Docker. </p><br><p>  El soporte de Docker se puede agregar a un proyecto existente.  Se agrega al proyecto de la misma manera que se agregan varios componentes nuevos.  Men√∫ contextual Agregar - Soporte Docker. </p><br><p>  Si Docker est√° instalado y ejecut√°ndose en su m√°quina, la consola se abrir√° autom√°ticamente y se ejecutar√° el comando </p><br><pre><code class="lua hljs">docker pull microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre> <br><p>  que inicia el proceso de descarga de la imagen.  Esta imagen es en realidad un espacio en blanco sobre la base de la cual se crear√° su imagen.  ASP.NET Core 2.1 usa una imagen diferente - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">microsoft / dotnet: sdk</a> </p><br><p>  Los siguientes archivos se crear√°n autom√°ticamente en el directorio con la soluci√≥n para usted: <br>  .dockerignore (excluyendo archivos y directorios de la imagen del docker), docker-compose.yml (usando este archivo puede configurar la ejecuci√≥n de varios servicios), docker-compose.override.yml (configuraci√≥n auxiliar docker-compose), docker-compose.dcproj ( archivo de proyecto para Visual Studio). </p><br><p>  Se crear√° un archivo Dockerfile en el directorio del proyecto.  En realidad, con la ayuda de este archivo creamos nuestra imagen.  De manera predeterminada (en caso de que el proyecto se llame DockerServiceDemo), puede verse as√≠: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo/DockerServiceDemo.csproj DockerServiceDemo/ RUN dotnet restore DockerServiceDemo/DockerServiceDemo.csproj COPY . . WORKDIR /src/DockerServiceDemo RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  La configuraci√≥n inicial para .NET Core 2.0 no le permitir√° compilar la imagen de forma inmediata utilizando el comando de construcci√≥n docker.  Est√° configurado para iniciar el archivo docker-compose desde un directorio de un nivel superior.  Para que la construcci√≥n contin√∫e con √©xito, el Dockerfile puede tener un aspecto similar: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo.csproj DockerServiceDemo.csproj RUN dotnet restore DockerServiceDemo.csproj COPY . . WORKDIR /src RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  Todo lo que hice fue eliminar el directorio adicional DockerServiceDemo. </p><br><p>  Si usa Visual Studio Code, deber√° generar los archivos manualmente.  Aunque VS Code tiene una funcionalidad auxiliar en forma de una extensi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregar√©</a> un enlace al manual sobre c√≥mo trabajar con la ventana acoplable desde VS Code - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajar con Docker</a> .  S√≠, el art√≠culo est√° en ingl√©s, pero con im√°genes. </p><br><h2>  Docker de tres acordes </h2><br><p>  Para el trabajo diario con la ventana acoplable, solo unos pocos comandos son suficientes para recordar. </p><br><p>  El equipo m√°s importante es, por supuesto, construir una imagen.  Para hacer esto, debe usar bash / CMD / PowerShell para ir al directorio donde se encuentra el Dockerfile y ejecutar el comando: </p><br><pre> <code class="python hljs">docker build -t your_image_name .</code> </pre> <br><p>  Aqu√≠, despu√©s de la opci√≥n -t, se establece el nombre de su imagen.  Atenci√≥n: al final del comando, un espacio despu√©s del espacio  Este punto significa que se est√° utilizando el directorio actual.  Una imagen se puede etiquetar con una etiqueta (n√∫mero o nombre).  Para hacer esto, coloque dos puntos despu√©s del nombre y especifique una etiqueta.  Si no se especifica la etiqueta, de forma predeterminada se establecer√° con el nombre m√°s reciente.  Para enviar una imagen al repositorio, es necesario que el nombre de la imagen incluya el nombre del repositorio.  Algo como esto: </p><br><pre> <code class="python hljs">docker build -t docker_account_name/image_name:your_tag .</code> </pre> <br><p>  Aqu√≠ your_docker_account_name es el nombre de su cuenta de Docker Hub. </p><br><p>  Si cre√≥ la imagen solo con un nombre local que no incluye el repositorio, puede marcar la imagen con un nombre diferente despu√©s de la construcci√≥n utilizando el siguiente comando: </p><br><pre> <code class="python hljs">docker tag image_name docker_account_name/image_name:your_tag</code> </pre> <br><p>  Para enviar cambios al concentrador, ahora debe ejecutar el siguiente comando: </p><br><pre> <code class="python hljs">docker push docker_account_name/image_name:your_tag</code> </pre> <br><p>  Antes de esto, debe iniciar sesi√≥n en su cuenta de Docker.  En Windows, esto se hace desde la interfaz de usuario de la aplicaci√≥n, pero en * nix esto se hace mediante el comando: </p><br><pre> <code class="python hljs">docker login</code> </pre> <br><p>  De hecho, tres equipos no son suficientes.  Tambi√©n debe poder verificar el funcionamiento del contenedor.  El comando con el que puede iniciar el contenedor se ve as√≠: </p><br><pre> <code class="python hljs">docker run -it -p <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> image_name</code> </pre> <br><p>  La opci√≥n -it crear√° un pseudo-TTY y su contenedor responder√° a las solicitudes.  Despu√©s de ejecutar el comando, el servicio estar√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 5000 /</a> </p><br><p>  -p 5000: 80 asocia el puerto 5000 del contenedor con el puerto 80 del host. </p><br><p>  Adem√°s, hay tales comandos: </p><br><pre> <code class="python hljs">docker ps ‚Äìa</code> </pre> <br><p>  Mostrarle una lista de contenedores.  Como se ha agregado el modificador -a, se mostrar√°n todos los contenedores, no solo los que se est√°n ejecutando actualmente. </p><br><pre> <code class="python hljs">docker rm container_name</code> </pre> <br><p>  Este comando eliminar√° el contenedor llamado container_name.  rm - abreviatura de eliminar </p><br><pre> <code class="python hljs">docker logs container_name</code> </pre> <br><p>  Mostrar registros de contenedores </p><br><pre> <code class="python hljs">docker rmi image_name</code> </pre> <br><p>  Elimina una imagen llamada image_name </p><br><h2>  Lanzar un contenedor a trav√©s de un servidor proxy inverso </h2><br><p>  El hecho es que las aplicaciones .NET Core utilizan su servidor web Kestrel.  Este servidor no se recomienda para producci√≥n.  Por qu√©  Hay varias explicaciones. <br>  Si hay varias aplicaciones que comparten IP y puerto, Kestrel no podr√° distribuir el tr√°fico.  Adem√°s, el servidor proxy inverso proporciona una capa adicional de seguridad, simplifica el equilibrio de carga y la configuraci√≥n de SSL, y tambi√©n se integra mejor en la infraestructura existente.  Para la mayor√≠a de los desarrolladores, la raz√≥n m√°s importante para la necesidad de servidores proxy inversos es la seguridad adicional. </p><br><p>  Primero, restaure la configuraci√≥n original de Dockerfile.  Despu√©s de eso, trataremos con el archivo docker-compose.yml e intentaremos ejecutar nuestro servicio solo.  El formato de archivo yml se lee como ‚Äúyaml‚Äù y es una abreviatura de ‚ÄúYet Another Markup Language‚Äù o de ‚ÄúYAML Ain't Markup Language‚Äù.  Ya sea otro lenguaje de marcado o ning√∫n lenguaje de marcado.  De alguna manera, todo no es seguro. </p><br><p>  Mi archivo docker-compose predeterminado se ve as√≠: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile</code> </pre> <br><p>  El archivo docker-compose.override.yml agrega varias configuraciones a la configuraci√≥n: <br>  versi√≥n: '3.4' </p><br><pre> <code class="python hljs">services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development ports: - <span class="hljs-string"><span class="hljs-string">"80"</span></span></code> </pre> <br><p>  Podemos construir la soluci√≥n creada usando docker-compose build, llamando al comando docker-compose up, lanzaremos nuestro contenedor.  ¬øFunciona todo?  Luego ve al siguiente paso.  Cree el archivo nginx.info.  La configuraci√≥n ser√° aproximadamente la siguiente: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">80</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">80</span></span>; location / { proxy_pass http://app_servers; proxy_http_version <span class="hljs-number"><span class="hljs-number">1.1</span></span>; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  Aqu√≠ indicamos que nginx escuchar√° en el puerto 80 (listen 80;).  Y las solicitudes recibidas ser√°n redirigidas al puerto 80 del host en el contenedor dockerservicedemo.  Adem√°s, le decimos a nginx qu√© encabezados transmitir. </p><br><p>  Podemos usar http en nginx y acceder al sitio web a trav√©s de https.  Cuando una solicitud https pasa por un proxy http, no se pasa mucha informaci√≥n de https a http.  Adem√°s, cuando se usa un proxy, se pierde la direcci√≥n IP externa.  Para que esta informaci√≥n se transmita en los encabezados, debe cambiar el c√≥digo de nuestro proyecto ASP.NET y agregar el siguiente c√≥digo al comienzo del m√©todo Configure del archivo Startup.cs: </p><br><pre> <code class="python hljs"> app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto });</code> </pre> <br><p>  La mayor√≠a de los servidores proxy usan los encabezados X-Fordered-For y X-Fordered-Proto.  Son estos encabezados los que se especifican ahora en la configuraci√≥n de nginx. </p><br><p>  Ahora incluya la imagen nginx y el archivo nginx.conf en la configuraci√≥n doker-compose.  La precauci√≥n en los espacios YAML es importante: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile ports: - <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf ports: - <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span></code> </pre> <br><p>  Aqu√≠ agregamos proxies a nuestra configuraci√≥n como una imagen nginx.  Adjuntamos a esta imagen un archivo de configuraci√≥n externo.  Lo montamos en el sistema de archivos del contenedor utilizando un mecanismo llamado volumen.  Si agrega al final: ro, entonces el objeto se montar√° de solo lectura. </p><br><p>  El proxy escucha el puerto 80 externo de la m√°quina en la que se est√° ejecutando el contenedor y env√≠a una solicitud al puerto 80 interno del contenedor. </p><br><p>  Al ejecutar el comando doker-compose up, completaremos, es decir, extraeremos la imagen nginx del repositorio e iniciaremos nuestro contenedor junto con el contenedor proxy.  Ahora en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 80 /</a> ser√° accesible a trav√©s de nginx.  En el puerto 5000, la aplicaci√≥n "gira" tambi√©n bajo Kestrel. </p><br><p>  Podemos verificar que la solicitud a la aplicaci√≥n web pase por el proxy inverso.  Abra las herramientas de desarrollador en el navegador Chrome y vaya a la pesta√±a Red.  Haga clic en localhost aqu√≠ y seleccione la pesta√±a Encabezados. </p><br><p><img src="https://habrastorage.org/webt/zx/xi/sp/zxxisp6hjwtbza8u5wlmgu54jqq.png"></p><br><h2>  Lanzamos el contenedor a trav√©s de proxies y HTTPS </h2><br><p>  ASP.NET Core 2.1 trajo consigo mejoras en el soporte HTTPS. <br>  Digamos que el siguiente middleware le permite redirigir desde una conexi√≥n no segura a una segura: </p><br><pre> <code class="python hljs">app.UseHttpsRedirection();</code> </pre> <br><p>  Y el siguiente le permite utilizar el Protocolo de seguridad de transporte estricto HTTP: HSTS. </p><br><pre> <code class="python hljs">app.UseHsts();</code> </pre> <br><p>  HSTS es una caracter√≠stica del protocolo HTTP / 2, cuya especificaci√≥n se lanz√≥ en 2015.  Esta funcionalidad es compatible con los navegadores modernos e informa que el sitio web usa solo https.  Por lo tanto, se produce protecci√≥n contra un ataque de degradaci√≥n durante el cual el atacante puede aprovechar la situaci√≥n mediante el uso de la transici√≥n a un protocolo http inseguro.  Por ejemplo, degradar TLS o incluso reemplazar un certificado. </p><br><p>  Por lo general, este tipo de ataque se usa junto con ataques de hombre en el medio.  Debe saber y recordar que HSTS no lo salva de una situaci√≥n en la que un usuario visita el sitio utilizando el protocolo http y luego lo redirige a https.  Existe la llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lista de precarga de Chrome</a> , que contiene enlaces a sitios que admiten https.  Otros navegadores (Firefox, Opera, Safari, Edge) tambi√©n admiten listas de sitios https creados en base a la lista de Chrome.  Pero todas estas listas est√°n lejos de todos los sitios. </p><br><p>  La primera vez que ejecute una aplicaci√≥n Core en Windows, recibir√° un mensaje que indica que se ha creado e instalado un certificado de desarrollador.  Al hacer clic en el bot√≥n e instalar el certificado, lo har√° confiable.  Desde la l√≠nea de comandos en macOS, puede agregar confianza al certificado con el comando: <br>  dotnet dev-certs https ‚Äìtrust </p><br><p>  Si la utilidad dev-certs no est√° instalada, puede instalarla con el comando: </p><br><pre> <code class="python hljs">dotnet tool install --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> dotnet-dev-certs</code> </pre> <br><p>  C√≥mo agregar un certificado de confianza en Linux depende de la distribuci√≥n. <br>  Para fines de prueba, utilizamos el certificado del desarrollador.  Las acciones con un certificado firmado por CA son similares.  Si lo desea, puede usar certificados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LetsEncrypt</a> gratuitos </p><br><p>  Puede exportar el certificado de desarrollador a un archivo con el comando </p><br><pre> <code class="python hljs">dotnet dev-certs https -ep ___.pfx</code> </pre> <br><p>  El archivo debe copiarse en el directorio% APPDATA% / ASP.NET / Https / en Windows o en /root/.aspnet/https/ en macOS / Linux. </p><br><p>  Para que el contenedor tome la ruta al certificado y su contrase√±a, cree secretos de usuario con los siguientes contenidos: </p><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"Kestrel"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Certificates"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Default"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/root/.aspnet/https/__.pfx"</span></span>, <span class="hljs-string"><span class="hljs-string">"Password"</span></span>: <span class="hljs-string"><span class="hljs-string">"___"</span></span> } } } }</code> </pre> <br><p>  Este archivo almacena datos sin cifrar y, por lo tanto, solo se usa durante el desarrollo.  Se crea un archivo en Visual Studio llamando al men√∫ contextual en el icono del proyecto o utilizando la utilidad de secretos de usuario en Linux. </p><br><p>  En Windows, el archivo se guardar√° en el directorio% APPDATA% \ Microsoft \ UserSecrets \ &lt;user_secrets_id&gt; \ secrets.json, y en macOS y Linux se guardar√° en ~ / .microsoft / usersecrets / &lt;user_secrets_id&gt; /secrets.json </p><br><p>  Para guardar la configuraci√≥n para producci√≥n, algunas distribuciones de Linux pueden usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">systemd. La</a> configuraci√≥n se guarda bajo el atributo Servicio.  Por ejemplo, as√≠: </p><br><pre> <code class="python hljs">[Service] Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Path=/root/.aspnet/https/__.pfx"</span></span> Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Password=___"</span></span></code> </pre> <br><p>  A continuaci√≥n, dar√© y analizar√© de inmediato la versi√≥n de trabajo de la configuraci√≥n del acoplador para el proxy y el contenedor a trav√©s de https. </p><br><p>  Archivo Docker-compose: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo21: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile  override: version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=https://+:<span class="hljs-number"><span class="hljs-number">44392</span></span>;http://+:<span class="hljs-number"><span class="hljs-number">80</span></span> - ASPNETCORE_HTTPS_PORT=<span class="hljs-number"><span class="hljs-number">44392</span></span> ports: - <span class="hljs-string"><span class="hljs-string">"59404:80"</span></span> - <span class="hljs-string"><span class="hljs-string">"44392:44392"</span></span> volumes: - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf - ./DockerServiceDemo/cert.crt:/etc/nginx/cert.crt - ./DockerServiceDemo/cert.rsa:/etc/nginx/cert.rsa ports: - <span class="hljs-string"><span class="hljs-string">"5001:44392"</span></span></code> </pre> <br><p>  Ahora describir√© momentos incomprensibles.  ASPNETCORE_URLS nos permite no indicar en el c√≥digo de la aplicaci√≥n usando app.UseUrl el puerto en el que la aplicaci√≥n est√° escuchando. </p><br><p>  ASPNETCORE_HTTPS_PORT realiza una redirecci√≥n similar a la que har√≠a el siguiente c√≥digo: <br>  services.AddHttpsRedirection (opciones =&gt; opciones.HttpsPort = 44392) </p><br><p>  Es decir, el tr√°fico de las solicitudes http se redirigir√° a un puerto espec√≠fico de solicitudes https. <br>  Al usar los puertos, se indica que la solicitud del puerto externo 59404 se redirigir√° al contenedor 80 y del puerto externo 44392 al 44392.  Te√≥ricamente, dado que hemos configurado un servidor proxy inverso, podemos eliminar puertos con estos redireccionamientos. <br>  Usando vol√∫menes, un directorio con un certificado pfx y una aplicaci√≥n UserSecrets se montan con una contrase√±a y un enlace al certificado. </p><br><p>  La secci√≥n de proxy indica que las solicitudes del puerto externo 5001 se redirigir√°n al puerto nginx 44392.  Adem√°s, se monta un archivo de configuraci√≥n nginx, as√≠ como un certificado y una clave de certificado. </p><br><p>  Para que puedan crear un solo certificado pfx (que ya tenemos) para crear archivos crt y rsa, puede usar OpenSSL.  Primero necesitas extraer el certificado: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -clcerts -nokeys -out domain.crt</code> </pre> <br><p>  Y luego la clave privada: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -nocerts -nodes -out domain.rsa</code> </pre> <br><p>  La configuraci√≥n de nginx es la siguiente: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">44392</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">44392</span></span> ssl; ssl_certificate /etc/nginx/cert.crt; ssl_certificate_key /etc/nginx/cert.rsa; location / { proxy_pass https://app_servers; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  El servidor proxy est√° escuchando en el puerto 44392.  Este puerto recibe solicitudes del puerto de host 5001.  A continuaci√≥n, el proxy redirige las solicitudes al puerto 44392 del contenedor dockerdemoservice. </p><br><p>  Una vez que haya entendido estos ejemplos, obtendr√° buenos antecedentes para trabajar con Docker, microservicios y nginx. </p><br><p>  Le recordamos que esta es la versi√≥n completa de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo de la revista Hacker</a> .  Su autor es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexey Sommer</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435914/">https://habr.com/ru/post/es435914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435904/index.html">AI tradujo la actividad cerebral al habla</a></li>
<li><a href="../es435906/index.html">Marcapasos Cluster Storage + DRBD (Dual primario) + ctdb</a></li>
<li><a href="../es435908/index.html">Web asc√©tica: prototipo de mercados de pulgas en go and js</a></li>
<li><a href="../es435910/index.html">¬øPor qu√© BSD perdi√≥ la batalla con GNU / Linux?</a></li>
<li><a href="../es435912/index.html">Los principales problemas del desarrollo de interfaces modernas.</a></li>
<li><a href="../es435916/index.html">Hackear VK, la autenticaci√≥n de dos factores no guardar√°</a></li>
<li><a href="../es435920/index.html">Developer Cookbook: DDD Recipes (Part 4, Structures)</a></li>
<li><a href="../es435922/index.html">Java, Spring, Kurento y servicios de medios. Parte 2</a></li>
<li><a href="../es435924/index.html">La red neuronal genera im√°genes de platos seg√∫n recetas para su preparaci√≥n.</a></li>
<li><a href="../es435926/index.html">La red neuronal recoge fragmentos de hallazgos arqueol√≥gicos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>