<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏼 🍊 🚪 Empaquetado de aplicaciones principales de ASP.NET con Docker 🔐 👸🏾 ⛄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las aplicaciones ASP.NET Core son verdaderamente multiplataforma y pueden ejecutarse en nixes y, en consecuencia, en Docker. Veamos cómo pueden empaqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Empaquetado de aplicaciones principales de ASP.NET con Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/435914/"><p>  Las aplicaciones ASP.NET Core son verdaderamente multiplataforma y pueden ejecutarse en nixes y, en consecuencia, en Docker.  Veamos cómo pueden empaquetarse para implementarse en Linux y usarse junto con Nginx.  Detalles debajo del corte! </p><br><p><img src="https://habrastorage.org/webt/rv/zy/xx/rvzyxxq8mg8yreoka2rkkukpr3i.jpeg"><a name="habracut"></a></p><br><p>  <em>Nota: continuamos la serie de publicaciones de versiones completas de artículos de la revista Hacker.</em>  <em>Ortografía y puntuación del autor guardado.</em> </p><br><h2>  Sobre Docker </h2><br><p>  Casi todos han escuchado sobre la arquitectura de microservicios.  El concepto de dividir la aplicación en partes no quiere decir que sea nueva.  Pero, lo nuevo es lo viejo olvidado y reciclado. </p><br><p>  Si intenta hablar de arquitectura en pocas palabras, la aplicación web se divide en partes unitarias separadas: servicios.  Los servicios no interactúan directamente entre sí y no tienen bases de datos comunes.  Esto se hace para poder cambiar cada servicio sin consecuencias para los demás.  Los servicios se empaquetan en contenedores.  Entre los contenedores, Docker gobierna la pelota. </p><br><p>  Para describir qué Docker se simplifica muy a menudo, use el término "máquina virtual".  Definitivamente hay una similitud, pero es un error decirlo.  La forma más fácil de comprender esta diferencia es mirar las siguientes imágenes de la documentación oficial de la ventana acoplable: </p><br><p><img src="https://habrastorage.org/webt/xf/os/nu/xfosnujlxyttzdhimiuzf8tmcd8.png"></p><br><p><img src="https://habrastorage.org/webt/w4/y4/6e/w4y46e4boi3u-l8pwo70rs-7xmm.png"></p><br><p>  Los contenedores utilizan el núcleo del sistema operativo actual y lo dividen entre ellos.  Mientras que las máquinas virtuales que usan hipervisor usan recursos de hardware. <br>  Docker Image es un objeto de solo lectura que esencialmente almacena una plantilla para construir un contenedor.  Un contenedor es un entorno en el que se ejecuta el código.  Las imágenes se almacenan en repositorios.  Por ejemplo, el repositorio oficial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker Hub le</a> permite almacenar solo una imagen de forma privada.  Sin embargo, es gratis, así que incluso por esto debes agradecerles. </p><br><h1>  INFORMACIÓN </h1><br><p>  Docker no es el único representante de la contenedorización.  Además de eso, hay otras tecnologías.  Por ejemplo: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rkt</a> (pronunciado 'cohete') por CoreOS </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LXD</a> (pronunciado 'lexdi') por Ubuntu </p><br><p>  Contenedores de Windows: nunca lo adivinará nadie. </p><br><p>  Ahora que nos hemos familiarizado con la teoría, pasemos a la práctica. </p><br><p>  No tiene sentido desmontar la instalación de la ventana acoplable, ya que se puede instalar en muchos sistemas operativos.  Solo le indicaré que puede descargarlo para su plataforma desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker Store</a> .  Si instala Docker en Windows, la virtualización debe estar habilitada en el BIOS y el sistema operativo.  Puede leer sobre cómo habilitarlo en 10-ke en el siguiente artículo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instalación de Hyper-V en Windows10</a> </p><br><h2>  Crear un proyecto habilitado para Docker </h2><br><p> Docker es, por supuesto, un producto Linux, pero si es necesario, puede usarlo cuando desarrolle para Mac o Windows.  Al crear un proyecto en Visual Studio, para agregar compatibilidad con Docker, simplemente seleccione la casilla de verificación Habilitar compatibilidad con Docker. </p><br><p>  El soporte de Docker se puede agregar a un proyecto existente.  Se agrega al proyecto de la misma manera que se agregan varios componentes nuevos.  Menú contextual Agregar - Soporte Docker. </p><br><p>  Si Docker está instalado y ejecutándose en su máquina, la consola se abrirá automáticamente y se ejecutará el comando </p><br><pre><code class="lua hljs">docker pull microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre> <br><p>  que inicia el proceso de descarga de la imagen.  Esta imagen es en realidad un espacio en blanco sobre la base de la cual se creará su imagen.  ASP.NET Core 2.1 usa una imagen diferente - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">microsoft / dotnet: sdk</a> </p><br><p>  Los siguientes archivos se crearán automáticamente en el directorio con la solución para usted: <br>  .dockerignore (excluyendo archivos y directorios de la imagen del docker), docker-compose.yml (usando este archivo puede configurar la ejecución de varios servicios), docker-compose.override.yml (configuración auxiliar docker-compose), docker-compose.dcproj ( archivo de proyecto para Visual Studio). </p><br><p>  Se creará un archivo Dockerfile en el directorio del proyecto.  En realidad, con la ayuda de este archivo creamos nuestra imagen.  De manera predeterminada (en caso de que el proyecto se llame DockerServiceDemo), puede verse así: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo/DockerServiceDemo.csproj DockerServiceDemo/ RUN dotnet restore DockerServiceDemo/DockerServiceDemo.csproj COPY . . WORKDIR /src/DockerServiceDemo RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  La configuración inicial para .NET Core 2.0 no le permitirá compilar la imagen de forma inmediata utilizando el comando de construcción docker.  Está configurado para iniciar el archivo docker-compose desde un directorio de un nivel superior.  Para que la construcción continúe con éxito, el Dockerfile puede tener un aspecto similar: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo.csproj DockerServiceDemo.csproj RUN dotnet restore DockerServiceDemo.csproj COPY . . WORKDIR /src RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  Todo lo que hice fue eliminar el directorio adicional DockerServiceDemo. </p><br><p>  Si usa Visual Studio Code, deberá generar los archivos manualmente.  Aunque VS Code tiene una funcionalidad auxiliar en forma de una extensión <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregaré</a> un enlace al manual sobre cómo trabajar con la ventana acoplable desde VS Code - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajar con Docker</a> .  Sí, el artículo está en inglés, pero con imágenes. </p><br><h2>  Docker de tres acordes </h2><br><p>  Para el trabajo diario con la ventana acoplable, solo unos pocos comandos son suficientes para recordar. </p><br><p>  El equipo más importante es, por supuesto, construir una imagen.  Para hacer esto, debe usar bash / CMD / PowerShell para ir al directorio donde se encuentra el Dockerfile y ejecutar el comando: </p><br><pre> <code class="python hljs">docker build -t your_image_name .</code> </pre> <br><p>  Aquí, después de la opción -t, se establece el nombre de su imagen.  Atención: al final del comando, un espacio después del espacio  Este punto significa que se está utilizando el directorio actual.  Una imagen se puede etiquetar con una etiqueta (número o nombre).  Para hacer esto, coloque dos puntos después del nombre y especifique una etiqueta.  Si no se especifica la etiqueta, de forma predeterminada se establecerá con el nombre más reciente.  Para enviar una imagen al repositorio, es necesario que el nombre de la imagen incluya el nombre del repositorio.  Algo como esto: </p><br><pre> <code class="python hljs">docker build -t docker_account_name/image_name:your_tag .</code> </pre> <br><p>  Aquí your_docker_account_name es el nombre de su cuenta de Docker Hub. </p><br><p>  Si creó la imagen solo con un nombre local que no incluye el repositorio, puede marcar la imagen con un nombre diferente después de la construcción utilizando el siguiente comando: </p><br><pre> <code class="python hljs">docker tag image_name docker_account_name/image_name:your_tag</code> </pre> <br><p>  Para enviar cambios al concentrador, ahora debe ejecutar el siguiente comando: </p><br><pre> <code class="python hljs">docker push docker_account_name/image_name:your_tag</code> </pre> <br><p>  Antes de esto, debe iniciar sesión en su cuenta de Docker.  En Windows, esto se hace desde la interfaz de usuario de la aplicación, pero en * nix esto se hace mediante el comando: </p><br><pre> <code class="python hljs">docker login</code> </pre> <br><p>  De hecho, tres equipos no son suficientes.  También debe poder verificar el funcionamiento del contenedor.  El comando con el que puede iniciar el contenedor se ve así: </p><br><pre> <code class="python hljs">docker run -it -p <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> image_name</code> </pre> <br><p>  La opción -it creará un pseudo-TTY y su contenedor responderá a las solicitudes.  Después de ejecutar el comando, el servicio estará disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 5000 /</a> </p><br><p>  -p 5000: 80 asocia el puerto 5000 del contenedor con el puerto 80 del host. </p><br><p>  Además, hay tales comandos: </p><br><pre> <code class="python hljs">docker ps –a</code> </pre> <br><p>  Mostrarle una lista de contenedores.  Como se ha agregado el modificador -a, se mostrarán todos los contenedores, no solo los que se están ejecutando actualmente. </p><br><pre> <code class="python hljs">docker rm container_name</code> </pre> <br><p>  Este comando eliminará el contenedor llamado container_name.  rm - abreviatura de eliminar </p><br><pre> <code class="python hljs">docker logs container_name</code> </pre> <br><p>  Mostrar registros de contenedores </p><br><pre> <code class="python hljs">docker rmi image_name</code> </pre> <br><p>  Elimina una imagen llamada image_name </p><br><h2>  Lanzar un contenedor a través de un servidor proxy inverso </h2><br><p>  El hecho es que las aplicaciones .NET Core utilizan su servidor web Kestrel.  Este servidor no se recomienda para producción.  Por qué  Hay varias explicaciones. <br>  Si hay varias aplicaciones que comparten IP y puerto, Kestrel no podrá distribuir el tráfico.  Además, el servidor proxy inverso proporciona una capa adicional de seguridad, simplifica el equilibrio de carga y la configuración de SSL, y también se integra mejor en la infraestructura existente.  Para la mayoría de los desarrolladores, la razón más importante para la necesidad de servidores proxy inversos es la seguridad adicional. </p><br><p>  Primero, restaure la configuración original de Dockerfile.  Después de eso, trataremos con el archivo docker-compose.yml e intentaremos ejecutar nuestro servicio solo.  El formato de archivo yml se lee como “yaml” y es una abreviatura de “Yet Another Markup Language” o de “YAML Ain't Markup Language”.  Ya sea otro lenguaje de marcado o ningún lenguaje de marcado.  De alguna manera, todo no es seguro. </p><br><p>  Mi archivo docker-compose predeterminado se ve así: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile</code> </pre> <br><p>  El archivo docker-compose.override.yml agrega varias configuraciones a la configuración: <br>  versión: '3.4' </p><br><pre> <code class="python hljs">services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development ports: - <span class="hljs-string"><span class="hljs-string">"80"</span></span></code> </pre> <br><p>  Podemos construir la solución creada usando docker-compose build, llamando al comando docker-compose up, lanzaremos nuestro contenedor.  ¿Funciona todo?  Luego ve al siguiente paso.  Cree el archivo nginx.info.  La configuración será aproximadamente la siguiente: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">80</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">80</span></span>; location / { proxy_pass http://app_servers; proxy_http_version <span class="hljs-number"><span class="hljs-number">1.1</span></span>; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  Aquí indicamos que nginx escuchará en el puerto 80 (listen 80;).  Y las solicitudes recibidas serán redirigidas al puerto 80 del host en el contenedor dockerservicedemo.  Además, le decimos a nginx qué encabezados transmitir. </p><br><p>  Podemos usar http en nginx y acceder al sitio web a través de https.  Cuando una solicitud https pasa por un proxy http, no se pasa mucha información de https a http.  Además, cuando se usa un proxy, se pierde la dirección IP externa.  Para que esta información se transmita en los encabezados, debe cambiar el código de nuestro proyecto ASP.NET y agregar el siguiente código al comienzo del método Configure del archivo Startup.cs: </p><br><pre> <code class="python hljs"> app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto });</code> </pre> <br><p>  La mayoría de los servidores proxy usan los encabezados X-Fordered-For y X-Fordered-Proto.  Son estos encabezados los que se especifican ahora en la configuración de nginx. </p><br><p>  Ahora incluya la imagen nginx y el archivo nginx.conf en la configuración doker-compose.  La precaución en los espacios YAML es importante: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile ports: - <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf ports: - <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span></code> </pre> <br><p>  Aquí agregamos proxies a nuestra configuración como una imagen nginx.  Adjuntamos a esta imagen un archivo de configuración externo.  Lo montamos en el sistema de archivos del contenedor utilizando un mecanismo llamado volumen.  Si agrega al final: ro, entonces el objeto se montará de solo lectura. </p><br><p>  El proxy escucha el puerto 80 externo de la máquina en la que se está ejecutando el contenedor y envía una solicitud al puerto 80 interno del contenedor. </p><br><p>  Al ejecutar el comando doker-compose up, completaremos, es decir, extraeremos la imagen nginx del repositorio e iniciaremos nuestro contenedor junto con el contenedor proxy.  Ahora en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 80 /</a> será accesible a través de nginx.  En el puerto 5000, la aplicación "gira" también bajo Kestrel. </p><br><p>  Podemos verificar que la solicitud a la aplicación web pase por el proxy inverso.  Abra las herramientas de desarrollador en el navegador Chrome y vaya a la pestaña Red.  Haga clic en localhost aquí y seleccione la pestaña Encabezados. </p><br><p><img src="https://habrastorage.org/webt/zx/xi/sp/zxxisp6hjwtbza8u5wlmgu54jqq.png"></p><br><h2>  Lanzamos el contenedor a través de proxies y HTTPS </h2><br><p>  ASP.NET Core 2.1 trajo consigo mejoras en el soporte HTTPS. <br>  Digamos que el siguiente middleware le permite redirigir desde una conexión no segura a una segura: </p><br><pre> <code class="python hljs">app.UseHttpsRedirection();</code> </pre> <br><p>  Y el siguiente le permite utilizar el Protocolo de seguridad de transporte estricto HTTP: HSTS. </p><br><pre> <code class="python hljs">app.UseHsts();</code> </pre> <br><p>  HSTS es una característica del protocolo HTTP / 2, cuya especificación se lanzó en 2015.  Esta funcionalidad es compatible con los navegadores modernos e informa que el sitio web usa solo https.  Por lo tanto, se produce protección contra un ataque de degradación durante el cual el atacante puede aprovechar la situación mediante el uso de la transición a un protocolo http inseguro.  Por ejemplo, degradar TLS o incluso reemplazar un certificado. </p><br><p>  Por lo general, este tipo de ataque se usa junto con ataques de hombre en el medio.  Debe saber y recordar que HSTS no lo salva de una situación en la que un usuario visita el sitio utilizando el protocolo http y luego lo redirige a https.  Existe la llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lista de precarga de Chrome</a> , que contiene enlaces a sitios que admiten https.  Otros navegadores (Firefox, Opera, Safari, Edge) también admiten listas de sitios https creados en base a la lista de Chrome.  Pero todas estas listas están lejos de todos los sitios. </p><br><p>  La primera vez que ejecute una aplicación Core en Windows, recibirá un mensaje que indica que se ha creado e instalado un certificado de desarrollador.  Al hacer clic en el botón e instalar el certificado, lo hará confiable.  Desde la línea de comandos en macOS, puede agregar confianza al certificado con el comando: <br>  dotnet dev-certs https –trust </p><br><p>  Si la utilidad dev-certs no está instalada, puede instalarla con el comando: </p><br><pre> <code class="python hljs">dotnet tool install --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> dotnet-dev-certs</code> </pre> <br><p>  Cómo agregar un certificado de confianza en Linux depende de la distribución. <br>  Para fines de prueba, utilizamos el certificado del desarrollador.  Las acciones con un certificado firmado por CA son similares.  Si lo desea, puede usar certificados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LetsEncrypt</a> gratuitos </p><br><p>  Puede exportar el certificado de desarrollador a un archivo con el comando </p><br><pre> <code class="python hljs">dotnet dev-certs https -ep ___.pfx</code> </pre> <br><p>  El archivo debe copiarse en el directorio% APPDATA% / ASP.NET / Https / en Windows o en /root/.aspnet/https/ en macOS / Linux. </p><br><p>  Para que el contenedor tome la ruta al certificado y su contraseña, cree secretos de usuario con los siguientes contenidos: </p><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"Kestrel"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Certificates"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Default"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/root/.aspnet/https/__.pfx"</span></span>, <span class="hljs-string"><span class="hljs-string">"Password"</span></span>: <span class="hljs-string"><span class="hljs-string">"___"</span></span> } } } }</code> </pre> <br><p>  Este archivo almacena datos sin cifrar y, por lo tanto, solo se usa durante el desarrollo.  Se crea un archivo en Visual Studio llamando al menú contextual en el icono del proyecto o utilizando la utilidad de secretos de usuario en Linux. </p><br><p>  En Windows, el archivo se guardará en el directorio% APPDATA% \ Microsoft \ UserSecrets \ &lt;user_secrets_id&gt; \ secrets.json, y en macOS y Linux se guardará en ~ / .microsoft / usersecrets / &lt;user_secrets_id&gt; /secrets.json </p><br><p>  Para guardar la configuración para producción, algunas distribuciones de Linux pueden usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">systemd. La</a> configuración se guarda bajo el atributo Servicio.  Por ejemplo, así: </p><br><pre> <code class="python hljs">[Service] Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Path=/root/.aspnet/https/__.pfx"</span></span> Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Password=___"</span></span></code> </pre> <br><p>  A continuación, daré y analizaré de inmediato la versión de trabajo de la configuración del acoplador para el proxy y el contenedor a través de https. </p><br><p>  Archivo Docker-compose: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo21: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile  override: version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=https://+:<span class="hljs-number"><span class="hljs-number">44392</span></span>;http://+:<span class="hljs-number"><span class="hljs-number">80</span></span> - ASPNETCORE_HTTPS_PORT=<span class="hljs-number"><span class="hljs-number">44392</span></span> ports: - <span class="hljs-string"><span class="hljs-string">"59404:80"</span></span> - <span class="hljs-string"><span class="hljs-string">"44392:44392"</span></span> volumes: - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf - ./DockerServiceDemo/cert.crt:/etc/nginx/cert.crt - ./DockerServiceDemo/cert.rsa:/etc/nginx/cert.rsa ports: - <span class="hljs-string"><span class="hljs-string">"5001:44392"</span></span></code> </pre> <br><p>  Ahora describiré momentos incomprensibles.  ASPNETCORE_URLS nos permite no indicar en el código de la aplicación usando app.UseUrl el puerto en el que la aplicación está escuchando. </p><br><p>  ASPNETCORE_HTTPS_PORT realiza una redirección similar a la que haría el siguiente código: <br>  services.AddHttpsRedirection (opciones =&gt; opciones.HttpsPort = 44392) </p><br><p>  Es decir, el tráfico de las solicitudes http se redirigirá a un puerto específico de solicitudes https. <br>  Al usar los puertos, se indica que la solicitud del puerto externo 59404 se redirigirá al contenedor 80 y del puerto externo 44392 al 44392.  Teóricamente, dado que hemos configurado un servidor proxy inverso, podemos eliminar puertos con estos redireccionamientos. <br>  Usando volúmenes, un directorio con un certificado pfx y una aplicación UserSecrets se montan con una contraseña y un enlace al certificado. </p><br><p>  La sección de proxy indica que las solicitudes del puerto externo 5001 se redirigirán al puerto nginx 44392.  Además, se monta un archivo de configuración nginx, así como un certificado y una clave de certificado. </p><br><p>  Para que puedan crear un solo certificado pfx (que ya tenemos) para crear archivos crt y rsa, puede usar OpenSSL.  Primero necesitas extraer el certificado: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -clcerts -nokeys -out domain.crt</code> </pre> <br><p>  Y luego la clave privada: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -nocerts -nodes -out domain.rsa</code> </pre> <br><p>  La configuración de nginx es la siguiente: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">44392</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">44392</span></span> ssl; ssl_certificate /etc/nginx/cert.crt; ssl_certificate_key /etc/nginx/cert.rsa; location / { proxy_pass https://app_servers; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  El servidor proxy está escuchando en el puerto 44392.  Este puerto recibe solicitudes del puerto de host 5001.  A continuación, el proxy redirige las solicitudes al puerto 44392 del contenedor dockerdemoservice. </p><br><p>  Una vez que haya entendido estos ejemplos, obtendrá buenos antecedentes para trabajar con Docker, microservicios y nginx. </p><br><p>  Le recordamos que esta es la versión completa de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo de la revista Hacker</a> .  Su autor es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexey Sommer</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435914/">https://habr.com/ru/post/es435914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435904/index.html">AI tradujo la actividad cerebral al habla</a></li>
<li><a href="../es435906/index.html">Marcapasos Cluster Storage + DRBD (Dual primario) + ctdb</a></li>
<li><a href="../es435908/index.html">Web ascética: prototipo de mercados de pulgas en go and js</a></li>
<li><a href="../es435910/index.html">¿Por qué BSD perdió la batalla con GNU / Linux?</a></li>
<li><a href="../es435912/index.html">Los principales problemas del desarrollo de interfaces modernas.</a></li>
<li><a href="../es435916/index.html">Hackear VK, la autenticación de dos factores no guardará</a></li>
<li><a href="../es435920/index.html">Developer Cookbook: DDD Recipes (Part 4, Structures)</a></li>
<li><a href="../es435922/index.html">Java, Spring, Kurento y servicios de medios. Parte 2</a></li>
<li><a href="../es435924/index.html">La red neuronal genera imágenes de platos según recetas para su preparación.</a></li>
<li><a href="../es435926/index.html">La red neuronal recoge fragmentos de hallazgos arqueológicos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>