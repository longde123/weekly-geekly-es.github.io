<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé™ üßúüèø ü¶Ç JavaScript-Handbuch Teil 8: √úbersicht √ºber die ES6-Funktionen ‚òùüèæ ü•® üà∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute, im achten Teil der √úbersetzung des JavaScript-Handbuchs, werden wir die Funktionen der Sprache √ºberpr√ºfen, die nach der Ver√∂ffentlichung des ES...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Handbuch Teil 8: √úbersicht √ºber die ES6-Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431074/">  Heute, im achten Teil der √úbersetzung des JavaScript-Handbuchs, werden wir die Funktionen der Sprache √ºberpr√ºfen, die nach der Ver√∂ffentlichung des ES6-Standards darin enthalten war.  Auf die eine oder andere Weise sind wir schon fr√ºher auf viele dieser M√∂glichkeiten gesto√üen, irgendwo, wo wir uns n√§her damit befassen, irgendwo, wo es f√ºr selbstverst√§ndlich gehalten wird.  Dieser Abschnitt des Handbuchs soll zusammen mit der Offenlegung einiger Themen, die wir bisher nicht angesprochen haben, das Wissen eines unerfahrenen Entwicklers auf dem Gebiet des modernen JavaScript optimieren. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Erstes Programm, Sprachfunktionen, Standards</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Codestil und Programmstruktur</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Variablen, Datentypen, Ausdr√ºcke, Objekte</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Funktionen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: Arrays und Loops</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6: Ausnahmen, Semikolons, Platzhalterliterale</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7: Strict Mode, dieses Schl√ºsselwort, Ereignisse, Module, mathematische Berechnungen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 8: √úbersicht √ºber die ES6-Funktionen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 9: √úbersicht √ºber die ES7-, ES8- und ES9-Standards</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">√úber ES6</font> </h2><br>  Der ES6-Standard, der korrekter w√§re, ES2015 oder ECMAScript 2015 zu nennen (dies sind seine offiziellen Namen, obwohl jeder ihn ES6 nennt), erschien 4 Jahre nach der Ver√∂ffentlichung des vorherigen Standards - ES5.1.  Es dauerte ungef√§hr zehn Jahre, um alles zu entwickeln, was in den ES5.1-Standard ging.  Heutzutage ist alles, was in diesem Standard enthalten ist, zu den √ºblichen Werkzeugen des JS-Entwicklers geworden.  Es ist zu beachten, dass ES6 wesentliche √Ñnderungen an der Sprache vorgenommen hat (unter Beibehaltung der Abw√§rtskompatibilit√§t mit den vorherigen Versionen).  Um das Ausma√ü dieser √Ñnderungen einzusch√§tzen, kann angemerkt werden, dass die Gr√∂√üe des Dokuments, das den ES5-Standard beschreibt, ungef√§hr 250 Seiten betr√§gt, und dass der Standard ES6 in einem Dokument beschrieben wird, das bereits ungef√§hr 600 Seiten umfasst. <br><br>  Die Liste der wichtigsten Neuerungen des ES2015-Standards kann Folgendes umfassen: <br><br><ul><li>  Pfeilfunktionen </li><li>  Versprechen </li><li>  Generatoren </li><li> Schl√ºsselw√∂rter <code>let</code> und <code>const</code> </li><li>  Klassen </li><li>  Module </li><li>  Template Literal Support </li><li>  Unterst√ºtzung f√ºr Standardfunktionsparameter </li><li>  Spread-Operator </li><li>  Zerst√∂rerische Aufgabe </li><li>  Objektliterale verbessern </li><li>  <code>for...of</code> Schleife </li><li>  Unterst√ºtzung f√ºr <code>Map</code> and <code>Set</code> Datenstrukturen </li></ul><br>  Betrachten Sie diese M√∂glichkeiten. <br><br><h2>  <font color="#3AC1EF">Pfeilfunktionen</font> </h2><br>  Pfeilfunktionen haben das Erscheinungsbild von JavaScript-Code ge√§ndert.  In Bezug auf das Erscheinungsbild macht ihre Verwendung Funktionsdeklarationen k√ºrzer und einfacher.  Hier ist eine regul√§re Funktionsdeklaration. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Aber fast die gleiche (obwohl nicht ganz √§hnlich wie oben) Pfeilfunktion. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Wenn der Hauptteil der Pfeilfunktion nur aus einer Zeile besteht, deren Ergebnis von dieser Funktion zur√ºckgegeben werden muss, wird sie noch k√ºrzer geschrieben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething()</code> </pre> <br>  Wenn die Pfeilfunktion nur einen Parameter akzeptiert, k√∂nnen Sie ihn wie folgt schreiben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething(param)</code> </pre> <br>  Es sollte beachtet werden, dass mit dem Aufkommen von Pfeilfunktionen gew√∂hnliche Funktionen nicht verschwunden sind, sie weiterhin im Code verwendet werden k√∂nnen und auf die gleiche Weise wie zuvor funktionieren. <br><br><h2>  <font color="#3AC1EF">Dieses Schl√ºsselwort ist in Pfeilfunktionen enthalten</font> </h2><br>  Pfeilfunktionen haben <code>this</code> eigenen Wert nicht, sie erben ihn vom Ausf√ºhrungskontext. <br><br>  Dies behebt das Problem, f√ºr das bei Verwendung regul√§rer Funktionen Konstrukte wie <code>var that = this</code> , um den Kontext zu erhalten.  Wie in den vorherigen Teilen des Handbuchs gezeigt wurde, wirkt sich diese √Ñnderung jedoch ernsthaft auf die Funktionen der Arbeit mit Pfeilfunktionen und den Umfang ihrer Anwendung aus. <br><br><h2>  <font color="#3AC1EF">Versprechen</font> </h2><br>  Mit Versprechungen k√∂nnen Sie das bekannte Problem der ‚ÄûR√ºckrufh√∂lle‚Äú loswerden, obwohl ihre Verwendung die Verwendung ziemlich komplexer Strukturen impliziert.  Dieses Problem wurde im ES2017-Standard mit dem Aufkommen des <code>async/await</code> Konstrukts gel√∂st, das auf Versprechungen basiert. <br><br>  JavaScript-Entwickler verwendeten Versprechen vor dem ES2015-Standard und verwendeten daf√ºr verschiedene Bibliotheken (z. B. jQuery, q, deferred.js, vow).  Dies zeigt die Bedeutung und Relevanz dieses Mechanismus.  Verschiedene Bibliotheken implementieren es auf unterschiedliche Weise. Die Entstehung eines Standards in diesem Bereich kann als sehr positive Tatsache angesehen werden. <br>  Hier ist Code, der mit R√ºckruffunktionen (R√ºckrufen) geschrieben wurde. <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Mit Versprechungen kann dies wie folgt umgeschrieben werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) wait().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait() }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Generatoren</font> </h2><br>  Generatoren sind spezielle Funktionen, die ihre eigene Ausf√ºhrung anhalten und fortsetzen k√∂nnen.  Dadurch kann ein anderer Code ausgef√ºhrt werden, w√§hrend der Generator inaktiv ist. <br><br>  Der Generator entscheidet von selbst, dass er pausieren und zulassen muss, dass ein anderer Code, der darauf wartet, dass er an die Reihe kommt, ausgef√ºhrt wird.  Gleichzeitig hat der Generator die M√∂glichkeit, seine Ausf√ºhrung fortzusetzen, nachdem der Vorgang, auf dessen Ergebnisse er wartet, abgeschlossen ist. <br><br>  All dies geschieht dank einer einzigen einfachen Keyword- <code>yield</code> .  Wenn dieses Schl√ºsselwort im Generator gefunden wird, wird seine Ausf√ºhrung angehalten. <br>  Ein Generator kann viele Zeilen mit diesem Schl√ºsselwort enthalten und seine eigene Ausf√ºhrung mehrmals anhalten.  Generatoren werden mit dem Konstrukt <code>*function</code> deklariert.  Dieses Sternchen vor der Wortfunktion sollte nicht f√ºr einen Zeiger-Dereferenzierungsoperator verwendet werden, der in Sprachen wie C, C ++ oder Go verwendet wird. <br><br>  Generatoren markieren das Aufkommen eines neuen JavaScript-Programmierparadigmas.  Insbesondere erm√∂glichen sie den bidirektionalen Datenaustausch zwischen dem Generator und anderem Code und erm√∂glichen die Erstellung langlebiger <code>while</code> Schleifen, die das Programm nicht ‚Äûh√§ngen‚Äú lassen. <br><br>  Betrachten Sie ein Beispiel, das die Funktionsweise von Generatoren veranschaulicht.  Hier ist der Generator selbst. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doubleThat = <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (input / <span class="hljs-number"><span class="hljs-number">2</span></span>))   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> another = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (doubleThat)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (input * doubleThat * another) }</code> </pre> <br>  Mit diesem Befehl initialisieren wir es. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calc = calculator(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br>  Dann wenden wir uns seinem Iterator zu. <br><br><pre> <code class="javascript hljs">calc.next()</code> </pre> <br>  Dieser Befehl startet einen Iterator und gibt ein solches Objekt zur√ºck. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br>  Hier passiert folgendes.  Der Code f√ºhrt eine Funktion unter Verwendung des <code>input</code> , der an den Generatorkonstruktor √ºbergeben wird.  Der Generatorcode wird ausgef√ºhrt, bis das Schl√ºsselwort <code>yield</code> darin gefunden wird.  Zu diesem Zeitpunkt wird das Ergebnis der Division der <code>input</code> durch <code>2</code> , was, da die <code>input</code> <code>10</code> , die Zahl <code>5</code> ergibt.  Wir erhalten diese Nummer dank des Iterators und zusammen mit diesem Hinweis, dass der Generator noch nicht abgeschlossen ist (die Eigenschaft <code>done</code> in dem vom Iterator zur√ºckgegebenen Objekt ist auf <code>false</code> ), dh die Funktion wurde nur angehalten. <br>  Beim n√§chsten Aufruf des Iterators √ºbergeben wir die Nummer <code>7</code> an den Generator. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br>  Als Antwort darauf gibt der Iterator das n√§chste Objekt an uns zur√ºck. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">14</span></span> }</code> </pre> <br>  Hier wurde die Zahl <code>7</code> verwendet, um den <code>doubleThat</code> Wert zu berechnen. <br><br>  Auf den ersten Blick scheint der <code>input / 2</code> Code so etwas wie ein Argument f√ºr eine Funktion zu sein, aber dies ist nur der Wert, der bei der ersten Iteration zur√ºckgegeben wird.  Hier √ºberspringen wir diesen Wert und verwenden den neuen Eingabewert <code>7</code> , indem wir ihn mit <code>2</code> multiplizieren.  Danach gelangen wir zum zweiten <code>yield</code> Schl√ºsselwort. Infolgedessen betr√§gt der in der zweiten Iteration erhaltene Wert <code>14</code> . <br><br>  Bei der n√§chsten Iteration, der letzten, √ºbergeben wir die Nummer <code>100</code> an den Generator. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  Als Antwort erhalten wir das folgende Objekt. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> value: <span class="hljs-number"><span class="hljs-number">14000</span></span> }</code> </pre> <br>  Die Iteration ist abgeschlossen (das Schl√ºsselwort <code>yield</code> wird im Generator nicht mehr gefunden), das Ergebnis der Auswertung des Ausdrucks <code>(input * doubleThat * another)</code> im Objekt zur√ºckgegeben, <code>(input * doubleThat * another)</code> - <code>10 * 14 * 100</code> und ein Hinweis auf die Fertigstellung des Iterators ( <code>done: true</code> ). <br><br><h2>  <font color="#3AC1EF">Schl√ºsselw√∂rter let und const</font> </h2><br>  JavaScript hat immer das Schl√ºsselwort <code>var</code> , um Variablen zu deklarieren.  Solche Variablen haben einen Funktionsumfang.  Mit <code>let</code> Schl√ºsselw√∂rtern <code>let</code> und <code>const</code> k√∂nnen Sie Variablen und Konstanten deklarieren, die einen Blockbereich haben. <br><br>  Dies bedeutet, dass beispielsweise eine Variable, die mit dem Schl√ºsselwort <code>let</code> in einer Schleife, in einem <code>if</code> Block oder in einem durch geschweifte Klammern begrenzten regul√§ren Codeblock deklariert wurde, diesen Block nicht √ºberschreitet.  Mit <code>var</code> deklarierte Variablen werden nicht in solchen Bl√∂cken gespeichert und werden in der Funktion verf√ºgbar, auf deren Ebene sie deklariert werden. <br><br>  Das <code>const</code> Schl√ºsselwort funktioniert genauso wie <code>let</code> , aber damit werden unver√§nderliche Konstanten deklariert. <br><br>  Im modernen JS-Code wird das Schl√ºsselwort <code>var</code> selten verwendet.  Es gab Platz f√ºr die Schl√ºsselw√∂rter <code>let</code> und <code>const</code> .  Gleichzeitig wird das Schl√ºsselwort <code>const</code> , was ungew√∂hnlich erscheinen mag, heute sehr h√§ufig verwendet, was auf die Popularit√§t der Ideen der Immunit√§t von Entit√§ten in der modernen Programmierung hinweist. <br><br><h2>  <font color="#3AC1EF">Klassen</font> </h2><br>  Es stellte sich heraus, dass JavaScript die einzige extrem verbreitete Sprache war, die das Prototyp-Vererbungsmodell verwendete.  Programmierer, die von Sprachen, die den klassenbasierten Vererbungsmechanismus implementieren, zu JS wechseln, f√ºhlten sich in einer solchen Umgebung unwohl.  Mit dem ES2015-Standard wurde die Klassenunterst√ºtzung in JavaScript eingef√ºhrt.  Dies ist im Wesentlichen ‚Äûsyntaktischer Zucker‚Äú um JS-interne Mechanismen unter Verwendung von Prototypen.  Dies wirkt sich jedoch darauf aus, wie genau JS-Anwendungen schreiben. <br><br>  JavaScript-Vererbungsmechanismen sehen jetzt wie √§hnliche Mechanismen in anderen objektorientierten Sprachen aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name } hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, I am '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name + <span class="hljs-string"><span class="hljs-string">'.'</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.hello() + <span class="hljs-string"><span class="hljs-string">' I am an actor.'</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomCruise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Actor(<span class="hljs-string"><span class="hljs-string">'Tom Cruise'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(tomCruise.hello())</code> </pre> <br>  Dieses Programm zeigt den Text <code>Hello, I am Tom Cruise. I am an actor</code> an der Konsole an <code>Hello, I am Tom Cruise. I am an actor</code>  <code>Hello, I am Tom Cruise. I am an actor</code> . <br>  In JS-Klassen k√∂nnen Instanzvariablen nicht deklariert werden, sie m√ºssen in den Konstruktoren initialisiert werden. <br><br><h3>  <font color="#3AC1EF"> Klassenkonstruktor</font> </h3><br>  Klassen haben eine spezielle Methode, den <code>constructor</code> , der aufgerufen wird, wenn eine Instanz der Klasse mit dem <code>new</code> Schl√ºsselwort erstellt wird. <br><br><h3>  <font color="#3AC1EF">‚ñç Stichwort super</font> </h3><br>  Mit dem Schl√ºsselwort <code>super</code> k√∂nnen Sie von untergeordneten Klassen auf die √ºbergeordnete Klasse zugreifen. <br><br><h3>  <font color="#3AC1EF">‚ñç Getter und Setter</font> </h3><br>  Der Getter f√ºr eine Eigenschaft kann wie folgt festgelegt werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ get fullName() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.firstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.lastName}</span></span></span><span class="hljs-string">`</span></span> } }</code> </pre> <br>  Der Setter kann wie unten gezeigt beschrieben werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ set age(years) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.theAge = years } }</code> </pre> <br>  Sie arbeiten mit Gettern und Setzern, als w√§ren sie keine Funktionen, sondern gew√∂hnliche Eigenschaften von Objekten. <br><br><h2>  <font color="#3AC1EF">Module</font> </h2><br>  Vor dem ES2015-Standard gab es mehrere konkurrierende Ans√§tze f√ºr die Arbeit mit Modulen.  Insbesondere sprechen wir √ºber RequireJS- und CommonJS-Technologien.  Diese Situation f√ºhrte zu Meinungsverschiedenheiten in der Community der JS-Entwickler. <br><br>  Dank der Standardisierung der Module in ES2015 normalisiert sich die Situation heutzutage allm√§hlich. <br><br><h3>  <font color="#3AC1EF">‚ñç Module importieren</font> </h3><br>  Module werden mit einem Konstrukt des Formularimports <code>import...from...</code>  Hier sind einige Beispiele. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { React, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyLibrary <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Export von Modulen</font> </h3><br>  Die internen Mechanismen des Moduls sind von au√üen geschlossen, aber aus dem Modul k√∂nnen Sie alles exportieren, was es anderen Modulen bieten kann.  Dies erfolgt mit dem Schl√ºsselwort <code>export</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Vorlagenliterale</font> </h3><br>  Vorlagenliterale sind eine neue Methode zur Beschreibung von Zeichenfolgen in JavaScript.  So sieht es aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aString = <span class="hljs-string"><span class="hljs-string">`A string`</span></span></code> </pre> <br>  Durch die Verwendung der Syntax von Vorlagenliteralen k√∂nnen Sie au√üerdem Ausdr√ºcke in Zeichenfolgen einbetten und diese interpolieren.  Dies erfolgt mit einer Konstruktion der Form <code>${a_variable}</code> .  Hier ist ein einfaches Beispiel f√ºr seine Verwendung: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">//something test</span></span></code> </pre> <br>  Hier ist ein komplizierteres Beispiel, das die F√§higkeit veranschaulicht, Ausdr√ºcke auszuwerten und ihre Ergebnisse durch eine Zeichenfolge zu ersetzen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str2 = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${foo() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span></code> </pre> <br>  Dank der Verwendung von Vorlagenliteralen ist es viel einfacher geworden, mehrzeilige Zeichenfolgen zu deklarieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str3 = <span class="hljs-string"><span class="hljs-string">`Hey this string is awesome!`</span></span></code> </pre> <br>  Vergleichen Sie dies mit dem, was Sie tun mussten, um mehrzeilige Zeichenfolgen zu beschreiben, wenn Sie die Funktionen verwenden, die in der Sprache vor ES2015 verf√ºgbar waren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">'One\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Two\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Three'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Standardfunktionsparameter</font> </h2><br>  Jetzt unterst√ºtzen Funktionen die standardm√§√üig verwendeten Parameter - f√ºr den Fall, dass die entsprechenden Argumente beim Aufrufen von Funktionen nicht an sie √ºbergeben werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, testing = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } foo()</code> </pre> <br><h2>  <font color="#3AC1EF">Spread-Operator</font> </h2><br>  Mit dem Spread-Operator (Erweiterungsoperator) k√∂nnen Sie Arrays, Objekte oder Zeichenfolgen erweitern.  Dieser Operator sieht aus wie drei Punkte ( <code>...</code> ).  Betrachten Sie es zun√§chst mit einem Array-Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br>  So erstellen Sie ein neues Array basierend auf diesem Array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [...a, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]</code> </pre> <br>  So erstellen Sie eine Kopie des Arrays. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = [...a]</code> </pre> <br>  Dieser Operator arbeitet auch mit Objekten.  Hier erfahren Sie beispielsweise, wie Sie damit ein Objekt klonen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newObj = { ...oldObj }</code> </pre> <br>  Wenn Sie den Spread-Operator auf eine Zeichenfolge anwenden, k√∂nnen Sie ihn in ein Array konvertieren, dessen jedes Element ein Zeichen aus dieser Zeichenfolge enth√§lt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayized = [...hey] <span class="hljs-comment"><span class="hljs-comment">// ['h', 'e', 'y']</span></span></code> </pre> <br>  Dieser Operator ist zus√§tzlich zu den oben genannten Varianten seiner Anwendung praktisch, wenn Funktionen aufgerufen werden, die eine normale Liste von Argumenten erwarten, und ihnen ein Array mit diesen Argumenten √ºbergeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) =&gt;</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] f(...a)</code> </pre> <br>  Fr√ºher wurde dies mit einer Konstruktion der Form <code>f.apply(null, a)</code> , aber ein solcher Code ist schwieriger zu schreiben und weniger lesbar. <br><br><h2>  <font color="#3AC1EF">Zerst√∂rerische Aufgabe</font> </h2><br>  Die Destrukturierungszuweisungstechnik erm√∂glicht es beispielsweise, ein Objekt zu nehmen, einige Werte daraus zu extrahieren und sie in benannte Variablen oder Konstanten zu setzen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">'Cruise'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actor</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">54</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: name, age} = person</code> </pre> <br>  Hier werden die Eigenschaften <code>firstName</code> und <code>age</code> aus dem Objekt abgerufen.  Die <code>age</code> Eigenschaft wird in die mit demselben Namen deklarierte Konstante geschrieben, und die <code>firstName</code> Eigenschaft f√§llt nach der Extraktion in den Konstantennamen. <br><br>  Die destruktive Zuordnung eignet sich auch f√ºr die Arbeit mit Arrays. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, , , fifth] = a</code> </pre> <br>  Die <code>first</code> , <code>second</code> und <code>fifth</code> Konstante erhalten das erste, zweite und f√ºnfte Element des Arrays. <br><br><h2>  <font color="#3AC1EF">Objektliterale verbessern</font> </h2><br>  ES2015 hat die M√∂glichkeit zur Beschreibung von Objekten mithilfe von Objektliteralen erheblich erweitert. <br><br><h3>  <font color="#3AC1EF">‚ñç Vereinfachung der Einbeziehung von Variablen in Objekte</font> </h3><br>  Bisher war es erforderlich, die folgende Konstruktion zu verwenden, um einer Eigenschaft eines Objekts eine Variable zuzuweisen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">something</span></span>: something }</code> </pre> <br>  Jetzt kann das Gleiche so gemacht werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { something }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Prototypen</font> </h3><br>  Der Prototyp des Objekts kann nun mithilfe der folgenden Konstruktion festgelegt werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Stichwort super</font> </h3><br>  Mit dem Schl√ºsselwort <code>super</code> k√∂nnen Objekte auf Prototypobjekte zugreifen.  Zum Beispiel, um ihre Methoden aufzurufen, die dieselben Namen wie die Methoden dieser Objekte selbst haben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'zoo'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject, test() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.test() + <span class="hljs-string"><span class="hljs-string">'x'</span></span> } } x.test() <span class="hljs-comment"><span class="hljs-comment">//zoox</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Berechnete Eigenschaftsnamen</font> </h3><br>  Berechnete Eigenschaftsnamen werden in der Phase der Objekterstellung gebildet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { [<span class="hljs-string"><span class="hljs-string">'a'</span></span> + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + <span class="hljs-string"><span class="hljs-string">'b'</span></span>]: <span class="hljs-string"><span class="hljs-string">'z'</span></span> } x.a_b <span class="hljs-comment"><span class="hljs-comment">//z</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">F√ºr ... der Schleife</font> </h2><br>  Im Jahr 2009 wurden im ES5-Standard <code>forEach()</code> -Schleifen angezeigt.  Dies ist ein n√ºtzliches Design, dessen Nachteil die Tatsache ist, dass solche Zyklen sehr unpraktisch zu unterbrechen sind.  Der Klassiker <code>for</code> Schleife in Situationen, in denen Sie die Ausf√ºhrung der Schleife vor ihrem normalen Abschluss unterbrechen m√ºssen, ist eine viel geeignetere Wahl. <br><br>  In ES2015 ist ein <code>for...of</code> Zyklus erschienen, der sich einerseits durch seine pr√§gnante Syntax und Bequemlichkeit f√ºr jeden auszeichnet und andererseits die M√∂glichkeit eines vorzeitigen Austritts aus dem Zyklus unterst√ºtzt. <br><br>  Hier sind einige Beispiele <code>for...of</code> Schleifen. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    for (const v of ['a', 'b', 'c']) { console.log(v); } //           entries() for (const [i, v] of ['a', 'b', 'c'].entries()) { console.log(i, v); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Datenstrukturen zuordnen und festlegen</font> </h2><br>  ES2015 f√ºhrte Map- und <code>Set</code> Datenstrukturen ein (sowie deren ‚Äûschwache‚Äú Versionen <code>WeakMap</code> und <code>WeakSet</code> , deren Verwendung die Leistung des ‚ÄûGarbage Collector‚Äú verbessert - des Mechanismus, der f√ºr die Speicherverwaltung in JS-Engines verantwortlich ist).  Dies sind sehr beliebte Datenstrukturen, die vor dem Erscheinen ihrer offiziellen Implementierung mit den verf√ºgbaren Sprachwerkzeugen nachgeahmt werden mussten. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir die Funktionen des ES2015-Standards √ºberpr√ºft, die den aktuellen Status der Sprache stark beeinflusst haben.  Unser n√§chstes Thema werden Funktionen der Standards ES2016, ES2017 und ES2018 sein. <br><br>  <b>Liebe Leser!</b>  Welche Neuerungen des ES6-Standards finden Sie am n√ºtzlichsten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431074/">https://habr.com/ru/post/de431074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431064/index.html">Rigid Programmer Manifesto</a></li>
<li><a href="../de431066/index.html">DEFCON 16. Wie kann ich dich erreichen? Lassen Sie mich die Wege auflisten. Teil 2</a></li>
<li><a href="../de431068/index.html">Die Kunst der Bildung: die Ideologie der Spielautomaten</a></li>
<li><a href="../de431070/index.html">Hara essen? Wir sprechen √ºber die Essgewohnheiten eines modernen IT-Spezialisten</a></li>
<li><a href="../de431072/index.html">JavaScript-Handbuch Teil 7: Strenger Modus, dieses Schl√ºsselwort, Ereignisse, Module, Mathematik</a></li>
<li><a href="../de431076/index.html">Die beliebtesten Node.js-Frameworks von 2018</a></li>
<li><a href="../de431078/index.html">JavaScript-Anleitung zur Fehlerbehandlung</a></li>
<li><a href="../de431080/index.html">So organisieren Sie Remote-B√ºros und verlieren kein Team im Weltraum</a></li>
<li><a href="../de431082/index.html">Kotlin: auf der Suche nach Marketingleiter</a></li>
<li><a href="../de431084/index.html">In jeder unverst√§ndlichen Situation - schreiben Sie Skripte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>