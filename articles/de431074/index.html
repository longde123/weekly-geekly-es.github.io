<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎪 🧜🏿 🦂 JavaScript-Handbuch Teil 8: Übersicht über die ES6-Funktionen ☝🏾 🥨 🈷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute, im achten Teil der Übersetzung des JavaScript-Handbuchs, werden wir die Funktionen der Sprache überprüfen, die nach der Veröffentlichung des ES...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Handbuch Teil 8: Übersicht über die ES6-Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431074/">  Heute, im achten Teil der Übersetzung des JavaScript-Handbuchs, werden wir die Funktionen der Sprache überprüfen, die nach der Veröffentlichung des ES6-Standards darin enthalten war.  Auf die eine oder andere Weise sind wir schon früher auf viele dieser Möglichkeiten gestoßen, irgendwo, wo wir uns näher damit befassen, irgendwo, wo es für selbstverständlich gehalten wird.  Dieser Abschnitt des Handbuchs soll zusammen mit der Offenlegung einiger Themen, die wir bisher nicht angesprochen haben, das Wissen eines unerfahrenen Entwicklers auf dem Gebiet des modernen JavaScript optimieren. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Erstes Programm, Sprachfunktionen, Standards</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Codestil und Programmstruktur</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Variablen, Datentypen, Ausdrücke, Objekte</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Funktionen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: Arrays und Loops</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6: Ausnahmen, Semikolons, Platzhalterliterale</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7: Strict Mode, dieses Schlüsselwort, Ereignisse, Module, mathematische Berechnungen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 8: Übersicht über die ES6-Funktionen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 9: Übersicht über die ES7-, ES8- und ES9-Standards</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Über ES6</font> </h2><br>  Der ES6-Standard, der korrekter wäre, ES2015 oder ECMAScript 2015 zu nennen (dies sind seine offiziellen Namen, obwohl jeder ihn ES6 nennt), erschien 4 Jahre nach der Veröffentlichung des vorherigen Standards - ES5.1.  Es dauerte ungefähr zehn Jahre, um alles zu entwickeln, was in den ES5.1-Standard ging.  Heutzutage ist alles, was in diesem Standard enthalten ist, zu den üblichen Werkzeugen des JS-Entwicklers geworden.  Es ist zu beachten, dass ES6 wesentliche Änderungen an der Sprache vorgenommen hat (unter Beibehaltung der Abwärtskompatibilität mit den vorherigen Versionen).  Um das Ausmaß dieser Änderungen einzuschätzen, kann angemerkt werden, dass die Größe des Dokuments, das den ES5-Standard beschreibt, ungefähr 250 Seiten beträgt, und dass der Standard ES6 in einem Dokument beschrieben wird, das bereits ungefähr 600 Seiten umfasst. <br><br>  Die Liste der wichtigsten Neuerungen des ES2015-Standards kann Folgendes umfassen: <br><br><ul><li>  Pfeilfunktionen </li><li>  Versprechen </li><li>  Generatoren </li><li> Schlüsselwörter <code>let</code> und <code>const</code> </li><li>  Klassen </li><li>  Module </li><li>  Template Literal Support </li><li>  Unterstützung für Standardfunktionsparameter </li><li>  Spread-Operator </li><li>  Zerstörerische Aufgabe </li><li>  Objektliterale verbessern </li><li>  <code>for...of</code> Schleife </li><li>  Unterstützung für <code>Map</code> and <code>Set</code> Datenstrukturen </li></ul><br>  Betrachten Sie diese Möglichkeiten. <br><br><h2>  <font color="#3AC1EF">Pfeilfunktionen</font> </h2><br>  Pfeilfunktionen haben das Erscheinungsbild von JavaScript-Code geändert.  In Bezug auf das Erscheinungsbild macht ihre Verwendung Funktionsdeklarationen kürzer und einfacher.  Hier ist eine reguläre Funktionsdeklaration. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Aber fast die gleiche (obwohl nicht ganz ähnlich wie oben) Pfeilfunktion. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Wenn der Hauptteil der Pfeilfunktion nur aus einer Zeile besteht, deren Ergebnis von dieser Funktion zurückgegeben werden muss, wird sie noch kürzer geschrieben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething()</code> </pre> <br>  Wenn die Pfeilfunktion nur einen Parameter akzeptiert, können Sie ihn wie folgt schreiben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething(param)</code> </pre> <br>  Es sollte beachtet werden, dass mit dem Aufkommen von Pfeilfunktionen gewöhnliche Funktionen nicht verschwunden sind, sie weiterhin im Code verwendet werden können und auf die gleiche Weise wie zuvor funktionieren. <br><br><h2>  <font color="#3AC1EF">Dieses Schlüsselwort ist in Pfeilfunktionen enthalten</font> </h2><br>  Pfeilfunktionen haben <code>this</code> eigenen Wert nicht, sie erben ihn vom Ausführungskontext. <br><br>  Dies behebt das Problem, für das bei Verwendung regulärer Funktionen Konstrukte wie <code>var that = this</code> , um den Kontext zu erhalten.  Wie in den vorherigen Teilen des Handbuchs gezeigt wurde, wirkt sich diese Änderung jedoch ernsthaft auf die Funktionen der Arbeit mit Pfeilfunktionen und den Umfang ihrer Anwendung aus. <br><br><h2>  <font color="#3AC1EF">Versprechen</font> </h2><br>  Mit Versprechungen können Sie das bekannte Problem der „Rückrufhölle“ loswerden, obwohl ihre Verwendung die Verwendung ziemlich komplexer Strukturen impliziert.  Dieses Problem wurde im ES2017-Standard mit dem Aufkommen des <code>async/await</code> Konstrukts gelöst, das auf Versprechungen basiert. <br><br>  JavaScript-Entwickler verwendeten Versprechen vor dem ES2015-Standard und verwendeten dafür verschiedene Bibliotheken (z. B. jQuery, q, deferred.js, vow).  Dies zeigt die Bedeutung und Relevanz dieses Mechanismus.  Verschiedene Bibliotheken implementieren es auf unterschiedliche Weise. Die Entstehung eines Standards in diesem Bereich kann als sehr positive Tatsache angesehen werden. <br>  Hier ist Code, der mit Rückruffunktionen (Rückrufen) geschrieben wurde. <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Mit Versprechungen kann dies wie folgt umgeschrieben werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) wait().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait() }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Generatoren</font> </h2><br>  Generatoren sind spezielle Funktionen, die ihre eigene Ausführung anhalten und fortsetzen können.  Dadurch kann ein anderer Code ausgeführt werden, während der Generator inaktiv ist. <br><br>  Der Generator entscheidet von selbst, dass er pausieren und zulassen muss, dass ein anderer Code, der darauf wartet, dass er an die Reihe kommt, ausgeführt wird.  Gleichzeitig hat der Generator die Möglichkeit, seine Ausführung fortzusetzen, nachdem der Vorgang, auf dessen Ergebnisse er wartet, abgeschlossen ist. <br><br>  All dies geschieht dank einer einzigen einfachen Keyword- <code>yield</code> .  Wenn dieses Schlüsselwort im Generator gefunden wird, wird seine Ausführung angehalten. <br>  Ein Generator kann viele Zeilen mit diesem Schlüsselwort enthalten und seine eigene Ausführung mehrmals anhalten.  Generatoren werden mit dem Konstrukt <code>*function</code> deklariert.  Dieses Sternchen vor der Wortfunktion sollte nicht für einen Zeiger-Dereferenzierungsoperator verwendet werden, der in Sprachen wie C, C ++ oder Go verwendet wird. <br><br>  Generatoren markieren das Aufkommen eines neuen JavaScript-Programmierparadigmas.  Insbesondere ermöglichen sie den bidirektionalen Datenaustausch zwischen dem Generator und anderem Code und ermöglichen die Erstellung langlebiger <code>while</code> Schleifen, die das Programm nicht „hängen“ lassen. <br><br>  Betrachten Sie ein Beispiel, das die Funktionsweise von Generatoren veranschaulicht.  Hier ist der Generator selbst. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doubleThat = <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (input / <span class="hljs-number"><span class="hljs-number">2</span></span>))   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> another = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (doubleThat)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (input * doubleThat * another) }</code> </pre> <br>  Mit diesem Befehl initialisieren wir es. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calc = calculator(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br>  Dann wenden wir uns seinem Iterator zu. <br><br><pre> <code class="javascript hljs">calc.next()</code> </pre> <br>  Dieser Befehl startet einen Iterator und gibt ein solches Objekt zurück. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br>  Hier passiert folgendes.  Der Code führt eine Funktion unter Verwendung des <code>input</code> , der an den Generatorkonstruktor übergeben wird.  Der Generatorcode wird ausgeführt, bis das Schlüsselwort <code>yield</code> darin gefunden wird.  Zu diesem Zeitpunkt wird das Ergebnis der Division der <code>input</code> durch <code>2</code> , was, da die <code>input</code> <code>10</code> , die Zahl <code>5</code> ergibt.  Wir erhalten diese Nummer dank des Iterators und zusammen mit diesem Hinweis, dass der Generator noch nicht abgeschlossen ist (die Eigenschaft <code>done</code> in dem vom Iterator zurückgegebenen Objekt ist auf <code>false</code> ), dh die Funktion wurde nur angehalten. <br>  Beim nächsten Aufruf des Iterators übergeben wir die Nummer <code>7</code> an den Generator. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br>  Als Antwort darauf gibt der Iterator das nächste Objekt an uns zurück. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">14</span></span> }</code> </pre> <br>  Hier wurde die Zahl <code>7</code> verwendet, um den <code>doubleThat</code> Wert zu berechnen. <br><br>  Auf den ersten Blick scheint der <code>input / 2</code> Code so etwas wie ein Argument für eine Funktion zu sein, aber dies ist nur der Wert, der bei der ersten Iteration zurückgegeben wird.  Hier überspringen wir diesen Wert und verwenden den neuen Eingabewert <code>7</code> , indem wir ihn mit <code>2</code> multiplizieren.  Danach gelangen wir zum zweiten <code>yield</code> Schlüsselwort. Infolgedessen beträgt der in der zweiten Iteration erhaltene Wert <code>14</code> . <br><br>  Bei der nächsten Iteration, der letzten, übergeben wir die Nummer <code>100</code> an den Generator. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  Als Antwort erhalten wir das folgende Objekt. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> value: <span class="hljs-number"><span class="hljs-number">14000</span></span> }</code> </pre> <br>  Die Iteration ist abgeschlossen (das Schlüsselwort <code>yield</code> wird im Generator nicht mehr gefunden), das Ergebnis der Auswertung des Ausdrucks <code>(input * doubleThat * another)</code> im Objekt zurückgegeben, <code>(input * doubleThat * another)</code> - <code>10 * 14 * 100</code> und ein Hinweis auf die Fertigstellung des Iterators ( <code>done: true</code> ). <br><br><h2>  <font color="#3AC1EF">Schlüsselwörter let und const</font> </h2><br>  JavaScript hat immer das Schlüsselwort <code>var</code> , um Variablen zu deklarieren.  Solche Variablen haben einen Funktionsumfang.  Mit <code>let</code> Schlüsselwörtern <code>let</code> und <code>const</code> können Sie Variablen und Konstanten deklarieren, die einen Blockbereich haben. <br><br>  Dies bedeutet, dass beispielsweise eine Variable, die mit dem Schlüsselwort <code>let</code> in einer Schleife, in einem <code>if</code> Block oder in einem durch geschweifte Klammern begrenzten regulären Codeblock deklariert wurde, diesen Block nicht überschreitet.  Mit <code>var</code> deklarierte Variablen werden nicht in solchen Blöcken gespeichert und werden in der Funktion verfügbar, auf deren Ebene sie deklariert werden. <br><br>  Das <code>const</code> Schlüsselwort funktioniert genauso wie <code>let</code> , aber damit werden unveränderliche Konstanten deklariert. <br><br>  Im modernen JS-Code wird das Schlüsselwort <code>var</code> selten verwendet.  Es gab Platz für die Schlüsselwörter <code>let</code> und <code>const</code> .  Gleichzeitig wird das Schlüsselwort <code>const</code> , was ungewöhnlich erscheinen mag, heute sehr häufig verwendet, was auf die Popularität der Ideen der Immunität von Entitäten in der modernen Programmierung hinweist. <br><br><h2>  <font color="#3AC1EF">Klassen</font> </h2><br>  Es stellte sich heraus, dass JavaScript die einzige extrem verbreitete Sprache war, die das Prototyp-Vererbungsmodell verwendete.  Programmierer, die von Sprachen, die den klassenbasierten Vererbungsmechanismus implementieren, zu JS wechseln, fühlten sich in einer solchen Umgebung unwohl.  Mit dem ES2015-Standard wurde die Klassenunterstützung in JavaScript eingeführt.  Dies ist im Wesentlichen „syntaktischer Zucker“ um JS-interne Mechanismen unter Verwendung von Prototypen.  Dies wirkt sich jedoch darauf aus, wie genau JS-Anwendungen schreiben. <br><br>  JavaScript-Vererbungsmechanismen sehen jetzt wie ähnliche Mechanismen in anderen objektorientierten Sprachen aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name } hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, I am '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name + <span class="hljs-string"><span class="hljs-string">'.'</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.hello() + <span class="hljs-string"><span class="hljs-string">' I am an actor.'</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomCruise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Actor(<span class="hljs-string"><span class="hljs-string">'Tom Cruise'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(tomCruise.hello())</code> </pre> <br>  Dieses Programm zeigt den Text <code>Hello, I am Tom Cruise. I am an actor</code> an der Konsole an <code>Hello, I am Tom Cruise. I am an actor</code>  <code>Hello, I am Tom Cruise. I am an actor</code> . <br>  In JS-Klassen können Instanzvariablen nicht deklariert werden, sie müssen in den Konstruktoren initialisiert werden. <br><br><h3>  <font color="#3AC1EF"> Klassenkonstruktor</font> </h3><br>  Klassen haben eine spezielle Methode, den <code>constructor</code> , der aufgerufen wird, wenn eine Instanz der Klasse mit dem <code>new</code> Schlüsselwort erstellt wird. <br><br><h3>  <font color="#3AC1EF">▍ Stichwort super</font> </h3><br>  Mit dem Schlüsselwort <code>super</code> können Sie von untergeordneten Klassen auf die übergeordnete Klasse zugreifen. <br><br><h3>  <font color="#3AC1EF">▍ Getter und Setter</font> </h3><br>  Der Getter für eine Eigenschaft kann wie folgt festgelegt werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ get fullName() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.firstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.lastName}</span></span></span><span class="hljs-string">`</span></span> } }</code> </pre> <br>  Der Setter kann wie unten gezeigt beschrieben werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ set age(years) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.theAge = years } }</code> </pre> <br>  Sie arbeiten mit Gettern und Setzern, als wären sie keine Funktionen, sondern gewöhnliche Eigenschaften von Objekten. <br><br><h2>  <font color="#3AC1EF">Module</font> </h2><br>  Vor dem ES2015-Standard gab es mehrere konkurrierende Ansätze für die Arbeit mit Modulen.  Insbesondere sprechen wir über RequireJS- und CommonJS-Technologien.  Diese Situation führte zu Meinungsverschiedenheiten in der Community der JS-Entwickler. <br><br>  Dank der Standardisierung der Module in ES2015 normalisiert sich die Situation heutzutage allmählich. <br><br><h3>  <font color="#3AC1EF">▍ Module importieren</font> </h3><br>  Module werden mit einem Konstrukt des Formularimports <code>import...from...</code>  Hier sind einige Beispiele. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { React, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyLibrary <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Export von Modulen</font> </h3><br>  Die internen Mechanismen des Moduls sind von außen geschlossen, aber aus dem Modul können Sie alles exportieren, was es anderen Modulen bieten kann.  Dies erfolgt mit dem Schlüsselwort <code>export</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Vorlagenliterale</font> </h3><br>  Vorlagenliterale sind eine neue Methode zur Beschreibung von Zeichenfolgen in JavaScript.  So sieht es aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aString = <span class="hljs-string"><span class="hljs-string">`A string`</span></span></code> </pre> <br>  Durch die Verwendung der Syntax von Vorlagenliteralen können Sie außerdem Ausdrücke in Zeichenfolgen einbetten und diese interpolieren.  Dies erfolgt mit einer Konstruktion der Form <code>${a_variable}</code> .  Hier ist ein einfaches Beispiel für seine Verwendung: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">//something test</span></span></code> </pre> <br>  Hier ist ein komplizierteres Beispiel, das die Fähigkeit veranschaulicht, Ausdrücke auszuwerten und ihre Ergebnisse durch eine Zeichenfolge zu ersetzen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str2 = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${foo() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span></code> </pre> <br>  Dank der Verwendung von Vorlagenliteralen ist es viel einfacher geworden, mehrzeilige Zeichenfolgen zu deklarieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str3 = <span class="hljs-string"><span class="hljs-string">`Hey this string is awesome!`</span></span></code> </pre> <br>  Vergleichen Sie dies mit dem, was Sie tun mussten, um mehrzeilige Zeichenfolgen zu beschreiben, wenn Sie die Funktionen verwenden, die in der Sprache vor ES2015 verfügbar waren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">'One\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Two\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Three'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Standardfunktionsparameter</font> </h2><br>  Jetzt unterstützen Funktionen die standardmäßig verwendeten Parameter - für den Fall, dass die entsprechenden Argumente beim Aufrufen von Funktionen nicht an sie übergeben werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, testing = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } foo()</code> </pre> <br><h2>  <font color="#3AC1EF">Spread-Operator</font> </h2><br>  Mit dem Spread-Operator (Erweiterungsoperator) können Sie Arrays, Objekte oder Zeichenfolgen erweitern.  Dieser Operator sieht aus wie drei Punkte ( <code>...</code> ).  Betrachten Sie es zunächst mit einem Array-Beispiel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br>  So erstellen Sie ein neues Array basierend auf diesem Array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [...a, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]</code> </pre> <br>  So erstellen Sie eine Kopie des Arrays. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = [...a]</code> </pre> <br>  Dieser Operator arbeitet auch mit Objekten.  Hier erfahren Sie beispielsweise, wie Sie damit ein Objekt klonen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newObj = { ...oldObj }</code> </pre> <br>  Wenn Sie den Spread-Operator auf eine Zeichenfolge anwenden, können Sie ihn in ein Array konvertieren, dessen jedes Element ein Zeichen aus dieser Zeichenfolge enthält. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayized = [...hey] <span class="hljs-comment"><span class="hljs-comment">// ['h', 'e', 'y']</span></span></code> </pre> <br>  Dieser Operator ist zusätzlich zu den oben genannten Varianten seiner Anwendung praktisch, wenn Funktionen aufgerufen werden, die eine normale Liste von Argumenten erwarten, und ihnen ein Array mit diesen Argumenten übergeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) =&gt;</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] f(...a)</code> </pre> <br>  Früher wurde dies mit einer Konstruktion der Form <code>f.apply(null, a)</code> , aber ein solcher Code ist schwieriger zu schreiben und weniger lesbar. <br><br><h2>  <font color="#3AC1EF">Zerstörerische Aufgabe</font> </h2><br>  Die Destrukturierungszuweisungstechnik ermöglicht es beispielsweise, ein Objekt zu nehmen, einige Werte daraus zu extrahieren und sie in benannte Variablen oder Konstanten zu setzen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">'Cruise'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actor</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">54</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: name, age} = person</code> </pre> <br>  Hier werden die Eigenschaften <code>firstName</code> und <code>age</code> aus dem Objekt abgerufen.  Die <code>age</code> Eigenschaft wird in die mit demselben Namen deklarierte Konstante geschrieben, und die <code>firstName</code> Eigenschaft fällt nach der Extraktion in den Konstantennamen. <br><br>  Die destruktive Zuordnung eignet sich auch für die Arbeit mit Arrays. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, , , fifth] = a</code> </pre> <br>  Die <code>first</code> , <code>second</code> und <code>fifth</code> Konstante erhalten das erste, zweite und fünfte Element des Arrays. <br><br><h2>  <font color="#3AC1EF">Objektliterale verbessern</font> </h2><br>  ES2015 hat die Möglichkeit zur Beschreibung von Objekten mithilfe von Objektliteralen erheblich erweitert. <br><br><h3>  <font color="#3AC1EF">▍ Vereinfachung der Einbeziehung von Variablen in Objekte</font> </h3><br>  Bisher war es erforderlich, die folgende Konstruktion zu verwenden, um einer Eigenschaft eines Objekts eine Variable zuzuweisen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">something</span></span>: something }</code> </pre> <br>  Jetzt kann das Gleiche so gemacht werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { something }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Prototypen</font> </h3><br>  Der Prototyp des Objekts kann nun mithilfe der folgenden Konstruktion festgelegt werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject }</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Stichwort super</font> </h3><br>  Mit dem Schlüsselwort <code>super</code> können Objekte auf Prototypobjekte zugreifen.  Zum Beispiel, um ihre Methoden aufzurufen, die dieselben Namen wie die Methoden dieser Objekte selbst haben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'zoo'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject, test() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.test() + <span class="hljs-string"><span class="hljs-string">'x'</span></span> } } x.test() <span class="hljs-comment"><span class="hljs-comment">//zoox</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Berechnete Eigenschaftsnamen</font> </h3><br>  Berechnete Eigenschaftsnamen werden in der Phase der Objekterstellung gebildet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { [<span class="hljs-string"><span class="hljs-string">'a'</span></span> + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + <span class="hljs-string"><span class="hljs-string">'b'</span></span>]: <span class="hljs-string"><span class="hljs-string">'z'</span></span> } x.a_b <span class="hljs-comment"><span class="hljs-comment">//z</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Für ... der Schleife</font> </h2><br>  Im Jahr 2009 wurden im ES5-Standard <code>forEach()</code> -Schleifen angezeigt.  Dies ist ein nützliches Design, dessen Nachteil die Tatsache ist, dass solche Zyklen sehr unpraktisch zu unterbrechen sind.  Der Klassiker <code>for</code> Schleife in Situationen, in denen Sie die Ausführung der Schleife vor ihrem normalen Abschluss unterbrechen müssen, ist eine viel geeignetere Wahl. <br><br>  In ES2015 ist ein <code>for...of</code> Zyklus erschienen, der sich einerseits durch seine prägnante Syntax und Bequemlichkeit für jeden auszeichnet und andererseits die Möglichkeit eines vorzeitigen Austritts aus dem Zyklus unterstützt. <br><br>  Hier sind einige Beispiele <code>for...of</code> Schleifen. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    for (const v of ['a', 'b', 'c']) { console.log(v); } //           entries() for (const [i, v] of ['a', 'b', 'c'].entries()) { console.log(i, v); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Datenstrukturen zuordnen und festlegen</font> </h2><br>  ES2015 führte Map- und <code>Set</code> Datenstrukturen ein (sowie deren „schwache“ Versionen <code>WeakMap</code> und <code>WeakSet</code> , deren Verwendung die Leistung des „Garbage Collector“ verbessert - des Mechanismus, der für die Speicherverwaltung in JS-Engines verantwortlich ist).  Dies sind sehr beliebte Datenstrukturen, die vor dem Erscheinen ihrer offiziellen Implementierung mit den verfügbaren Sprachwerkzeugen nachgeahmt werden mussten. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir die Funktionen des ES2015-Standards überprüft, die den aktuellen Status der Sprache stark beeinflusst haben.  Unser nächstes Thema werden Funktionen der Standards ES2016, ES2017 und ES2018 sein. <br><br>  <b>Liebe Leser!</b>  Welche Neuerungen des ES6-Standards finden Sie am nützlichsten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431074/">https://habr.com/ru/post/de431074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431064/index.html">Rigid Programmer Manifesto</a></li>
<li><a href="../de431066/index.html">DEFCON 16. Wie kann ich dich erreichen? Lassen Sie mich die Wege auflisten. Teil 2</a></li>
<li><a href="../de431068/index.html">Die Kunst der Bildung: die Ideologie der Spielautomaten</a></li>
<li><a href="../de431070/index.html">Hara essen? Wir sprechen über die Essgewohnheiten eines modernen IT-Spezialisten</a></li>
<li><a href="../de431072/index.html">JavaScript-Handbuch Teil 7: Strenger Modus, dieses Schlüsselwort, Ereignisse, Module, Mathematik</a></li>
<li><a href="../de431076/index.html">Die beliebtesten Node.js-Frameworks von 2018</a></li>
<li><a href="../de431078/index.html">JavaScript-Anleitung zur Fehlerbehandlung</a></li>
<li><a href="../de431080/index.html">So organisieren Sie Remote-Büros und verlieren kein Team im Weltraum</a></li>
<li><a href="../de431082/index.html">Kotlin: auf der Suche nach Marketingleiter</a></li>
<li><a href="../de431084/index.html">In jeder unverständlichen Situation - schreiben Sie Skripte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>