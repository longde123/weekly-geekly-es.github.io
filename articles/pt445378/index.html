<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòπ üéº üèñÔ∏è Labirintos: classifica√ß√£o, gera√ß√£o, busca de solu√ß√µes ü§¥üèø üë®üèΩ‚Äçüé® üëßüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este post cl√°ssico detalha as maneiras mais populares de criar e passar por labirintos. O artigo est√° dividido em quatro partes: classifica√ß√£o, algori...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Labirintos: classifica√ß√£o, gera√ß√£o, busca de solu√ß√µes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445378/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"></div><br>  <i>Este post cl√°ssico detalha as maneiras mais populares de criar e passar por labirintos.</i>  <i>O artigo est√° dividido em quatro partes: classifica√ß√£o, algoritmos de gera√ß√£o, algoritmos para resolver labirintos e outras opera√ß√µes com labirintos.</i> <br><br><h2>  Classifica√ß√£o do labirinto </h2><br>  Os labirintos como um todo (e, portanto, os algoritmos para cri√°-los) podem ser divididos em sete classifica√ß√µes diferentes: dimens√£o, hiperdimens√£o, topologia, mosaico, roteamento, textura e prioridade.  O labirinto pode usar um elemento de cada classe em qualquer combina√ß√£o. <a name="habracut"></a><br>  <b>Dimens√£o:</b> a classe de dimens√£o determina essencialmente quantas dimens√µes no espa√ßo o labirinto preenche.  Os seguintes tipos est√£o dispon√≠veis: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Bidimensional</b> <b>: a</b> maioria dos labirintos, tanto em papel quanto em real, tem essa dimens√£o, ou seja, sempre podemos exibir o plano do labirinto em uma folha de papel e mov√™-lo sem cruzar outros corredores do labirinto. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>Tridimensional</b></a> <b>:</b> labirinto tridimensional tem v√°rios n√≠veis;  nele (pelo menos na vers√£o ortogonal), as passagens podem, al√©m das quatro dire√ß√µes cardeais, descer e subir.  Um labirinto 3D √© frequentemente visualizado como uma matriz de n√≠veis 2D com escadas para cima e para baixo. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/999/897/373/9998973734d2c66d06205a9ade0b501c.gif"><br><br>  <b>Dimens√µes mais altas</b> <b>:</b> voc√™ pode criar labirintos quadridimensionais e ainda mais multidimensionais.  √Äs vezes, eles s√£o visualizados como labirintos em 3D com "portais" que levam at√© a quarta dimens√£o, por exemplo, portais para o "passado" e o "futuro". </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br>  Entrela√ßamento <b>:</b> labirintos com entrela√ßamento - s√£o essencialmente labirintos bidimensionais (ou melhor, 2.5 dimensionais), nos quais, no entanto, as passagens podem se sobrepor.  Ao exibir, geralmente √© bastante √≥bvio onde est√£o os becos sem sa√≠da e como uma passagem est√° acima da outra.  Labirintos do mundo real, nos quais existem pontes conectando uma parte do labirinto com outra, s√£o parcialmente entrela√ßados. </li></ul><br>  <b>Hyperdimension: a</b> classifica√ß√£o de acordo com a hyperdimension corresponde √† dimens√£o de um objeto que se move atrav√©s de um labirinto, e n√£o ao pr√≥prio labirinto.  Os seguintes tipos est√£o dispon√≠veis: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>N√£o-hiperlabirintos</b> <b>:</b> quase todos os labirintos, mesmo aqueles criados em alta dimensionalidade ou com regras especiais, geralmente s√£o n√£o-hiperlabirintos.  Nelas, trabalhamos com um ponto ou um objeto pequeno, por exemplo, uma bola ou o pr√≥prio jogador, que se move de um ponto a outro, e a rota pavimentada forma uma linha.  Em cada ponto, h√° um n√∫mero de op√ß√µes facilmente cont√°vel. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hyperlabyrinths:</a></b> hyperlabyrinths s√£o labirintos nos quais o objeto que est√° sendo resolvido n√£o √© apenas um ponto.  Um hiperlabirinto padr√£o (ou hiperlabirinto de primeira ordem) consiste em uma linha que forma uma superf√≠cie ao se mover ao longo de um caminho.  O hiperlabirinto pode existir apenas em 3D ou em um meio com uma dimens√£o maior, e a entrada no hiperlabirinto geralmente n√£o √© um ponto, mas uma linha.  O Hyperlabyrinth √© fundamentalmente diferente, porque √© necess√°rio levar em considera√ß√£o e trabalhar simultaneamente com v√°rias partes da linha, e a qualquer momento existe um n√∫mero quase infinito de estados e op√ß√µes para o que pode ser feito com a linha.  A linha de solu√ß√£o √© infinita ou seus pontos de extremidade est√£o fora do hiperlabirinto para evitar que a linha seja compactada em um ponto, pois, neste caso, pode ser considerado um n√£o-hiperlabirinto. </li><li>  <b>Hiper-hiperlabirinto: os</b> hiperlabirintos podem ter uma dimens√£o arbitrariamente alta.  O hiper-hiper-labirinto (ou hiper-labirinto de segunda ordem) aumenta novamente a dimens√£o do objeto que est√° sendo resolvido.  Aqui, o objeto a ser resolvido √© um plano que, ao se mover pelo caminho, forma uma figura tridimensional.  O hiper-hiperlabirinto pode existir apenas em ambientes dimensionais 4D ou superiores. </li></ul><br>  <b>Topologia: a</b> classe de topologia descreve a geometria do espa√ßo do labirinto no qual ele existe como um todo.  Os seguintes tipos est√£o dispon√≠veis: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Normal</b> <b>:</b> Este √© o labirinto padr√£o no espa√ßo euclidiano. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br>  <b>Planair</b> <b>: O</b> termo "planair" descreve qualquer labirinto com uma topologia incomum.  Normalmente, isso significa que as bordas do labirinto est√£o conectadas de uma maneira interessante.  Exemplos: labirintos na superf√≠cie de um cubo, labirintos na superf√≠cie de uma faixa de Mobius e labirintos equivalentes aos de um toro onde os lados esquerdo e direito, superior e inferior est√£o conectados em pares. </li></ul><br>  <b>Tecelagem: uma</b> classifica√ß√£o da geometria das c√©lulas individuais que comp√µem o labirinto.  Tipos existentes: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ortogonal</b> <b>:</b> Esta √© uma grade retangular padr√£o na qual as c√©lulas t√™m passagens que se cruzam em √¢ngulos retos.  No contexto do mosaico, eles tamb√©m podem ser chamados de labirintos gama. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Delta</b> <b>: Os</b> labirintos Delta consistem em tri√¢ngulos conectados e cada c√©lula pode ter at√© tr√™s passagens conectadas a ela. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/650/dcd/b76/650dcdb76582619209847e3111cb0ad4.gif"><br><br>  <b>Sigma</b> <b>:</b> Os labirintos Sigma s√£o compostos de hex√°gonos conectados;  cada c√©lula pode ter at√© seis passagens. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/b12/0eb/9da/b120eb9da20a99a3985e76a644b4e740.gif"><br><br>  <b>Teta</b> <b>:</b> Os labirintos teta consistem em c√≠rculos conc√™ntricos de passagens nas quais o come√ßo ou o fim est√° no centro e o outro na borda externa.  As c√©lulas geralmente t√™m quatro caminhos de conex√£o poss√≠veis, mas pode haver mais devido ao maior n√∫mero de c√©lulas nos an√©is externos das passagens. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/283/751/2a5/2837512a58f5ad292e93b65a832e80fa.gif"><br><br>  <b>Epsilon</b> <b>: Os</b> labirintos Epsilon consistem em oct√≥gonos ou quadrados conectados, cada c√©lula neles pode ter at√© oito ou quatro passagens. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/bba/929/e12/bba929e1276ce4be65f121f20bf101c0.gif"><br><br>  <b>Zeta</b> <b>: O</b> labirinto zeta est√° localizado em uma grade retangular; somente al√©m das passagens horizontais e verticais, as passagens diagonais s√£o permitidas em um √¢ngulo de 45 graus. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>√îmega</b> <b>: o</b> termo √¥mega refere-se a quase todos os labirintos com mosaico n√£o ortogonal constante.  Os labirintos delta, sigma, teta e ipsilon s√£o desse tipo, como muitos outros esquemas em que voc√™ pode pensar, por exemplo, em um labirinto que consiste em pares de tri√¢ngulos ret√¢ngulos. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br>  <b>Rachadura</b> <b>: Um</b> labirinto de crack √© um labirinto amorfo sem mosaico constante, no qual paredes e passarelas est√£o localizadas em √¢ngulos aleat√≥rios. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/538/fe4/b6e/538fe4b6e758b139f1e9b1b258a5bc25.gif"><br><br>  <b>Fractal</b> <b>: Um</b> labirinto fractal √© um labirinto composto de labirintos menores.  Um labirinto fractal de c√©lulas aninhadas √© um labirinto em cada c√©lula da qual outros labirintos s√£o colocados, e esse processo pode ser repetido v√°rias vezes.  Um labirinto fractal infinitamente recursivo √© um verdadeiro fractal no qual o conte√∫do do labirinto se replica, criando um labirinto essencialmente infinitamente grande. </li></ul><br>  <b>Roteamento: a</b> classifica√ß√£o por roteamento √© provavelmente o aspecto mais interessante na gera√ß√£o de labirintos.  From est√° associado a tipos de passes dentro da geometria definida nas categorias descritas acima. <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> ‚Äúideal‚Äù √© um labirinto sem loops ou circuitos fechados e sem √°reas inacess√≠veis.  √â tamb√©m chamado de labirinto simplesmente conectado.  De cada ponto, h√° exatamente um caminho para qualquer outro ponto.  Labirinto tem apenas uma solu√ß√£o.  Do ponto de vista da programa√ß√£o, esse labirinto pode ser descrito como uma √°rvore, um conjunto de c√©lulas ou v√©rtices de conex√£o. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br>  <b>Tran√ßado</b> <b>:</b> Tran√ßado significa que n√£o h√° becos sem sa√≠da no labirinto.  √â tamb√©m chamado de labirinto de labirintos puramente multiplicado.  Nesse labirinto, s√£o usadas passagens que s√£o fechadas e retornam uma √† outra (da√≠ o nome ‚Äúvime‚Äù), fazendo com que passem mais tempo andando em c√≠rculos, em vez de chegar a becos sem sa√≠da.  Um labirinto tecido de qualidade pode ser muito mais complicado que um labirinto ideal do mesmo tamanho. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br>  <b>Via</b> √∫nica <b>(Unicursal)</b> <b>:</b> <b>rota</b> √∫nica significa um labirinto sem garfos.  O labirinto de m√£o √∫nica cont√©m uma passagem longa e sinuosa que muda de dire√ß√£o por todo o labirinto.  N√£o √© muito complicado, apenas se voc√™ n√£o voltar acidentalmente at√© a metade e n√£o voltar ao in√≠cio. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/add/a2c/cb6/adda2ccb6c09bd76428e17a395f8fd3e.gif"><br><br></b>  <b>Esparso: um</b> labirinto esparso n√£o passa por cada c√©lula, ou seja, alguns deles n√£o s√£o criados.  Isso implica a presen√ßa de √°reas inacess√≠veis, ou seja, de certa forma, √© o oposto do labirinto de vime.  Um conceito semelhante pode ser aplicado ao adicionar paredes, para que voc√™ possa obter um labirinto irregular com corredores e salas amplas. </li><li>  <b>Parcialmente vime: O</b> labirinto parcialmente vime √© um labirinto misto que possui loops e becos sem sa√≠da.  A palavra "vime" pode ser usada para avalia√ß√£o quantitativa, ou seja, um "labirinto com tecelagem forte" √© um labirinto com muitas voltas ou paredes removidas, e h√° apenas alguns no "labirinto com tecelagem fraca". </li></ul><br>  <b>Textura: a</b> classifica√ß√£o da <b>textura</b> descreve o estilo de passes com roteamento e geometria diferentes.  A textura n√£o √© apenas par√¢metros que podem ser ativados ou desativados.  Aqui est√£o alguns exemplos de vari√°veis: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/96d/730/eb5/96d730eb5f18e0c65786b410e5cb77cd.gif"><br><br>  <b>Vi√©s</b> <b>:</b> em um labirinto com passagens deslocadas, as passagens retas tendem a ir mais em uma dire√ß√£o do que em outras.  Por exemplo, em um labirinto com alto deslocamento horizontal, teremos longas passagens da esquerda para a direita e apenas pequenas passagens de cima para baixo conectando-as.  Esse labirinto √© geralmente mais dif√≠cil de passar "atrav√©s das fibras". </li><li><img src="https://habrastorage.org/getpro/habr/post_images/264/855/d73/264855d73cffcf3937c7497f8e021ae1.gif"><br><br>  <b>Sobrecarga</b> <b>: a</b> m√©trica <b>Sobrecarga</b> determina quanto tempo os corredores levar√£o antes que os turnos for√ßados apare√ßam.  Em um labirinto com um v√£o baixo, n√£o haver√° passagens retas com mais de tr√™s ou quatro c√©lulas e parecer√° muito aleat√≥rio.  Em um labirinto com um v√£o alto, o labirinto ter√° uma grande porcentagem de passes longos, o que far√° com que pare√ßa um microchip. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/923/8dd/bac/9238ddbac833a6b351ddbec6aef9eee0.gif"><br><br></b>  <b>Elitismo:</b> o indicador de ‚Äúelite‚Äù do labirinto determina o comprimento da solu√ß√£o em rela√ß√£o ao tamanho do labirinto.  Os labirintos de elite geralmente t√™m uma solu√ß√£o curta e direta, enquanto nos labirintos que n√£o s√£o de elite, a solu√ß√£o passa por grande parte da √°rea do labirinto.  Um labirinto de elite de alta qualidade pode ser muito mais complicado que um labirinto que n√£o √© de elite. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/471/8e1/c13/4718e1c13d43140bd41c40081eaf0b4c.gif"><br><br>  <b>Simetria</b> <b>: um</b> labirinto sim√©trico possui passagens sim√©tricas, por exemplo, na simetria de rota√ß√£o em rela√ß√£o ao centro ou refletida ao longo dos eixos horizontal ou vertical.  O labirinto pode ser parcial ou completamente sim√©trico e pode repetir o padr√£o v√°rias vezes. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br></b>  <b>Homogeneidade: um</b> algoritmo homog√™neo gera todos os labirintos poss√≠veis com igual probabilidade.  Um labirinto pode ser chamado com uma textura homog√™nea se parecer com um labirinto t√≠pico gerado por um algoritmo homog√™neo.  Teoricamente, um algoritmo heterog√™neo tamb√©m pode gerar todos os labirintos poss√≠veis em qualquer espa√ßo, mas n√£o com igual probabilidade.  A heterogeneidade pode ir ainda mais longe - pode haver labirintos que o algoritmo nunca gerar√°. </li><li>  <b>Fluxo do rio: A</b> caracter√≠stica "fluxo" significa que, ao criar um labirinto, o algoritmo procurar√° e limpar√° as c√©lulas (ou paredes) vizinhas √† atual, ou seja, fluir√° (da√≠ o termo "fluidez") para as partes ainda n√£o criadas do labirinto, como a √°gua.  Em um labirinto ideal com uma taxa de fluxo mais baixa, geralmente haver√° muitos becos sem sa√≠da curtos, e em um labirinto mais "fluido" haver√° menos becos sem sa√≠da, mas ser√£o mais longos. </li></ul><br>  <b>Prioridade:</b> esta classifica√ß√£o mostra que os processos de cria√ß√£o de labirintos podem ser divididos em dois tipos principais: adi√ß√£o de paredes e passagens de entalhe.  Geralmente, ao gerar isso, tudo se resume apenas √† diferen√ßa nos algoritmos, e n√£o √†s diferen√ßas vis√≠veis nos labirintos, mas ainda √© √∫til levar isso em considera√ß√£o.  O mesmo labirinto √© frequentemente gerado de ambos os modos: <br><br><ul><li>  <b>Adicionando paredes: os</b> algoritmos para os quais as paredes s√£o priorit√°rias come√ßam com uma √°rea vazia (ou borda externa), adicionando paredes no processo.  No mundo real, labirintos reais compostos por sebes, tetos ou paredes de madeira est√£o definitivamente adicionando paredes. </li><li>  <b>Corredores de corte: os</b> algoritmos cuja prioridade s√£o corredores come√ßam com um bloco s√≥lido e cortam passagens nele no processo.  No mundo real, esses labirintos s√£o t√∫neis de minas ou labirintos dentro de canos. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br></b>  <b>Predefini√ß√£o: √©</b> claro, os labirintos podem cortar passagens e adicionar paredes simultaneamente;  alguns algoritmos de computador fazem isso.  Um modelo de labirinto √© uma imagem gr√°fica que n√£o √© um labirinto, que no menor n√∫mero de etapas se transforma em um labirinto real, mas ainda mant√©m a textura do modelo gr√°fico original.  Estilos complexos de labirinto, como espirais que se cruzam, s√£o mais f√°ceis de implementar como padr√µes em um computador do que tentar criar o labirinto certo, preservando seu estilo. </li></ul><br>  <b>Outro: o</b> acima n√£o √© de forma alguma uma lista exaustiva de todas as classes ou elementos poss√≠veis dentro de cada classe.  Estes s√£o apenas os tipos de labirintos que eu mesmo criei.  Observe que quase todo tipo de labirinto, incluindo labirintos com regras especiais, pode ser expresso como um gr√°fico direcionado no qual haver√° um n√∫mero finito de estados e um n√∫mero finito de op√ß√µes em cada estado, e isso √© chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>equival√™ncia dos labirintos</b></a> .  Aqui est√£o algumas outras classifica√ß√µes e tipos de labirintos: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/d19/d0e/264/d19d0e264db5d3d8521fbe62037c1b07.gif"><br><br>  <b>Orienta√ß√£o</b> <b>:</b> em certas passagens, voc√™ s√≥ pode se mover em uma dire√ß√£o.  Do ponto de vista da programa√ß√£o, esse labirinto ser√° descrito por um gr√°fico direcionado, em contraste com um gr√°fico n√£o direcionado que descreve todos os outros tipos. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/43e/596/214/43e596214c1af1f52950a1223d111c3e.gif"><br><br>  <b>Segmenta√ß√£o</b> <b>: o</b> labirinto pode ter diferentes partes correspondentes a diferentes classes. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/099/aee/262/099aee262a4d50e33bb92ab5b82946c6.gif"><br><br></b>  <b>Labirintos de comprimento infinito:</b> podemos criar um labirinto infinitamente longo (um n√∫mero finito de colunas e qualquer n√∫mero de linhas), mas ao mesmo tempo armazenar apenas uma parte do labirinto na mem√≥ria, "rolando" de uma extremidade √† outra e destruindo as linhas anteriores ao criar a pr√≥xima.  Um exemplo √© uma vers√£o modificada do algoritmo Hunt and Kill.  Pode-se imaginar um labirinto potencialmente intermin√°vel na forma de um filme longo composto por quadros individuais.  Apenas dois quadros consecutivos s√£o armazenados na mem√≥ria por vez.  Vamos executar o algoritmo Hunt and Kill, embora ele crie um vi√©s que √© propenso ao quadro superior, ent√£o ele termina primeiro.  Ap√≥s a conclus√£o, o quadro n√£o √© mais necess√°rio, voc√™ pode imprimi-lo ou fazer outra coisa com ele.  Seja como for, descarte-o, torne o quadro inferior parcialmente criado um novo quadro superior e limpe o novo quadro inferior.  Repita o processo at√© decidirmos parar e aguarde at√© que Hunt And Kill complete os dois quadros.  A √∫nica limita√ß√£o √© que o labirinto nunca ter√° um caminho que se ramifica em dire√ß√£o √† entrada por um comprimento de mais de dois quadros.  A maneira mais f√°cil de criar um labirinto sem fim √© o algoritmo Eller ou Sidewinder, porque eles j√° criam labirintos uma linha de cada vez, para que voc√™ possa deix√°-los adicionar infinitamente linhas ao labirinto. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8e1/677/f0f/8e1677f0fc6dbdfb99739ed66ec8d534.png" alt="imagem"><br><br></b>  <b>Labirintos fractais</b> virtuais <b>:</b> virtual √© um labirinto no qual o labirinto inteiro n√£o √© armazenado na mem√≥ria ao mesmo tempo.  Por exemplo, ele pode armazenar apenas parte das passagens de 100x100 pr√≥ximas √† sua localiza√ß√£o em uma simula√ß√£o em que voc√™ caminha por um grande labirinto.  A extens√£o de labirintos fractal aninhados pode ser usada para criar enormes labirintos virtuais, por exemplo, um bilh√£o por bilh√£o de passes.  Se constru√≠ssemos uma c√≥pia real do labirinto de um bilh√£o por bilh√£o de passes (com uma dist√¢ncia de seis p√©s entre as passagens), ent√£o ela preencheria a superf√≠cie da Terra mais de 6.000 vezes!  Considere um labirinto de 10 <sup>9</sup> a 10 <sup>9</sup> passes, ou um labirinto fechado com apenas 9 n√≠veis.  Se quisermos ter pelo menos uma parte de 100x100 em torno de n√≥s, basta criar um n√≠vel labirinto inferior de 100x100 passes e sete labirintos 10x10 nos quais est√° incorporado, a fim de saber exatamente onde as paredes est√£o na parte 100x100.  (Na verdade, √© melhor ter quatro partes adjacentes de tamanho 100x100, formando um quadrado, caso voc√™ esteja pr√≥ximo da borda ou canto da pe√ßa, mas o mesmo conceito se aplica aqui.) Para garantir que o labirinto seja constante e inalterado ao mov√™-lo, temos uma f√≥rmula: definindo um n√∫mero de semente aleat√≥ria para cada coordenada em cada n√≠vel de aninhamento.  Os labirintos de fractal virtual s√£o semelhantes ao fractal de Mandelbrot, nas imagens em que ele existe virtualmente, e precisamos visitar uma determinada coordenada com uma amplia√ß√£o bastante alta.  para que apare√ßa. </li></ul><br><h2>  Algoritmos de labirinto </h2><br>  Aqui est√° uma lista de algoritmos generalizados para criar as v√°rias classes de labirintos descritas acima: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> para criar um labirinto ideal padr√£o, geralmente √© necess√°rio ‚Äúcultiv√°-lo‚Äù, garantindo a aus√™ncia de loops e √°reas isoladas.  Come√ßamos a partir da parede externa e adicionamos aleatoriamente um fragmento da parede que a toca.  Continuamos adicionando aleatoriamente segmentos de parede ao labirinto, mas certifique-se de que cada novo segmento toque em uma extremidade da parede existente e sua outra extremidade esteja na parte ainda n√£o criada do labirinto.  Se voc√™ adicionar um segmento de parede, cujas duas extremidades s√£o separadas do resto do labirinto, isso criar√° uma parede n√£o conectada com um la√ßo em volta e, se voc√™ adicionar um segmento, cujas extremidades tocam o labirinto, isso criar√° uma √°rea inacess√≠vel.  Este √© um m√©todo de adicionar paredes;  √© quase an√°logo ao recorte de passagens, em que partes das passagens s√£o cortadas, de modo que apenas uma extremidade toque a passagem existente. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br> <b></b> <b>:</b>               ,   ,          .      : (1)    , (2)       ,    ,          -¬´¬ª, (3)        ,   ,     , (4)        ,       ,      (3)   ,     ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br> <b></b> <b>:</b>        ‚Äî   ,  ,     ,    ,      .      U- ,      ,       ,       ,       .           .    ,           :          ,      ,       ,   .      ,             .     ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/ce1/9b2/36c/ce19b236c5dd3f766d0c817aeb551bdc.gif"><br><br> :</b>         ,     .              ,      ,     .  -       ,       ,            ,  ,    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>3D</b></a> <b>:</b>           ,     ,          ,      . -         . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br> <b></b> <b>:</b>           ,          ,               .             (        ):     ,      ,       ,         .           ,  .    ,   ;    ,     .           ,      ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br> <b>Crack</b> <b>:</b> Crack-         ,      ,     .  ,     ,     ,  ¬´¬ª        .   ,      ,    .  ,  -       . ,           ,             ;      .        ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br> <b></b> <b>:</b>     ¬´¬ª    ,           ,   . ,   -    : (1)  ,           . (2)     ,      ,    ,         ,    ,      (..      ). (3)     ,  ,     .            ,            . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7d0/844/5f9/7d08445f9ee145b6db8b844d70f9d21c.gif"><br><br> <b></b> <b>:</b>  ‚Äî  3D-,       -,      ,  .   3D-       ,       ,    .           ,             ,         .         ,         .         ,     (   ),          ,          ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br> <b>Planair</b> <b>:</b> Planair-               ,         .     ‚Äî       .      ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br> :</b> ,   , ,    -,      ,    ,     ,   .     ,     . ,   ,         ,    ,    ,          . </li></ul><br><h2>     </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem muitas maneiras de criar labirintos perfeitos, e cada uma delas tem suas pr√≥prias caracter√≠sticas. </font><font style="vertical-align: inherit;">Abaixo est√° uma lista de algoritmos espec√≠ficos. </font><font style="vertical-align: inherit;">Todos eles descrevem a cria√ß√£o de um labirinto cortando passagens, no entanto, a menos que seja indicado o contr√°rio, cada um tamb√©m pode ser implementado adicionando paredes:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/128/314/7ba/1283147bad2733851cdba5fb965b7530.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backtracker recursivo </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>   -      recursive backtracker,   ,       .       ,       ,       .  ,      ,     .        ,      .  ,       .         ,  ,   ,        .      ,       . Recursive backtracking      ,       ,    ,          . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br> <b> </b> <b>:</b>  ,    .  ,     ¬´¬ª   ,          ,           .      ,   ,               (          ).     ,        .           ,             ,     .          ,      - ,    ,    .        ,    ,    .          ,            . ,             - (union-find algorithm):      ,    .       .        ,    -      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br>  <b>Algoritmo de Prim (verdadeiro)</b> <b>:</b> esse algoritmo cria uma √°rvore de abrang√™ncia m√≠nima processando pesos de borda aleatoriamente exclusivos.  A quantidade de mem√≥ria necess√°ria √© proporcional ao tamanho do labirinto.  Come√ßamos a partir de qualquer v√©rtice (o labirinto acabado ser√° o mesmo, n√£o importa de onde partimos).  Selecionamos a aresta da passagem com o menor peso que conecta o labirinto a um ponto que ainda n√£o est√° nele e depois a anexamos ao labirinto.  O labirinto √© conclu√≠do quando as bordas em quest√£o n√£o s√£o mais deixadas.  Para selecionar com efici√™ncia a pr√≥xima borda, voc√™ precisa de uma fila de prioridade (geralmente implementada usando um heap) que armazena todas as bordas da borda.  No entanto, esse algoritmo √© bastante lento porque leva tempo de log (n) para selecionar itens do heap.  Portanto, √© melhor preferir o algoritmo Kraskal, que tamb√©m cria uma √°rvore de abrang√™ncia m√≠nima, porque √© mais r√°pido e cria labirintos com uma estrutura id√™ntica.  De fato, com a mesma semente aleat√≥ria, os algoritmos Prima e Kraskal podem criar os mesmos labirintos. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/fe7/700/d75/fe7700d7554d3456bb9f7c185b16dec1.gif"><br><br>  <b>Algoritmo de Prim (simplificado)</b> <b>:</b> o algoritmo deste Prim cria uma √°rvore de abrang√™ncia m√≠nima.  √â simplificado de forma que todos os pesos das arestas sejam os mesmos.  Requer uma capacidade de mem√≥ria proporcional ao tamanho do labirinto.  Come√ßamos a partir de um pico aleat√≥rio.  Selecionamos aleatoriamente a aresta da passagem que conecta o labirinto com um ponto que ainda n√£o est√° nele e, em seguida, o anexamos ao labirinto.  O labirinto √© conclu√≠do quando as bordas em quest√£o n√£o s√£o mais deixadas.  Como as arestas n√£o t√™m peso e n√£o s√£o ordenadas, elas podem ser armazenadas como uma lista simples, ou seja, a sele√ß√£o de elementos da lista ser√° muito r√°pida e levar√° tempo constante.  Portanto, √© muito mais r√°pido que o verdadeiro algoritmo Prim, com pesos de borda aleat√≥rios.  A textura de labirinto criada ter√° uma taxa de fluxo mais baixa e uma solu√ß√£o mais simples do que o m√©todo Prim verdadeiro, porque se espalha do ponto de partida uniformemente, como xarope derramado, e n√£o ignora fragmentos de costelas com um peso maior, que ser√£o levados em considera√ß√£o posteriormente. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/95d/7bf/e0a/95d7bfe0ad94b47045e086ff12847b94.gif"><br><br>  <b>Algoritmo do Prim (modificado)</b> <b>:</b> o algoritmo do Prim cria uma √°rvore de abrang√™ncia m√≠nima, modificada para que todos os pesos das arestas sejam os mesmos.  No entanto, √© implementado de tal maneira que, em vez de bordas, ele olha para as c√©lulas.  A quantidade de mem√≥ria √© proporcional ao tamanho do labirinto.  No processo de cria√ß√£o, cada c√©lula pode ter um dos tr√™s tipos: (1) ‚Äúinterno‚Äù: a c√©lula faz parte do labirinto e j√° est√° cortada nele; (2) ‚Äúlimite‚Äù: a c√©lula n√£o faz parte do labirinto e ainda n√£o foi cortada nele, mas est√° localizada pr√≥ximo √† c√©lula que j√° √© "interna" e (3) "externa": a c√©lula ainda n√£o faz parte do labirinto e nenhum de seus vizinhos tamb√©m √© a c√©lula "interna".  Come√ßamos escolhendo uma c√©lula, a tornamos "interna" e, para todos os seus vizinhos, definimos o tipo como "limite".  Selecionamos aleatoriamente a c√©lula ‚Äúlimite‚Äù e cortamos uma passagem de uma das c√©lulas ‚Äúinternas‚Äù vizinhas para dentro dela.  Mudamos o estado dessa c√©lula "limite" para "interno" e alteramos o tipo de todos os seus vizinhos de "externo" para "fronteira".  O labirinto √© conclu√≠do quando n√£o h√° mais c√©lulas "de fronteira" (isto √©, n√£o existem c√©lulas "externas", o que significa que todos se tornaram "internos").  Esse algoritmo cria labirintos com um √≠ndice de rendimento muito baixo, possui muitos impasses curtos e uma solu√ß√£o bastante direta.  O labirinto resultante √© muito semelhante ao resultado do algoritmo Prima simplificado, com uma pequena diferen√ßa: os vazios na √°rvore de abrang√™ncia s√£o preenchidos apenas se uma c√©lula de fronteira for selecionada aleatoriamente, em contraste com a probabilidade tripla de encher essa c√©lula atrav√©s de uma das c√©lulas de fronteira que o levam.  Al√©m disso, o algoritmo √© muito r√°pido, mais r√°pido que o algoritmo Prim simplificado, porque n√£o precisa compilar e processar a lista de arestas. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  Algoritmo <b>Aldous-Broder</b> : o que √© interessante nesse algoritmo √© que ele √© homog√™neo, ou seja, cria com igual probabilidade todos os labirintos poss√≠veis de um determinado tamanho.  Al√©m disso, ele n√£o requer mem√≥ria adicional ou uma pilha.  Selecionamos um ponto e movemos aleatoriamente para uma c√©lula vizinha.  Se entrarmos em uma c√©lula sem cortes, recorte a passagem da c√©lula anterior para ela.  Continuamos a avan√ßar para c√©lulas vizinhas at√© cortar as passagens para todas as c√©lulas.  Esse algoritmo cria labirintos com uma vaz√£o baixa, apenas um pouco maior que o algoritmo de Kraskal.  (Isso significa que, para uma determinada troca, h√° mais labirintos com um √≠ndice de rendimento baixo do que com um alto, porque o labirinto com uma probabilidade m√©dia √© igualmente baixa.) O ruim desse algoritmo √© que ele √© muito lento porque n√£o realiza uma pesquisa intelectual pelo √∫ltimo. c√©lulas, isto √©, de fato, n√£o tem garantias de conclus√£o.  No entanto, devido √† sua simplicidade, ele pode passar rapidamente por muitas c√©lulas, sendo conclu√≠do mais rapidamente do que voc√™ imagina.  Em m√©dia, leva sete vezes mais tempo para ser conclu√≠do do que os algoritmos padr√£o, embora em casos ruins possa demorar muito mais se o gerador de n√∫meros aleat√≥rios evitar constantemente as √∫ltimas c√©lulas.  Ele pode ser implementado como adi√ß√£o de paredes, se a parede da borda for considerada um √∫nico v√©rtice, ou seja, por exemplo, se o movimento nos mover para a parede da borda, nos teletransportamos para um ponto aleat√≥rio ao longo da borda e s√≥ ent√£o continuamos a se mover.  No caso de adicionar paredes, funciona quase duas vezes mais r√°pido, porque o teletransporte ao longo da parede da fronteira permite um acesso mais r√°pido √†s partes mais distantes do labirinto. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  <b>Algoritmo de Wilson</b> <b>:</b> esta √© uma vers√£o aprimorada do algoritmo Aldous-Broder, cria labirintos com exatamente a mesma textura (os algoritmos s√£o homog√™neos, ou seja, todos os labirintos poss√≠veis s√£o gerados com igual probabilidade), mas o algoritmo de Wilson √© muito mais r√°pido.  Leva mem√≥ria at√© o tamanho do labirinto.  Come√ßamos com uma c√©lula de labirinto inicial selecionada aleatoriamente.  Selecionamos uma c√©lula aleat√≥ria que ainda n√£o faz parte do labirinto e fazemos uma caminhada aleat√≥ria at√© encontrarmos uma c√©lula que j√° pertence ao labirinto.  Assim que topamos com a parte j√° criada do labirinto, retornamos √† c√©lula aleat√≥ria selecionada e cortamos todo o caminho feito adicionando essas c√©lulas ao labirinto.  Mais especificamente, quando retornamos ao longo do caminho, cortamos cada c√©lula na dire√ß√£o em que a caminhada aleat√≥ria ocorreu na √∫ltima vez que sa√≠mos da c√©lula.  Isso evita o aparecimento de loops ao longo do caminho de retorno, de modo que uma passagem longa se junte ao labirinto.  O labirinto √© conclu√≠do quando todas as c√©lulas est√£o conectadas a ele.  O algoritmo tem os mesmos problemas de velocidade que Aldous-Broder, porque pode levar muito tempo para encontrar o primeiro caminho aleat√≥rio para a c√©lula inicial, mas depois de colocar v√°rios caminhos, o resto do labirinto √© cortado rapidamente.  Em m√©dia, ele roda cinco vezes mais r√°pido que o Aldous-Broder e menos de duas vezes mais lento que os melhores algoritmos.  Vale a pena considerar que, no caso de adicionar paredes, funciona duas vezes mais r√°pido, porque toda a parede da borda √© inicialmente parte do labirinto, de modo que as primeiras paredes se juntam muito mais rapidamente. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/912/5a5/0b6/9125a50b62f3da5c999aa65dc144bc4a.gif"><br><br>  Algoritmo de <b>busca e</b> elimina√ß√£o <b>:</b> esse algoritmo √© conveniente porque n√£o requer mem√≥ria ou pilha adicional e, portanto, √© adequado para criar grandes labirintos ou labirintos em computadores fracos devido √† impossibilidade de ficar sem mem√≥ria.  Como n√£o possui regras que precisam ser seguidas constantemente, tamb√©m √© mais f√°cil modificar e criar labirintos com diferentes texturas.  √â quase semelhante a um backtracker recursivo, mas n√£o h√° c√©lula n√£o criada perto da posi√ß√£o atual.  Entramos no modo "ca√ßa" e examinamos sistematicamente o labirinto at√© encontrarmos uma c√©lula n√£o criada ao lado da c√©lula j√° cortada.  Nesta fase, novamente come√ßamos a cortar neste novo local.  O labirinto √© conclu√≠do quando no modo "ca√ßa" todas as c√©lulas s√£o digitalizadas.  Esse algoritmo tende a criar labirintos com uma taxa de fluxo alta, mas n√£o t√£o alta quanto o backtracker recursivo.  Voc√™ pode for√ß√°-lo a gerar labirintos com uma taxa de fluxo mais baixa, entrando com mais frequ√™ncia no modo "ca√ßa".  Ele corre mais devagar devido ao tempo gasto ca√ßando as √∫ltimas c√©lulas, mas n√£o muito mais lento que o algoritmo de Kraskal.  Pode ser implementado de acordo com o princ√≠pio de adicionar paredes, se voc√™ ocasionalmente se teletransportar aleatoriamente para evitar os problemas inerentes a um backtracker recursivo. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/823/3be/623/8233be62330af193c9f7a6ff63841cca.gif"><br><br>  <b>Algoritmo crescente</b> <b><br></b>  <b>tree (algoritmo da √°rvore em crescimento)</b> <b>:</b> este √© um algoritmo generalizado que pode criar labirintos com diferentes texturas.  A mem√≥ria necess√°ria pode atingir o tamanho do labirinto.  Cada vez que uma c√©lula √© cortada, a adicionamos √† lista.  Selecione uma c√©lula da lista e recorte a passagem para a c√©lula n√£o criada pr√≥xima a ela.  Se n√£o houver c√©lulas n√£o criadas pr√≥ximas √† atual, exclua a c√©lula atual da lista.  O labirinto √© conclu√≠do quando n√£o h√° mais nada na lista.  O interessante do algoritmo √© que, dependendo de como voc√™ seleciona uma c√©lula da lista, √© poss√≠vel criar muitas texturas diferentes.  Por exemplo, se voc√™ sempre selecionar a √∫ltima c√©lula adicionada, esse algoritmo se tornar√° um backtracker recursivo.  Se voc√™ sempre selecionar c√©lulas aleatoriamente, ele se comportar√° de maneira semelhante, mas n√£o id√™ntica ao algoritmo Prim.  Se voc√™ sempre selecionar as c√©lulas mais antigas adicionadas √† lista, criaremos um labirinto com o menor √≠ndice de rendimento poss√≠vel, ainda mais baixo que o do algoritmo Prim.  Se voc√™ costuma escolher a √∫ltima c√©lula, mas ocasionalmente escolhe uma c√©lula aleat√≥ria, o labirinto ter√° uma taxa de fluxo alta, mas uma solu√ß√£o curta e direta.  Se uma das c√©lulas mais recentes for selecionada aleatoriamente, o labirinto ter√° uma taxa de fluxo baixa, mas uma solu√ß√£o longa e sinuosa. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/3ee/6d6/3d0/3ee6d63d01f5e26e2f1c8b4a0f1e10e2.gif"><br><br>  <b>Algoritmo crescente da floresta</b> <b>:</b> este √© um algoritmo mais generalizado que combina tipos com base em √°rvores e conjuntos.  √â uma extens√£o do algoritmo de crescimento de √°rvore, que inclui essencialmente v√°rias inst√¢ncias que se expandem simultaneamente.  Come√ßamos com todas as c√©lulas classificadas aleatoriamente em uma lista de "novo";  al√©m disso, cada c√©lula tem seu pr√≥prio conjunto, como no in√≠cio do algoritmo de Kruskal.  Primeiro, selecione uma ou mais c√©lulas movendo-as da lista de "novo" para a lista de "ativo".  Selecione uma c√©lula da lista "ativa" e recorte a passagem para a pr√≥xima c√©lula n√£o criada da lista "nova", adicionando uma nova c√©lula √† lista de "ativa" e combinando os conjuntos de duas c√©lulas.  Se for feita uma tentativa de cortar a parte existente do labirinto, ative-a se as c√©lulas estiverem em conjuntos diferentes e combine as c√©lulas, como √© feito no algoritmo de Kraskal.  Se n√£o houver c√©lulas ‚Äúnovas‚Äù pr√≥ximas √† c√©lula atual, mova a c√©lula atual para a lista de c√©lulas ‚Äúconclu√≠das‚Äù.  O labirinto √© conclu√≠do quando a lista de "ativo" fica vazia.  No final, combinamos todos os conjuntos restantes, como no algoritmo de Kruskal.  Periodicamente, voc√™ pode criar novas √°rvores movendo uma ou mais c√©lulas da lista de "novo" para a lista de "ativo", como foi feito no in√≠cio.  Ao controlar o n√∫mero de √°rvores originais e os compartilhamentos das √°rvores rec√©m-criadas, voc√™ pode gerar muitas texturas exclusivas que combinam com os par√¢metros j√° flex√≠veis do algoritmo de crescimento de √°rvores. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/0df/4b2/2af/0df4b22af0d9c528721505c5863baa81.gif"><br><br>  <b>Algoritmo de Eller</b> <b>:</b> esse √© um algoritmo especial, porque n√£o √© apenas mais r√°pido que todos os outros, mas tamb√©m n√£o possui vi√©s ou defici√™ncias √≥bvias;  al√©m disso, quando √© criada, a mem√≥ria √© usada com mais efici√™ncia.  Nem exige que todo o labirinto esteja na mem√≥ria, ele usa um volume proporcional ao tamanho da linha.  Ele cria um labirinto linha por linha. Ap√≥s a gera√ß√£o da sequ√™ncia, o algoritmo n√£o leva mais em considera√ß√£o.  Cada c√©lula em uma linha est√° contida em um conjunto;  duas c√©lulas pertencem ao mesmo conjunto se houver um caminho entre elas ao longo do labirinto j√° criado.  Esta informa√ß√£o permite cortar passagens na linha atual sem criar loops ou √°reas isoladas.  De fato, √© bastante semelhante ao algoritmo de Kraskal, apenas aqui √© formado uma linha de cada vez, enquanto Kraskal olha atrav√©s de todo o labirinto.  A cria√ß√£o de uma linha consiste em duas partes: conecte aleatoriamente as c√©lulas adjacentes na linha, ou seja,  recortamos passagens horizontais e, em seguida, conectamos aleatoriamente as c√©lulas entre a corrente e a pr√≥xima linha, ou seja,  cortar passagens verticais.  Ao cortar passagens horizontais, n√£o conectamos c√©lulas que j√° est√£o no mesmo conjunto (porque um loop ser√° criado de outra forma) e, ao cortar passagens verticais, devemos conectar uma c√©lula se tiver um tamanho de unidade (porque, se voc√™ a deixar, criar√° uma √°rea isolada).  Ao cortar passagens horizontais, conectamos c√©lulas se elas estiverem no mesmo conjunto (porque agora existe um caminho entre elas) e, ao cortar passagens verticais quando n√£o nos conectamos √† c√©lula, colocamos em um conjunto separado (porque agora est√° separado do resto do labirinto )  A cria√ß√£o come√ßa com o fato de que antes de conectar as c√©lulas na primeira linha, cada c√©lula tem seu pr√≥prio conjunto.  A cria√ß√£o √© conclu√≠da ap√≥s as c√©lulas serem conectadas na √∫ltima linha.  Existe uma regra especial de conclus√£o: no momento da conclus√£o, cada c√©lula deve estar no mesmo conjunto para evitar √°reas isoladas.  (A √∫ltima linha √© criada combinando cada um dos pares de c√©lulas vizinhas que ainda n√£o est√£o no mesmo conjunto.) √â melhor implementar o conjunto usando uma lista c√≠clica de c√©lulas duplamente vinculada (que pode ser apenas uma matriz que liga c√©lulas a pares de c√©lulas nos dois lados do mesmo conjunto), permitindo realizar a inser√ß√£o, exclus√£o e verifica√ß√£o da presen√ßa de c√©lulas vizinhas em um conjunto por um tempo constante.  O problema com esse algoritmo √© o desequil√≠brio no processamento das diferentes bordas do labirinto;  Para evitar manchas nas texturas, √© necess√°rio conectar e pular as c√©lulas conectadas nas propor√ß√µes corretas. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"><br><br></b>  <b>Divis√£o recursiva:</b> esse algoritmo √© um pouco semelhante ao retorno recursivo, porque ambos usam pilhas, s√≥ que funciona n√£o com corredores, mas com paredes.  Come√ßamos criando uma parede horizontal ou vertical aleat√≥ria que cruza uma √°rea acess√≠vel em uma linha ou coluna aleat√≥ria e colocamos aleatoriamente espa√ßos vazios ao longo dela.  Em seguida, repetimos recursivamente o processo para as duas sub-regi√µes geradas pela parede divis√≥ria.  Para obter melhores resultados, √© necess√°rio adicionar um desvio na escolha de horizontal ou vertical com base nas propor√ß√µes da √°rea, por exemplo, uma √°rea cuja largura seja duas vezes a altura deve ser mais frequentemente dividida por paredes verticais.  Este √© o algoritmo mais r√°pido, sem desvios de dire√ß√£o, e muitas vezes pode at√© competir com labirintos baseados em √°rvores bin√°rias, porque cria v√°rias c√©lulas ao mesmo tempo, embora tenha uma desvantagem √≥bvia na forma de longas paredes que cruzam o interior do labirinto.  Esse algoritmo √© uma esp√©cie de labirinto fractal embutido, mas em vez de criar constantemente labirintos de c√©lulas de tamanho fixo com labirintos do mesmo tamanho dentro de cada c√©lula, divide aleatoriamente uma determinada √°rea em um labirinto de tamanho aleat√≥rio: 1x2 ou 2x1.  A divis√£o recursiva n√£o pode ser usada para cortar passagens, porque isso leva √† cria√ß√£o de uma solu√ß√£o √≥bvia que segue ao longo da borda externa ou cruza diretamente o interior. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d01/81f/8a0/d0181f8a04730302dbe6d88d0dc91431.gif"><br><br>  <b>Labirintos baseados em √°rvores bin√°rias</b> <b>:</b> na verdade, esses s√£o os algoritmos mais simples e r√°pidos poss√≠veis, no entanto, os labirintos criados t√™m uma textura com um vi√©s muito alto.  Para cada c√©lula, cortamos uma passagem para cima ou para a esquerda, mas nunca nas duas dire√ß√µes.  Na vers√£o com adi√ß√£o de paredes, um segmento de parede √© adicionado para cada v√©rtice que desce ou desce √† direita, mas n√£o nas duas dire√ß√µes.  Cada c√©lula √© independente de todas as outras c√©lulas, porque n√£o precisamos verificar o estado de outras c√©lulas ao cri√°-lo.  Portanto, este √© um algoritmo real para gerar labirintos sem mem√≥ria, n√£o limitado pelo tamanho dos labirintos criados.  De fato, essa √© uma √°rvore bin√°ria, se considerarmos o canto superior esquerdo como uma raiz, e cada n√≥ ou c√©lula possui um n√≥ pai exclusivo, que √© uma c√©lula no topo ou √† esquerda dele.  Os labirintos baseados em √°rvores bin√°rias s√£o diferentes dos labirintos ideais padr√£o, porque mais da metade dos tipos de c√©lulas n√£o podem existir neles.  Por exemplo, nunca haver√° interse√ß√µes nelas e todos os becos sem sa√≠da t√™m passagens que v√£o para cima ou para a esquerda e nunca para baixo ou para a direita.  Os labirintos tendem a ter passagens na diagonal do canto superior esquerdo para o canto inferior direito, e √© muito mais f√°cil mover-se do canto inferior direito para o canto superior esquerdo.  Voc√™ sempre pode se mover para cima ou para a esquerda, mas nunca simultaneamente nas duas dire√ß√µes, para poder sempre se mover deterministicamente na diagonal para cima e para a esquerda, sem encontrar barreiras.  Voc√™ ter√° a oportunidade de escolher e cair em becos sem sa√≠da, movendo-se para baixo e para a direita. ,            ,  ,        . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f3f/f8c/58c/f3ff8c58c53fce1c8d57401f7f41c924.gif"><br><br>  Sidewinder:</b>         ,    .       :      ,    ,  .    ,   ,      ,       ,  ,   .           ,     (    ,      ).                ,  sidewinder     .              ,    sidewinder        .     ,  sidewinder        ,          ,  .   sidewinder            ,   ¬´    ¬ª.   ,       sidewinder ‚Äî      ,      ,   ,  ,    .  sidewinder     ,       ,         ,   . </li></ul><br><table><tbody><tr><td> <b></b> </td><td> <b>% </b> </td><td> <b></b> </td><td> <b></b> </td><td> <b> ?</b> </td><td> <b>?</b> </td><td> <b></b> </td><td> <b></b> </td><td> <b>% </b> </td></tr><tr><td>  </td><td>  0 0 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 379 </td><td> 100.0 </td></tr><tr><td> Recursive Backtracker </td><td>  10 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  27 </td><td> 19.0 </td></tr><tr><td> Hunt and Kill </td><td> 11 (21) </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  0 0 </td><td> 100 (143) </td><td> 9.5 (3.9) </td></tr><tr><td>   </td><td>  23 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N* </td><td>  10 </td><td> 7.2 </td></tr><tr><td>   </td><td>  25 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> 0* </td><td>  10 </td><td> 2.0 </td></tr><tr><td> Sidewinder </td><td>  27 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> 0* </td><td>  12 </td><td> 2.6 </td></tr><tr><td>   </td><td>  28. </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N* </td><td>  20 </td><td> 4.2 (3.2) </td></tr><tr><td>   </td><td>  29 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 48 (25) </td><td> 4.5 </td></tr><tr><td>  - </td><td>  29 </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  0 0 </td><td> 279 (208) </td><td> 4.5 </td></tr><tr><td>   </td><td>  30 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  33 </td><td> 4.1 </td></tr><tr><td>   () </td><td>  30 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 160 </td><td> 4.1 </td></tr><tr><td>   () </td><td>  32. </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 59 </td><td> 2.3 </td></tr><tr><td>   () </td><td> 36 (31) </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  30 </td><td> 2.3 </td></tr><tr><td>   </td><td> 49 (39) </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 48 </td><td> 11.0 </td></tr><tr><td>   </td><td> 49 (39) </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  76 </td><td> 11.0 </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta tabela resume as caracter√≠sticas dos algoritmos para criar labirintos ideais descritos acima. Para compara√ß√£o, foi adicionado um algoritmo de labirinto de rota √∫nica (teoricamente, os labirintos de rota √∫nica s√£o ideais). Explica√ß√£o da coluna:</font></font><br><br><ul><li> <b>:</b>    ,    ,     ,    2D-.       .       ,     ,     ,        .           10% (     )  49% (    ).        Recursive Backtracker    1%.           66%:              . </li><li> <b>:</b>       :        ,    ,           .       ,   ,   ,    ,           .  ,    ,    . </li><li> <b>:</b>        ,    .          .       ,           ,       . Recursive Backtracker     ,          ,    ,          . ,        ,       .  , Hunt and Kill          ,        ,            . </li><li> <b> :</b>          ,          .     ,           . Sidewinder  ,           .      ,      .  Hunt and Kill  ,      ,     ,       . </li><li> <b>:</b>         . ¬´¬ª ,    . ¬´¬ª ,            ,     . ¬´¬ª ,    ,      . ,           . </li><li> <b>:</b>     ,    .        ,        ,    (N),     (N^2).          ,        (   ).        ,     ,        .  Sidewinder       ,           .          ,         . </li><li> <b>:</b>      ,          ,   ,    .      ,       (     10),          .         100x100    Daedalus.         ,     ,     ,       . </li><li> <b>:</b>    ,        ,  .  ,     100x100 .        .     ¬´¬ª  .     ,       .      ,                  .        ,    ,     ,         . </li></ul><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem muitas maneiras de resolver labirintos, e cada um deles tem suas pr√≥prias caracter√≠sticas. </font><font style="vertical-align: inherit;">Aqui est√° uma lista de algoritmos espec√≠ficos:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/62b/7f0/7c6/62b7f07c68ae7a9544c6ad481577e816.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seguindo ao longo das paredes (seguidor de parede) </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>     .        (¬´¬ª),         .            (  ).        ,      ( )           .         ,  .       ,    ,   .      ,     ,           ,             .     3D-    ,  3D-  2D-, .. ,          -,      -,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d5b/25c/4de/d5b25c4de2e848708f6f9ba70a47957f.gif"><br><br> <b> </b> <b>:</b>      ,    ¬´¬ª    ,      .          2D-    ,       , ..    .           ,        ,         .            .   ,    ,        .  ,         ,    .       ,             ,   .        , ,   ‚Äî  -1,    ‚Äî  1.            ,      , ..     360   ,        ¬´¬ª.  ,         ¬´¬ª,      ,        ,      ,      ,         .  ,             ,           .      ,    ‚Äî    ,              . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/885/45e/39a/88545e39a856cc77b791086ebc958e0c.gif"><br><br> <b> </b> <b>:</b>   (Chain algorithm)  ,        (  )     .        ,         ,   .       ,    .  ,      ,      .      ,              .      (     )    ,      .         .     ,      ,    .      ¬´¬ª      ,   .          ,     ,       ,      .       ,    .          ,         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/402/cba/ed2/402cbaed27df8e2319b04647f963dc2e.gif"><br><br> Recursive backtracker:</b>    ,     .       ,              .   :      (    ),   ¬´¬ª, ,     ,  ¬´¬ª, ,       .  ,         ,    ¬´¬ª;    ¬´¬ª       .    (backtracking)       ,      ,    .  ,       .     ,   ,      . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/965/84c/528/96584c52805bc66d81e23eeae05b2057.gif"><br><br>   (Tr√©maux's algorithm):</b>          .    recursive backtracker      :         ,   .           ,  .   ,     ,     .          ,   ,         ,  . (     ,           .)    ,     (..  ),    ,     ,   ,       (.. ,    ).     ,       ,   ,        ,   ,             .     ,            .     ,     ,      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/949/1f9/5b9/9491f95b97951ee9f10551bb24187e94.gif"><br><br> <b>  (Dead end filler)</b> <b>:</b>     .     ,         .        ,       ,    .         ,        .       ,   ,      .         ,         ,           . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/af6/640/839/af6640839e35705adb99b781278d56a9.gif"><br><br> <b>Cul-de-sac filler</b> <b>:</b>         ,     ,         .    dead end filler,    ,        .        (  ‚Äî   ,           ,      )  ,       .    dead end filler.     ,    ,       ,     ,       .       ,   ,     ,   dead end filler. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/a01/d27/475/a01d27475d474454f478264e022e0383.gif"><br><br> <b>Blind alley filler</b> <b>:</b>      ,    ,     .   ,    .   ‚Äî   ,      ,             .     ,    ,    cul-de-sac filler,      .       .    ,    , ,  ,  .            ,   ,  ,          (           ).   ,             ,          .      ,   cul-de-sac filler  - ,     collision solver    ,      - . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/105/ade/5a7/105ade5a7dd7cbce67bcbd57d3ba3b7e.gif"><br><br> <b>Blind alley sealer</b> <b>:</b>     blind alley filler ,       ,     .                 .               .     ,   ,  blind alley filler,     .         .   ,    ,     ,        ,        .  ,      ,     .          ,     .      ,          ,   .  ,               ,    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/5e2/562/508/5e25625080da8af3396476127a2cc9ed.gif"><br><br>    (Shortest path finder):</b>     ,     ,        .        ,           ,   .   collision solver, ,  ,   ¬´¬ª ,          (      ),   ¬´¬ª  , ,     .      ¬´¬ª,       ,     .        ,             -    ,    .  ,  ,  ,    A*  ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/396/221/e2e/396221e2ed8b51be85c22fc94f5610db.gif"><br><br> <b>   (Shortest paths finder)</b> <b>:</b>       ,     .     ,        ,     ,   ,   ,       ,    ,     -     ,    .  ,     ,     ,   ¬´¬ª ,         ,     ,      .         ,   ,       ,      ,    .         ,                  . </li><li> <b>Collision solver:</b>   "amoeba" solver.      .        ,                        .    ¬´¬ª ,          (  ).   ¬´ ¬ª       (   ),       ,   .      ¬´¬ª,     ,       ,   ,     . ( ,    ¬´¬ª,     .   ,      ,         ,    .)  ,   shortest paths finder,     (           )    (         ). </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rato aleat√≥rio:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para contraste, darei um m√©todo ineficaz para resolver um labirinto, que consiste essencialmente em movimento aleat√≥rio, ou seja, </font><font style="vertical-align: inherit;">movendo-se em uma dire√ß√£o e seguindo esta passagem com todas as curvas at√© chegarmos ao pr√≥ximo garfo. </font><font style="vertical-align: inherit;">N√£o fazemos curvas de 180 graus, se voc√™ puder ficar sem elas. </font><font style="vertical-align: inherit;">Isso simula o comportamento de uma pessoa que vagueia acidentalmente por um labirinto e n√£o se lembra de onde j√° estava. </font><font style="vertical-align: inherit;">O algoritmo √© lento e n√£o garante a conclus√£o ou solu√ß√£o do labirinto e, ap√≥s chegar ao fim, ser√° igualmente dif√≠cil retornar ao in√≠cio, mas √© simples e n√£o requer mem√≥ria adicional para implementa√ß√£o.</font></font></li></ul><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmo</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solu√ß√µes</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garantia?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prioridade</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dispon√≠vel para humanos?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Independente dos corredores?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o √© necess√°ria mem√≥ria?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√°pido?</font></font></b> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rato aleat√≥rio </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voc√™ √© </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por dentro / por cima </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sim </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seguidor de parede </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voc√™ √© </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por dentro / por cima </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sim </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sim </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sim </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmo de Penhor </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voc√™ √© </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por dentro / por cima </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sim </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sim </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sim </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmo de circuito </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sim </font></font></td><td> Voc√™ + </td><td>  N√£o </td><td>  Sim </td><td>  N√£o </td><td>  Sim </td></tr><tr><td>  Backtracker recursivo </td><td>  1 </td><td>  Sim </td><td>  Voc√™ √© </td><td>  N√£o </td><td>  Sim </td><td>  N√£o </td><td>  Sim </td></tr><tr><td>  Algoritmo de Tremo </td><td>  1 </td><td>  Sim </td><td>  Voc√™ √© </td><td>  Por dentro / por cima </td><td>  N√£o </td><td>  N√£o </td><td>  Sim </td></tr><tr><td>  Massa sem sa√≠da </td><td>  Tudo + </td><td>  N√£o </td><td>  Labirinto </td><td>  Over </td><td>  N√£o </td><td>  Sim </td><td>  Sim </td></tr><tr><td>  Enchimento de fundo de saco </td><td>  Tudo + </td><td>  N√£o </td><td>  Labirinto </td><td>  Over </td><td>  N√£o </td><td>  Sim </td><td>  Sim </td></tr><tr><td>  Aferidor de becos sem sa√≠da </td><td>  Tudo + </td><td>  Sim </td><td>  Labirinto </td><td>  N√£o </td><td>  N√£o </td><td>  N√£o </td><td>  Sim </td></tr><tr><td>  Enchimento de beco sem sa√≠da </td><td>  Todos </td><td>  Sim </td><td>  Labirinto </td><td>  Over </td><td>  N√£o </td><td>  Sim </td><td>  N√£o </td></tr><tr><td>  Solucionador de colis√£o </td><td>  Todos os mais curtos </td><td>  Sim </td><td>  Voc√™ + </td><td>  N√£o </td><td>  N√£o </td><td>  N√£o </td><td>  Sim </td></tr><tr><td>  Pesquise os caminhos mais curtos </td><td>  Todos os mais curtos </td><td>  Sim </td><td>  Voc√™ + </td><td>  N√£o </td><td>  Sim </td><td>  N√£o </td><td>  Sim </td></tr><tr><td>  Procure o caminho mais curto </td><td>  1 mais curto </td><td>  Sim </td><td>  Voc√™ + </td><td>  N√£o </td><td>  Sim </td><td>  N√£o </td><td>  Sim </td></tr></tbody></table><br>  Esta tabela lista brevemente as caracter√≠sticas dos algoritmos de resolu√ß√£o de labirinto descritos acima.  De acordo com esses crit√©rios, √© poss√≠vel classificar e avaliar algoritmos para a resolu√ß√£o de labirintos.  Explica√ß√µes da coluna: <br><br><ul><li>  <b>Solu√ß√µes:</b> descreve as solu√ß√µes encontradas pelo algoritmo e as a√ß√µes do algoritmo, se houver v√°rias.  O algoritmo pode escolher uma solu√ß√£o ou deixar v√°rias.  Al√©m disso, as solu√ß√µes podem ser qualquer caminho ou o caminho mais curto.  O preenchimento sem sa√≠da e o preenchimento de um beco sem sa√≠da (assim como o selador de becos sem sa√≠da ao processar suas √°reas inacess√≠veis) deixam todas as solu√ß√µes; no entanto, eles tamb√©m podem deixar passagens que n√£o est√£o em nenhum dos caminhos da solu√ß√£o, ent√£o eu as marquei como "Tudo + " </li><li>  <b>Garantia:</b> O algoritmo tem garantia de encontrar pelo menos uma solu√ß√£o?  Para mouse aleat√≥rio, ‚Äún√£o‚Äù √© indicado, porque sua conclus√£o n√£o √© garantida, e para o seguidor de parede e o algoritmo do Col√©gio, ‚Äún√£o‚Äù √© indicado, porque eles n√£o ser√£o capazes de encontrar uma solu√ß√£o se o alvo estiver dentro da ilha.  "Dead" √© ‚Äã‚Äãindicado para preenchimento sem sa√≠da e preenchimento de becos sem sa√≠da, porque em labirintos de vime eles podem n√£o encontrar uma solu√ß√£o. </li><li>  <b>Prioridade:</b> Existem dois tipos de algoritmos para resolver o labirinto: dar prioridade a "voc√™" (localizado no labirinto) ou dar prioridade ao labirinto.  Se a prioridade √© dada a voc√™, temos um ponto (‚ÄúVoc√™‚Äù √© indicado na tabela) ou muitos pontos (‚ÄúVoc√™ +‚Äù) e o algoritmo tenta desenh√°-los do in√≠cio ao fim do labirinto.  Se for dada prioridade ao labirinto, examinamos o labirinto como um todo e descartamos passagens in√∫teis. </li><li>  <b>Dispon√≠vel para o homem:</b> um homem pode usar o algoritmo para resolver o labirinto, no labirinto real ou olhando o mapa de cima.  Alguns dos algoritmos que d√£o prioridade a "voc√™" podem ser implementados como uma pessoa dentro do labirinto (ou acima dele), e alguns que d√£o prioridade ao labirinto podem ser implementados como uma pessoa, mas apenas acima do labirinto.  Outros algoritmos s√£o muito complexos e sua implementa√ß√£o confi√°vel √© poss√≠vel apenas em um computador. </li><li>  <b>Passagem independente:</b> o algoritmo pode ser executado em qualquer lugar.  Alguns algoritmos exigem que o labirinto tenha passagens √≥bvias ou, falando na terminologia de gr√°ficos, arestas claras entre v√©rtices individuais ou passagens de um pixel quando implementadas em um computador.  O seguidor de Wall, o algoritmo Pledge e o algoritmo de circuito requerem uma parede apenas de um lado.  O backtracker recursivo e o localizador de caminhos mais curto direcionam os deles por espa√ßos abertos. </li><li>  <b>N√£o √© necess√°ria mem√≥ria:</b> voc√™ precisa de mem√≥ria adicional ou uma pilha para implementar o algoritmo.  Algoritmos eficazes exigem apenas um bitmap do pr√≥prio labirinto e n√£o precisam adicionar marcadores ao labirinto no processo de solu√ß√£o. </li><li>  <b>R√°pido:</b> o processo de decis√£o √© considerado r√°pido.  Os algoritmos mais eficientes s√£o suficientes para examinar cada c√©lula do labirinto apenas uma vez, ou podem pular completamente partes dele.  O tempo de execu√ß√£o deve ser proporcional ao tamanho do labirinto, ou O (n ^ 2), onde n √© o n√∫mero de c√©lulas ao longo de um lado.  O mouse aleat√≥rio √© lento porque sua conclus√£o n√£o √© garantida, e o enchimento de becos sem sa√≠da potencialmente resolve o labirinto de cada garfo. </li></ul><br><h2>  Outras opera√ß√µes com labirintos </h2><br>  Al√©m de criar e resolver labirintos, voc√™ pode executar outras opera√ß√µes com eles: <br><br><ul><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/6f7/fee/d6d/6f7feed6d3542670945c7601c6d17656.gif"><br><br></b>  <b>Preenchimento:</b> √© uma fun√ß√£o ‚Äúr√°pida e suja‚Äù, mas √∫til que pode ser implementada com uma √∫nica chamada para o procedimento da biblioteca gr√°fica Fill ou FloodFill.  Realizamos o preenchimento de inunda√ß√£o da passagem no in√≠cio e, se o final n√£o for inundado, o labirinto n√£o ter√° solu√ß√£o.  Nos labirintos, cuja entrada e sa√≠da est√£o nas bordas, realizamos o FloodFill de uma parede e as bordas restantes marcam a solu√ß√£o.  Nos labirintos onde est√£o o in√≠cio e o fim, executamos o FloodFill da parede delimitadora e, se a parede de sa√≠da n√£o tiver sido removida, esse labirinto n√£o poder√° ser resolvido seguindo-se as paredes.  Muitos m√©todos de cria√ß√£o de labirintos e outras fun√ß√µes usam o "preenchimento" do labirinto em determinados pontos. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f09/223/2e3/f092232e3f56154a43c81d5b71eee6c2.gif"><br><br></b>  <b>Removedor de isolamento:</b> Troque o labirinto para que ele n√£o tenha partes com passagens que n√£o possam ser alcan√ßadas pelo resto do labirinto.  Isso √© realizado removendo as paredes que conectam essas partes com o resto do labirinto.  Come√ßamos com uma c√≥pia do labirinto, depois preenchemos a passagem perto do in√≠cio.  Examinamos o labirinto (de prefer√™ncia em ordem aleat√≥ria, mas com uma visita a todas as c√©lulas poss√≠veis) quanto √† presen√ßa de c√©lulas n√£o preenchidas adjacentes √† c√©lula preenchida.  Exclu√≠mos o segmento da parede nesse ponto do labirinto original, preenchemos o labirinto nesse novo ponto e repetimos at√© que todas as pe√ßas estejam preenchidas.  Esta fun√ß√£o √© usada para criar labirintos tecidos e estampados. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/e02/4fb/283/e024fb2832bd8e5d855b80393a75cf67.gif"><br><br></b>  <b>Remo√ß√£o de al√ßa:</b> mude o labirinto para que n√£o haja la√ßos e paredes n√£o conectados a nada, e cada parte do labirinto pode ser alcan√ßada a partir de qualquer ponto de apenas uma maneira.  A implementa√ß√£o dessa fun√ß√£o √© quase semelhante √† remo√ß√£o de √°reas isoladas, apenas percebemos as paredes como passagens e vice-versa.  Come√ßamos com uma c√≥pia do labirinto e depois enchemos as paredes externas.  Escaneamos o labirinto (de prefer√™ncia em ordem aleat√≥ria, mas com uma visita a todos os poss√≠veis topos das paredes) quanto √† presen√ßa de paredes n√£o preenchidas pr√≥ximas √†s preenchidas.  Adicione um segmento de parede conectando as duas partes das paredes ao labirinto original nesse ponto, encha o labirinto nesse novo ponto e repita at√© que todas as pe√ßas estejam preenchidas.  Esta fun√ß√£o √© usada para criar labirintos de modelos e pode ser usada para converter labirintos de vime em ideais, que, no entanto, permanecem semelhantes aos originais. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ea4/f95/188/ea4f951888f580d0a1446246e20e0ea1.gif"><br><br>  <b>Procure por gargalos</b> <b>:</b> pesquise no labirinto de passagens ou pontos de interse√ß√£o pelos quais todas as solu√ß√µes desse labirinto passam.  Para fazer isso, comece a seguir ao longo das paredes com o m√©todo da m√£o esquerda para obter a solu√ß√£o esquerda e comece a seguir ao longo das paredes com o m√©todo da m√£o direita para obter a solu√ß√£o certa.  Os lugares em que as duas solu√ß√µes s√£o comuns s√£o gargalos.  No entanto, essa t√©cnica funciona apenas para labirintos, que podem ser resolvidos com sucesso seguindo-se ao longo das paredes.  Em outros labirintos, para encontrar gargalos, voc√™ precisa encontrar qualquer solu√ß√£o e executar o selador de becos sem sa√≠da (isso pode tornar o labirinto insol√∫vel se perceber a entrada ou a sa√≠da dentro do labirinto como um grande beco sem sa√≠da).  Partes do caminho da solu√ß√£o que passam por passagens fechadas s√£o gargalos. </li></ul><br><h2>  Implementa√ß√µes de algoritmos </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>Daedalus</b></a> <b>:</b> todos os algoritmos para cria√ß√£o e solu√ß√£o de labirintos descritos acima s√£o implementados no Daedalus, um programa gratuito e dispon√≠vel para download no Windows.  Completo com Daedalus, h√° um c√≥digo fonte completo. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445378/">https://habr.com/ru/post/pt445378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445362/index.html">O livro "Sistemas Distribu√≠dos. Padr√µes de Design</a></li>
<li><a href="../pt445366/index.html">Como acelerar a criptografia de acordo com GOST 28147-89 no processador Baikal-T1 devido ao bloco SIMD</a></li>
<li><a href="../pt445368/index.html">Carregar testando um jogo com algumas centenas de milhares de usu√°rios virtuais</a></li>
<li><a href="../pt445370/index.html">An√°lise TSDB em Prometheus 2</a></li>
<li><a href="../pt445372/index.html">Vis√£o de m√°quina versus intui√ß√£o humana: algoritmos para interromper a opera√ß√£o de programas de reconhecimento de objetos</a></li>
<li><a href="../pt445380/index.html">PHP moderno √© bonito e produtivo</a></li>
<li><a href="../pt445384/index.html">Miss√£o Chang'e-4 - equipamento cient√≠fico no m√≥dulo de aterragem e no sat√©lite repetidor</a></li>
<li><a href="../pt445390/index.html">IDE de uma pessoa normal ou por que escolhemos M√¥naco</a></li>
<li><a href="../pt445392/index.html">Remarketing din√¢mico MyTarget: recomenda√ß√µes n√£o pessoais de produtos</a></li>
<li><a href="../pt445394/index.html">Altera√ß√µes no protocolo seguro 3D: conhe√ßa o 3-D Secure 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>