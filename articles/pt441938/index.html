<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úÖ ü§¶üèø ü§± F√≥rmula para coreano ou reconhe√ßa Hangul de forma r√°pida, f√°cil e sem erros. üè• üîä ‚òïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At√© o momento, qualquer aluno que tenha feito um curso em redes neurais pode reconhecer caracteres coreanos. D√™ a ele uma amostra e um computador com ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>F√≥rmula para coreano ou reconhe√ßa Hangul de forma r√°pida, f√°cil e sem erros.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/441938/"><img src="https://habrastorage.org/webt/ba/mt/v2/bamtv2b4kyxq8bt4-5hynwx0are.jpeg" align="right">  At√© o momento, qualquer aluno que tenha feito um curso em redes neurais pode reconhecer caracteres coreanos.  D√™ a ele uma amostra e um computador com uma placa de v√≠deo e, depois de um tempo, ele oferecer√° uma rede que reconhecer√° os caracteres coreanos quase sem erros. <br><br>  Mas essa solu√ß√£o ter√° v√°rias desvantagens: <br><br>  <b>Primeiro</b> , um grande n√∫mero de c√°lculos necess√°rios, que afetam o tempo de opera√ß√£o ou a energia necess√°ria (o que √© muito importante para dispositivos m√≥veis).  De fato, se queremos reconhecer pelo menos 3000 caracteres, esse ser√° o tamanho da √∫ltima camada da rede.  E se a entrada dessa camada for pelo menos 512, obteremos multiplica√ß√µes de 512 * 3000.  Demais. <br><br>  <b>Em segundo lugar</b> , o tamanho.  A mesma √∫ltima camada do exemplo anterior pesar√° 512 * 3001 * 4 bytes, ou seja, cerca de 6 megabytes.  Esta √© apenas uma camada, a rede inteira pesar√° dezenas de megabytes.  √â claro que esse n√£o √© um grande problema para um computador de mesa, mas nem todos estar√£o prontos para armazenar tantos dados em um smartphone para reconhecer um idioma. <br><br>  <b>Em terceiro lugar</b> , essa rede fornecer√° resultados imprevis√≠veis em imagens que n√£o s√£o caracteres coreanos, mas s√£o usadas em textos coreanos.  Em condi√ß√µes de laborat√≥rio, isso n√£o √© dif√≠cil, mas para a aplica√ß√£o pr√°tica da tecnologia, esse problema dever√° ser resolvido de alguma forma. <br><br>  <b>E em quarto lugar</b> , o problema √© o n√∫mero de caracteres: 3000 √© provavelmente o suficiente para, por exemplo, distinguir um bife de um pepino do mar frito no menu do restaurante, mas √†s vezes existem textos mais complexos.  Ser√° dif√≠cil treinar a rede para um n√∫mero maior de caracteres: n√£o apenas ser√° mais lento, como tamb√©m haver√° um problema com a coleta da amostra de treinamento, uma vez que a frequ√™ncia dos caracteres diminui aproximadamente exponencialmente.  Obviamente, voc√™ pode obter imagens de fontes e aument√°-las, mas isso n√£o √© suficiente para treinar uma boa rede. <br><br>  E hoje vou lhe contar como conseguimos resolver esses problemas. <br><a name="habracut"></a><br><h2>  Como a escrita coreana funciona? </h2><br>  A escrita coreana, Hangul, √© um cruzamento entre a escrita chinesa e a europeia.  Externamente, esses s√£o caracteres quadrados que se assemelham a hier√≥glifos e, em uma p√°gina do texto, voc√™ pode contar mais de uma centena de caracteres √∫nicos.  Por outro lado, √© a escrita fon√©tica, ou seja, baseada na grava√ß√£o de sons.  H√° um alfabeto contendo 24 letras (al√©m disso, voc√™ tamb√©m pode contar difractos e ditongos).  Mas, diferentemente do alfabeto latino ou cir√≠lico, os sons n√£o s√£o escritos em uma linha, mas combinados em blocos.  Por exemplo, se escrevermos da mesma maneira, a frase "Ol√°, Habr" poder√° ser escrita em tr√™s blocos como este: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/ya/wu/idyawulbnrayub1igw6bkpjwcca.png"></div><br>  Cada bloco pode consistir em duas, tr√™s ou quatro letras.  Nesse caso, a consoante sempre vem primeiro, depois uma ou duas vogais e, no final, pode haver outra consoante.  Existem v√°rias maneiras diferentes de combinar letras em blocos, ou seja, em blocos diferentes, a segunda letra, por exemplo, fica em lugares diferentes. <br><br>  A figura abaixo mostra dois blocos que juntos formam a palavra "Hangul".  A primeira letra de cada bloco √© indicada em vermelho, as vogais s√£o destacadas em azul e a consoante final √© destacada em verde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4b/76/0p/4b760pyxzvlfy0wy0bigrlqgmaw.png"></div><br>  <i>Fonte da imagem: Wikipedia.</i> <br><br><h2>  Modificar bloco Hangul </h2><br>  Ou seja, acontece que um bloco Hangul pode ser descrito pela f√≥rmula: Ci V [V] [Cf], em que Ci √© a consoante inicial (possivelmente dupla), V √© a vogal e Cf √© a consoante final (tamb√©m pode ser dupla).  Essa representa√ß√£o √© inconveniente para o reconhecimento, por isso a alteramos. <br><br>  Primeiro, combine as duas vogais.  Temos a f√≥rmula Ci V '[Cf], onde V' - todas as op√ß√µes poss√≠veis para combinar letras, considerando a aus√™ncia da segunda letra.  Como existem 10 vogais no idioma, seria de esperar que, como resultado, obtivemos 10 * (10 + 1) op√ß√µes, mas, na pr√°tica, nem todas elas s√£o poss√≠veis, apenas 21 s√£o obtidas. <br><br>  Al√©m disso, a √∫ltima letra pode n√£o ser.  Acrescente √†s muitas letras esperadas no final uma letra vazia.  Em seguida, obtemos a f√≥rmula Ci V 'Cf *.  Assim, verifica-se que agora o s√≠mbolo coreano sempre consiste em tr√™s "letras".  Voc√™ pode aprender a grade. <br><br><h2>  Constru√≠mos uma rede </h2><br>  A id√©ia √© que, em vez de reconhecermos todo o personagem, reconheceremos as letras individuais neles.  Assim, em vez de um softmax enorme no final, temos tr√™s pequenos, cada um com algumas dezenas de tamanho.  Eles correspondem √† primeira, segunda e terceira "letras" da s√≠laba.  Como resultado, obtivemos a seguinte arquitetura: <br><br>  <i>imagem clic√°vel</i> <br> <a href=""><img src="https://habrastorage.org/webt/oe/tx/la/oetxlav-phzctw_re0w02a982gq.png"></a> <br><br>  N√≥s treinamos, corremos em uma amostra separada.  A qualidade √© boa, a grade √© r√°pida e pesa pouco.  Vamos tentar tir√°-lo do laborat√≥rio para o mundo real. <br><br><h2>  Resolvemos problemas </h2><br>  N√≥s vamos encontrar o primeiro problema imediatamente: √†s vezes imagens que n√£o s√£o caracteres coreanos entram na entrada e a rede nelas se comporta de maneira extremamente imprevis√≠vel.  √â claro que voc√™ pode treinar outra rede que distingue os blocos coreanos de todo o resto, mas facilitaremos isso. <br><br>  Vamos fazer o mesmo que fizemos com o terceiro grupo de letras: adicione uma sa√≠da pela aus√™ncia de uma letra.  Ent√£o a f√≥rmula do s√≠mbolo ficar√° assim: Ci * V '* Cf *.  E no conjunto de treinamento, adicionaremos todo tipo de lixo - caracteres chineses, caracteres incorretamente cortados, letras europ√©ias e ensinaremos a rede a marcar tr√™s letras vazias. <br><br>  N√≥s treinamos, testamos.  Funciona, mas os problemas permanecem.  Acontece que, com bastante frequ√™ncia, por exemplo, essas imagens entram na grade: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/9o/wk/bs9owkuyyvxqhqgky8kea-51sxc.png"></div><br>  Esse √© o bloco coreano correto no qual uma aspas simples est√° presa.  E √© √≥bvio que neles a rede encontra perfeitamente todas as tr√™s letras das quais o bloco consiste.  Isso √© apenas a imagem n√£o est√° correta, e precisamos sinalizar sobre isso.  √â errado retornar letras vazias aqui, como est√£o na imagem.  Vamos tentar aplicar o que j√° provou ser bom: adicione mais duas sa√≠das para reconhecer esses pontuadores r√≠gidos.  Em cada uma delas, haver√° uma sa√≠da adicional para uma situa√ß√£o em que n√£o h√° nada sup√©rfluo na imagem, mas, al√©m disso, √© necess√°rio adicionar mais uma sa√≠da para a situa√ß√£o "h√° um pontuador, mas n√£o √© reconhecido, provavelmente lixo". <br><br>  Treinado  √â ruim nessa grade reconhecer os pontuadores: distingue uma v√≠rgula de um colchete, mas j√° √© dif√≠cil de um ponto.  Voc√™ pode aumentar a complexidade da grade, mas n√£o deseja.  Lidaremos com o reconhecimento dos pontuadores mais tarde, mas, por enquanto, simplesmente divulgaremos se h√° algo l√° ou n√£o.  Essa grade aprendeu bem. <br><br>  Descobrimos os pontuadores colados, mas e se, pelo contr√°rio, parte da chave estiver faltando na imagem?  Havia uma palavra com dois caracteres, mas a dividimos em caracteres incorretamente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0k/0b/is/0k0bis_huro2eqavjxat7y2ztx8.png"></div><br>  A rede aqui sem problemas determina a letra central.  Seria uma qualidade muito √∫til se nossa tarefa fosse reconhecer apenas uma sele√ß√£o de caracteres, mas no mundo real seria prejudicial: quando cortamos incorretamente a string em caracteres, devemos passar essas informa√ß√µes acima, pois, caso contr√°rio, a pe√ßa restante ser√° reconhecida como algum tipo de pontua√ß√£o e no texto resultante haver√° um caractere extra. <br><br>  Para resolver esse problema, usaremos o que resta de alguns experimentos antigos de muitos anos atr√°s.  A id√©ia de reconhecer caracteres coreanos por letras apareceu h√° muito tempo, e as primeiras tentativas foram feitas mesmo antes da era das redes neurais, mas elas n√£o encontraram aplica√ß√£o pr√°tica.  Mas desde ent√£o, coisas interessantes permaneceram: <br><br><ol><li>  Marcar onde cada bloco tem uma letra. </li><li>  Alta qualidade, embora r√°pida, cortando essas letras dos s√≠mbolos. </li></ol><br>  Depois de limpar a poeira, com a ajuda dessas coisas, geraremos um n√∫mero suficiente de imagens problem√°ticas sem uma das letras e ensinaremos especialmente a rede a responder que elas s√£o uma carta vazia. <br><br>  Isso √© tudo, n√£o h√° mais problemas em reconhecer caracteres coreanos, mas a vida coloca as varas nas rodas novamente. <br><br>  O fato √© que, al√©m dos caracteres Hangeul, os textos coreanos tamb√©m consistem em um grande n√∫mero de outros caracteres: pontuadores, caracteres europeus (pelo menos n√∫meros) e caracteres chineses.  Mas eles ocorrem naturalmente com muito menos frequ√™ncia.  Vamos dividi-los em dois grupos: hier√≥glifos e tudo mais, e treinaremos nossa grade para cada um deles.  E faremos um classificador simples, que, de acordo com os resultados da rede para o reconhecimento de caracteres coreanos e para alguns outros sinais (geom√©tricos, em primeiro lugar), responder√° se pelo menos um deles precisa ser lan√ßado e, em caso afirmativo, qual.  Voc√™ precisa reconhecer um pouco de caracteres europeus, para que a grade seja pequena, mas para hier√≥glifos ... Isso poupa que eles raramente sejam encontrados em textos, ent√£o vamos torcer nosso classificador para sugerir muito raramente reconhec√™-los. <br><br>  Em geral, com essas duas grades, o problema de uma resposta adequada surge em imagens que n√£o s√£o s√≠mbolos sobre as quais ela foi treinada, mas falaremos sobre como resolver esse problema outra vez. <br><br><h2>  Realizar experi√™ncias </h2><br>  <b>Primeiro</b> .  Existem duas bases de imagem, vamos cham√°-las de Real e Sint√©tica.  Real consiste em imagens reais obtidas de documentos digitalizados e Imagens sint√©ticas obtidas de fontes.  Na primeira base, existem imagens para 2374 blocos (o restante √© muito raro) e, a partir das fontes, obtivemos todos os 11172 caracteres poss√≠veis.  Vamos tentar treinar a rede nos blocos que est√£o no Real (vamos tirar as imagens das duas bases) e testar nos que est√£o apenas no Synthetic.  Resultados: <br><br><img src="https://habrastorage.org/webt/ee/zf/-p/eezf-phs4-blg-lmo5zizle4yl4.png" alt="imagem"><br><br>  Ou seja, em cerca de 60% dos casos, a rede √© capaz de reconhecer esses blocos, exemplos dos quais n√£o viu durante o treinamento.  A qualidade poderia ter sido maior, se n√£o fosse por um problema: entre as cartas finais, h√° muito raras e, durante o treinamento, a rede viu muito poucas imagens de blocos nelas.  Isso explica a baixa qualidade na √∫ltima coluna.  Se fosse poss√≠vel escolher os 2374 blocos em que estudamos, de uma maneira diferente, a qualidade provavelmente seria notavelmente mais alta. <br><br>  <b>Segundo</b> .  Compare nossa rede com uma rede "normal", que possui o softmax no final.  Gostaria de fazer 11172 em tamanho, mas n√£o conseguimos encontrar um n√∫mero suficiente de imagens reais para blocos raros, por isso nos restringimos a 2374.  A qualidade e a velocidade dessa rede dependem do tamanho das camadas ocultas.  Apenas ensinaremos no Real, test√°-lo (por outro lado, √© claro). <br><br><img src="https://habrastorage.org/webt/hh/xg/uc/hhxgucuke45t66gchwdnmf6qft4.png" alt="imagem"><br><br>  Ou seja, mesmo que nos limitemos a reconhecer apenas 2374 blocos, nossa rede √© mais r√°pida e com o mesmo n√≠vel de qualidade. <br><br>  <b>Terceiro</b> .  Suponha que fomos capazes de chegar a algum lugar com uma base enorme de todos os 11172 blocos coreanos.  Se treinarmos uma rede com softmax, por quanto tempo ela funcionar√° no prazo?  √â caro realizar todas as experi√™ncias, portanto, consideraremos apenas uma rede com 256 tamanhos de camada oculta: <br><br><img src="https://habrastorage.org/webt/lr/8t/4s/lr8t4sb00ghq54azyowxnahpudo.png" alt="imagem"><br><br><h2>  N√≥s obtemos os resultados </h2><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/d5/ig/gzd5ighx6_yl3655fpbh8j5fitu.png"></div><br><br><h2>  Sem eles, nada teria acontecido </h2><br>  Expresso minha gratid√£o √† minha colega Jura Chulinin, a autora original da id√©ia.  √â <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patenteado</a> na R√∫ssia e, al√©m disso, um pedido semelhante foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">registrado</a> no American Patent Office (USPTO).  Muito obrigado √† desenvolvedora Misha Zatsepin, que implementou tudo isso e conduziu todos os experimentos. <br><br>  <i>Yuri Vatlin,</i> <i><br></i>  <i>Chefe do grupo de scripts complexos</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441938/">https://habr.com/ru/post/pt441938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441918/index.html">Estamos em UltraHD Morty! Como assistir a qualquer filme em 4K</a></li>
<li><a href="../pt441920/index.html">Estrat√©gia de seguran√ßa da informa√ß√£o: voc√™ decidiu como seguir em frente?</a></li>
<li><a href="../pt441928/index.html">Inicie o aplicativo no Openshift e compare as ferramentas existentes</a></li>
<li><a href="../pt441932/index.html">Como se antecipar aos concorrentes: SIBUR desenvolve manufatura aditiva</a></li>
<li><a href="../pt441934/index.html">7 etapas para usar o Room. Passo a passo para migrar seu aplicativo para o Room</a></li>
<li><a href="../pt441942/index.html">Quebrando - n√£o construindo. Ou devolu√ß√£o</a></li>
<li><a href="../pt441944/index.html">Por que escolhemos o Lexus RX450h</a></li>
<li><a href="../pt441946/index.html">API REST no Laravel em 100 linhas de c√≥digo</a></li>
<li><a href="../pt441950/index.html">Eclipse Che 7 j√° est√° aqui</a></li>
<li><a href="../pt441952/index.html">Escolhendo um sistema de armazenamento de arquivos para o trabalho em equipe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>