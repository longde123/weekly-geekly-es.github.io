<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå°Ô∏è üçë üå§Ô∏è AsyncIO Micropython: m√©todos de sincronizaci√≥n en programaci√≥n asincr√≥nica üë∑üèª üõ§Ô∏è ‚úÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la programaci√≥n secuencial, constantemente encuentro el deseo obvio de no detener el programa en un momento en que el objetivo de ciertas tareas (p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AsyncIO Micropython: m√©todos de sincronizaci√≥n en programaci√≥n asincr√≥nica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442268/">  En la programaci√≥n secuencial, constantemente encuentro el deseo obvio de no detener el programa en un momento en que el objetivo de ciertas tareas (procesos) son las acciones peri√≥dicas, por ejemplo, sondear los valores del sensor o transmitir datos en un horario a un servidor o la entrada / salida de una gran cantidad de datos.  Lo m√°s simple, por supuesto, es esperar la finalizaci√≥n del evento peri√≥dico y luego, lentamente, continuar realizando otras tareas. <br><a name="habracut"></a><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: do_ext_proc_before() do_internal_proc() sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) do_ext_proc_after()</code> </pre> <cut><br>  Puede abandonar 'sleep ()' y habilitar la verificaci√≥n de algunas condiciones en el ciclo, lo que le permitir√° no retrasar el ciclo principal al menos hasta que ocurra un evento peri√≥dico: <br><br><pre> <code class="python hljs"> start = time() set_timer(start,wait=<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   set_timeout(start,wait_to=7) #   set_irq(alarm) #    while True: curTime = time() do_ext_proc_before() if timer(curTime) or timeout(curTime) or alarm: # if all events crazy start simultaneously - reset all start = time() set_timer(start,wait=5) #   set_timeout(start,wait_to=7) #   set_irq(alarm) #    do_internal_proc() do_ext_proc_after()</span></span></code> </pre><br>  En la programaci√≥n asincr√≥nica, cada tarea se convierte en un proceso independiente y se ejecuta, dependiendo de la implementaci√≥n espec√≠fica, en paralelo o pseudo-paralelo, utilizando una comprensi√≥n interna de las condiciones de espera naturales o artificialmente establecidas o el uso de un recurso limitado, por ejemplo, un disco o un canal de comunicaci√≥n. <br><br><pre> <code class="python hljs"> setTask(do_ext_proc_before()) setTask(do_internal_proc(),timer=<span class="hljs-number"><span class="hljs-number">5</span></span>,timeout=<span class="hljs-number"><span class="hljs-number">7</span></span>,alarm_handler=alarm) setTask(do_ext_proc_after()) runTasks()</code> </pre><br>  Ahora surge un problema que no existe en la programaci√≥n secuencial: qu√© hacer si es necesario sincronizar algunos procesos con sus sistemas as√≠ncronos. <br>  haciendo?  Por ejemplo, despu√©s de haber recibido datos de los sensores, inicie el proceso de enviar datos a un servidor o responda a una emergencia.  Adem√°s, en la programaci√≥n asincr√≥nica, la organizaci√≥n de la entrada / salida asincr√≥nica se resuelve org√°nicamente en el lenguaje est√°ndar, y otras situaciones se resuelven en las bibliotecas. <br><br>  Estudi√© esta pregunta usando la biblioteca extendida asyncio Micropython publicada <br>  Peter Hinch ( <a href="">https://github.com/peterhinch/micropython-async/blob/master/TUTORIAL.md</a> ) <br>  La soluci√≥n m√°s simple es se√±alar el evento a los procesos interesados.  Para hacer esto, use la clase Event (), que contiene varios m√≥dulos <br><br><pre> <code class="python hljs"> Event.Set( timeout = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ) -    (Event = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>), ,     , Event.IsSet() - ,   ,  <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,    <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>   Event.Wait() -   ,     - Done,Timeout,Cancel Event.Data() -  ,     Event.Clear() -   (Event = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>).</code> </pre><br>  La finalizaci√≥n se registra, como regla, por el proceso que est√° esperando que ocurra el evento, por ejemplo, el proceso de visualizaci√≥n en la pantalla o el proceso de guardar datos en el disco, o el tiempo de espera, entonces no hay necesidad de actualizar o guardar los datos, ya que no se actualizan por ning√∫n motivo, o debido a su interrupci√≥n ante la ocurrencia de otro evento importante, por ejemplo, la transici√≥n al modo de suspensi√≥n o reinicio, que puede requerir la liberaci√≥n de todos los procesos pendientes restableciendo los eventos correspondientes. <br><br>  Debe tenerse en cuenta que es recomendable hacer Event.Clear () con un solo proceso, si esto no contradice el algoritmo dado.  De lo contrario, si varios procesos est√°n esperando que ocurra el evento Event.Set (), se supone que Event.Clear () debe ser realizado por uno de los procesos interesados, solo asegur√°ndose de que todos los procesos interesados ‚Äã‚Äãhayan respondido al evento.  Esto complica la l√≥gica de decisi√≥n cuando se usa Event-Class cuando se espera un evento por varios procesos.  Esta situaci√≥n se resuelve estableciendo una cierta cantidad de Clear () del evento que ocurri√≥. <br><br><pre> <code class="python hljs"> Barrier.Set( quantity = <span class="hljs-number"><span class="hljs-number">1</span></span>, timeout = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ) - quantity = <span class="hljs-number"><span class="hljs-number">1</span></span>  Event.Set() Barrier.IsSet() - ,   ,  <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,    <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>   Barrier.Wait() -   ,     - Done,Timeout,Cancel Barrier.Data() -  ,     Barrier.qty -      Barrier.Clear() -   (Event = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>),        Barrier.quantity  ,    ,    </code> </pre><br>  Al mismo tiempo, no se mantiene ninguna contabilidad: qu√© proceso espec√≠fico ya ha respondido y cu√°l a√∫n no, lo que puede dar lugar al problema de volver a reaccionar ante el evento, si esto es esencial para un algoritmo dado.  Si en lugar de Barrier.quantity pasa una lista de nombres de procesos interesados, se puede evitar este conflicto.  Adem√°s, en caso de tiempo de espera o interrupci√≥n del evento, puede determinar qu√© procesos pendientes espec√≠ficos a√∫n no han funcionado.  Todo lo anterior se aplica a una situaci√≥n en la que uno o m√°s procesos est√°n esperando la ocurrencia de un determinado evento, o una situaci√≥n de uno a muchos.  Esto ocurre cuando el proceso o procesos do_ext_proc_after () durante la programaci√≥n secuencial solo se ejecutar√°n despu√©s de completar do_internal_proc ().  Para la conveniencia de una mayor comprensi√≥n, ampliaremos la clase de evento y la clase de barrera existentes en la nueva clase EEvent y la convertiremos en global o en los objetos generados por ella.  Aqu√≠ 'creadores' es el nombre o la lista de nombres de procesos que desencadenan el evento o desbloquean el recurso, 'seguidores' es el nombre o la lista de nombres de procesos que esperan el evento o desbloquean el recurso <br><br><pre> <code class="python hljs"> EEvent.Set (creators, folowers, timeout = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, data = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ) -  <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,        EEvent.IsSet( procName ) - procName -   ID   EEvent.Wait( procName ) EEvent.Clear( procName ) EEvent.Folowers() -    ,      . Barrier.qty = len(EEvent.List()) EEvent.Creators() -   ,    </code> </pre><br>  Usando los m√≥dulos EEvent-Class, podemos describir la soluci√≥n al problema discutido anteriormente. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_internal_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... EEvent.Set (<span class="hljs-string"><span class="hljs-string">'p_Creator'</span></span>,(<span class="hljs-string"><span class="hljs-string">'p_Folwer1'</span></span>,<span class="hljs-string"><span class="hljs-string">'p_Folwer2'</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># exec 'p_Folwer1','p_Folwer2' after event is come in 'p_Creator' ... def do_ext_proc_after1() ... EEvent.Wait('p_Creator') ... EEvent.Clear('p_Folwer1') def do_ext_proc_after1() ... EEvent.Wait('p_Creator') ... EEvent.Clear('p_Folwer2')</span></span></code> </pre><br>  Considere la situaci√≥n opuesta: cuando un proceso est√° esperando la finalizaci√≥n de varios eventos, o una situaci√≥n de "muchos a uno".  En otras palabras, si la ejecuci√≥n de do_internal_proc () puede ser solo despu√©s de la ejecuci√≥n de do_ext_proc_before (). En el caso extremo, cuando un proceso est√° esperando la finalizaci√≥n / ocurrencia de un evento, la tarea puede resolverse usando la clase Event.  Cuando se espera la finalizaci√≥n de varios eventos, por ejemplo, solo despu√©s de mostrar los datos recibidos y enviarlos al servidor, guardarlos en el disco, es necesario que cada proceso ejecutado establezca su participaci√≥n en el evento esperado y espere hasta que se completen todos los procesos. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ext_proc_before1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EEvent</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Creator1'</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Folwer'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_ext_proc_before2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EEvent</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Creator2'</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'p_Folwer'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_internal_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... EEvent.Wait((<span class="hljs-string"><span class="hljs-string">'p_Creator1'</span></span>,<span class="hljs-string"><span class="hljs-string">'p_Creator2'</span></span>)) ... EEvent.Clear(<span class="hljs-string"><span class="hljs-string">'p_Folwer'</span></span>)</code> </pre><br>  Otro aspecto importante de la programaci√≥n asincr√≥nica es compartir un recurso limitado.  Por ejemplo, la actualizaci√≥n de datos debe llevarse a cabo mediante un solo proceso, el resto de los procesos que afirman una acci√≥n similar debe hacer cola o esperar hasta que los datos se actualicen.  Al mismo tiempo, es posible que la lectura de datos para visualizaci√≥n o reenv√≠o no sea cr√≠tica.  Por lo tanto, es necesario conocer la lista de procesos competitivos al organizar eventos relevantes. <br><br>  En el est√°ndar de programaci√≥n as√≠ncrona, esta tarea se resuelve mediante m√≥dulos de clase de bloqueo.  En el caso general, el problema tambi√©n se puede resolver de manera similar a la situaci√≥n de uno a muchos. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_internal_proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># lock activity all 'followers' in list ... EEvent.Set ('p_Creator',('p_Folwer1','p_Folwer2')) # exec 'p_Folwer1','p_Folwer2' after event is come in 'p_Creator' ... def do_ext_proc_after1() ... EEvent.Wait('p_Creator') # waiting for recourse releale if ( EEvent.Set ('p_Folwer1','p_Folwer2')): # lock resource 'p_Folower1' now is 'p_Creator' ... else: EEvent.Wait('p_Folower2') # continue waiting for recourse releale ... EEvent.Clear('p_Folwer1') # releafe recourse def do_ext_proc_after1() ... EEvent.Wait('p_Creator') if ( EEvent.Set ('p_Folwer2','p_Folwer1')): # lock resource 'p_Folower2' now is 'p_Creator' ... else: EEvent.Wait('p_Folower1') # continue waiting for recourse releale ... EEvent.Clear('p_Folwer2') # releafe recourse</span></span></code> </pre><br>  Adem√°s de las opciones consideradas, existen soluciones que limitan el rendimiento, organizan las colas y la programaci√≥n controlada de los procesos, pero en mi actividad a√∫n no ha sido necesario y, como resultado, la necesidad de una comprensi√≥n suficiente para m√≠, aunque no excluyo que haya m√°s elegante o decisiones econ√≥micas <br><br>  En conclusi√≥n, quiero decir que los enfoques secuenciales y asincr√≥nicos tienen el mismo derecho a existir e implementar con √©xito los algoritmos dados.  Por lo tanto, la aplicaci√≥n de este o aquel enfoque est√° determinada por las prioridades del creador, que es m√°s importante para √©l cuando implementa los algoritmos dados, transparencia y legibilidad, velocidad o volumen del c√≥digo resultante. </cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442268/">https://habr.com/ru/post/442268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442258/index.html">Raspado web para desarrolladores web: un breve resumen</a></li>
<li><a href="../442260/index.html">10 comandos de Git que un desarrollador debe saber</a></li>
<li><a href="../442262/index.html">Secreto de firmware</a></li>
<li><a href="../442264/index.html">Eliminando oportunidades para secuestro de tr√°fico</a></li>
<li><a href="../442266/index.html">Delta Chat: mensajer√≠a descentralizada en la parte superior del correo electr√≥nico</a></li>
<li><a href="../442270/index.html">5 errores a evitar al crear modelos 3D para impresi√≥n 3D</a></li>
<li><a href="../442272/index.html">Ir + = versi√≥n de paquete</a></li>
<li><a href="../442274/index.html">Dart 2. Programaci√≥n asincr√≥nica: flujos de datos</a></li>
<li><a href="../442278/index.html">Gu√≠a del usuario de Kibana. Visualizaci√≥n. Parte 6</a></li>
<li><a href="../442280/index.html">Aprendizaje autom√°tico en Dodo. C√≥mo lanzar una nueva direcci√≥n si eres desarrollador</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>