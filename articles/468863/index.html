<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîô üë®üèª üçà Internals Go: variables de bucle de envoltura en cierre üë®üèª‚Äçüíº üê° üïç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy decid√≠ traducir un breve art√≠culo sobre el interior de la implementaci√≥n de los llamados cierres o cierres. Adem√°s, aprender√° c√≥mo Go intenta dete...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Internals Go: variables de bucle de envoltura en cierre</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468863/"><p><img src="https://habrastorage.org/webt/a2/v0/es/a2v0es8qfgkdntuzeattfznxanq.jpeg"></p><br><p>  <em>Hoy decid√≠ traducir un breve art√≠culo sobre el interior de la implementaci√≥n de los llamados cierres o cierres.</em>  <em>Adem√°s, aprender√° c√≥mo Go intenta determinar autom√°ticamente si usar un puntero / enlace o valor en diferentes casos.</em>  <em>Comprender estas cosas evitar√° errores.</em>  <em>¬°Y es que todos estos interiores son muy interesantes, creo!</em> </p><br><p>  <em>Y tambi√©n me gustar√≠a invitarlos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Golang Conf 2019</a> , que se llevar√° a cabo el 7 de octubre en Mosc√∫.</em>  <em>Soy miembro del comit√© del programa de la conferencia, y mis colegas y yo hemos elegido muchos informes igualmente interesantes y muy interesantes.</em>  <em>Lo que amo</em> </p><br><p>  <em>Debajo del corte, le paso la palabra al autor.</em> </p><a name="habracut"></a><br><br><p>  Hay una p√°gina en la wiki de Go titulada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Errores frecuentes</a> .  Curiosamente, solo hay un ejemplo: mal uso de variables de bucle con goroutines: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(val) }() }</code> </pre> <br><p>  Este c√≥digo generar√° el √∫ltimo valor de la matriz de valores len (valores) veces.  Arreglar el c√≥digo es muy simple: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// assume the type of each value is string for _, val := range values { go func(val string) { fmt.Println(val) }(val) }</span></span></code> </pre> <br><p>  Este ejemplo es suficiente para comprender el problema y nunca m√°s cometer un error.  Pero si est√° interesado en conocer los detalles de implementaci√≥n, este art√≠culo le dar√° una comprensi√≥n profunda tanto del problema como de la soluci√≥n. </p><br><h1 id="bazovye-veschi-peredacha-po-znacheniyu-i-peredacha-po-ssylke">  Cosas b√°sicas: pasar por valor y pasar por referencia </h1><br><p>  En Go, hay una diferencia en pasar objetos por valor y por referencia [1].  Comencemos con el <strong>ejemplo 1</strong> [2]: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyval(i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre><br><p>  Probablemente, nadie tiene ninguna duda de que el resultado mostrar√° valores de 0 a 4. Probablemente en alg√∫n tipo de orden aleatorio. </p><br><p>  Veamos el <strong>ejemplo 2</strong> . </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(*n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foobyref(&amp;i) } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Como resultado, se mostrar√° lo siguiente: </p><br><p>  5 5 <br>  5 5 <br>  5 5 <br>  5 5 <br>  5 5 </p><br><p>  Comprender por qu√© el resultado es exactamente esto nos dar√° el 80% de la comprensi√≥n de la esencia del problema.  Por lo tanto, tomemos un tiempo para encontrar las razones. </p><br><p>  Y la respuesta est√° ah√≠ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la especificaci√≥n del lenguaje Go</a> .  La especificaci√≥n lee: </p><br><blockquote>  Las variables declaradas en la declaraci√≥n de inicializaci√≥n se reutilizan en cada bucle. </blockquote><p>  Esto significa que cuando el programa se est√° ejecutando, solo hay un objeto o pieza de memoria para la variable i, y no se crea uno nuevo para cada ciclo.  Este objeto adquiere un nuevo valor en cada iteraci√≥n. </p><br><p>  Veamos la diferencia en el c√≥digo de m√°quina generado [3] para el bucle en los ejemplos 1 y 2. Comencemos con el ejemplo 1. </p><br><pre> <code class="plaintext hljs">0x0026 00038 (go-func-byval.go:14) MOVL $8, (SP) 0x002d 00045 (go-func-byval.go:14) LEAQ "".foobyval¬∑f(SB), CX 0x0034 00052 (go-func-byval.go:14) MOVQ CX, 8(SP) 0x0039 00057 (go-func-byval.go:14) MOVQ AX, 16(SP) 0x003e 00062 (go-func-byval.go:14) CALL runtime.newproc(SB) 0x0043 00067 (go-func-byval.go:13) MOVQ "".i+24(SP), AX 0x0048 00072 (go-func-byval.go:13) INCQ AX 0x004b 00075 (go-func-byval.go:13) CMPQ AX, $5 0x004f 00079 (go-func-byval.go:13) JLT 33</code> </pre> <br><p>  La instrucci√≥n Go se convierte en una llamada a la funci√≥n runtime.newproc.  La mec√°nica de este proceso es muy interesante, pero dejemos esto para el pr√≥ximo art√≠culo.  Ahora estamos m√°s interesados ‚Äã‚Äãen lo que le sucede a la variable i.  Se almacena en el registro AX, que luego se pasa por valor a trav√©s de la pila a la funci√≥n foobyval [4] como argumento.  "Por valor" en este caso parece copiar el valor del registro AX en la pila.  Y cambiar AX en el futuro no afecta lo que se pasa a la funci√≥n foobyval. </p><br><p>  Y as√≠ es como se ve el ejemplo 2: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-func-byref.go:14) LEAQ "".foobyref¬∑f(SB), CX 0x0047 00071 (go-func-byref.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-func-byref.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-func-byref.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-func-byref.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-func-byref.go:13) INCQ (AX) 0x005e 00094 (go-func-byref.go:13) CMPQ (AX), $5 0x0062 00098 (go-func-byref.go:13) JLT 57</code> </pre> <br><p>  El c√≥digo es muy similar, con solo una, pero muy importante, diferencia.  Ahora en AX est√° la direcci√≥n i, y no su valor.  Tenga en cuenta tambi√©n que el incremento y la comparaci√≥n del bucle se realizan en (AX), no en AX.  Y luego, cuando ponemos AX en la pila, resulta que pasamos la direcci√≥n i a la funci√≥n.  El cambio (AX) tambi√©n se ver√° de esta manera en goroutine. </p><br><p>  Sin sorpresas  Al final, pasamos un puntero a un n√∫mero en la funci√≥n foobyref. <br>  Durante la operaci√≥n, el ciclo termina m√°s r√°pido de lo que cualquiera de las gorutinas creadas comienza a funcionar.  Cuando comiencen a trabajar, tendr√°n un puntero a la misma variable i, y no a una copia.  ¬øY cu√°l es el valor de i en este momento?  El valor es 5. El mismo en el que se detuvo el ciclo.  Y es por eso que todas las goroutinas obtienen 5. </p><br><h1 id="metody-so-znacheniem-vs-metody-s-ukazatelem">  M√©todos con un valor VS m√©todos con un puntero </h1><br><p>  Se puede observar un comportamiento similar al crear gorutinas que invocan cualquier m√©todo.  Esto se indica en la misma p√°gina wiki.  Mira el <strong>ejemplo 3</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Este ejemplo muestra los elementos de la matriz ms.  En orden aleatorio, como esper√°bamos.  Un <strong>ejemplo 4</strong> muy similar utiliza un m√©todo de puntero para el m√©todo Show: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mi *MyInt)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(*mi) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ms := []MyInt{<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, m := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ms { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> m.Show() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  Intenta adivinar cu√°l ser√° la conclusi√≥n: 90, impresa cinco veces.  La raz√≥n es la misma que en el ejemplo m√°s simple 2. Aqu√≠ el problema es menos notable debido al az√∫car sint√°ctico en Go cuando se utilizan m√©todos de puntero.  Si en los ejemplos, al cambiar del ejemplo 1 al ejemplo 2, cambiamos i a &amp; i, ¬°aqu√≠ la llamada se ve igual!  m.Show () en ambos ejemplos, y el comportamiento es diferente. </p><br><p>  No me parece una combinaci√≥n muy feliz de dos funciones de Go.  Nada en el lugar de la llamada indica transmisi√≥n por referencia.  Y deber√° observar la implementaci√≥n del m√©todo Show para ver exactamente c√≥mo se realizar√° la llamada (y el m√©todo, por supuesto, puede estar en un archivo o paquete completamente diferente). </p><br><p>  En la mayor√≠a de los casos, esta caracter√≠stica es √∫til.  Escribimos c√≥digo m√°s limpio.  Pero aqu√≠, pasar por referencia conduce a efectos inesperados. </p><br><h1 id="zamykaniya">  Cortocircuitos </h1><br><p>  Finalmente llegamos a los cierres.  Veamos el <strong>ejemplo 5</strong> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(n) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(i) }() } time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) }</code> </pre> <br><p>  √âl imprimir√° lo siguiente: </p><br><p>  5 5 <br>  5 5 <br>  5 5 <br>  5 5 <br>  5 5 </p><br><p>  Y esto a pesar del hecho de que se pasa por valor a foobyval en el cierre.  Similar al ejemplo 1. ¬øPero por qu√©?  Veamos la vista de bucle del ensamblador: </p><br><pre> <code class="plaintext hljs">0x0040 00064 (go-closure.go:14) LEAQ "".main.func1¬∑f(SB), CX 0x0047 00071 (go-closure.go:14) MOVQ CX, 8(SP) 0x004c 00076 (go-closure.go:14) MOVQ AX, 16(SP) 0x0051 00081 (go-closure.go:14) CALL runtime.newproc(SB) 0x0056 00086 (go-closure.go:13) MOVQ "".&amp;i+24(SP), AX 0x005b 00091 (go-closure.go:13) INCQ (AX) 0x005e 00094 (go-closure.go:13) CMPQ (AX), $5 0x0062 00098 (go-closure.go:13) JLT 57</code> </pre> <br><p>  El c√≥digo es muy similar al Ejemplo 2: observe que i est√° representado por una direcci√≥n en el registro AX.  Es decir, pasamos i por referencia.  Y esto a pesar del hecho de que se llama foobyval.  El cuerpo del bucle llama a la funci√≥n usando runtime.newproc, pero ¬øde d√≥nde viene esta funci√≥n? </p><br><p>  Func1 es creado por el compilador, y es un cierre.  El compilador ha asignado el c√≥digo de cierre como una funci√≥n separada y lo llama desde main.  El principal problema con esta asignaci√≥n es c√≥mo manejar las variables que usan los cierres, pero que claramente no son argumentos. </p><br><p>  As√≠ es como se ve el cuerpo de func1: </p><br><pre> <code class="plaintext hljs">0x0000 00000 (go-closure.go:14) MOVQ (TLS), CX 0x0009 00009 (go-closure.go:14) CMPQ SP, 16(CX) 0x000d 00013 (go-closure.go:14) JLS 56 0x000f 00015 (go-closure.go:14) SUBQ $16, SP 0x0013 00019 (go-closure.go:14) MOVQ BP, 8(SP) 0x0018 00024 (go-closure.go:14) LEAQ 8(SP), BP 0x001d 00029 (go-closure.go:15) MOVQ "".&amp;i+24(SP), AX 0x0022 00034 (go-closure.go:15) MOVQ (AX), AX 0x0025 00037 (go-closure.go:15) MOVQ AX, (SP) 0x0029 00041 (go-closure.go:15) CALL "".foobyval(SB) 0x002e 00046 (go-closure.go:16) MOVQ 8(SP), BP 0x0033 00051 (go-closure.go:16) ADDQ $16, SP 0x0037 00055 (go-closure.go:16) RET</code> </pre> <br><p>  Es interesante aqu√≠ que la funci√≥n tiene un argumento de 24 (SP), que es un puntero a int: eche un vistazo a la l√≠nea MOVQ (AX), AX, que toma un valor antes de pasarlo a foobyval.  De hecho, func1 se parece a esto: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { foobyval(*i) }    main   - : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> func1(&amp;i) }</code> </pre><br><p>  Recibi√≥ el equivalente del ejemplo 2, y esto explica la conclusi√≥n.  En lenguaje t√©cnico, dir√≠amos que i es una variable libre dentro de un cierre y dichas variables se capturan por referencia en Go. </p><br><p>  ¬øPero es este siempre el caso?  Sorprendentemente, la respuesta es no.  En algunos casos, las variables libres se capturan por valor.  Aqu√≠ hay una variaci√≥n de nuestro ejemplo: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++ { ii := i <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foobyval(ii) }() }</code> </pre> <br><p>  Este ejemplo generar√° 0, 1, 2, 3, 4 en orden aleatorio.  Pero, ¬øpor qu√© el comportamiento aqu√≠ es diferente del Ejemplo 5? </p><br><p>  Resulta que este comportamiento es un artefacto de la heur√≠stica que utiliza el compilador Go cuando trabaja con cierres. </p><br><h1 id="smotrim-pod-kapot">  Miramos debajo del cap√≥ </h1><br><p>  Si no est√° familiarizado con la arquitectura del compilador Go, le recomiendo que lea mis primeros art√≠culos sobre este tema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> . </p><br><p>  El √°rbol de sintaxis espec√≠fico (en oposici√≥n al abstracto) que se obtiene al analizar el c√≥digo tiene este aspecto: </p><br><pre> <code class="go hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.CallStmt { . Tok: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> . Call: *syntax.CallExpr { . . Fun: *syntax.FuncLit { . . . Type: *syntax.FuncType { . . . . ParamList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . . ResultList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . . } . . . Body: *syntax.BlockStmt { . . . . List: []syntax.Stmt (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: *syntax.ExprStmt { . . . . . . X: *syntax.CallExpr { . . . . . . . Fun: foobyval @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span> . . . . . . . ArgList: []syntax.Expr (<span class="hljs-number"><span class="hljs-number">1</span></span> entries) { . . . . . . . . <span class="hljs-number"><span class="hljs-number">0</span></span>: i @ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-closure.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> . . . . . . . } . . . . . . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . . . . . . } . . . . . } . . . . } . . . . Rbrace: syntax.Pos {} . . . } . . } . . ArgList: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> . . HasDots: <span class="hljs-literal"><span class="hljs-literal">false</span></span> . } }</code> </pre> <br><p>  La funci√≥n llamada est√° representada por el nodo FuncLit, una funci√≥n constante.  Cuando este √°rbol se convierte en AST (√°rbol de sintaxis abstracta), el resultado ser√° resaltar esta funci√≥n constante como una funci√≥n separada.  Esto sucede en el m√©todo noder.funcLit, que vive en gc / closet.go. </p><br><p>  Luego, el comprobador de tipos completa la transformaci√≥n y obtenemos la siguiente representaci√≥n para la funci√≥n en el AST: </p><br><pre> <code class="go hljs">main.func1: . DCLFUNC l(<span class="hljs-number"><span class="hljs-number">14</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) FUNC-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobyval</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(8)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PFUNC)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CALLFUNC</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function"> . . . </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NAME</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">il</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(15)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(0)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PAUTOHEAP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(1)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">used</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span></code> </pre> <br><p>  Tenga en cuenta que el valor pasado a foobyval es NAME-main.i, es decir, se√±alamos expl√≠citamente la variable desde la funci√≥n que envuelve el cierre. </p><br><p>  En esta etapa, entra en funcionamiento la etapa del compilador, llamada capturevars, es decir, "capturando variables".  Su prop√≥sito es decidir c√≥mo capturar las "variables cerradas" (es decir, las variables libres utilizadas en los cierres).  Aqu√≠ hay un comentario de la funci√≥n del compilador correspondiente, que tambi√©n describe la heur√≠stica: </p><br><p>  // capturevars se llama en una fase separada despu√©s de todas las comprobaciones de tipo. <br>  // Decide si capturar la variable por valor o por referencia. <br>  // Utilizamos captura por valor para valores &lt;= 128 bytes que ya no cambian de valor despu√©s de la captura (esencialmente constantes). </p><br><p>  Cuando se llama a capturevars en el Ejemplo 5, decide que la variable de bucle i debe capturarse por referencia, y le agrega el indicador addrtaken apropiado.  Esto se puede ver en la salida AST: </p><br><pre> <code class="go hljs">FOR l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) . LT l(<span class="hljs-number"><span class="hljs-number">13</span></span>) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> . . NAME-main.ia(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) g(<span class="hljs-number"><span class="hljs-number">1</span></span>) l(<span class="hljs-number"><span class="hljs-number">13</span></span>) x(<span class="hljs-number"><span class="hljs-number">0</span></span>) class(PAUTOHEAP) esc(h) tc(<span class="hljs-number"><span class="hljs-number">1</span></span>) addrtaken assigned used <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br><p>  Para la variable de bucle, la heur√≠stica de selecci√≥n "por valor" no funciona, ya que la variable cambia su valor despu√©s de la llamada (recuerde la cita de la especificaci√≥n de que la variable de bucle se reutiliza en cada iteraci√≥n).  Por lo tanto, la variable i se captura por referencia. <br>  En esa variaci√≥n de nuestro ejemplo, donde tenemos ii: = i, ii ya no se usa y, por lo tanto, se captura por valor [5]. </p><br><p>  Por lo tanto, vemos un ejemplo sorprendente de superposici√≥n de dos caracter√≠sticas diferentes de un idioma de una manera inesperada.  En lugar de usar una nueva variable en cada iteraci√≥n del ciclo, Go reutiliza la misma.  Esto, a su vez, conduce a la activaci√≥n de la heur√≠stica y la elecci√≥n de la captura por referencia, y esto conduce a un resultado inesperado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las preguntas frecuentes de Go</a> indican que este comportamiento puede ser un error de dise√±o. </p><br><blockquote>  Este comportamiento (no use una nueva variable) es probablemente un error al dise√±ar un lenguaje.  Quiz√°s lo arreglemos en futuras versiones, pero debido a la compatibilidad con versiones anteriores, no podemos hacer nada en Go versi√≥n 1. </blockquote><p>  Si eres consciente del problema, lo m√°s probable es que no pises este rastrillo.  Pero tenga en cuenta que las variables libres siempre se pueden capturar por referencia.  Para evitar errores, aseg√∫rese de que solo se capturen las variables de solo lectura cuando se usa goroutin.  Esto tambi√©n es importante debido a posibles problemas con los vuelos de datos. </p><br><hr><br><p>  [1] Algunos lectores han notado que, estrictamente hablando, no hay un concepto de "pasar por referencia" en Go, porque todo se pasa por valor, incluidos los punteros.  En este art√≠culo, cuando ve "pasar por referencia", me refiero a "pasar por direcci√≥n" y es expl√≠cito en algunos casos (como pasar &amp; n a una funci√≥n que espera * int), y en algunos casos impl√≠cito, como en los posteriores partes del art√≠culo. </p><br><p>  [2] De aqu√≠ en adelante, uso el tiempo. Dormir como una forma r√°pida y sucia de esperar a que se completen todas las gorutinas.  Sin esto, main terminar√° antes de que las gorutinas comiencen a funcionar.  La forma correcta de hacer esto ser√≠a usar algo como WaitGroup o done channel. </p><br><p>  [3] La representaci√≥n del ensamblador para todos los ejemplos en este art√≠culo se obtuvo usando el comando go tool compile -l -S.  El indicador -l deshabilita la funci√≥n en l√≠nea y hace que el c√≥digo del ensamblador sea m√°s legible. </p><br><p>  [4] Foobyval no se llama directamente, ya que la llamada pasa por ir.  En cambio, la direcci√≥n se pasa como el segundo argumento (16 (SP)) a la funci√≥n runtime.newproc, y el argumento a foobyval (i en este caso) sube la pila. </p><br><p>  [5] Como ejercicio, agregue ii = 10 como la √∫ltima l√≠nea del bucle for (despu√©s de llamar ir).  ¬øCu√°l fue tu conclusi√≥n?  Por qu√© </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468863/">https://habr.com/ru/post/468863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468849/index.html">Procesador desconocido ingenier√≠a inversa en un solo programa</a></li>
<li><a href="../468851/index.html">Implementaci√≥n de animaci√≥n en React Native</a></li>
<li><a href="../468853/index.html">La historia de una aplicaci√≥n exitosa de SPR en un proyecto Legacy</a></li>
<li><a href="../468859/index.html">"Enrutador para bombeo": ajuste del equipo TP-Link para proveedores de Internet</a></li>
<li><a href="../468861/index.html">Positive Technologies da vida a 'Hackable City' en The Standoff Cyberbattle en HITB + CyberWeek</a></li>
<li><a href="../468873/index.html">Un tren privado que una vez arruin√≥ la comodidad.</a></li>
<li><a href="../468875/index.html">Hashrate colapsado y episodio de depreciaci√≥n</a></li>
<li><a href="../468877/index.html">Un enfoque alternativo para mostrar la carga durante la paginaci√≥n</a></li>
<li><a href="../468879/index.html">En los albores de la memoria de la computadora</a></li>
<li><a href="../468883/index.html">Natalia Kozlovskaya: "¬øA qui√©n le importa qui√©n dibuja OpenStreetMap: hombres o mujeres?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>