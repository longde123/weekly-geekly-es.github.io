<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌷 🙋🏾 🧚 Théorie de la programmation: variante 😐 🕖 🕺🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, je m'appelle Dmitry Karlovsky et je ... veux vous parler de la particularité fondamentale des systèmes de types, qui est souvent ou pas du to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Théorie de la programmation: variante</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477448/"><p> Bonjour, je m'appelle Dmitry Karlovsky et je ... veux vous parler de la particularité fondamentale des systèmes de types, qui est souvent ou pas du tout comprise ou est mal comprise à travers le prisme de la mise en œuvre d'un langage particulier, qui, en raison du développement évolutif, a de nombreux atavismes.  Par conséquent, même si vous pensez savoir ce qu'est une «variation», essayez de regarder les problèmes avec un regard neuf.  Nous partirons des bases, donc même un débutant comprendra tout.  Et nous continuons sans eau, de sorte que même les pros seront utiles pour structurer leurs connaissances.  Les exemples de code seront dans un pseudo-langage similaire à TypeScript.  Ensuite, les approches de plusieurs langages réels seront examinées.  Et si vous développez votre propre langue, cet article vous aidera à ne pas marcher sur le râteau de quelqu'un d'autre. </p><br><p><img src="https://habrastorage.org/webt/uz/yw/ly/uzywlybdb47qium0-khvukslzwc.png" alt="et s'il y a des renards?"></p><a name="habracut"></a><br><h1 id="argumenty-i-parametry">  Arguments et paramètres </h1><br><p>  <strong>Le paramètre</strong> est ce que nous acceptons.  Décrivant le type de paramètre, nous avons défini une restriction sur l'ensemble des types qui peuvent nous être transmis.  Quelques exemples: </p><br><pre><code class="plaintext hljs">//   function log( id : string | number ) {} //   class Logger { constructor( readonly id : Natural ) {} } //   class Node&lt; Id extends Number &gt; { id : Id }</code> </pre> <br><p>  <strong>Un argument</strong> est ce que nous transmettons.  Au moment du transfert, l'argument a toujours un type particulier.  Cependant, dans l'analyse statique, un type particulier peut ne pas être connu, c'est pourquoi le compilateur fonctionne à nouveau avec des restrictions de type.  Quelques exemples: </p><br><pre> <code class="plaintext hljs">log( 123 ) //   new Logger( promptStringOrNumber( 'Enter id' ) ) //       new Node( 'root' ) //   ,  </code> </pre> <br><h1 id="podtipy">  Sous-types </h1><br><p>  Les types peuvent former une hiérarchie.  <em>Un sous</em> - <em>type</em> est un cas particulier d'un sur-type.  Un sous-type peut être formé en <strong>rétrécissant l'</strong> ensemble des valeurs possibles d'un supertype.  Par exemple, le type Naturel est un sous-type Entier et Positif.  Et tous les trois sont des sous-types de Real en même temps.  Et le type Prime est un sous-type de tout ce qui précède.  Dans le même temps, les types Positif et Entier se chevauchent, mais aucun d'entre eux ne restreint l'autre. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ca8/220/c10/ca8220c10205146b59dc7f9b4a479c4b.png" alt="image"></p><br><p>  Une autre façon de former un sous-type consiste <strong>à le développer</strong> en le combinant avec un autre type orthogonal à celui-ci.  Par exemple, il y a une «figure de couleur» avec la propriété «couleur», et il y a un «carré» avec la propriété «hauteur».  En combinant ces types, nous obtenons un "carré de couleur".  Et en ajoutant un «cercle» avec son «rayon», nous pouvons obtenir un «cylindre de couleur». </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/484/181/21d/48418121d846dc7aa19d4cd7472638c6.png" alt="image"></p><br><h1 id="ierarhii">  Hiérarchies </h1><br><p>  Pour une narration plus approfondie, nous avons besoin d'une petite hiérarchie d'animaux et d'une hiérarchie similaire de cellules. </p><br><pre> <code class="plaintext hljs">abstract class Animal {} abstract class Pet extends Animal {} class Cat extends Pet {} class Dog extends Pet {} class Fox extends Animal {} class AnimalCage { content : Animal } class PetCage extends AnimalCage { content : Pet } class CatCage extends PetCage { content : Cat } class DogCage extends PetCage { content : Dog } class FoxCage extends AnimalCage { content : Fox }</code> </pre> <br><p>  Tout ce qui suit est un rétrécissement du type ci-dessus.  Une cage avec un animal domestique ne peut contenir que des animaux domestiques, mais pas des animaux sauvages.  Une cage avec un chien ne peut contenir que des chiens. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/397/a01/046/397a01046371d0316d2231db9771de24.png" alt="image"></p><br><h1 id="kovariantnost">  Covariance </h1><br><p>  La plus simple et la plus compréhensible est la <strong>restriction d'un supertype</strong> ou d'une covariance.  Dans l'exemple suivant, le paramètre de fonction est covariant au type spécifié pour lui.  Autrement dit, la fonction peut accepter à la fois ce type lui-même et n'importe quel sous-type de celui-ci, mais ne peut pas accepter de supertypes ou d'autres types. </p><br><pre> <code class="plaintext hljs">function touchPet( cage : PetCage ) : void { log( `touch ${cage.content}` ) } touchPet( new AnimalCage ) // forbid touchPet( new PetCage ) // allow touchPet( new CatCage ) // allow touchPet( new DogCage ) // allow touchPet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/a68/94b/667/a6894b667d46336844466ff63a972011.png" alt="image"></p><br><p>  Comme nous ne changeons rien dans la cage, nous pouvons transférer en toute sécurité des fonctions dans la cage avec le chat, car il ne s'agit que d'un cas spécial de la cage avec un animal de compagnie. </p><br><h1 id="kontravariantnost">  Contravariance </h1><br><p>  Il est un peu plus difficile de comprendre la <strong>restriction</strong> ou la contravariance des <strong>sous</strong> -types.  Dans l'exemple suivant, le paramètre de fonction est contraire au type spécifié pour lui.  Autrement dit, la fonction peut accepter à la fois ce type lui-même et n'importe lequel de ses supertypes, mais ne peut pas accepter de sous-types ou d'autres types. </p><br><pre> <code class="plaintext hljs">function pushPet( cage : PetCage ) : void { const Pet = random() &gt; .5 ? Cat : Dog cage.content = new Pet } pushPet( new AnimalCage ) // allow pushPet( new PetCage ) // allow pushPet( new CatCage ) // forbid pushPet( new DogCage ) // forbid pushPet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9b/a03/b2d/e9ba03b2d3e4f0b82a6f3d9a4f85c05f.png" alt="image"></p><br><p>  Nous ne pouvons pas passer la cage avec le chat, car la fonction peut y placer le chien, ce qui n'est pas autorisé.  Mais la cage avec n'importe quel animal peut être transférée en toute sécurité, car le chat et le chien peuvent y être placés. </p><br><h1 id="invariantnost">  Invariance </h1><br><p>  <strong>La limitation du sous-type et du supertype</strong> peut être simultanée.  Un tel cas est appelé invariance.  Dans l'exemple suivant, le paramètre de fonction est invariant au type spécifié pour lui.  Autrement dit, la fonction ne peut accepter que le type spécifié et pas plus. </p><br><pre> <code class="plaintext hljs">function replacePet( cage : PetCage ) : void { touchPet( cage ) pushPet( cage ) } replacePet( new AnimalCage ) // forbid replacePet( new PetCage ) // allow replacePet( new CatCage ) // forbid replacePet( new DogCage ) // forbid replacePet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/3c3/bec/d6d/3c3becd6de5faa045963dc7c45774d19.png" alt="image"></p><br><p>  La fonction <code>replacePet</code> hérite des limitations de ces fonctions qu'elle utilise en interne: elle a pris la restriction sur le type de <code>pushPet</code> , et la restriction sur le sous-type par <code>pushPet</code> .  Si nous lui donnons une cage avec n'importe quel animal, elle ne pourra pas la transférer vers la fonction touchPet, qui ne sait pas comment travailler avec les renards (un animal sauvage mordra simplement un doigt).  Et si nous transférons la cage avec le chat, cela ne fonctionnera pas d'appeler <code>pushPet</code> . </p><br><h1 id="bivariantnost">  Bivariance </h1><br><p>  On ne peut que mentionner l' <strong>absence</strong> exotique <strong>de restrictions</strong> - la bivariance.  Dans l'exemple suivant, une fonction peut accepter n'importe quel type qui est un sous-type ou un sous-type. </p><br><pre> <code class="plaintext hljs">function enshurePet( cage : PetCage ) : void { if( cage.content instanceof Pet ) return pushPet( cage ) } replacePet( new AnimalCage ) // allow replacePet( new PetCage ) // allow replacePet( new CatCage ) // allow replacePet( new DogCage ) // allow replacePet( new FoxCage ) // forbid</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b8/b85/66f/8b8b8566f8c6db9cd3959f1152202957.png" alt="image"></p><br><p>  Vous pouvez y transférer la cage avec l'animal.  Ensuite, elle vérifiera qu'il y a un animal dans la cage, sinon elle le mettra à l'intérieur d'un animal au hasard.  Et vous pouvez transférer, par exemple, une cage avec un chat, alors elle ne fera rien. </p><br><h1 id="obobscheniya">  Généralisations </h1><br><p>  Certains croient que la variance est en quelque sorte liée aux généralisations.  Souvent parce que la variance est souvent expliquée en utilisant des conteneurs génériques comme exemple.  Cependant, dans toute l'histoire, nous n'avons toujours pas eu une seule généralisation - ce sont des classes entièrement concrètes: </p><br><pre> <code class="plaintext hljs">class AnimalCage { content : Animal } class PetCage extends AnimalCage { content : Pet } class CatCage extends PetCage { content : Cat } class DogCage extends PetCage { content : Dog } class FoxCage extends AnimalCage { content : Fox }</code> </pre> <br><p>  Cela a été fait pour montrer que les problèmes de variance ne sont pas liés aux généralisations.  Des généralisations ne sont nécessaires que pour réduire le copier-coller.  Par exemple, le code ci-dessus peut être réécrit par une simple généralisation: </p><br><pre> <code class="plaintext hljs">class Cage&lt;Animal&gt; { content : Animal }</code> </pre> <br><p>  Et maintenant, vous pouvez créer des instances de n'importe quelle cellule: </p><br><pre> <code class="plaintext hljs">const animalCage = new Cage&lt;Animal&gt;() const petCage = new Cage&lt;Pet&gt;() const catCage = new Cage&lt;Cat&gt;() const dogCage = new Cage&lt;Dog&gt;() const foxCage = new Cage&lt;Fox&gt;()</code> </pre> <br><h1 id="deklaraciya-ogranicheniy">  Déclaration de limitations </h1><br><p>  Veuillez noter que les signatures des quatre fonctions précédemment répertoriées sont exactement les mêmes: </p><br><pre> <code class="plaintext hljs">( cage : PetCage )=&gt; void</code> </pre> <br><p>  Autrement dit, une telle description des paramètres acceptés de la fonction n'est pas complète - on ne peut pas en dire qu'elle peut être transférée à la fonction.  Eh bien, à moins qu'il ne soit clairement vu que cela ne vaut vraiment pas la peine d'y passer la cage avec le renard. </p><br><p>  Par conséquent, dans les langues modernes, il existe un moyen d'indiquer explicitement les restrictions de type d'un paramètre.  Par exemple, les modificateurs d' <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out-generic-modifier">entrée</a> et de <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out-generic-modifier">sortie</a> <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-generic-modifier">en</a> C #: </p><br><pre> <code class="plaintext hljs">interface ICageIn&lt;in T&gt; { T content { set; } } // contravariant generic parameter interface ICageOut&lt;out T&gt; { T content { get; } } // covariant generic parameter interface ICageInOut&lt;T&gt; { T content { get; set; } } // invariant generic parameter</code> </pre> <br><p>  Malheureusement, en C # pour chaque variante de modificateurs, il est nécessaire de démarrer sur une interface distincte.  De plus, si je comprends bien, la bivariance en C # est généralement inexprimable. </p><br><h1 id="vyhodnye-parametry">  Paramètres de sortie </h1><br><p>  Les fonctions peuvent non seulement accepter, mais aussi renvoyer des valeurs.  En général, la valeur de retour peut ne pas être une.  Par exemple, prenez la fonction de prendre une cage avec un animal de compagnie et de rendre deux animaux de compagnie. </p><br><pre> <code class="plaintext hljs">function getPets( input : PetCage ) : [ Pet , Pet ] { return [ input.content , new Cat ] }</code> </pre> <br><p>  Une telle fonction équivaut à une fonction qui prend, en plus d'un paramètre d'entrée, deux sorties supplémentaires. </p><br><pre> <code class="plaintext hljs">function getPets( input : PetCage , output1 : PetCage , output2 : PetCage ) : void { output1.content = input.content output2.content = new Cat }</code> </pre> <br><p>  Le code externe alloue de la mémoire supplémentaire sur la pile afin que la fonction y mette tout ce qu'elle veut y retourner.  Et une fois terminé, le code appelant pourra déjà utiliser ces conteneurs à leurs propres fins. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2c3/292/0b5/2c32920b5a5aeb4ed22923ac97de9267.png" alt="image"></p><br><p>  De l'équivalence de ces deux fonctions, il s'ensuit que les valeurs renvoyées par la fonction, contrairement aux paramètres, sont toujours contravariantes au type de sortie spécifié.  Car une fonction peut leur écrire, mais ne peut pas lire d'eux. </p><br><h1 id="metody-obektov">  Méthodes d'objet </h1><br><p>  Les méthodes objet sont des fonctions qui prennent un pointeur supplémentaire sur un objet comme paramètre implicite.  Autrement dit, les deux fonctions suivantes sont équivalentes. </p><br><pre> <code class="plaintext hljs">class PetCage { pushPet() : void { const Pet = random() &gt; .5 ? Cat : Dog this.content = new Pet } }</code> </pre> <br><pre> <code class="plaintext hljs">function pushPet( this : PetCage ) : void { const Pet = random() &gt; .5 ? Cat : Dog this.content = new Pet }</code> </pre> <br><p>  Cependant, il est important de noter qu'une méthode, contrairement à une fonction régulière, est également membre de la classe, qui est une extension du type.  Cela conduit au fait qu'une restriction de supertype supplémentaire apparaît pour les fonctions appelant cette méthode: </p><br><pre> <code class="plaintext hljs">function fillPetCage( cage : PetCage ) { cage.pushPet() }</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/44e/f44/c67/44ef44c670ebef55ab1d8f248da44b11.png" alt="image"></p><br><p>  Nous ne pouvons pas lui passer un tel sur-type où la méthode <code>pushPet</code> pas encore définie.  Ceci est similaire au cas de l'invariance en ce sens qu'il existe une restriction à la fois par le bas et par le haut.  Cependant, l'emplacement de la méthode <code>pushPet</code> peut être plus élevé dans la hiérarchie.  Et c'est là que sera la limitation de surcharge. </p><br><h1 id="princip-podstanovki--barbary-liskov-lsp">  Principe de substitution de Barbara Lisk (LSP) </h1><br><p>  Beaucoup de gens croient que le rapport d'un sous-type à un sous-type est déterminé non pas sur la base des méthodes susmentionnées de rétrécissement et d'extension du type, mais par la capacité de remplacer le sous-type à n'importe quel endroit où le supertype est utilisé.  Apparemment, la raison de cette erreur est précisément dans le LSP.  Cependant, lisons attentivement la définition de ce principe, en faisant attention à ce qui est primaire et à ce qui est secondaire: </p><br><blockquote>  Les fonctions qui utilisent le type de base doivent pouvoir utiliser des sous-types du type de base sans le savoir et sans violer l'exactitude du programme. </blockquote><p>  Pour les objets immuables (y compris ceux qui ne font pas référence à des objets mutables), ce principe est exécuté automatiquement, car il n'y a pas de place pour prendre la restriction de sous-type. </p><br><p>  Avec les mutables, c'est de plus en plus difficile, car les deux situations suivantes s'excluent mutuellement pour le principe LSP: </p><br><ol><li>  La classe <code>A</code> a une sous-classe de <code>B</code> , où le champ <code>B::foo</code> est un sous-type de <code>A::foo</code> . </li><li>  La classe <code>A</code> a une méthode qui peut changer le champ <code>A::foo</code> . </li></ol><br><p>  En conséquence, il ne reste que trois façons: </p><br><ol><li>  Empêchez les objets d'hériter de restreindre leurs types de champs.  Mais alors vous pouvez pousser un éléphant dans la cage pour un chat. </li><li>  Guidé non pas par le LSP, mais par la variabilité de chaque paramètre de chaque fonction séparément.  Mais alors vous devez réfléchir beaucoup et expliquer au compilateur où se trouvent les restrictions de type. </li><li>  Crache sur tout et va à <del>  le monastère </del>  programmation fonctionnelle, où tous les objets sont immuables, ce qui signifie que leurs paramètres acceptant sont covariants au type déclaré. </li></ol><br><h1 id="typescript">  TypeScript </h1><br><p>  Dans le script temporel, la logique est simple: tous les paramètres de la fonction sont considérés comme covariants (ce qui n'est pas vrai) et les valeurs de retour sont considérées comme contravariantes (ce qui est vrai).  Il a été montré précédemment que les paramètres d'une fonction peuvent avoir absolument n'importe quelle variation, selon ce que fait cette fonction avec ces paramètres.  Par conséquent, ce sont les incidents suivants: </p><br><pre> <code class="plaintext hljs">abstract class Animal { is! : 'cat' | 'dog' | 'fox' } abstract class Pet extends Animal { is! : 'cat' | 'dog' } class Cat extends Pet { is! : 'cat' } class Dog extends Pet { is! : 'dog' } class Fox extends Animal { is! : 'fox' } class Cage&lt;Animal&gt; { content! : Animal } function pushPet( cage : Cage&lt;Pet&gt; ) : void { const Pet = Math.random() &gt; .5 ? Cat : Dog cage.content = new Pet } pushPet( new Cage&lt;Animal&gt;() ) // forbid to push Pet to Animal Cage :-( pushPet( new Cage&lt;Cat&gt;() ) // allow to push Dog to Cat Cage :-(</code> </pre> <br><p>  Pour résoudre ce problème, vous devez aider le compilateur avec un code plutôt simple: </p><br><pre> <code class="plaintext hljs">function pushPet&lt; PetCage extends Cage&lt;Animal&gt; &gt;( cage: Cage&lt;Pet&gt; extends PetCage ? PetCage : never ): void { const Pet = Math.random() &gt; .5 ? Cat : Dog cage.content = new Pet } pushPet( new Cage&lt;Animal&gt;() ) // allow :-) pushPet( new Cage&lt;Pet&gt;() ) // allow :-) pushPet( new Cage&lt;Cat&gt;() ) // forbid :-) pushPet( new Cage&lt;Dog&gt;() ) // forbid :-) pushPet( new Cage&lt;Fox&gt;() ) // forbid :-)</code> </pre> <br><p>  <a href="https://tinyurl.com/uesu87y"><strong>Essayez en ligne</strong></a> </p><br><h1 id="flowjs">  Flowjs </h1><br><p>  FlowJS a un système de type plus avancé.  En particulier, dans la <a href="https://flow.org/en/docs/types/generics/">description</a> du <a href="https://flow.org/en/docs/types/generics/">type, il est possible d'indiquer sa variabilité</a> pour les paramètres généralisés et pour les champs d'objet.  Dans notre exemple de cellule, cela ressemble à ceci: </p><br><pre> <code class="plaintext hljs">class Animal {} class Pet extends Animal {} class Cat extends Pet {} class Dog extends Pet {} class Fox extends Animal {} class Cage&lt; Animal &gt; { content : Animal } function touchPet( cage : { +content : Pet } ) : void { console.log( `touch ${typeof cage.content}` ) } function pushPet( cage: { -content: Pet } ): void { const Pet = Number((0: any)) &gt; .5 ? Cat : Dog cage.content = new Pet } function replacePet( cage : { content : Pet } ) : void { touchPet( cage ) pushPet( cage ) } touchPet( new Cage&lt;Animal&gt; ) // forbid :-) touchPet( new Cage&lt;Pet&gt; ) // allow :-) touchPet( new Cage&lt;Cat&gt; ) // allow :-) touchPet( new Cage&lt;Dog&gt; ) // allow :-) touchPet( new Cage&lt;Fox&gt; ) // forbid :-) pushPet( new Cage&lt;Animal&gt; ) // allow :-) pushPet( new Cage&lt;Pet&gt; ) // allow :-) pushPet( new Cage&lt;Cat&gt; ) // forbid :-) pushPet( new Cage&lt;Dog&gt; ) // forbid :-) pushPet( new Cage&lt;Fox&gt; ) // forbid :-) replacePet( new Cage&lt;Animal&gt; ) // forbid :-) replacePet( new Cage&lt;Pet&gt; ) // allow :-) replacePet( new Cage&lt;Cat&gt; ) // forbid :-) replacePet( new Cage&lt;Dog&gt; ) // forbid :-) replacePet( new Cage&lt;Fox&gt;) // forbid :-)</code> </pre> <br><p>  <a href="https://tinyurl.com/uak4hne"><strong>Essayez en ligne</strong></a> </p><br><p>  La bivariance est ici inexprimable.  Malheureusement, je n'ai pas pu trouver un moyen de régler la variance de manière plus pratique sans décrire explicitement les types de tous les champs.  Par exemple, quelque chose comme ceci: </p><br><pre> <code class="plaintext hljs">function pushPet( cage: Contra&lt; Cage&lt;Pet&gt; , 'content' &gt; ): void { const Pet = Number((0: any)) &gt; .5 ? Cat : Dog cage.content = new Pet }</code> </pre> <br><h1 id="c-sharp">  C forte </h1><br><p>  C # a été initialement conçu sans aucune compréhension des variations.  Cependant, plus tard, des modificateurs de paramètres ont été ajoutés, ce qui a permis au compilateur de vérifier correctement les types d'arguments transmis.  Malheureusement, l'utilisation de ces modificateurs n'est à nouveau pas très pratique. </p><br><pre> <code class="plaintext hljs">using System; abstract class Animal {} abstract class Pet : Animal {} class Cat : Pet {} class Dog : Pet {} class Fox : Animal {} interface ICageIn&lt;in T&gt; { T content { set; } } interface ICageOut&lt;out T&gt; { T content { get; } } interface ICageInOut&lt;T&gt; { T content { get; set; } } class Cage&lt;T&gt; : ICageIn&lt;T&gt;, ICageOut&lt;T&gt;, ICageInOut&lt;T&gt; { public T content { get; set; } } public class Program { static void touchPet( ICageOut&lt;Pet&gt; cage ) { Console.WriteLine( cage.content ); } static void pushPet( ICageIn&lt;Pet&gt; cage ) { cage.content = new Dog(); } static void replacePet( ICageInOut&lt;Pet&gt; cage ) { touchPet( cage as ICageOut&lt;Pet&gt; ); pushPet( cage as ICageIn&lt;Pet&gt; ); } void enshurePet( Cage&lt;Pet&gt; cage ) { if( cage.content is Pet ) return; pushPet( cage as ICageIn&lt;Pet&gt; ); } public static void Main() { var animalCage = new Cage&lt;Animal&gt;(); var petCage = new Cage&lt;Pet&gt;(); var catCage = new Cage&lt;Cat&gt;(); var dogCage = new Cage&lt;Dog&gt;(); var foxCage = new Cage&lt;Fox&gt;(); touchPet( animalCage ); // forbid :-) touchPet( petCage ); // allow :-) touchPet( catCage ); // allow :-) touchPet( dogCage ); // allow :-) touchPet( foxCage ); // forbid :-) pushPet( animalCage ); // allow :-) pushPet( petCage ); // allow :-) pushPet( catCage ); // forbid :-) pushPet( dogCage ); // forbid :-) pushPet( foxCage ); // forbid :-) replacePet( animalCage ); // forbid :-) replacePet( petCage ); // allow :-) replacePet( catCage ); // forbid :-) replacePet( dogCage ); // forbid :-) replacePet( foxCage ); // forbid :-) } }</code> </pre> <br><p>  <a href="https://dotnetfiddle.net/jAx53p"><strong>Essayez en ligne</strong></a> </p><br><h1 id="java">  Java </h1><br><p>  Pour Java, la possibilité de changer de variation a été ajoutée assez tard et uniquement pour les paramètres généralisés, qui eux-mêmes sont apparus relativement récemment.  Si le paramètre n'est pas généralisé, alors problème. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fox</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cage</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T content; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touchPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Cage&lt;? extends Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ System.out.println( cage.content ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Cage&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ cage.content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replacePet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cage&lt;Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ touchPet( cage ); pushPet( cage ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enshurePet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Cage&lt;Pet&gt; cage )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( cage.content <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Pet ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; pushPet( cage ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Cage&lt;Animal&gt; animalCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Animal&gt;(); Cage&lt;Pet&gt; petCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Pet&gt;(); Cage&lt;Cat&gt; catCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Cat&gt;(); Cage&lt;Dog&gt; dogCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Dog&gt;(); Cage&lt;Fox&gt; foxCage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cage&lt;Fox&gt;(); touchPet( animalCage ); <span class="hljs-comment"><span class="hljs-comment">// forbid :-) touchPet( petCage ); // allow :-) touchPet( catCage ); // allow :-) touchPet( dogCage ); // allow :-) touchPet( foxCage ); // forbid :-) pushPet( animalCage ); // allow :-) pushPet( petCage ); // allow :-) pushPet( catCage ); // forbid :-) pushPet( dogCage ); // forbid :-) pushPet( foxCage ); // forbid :-) replacePet( animalCage ); // forbid :-) replacePet( petCage ); // allow :-) replacePet( catCage ); // forbid :-) replacePet( dogCage ); // forbid :-) replacePet( foxCage ); // forbid :-) } }</span></span></code> </pre> <br><p>  <a href="https://paiza.io/projects/pIBVVcjarSB0j0RJY8iNTw%3Flanguage%3Djava"><strong>Essayez en ligne</strong></a> </p><br><h1 id="c">  C ++ </h1><br><p>  Le C ++, grâce à son puissant système de modèles, peut exprimer diverses variantes, mais bien sûr, il y a beaucoup de code. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;typeinfo&gt; #include &lt;type_traits&gt; class Animal {}; class Pet: public Animal {}; class Cat: public Pet {}; class Dog: public Pet {}; class Fox: public Animal {}; template&lt;class T&gt; class Cage { public: T *content; }; template&lt;class T, class = std::enable_if_t&lt;std::is_base_of&lt;Pet, T&gt;::value&gt;&gt; void touchPet(const Cage&lt;T&gt; &amp;cage) { std::cout &lt;&lt; typeid(T).name(); } template&lt;class T, class = std::enable_if_t&lt;std::is_base_of&lt;T, Pet&gt;::value&gt;&gt; void pushPet(Cage&lt;T&gt; &amp;cage) { cage.content = new Dog(); } void replacePet(Cage&lt;Pet&gt; &amp;cage) { touchPet(cage); pushPet(cage); } int main(void) { Cage&lt;Animal&gt; animalCage {new Fox()}; Cage&lt;Pet&gt; petCage {new Cat()}; Cage&lt;Cat&gt; catCage {new Cat()}; Cage&lt;Dog&gt; dogCage {new Dog()}; Cage&lt;Fox&gt; foxCage {new Fox()}; touchPet( animalCage ); // forbid :-) touchPet( petCage ); // allow :-) touchPet( catCage ); // allow :-) touchPet( dogCage ); // allow :-) touchPet( foxCage ); // forbid :-) pushPet( animalCage ); // allow :-) pushPet( petCage ); // allow :-) pushPet( catCage ); // forbid :-) pushPet( dogCage ); // forbid :-) pushPet( foxCage ); // forbid :-) replacePet( animalCage ); // forbid :-) replacePet( petCage ); // allow :-) replacePet( catCage ); // forbid :-) replacePet( dogCage ); // forbid :-) replacePet( foxCage ); // forbid :-) return 0; }</span></span></span></span></code> </pre> <br><p>  <a href="http://cpp.sh/8aqxm"><strong>Essayez en ligne</strong></a> </p><br><h1 id="d">  D </h1><br><p>  D n'a aucun moyen sensé d'indiquer explicitement la variance, mais il sait déduire les types en fonction de leur utilisation. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.random; abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> {</span></span>} abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> :</span></span> Animal { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> Pet {} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> :</span></span> Pet {} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fox</span></span></span><span class="hljs-class"> :</span></span> Animal {} <span class="hljs-function"><span class="hljs-function">class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>{ T content; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touchPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage cage )</span></span></span><span class="hljs-function"> </span></span>{ writeln( cage.content.name ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushPet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage cage )</span></span></span><span class="hljs-function"> </span></span>{ cage.content = ( uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog() : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replacePet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PetCage cage )</span></span></span><span class="hljs-function"> </span></span>{ touchPet( cage ); pushPet( cage); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Cage!Animal animalCage; Cage!Pet petCage; Cage!Cat catCage; Cage!Dog dogCage; Cage!Fox foxCage; animalCage.touchPet(); <span class="hljs-comment"><span class="hljs-comment">// forbid :-) petCage.touchPet(); // allow :-) catCage.touchPet(); // allow :-) dogCage.touchPet(); // allow :-) foxCage.touchPet(); // forbid :-) animalCage.pushPet(); // allow :-) petCage.pushPet(); // allow :-) catCage.pushPet(); // forbid :-) dogCage.pushPet(); // forbid :-) foxCage.pushPet(); // forbid :-) animalCage.replacePet(); // forbid :-) petCage.replacePet(); // allow :-) catCage.replacePet(); // forbid :-) dogCage.replacePet(); // forbid :-) foxCage.replacePet(); // forbid :-) }</span></span></code> </pre> <br><p>  <a href="https://tinyurl.com/qwxwzqg"><strong>Essayez en ligne</strong></a> </p><br><h1 id="epilog">  Épilogue </h1><br><p>  C'est tout pour l'instant.  J'espère que le matériel présenté vous a aidé à mieux comprendre les restrictions sur les types et comment elles sont mises en œuvre dans différentes langues.  Quelque part mieux, quelque part pire, quelque part pas du tout, mais dans l'ensemble - tant bien que mal.  C'est peut-être vous qui développerez le langage dans lequel tout cela sera implémenté à la fois de manière pratique et sécurisée.  En attendant, rejoignez notre <a href="https://teleg.run/lang_idioms">chat télégramme, où nous discutons parfois des concepts théoriques des langages de programmation</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477448/">https://habr.com/ru/post/fr477448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477434/index.html">Maillage de service pour microservices. Partie II, les bases de travailler avec Istio</a></li>
<li><a href="../fr477436/index.html">Comment écrire une simple calculatrice client-serveur (JavaFX + EJB + WildFly)</a></li>
<li><a href="../fr477438/index.html">Comment reprendre le contrôle et réduire la dépendance aux smartphones et aux notifications</a></li>
<li><a href="../fr477440/index.html">Flipper Zero - Multitool Tomagotchi Patsan pour pentester</a></li>
<li><a href="../fr477442/index.html">56 projets Python open source</a></li>
<li><a href="../fr477450/index.html">9 approches pour détecter les anomalies</a></li>
<li><a href="../fr477452/index.html">Le deuxième championnat de programmation: nous analysons les tâches de la piste ML</a></li>
<li><a href="../fr477454/index.html">Fichiers de configuration. Bibliothèque Libconfig et définition des paramètres inutilisés</a></li>
<li><a href="../fr477458/index.html">Avantages et inconvénients de la vie informatique en Écosse</a></li>
<li><a href="../fr477460/index.html">Numéro 26: Formation informatique - problèmes et défis actuels des grandes entreprises</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>