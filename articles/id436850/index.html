<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏾 ▶️ 😪 Kesalahan umum saat menulis tes unit. Kuliah Yandex 🤱🏽 ⛱️ ⏺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda menguasai daftar kecil kesalahan khas yang terjadi saat menulis unit test, Anda bahkan dapat menulisnya. Hari ini ketua kelompok pengembanga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kesalahan umum saat menulis tes unit. Kuliah Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/436850/">  Jika Anda menguasai daftar kecil kesalahan khas yang terjadi saat menulis unit test, Anda bahkan dapat menulisnya.  Hari ini ketua kelompok pengembangan Yandex.Browser untuk Android Konstantin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">kzaikin</a> Zaikin akan berbagi pengalamannya dengan pembaca Habr. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZyGZjpxF9Fo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Saya punya laporan praktis.  Saya berharap itu akan bermanfaat bagi Anda semua - mereka yang sudah menulis tes unit, dan mereka yang hanya berpikir untuk menulis, dan mereka yang mencoba, dan yang belum berhasil. <a name="habracut"></a><br><br>  Kami memiliki proyek yang cukup besar.  Salah satu proyek seluler terbesar di Rusia.  Kami memiliki banyak kode, banyak tes.  Tes dikejar pada setiap permintaan kumpulan, mereka tidak jatuh pada saat yang sama. <br><br>  Siapa yang tahu cakupan tes apa yang dia miliki di proyek?  Nol, oke.  Siapa yang memiliki tes unit dalam proyek?  Dan siapa yang percaya bahwa unit test tidak diperlukan?  Saya tidak melihat ada yang salah dengan itu, ada orang yang dengan tulus meyakini hal ini, dan kisah saya harus membantu mereka untuk diyakinkan tentang hal ini. <br><br>  Untungnya, ribuan tes hijau - kami tidak langsung datang.  Tidak ada peluru perak, dan gagasan utama laporan saya di layar: <br><br><img src="https://habrastorage.org/webt/w1/0y/wm/w10ywme1xumvi5asap7gp0a5iee.jpeg"><br><br>  Pepatah Cina ditulis dalam hieroglif bahwa perjalanan seribu atau lebih dimulai dengan satu langkah.  Tampaknya ada analogi dari ungkapan ini. <br><br>  Kami sudah lama membuat keputusan bahwa kami perlu meningkatkan produk kami, kode kami, dan kami bergerak ke arah ini dengan sengaja.  Dalam perjalanan ini kami bertemu banyak gundukan, garu bawah air, dan berkumpul bersama beberapa keyakinan ini. <br><br><img src="https://habrastorage.org/webt/ks/9z/5w/ks9z5wmzmkghfc-vireaf5rdvvg.jpeg"><br><br>  Mengapa kita perlu tes? <br><br>  Agar fitur lama tidak jatuh saat kami memperkenalkan yang baru.  Untuk memiliki lencana di GitHub.  Untuk memperbaiki fitur yang ada - pemikiran yang mendalam, perlu diungkapkan kepada mereka yang tidak menulis tes.  Agar fitur yang ada tidak jatuh selama refactoring, kami akan melindungi diri dengan tes.  Agar bos mengirim permintaan kumpulan, ya. <br><br>  Pendapat saya - tolong jangan menghubungkannya dengan pendapat tim saya - bahwa tes membantu kami.  Mereka memungkinkan Anda menjalankan kode tanpa memproduksinya, tanpa menginstalnya di perangkat, Anda meluncurkan dan menjalankannya dengan sangat cepat.  Anda dapat melarikan diri semua kasing pojok yang tidak Anda pakai seumur hidup pada perangkat dan dalam produksi, dan tester Anda tidak akan menemukannya.  Tetapi Anda, sebagai pengembang, akan menemukan mereka, memeriksa mereka dan memperbaiki bug pada tahap awal. <br><br>  Sangat penting: tes memberi tahu bagaimana, menurut pengembang, kode harus bekerja dan apa, menurut pengembang, metode Anda harus lakukan.  Ini bukan komentar yang mengusir dan setelah beberapa saat dari yang bermanfaat menjadi berbahaya.  Kebetulan di komentar ada satu hal yang ditulis, dan dalam kode sama sekali berbeda.  Unit test dalam pengertian ini tidak bisa berbohong.  Jika tes berwarna hijau, itu mendokumentasikan apa yang terjadi di sana.  Tes gagal - Anda melanggar maksud utama pengembang. <br><br>  Kontrak komitmen.  Ini bukan kontrak yang ditandatangani dan dicap, tetapi kontrak perangkat lunak untuk perilaku kelas.  Jika Anda menolak, dalam hal ini kontrak akan dilanggar dan tes akan jatuh jika Anda memutuskannya.  Jika kontrak disimpan, tes akan tetap hijau, Anda akan lebih yakin bahwa refactoring Anda benar. <br><br><img src="https://habrastorage.org/webt/pr/z0/fc/prz0fclospeod5fnxeum2bi19gw.jpeg"><br><br>  Ini adalah ide umum dari seluruh laporan saya.  Anda dapat menunjukkan baris pertama dan pergi. <br><br>  Banyak orang berpikir bahwa kode uji adalah kode begitu-begitu, bukan untuk produksi, sehingga Anda dapat menuliskannya begitu-begitu.  Saya sangat tidak setuju dengan ini dan saya pikir tes harus didekati pertama-tama secara bertanggung jawab, serta kode produksi.  Jika Anda mendekati mereka dengan cara yang sama, maka tes akan menguntungkan Anda.  Kalau tidak, itu akan menjadi satu cabul. <br><br>  Lebih khusus, dua baris di bawah ini mengacu pada kode apa saja, tampaknya. <br><br>  KISS - jadikan itu sederhana, bodoh.  Tidak perlu repot.  Tes harus sederhana.  Dan kode produksi harus sederhana, tetapi tes khususnya.  Jika Anda memiliki tes yang mudah dibaca, maka ini akan menjadi tes yang kemungkinan besar ditulis dengan baik, mereka dinyatakan dengan baik, mereka akan mudah untuk diuji.  Bahkan selama permintaan pool, seseorang yang melihat tes baru Anda akan mengerti apa yang ingin Anda katakan.  Dan jika sesuatu rusak, Anda dapat dengan mudah memahami apa yang terjadi. <br><br>  KERING - jangan ulangi diri Anda sendiri.  Dalam pengujian, pengembang sering cenderung menggunakan teknik terlarang yang tampaknya tidak ada yang digunakan dalam produksi - copy paste.  Dalam produksi pengembang yang akan secara aktif menyalin-menempel, mereka tidak akan mengerti.  Dalam tes, sayangnya ini adalah praktik yang normal.  Tidak perlu melakukan ini, karena - baris pertama.  Jika Anda menulis tes dengan jujur, seperti kode yang benar-benar bagus, tes itu akan berguna bagi Anda. <br><br>  Sementara kami mengembangkan ratusan ribu baris kode, menulis ribuan tes, mengumpulkan rake, saya telah mengumpulkan komentar khas pada tes.  Saya cukup malas, dan ketika saya pergi ke kolam meminta dan mengamati kesalahan yang sama, berdasarkan prinsip KERING, saya memutuskan untuk menuliskan masalah-masalah khas ini, dan saya melakukannya terlebih dahulu di Wiki internal dan kemudian memposting bau tes praktis pada GitHub yang dapat Anda ikuti ketika Anda menulis tes. <br><br><img src="https://habrastorage.org/webt/oj/k1/u2/ojk1u2fjmy269sioq4vin6yylua.jpeg"><br><br>  Saya akan mendaftar berdasarkan poin.  Tambahkan penghitung di pikiran Anda jika Anda mengingat bau tes seperti itu.  Jika Anda menghitung sampai lima, Anda dapat mengangkat tangan dan berteriak "Bingo!"  Dan pada akhirnya, saya bertanya-tanya siapa yang menghitung berapa.  Penghitung saya akan sama dengan jumlah poin, saya mengumpulkan semuanya sendiri. <br><br><img src="https://habrastorage.org/webt/nm/pw/8n/nmpw8nk89hl6gmggyims0llmn28.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan GitHub</a></sub></sup> </h5><br>  Hal paling sulit dalam pemrograman lho.  Dan dalam tes ini sangat penting.  Jika Anda tidak menyebutkan nama tes dengan baik, kemungkinan besar Anda tidak akan dapat merumuskan apa yang diperiksa tes. <br><br>  Manusia adalah makhluk yang cukup sederhana, mereka mudah terjebak dalam nama.  Karena itu, saya meminta Anda untuk memanggil tes dengan baik.  Merumuskan tes untuk memverifikasi dan mengikuti aturan sederhana. <br><br><h4>  no_action_or_assertion </h4><br>  Jika nama tes tidak berisi deskripsi tentang apa yang tes periksa, misalnya, Anda memiliki kelas Controller dan Anda menulis tes testController, apa yang Anda periksa?  Apa yang harus dilakukan tes ini?  Kemungkinan besar, tidak ada atau terlalu banyak hal untuk diperiksa.  Tidak ada yang cocok dengan kita.  Karena itu, perlu dituliskan atas nama ujian apa yang kami periksa. <br><br><h4>  long_name </h4><br>  Anda tidak dapat pergi ke ekstrim lainnya.  Nama tes harus cukup pendek sehingga seseorang dapat dengan mudah menguraikannya.  Dalam pengertian ini, Kotlin hebat karena memungkinkan Anda untuk menulis nama uji dalam tanda kutip dengan spasi dalam bahasa Inggris normal.  Mereka lebih mudah dibaca.  Tapi tetap saja, nama-nama panjang berbau. <br><br>  Jika nama tes Anda terlalu panjang, kemungkinan besar Anda memasukkan terlalu banyak metode pengujian dalam satu kelas tes, dan Anda perlu mengklarifikasi apa yang Anda periksa.  Dalam hal ini, Anda perlu membagi kelas tes menjadi beberapa.  Tidak perlu takut dengan ini.  Anda akan memiliki nama kelas uji yang memeriksa nama kode produksi Anda, dan akan ada nama tes pendek. <br><br><h4>  older_prefix </h4><br>  Ini atavisme.  Sebelumnya, di Jawa, semua orang diuji menggunakan JUnit, di mana hingga versi keempat ada kesepakatan bahwa metode pengujian harus dimulai dengan tes kata.  Kebetulan, semua orang masih menyebutnya begitu.  Tetapi ada masalah, dalam bahasa Inggris kata test adalah kata kerja "check".  Orang-orang mudah terjebak dalam jebakan ini, dan tidak lagi menulis kata kerja lainnya.  Tulis testController.  Mudah untuk memeriksa diri Anda sendiri: jika Anda tidak menulis kata kerja apa yang harus dilakukan kelas tes Anda, kemungkinan besar Anda tidak memeriksa sesuatu, Anda tidak menulisnya dengan cukup baik.  Oleh karena itu, saya selalu meminta Anda untuk menghapus kata tes dari nama-nama metode pengujian. <br><br>  Saya mengatakan hal-hal yang sangat sederhana, tetapi anehnya, mereka membantu.  Jika tes disebut baik, kemungkinan besar di bawah tenda mereka akan terlihat bagus.  Ini sangat sederhana. <br><br><img src="https://habrastorage.org/webt/1e/_h/b3/1e_hb3te9onmzprsqcvilm2i_cc.jpeg"><br><br>  Saya sebenarnya membaca id tes bau seperti pada GitHub.  Tautan di bawah, Anda bisa berjalan dan menggunakan. <br><br><h4>  multiple_asserts </h4><br>  Dalam metode tes ada banyak pernyataan.  Jadi mungkin atau tidak?  Mungkin  Apakah itu baik atau buruk?  Saya pikir ini sangat buruk.  Jika Anda menulis beberapa pernyataan dalam suatu metode pengujian, maka Anda memeriksa beberapa pernyataan.  Jika Anda menguji tes Anda dan pernyataan pertama jatuh, akankah tes mencapai pernyataan kedua?  Tidak akan mencapai.  Anda sudah setelah jatuhnya perakitan Anda di suatu tempat di CI mendapatkan bahwa tes jatuh, pergi perbaiki sesuatu, isi lagi, itu akan jatuh pada pernyataan berikutnya.  Mungkin saja. <br><br>  Dalam hal ini, akan jauh lebih keren jika Anda menggergaji metode pengujian ini menjadi beberapa, dan semua metode dengan beberapa penegasan jatuh pada saat yang sama, karena mereka akan diluncurkan secara independen satu sama lain. <br><br>  Beberapa pernyataan lagi dapat menutupi tindakan berbeda yang dilakukan dengan kelas tes.  Saya sarankan menulis satu tes - satu menegaskan.  Pada saat yang sama, pernyataan bisa sangat kompleks.  Kolega saya, dalam laporan pertama, mendemonstrasikan sepotong kode di mana ia menggunakan konstruksi yang menyatakan dengan sangat baik.  Saya sangat suka pertarungan di JUnit, jadi Anda bisa menggunakannya juga.  Untuk pembaca tes, ternyata hanya satu pernyataan singkat.  GitHub memiliki contoh semua bau ini dan cara memperbaikinya.  Ada contoh kode buruk dan beberapa kode bagus.  Ini semua dilakukan dalam bentuk proyek yang dapat Anda unduh, buka, kompilasi, dan jalankan semua tes. <br><br><h4>  many_tests_in_one </h4><br>  Bau selanjutnya sangat erat kaitannya dengan sebelumnya.  Anda melakukan sesuatu dengan sistem - Anda menegaskan.  Melakukan sesuatu yang lain dengan sistem, beberapa operasi panjang - melakukan penegasan - melakukan sesuatu yang lain.  Bahkan, Anda hanya melihat ke dalam beberapa metode, dan Anda mendapatkan metode pengujian yang solid dan bagus. <br><br><h4>  repeating_setup </h4><br>  Ini mengacu pada verbositas.  Jika Anda memiliki kelas tes, dan setiap metode pengujian menjalankan metode yang sama di awal. <br><br>  Kelas uji di mana metode yang sama dijalankan di awal.  Ini sepertinya sedikit, tetapi dalam setiap metode pengujian, sampah ini ada.  Dan jika itu umum untuk semua metode pengujian, maka mengapa tidak menyeretnya ke konstruktor atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Sebelum</a> blok atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Sebelum</a> Setiap blok di JUnit 5. Jika Anda melakukan ini, maka keterbacaan masing-masing metode akan meningkat, ditambah Anda akan menyingkirkan dosa KERING.  Tes semacam itu lebih mudah untuk dipertahankan dan lebih mudah dibaca. <br><br><img src="https://habrastorage.org/webt/jz/e6/pt/jze6ptgcma9s-f62hobgcoj5jbu.jpeg"><br><br>  Keandalan tes sangat penting.  Ada tanda-tanda dimana dapat ditentukan bahwa tes akan menangis, menjadi hijau atau merah.  Ketika pengembang menulisnya, dia yakin itu hijau, dan kemudian karena beberapa alasan tes berubah menjadi hijau atau merah, yang memberi kita rasa sakit dan ketidakpastian pada umumnya bahwa tes itu berguna.  Kami tidak yakin tentang tes, yang berarti kami tidak yakin bahwa itu berguna. <br><br><h4>  acak </h4><br>  Saya sendiri pernah menulis tes yang memiliki Math.random () di dalam, melakukan angka acak, melakukan sesuatu dengan mereka.  Tidak perlu melakukan ini.  Kami berharap bahwa sistem pengujian memasuki sistem pengujian dalam konfigurasi yang sama, dan output darinya juga harus sama.  Karena itu, dalam pengujian unit, misalnya, Anda tidak perlu melakukan operasi apa pun dengan jaringan.  Karena server mungkin tidak merespons, mungkin ada timing yang berbeda, sesuatu yang lain. <br><br>  Jika Anda memerlukan tes yang berfungsi dengan jaringan, lakukan proxy, lokal, apa saja, tetapi tidak perlu pergi ke jaringan nyata.  Ini adalah acak yang sama.  Dan tentu saja, Anda tidak dapat menggunakan data acak.  Jika Anda harus melakukan sesuatu, lakukan beberapa contoh dengan syarat batas, dengan kondisi buruk, tetapi harus dikodekan dengan keras. <br><br><h4>  tread_sleep </h4><br>  Masalah klasik yang dihadapi pengembang saat mencoba menguji beberapa jenis kode asinkron.  Itu yang saya lakukan sesuatu dalam tes, dan kemudian saya harus menunggu sampai selesai.  Bagaimana membuat?  Thread.sleep (), tentu saja. <br><br>  Ada masalah.  Ketika Anda mengembangkan tes Anda, misalnya, Anda melakukannya pada beberapa mesin tik Anda, itu bekerja pada kecepatan tertentu.  Anda menjalankan tes di komputer lain.  Dan apa yang akan terjadi jika sistem Anda tidak berhasil selama Thread.sleep ()?  Tes berubah merah.  Ini tidak terduga.  Oleh karena itu, rekomendasi di sini adalah, jika Anda melakukan operasi asinkron, jangan mengujinya sama sekali.  Hampir semua operasi asinkron dapat digunakan sehingga Anda memiliki semacam mekanisme kondisional yang menyediakan operasi asinkron, dan blok kode yang dijalankan secara sinkron.  Misalnya, AsyncTask di dalam memiliki blok kode yang dijalankan secara sinkron.  Anda dapat dengan mudah mengujinya secara sinkron, tanpa sinkronisasi apa pun.  Tidak perlu menguji AsyncTask sendiri, ini adalah kelas kerangka kerja, mengapa mengujinya?  Braket dan hidup Anda akan lebih mudah. <br><br>  Thread.sleep () banyak kesakitan.  Selain fakta bahwa itu memperburuk keandalan tes, karena memungkinkan mereka untuk menangis karena perbedaan waktu pada perangkat, itu juga memperlambat pelaksanaan tes Anda.  Siapa yang mau tes unitnya, yang harus dijalankan dalam milidetik, akan berjalan selama lima detik, karena saya mengatur tidur tapak? <br><br><h4>  memodifikasi_global </h4><br>  Bau khas bahwa kami mengubah beberapa variabel statis global di awal pengujian untuk memeriksa apakah sistem kami berfungsi dengan benar, tetapi tidak kembali pada akhirnya.  Lalu kami mendapatkan situasi yang keren: pada mesin, pengembang menjalankan tes dalam satu urutan, pertama-tama memeriksa variabel global dengan nilai default, kemudian mengubahnya dalam tes lain, lalu melakukan sesuatu yang lain.  Kedua tes berwarna hijau.  Dan pada CI, hal itu terjadi, tes dimulai dengan urutan terbalik.  Dan salah satu atau kedua tes akan berwarna merah, meskipun semuanya berwarna hijau. <br><br>  Anda perlu membersihkan diri sendiri.  Aturan pramuka dalam pengertian ini: mengubah variabel global - kembali ke keadaan semula.  Lebih baik lagi, pastikan bahwa negara-negara global tidak digunakan.  Tapi ini pemikiran yang lebih dalam.  Ini tentang fakta bahwa tes terkadang menyoroti cacat dalam arsitektur.  Jika kita harus mengubah keadaan global dan mengembalikannya ke keadaan semula untuk menulis tes, apakah kita semua baik-baik saja dalam arsitektur kita?  Apakah kita benar-benar membutuhkan variabel global, misalnya?  Sebagai aturan, Anda dapat melakukannya tanpa mereka dengan menyuntikkan beberapa kelas konteks atau sesuatu, sehingga Anda dapat menginisialisasi ulang, menyuntikkan dan menginisialisasi ulang mereka setiap kali dalam tes. <br><br><h4>  @VisibleForTesting </h4><br>  Uji bau untuk lanjut.  Kebutuhan untuk menggunakan hal seperti itu tidak muncul pada hari pertama, sebagai suatu peraturan.  Anda sudah menguji sesuatu, dan kemudian Anda perlu menerjemahkan kelas ke beberapa keadaan tertentu.  Dan Anda menjadikan diri Anda sebagai pintu belakang.  Anda memiliki kelas produksi, dan Anda membuat metode spesifik yang tidak akan pernah dipanggil dalam produksi, dan melaluinya Anda menyuntikkan sesuatu ke dalam kelas atau mengubah kondisinya.  Dengan demikian, merusak enkapsulasi berbahaya.  Dalam produksi, kelas Anda bekerja entah bagaimana, tetapi dalam tes, pada kenyataannya, ini adalah kelas yang berbeda, Anda berkomunikasi dengannya melalui input dan output lain.  Dan di sini Anda bisa mendapatkan situasi di mana Anda mengubah produksi, tetapi tes tidak menyadarinya.  Tes terus dilakukan melalui pintu belakang dan tidak menyadari bahwa, misalnya, pengecualian mulai menembak pada konstruktor, karena mereka melewati konstruktor lain. <br><br>  Secara umum, Anda harus menguji kelas Anda melalui input dan output yang sama seperti dalam produksi.  Seharusnya tidak ada akses ke metode apa pun hanya untuk tes. <br><br><img src="https://habrastorage.org/webt/dy/sf/s0/dysfs0rl9n6ftff4nt3ftwpy988.jpeg"><br><br>  Berapa dari 15 ribu tes kami yang dilakukan?  Sekitar 20 menit, di setiap permintaan kumpulan, di Team City, pengembang dipaksa untuk menunggu.  Hanya karena 15 ribu banyak tes.  Dan di bagian ini, saya telah mengumpulkan bau yang memperlambat tes.  Meskipun thread_sleep sudah ada di sana. <br><br><h4>  tidak perlu_android_test </h4><br>  Android memiliki tes instrumentasi, mereka cantik, mereka berjalan di perangkat atau emulator.  Ini akan mengangkat proyek Anda sepenuhnya, nyata, tetapi sangat lambat.  Dan bagi mereka, Anda perlu menaikkan emulator keseluruhan.  Bahkan jika Anda membayangkan bahwa Anda memiliki emulator yang dinaikkan pada CI - itu hanya bertepatan dengan yang Anda miliki - maka menjalankan tes pada emulator akan memakan waktu lebih lama daripada pada mesin host, misalnya, menggunakan Robolectric.  Meskipun ada metode lain.  Ini adalah kerangka kerja yang memungkinkan Anda untuk bekerja dengan kelas-kelas dari kerangka kerja Android pada mesin host, di Jawa murni.  Kami menggunakannya dengan cukup aktif.  Sebelumnya, Google agak keren tentang hal itu, tetapi sekarang googler sendiri membicarakannya dalam berbagai laporan, disarankan untuk digunakan. <br><br><h4>  tidak perlu_robolektrik </h4><br>  Kerangka kerja Robolectric ditiru.  Tidak lengkap di sana, meski implementasi semakin jauh, semakin lengkap.  Ini hampir Android nyata, hanya berjalan di desktop, laptop atau CI.  Tapi itu juga tidak perlu digunakan di mana-mana.  Robolectric tidak gratis.  Jika Anda memiliki tes yang secara heroik Anda transfer dari instrumentasi Android ke Robolectric, Anda perlu berpikir - mungkin melangkah lebih jauh, menyingkirkan Robolectric, mengubahnya menjadi tes JUnit yang paling sederhana?  Tes Robolectric membutuhkan waktu untuk menginisialisasi, mencoba memuat sumber daya, menginisialisasi aktivitas, aplikasi, dan yang lainnya.  Butuh beberapa waktu.  Ini bukan yang kedua, itu adalah milidetik, kadang-kadang puluhan dan ratusan.  Tetapi ketika ada banyak tes, bahkan itu penting. <br><br>  Ada teknik yang menyingkirkan Robolectric.  Anda dapat mengisolasi kode Anda melalui antarmuka dengan membungkus seluruh bagian platform dengan antarmuka.  Kemudian hanya akan ada tes host JUnit.  JUnit pada mesin host sangat cepat, ada jumlah minimal overhead, tes tersebut dapat dijalankan dalam ribuan dan puluhan ribu, mereka akan berjalan satu menit, beberapa menit.  Sayangnya, pengujian kami berjalan untuk waktu yang lama karena kami memiliki banyak tes instrumentasi Android, karena kami memiliki bagian asli di browser dan kami terpaksa menjalankannya di emulator atau perangkat nyata.  Kenapa begitu lama. <br><br>  Aku tidak akan membuatmu bosan lagi.  Berapa banyak aroma yang Anda miliki?  Sejauh ini, maksimal tujuh.  Berlangganan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran</a> , letakkan bintang-bintang. <br><br><img src="https://habrastorage.org/webt/ph/cs/52/phcs52po2jsf1lbjumu1um2e3ha.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436850/">https://habr.com/ru/post/id436850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436838/index.html">Memahami jaringan saraf convolutional melalui visualisasi di PyTorch</a></li>
<li><a href="../id436840/index.html">Jalan dari Gloss ke Neuroscience: Podcast Tematik tentang Karier di Media dan Pemasaran Konten</a></li>
<li><a href="../id436842/index.html">Solusi Veeam untuk pencadangan dan pemulihan mesin virtual pada platform Nutanix AHV. Bagian 2</a></li>
<li><a href="../id436846/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 348 (14-20 Januari 2019)</a></li>
<li><a href="../id436848/index.html">NSA mengumumkan rilis alat internal untuk rekayasa balik</a></li>
<li><a href="../id436852/index.html">Memperlambat untuk mendorong pengembangan</a></li>
<li><a href="../id436854/index.html">Rust 1.32 Rilis</a></li>
<li><a href="../id436856/index.html">Rencana pengembangan TI menurut Kementerian Komunikasi: kedaulatan digital, blockchain dalam layanan perumahan dan komunal, perangkat lunak untuk "realitas yang berubah"</a></li>
<li><a href="../id436858/index.html">Esperanto, Elven dan Klingon</a></li>
<li><a href="../id436860/index.html">Dell dan Alienware di CES 2019: panduan untuk semua inovasi besar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>