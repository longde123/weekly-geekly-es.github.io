<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕛 ⛑️ 👨🏾‍⚕️ Plongez dans les espaces de noms Linux, partie 2 🧟 👋🏼 📆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la partie précédente, nous avons simplement plongé nos orteils dans les eaux de l'espace de noms et en même temps , nous avons vu à quel point il...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plongez dans les espaces de noms Linux, partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459574/"><p>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie précédente,</a> nous avons simplement plongé nos orteils dans les eaux de l'espace de noms et en même temps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> nous avons vu à quel point il était facile de démarrer le processus dans un espace de noms UTS isolé.  Dans cet article, nous couvrirons l'espace de noms des utilisateurs. </p><br><p>  Parmi les autres ressources liées à la sécurité, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les espaces de noms d'utilisateurs</a> isolent les identifiants des utilisateurs et des groupes du système.  Dans cet article, nous nous concentrerons uniquement sur les ressources d'ID utilisateur et de groupe (UID et GID, respectivement), car elles jouent un rôle fondamental dans la vérification des autorisations et d'autres activités liées à la sécurité dans tout le système. </p><br><p>  Sous Linux, ces ID sont simplement des entiers qui identifient les utilisateurs et les groupes dans le système.  Et certains d'entre eux sont affectés à chaque processus afin de définir à quelles opérations / ressources ce processus peut et ne peut pas accéder.  La capacité d'un processus à nuire dépend des autorisations associées aux ID attribués. <a name="habracut"></a></p><br><h2 id="user-namespaces">  Espaces de noms d'utilisateurs </h2><br><blockquote>  <em>Nous allons illustrer les capacités des espaces de noms d'utilisateurs en utilisant uniquement des ID utilisateur.</em>  <em>Exactement les mêmes actions s'appliquent aux identifiants de groupe, que nous aborderons plus loin dans ce post.</em> </blockquote><p> L'espace de noms des utilisateurs possède sa propre copie des identifiants d'utilisateurs et de groupes.  L'isolement vous permet ensuite d'associer le processus à un autre ensemble d'ID, en fonction de l'espace de noms d'utilisateurs auquel il appartient actuellement.  Par exemple, le processus <code>$pid</code> peut s'exécuter à partir de la <code>root</code> (UID 0) dans l'espace de noms utilisateur <strong>P</strong> et continue soudainement à s'exécuter à partir du <code>proxy</code> (UID 13) après être passé à un autre espace de noms d'utilisateurs <strong>Q.</strong> </p><br><p>  Les espaces utilisateurs peuvent être imbriqués!  Cela signifie qu'une instance d'un espace de noms personnalisé (parent) peut avoir zéro ou plusieurs espaces de noms enfants, et chaque espace de noms enfants peut, à son tour, avoir ses propres espaces de noms enfants et ainsi de suite ... (jusqu'à atteindre la limite de 32 niveaux d'imbrication).  Lorsqu'un nouvel espace de noms <strong>C</strong> est créé, Linux définit l'espace de noms utilisateur actuel du processus <strong>P</strong> créant <strong>C</strong> comme parent pour <strong>C</strong> et cela ne peut pas être modifié ultérieurement.  Par conséquent, tous les espaces de noms d'utilisateurs ont exactement un parent, formant une structure arborescente d'espaces de noms.  Et, comme dans le cas des arbres, une exception à cette règle se trouve en haut, où nous avons l'espace de noms racine (ou initial, par défaut).  Si vous ne faites pas déjà une sorte de magie de conteneur, c'est probablement l'espace de noms utilisateur auquel tous vos processus appartiennent, car c'est le seul espace de noms utilisateur depuis le démarrage du système. </p><br><blockquote>  <em>Dans cet article, nous utiliserons les invites de commande P $ et C $ pour indiquer le shell qui s'exécute actuellement dans l'espace de noms utilisateur parent <strong>P</strong> et <strong>C</strong> enfant respectivement.</em> </blockquote><br><h2 id="mappingi-user-id">  Mappages d'ID utilisateur </h2><br><p>  L'espace de noms d'utilisateurs, en fait, contient un ensemble d'identifiants et quelques informations reliant ces ID à un ensemble d'ID d'autres espaces de noms d'utilisateurs - ce duo définit une idée complète des ID des processus disponibles dans le système.  Voyons à quoi cela pourrait ressembler: </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ id uid=1000(iffy) gid=1000(iffy)</code> </pre> <br><p>  Dans une autre fenêtre de terminal, commençons le shell en utilisant <code>unshare</code> (le drapeau <code>-U</code> crée un processus dans le nouvel espace de noms utilisateur): </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ unshare -U bash <span class="hljs-comment"><span class="hljs-comment">#    ,     user namespace C$ whoami nobody C$ id uid=65534(nobody) gid=65534(nogroup) C$ ls -l my_file -rw-r--r-- 1 nobody nogroup 0 May 18 16:00 my_file</span></span></code> </pre> <br><p>  Attends une minute, qui?  Maintenant que nous sommes dans un shell imbriqué en <strong>C</strong> , l'utilisateur actuel devient personne?  Nous pourrions avoir deviné que puisque <strong>C</strong> est un nouvel espace de noms d'utilisateurs, le processus peut avoir un type d'ID différent.  Par conséquent, nous ne nous attendions probablement pas à ce qu'il reste <code>iffy</code> , mais <code>nobody</code> n'est pas drôle.  D'un autre côté, c'est super parce que nous avons obtenu l'isolement que nous voulions.  Notre processus a maintenant une substitution d'ID différente (quoique cassée) dans le système - actuellement, il voit tout le monde comme <code>nobody</code> et chaque groupe comme <code>nogroup</code> . </p><br><p>  Les informations liant un UID d'un espace de noms d'utilisateur à un autre sont appelées <strong>mappage d'ID utilisateur</strong> .  Il s'agit d'une table de recherche pour faire correspondre les ID dans l'espace de noms d'utilisateur actuel pour les ID dans d'autres espaces de noms et chaque espace de noms d'utilisateurs est associé à exactement un mappage UID (en plus d'un autre mappage GID pour l'ID de groupe). </p><br><p>  Ce mappage est ce qui est cassé dans notre shell <code>unshare</code> .  Il s'avère que les nouveaux espaces de noms d'utilisateurs commencent par un mappage vide et, par conséquent, Linux utilise l'horrible utilisateur <code>nobody</code> par défaut.  Nous devons résoudre ce problème avant de pouvoir effectuer tout travail utile dans notre nouvel espace de noms.  Par exemple, actuellement, les appels système (tels que <code>setuid</code> ) qui tentent de travailler avec l'UID échouent.  Mais n'ayez pas peur!  Fidèle à la tradition du <em>tout-fichier</em> , Linux présente ce mappage en utilisant le système de fichiers <code>/proc</code> dans <code>/proc/$pid/uid_map</code> (dans <code>/proc/$pid/gid_map</code> pour le GID), où <code>$pid</code> est l'ID du processus.  Nous appellerons ces deux fichiers des fichiers de <em>mappage.</em> </p><br><h2 id="map-fayly">  Fichiers de carte </h2><br><p>  Les fichiers de carte sont des fichiers spéciaux du système.  Quelles sont les particularités?  Eh bien, en renvoyant des contenus différents à chaque lecture, selon ce que votre processus lit.  Par exemple, le fichier de mappage <code>/proc/$pid/uid_maps</code> renvoie le mappage à partir des UID de l'espace de noms utilisateur auquel appartient le processus <code>$pid</code> , des UID dans l'espace de noms utilisateur du processus de lecture.  Et, par conséquent, le contenu renvoyé au processus <strong>X</strong> peut différer de ce qui est retourné au processus <strong>Y</strong> , même s'il lit le même fichier de mappage en même temps. </p><br><p>  En particulier, le processus <strong>X</strong> , qui lit le fichier de carte UID <code>/proc/$pid/uid_map</code> , reçoit un ensemble de chaînes.  Chaque ligne mappe une plage continue d'UID à l'espace de noms utilisateur <strong>C du</strong> processus <code>$pid</code> , correspondant à une plage d'UID dans un autre espace de noms. </p><br><p>  Chaque ligne a le format <code>$fromID $toID $length</code> , où: </p><br><ul><li>  <code>$fromID</code> est l'UID de départ de la plage pour l'espace de noms utilisateur du processus <code>$pid</code> </li><li>  <code>$lenght</code> est la longueur de la plage. </li><li>  La traduction de <code>$toID</code> dépend du processus de lecture <strong>X.</strong>  Si <strong>X</strong> appartient à un autre espace de noms utilisateur <strong>U</strong> , alors <code>$toID</code> est l'UID de départ de la plage en <strong>U</strong> qui mappe à partir de <code>$fromID</code> .  Sinon, <code>$toID</code> est l'UID de début de la plage dans <strong>P</strong> , l'espace de noms utilisateur parent du processus <strong>C.</strong> </li></ul><br><p>  Par exemple, si un processus lit le fichier <code>/proc/1409/uid_map</code> et parmi les lignes reçues, vous pouvez voir <code>15 22 5</code> , puis les UID de 15 à 19 dans l'espace de noms utilisateur du processus <code>1409</code> mappés aux UID 22-26 d'un espace de noms utilisateur distinct du processus de lecture. </p><br><p>  D'un autre côté, si un processus lit le fichier <code>/proc/$$/uid_map</code> (ou un fichier de mappage de n'importe quel processus appartenant au même espace de noms d'utilisateur que le processus de lecture) et reçoit <code>15 22 5</code> , alors les UID de 15 à 19 dans l'espace de noms utilisateur <strong>C</strong> correspond aux UID de 22 à 26 du parent pour l'espace de noms utilisateur <strong>C.</strong> </p><br><p>  Essayons-le: </p><br><pre> <code class="bash hljs">P$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 1442 <span class="hljs-comment"><span class="hljs-comment">#   user namespace... C$ echo $$ 1409 # C      ,     C$ cat /proc/1409/uid_map #  #   namespace P      # UIDs    UID    P$ cat /proc/1442/uid_map 0 0 4294967295 # UIDs  0  4294967294  P  #  4294967295 -  ID no user -  C. C$ cat /proc/1409/uid_map 0 4294967295 4294967295</span></span></code> </pre> <br><p>  Eh bien, ce n'était pas très excitant, car il s'agissait de deux cas extrêmes, mais cela dit quelques choses: </p><br><ol><li>  L'espace de noms utilisateur nouvellement créé aura en fait des fichiers de carte vides. </li><li>  L'UID 4294967295 n'est pas mappable et ne peut pas être utilisé même dans l'espace de noms des utilisateurs <code>root</code> .  Linux utilise cet UID spécifiquement pour indiquer l' <strong>absence d'un ID utilisateur</strong> . </li></ol><br><h2 id="napisanie-uid-map-faylov">  Écriture de fichiers de carte UID </h2><br><p>  Pour corriger notre nouvel espace de noms d'utilisateurs <strong>C</strong> , nous avons juste besoin de fournir nos mappages nécessaires en écrivant leur contenu dans des fichiers de mappage pour tout processus appartenant à <strong>C</strong> (nous ne pouvons pas mettre à jour ce fichier après y avoir écrit).  L'écriture dans ce fichier indique à Linux deux choses: </p><br><ol><li>  Quels UID sont disponibles pour les processus liés à l'espace de noms d'utilisateur cible <strong>C.</strong> </li><li>  Quels UID dans l'espace de noms d'utilisateur actuel correspondent aux UID en <strong>C.</strong> </li></ol><br><p>  Par exemple, si nous écrivons ce qui suit à partir de l'espace de noms utilisateur parent <strong>P</strong> dans le fichier de mappage pour l'espace de noms <strong>C</strong> enfant: </p><br><pre> <code class="plaintext hljs">0 1000 1 3 0 1</code> </pre> <br><p>  nous disons essentiellement à Linux que: </p><br><ol><li>  Pour les processus en <strong>C</strong> , les seuls UID qui existent dans le système sont les UID <code>0</code> et <code>3</code> .  Par exemple, l'appel système <code>setuid(9)</code> se terminera toujours par quelque chose comme un <em>ID utilisateur non valide</em> . </li><li>  Les UID <code>1000</code> et <code>0</code> dans <strong>P</strong> correspondent aux UID <code>0</code> et <code>3</code> dans <strong>C.</strong>  Par exemple, si un processus exécuté avec l'UID <code>1000</code> dans <strong>P</strong> bascule vers <strong>C</strong> , il constatera qu'après la commutation, son UID est devenu <code>root</code> <code>0</code> . </li></ol><br><h2 id="vladelec-prostranstv-imyon-i-privilegii">  Propriétaire d'espace de noms et de privilèges </h2><br><p>  Dans un article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">précédent,</a> nous avons mentionné que lors de la création de nouveaux espaces de noms, l'accès avec le niveau superutilisateur est requis.  Les espaces de noms des utilisateurs n'imposent pas cette exigence.  En fait, une autre caractéristique est qu'ils peuvent <em>posséder d'</em> autres espaces de noms. </p><br><p>  Chaque fois qu'un espace de noms non utilisateur <strong>N est créé</strong> , Linux attribue l'espace de noms utilisateur actuel <strong>P du</strong> processus qui crée <strong>N</strong> comme <em>propriétaire de l'</em> espace <em>de</em> noms <strong>N.</strong>  Si <strong>P est</strong> créé avec d'autres espaces de noms dans le même appel système <code>clone</code> , Linux garantit que <strong>P</strong> sera créé en premier et deviendra le propriétaire d'autres espaces de noms. </p><br><p>  Le propriétaire des espaces de noms est important car un processus demandant une action privilégiée sur une ressource qui n'est pas un espace de noms utilisateur verra ses privilèges UID comparés au propriétaire de cet espace de noms utilisateur et non à l'espace de noms utilisateur racine.  Par exemple, supposons que <strong>P</strong> est l'espace de noms utilisateur parent de l'enfant <strong>C</strong> , et <strong>P</strong> et <strong>C</strong> possèdent leur propre espace de noms réseau <strong>M</strong> et <strong>N,</strong> respectivement.  Un processus peut ne pas avoir les privilèges pour créer les périphériques réseau inclus dans <strong>M</strong> , mais il peut être en mesure de le faire pour <strong>N.</strong> </p><br><p>  La conséquence d'avoir un propriétaire d'espace de noms pour nous est que nous pouvons supprimer l'exigence <code>sudo</code> lors de l'exécution de commandes en utilisant <code>unshare</code> ou <code>unshare</code> si nous demandons également la création d'un espace de noms utilisateur.  Par exemple, <code>unshare -u bash</code> nécessitera <code>sudo</code> , mais <code>unshare -Uu bash</code> ne sera plus: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># UID 1000 --      user namespace P. P$ id uid=1000(iffy) gid=1000(iffy) #           # network namespace. P$ ip link add type veth RTNETLINK answers: Operation not permitted #     ,     #  user  network namespace P$ unshare -nU bash # :  sudo C$ ip link add type veth RTNETLINK answers: Operation not permitted # ,  . ,  # UID 0 (root)    ,  #     nobody.   . C$ echo $$ 13294 #   P,   UID 1000  P  UID 0  C P$ echo "0 1000 1" &gt; /proc/13294/uid_map #   ? C$ id uid=0(root) gid=65534(nogroup) C$ ip link add type veth # !</span></span></code> </pre> <br><blockquote>  <em>Malheureusement, nous réappliquerons l'exigence de superutilisateur dans le prochain post, car <code>isolate</code> besoin <code>root</code> privilèges <code>root</code> dans l'espace de noms utilisateur root afin de configurer correctement les espaces de noms Mount et Network.</em>  <em>Mais nous supprimerons sûrement les privilèges du processus d'équipe pour nous assurer que l'équipe ne dispose pas d'autorisations inutiles.</em> </blockquote><br><h2 id="kak-razreshayutsya-id">  Comment les identifiants sont résolus </h2><br><p>  Nous venons de voir un processus en cours d'exécution en tant qu'utilisateur régulier <code>1000</code> soudainement passé à <code>root</code> .  Ne vous inquiétez pas, il n'y a pas eu d'escalade de privilèges.  Rappelez-vous qu'il ne s'agit que d'un ID de <em>mappage</em> : alors que notre processus <em>pense</em> qu'il s'agit de l' <code>root</code> sur le système, Linux sait que <code>root</code> - dans son cas - signifie l'UID <code>1000</code> habituel (grâce à notre mappage).  Donc, à un moment où les espaces de noms appartenant à son nouvel espace de noms d'utilisateurs (comme l'espace de noms de réseau en <strong>C</strong> ) reconnaissent ses droits en tant que <code>root</code> , d'autres (comme l'espace de noms de réseau en <strong>P</strong> ) ne le font pas.  Par conséquent, le processus ne peut rien faire que l'utilisateur <code>1000</code> ne pourrait pas faire. </p><br><p>  Chaque fois qu'un processus dans un espace de noms d'utilisateurs imbriqué effectue une opération qui nécessite une vérification des autorisations - par exemple, la création d'un fichier - son UID dans cet espace de noms d'utilisateurs est comparé à l'ID utilisateur équivalent dans l'espace de noms d'utilisateurs racine en parcourant les mappages de l'arborescence des espaces de noms jusqu'à la racine.  Il y a un mouvement dans la direction opposée, par exemple, quand il lit les ID utilisateur, comme nous le faisons avec <code>ls -l my_file</code> .  L'UID du propriétaire <code>my_file</code> mappé de l'espace de noms de l'utilisateur racine à celui en cours et l'ID correspondant final (ou personne si le mappage était absent quelque part le long de l'arborescence) est donné au processus de lecture. </p><br><h2 id="gruppovye-id">  ID de groupe </h2><br><p>  Même si nous étions root en <strong>C</strong> , nous sommes toujours associés au terrible <code>nogroup</code> comme identifiant de groupe.  Nous avons juste besoin de faire la même chose pour le <code>/proc/$pid/gid_map</code> .  Avant de pouvoir faire cela, nous devons désactiver l' <code>setgroups</code> système <code>setgroups</code> (ce n'est pas nécessaire si notre utilisateur a déjà une capacité <code>CAP_SETGID</code> dans <strong>P</strong> , mais nous ne le supposerons pas, car cela vient généralement avec des privilèges de superutilisateur) en écrivant "deny" "dans le fichier <code>proc/$pid/setgroups</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  13294 -- pid  unshared  C$ id uid=0(root) gid=65534(nogroup) P$ echo deny &gt; /proc/13294/setgroups P$ echo "0 1000 1" &gt; /proc/13294/gid_map #  group ID   C$ id uid=0(root) gid=0(root)</span></span></code> </pre> <br><h2 id="realizaciya">  Implémentation </h2><br><blockquote>  <em>Le code source de cet article peut être trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .</em> </blockquote><p>  Comme vous pouvez le voir, la gestion des espaces de noms des utilisateurs présente de nombreuses difficultés, mais la mise en œuvre est assez simple.  Tout ce que nous devons faire est d'écrire un tas de lignes dans un fichier - c'était triste de savoir quoi et où écrire.  Sans plus tarder, voici nos objectifs: </p><br><ol><li>  Clonez un processus d'équipe dans son propre espace de noms d'utilisateurs. </li><li>  Écrivez dans les fichiers de mappage UID et GID du processus d'équipe. </li><li>  Réinitialisez tous les privilèges de superutilisateur avant d'exécuter la commande. </li></ol><br><p>  <code>1</code> obtenu en ajoutant simplement l'indicateur <code>CLONE_NEWUSER</code> à notre appel système <code>clone</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER;</code> </pre> <br><p>  Pour <code>2</code> nous ajoutons la fonction <code>prepare_user_ns</code> , qui représente soigneusement un utilisateur régulier <code>1000</code> tant que <code>root</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_userns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> line[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uid = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/uid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/setgroups"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"deny"</span></span>); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/gid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); }</code> </pre> <br><p>  Et nous l'appellerons à partir du processus principal dans l'espace de noms de l'utilisateur parent juste avant de signaler le processus de commande. </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//      . int pipe = params.fd[1]; //      namespace ... prepare_userns(cmd_pid); //   ,     . ...</span></span></code> </pre> <br><p>  Pour l'étape <code>3</code> nous mettons à jour la fonction <code>cmd_exec</code> pour nous assurer que la commande est exécutée à partir de l'utilisateur non privilégié habituel <code>1000</code> que nous avons fourni dans le mappage (rappelez-vous que l'utilisateur root <code>0</code> dans l'espace de noms utilisateur du processus d'équipe est l'utilisateur <code>1000</code> ): </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//   ' '   . await_setup(params-&gt;fd[0]); if (setgid(0) == -1) die("Failed to setgid: %m\n"); if (setuid(0) == -1) die("Failed to setuid: %m\n"); ...</span></span></code> </pre> <br><p>  Et c'est tout!  <code>isolate</code> démarre maintenant le processus dans un espace de noms utilisateur isolé. </p><br><pre> <code class="bash hljs">$ ./isolate sh ===========sh============ $ id uid=0(root) gid=0(root)</code> </pre> <br><p>  Il y avait pas mal de détails dans ce post sur le fonctionnement des espaces de noms d'utilisateurs, mais à la fin, la configuration de l'instance était relativement indolore.  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prochain article,</a> nous verrons la possibilité d'exécuter une commande dans notre propre espace de noms Mount en utilisant <code>isolate</code> (révélant le secret derrière l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> <code>FROM</code> du <code>Dockerfile</code> ).  Là, nous devrons aider Linux un peu plus afin de configurer correctement l'instance. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459574/">https://habr.com/ru/post/fr459574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459560/index.html">Capacités des centres de données de conteneurs: centre de commutation prêt à l'emploi au Myanmar en 50 jours</a></li>
<li><a href="../fr459562/index.html">Programmation différenciable</a></li>
<li><a href="../fr459564/index.html">Ce que les développeurs doivent savoir sur l'entreprise</a></li>
<li><a href="../fr459568/index.html">Lettre verticale dans l'informatique moderne</a></li>
<li><a href="../fr459570/index.html">Beeline montre des annonces à Google bot. Bot mécontent</a></li>
<li><a href="../fr459576/index.html">Extensions Google Chrome utiles pour le programmeur</a></li>
<li><a href="../fr459578/index.html">Système ouvert de gestion de projet du secteur public</a></li>
<li><a href="../fr459580/index.html">Systèmes téléphoniques virtuels</a></li>
<li><a href="../fr459582/index.html">Aperçu: comment acheter des actions de sociétés américaines à la Russie</a></li>
<li><a href="../fr459584/index.html">J'ai trouvé un super programmeur nommé Steve Wozniak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>