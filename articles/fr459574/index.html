<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïõ ‚õëÔ∏è üë®üèæ‚Äç‚öïÔ∏è Plongez dans les espaces de noms Linux, partie 2 üßü üëãüèº üìÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la partie pr√©c√©dente, nous avons simplement plong√© nos orteils dans les eaux de l'espace de noms et en m√™me temps , nous avons vu √† quel point il...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plongez dans les espaces de noms Linux, partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459574/"><p>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie pr√©c√©dente,</a> nous avons simplement plong√© nos orteils dans les eaux de l'espace de noms et en m√™me temps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> nous avons vu √† quel point il √©tait facile de d√©marrer le processus dans un espace de noms UTS isol√©.  Dans cet article, nous couvrirons l'espace de noms des utilisateurs. </p><br><p>  Parmi les autres ressources li√©es √† la s√©curit√©, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les espaces de noms d'utilisateurs</a> isolent les identifiants des utilisateurs et des groupes du syst√®me.  Dans cet article, nous nous concentrerons uniquement sur les ressources d'ID utilisateur et de groupe (UID et GID, respectivement), car elles jouent un r√¥le fondamental dans la v√©rification des autorisations et d'autres activit√©s li√©es √† la s√©curit√© dans tout le syst√®me. </p><br><p>  Sous Linux, ces ID sont simplement des entiers qui identifient les utilisateurs et les groupes dans le syst√®me.  Et certains d'entre eux sont affect√©s √† chaque processus afin de d√©finir √† quelles op√©rations / ressources ce processus peut et ne peut pas acc√©der.  La capacit√© d'un processus √† nuire d√©pend des autorisations associ√©es aux ID attribu√©s. <a name="habracut"></a></p><br><h2 id="user-namespaces">  Espaces de noms d'utilisateurs </h2><br><blockquote>  <em>Nous allons illustrer les capacit√©s des espaces de noms d'utilisateurs en utilisant uniquement des ID utilisateur.</em>  <em>Exactement les m√™mes actions s'appliquent aux identifiants de groupe, que nous aborderons plus loin dans ce post.</em> </blockquote><p> L'espace de noms des utilisateurs poss√®de sa propre copie des identifiants d'utilisateurs et de groupes.  L'isolement vous permet ensuite d'associer le processus √† un autre ensemble d'ID, en fonction de l'espace de noms d'utilisateurs auquel il appartient actuellement.  Par exemple, le processus <code>$pid</code> peut s'ex√©cuter √† partir de la <code>root</code> (UID 0) dans l'espace de noms utilisateur <strong>P</strong> et continue soudainement √† s'ex√©cuter √† partir du <code>proxy</code> (UID 13) apr√®s √™tre pass√© √† un autre espace de noms d'utilisateurs <strong>Q.</strong> </p><br><p>  Les espaces utilisateurs peuvent √™tre imbriqu√©s!  Cela signifie qu'une instance d'un espace de noms personnalis√© (parent) peut avoir z√©ro ou plusieurs espaces de noms enfants, et chaque espace de noms enfants peut, √† son tour, avoir ses propres espaces de noms enfants et ainsi de suite ... (jusqu'√† atteindre la limite de 32 niveaux d'imbrication).  Lorsqu'un nouvel espace de noms <strong>C</strong> est cr√©√©, Linux d√©finit l'espace de noms utilisateur actuel du processus <strong>P</strong> cr√©ant <strong>C</strong> comme parent pour <strong>C</strong> et cela ne peut pas √™tre modifi√© ult√©rieurement.  Par cons√©quent, tous les espaces de noms d'utilisateurs ont exactement un parent, formant une structure arborescente d'espaces de noms.  Et, comme dans le cas des arbres, une exception √† cette r√®gle se trouve en haut, o√π nous avons l'espace de noms racine (ou initial, par d√©faut).  Si vous ne faites pas d√©j√† une sorte de magie de conteneur, c'est probablement l'espace de noms utilisateur auquel tous vos processus appartiennent, car c'est le seul espace de noms utilisateur depuis le d√©marrage du syst√®me. </p><br><blockquote>  <em>Dans cet article, nous utiliserons les invites de commande P $ et C $ pour indiquer le shell qui s'ex√©cute actuellement dans l'espace de noms utilisateur parent <strong>P</strong> et <strong>C</strong> enfant respectivement.</em> </blockquote><br><h2 id="mappingi-user-id">  Mappages d'ID utilisateur </h2><br><p>  L'espace de noms d'utilisateurs, en fait, contient un ensemble d'identifiants et quelques informations reliant ces ID √† un ensemble d'ID d'autres espaces de noms d'utilisateurs - ce duo d√©finit une id√©e compl√®te des ID des processus disponibles dans le syst√®me.  Voyons √† quoi cela pourrait ressembler: </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ id uid=1000(iffy) gid=1000(iffy)</code> </pre> <br><p>  Dans une autre fen√™tre de terminal, commen√ßons le shell en utilisant <code>unshare</code> (le drapeau <code>-U</code> cr√©e un processus dans le nouvel espace de noms utilisateur): </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ unshare -U bash <span class="hljs-comment"><span class="hljs-comment">#    ,     user namespace C$ whoami nobody C$ id uid=65534(nobody) gid=65534(nogroup) C$ ls -l my_file -rw-r--r-- 1 nobody nogroup 0 May 18 16:00 my_file</span></span></code> </pre> <br><p>  Attends une minute, qui?  Maintenant que nous sommes dans un shell imbriqu√© en <strong>C</strong> , l'utilisateur actuel devient personne?  Nous pourrions avoir devin√© que puisque <strong>C</strong> est un nouvel espace de noms d'utilisateurs, le processus peut avoir un type d'ID diff√©rent.  Par cons√©quent, nous ne nous attendions probablement pas √† ce qu'il reste <code>iffy</code> , mais <code>nobody</code> n'est pas dr√¥le.  D'un autre c√¥t√©, c'est super parce que nous avons obtenu l'isolement que nous voulions.  Notre processus a maintenant une substitution d'ID diff√©rente (quoique cass√©e) dans le syst√®me - actuellement, il voit tout le monde comme <code>nobody</code> et chaque groupe comme <code>nogroup</code> . </p><br><p>  Les informations liant un UID d'un espace de noms d'utilisateur √† un autre sont appel√©es <strong>mappage d'ID utilisateur</strong> .  Il s'agit d'une table de recherche pour faire correspondre les ID dans l'espace de noms d'utilisateur actuel pour les ID dans d'autres espaces de noms et chaque espace de noms d'utilisateurs est associ√© √† exactement un mappage UID (en plus d'un autre mappage GID pour l'ID de groupe). </p><br><p>  Ce mappage est ce qui est cass√© dans notre shell <code>unshare</code> .  Il s'av√®re que les nouveaux espaces de noms d'utilisateurs commencent par un mappage vide et, par cons√©quent, Linux utilise l'horrible utilisateur <code>nobody</code> par d√©faut.  Nous devons r√©soudre ce probl√®me avant de pouvoir effectuer tout travail utile dans notre nouvel espace de noms.  Par exemple, actuellement, les appels syst√®me (tels que <code>setuid</code> ) qui tentent de travailler avec l'UID √©chouent.  Mais n'ayez pas peur!  Fid√®le √† la tradition du <em>tout-fichier</em> , Linux pr√©sente ce mappage en utilisant le syst√®me de fichiers <code>/proc</code> dans <code>/proc/$pid/uid_map</code> (dans <code>/proc/$pid/gid_map</code> pour le GID), o√π <code>$pid</code> est l'ID du processus.  Nous appellerons ces deux fichiers des fichiers de <em>mappage.</em> </p><br><h2 id="map-fayly">  Fichiers de carte </h2><br><p>  Les fichiers de carte sont des fichiers sp√©ciaux du syst√®me.  Quelles sont les particularit√©s?  Eh bien, en renvoyant des contenus diff√©rents √† chaque lecture, selon ce que votre processus lit.  Par exemple, le fichier de mappage <code>/proc/$pid/uid_maps</code> renvoie le mappage √† partir des UID de l'espace de noms utilisateur auquel appartient le processus <code>$pid</code> , des UID dans l'espace de noms utilisateur du processus de lecture.  Et, par cons√©quent, le contenu renvoy√© au processus <strong>X</strong> peut diff√©rer de ce qui est retourn√© au processus <strong>Y</strong> , m√™me s'il lit le m√™me fichier de mappage en m√™me temps. </p><br><p>  En particulier, le processus <strong>X</strong> , qui lit le fichier de carte UID <code>/proc/$pid/uid_map</code> , re√ßoit un ensemble de cha√Ænes.  Chaque ligne mappe une plage continue d'UID √† l'espace de noms utilisateur <strong>C du</strong> processus <code>$pid</code> , correspondant √† une plage d'UID dans un autre espace de noms. </p><br><p>  Chaque ligne a le format <code>$fromID $toID $length</code> , o√π: </p><br><ul><li>  <code>$fromID</code> est l'UID de d√©part de la plage pour l'espace de noms utilisateur du processus <code>$pid</code> </li><li>  <code>$lenght</code> est la longueur de la plage. </li><li>  La traduction de <code>$toID</code> d√©pend du processus de lecture <strong>X.</strong>  Si <strong>X</strong> appartient √† un autre espace de noms utilisateur <strong>U</strong> , alors <code>$toID</code> est l'UID de d√©part de la plage en <strong>U</strong> qui mappe √† partir de <code>$fromID</code> .  Sinon, <code>$toID</code> est l'UID de d√©but de la plage dans <strong>P</strong> , l'espace de noms utilisateur parent du processus <strong>C.</strong> </li></ul><br><p>  Par exemple, si un processus lit le fichier <code>/proc/1409/uid_map</code> et parmi les lignes re√ßues, vous pouvez voir <code>15 22 5</code> , puis les UID de 15 √† 19 dans l'espace de noms utilisateur du processus <code>1409</code> mapp√©s aux UID 22-26 d'un espace de noms utilisateur distinct du processus de lecture. </p><br><p>  D'un autre c√¥t√©, si un processus lit le fichier <code>/proc/$$/uid_map</code> (ou un fichier de mappage de n'importe quel processus appartenant au m√™me espace de noms d'utilisateur que le processus de lecture) et re√ßoit <code>15 22 5</code> , alors les UID de 15 √† 19 dans l'espace de noms utilisateur <strong>C</strong> correspond aux UID de 22 √† 26 du parent pour l'espace de noms utilisateur <strong>C.</strong> </p><br><p>  Essayons-le: </p><br><pre> <code class="bash hljs">P$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 1442 <span class="hljs-comment"><span class="hljs-comment">#   user namespace... C$ echo $$ 1409 # C      ,     C$ cat /proc/1409/uid_map #  #   namespace P      # UIDs    UID    P$ cat /proc/1442/uid_map 0 0 4294967295 # UIDs  0  4294967294  P  #  4294967295 -  ID no user -  C. C$ cat /proc/1409/uid_map 0 4294967295 4294967295</span></span></code> </pre> <br><p>  Eh bien, ce n'√©tait pas tr√®s excitant, car il s'agissait de deux cas extr√™mes, mais cela dit quelques choses: </p><br><ol><li>  L'espace de noms utilisateur nouvellement cr√©√© aura en fait des fichiers de carte vides. </li><li>  L'UID 4294967295 n'est pas mappable et ne peut pas √™tre utilis√© m√™me dans l'espace de noms des utilisateurs <code>root</code> .  Linux utilise cet UID sp√©cifiquement pour indiquer l' <strong>absence d'un ID utilisateur</strong> . </li></ol><br><h2 id="napisanie-uid-map-faylov">  √âcriture de fichiers de carte UID </h2><br><p>  Pour corriger notre nouvel espace de noms d'utilisateurs <strong>C</strong> , nous avons juste besoin de fournir nos mappages n√©cessaires en √©crivant leur contenu dans des fichiers de mappage pour tout processus appartenant √† <strong>C</strong> (nous ne pouvons pas mettre √† jour ce fichier apr√®s y avoir √©crit).  L'√©criture dans ce fichier indique √† Linux deux choses: </p><br><ol><li>  Quels UID sont disponibles pour les processus li√©s √† l'espace de noms d'utilisateur cible <strong>C.</strong> </li><li>  Quels UID dans l'espace de noms d'utilisateur actuel correspondent aux UID en <strong>C.</strong> </li></ol><br><p>  Par exemple, si nous √©crivons ce qui suit √† partir de l'espace de noms utilisateur parent <strong>P</strong> dans le fichier de mappage pour l'espace de noms <strong>C</strong> enfant: </p><br><pre> <code class="plaintext hljs">0 1000 1 3 0 1</code> </pre> <br><p>  nous disons essentiellement √† Linux que: </p><br><ol><li>  Pour les processus en <strong>C</strong> , les seuls UID qui existent dans le syst√®me sont les UID <code>0</code> et <code>3</code> .  Par exemple, l'appel syst√®me <code>setuid(9)</code> se terminera toujours par quelque chose comme un <em>ID utilisateur non valide</em> . </li><li>  Les UID <code>1000</code> et <code>0</code> dans <strong>P</strong> correspondent aux UID <code>0</code> et <code>3</code> dans <strong>C.</strong>  Par exemple, si un processus ex√©cut√© avec l'UID <code>1000</code> dans <strong>P</strong> bascule vers <strong>C</strong> , il constatera qu'apr√®s la commutation, son UID est devenu <code>root</code> <code>0</code> . </li></ol><br><h2 id="vladelec-prostranstv-imyon-i-privilegii">  Propri√©taire d'espace de noms et de privil√®ges </h2><br><p>  Dans un article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©c√©dent,</a> nous avons mentionn√© que lors de la cr√©ation de nouveaux espaces de noms, l'acc√®s avec le niveau superutilisateur est requis.  Les espaces de noms des utilisateurs n'imposent pas cette exigence.  En fait, une autre caract√©ristique est qu'ils peuvent <em>poss√©der d'</em> autres espaces de noms. </p><br><p>  Chaque fois qu'un espace de noms non utilisateur <strong>N est cr√©√©</strong> , Linux attribue l'espace de noms utilisateur actuel <strong>P du</strong> processus qui cr√©e <strong>N</strong> comme <em>propri√©taire de l'</em> espace <em>de</em> noms <strong>N.</strong>  Si <strong>P est</strong> cr√©√© avec d'autres espaces de noms dans le m√™me appel syst√®me <code>clone</code> , Linux garantit que <strong>P</strong> sera cr√©√© en premier et deviendra le propri√©taire d'autres espaces de noms. </p><br><p>  Le propri√©taire des espaces de noms est important car un processus demandant une action privil√©gi√©e sur une ressource qui n'est pas un espace de noms utilisateur verra ses privil√®ges UID compar√©s au propri√©taire de cet espace de noms utilisateur et non √† l'espace de noms utilisateur racine.  Par exemple, supposons que <strong>P</strong> est l'espace de noms utilisateur parent de l'enfant <strong>C</strong> , et <strong>P</strong> et <strong>C</strong> poss√®dent leur propre espace de noms r√©seau <strong>M</strong> et <strong>N,</strong> respectivement.  Un processus peut ne pas avoir les privil√®ges pour cr√©er les p√©riph√©riques r√©seau inclus dans <strong>M</strong> , mais il peut √™tre en mesure de le faire pour <strong>N.</strong> </p><br><p>  La cons√©quence d'avoir un propri√©taire d'espace de noms pour nous est que nous pouvons supprimer l'exigence <code>sudo</code> lors de l'ex√©cution de commandes en utilisant <code>unshare</code> ou <code>unshare</code> si nous demandons √©galement la cr√©ation d'un espace de noms utilisateur.  Par exemple, <code>unshare -u bash</code> n√©cessitera <code>sudo</code> , mais <code>unshare -Uu bash</code> ne sera plus: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># UID 1000 --      user namespace P. P$ id uid=1000(iffy) gid=1000(iffy) #           # network namespace. P$ ip link add type veth RTNETLINK answers: Operation not permitted #     ,     #  user  network namespace P$ unshare -nU bash # :  sudo C$ ip link add type veth RTNETLINK answers: Operation not permitted # ,  . ,  # UID 0 (root)    ,  #     nobody.   . C$ echo $$ 13294 #   P,   UID 1000  P  UID 0  C P$ echo "0 1000 1" &gt; /proc/13294/uid_map #   ? C$ id uid=0(root) gid=65534(nogroup) C$ ip link add type veth # !</span></span></code> </pre> <br><blockquote>  <em>Malheureusement, nous r√©appliquerons l'exigence de superutilisateur dans le prochain post, car <code>isolate</code> besoin <code>root</code> privil√®ges <code>root</code> dans l'espace de noms utilisateur root afin de configurer correctement les espaces de noms Mount et Network.</em>  <em>Mais nous supprimerons s√ªrement les privil√®ges du processus d'√©quipe pour nous assurer que l'√©quipe ne dispose pas d'autorisations inutiles.</em> </blockquote><br><h2 id="kak-razreshayutsya-id">  Comment les identifiants sont r√©solus </h2><br><p>  Nous venons de voir un processus en cours d'ex√©cution en tant qu'utilisateur r√©gulier <code>1000</code> soudainement pass√© √† <code>root</code> .  Ne vous inqui√©tez pas, il n'y a pas eu d'escalade de privil√®ges.  Rappelez-vous qu'il ne s'agit que d'un ID de <em>mappage</em> : alors que notre processus <em>pense</em> qu'il s'agit de l' <code>root</code> sur le syst√®me, Linux sait que <code>root</code> - dans son cas - signifie l'UID <code>1000</code> habituel (gr√¢ce √† notre mappage).  Donc, √† un moment o√π les espaces de noms appartenant √† son nouvel espace de noms d'utilisateurs (comme l'espace de noms de r√©seau en <strong>C</strong> ) reconnaissent ses droits en tant que <code>root</code> , d'autres (comme l'espace de noms de r√©seau en <strong>P</strong> ) ne le font pas.  Par cons√©quent, le processus ne peut rien faire que l'utilisateur <code>1000</code> ne pourrait pas faire. </p><br><p>  Chaque fois qu'un processus dans un espace de noms d'utilisateurs imbriqu√© effectue une op√©ration qui n√©cessite une v√©rification des autorisations - par exemple, la cr√©ation d'un fichier - son UID dans cet espace de noms d'utilisateurs est compar√© √† l'ID utilisateur √©quivalent dans l'espace de noms d'utilisateurs racine en parcourant les mappages de l'arborescence des espaces de noms jusqu'√† la racine.  Il y a un mouvement dans la direction oppos√©e, par exemple, quand il lit les ID utilisateur, comme nous le faisons avec <code>ls -l my_file</code> .  L'UID du propri√©taire <code>my_file</code> mapp√© de l'espace de noms de l'utilisateur racine √† celui en cours et l'ID correspondant final (ou personne si le mappage √©tait absent quelque part le long de l'arborescence) est donn√© au processus de lecture. </p><br><h2 id="gruppovye-id">  ID de groupe </h2><br><p>  M√™me si nous √©tions root en <strong>C</strong> , nous sommes toujours associ√©s au terrible <code>nogroup</code> comme identifiant de groupe.  Nous avons juste besoin de faire la m√™me chose pour le <code>/proc/$pid/gid_map</code> .  Avant de pouvoir faire cela, nous devons d√©sactiver l' <code>setgroups</code> syst√®me <code>setgroups</code> (ce n'est pas n√©cessaire si notre utilisateur a d√©j√† une capacit√© <code>CAP_SETGID</code> dans <strong>P</strong> , mais nous ne le supposerons pas, car cela vient g√©n√©ralement avec des privil√®ges de superutilisateur) en √©crivant "deny" "dans le fichier <code>proc/$pid/setgroups</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  13294 -- pid  unshared  C$ id uid=0(root) gid=65534(nogroup) P$ echo deny &gt; /proc/13294/setgroups P$ echo "0 1000 1" &gt; /proc/13294/gid_map #  group ID   C$ id uid=0(root) gid=0(root)</span></span></code> </pre> <br><h2 id="realizaciya">  Impl√©mentation </h2><br><blockquote>  <em>Le code source de cet article peut √™tre trouv√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .</em> </blockquote><p>  Comme vous pouvez le voir, la gestion des espaces de noms des utilisateurs pr√©sente de nombreuses difficult√©s, mais la mise en ≈ìuvre est assez simple.  Tout ce que nous devons faire est d'√©crire un tas de lignes dans un fichier - c'√©tait triste de savoir quoi et o√π √©crire.  Sans plus tarder, voici nos objectifs: </p><br><ol><li>  Clonez un processus d'√©quipe dans son propre espace de noms d'utilisateurs. </li><li>  √âcrivez dans les fichiers de mappage UID et GID du processus d'√©quipe. </li><li>  R√©initialisez tous les privil√®ges de superutilisateur avant d'ex√©cuter la commande. </li></ol><br><p>  <code>1</code> obtenu en ajoutant simplement l'indicateur <code>CLONE_NEWUSER</code> √† notre appel syst√®me <code>clone</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER;</code> </pre> <br><p>  Pour <code>2</code> nous ajoutons la fonction <code>prepare_user_ns</code> , qui repr√©sente soigneusement un utilisateur r√©gulier <code>1000</code> tant que <code>root</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_userns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> line[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uid = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/uid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/setgroups"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"deny"</span></span>); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/gid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); }</code> </pre> <br><p>  Et nous l'appellerons √† partir du processus principal dans l'espace de noms de l'utilisateur parent juste avant de signaler le processus de commande. </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//      . int pipe = params.fd[1]; //      namespace ... prepare_userns(cmd_pid); //   ,     . ...</span></span></code> </pre> <br><p>  Pour l'√©tape <code>3</code> nous mettons √† jour la fonction <code>cmd_exec</code> pour nous assurer que la commande est ex√©cut√©e √† partir de l'utilisateur non privil√©gi√© habituel <code>1000</code> que nous avons fourni dans le mappage (rappelez-vous que l'utilisateur root <code>0</code> dans l'espace de noms utilisateur du processus d'√©quipe est l'utilisateur <code>1000</code> ): </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//   ' '   . await_setup(params-&gt;fd[0]); if (setgid(0) == -1) die("Failed to setgid: %m\n"); if (setuid(0) == -1) die("Failed to setuid: %m\n"); ...</span></span></code> </pre> <br><p>  Et c'est tout!  <code>isolate</code> d√©marre maintenant le processus dans un espace de noms utilisateur isol√©. </p><br><pre> <code class="bash hljs">$ ./isolate sh ===========sh============ $ id uid=0(root) gid=0(root)</code> </pre> <br><p>  Il y avait pas mal de d√©tails dans ce post sur le fonctionnement des espaces de noms d'utilisateurs, mais √† la fin, la configuration de l'instance √©tait relativement indolore.  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prochain article,</a> nous verrons la possibilit√© d'ex√©cuter une commande dans notre propre espace de noms Mount en utilisant <code>isolate</code> (r√©v√©lant le secret derri√®re l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> <code>FROM</code> du <code>Dockerfile</code> ).  L√†, nous devrons aider Linux un peu plus afin de configurer correctement l'instance. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459574/">https://habr.com/ru/post/fr459574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459560/index.html">Capacit√©s des centres de donn√©es de conteneurs: centre de commutation pr√™t √† l'emploi au Myanmar en 50 jours</a></li>
<li><a href="../fr459562/index.html">Programmation diff√©renciable</a></li>
<li><a href="../fr459564/index.html">Ce que les d√©veloppeurs doivent savoir sur l'entreprise</a></li>
<li><a href="../fr459568/index.html">Lettre verticale dans l'informatique moderne</a></li>
<li><a href="../fr459570/index.html">Beeline montre des annonces √† Google bot. Bot m√©content</a></li>
<li><a href="../fr459576/index.html">Extensions Google Chrome utiles pour le programmeur</a></li>
<li><a href="../fr459578/index.html">Syst√®me ouvert de gestion de projet du secteur public</a></li>
<li><a href="../fr459580/index.html">Syst√®mes t√©l√©phoniques virtuels</a></li>
<li><a href="../fr459582/index.html">Aper√ßu: comment acheter des actions de soci√©t√©s am√©ricaines √† la Russie</a></li>
<li><a href="../fr459584/index.html">J'ai trouv√© un super programmeur nomm√© Steve Wozniak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>