<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😦 🐫 🏇🏿 Crear un sistema de extensión en la biblioteca Qt 📿 🚲 🛬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Complementos (extensiones) 


 Extensions es una biblioteca dinámica compartida diseñada para cargarse durante la ejecución de la aplicación principal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crear un sistema de extensión en la biblioteca Qt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448806/"><h2>  Complementos (extensiones) </h2><br><p>  Extensions es una biblioteca dinámica compartida diseñada para cargarse durante la ejecución de la aplicación principal, que necesariamente debe implementar al menos una interfaz especial. <br><br>  Las extensiones se dividen en dos tipos: <br><br></p><ul><li>  Para Qt </li><li>  Para aplicaciones nativas </li></ul><br>  Vamos a descubrir cómo crear su propio sistema de extensión y las extensiones en sí. <br><p>  La comunicación con la extensión se lleva a cabo utilizando la interfaz (señales, slots y métodos de clase).  La aplicación carga la extensión utilizando la clase <b><font color="blue">QPluginLoader</font></b> .  Para cargar la extensión, se utiliza el método <b><font color="blue">instancia ()</font></b> , que crea un objeto de extensión y le devuelve un puntero.  El método <b><font color="blue">unload () se</font></b> usa para descargar la extensión. <br><br></p><h2>  <font color="red">Parte 1</font> </h2><br>  En el primer ejemplo, cree una extensión que usará una función (algoritmo, fórmula) de la extensión. <br><br>  El esquema visual del proyecto tendrá el siguiente aspecto. <br><br><img src="https://habrastorage.org/webt/pg/5w/ey/pg5weydm_vy5o2iqqfxw0mzl8qa.png"><br><a name="habracut"></a><br><p></p><h3>  <font color="blueviolet">Etapa 1:</font> </h3><br><p>  El primer paso es crear una clase de interfaz heredada de QObject, como interfaz habrá un método que acepte una variable de tipo QString y devuelva la misma cadena en mayúsculas.  Usando la macro Q_DECLARE_INTERFACE, establecemos el identificador de las interfaces, el compilador c genera metainformación para la cadena del identificador.  Este módulo es el protocolo de comunicación entre el complemento y el programa principal y se utilizará en el proyecto del complemento y en el proyecto principal. <br><br>  La clase se verá de la siguiente manera. <br><br></p><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--------------------------------------------------- #ifndef INTERFACE_H #define INTERFACE_H //------------------------------------------------------- #include &lt;QObject&gt; //------------------------------------------------------- class interface : public QObject { public: /// \brief   virtual ~interface() = default; /// \brief   virtual QString getUpString(QString str) = 0; }; //---------------------------------------------------------------- Q_DECLARE_INTERFACE(interface, "com.mysoft.Application.interface") //---------------------------------------------------------------- #endif // INTERFACE_H //----------------------------------------------------------------</span></span></code> </pre> <br><br><h3>  <font color="blueviolet">Etapa 2:</font> </h3><br><p>  Creemos una aplicación básica que descargará la extensión.  Al presionar el botón, la extensión se buscará y se cargará en el sistema.  Además a través de la interfaz usaremos nuestra función. <br><br>  Aplicación base: <br><br>  <b>mainproject.h</b> <br><br></p><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--------------------------------------------------- #ifndef MAINPROJECT_H #define MAINPROJECT_H //------------------------------------------------------- #include &lt;QWidget&gt; #include &lt;QPluginLoader&gt; #include &lt;QDir&gt; #include "interface.h" //------------------------------------------------------- namespace Ui { class mainProject; } //------------------------------------------------------- class mainProject : public QWidget { Q_OBJECT public: /// \brief  explicit mainProject(QWidget *parent = nullptr); /// \brief  ~mainProject(); private slots: /// \brief   void on_searchPlugin_clicked(); /// \brief   void on_getUp_clicked(); private: Ui::mainProject *ui; interface *pluginObject; ///&lt;     }; //------------------------------------------------------- #endif // MAINPROJECT_H //-------------------------------------------------------</span></span></code> </pre><br>  <b>mainproject.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--------------------------------------------------- #include "mainproject.h" #include "ui_mainproject.h" //------------------------------------------------------- mainProject::mainProject(QWidget *parent) : QWidget(parent), ui(new Ui::mainProject) { ui-&gt;setupUi(this); } //------------------------------------------------------- mainProject::~mainProject() { delete ui; } //------------------------------------------------------- void mainProject::on_searchPlugin_clicked() { QStringList listFiles; QDir dir(QApplication::applicationDirPath() + "/Plugins/"); //      "Plugins" if(dir.exists()) listFiles = dir.entryList(QStringList("*"), QDir::Files); //     for(QString str: listFiles) { QPluginLoader loader(dir.absolutePath() + "/" +str); QObject *pobj = 0; //   pobj = qobject_cast&lt;QObject*&gt;(loader.instance()); if(!pobj) continue; pluginObject = 0; //   pluginObject = qobject_cast&lt;interface *&gt;(pobj); //      if(pluginObject) { ui-&gt;label-&gt;setText(" "); break; } } } //------------------------------------------------------- void mainProject::on_getUp_clicked() { QString tmp; tmp = ui-&gt;lineEdit-&gt;text(); //   getUpString() tmp = pluginObject-&gt;getUpString(tmp); ui-&gt;label_2-&gt;setText(tmp); } //-------------------------------------------------------</span></span></code> </pre><br><br><h3>  <font color="blueviolet">Etapa 3:</font> </h3><br><p>  Al crear una extensión, lo primero que debe hacer es cambiar el tipo de proyecto que se está construyendo en el archivo pro, para esto debe agregar la siguiente línea TEMPLATE = lib, y establecer la configuración del proyecto para la extensión del complemento CONFIG + =. <br><br>  upperstringplugin.pro <br><br></p><pre> <code class="cpp hljs">#------------------------------------------------- # # Project created by QtCreator <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-03</span></span>T11:<span class="hljs-number"><span class="hljs-number">35</span></span>:<span class="hljs-number"><span class="hljs-number">18</span></span> # #------------------------------------------------- QT += core greaterThan(QT_MAJOR_VERSION, <span class="hljs-number"><span class="hljs-number">4</span></span>): QT += widgets TARGET = upperStringPlugin TEMPLATE = lib CONFIG += plugin DESTDIR = ../Plugins DEFINES += QT_DEPRECATED_WARNINGS CONFIG += c++<span class="hljs-number"><span class="hljs-number">11</span></span> SOURCES += \ upperstringplugin.cpp HEADERS += \ upperstringplugin.h \ interface.h</code> </pre><br><p>  A continuación, creamos una clase para la futura extensión, la clase debe heredarse de la clase de interfaces.  Macro <b>Q_INTERFACES</b> , necesita el compilador para generar toda la metainformación necesaria para la extensión.  La macro <b>Q_PLUGIN_METADATA ()</b> establece el punto de entrada a la extensión y el acceso a la biblioteca Qt.  También debe crear un archivo inteface.json con metainformación (el archivo debe estar en la raíz del proyecto), en nuestro caso no hay información allí, así que simplemente escriba comillas vacías {} en el archivo. <br><br>  <b>upperstringplugin.h</b> <br><br></p><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--------------------------------------------------- #ifndef UPPERSTRINGPLUGIN_H #define UPPERSTRINGPLUGIN_H //--------------------------------------------------- #include "interface.h" //--------------------------------------------------- class upperStringPlugin : public interface { Q_OBJECT Q_INTERFACES(interface) Q_PLUGIN_METADATA(IID "com.mysoft.Application.interface" FILE "interface.json") public: explicit upperStringPlugin(); ~upperStringPlugin(); // interface interface public: QString getUpString(QString str); }; //--------------------------------------------------- #endif // UPPERSTRINGPLUGIN_H //---------------------------------------------------</span></span></code> </pre><br>  <b>upperstringplugin.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--------------------------------------------------- #include "upperstringplugin.h" //--------------------------------------------------- upperStringPlugin::upperStringPlugin() {} //--------------------------------------------------- upperStringPlugin::~upperStringPlugin() {} //--------------------------------------------------- QString upperStringPlugin::getUpString(QString str) { return str.toUpper(); } //---------------------------------------------------</span></span></code> </pre><br><p>  En la salida de compilar el proyecto, obtenemos un archivo con la extensión .so, movemos este archivo a la carpeta Plugins del proyecto principal y lo iniciamos.  En este caso, la extensión se carga en el programa principal y se crea un único objeto de extensión.  Si intenta reutilizar la función instancia (), la función devolverá un puntero al objeto de extensión ya creado. <br><br>  Ejecución del programa <br><br><img src="https://habrastorage.org/webt/sk/mq/3m/skmq3mkkimgxfow_jncj3cmjs28.png"><br><br></p><h2>  <i><font color="red">Parte 2</font></i> </h2><br><p></p><p>  Para complicar nuestra tarea, ahora necesitamos que la extensión sea un widget y la capacidad de crear varios de estos widgets.  El programa principal recibirá mensajes de complementos y enviará una respuesta.  Crearemos nuevos proyectos, en la primera etapa necesitaremos dos clases de interfaces, una será responsable de cargar la extensión y crear el widget, y la otra para el funcionamiento del widget en sí. <br><br>  El esquema del proyecto tendrá el siguiente aspecto: <br><br><img src="https://habrastorage.org/webt/t7/_o/cn/t7_ocnr1xn7rb7i8rayapie_lg4.png"><br><br></p><h3>  <font color="blueviolet">Etapa 1:</font> </h3><br><p>  La primera clase de interfaz tendrá dos funciones: obtener el nombre del complemento y obtener el widget del complemento.  El nombre del complemento se almacenará para su identificación en el sistema.  Agregaremos el widget de complemento a las ventanas MDI de la aplicación principal. <br><br></p><p>  La segunda clase es el widget gráfico en sí, se hereda de QWidget, aquí hemos especificado las funciones que necesitamos, el widget recibirá un mensaje y lo enviará al programa principal. <br><br>  <b>interfaz.h</b> <br><br></p><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------------------------------- #ifndef INTERFACE_H #define INTERFACE_H //------------------------------------------------------------------------- #include &lt;QWidget&gt; class QString; //------------------------------------------------------------------------- class interface : public QObject { public: /// \brief  virtual ~interface(){} /// \brief    virtual QString getNamePlugin() = 0; /// \brief    virtual QObject *getPluginWidget() = 0; }; //------------------------------------------------------------------------- class interfaceWidget: public QWidget { public: /// \brief  virtual ~interfaceWidget() = default; signals: /// \brief      virtual void signal_writeText(QString str) = 0; public slots: /// \brief      virtual void slot_getText(QString str) = 0; }; //------------------------------------------------------------------------- Q_DECLARE_INTERFACE(interface, "com.mysoft.Application.interface") //------------------------------------------------------------------------- #endif // INTERFACE_H //-------------------------------------------------------------------------</span></span></code> </pre><br><h3>  <font color="blueviolet">Etapa 2:</font> </h3><br><p>  El programa principal consta de una ventana MDI, en la que hay un widget principal para recibir mensajes de complementos y ventanas adicionales que aparecen dinámicamente a medida que se llaman los complementos. <br><br>  Al crear un widget de complemento, conectamos la señal del complemento a la ranura y, mediante la función remitente (), obtenemos un puntero al complemento que envió el mensaje.  Colocamos el widget creado en la ventana MDI, y el objeto del complemento en sí mismo puede descargarse del sistema. <br><br>  <b>mainproject.h</b> <br><br></p><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ #ifndef MAINPROJECT_H #define MAINPROJECT_H //------------------------------------------------ #include &lt;QMainWindow&gt; #include &lt;QDir&gt; #include &lt;QPluginLoader&gt; #include "interface.h" //------------------------------------------------ namespace Ui { class mainProject; } //------------------------------------------------ typedef struct str_plugin { QString namePlugin; ///&lt;   QString dirPlugin; ///&lt;   }TSTR_PLUGIN; //------------------------------------------------ class mainWidget; //------------------------------------------------ class mainProject : public QMainWindow { Q_OBJECT public: explicit mainProject(QWidget *parent = nullptr); ~mainProject(); private slots: void on_action_triggered(); /// \brief    void slot_showPlugin(); /// \brief          void slot_getTextFromPlugin(QString str); private: Ui::mainProject *ui; mainWidget *widget; ///&lt;   QVector&lt;TSTR_PLUGIN &gt; vecPlugin; ///&lt;   }; //------------------------------------------------ #endif // MAINPROJECT_H //------------------------------------------------</span></span></code> </pre><br>  <b>mainproject.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ #include "mainproject.h" #include "ui_mainproject.h" #include "mainwidget.h" #include &lt;QMdiSubWindow&gt; //------------------------------------------------ mainProject::mainProject(QWidget *parent) : QMainWindow(parent), ui(new Ui::mainProject) { ui-&gt;setupUi(this); QMdiSubWindow *sWPS = new QMdiSubWindow; widget = new mainWidget(); sWPS-&gt;setWidget(widget); ui-&gt;mdiArea-&gt;addSubWindow(sWPS); } //------------------------------------------------ mainProject::~mainProject() { delete ui; } //------------------------------------------------ void mainProject::on_action_triggered() { ui-&gt;menu_2-&gt;clear(); QStringList listFiles; QDir dir(QApplication::applicationDirPath() + "/Plugins/"); if(dir.exists()) { listFiles = dir.entryList(QStringList("*"), QDir::Files); } for(QString str: listFiles) { QPluginLoader loader(dir.absolutePath() + "/" +str); QObject *pobj = 0; pobj = qobject_cast&lt;QObject*&gt;(loader.instance()); if(!pobj) continue; interface *plW = 0; plW = qobject_cast&lt;interface *&gt;(pobj); if(!plW) continue; QString namePlugin = plW-&gt;getNamePlugin(); QAction *action = new QAction(namePlugin); ui-&gt;menu_2-&gt;addAction(action); connect(action, SIGNAL(triggered()), this, SLOT(slot_showPlugin())); TSTR_PLUGIN plug; plug.namePlugin = namePlugin; plug.dirPlugin = dir.absolutePath() + "/" +str; vecPlugin.push_back(plug); delete plW; } } //------------------------------------------------ void mainProject::slot_showPlugin() { QObject *pobj = sender(); QAction *action = qobject_cast&lt;QAction *&gt;(pobj); QString namePlugin = action-&gt;iconText(); for(int i = 0; i &lt; vecPlugin.size(); i++) { if(namePlugin == vecPlugin[i].namePlugin) { QMdiSubWindow *sWPS = new QMdiSubWindow; ui-&gt;mdiArea-&gt;addSubWindow(sWPS); sWPS-&gt;setAttribute(Qt::WA_DeleteOnClose, true); QPluginLoader loader(vecPlugin[i].dirPlugin); QObject *pobj = qobject_cast&lt;QObject*&gt;(loader.instance()); if(!pobj) continue; interface *plW = qobject_cast&lt;interface *&gt;(pobj); if(!plW) continue; QObject *ob = plW-&gt;getPluginWidget(); if(!ob) continue; interfaceWidget *interFaceW = dynamic_cast&lt;interfaceWidget *&gt;(ob); if(!interFaceW) continue; sWPS-&gt;setWidget(interFaceW); sWPS-&gt;show(); QSize size = interFaceW-&gt;minimumSize(); size.setHeight(size.height() + 20); size.setWidth(size.width() + 20); sWPS-&gt;resize(size); loader.unload(); connect(interFaceW, SIGNAL(signal_writeText(QString)), this, SLOT(slot_getTextFromPlugin(QString))); } } } //------------------------------------------------ void mainProject::slot_getTextFromPlugin(QString str) { //     QObject *pobj = sender(); interfaceWidget *pPlug = dynamic_cast&lt;interfaceWidget *&gt;(pobj); widget-&gt;slot_getText("   "); widget→slot_getText(str); widget-&gt;slot_getText(" "); widget→slot_getText("------------------------------"); pPlug-&gt;slot_getText(" "); } //------------------------------------------------</span></span></code> </pre><br>  La ventana principal acepta el mensaje y lo muestra. <br><br>  <b>mainwidget.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//---------------------------------------------------------- #ifndef MAINWIDGET_H #define MAINWIDGET_H //---------------------------------------------------------- #include &lt;QWidget&gt; //---------------------------------------------------------- namespace Ui { class mainWidget; } //---------------------------------------------------------- class mainWidget : public QWidget { Q_OBJECT public: explicit mainWidget(QWidget *parent = nullptr); ~mainWidget(); public slots: /// \brief      void slot_getText(QString str); private: Ui::mainWidget *ui; }; //---------------------------------------------------------- #endif // MAINWIDGET_H //----------------------------------------------------------</span></span></code> </pre><br>  <b>mainwidget.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//---------------------------------------------------------- #include "mainwidget.h" #include "ui_mainwidget.h" //---------------------------------------------------------- mainWidget::mainWidget(QWidget *parent) : QWidget(parent), ui(new Ui::mainWidget) { ui-&gt;setupUi(this); } //---------------------------------------------------------- mainWidget::~mainWidget() { delete ui; } //---------------------------------------------------------- void mainWidget::slot_getText(QString str) { ui-&gt;textEdit-&gt;append(str); } //----------------------------------------------------------</span></span></code> </pre><br><h3>  <font color="blueviolet">Etapa 2:</font> </h3><br><p>  Creamos un complemento, su idea es que sea una fábrica para crear un widget. <br><br>  <b>plugin.h</b> <br><br></p><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------- #ifndef PLUGIN_H #define PLUGIN_H //------------------------------------------------- #include "interface.h" #include "texttranferwidget.h" //------------------------------------------------- class plugin : public interface { Q_OBJECT Q_INTERFACES(interface) Q_PLUGIN_METADATA(IID "com.mysoft.Application.interface" FILE "interface.json") public: explicit plugin(); ~plugin(); // interface interface public: /// \brief    QString getNamePlugin(); /// \brief    QObject *getPluginWidget(); }; //------------------------------------------------- #endif // PLUGIN_H //-------------------------------------------------</span></span></code> </pre><br>  <b>plugin.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------- #include "plugin.h" //------------------------------------------------- plugin::plugin() { } //------------------------------------------------- plugin::~plugin() { } //------------------------------------------------- QString plugin::getNamePlugin() { return " 1"; } //------------------------------------------------- QObject *plugin::getPluginWidget() { textTranferWidget *widget = new textTranferWidget(); return qobject_cast&lt;QObject *&gt;(widget); } //-------------------------------------------------</span></span></code> </pre><br>  Widget creado por el complemento. <br><br>  <b>texttranferwidget.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------------------------- #ifndef TEXTTRANFERWIDGET_H #define TEXTTRANFERWIDGET_H //------------------------------------------------------------------- #include "interface.h" //------------------------------------------------------------------- namespace Ui { class textTranferWidget; } //------------------------------------------------------------------- class textTranferWidget : public interfaceWidget { Q_OBJECT public: /// \brief  explicit textTranferWidget(); /// \brief  ~textTranferWidget(); private: Ui::textTranferWidget *ui; // interfaceWidget interface signals: /// \brief      void signal_writeText(QString str); public slots: /// \brief      void slot_getText(QString str); private slots: void on_pushButton_clicked(); }; //------------------------------------------------------------------- #endif // TEXTTRANFERWIDGET_H //-------------------------------------------------------------------</span></span></code> </pre><br>  <b>texttranferwidget.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------------------------- #include "texttranferwidget.h" #include "ui_texttranferwidget.h" //------------------------------------------------------------------- textTranferWidget::textTranferWidget() : ui(new Ui::textTranferWidget) { ui-&gt;setupUi(this); } //------------------------------------------------------------------- textTranferWidget::~textTranferWidget() { delete ui; } //------------------------------------------------------------------- void textTranferWidget::slot_getText(QString str) { ui-&gt;textEdit-&gt;append(str); } //------------------------------------------------------------------- void textTranferWidget::on_pushButton_clicked() { emit signal_writeText(ui-&gt;lineEdit-&gt;text()); } //-------------------------------------------------------------------</span></span></code> </pre><br>  La salida del programa principal: <br><br><img src="https://habrastorage.org/webt/3l/bn/vt/3lbnvtf4whntsylnjs14uycp0cu.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448806/">https://habr.com/ru/post/448806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448796/index.html">Prueba de Python con pytest. Configuración, CAPÍTULO 6</a></li>
<li><a href="../448798/index.html">Prueba de Python con pytest. Usando pytest con otras herramientas, CAPÍTULO 7</a></li>
<li><a href="../448800/index.html">Configure Visual Studio en toda su organización con .vsconfig</a></li>
<li><a href="../448802/index.html">Pensar con portales: crear portales en Unreal Engine 4</a></li>
<li><a href="../448804/index.html">Preparándose para el tiempo de ejecución y el notario endurecidos de macOS</a></li>
<li><a href="../448808/index.html">Sobre cosas simples, complicadas. "Acero dormido". Cómo engrasar pernos oxidados o no WD-40 con un solo ...</a></li>
<li><a href="../448810/index.html">¿Cómo atrapé a un hacker?</a></li>
<li><a href="../448812/index.html">Misión lunar "Bereshit": busca la primera biblioteca lunar después de que el accidente de su portador haya comenzado</a></li>
<li><a href="../448814/index.html">Bosque Language: el nuevo lenguaje de programación de Microsoft</a></li>
<li><a href="../448820/index.html">Rust + CLion = Amor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>