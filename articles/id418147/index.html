<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš£ğŸ¾ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ» Silence of Ruby Executions: Transactional Rails / PostgreSQL Thriller ğŸ‘¨ğŸ½â€ğŸš€ ğŸ‘¨ğŸ»â€ğŸ”§ ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah cerita tentang mengapa Anda tidak boleh mengabaikan kesalahan ketika Anda berada di dalam transaksi dalam database. Mencari tahu cara mengg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Silence of Ruby Executions: Transactional Rails / PostgreSQL Thriller</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418147/"><p>  <em>Ini adalah cerita tentang mengapa Anda <strong>tidak boleh</strong> mengabaikan kesalahan ketika Anda berada di dalam transaksi dalam database.</em>  <em>Mencari tahu cara menggunakan transaksi dengan benar dan apa yang harus dilakukan saat menggunakannya bukan merupakan pilihan.</em>  <em>Spoiler: ini akan tentang kunci penasihat di PostgreSQL!</em> </p><br><p> Saya bekerja pada sebuah proyek di mana pengguna dapat mengimpor sejumlah besar entitas berat (sebut saja produk) dari layanan eksternal ke dalam aplikasi kami.  Untuk setiap produk, bahkan lebih beragam data yang terkait dengannya dimuat dari API eksternal.  Tidak jarang seorang pengguna memuat ratusan produk beserta semua dependensinya, sebagai akibatnya, mengimpor satu produk memerlukan waktu nyata (30-60 detik), dan keseluruhan proses dapat memakan waktu lama.  Pengguna mungkin bosan menunggu hasilnya dan ia berhak mengklik tombol "Batal" kapan saja dan aplikasi harus berguna dengan jumlah produk yang dapat diunduh saat ini. </p><a name="habracut"></a><br><p>  â€œImpor yang terputusâ€ diimplementasikan sebagai berikut: di awal untuk setiap produk, catatan tugas sementara dibuat di papan nama dalam database.  Untuk setiap produk, tugas impor latar belakang diluncurkan, yang mengunduh produk, menyimpannya ke database bersama dengan semua dependensi (melakukan semuanya secara umum), dan pada akhirnya menghapus catatan tugasnya.  Jika pada saat tugas latar belakang dimulai, tidak akan ada catatan dalam database - tugas hanya diam-diam berakhir.  Jadi, untuk membatalkan impor, cukup menghapus semua tugas dan hanya itu. </p><br><p>  Tidak masalah jika impor dibatalkan oleh pengguna atau diselesaikan sendiri - dalam hal apa pun, tidak adanya tugas berarti semuanya telah selesai dan pengguna dapat mulai menggunakan aplikasi. </p><br><p>  Desainnya sederhana dan dapat diandalkan, tetapi ada satu bug kecil di dalamnya.  Laporan bug khas tentang dia adalah: "Setelah impor dibatalkan, pengguna ditampilkan daftar barang-barangnya.  Namun, jika Anda me-refresh halaman, maka daftar produk dilengkapi dengan beberapa entri. "  Alasan untuk perilaku ini sederhana - ketika pengguna mengklik tombol "Batal", ia segera dipindahkan ke daftar semua produk.  Namun saat ini, sudah mulai impor barang-barang tertentu masih "berjalan". </p><br><p>  Ini, tentu saja, agak mudah, tetapi pengguna bingung dengan pesanan, jadi akan lebih baik untuk memperbaikinya.  Saya punya dua cara: entah bagaimana mengidentifikasi dan "membunuh" tugas yang sudah berjalan, atau ketika saya menekan tombol batal, tunggu sampai mereka selesai dan "matikan kematian mereka sendiri" sebelum mentransfer pengguna lebih lanjut.  Saya memilih cara kedua - untuk menunggu. </p><br><h2 id="tranzakcionnye-blokirovki-speshat-na-pomosch">  Kunci transaksi terburu-buru untuk menyelamatkan </h2><br><p>  Untuk semua orang yang bekerja dengan database (relasional), jawabannya jelas: gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transaksi</a> ! </p><br><p> Penting untuk diingat bahwa dalam sebagian besar RDBMS, catatan yang diperbarui dalam suatu transaksi akan <em>diblokir</em> dan tidak dapat diakses untuk perubahan oleh proses lain sampai transaksi ini selesai.  Catatan yang dipilih menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>SELECT FOR UPDATE</code></a> juga akan dikunci. </p><br><p>  Tepatnya kasus kami!  Saya membungkus tugas mengimpor barang individual ke dalam transaksi dan memblokir catatan tugas di awal: </p><br><pre> <code class="ruby hljs">ActiveRecord::Base.transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> task = Import::Task.lock.find_by(<span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> id) <span class="hljs-comment"><span class="hljs-comment"># SELECT â€¦ FOR UPDATE  Â«    Â» return unless task #  - ? ,    ! #     task.destroy end</span></span></code> </pre> <br><p>  Sekarang, ketika pengguna ingin membatalkan impor, operasi penghentian impor akan menghapus tugas-tugas untuk impor yang belum dimulai dan akan dipaksa untuk menunggu penyelesaian yang sudah ada: </p><br><pre> <code class="ruby hljs">user.import_tasks.delete_all <span class="hljs-comment"><span class="hljs-comment">#       </span></span></code> </pre> <br><p>  Sederhana dan elegan!  Saya menjalankan tes, memeriksa impor secara lokal dan pada pementasan, dan menyebarkan "ke pertempuran". </p><br><h2 id="ne-tak-bystro">  Tidak terlalu cepat ... </h2><br><p>  Puas dengan pekerjaan saya, saya sangat terkejut menemukan segera laporan bug dan banyak kesalahan dalam log.  Banyak produk yang tidak diimpor <em>sama sekali</em> .  Dalam beberapa kasus, hanya satu produk tunggal yang dapat tetap setelah selesainya semua impor. </p><br><p>  Kesalahan dalam log juga tidak mendorong: <code>PG::InFailedSqlTransaction</code> dengan backtrack yang mengarah ke kode yang mengeksekusi <code>SELECT</code> s yang tidak bersalah.  Apa yang sedang terjadi? </p><br><p>  Setelah seharian melakukan debugging yang melelahkan, saya mengidentifikasi tiga penyebab utama masalah: </p><br><ol><li>  Penyisipan kompetitif catatan yang bertentangan ke dalam database. </li><li>  Pembatalan transaksi otomatis dalam PostgreSQL setelah kesalahan. </li><li>  Kesunyian masalah (pengecualian Ruby) dalam kode aplikasi. </li></ol><br><p>  <strong>Masalah Satu: Penyisipan Kompetitif dari Entri yang Berkonflik</strong> </p><br><p>  Karena setiap operasi impor memakan waktu hingga satu menit dan ada banyak tugas ini, kami melakukannya secara paralel untuk menghemat waktu.  Catatan barang yang bergantung dapat bersinggungan, sepanjang semua produk pengguna dapat merujuk ke satu catatan tunggal, dibuat sekali dan kemudian digunakan kembali. </p><br><p>  Ada cek untuk menemukan dan menggunakan kembali dependensi yang sama dalam kode aplikasi, tetapi <em>sekarang, ketika kita menggunakan transaksi, cek ini menjadi tidak berguna</em> : jika transaksi A membuat catatan dependen tetapi belum selesai, maka transaksi B tidak akan dapat mencari tahu tentang keberadaannya dan akan mencoba untuk membuat duplikat merekam. </p><br><p>  <strong>Masalah Dua: Pembatalan transaksi otomatis PostgreSQL setelah kesalahan</strong> </p><br><p>  Tentu saja, kami mencegah pembuatan tugas duplikat di tingkat database menggunakan DDL berikut: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> product_deps <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (user_id, characteristics);</code> </pre> <br><p>  Jika suatu transaksi sedang berlangsung A menyisipkan catatan baru dan transaksi B mencoba menyisipkan catatan dengan nilai yang sama dari bidang <code>user_id</code> dan <code>characteristics</code> , transaksi B akan menerima kesalahan: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> product_deps (user_id, characteristics) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'{"same": "value"}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- Now it will block until first transaction will be finished ERROR: duplicate key value violates unique constraint "product_deps_user_id_characteristics_key" DETAIL: Key (user_id, characteristics)=(1, {"same": "value"}) already exists. -- And will throw an error when first transaction have commited and it is become clear that we have a conflict</span></span></code> </pre> <br><p>  Tetapi ada satu fitur yang tidak boleh dilupakan - transaksi B, setelah mendeteksi kesalahan, akan secara otomatis dibatalkan dan semua pekerjaan yang dilakukan di dalamnya akan sia-sia.  Namun, transaksi <strong>ini masih terbuka</strong> dalam keadaan "salah", tetapi dengan segala upaya untuk mengeksekusi apa pun, bahkan permintaan yang paling tidak berbahaya, hanya kesalahan yang akan dikembalikan sebagai respons: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> products; ERROR: current transaction is aborted, commands ignored until <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span></code> </pre> <br><p>  Yah, sama sekali tidak perlu untuk mengatakan bahwa segala sesuatu yang dimasukkan ke dalam basis data dalam transaksi ini tidak akan disimpan: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--      ,   ROLLBACK --          </span></span></code> </pre> <br><p>  <strong>Masalah Tiga: Diam</strong> </p><br><p>  Pada titik ini, sudah jelas bahwa hanya menambahkan transaksi ke aplikasi memecahkannya.  Tidak ada pilihan: Saya harus menyelami kode impor.  Dalam kode, cukup sering pola-pola berikut mulai menarik perhatian saya: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_stuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment"># ,   rescue StandardError nil #  ,  end</span></span></code> </pre> <br><p>  Penulis kode di sini memberi tahu kami, "Kami mencoba, kami tidak berhasil, tapi tidak apa-apa, kami melanjutkan tanpanya."  Dan meskipun alasan untuk pilihan ini bisa sangat dijelaskan (tidak semuanya dapat diproses pada tingkat aplikasi), ini yang membuat logika apa pun berdasarkan transaksi tidak mungkin: eksekusi yang dibuang tidak akan dapat mengapung ke blok <code>transaction</code> , dan tidak akan menyebabkan kemunduran yang benar transaksi (ActiveRecord menangkap semua kesalahan dalam blok ini, memutar kembali transaksi dan melemparkannya lagi). </p><br><h2 id="idealnyy-shtorm">  Badai sempurna </h2><br><p>  Dan inilah bagaimana ketiga faktor ini bersatu untuk menciptakan yang sempurna <del>  badai </del>  bug: </p><br><ul><li>  Aplikasi dalam transaksi mencoba untuk memasukkan catatan yang saling bertentangan ke dalam database dan menyebabkan kesalahan "duplikat kunci" dari PostgreSQL.  Namun, kesalahan ini tidak menyebabkan transaksi digulung kembali dalam aplikasi, karena "diam" di dalam salah satu bagian aplikasi. </li><li>  Transaksi menjadi tidak valid, tetapi aplikasi tidak mengetahuinya dan terus bekerja.  Dalam setiap upaya untuk mengakses database, aplikasi kembali menerima kesalahan, kali ini "transaksi saat ini dibatalkan", tetapi kesalahan ini juga dapat dibuang ... </li><li>  Anda mungkin sudah mengerti bahwa sesuatu dalam aplikasi terus rusak, tetapi tidak ada yang akan mengetahuinya sampai eksekusi mencapai tempat pertama, di mana tidak ada <code>rescue</code> terlalu rakus dan di mana kesalahan akhirnya muncul, dicatat, terdaftar di pelacak kesalahan - apa pun.  Tapi tempat ini sudah sangat jauh dari tempat yang menjadi akar penyebab kesalahan, dan ini saja akan mengubah debugging menjadi mimpi buruk. </li></ul><br><h2 id="alternativa-tranzakcionnym-blokirovkam-v-postgresql">  Alternatif untuk kunci transaksional di PostgreSQL </h2><br><p>  Berburu untuk <code>rescue</code> dalam kode aplikasi dan menulis ulang semua logika impor bukanlah suatu pilihan.  Waktu yang lama  Saya membutuhkan solusi cepat dan menemukannya di postgres!  Ini memiliki solusi bawaan untuk kunci, alternatif untuk mengunci catatan dalam transaksi, kunci rapat sesi-penasehat.  Saya menggunakannya sebagai berikut: </p><br><p>  Pertama, saya menghapus transaksi pembungkus terlebih dahulu.  Bagaimanapun, berinteraksi dengan API eksternal (atau "efek samping" lainnya) dari kode aplikasi dengan transaksi terbuka adalah ide yang buruk, karena bahkan jika Anda memutar kembali transaksi bersama dengan semua perubahan dalam database kami, perubahan dalam sistem eksternal akan tetap , dan aplikasi secara keseluruhan mungkin dalam keadaan aneh dan tidak diinginkan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Permata isolator</a> dapat membantu Anda memastikan bahwa efek samping <em>terisolasi</em> dengan benar dari transaksi. </p><br><p>  Kemudian, di setiap operasi impor, saya mengambil kunci <em>bersama</em> pada beberapa kunci unik untuk seluruh impor (misalnya, dibuat dari ID pengguna dan hash dari nama kelas operasi): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock_shared(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id);</code> </pre> <br><p>  Kunci bersama pada tombol yang sama dapat diambil secara bersamaan oleh sejumlah sesi. </p><br><p>  Pembatalan operasi impor pada saat yang sama menghapus semua entri tugas dari database dan mencoba mengambil kunci <em>eksklusif</em> pada kunci yang sama.  Dalam hal ini, ia harus menunggu sampai semua kunci bersama dilepaskan: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id)</code> </pre> <br><p>  Dan itu saja!  Sekarang "pembatalan" akan menunggu sampai semua "berjalan" impor barang individu selesai. </p><br><p>  Selain itu, sekarang kita tidak terhubung dengan transaksi, kita dapat menggunakan retasan kecil untuk membatasi waktu untuk menunggu impor dibatalkan (seandainya beberapa impor "tongkat"), karena itu tidak baik untuk memblokir aliran server web untuk waktu yang lama (dan memaksa tunggu pengguna): </p><br><pre> <code class="ruby hljs">transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute(<span class="hljs-string"><span class="hljs-string">"SET LOCAL lock_timeout = '30s'"</span></span>) execute(<span class="hljs-string"><span class="hljs-string">"SELECT pg_advisory_lock(42, user.id)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rescue</span></span> ActiveRecord::LockWaitTimeout <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (     ) end</span></span></code> </pre> <br><p>  Aman untuk menangkap kesalahan di <em>luar</em> blok <code>transaction</code> , karena <a href="">ActiveRecord sudah akan memutar kembali transaksi</a> . </p><br><h2 id="no-chto-delat-s-konkurentnoy-vstavkoy-odinakovyh-zapisey">  Tapi apa yang harus dilakukan dengan penyisipan kompetitif catatan identik? </h2><br><p>  Sayangnya, saya tidak tahu solusi yang akan bekerja dengan baik dengan sisipan <em>kompetitif</em> .  Ada beberapa pendekatan berikut, tetapi mereka semua akan memblokir insert bersamaan sampai transaksi pertama selesai: </p><br><ul><li>  <code>INSERT â€¦ ON CONFLICT UPDATE</code> (tersedia sejak PostgreSQL 9.5) dalam transaksi kedua akan dikunci hingga transaksi pertama selesai dan kemudian akan mengembalikan catatan yang dimasukkan oleh transaksi pertama. </li><li>  Kunci beberapa catatan umum dalam transaksi sebelum menjalankan validasi untuk memasukkan catatan baru.  Di sini kita akan menunggu hingga catatan yang dimasukkan dalam transaksi lain terlihat dan validasi tidak dapat sepenuhnya berhasil. </li><li>  Ambil semacam kunci rekomendasi umum - efeknya sama dengan memblokir catatan umum. </li></ul><br><p>  Nah, jika Anda tidak takut bekerja dengan kesalahan tingkat dasar, Anda bisa menangkap kesalahan keunikan: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import_all_the_things</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#   ,   Dep.create(user_id, chars) rescue ActiveRecord::RecordNotUnique retry end</span></span></span></span></code> </pre> <br><p>  Pastikan kode ini tidak lagi dibungkus dalam suatu transaksi. </p><br><blockquote>  Mengapa mereka diblokir? <br><br>  Kendala UNIQUE dan EXCLUDE menghalangi <em>potensi konflik dengan</em> mencegahnya direkam pada saat yang bersamaan.  Misalnya, jika Anda memiliki batasan unik pada kolom bilangan bulat dan satu transaksi menyisipkan baris dengan nilai 5, maka transaksi lain yang juga mencoba memasukkan 5 akan diblokir, tetapi transaksi yang mencoba memasukkan 6 atau 4 akan berhasil segera, tanpa pemblokiran.  Karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tingkat isolasi transaksi aktual minimum PostgreSQL</a> adalah <code>READ COMMITED</code> , transaksi tidak berhak melihat perubahan yang tidak dikomit dari transaksi lain.  Oleh karena itu, <code>INSERT</code> dengan nilai yang bertentangan tidak dapat diterima atau ditolak sampai transaksi pertama melakukan perubahannya (kemudian yang kedua menerima kesalahan keunikan) atau memutar kembali (kemudian masukkan dalam transaksi kedua akan berhasil).  Baca lebih lanjut tentang ini di sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel oleh penulis pembatasan EXCLUDE</a> . </blockquote><br><h2 id="predotvraschaem-katastrofu-v-buduschem">  Mencegah bencana di masa depan </h2><br><p>  <em>Sekarang</em> Anda tahu bahwa tidak semua kode dapat dibungkus dalam suatu transaksi.  Akan lebih baik untuk memastikan bahwa tidak ada orang lain yang membungkus kode tersebut dalam transaksi di masa depan, mengulangi kesalahan saya. </p><br><p>  Untuk melakukan ini, Anda dapat membungkus semua operasi Anda dalam modul tambahan kecil yang akan memeriksa apakah transaksi terbuka sebelum menjalankan kode operasi terbungkus (di sini diasumsikan bahwa semua operasi Anda memiliki antarmuka yang sama - metode <code>call</code> ). </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     module NoTransactionAllowed class InTransactionError &lt; RuntimeError; end def call(*) return super unless in_transaction? raise InTransactionError, "#{self.class.name} doesn't work reliably within a DB transaction" end def in_transaction? connection = ApplicationRecord.connection # service transactions (tests and database_cleaner) are not joinable connection.transaction_open? &amp;&amp; connection.current_transaction.joinable? end end #    class Deps::Import &lt; BaseService prepend NoTransactionAllowed def call do_import rescue ActiveRecord::RecordNotUnique retry end end</span></span></code> </pre> <br><p>  Sekarang, jika seseorang mencoba untuk membungkus layanan <em>berbahaya</em> dalam suatu transaksi, maka ia akan segera menerima kesalahan (kecuali, tentu saja, ia membiarkannya diam). </p><br><h2 id="itogi">  Ringkasan </h2><br><p>  Pelajaran utama yang harus dipelajari: berhati-hatilah dengan pengecualian.  Jangan menangani semuanya secara berurutan, tangkap hanya pengecualian yang Anda tahu cara menangani dan biarkan sisanya masuk ke log.  Jangan pernah mengabaikan pengecualian (hanya jika Anda tidak 100% yakin mengapa Anda melakukan ini).  Semakin cepat suatu kesalahan diperhatikan, semakin mudah untuk melakukan debug. </p><br><p>  Dan jangan berlebihan dengan transaksi dalam database.  Ini bukan obat mujarab.  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isolator</a> permata kami dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">after_commit_everywhere</a> - mereka akan membantu transaksi Anda menjadi sangat mudah. </p><br><h2 id="chto-pochitat">  Apa yang harus dibaca </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Ruby Luar Biasa</em></a> <em>oleh Avdi Grimm</em> .  Buku pendek ini akan mengajarkan Anda bagaimana menangani pengecualian yang ada di Ruby dan bagaimana merancang dengan baik sistem pengecualian untuk aplikasi Anda. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://brandur.org/"><em>Menggunakan Transaksi Atom untuk Memberi API</em></a> Idempoten oleh @Brandur.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blognya memiliki</a> banyak artikel bermanfaat tentang keandalan aplikasi, Ruby, dan PostgreSQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418147/">https://habr.com/ru/post/id418147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418137/index.html">Bloodlust: Wawancara dengan Pendiri DonorSearch</a></li>
<li><a href="../id418139/index.html">Solusi numerik dari model matematika objek yang diberikan oleh sistem persamaan diferensial</a></li>
<li><a href="../id418141/index.html">RE: Ghat / AFR Race Skipper Pemula</a></li>
<li><a href="../id418143/index.html">PVS-Studio sebagai solusi SAST</a></li>
<li><a href="../id418145/index.html">Gugatan pertama terhadap Roskomnadzor dari sebuah perusahaan yang menderita ketika Telegram diblokir</a></li>
<li><a href="../id418149/index.html">Phishing dengan tag judul</a></li>
<li><a href="../id418151/index.html">Pengantar tugas mengenali emosi</a></li>
<li><a href="../id418153/index.html">Kolesa Android Meetup Video: Tentang MVVM, Antipatterns, dan Pengembangan Modular</a></li>
<li><a href="../id418155/index.html">Diode LED Dioda zener</a></li>
<li><a href="../id418157/index.html">Buku "Benda elegan. Edisi Jawa Â»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>