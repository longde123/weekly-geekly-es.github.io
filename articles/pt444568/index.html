<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👻 👨‍👩‍👦‍👦 🧖🏻 Os 10 principais erros de projetos C ++ encontrados em 2018 🍇 🈁 🧑🏿‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Faz três meses que 2018 terminou. Para muitos, apenas sobrevoou, mas para nós, desenvolvedores do PVS-Studio, foi um ano bastante movimentado. Estávam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Os 10 principais erros de projetos C ++ encontrados em 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/444568/">  Faz três meses que 2018 terminou.  Para muitos, apenas sobrevoou, mas para nós, desenvolvedores do PVS-Studio, foi um ano bastante movimentado.  Estávamos trabalhando muito, competindo sem medo por divulgar a análise estática e procurando erros em projetos de código aberto, escritos nas linguagens C, C ++, C # e Java.  Neste artigo, reunimos os 10 mais interessantes deles para você! <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/72a/054/f7b72a054c744397f8c8c1830253ae2a.png"></div><a name="habracut"></a><br>  Para encontrar os lugares mais intrigantes, usamos o analisador de código estático <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PVS-Studio</a> .  Ele pode detectar erros e possíveis vulnerabilidades no código, escrito nos idiomas listados acima. <br><br>  Se você estiver entusiasmado com a busca de erros, sempre poderá fazer o download e experimentar o nosso analisador.  Fornecemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">versão gratuita do analisador</a> para estudantes e desenvolvedores entusiasmados, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">licença gratuita</a> para desenvolvedores de projetos de código aberto e também a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">versão de teste</a> para todo o mundo e seu cão.  Quem sabe, talvez até o próximo ano você consiga criar seu próprio top 10?  :) <br><br>  <b>Nota:</b> convido você a verificar a si mesmo e, antes de olhar para o aviso do analisador, tente revelar os próprios defeitos.  Quantos erros você poderá encontrar? <br><br><h2>  Décimo lugar </h2><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Into Space Again: como o unicórnio visitou o Stellarium</a> <br><br>  Este erro foi detectado ao verificar um planetário virtual chamado Stellarium. <br><br>  O fragmento de código acima, embora pequeno, está repleto de um erro bastante complicado: <br><br><pre><code class="cpp hljs">Plane::Plane(Vec3f &amp;v1, Vec3f &amp;v2, Vec3f &amp;v3) : distance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>), sDistance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { Plane(v1, v2, v3, SPolygon::CCW); }</code> </pre> <br>  Encontrou? <br><br>  <b>Aviso do PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V603</a> O objeto foi criado, mas não está sendo usado.  Se você deseja chamar o construtor, 'this-&gt; Plane :: Plane (....)' deve ser usado.  Plane.cpp 29 <br><br>  O autor do código pretendia inicializar os campos de alguns objetos, usando outro construtor, aninhado no principal.  Bem, em vez disso, ele apenas conseguiu criar um objeto temporário destruído ao sair de seu escopo.  Ao fazer isso, vários campos do objeto permanecerão não inicializados. <br><br>  O autor deveria ter usado um construtor delegado, introduzido no C ++ 11, em vez de uma chamada de construtor aninhado.  Por exemplo, ele poderia ter escrito assim: <br><br><pre> <code class="cpp hljs">Plane::Plane(Vec3f&amp; v1, Vec3f&amp; v2, Vec3f&amp; v3) : Plane(v1, v2, v3, SPolygon::CCW) { distance = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; sDistance = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; }</code> </pre> <br>  Dessa forma, todos os campos necessários teriam sido inicializados corretamente.  Não é maravilhoso? <br><br><h2>  Nono lugar </h2><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Perl 5: Como ocultar erros em macros</a> <br><br>  Uma macro muito notável se destaca em toda a sua beleza no nono lugar. <br><br>  Ao coletar erros para escrever um artigo, meu colega Svyatoslav encontrou um aviso, emitido pelo analisador, relacionado ao uso de macro.  Aqui está: <br><br><pre> <code class="cpp hljs">PP(pp_match) { .... MgBYTEPOS_set(mg, TARG, truebase, RXp_OFFS(prog)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end); .... }</code> </pre> <br>  Para descobrir o que estava errado, Svyatoslav se aprofundou.  Ele abriu a definição de macro e viu que ela continha várias macros aninhadas, algumas das quais também tinham macros aninhadas.  Era tão difícil entender isso, então ele teve que usar um arquivo pré-processado.  Infelizmente, não ajudou.  Isto foi o que Svyatoslav encontrou na linha de código anterior: <br><br><pre> <code class="cpp hljs">(((targ)-&gt;sv_flags &amp; <span class="hljs-number"><span class="hljs-number">0x00000400</span></span>) &amp;&amp; (!((targ)-&gt;sv_flags &amp; <span class="hljs-number"><span class="hljs-number">0x00200000</span></span>) || S_sv_only_taint_gmagic(targ)) ? (mg)-&gt;mg_len = ((prog-&gt;offs)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end), (mg)-&gt;mg_flags |= <span class="hljs-number"><span class="hljs-number">0x40</span></span> : ((mg)-&gt;mg_len = (((targ)-&gt;sv_flags &amp; <span class="hljs-number"><span class="hljs-number">0x20000000</span></span>) &amp;&amp; !__builtin_expect(((((PL_curcop)-&gt;cop_hints + <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x00000008</span></span>) ? (<span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span> :(<span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>),(<span class="hljs-number"><span class="hljs-number">0</span></span>))) ? (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span>)Perl_utf8_length( (U8 *)(truebase), (U8 *)(truebase)+((prog-&gt;offs)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end)) : (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span>)((prog-&gt;offs)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end), (mg)-&gt;mg_flags &amp;= ~<span class="hljs-number"><span class="hljs-number">0x40</span></span>));</code> </pre> <br>  <b>Aviso do PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V502</a> Talvez o operador '?:' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funcione de</a> maneira diferente do esperado.  O operador '?:' Tem uma prioridade mais baixa que o operador '&amp;&amp;'.  pp_hot.c 3036 <br><br>  Eu acho que seria um desafio simplesmente perceber esse erro.  Estamos estudando esse código há muito tempo, mas, falando francamente, não encontramos nenhum erro nele.  Enfim, é um exemplo bastante divertido de código mal legível. <br><br>  Eles dizem que as macros são más.  Claro, existem casos em que as macros são indispensáveis, mas se você pode substituir uma macro por uma função - você definitivamente deve fazê-lo. <br><br>  Macros aninhadas são especialmente cheias de armadilhas.  Não apenas porque é difícil compreendê-los, mas também porque eles podem dar resultados imprevisíveis.  Se um programador cometer um erro em tal macro - será muito mais difícil encontrá-lo em uma macro do que em uma função. <br><br><h2>  Oitavo lugar </h2><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Crómio: Outros Erros</a> <br><br>  O exemplo a seguir foi retirado da série de artigos sobre a análise do projeto Chromium.  O erro estava oculto na biblioteca WebRTC. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;SdpVideoFormat&gt; StereoDecoderFactory::GetSupportedFormats() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;SdpVideoFormat&gt; formats = ....; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; format : formats) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cricket::CodecNamesEq(....)) { .... formats.push_back(stereo_format); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> formats; }</code> </pre> <br>  <b>Aviso do PVS-Studio: os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">iteradores V789</a></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-672</a> para o contêiner de 'formatos', usados ​​no loop for baseado em intervalo, tornam-se inválidos quando a função 'push_back' é chamada.  stereocodecfactory.cc 89 <br><br>  O erro é que o tamanho do vetor de <i>formatos</i> varia dentro do loop for baseado em intervalo.  Os loops baseados em intervalo são baseados em iteradores, é por isso que a alteração do tamanho do contêiner dentro desses loops pode resultar na invalidação desses iteradores. <br><br>  Este erro persiste, se reescrever o loop com um uso explícito de iteradores.  Para maior clareza, posso citar o seguinte código: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> format = begin(formats), __end = end(formats); format != __end; ++format) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cricket::CodecNamesEq(....)) { .... formats.push_back(stereo_format); } }</code> </pre> <br>  Por exemplo, ao usar o método <i>push_back</i> , uma realocação de vetor pode ocorrer - dessa maneira, os iteradores abordarão um local de memória inválido. <br><br>  Para evitar esses erros, siga a regra: nunca altere o tamanho de um contêiner dentro de um loop com condições vinculadas a esse contêiner.  Também se refere a loops baseados em intervalo e loops usando iteradores.  Você pode ler esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discussão</a> no StackOverflow, que aborda o tópico de operações que causa a invalidação de iteradores. <br><br><h2>  Sétimo lugar </h2><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Godot: Sobre o uso regular de analisadores estáticos</a> <br><br>  O primeiro exemplo da indústria de jogos será um trecho de código que encontramos no mecanismo de jogos Godot.  Provavelmente, levará algum trabalho para perceber o erro, mas tenho certeza de que nossos leitores experientes vão lidar com isso. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimationNodeBlendSpace1D::add_blend_point( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ref&lt;AnimationRootNode&gt; &amp;p_node, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> p_position, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p_at_index) { ERR_FAIL_COND(blend_points_used &gt;= MAX_BLEND_POINTS); ERR_FAIL_COND(p_node.is_null()); ERR_FAIL_COND(p_at_index &lt; <span class="hljs-number"><span class="hljs-number">-1</span></span> || p_at_index &gt; blend_points_used); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_at_index == <span class="hljs-number"><span class="hljs-number">-1</span></span> || p_at_index == blend_points_used) { p_at_index = blend_points_used; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = blend_points_used - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt; p_at_index; i++) { blend_points[i] = blend_points[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } } .... }</code> </pre> <br>  <b>Aviso do PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V621</a></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-835</a> Considere inspecionar o operador 'for'.  É possível que o loop seja executado incorretamente ou não seja executado.  animation_blend_space_1d.cpp 113 <br><br>  Vamos dar uma olhada na condição do loop.  A variável do contador é inicializada pelo valor <i>blend_points_used - 1</i> .  Além disso, a julgar pelas duas verificações anteriores (em <i>ERR_FAIL_COND</i> e em <i>if</i> ), fica claro que, no momento da execução do loop <i>blend_points_used</i> , <i>blend_points_used</i> sempre será maior que <i>p_at_index</i> .  Portanto, a condição do loop é sempre verdadeira ou o loop não é executado. <br><br>  Se <i>blend_points_used - 1 == p_at_index</i> , o loop não será executado. <br><br>  Em todos os outros casos, a verificação <i>i&gt; p_at_index</i> sempre será verdadeira, pois o contador <i>i</i> sobe em cada iteração do loop. <br><br>  Parece que o ciclo é eterno, mas não é assim. <br><br>  Primeiramente, ocorrerá um estouro inteiro da variável <i>i</i> (que é um comportamento indefinido).  Isso significa que não devemos confiar nisso. <br><br>  Se <i>eu</i> <i>não</i> tivesse <i>assinado int</i> , depois que o contador atingir o maior valor possível, o operador <i>i ++</i> o transformaria em <i>0</i> .  Esse comportamento é definido pelo padrão e é chamado "Invólucro não assinado".  No entanto, você deve estar ciente de que o uso desse mecanismo também <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">não é uma boa ideia</a> . <br><br>  Foi o primeiro ponto, mas ainda temos o segundo!  O caso é que nem chegaremos a um estouro inteiro.  O índice da matriz sairá dos limites muito antes.  Isso significa que haverá uma tentativa de acessar a memória fora do bloco alocado para a matriz.  Qual é o comportamento indefinido também.  Um exemplo clássico :) <br><br>  Posso fazer algumas recomendações para facilitar a prevenção de erros semelhantes: <br><br><ol><li>  Escreva código simples e compreensível </li><li>  Revise o código mais detalhadamente e escreva mais testes para o código recém-escrito </li><li>  Use analisadores estáticos;) </li></ol><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e24/4d8/f8b/e244d8f8b0062e5c822e3630b50b26bc.png"></div><br><br><h2>  Sexto lugar </h2><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Amazon Lumberyard: Um Grito de Angústia</a> <br><br>  Aqui está outro exemplo da indústria gamedev, a saber, do código-fonte do mecanismo AAA do Amazon Lumberyard. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TranslateVariableNameByOperandType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Igor: yet another Qualcomm's special case // GLSL compiler thinks that -2147483648 is // an integer overflow which is not if (*((int*)(&amp;psOperand-&gt;afImmediates[0])) == 2147483648) { bformata(glsl, "-2147483647-1"); } else { // Igor: this is expected to fix // paranoid compiler checks such as Qualcomm's if (*((unsigned int*)(&amp;psOperand-&gt;afImmediates[0])) &gt;= 2147483648) { bformata(glsl, "%d", *((int*)(&amp;psOperand-&gt;afImmediates[0]))); } else { bformata(glsl, "%d", *((int*)(&amp;psOperand-&gt;afImmediates[0]))); } } bcatcstr(glsl, ")"); .... }</span></span></code> </pre> <br>  <b>Aviso do PVS-Studio</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V523</a> A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instrução</a> 'then' é equivalente à instrução 'else'.  toglsloperand.c 700 <br><br>  O Amazon Lumberyard é desenvolvido como um mecanismo de plataforma cruzada.  Por esse motivo, os desenvolvedores tentam oferecer suporte ao maior número possível de compiladores.  Como podemos ver nos comentários, um programador Igor veio contra o compilador Qualcomm. <br><br>  Não sabemos se ele conseguiu executar sua tarefa e verificou as verificações "paranóicas" do compilador, mas deixou um código muito estranho.  O estranho é que tanto os ramos <i>então</i> - quanto os outros <i>-</i> da instrução <i>if</i> contêm código absolutamente idêntico.  Provavelmente, esse erro resultou do uso de um método desleixado de copiar e colar. <br><br>  Eu nem sei o que aconselhar aqui.  Então, eu só desejo aos desenvolvedores do Amazon Lumberyard tudo de melhor na correção de erros e boa sorte para o desenvolvedor Igor! <br><br><h2>  Quinto lugar </h2><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais uma vez, o analisador PVS-Studio provou ser mais atento do que uma pessoa</a> <br><br>  Uma história interessante aconteceu com o próximo exemplo.  Meu colega Andrey Karpov estava preparando um artigo sobre outra verificação da estrutura do Qt.  Ao escrever alguns erros notáveis, ele tropeçou no aviso do analisador, que considerou falso.  Aqui está esse fragmento de código e o aviso para ele: <br><br><pre> <code class="cpp hljs">QWindowsCursor::CursorState QWindowsCursor::cursorState() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { cursorShowing = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, cursorSuppressed = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }; CURSORINFO cursorInfo; cursorInfo.cbSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(CURSORINFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetCursorInfo(&amp;cursorInfo)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cursorInfo.flags &amp; CursorShowing) <span class="hljs-comment"><span class="hljs-comment">// &lt;= V616 .... }</span></span></code> </pre> <br>  <b>Aviso do PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V616</a></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-480</a> A constante nomeada 'CursorShowing' com o valor de 0 é usada na operação bit a bit.  qwindowscursor.cpp 669 <br><br>  O que significa que o PVS-Studio estava reclamando no local, o que obviamente não tinha erro!  É impossível que a constante <i>CursorShowing</i> seja <i>0</i> , pois apenas algumas linhas acima dela são inicializadas por <i>1</i> . <br><br>  Como Andrey estava usando uma versão instável do analisador, ele questionou a exatidão do aviso.  Ele examinou cuidadosamente esse trecho de código e ainda não encontrou um bug.  Ele acabou dando um falso positivo no rastreador de bugs para que outros colegas pudessem remediar a situação. <br><br>  Apenas uma análise detalhada mostrou que o PVS-Studio acabou sendo mais cuidadoso do que uma pessoa novamente.  O valor <i>0x1</i> é atribuído a uma constante nomeada chamada <i>cursorShowing</i> enquanto <i>CursorShowing</i> participa de uma operação "e" bit a bit.  Estas são duas constantes totalmente diferentes, a primeira começa com uma letra minúscula, a segunda - com uma maiúscula. <br><br>  O código é compilado com êxito, porque a classe <i>QWindowsCursor</i> realmente contém uma constante com esse nome.  Aqui está sua definição: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QWindowsCursor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QPlatformCursor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CursorState { CursorShowing, CursorHidden, CursorSuppressed }; .... }</code> </pre> <br>  Se você não atribuir um valor a uma constante enum explicitamente, ele será inicializado por padrão.  Como <i>CursorShowing</i> é o primeiro elemento na enumeração, ele será atribuído <i>0</i> . <br><br>  Para evitar esses erros, você não deve dar nomes muito semelhantes às entidades.  Você deve seguir particularmente essa regra se as entidades forem do mesmo tipo ou puderem ser implicitamente convertidas uma para a outra.  Como nesses casos, será quase impossível perceber o erro, mas o código incorreto ainda será compilado e viverá na rua fácil dentro do seu projeto. <br><br><h2>  Quarto lugar </h2><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dê um tiro no pé ao manusear dados de entrada</a> <br><br>  Estamos nos aproximando dos três principais finalistas e o próximo da fila é o erro do projeto FreeSWITCH. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">basic_gets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cnt)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = getchar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets(command_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(command_buf) - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) != command_buf) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } command_buf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(command_buf)<span class="hljs-number"><span class="hljs-number">-1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* remove endline */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  <b>Aviso do PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V1010</a></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-20</a> Dados contaminados não verificados são usados ​​no índice: 'strlen (command_buf)'. <br><br>  O analisador avisa que alguns dados não verificados são usados ​​na expressão <i>strlen (command_buf) - 1</i> .  De fato: se <i>command_buf</i> é uma string vazia em termos da linguagem C (contendo o único caractere - '\ 0'), <i>strlen (command_buf)</i> retornará <i>0</i> .  Nesse caso, o <i>comando_buf [-1]</i> será acessado, o que é um comportamento indefinido.  Isso é ruim! <br><br>  O entusiasmo real deste erro não é <b>por</b> que ocorre, mas <b>como</b> .  Este erro é um desses exemplos mais agradáveis, que você "toca" sozinho, reproduz.  Você pode executar o FreeSwitch, realizar algumas ações que levarão à execução do fragmento de código mencionado acima e passar uma string vazia para a entrada do programa. <br><br>  Como resultado, com um movimento sutil da mão, um programa de trabalho se transforma em um não trabalho!  Você pode encontrar detalhes sobre como reproduzir esse erro no artigo de origem no link fornecido acima.  Enquanto isso, deixe-me fornecer um resultado revelador: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jSYJirPIK8E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Lembre-se de que os dados de saída podem ser qualquer coisa, portanto, você deve sempre verificar.  Dessa forma, o analisador não irá reclamar e o programa se tornará mais confiável. <br><br>  Agora é hora de escolher o vencedor: estamos no final do jogo agora!  A propósito, os finalistas de bugs já esperaram uma longa espera, depois ficaram entediados e até começaram a ser pequeninos.  Veja o que eles fizeram enquanto estávamos fora! <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c7/d5f/39e/2c7d5f39edfa5e07639ef95520889b09.png"></div><br><br><h2>  Terceiro lugar </h2><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NCBI Genome Workbench: Pesquisa científica sob ameaça</a> <br><br>  Um trecho de código do projeto NCBI Genome Workbench, que é um conjunto de ferramentas para estudar e analisar dados genéticos, abre os três principais vencedores.  Mesmo que você não precise ser um super-humano geneticamente modificado para encontrar esse bug, poucas pessoas sabem sobre a contingência para cometer um erro aqui. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Crypt a given password using schema required for NTLMv1 authentication * @param passwd clear text domain password * @param challenge challenge data given by server * @param flags NTLM flags from server side * @param answer buffer where to store crypted password */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds_answer_challenge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ntlm_v == <span class="hljs-number"><span class="hljs-number">1</span></span>) { .... <span class="hljs-comment"><span class="hljs-comment">/* with security is best be pedantic */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(hash, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(hash)); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(passwd_buf, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(passwd_buf)); ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  <b>Avisos do PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V597</a> O compilador pode excluir a chamada de função 'memset', usada para liberar o buffer 'hash'.  A função memset_s () deve ser usada para apagar os dados privados.  challenge.c 365 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V597</a> O compilador pode excluir a chamada de função 'memset', usada para liberar o buffer 'passwd_buf'.  A função memset_s () deve ser usada para apagar os dados privados.  challenge.c 366 </li></ul><br>  Você encontrou um bug?  Se sim, você é um attaboy! .. ou um super-humano geneticamente modificado. <br><br>  O fato é que os compiladores de otimização modernos são capazes de fazer muito para permitir que um programa criado funcione mais rapidamente.  Incluindo o fato de que os compiladores agora podem rastrear que um buffer, passado ao <i>memset</i> , não é usado em nenhum outro lugar. <br><br>  Nesse caso, eles podem remover a chamada "desnecessária" do <i>memset</i> , tendo todos os direitos para isso.  Em seguida, o buffer que armazena dados importantes pode permanecer na memória para o deleite dos atacantes. <br><br>  Nesse contexto, esse comentário nerd "com segurança é melhor ser pedante" soa ainda mais engraçado.  A julgar por um pequeno número de avisos, dados para este projeto, seus desenvolvedores fizeram o possível para serem precisos e escrever um código seguro.  No entanto, como podemos ver, é possível ignorar facilmente esse defeito de segurança.  De acordo com a Enumeração de fraqueza comum, esse defeito é classificado como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-14</a> : Remoção de código do compilador para limpar buffers. <br><br>  Você deve usar a função <i>memset_s ()</i> para que a desalocação de memória fique segura.  A função é mais segura que <i>memset ()</i> e não pode ser ignorada por um compilador. <br><br><h2>  Segundo lugar </h2><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o PVS-Studio se mostrou mais atento do que três programadores e meio</a> <br><br>  Um medalhista de prata foi gentilmente enviado a nós por um de nossos clientes.  Ele tinha certeza de que o analisador emitiu alguns falsos positivos. <br><br>  Evgeniy recebeu o e-mail, olhou através dele e enviou para Svyatoslav.  Svyatoslav examinou atentamente o código, enviado pelo cliente e pensou: "como é possível que o analisador tenha cometido tal erro?".  Então ele foi pedir conselhos a Andrey.  Ele também verificou o local e determinou: de fato, o analisador gerou falsos positivos. <br><br>  Então é isso, que precisava de conserto.  Somente depois que Svyatoslav começou a fazer exemplos sintéticos para criar a tarefa em nosso rastreador de erros, ele entendeu o que estava errado. <br><br>  Nenhum dos programadores conseguiu encontrar os erros, mas eles realmente estavam no código.  Francamente, o autor deste artigo também não conseguiu encontrá-los, apesar do fato de que o analisador emitiu claramente avisos sobre locais errados! <br><br>  Você encontrará um bug tão astuto?  Teste-se em vigilância e atenção. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/002/b12/75b/002b1275be55e7c96131de9f44d02ef7.png"></div><br>  <b>Aviso do PVS-Studio:</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V560</a> Uma parte da expressão condicional é sempre falsa: (ch&gt; = 0x0FF21).  decodew.cpp 525 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V560</a> Uma parte da expressão condicional é sempre verdadeira: (ch &lt;= 0x0FF3A).  decodew.cpp 525 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V560</a> Uma parte da expressão condicional é sempre falsa: (ch&gt; = 0x0FF41).  decodew.cpp 525 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V560</a> Uma parte da expressão condicional é sempre verdadeira: (ch &lt;= 0x0FF5A).  decodew.cpp 525 </li></ul><br>  Se você fez isso - parabéns para você! <br><br>  O erro está no fato de que o operador de negação lógica (!) Não é aplicado a toda a condição, mas apenas à sua primeira subexpressão: <br><br><pre> <code class="cpp hljs">!((ch &gt;= <span class="hljs-number"><span class="hljs-number">0x0FF10</span></span>) &amp;&amp; (ch &lt;= <span class="hljs-number"><span class="hljs-number">0x0FF19</span></span>))</code> </pre> <br>  Se essa condição for verdadeira, o valor da variável <i>ch</i> estará no intervalo [0x0FF10 ... 0x0FF19].  Assim, quatro comparações adicionais já não têm sentido: elas sempre serão verdadeiras ou falsas. <br><br>  Para evitar esses erros, vale a pena seguir algumas regras.  Em primeiro lugar, é muito conveniente e informativo alinhar o código como uma tabela.  Em segundo lugar, você não deve sobrecarregar as expressões entre parênteses.  Por exemplo, esse código pode ser reescrito assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLetterOrDigit = (ch &gt;= <span class="hljs-number"><span class="hljs-number">0x0FF10</span></span> &amp;&amp; ch &lt;= <span class="hljs-number"><span class="hljs-number">0x0FF19</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 0..9 || (ch &gt;= 0x0FF21 &amp;&amp; ch &lt;= 0x0FF3A) // A..Z || (ch &gt;= 0x0FF41 &amp;&amp; ch &lt;= 0x0FF5A); // a..z if (!isLetterOrDigit)</span></span></code> </pre> <br>  Dessa forma, haverá menos parênteses e, por outro lado - você provavelmente perceberá um erro ocasional. <br><br>  Aí vem a cereja no topo - vamos para o primeiro lugar! <br><br><h2>  Primeiro lugar </h2><br>  Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sistema chocado: erros interessantes no código-fonte do choque lendário do sistema</a> <br><br>  O principal finalista de hoje é um erro do lendário System Shock!  É um jogo lançado há muito tempo em 1994, que se tornou um antecessor e inspiração para jogos icônicos, como Dead Space, BioShock e Deus Ex. <br><br>  Mas primeiro tenho algo a confessar.  O que vou mostrar agora, não contém erros.  Na verdade, não é nem um pedaço de código, mas simplesmente não pude deixar de compartilhá-lo com você! <br><br>  O fato é que, ao analisar o código-fonte do jogo, minha colega Victoria descobriu muitos comentários fascinantes.  Em fragmentos diferentes, ela encontrou alguns comentários espirituosos e irônicos e até poesia. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// I'll give you fish, I'll give you candy, // I'll give you, everything I have in my hand // that kid from the wrong side came over my house again, // decapitated all my dolls // and if you bore me, you lose your soul to me // - "Gepetto", Belly, _Star_ // And here, ladies and gentlemen, // is a celebration of C and C++ and their untamed passion... // ================== TerrainData terrain_info; // Now the actual stuff... // ======================= // this is all outrageously horrible, as we dont know what // we really need to deal with here // And if you thought the hack for papers was bad, // wait until you see the one for datas... - X // Returns whether or not in the humble opinion of the // sound system, the sample should be politely obliterated // out of existence // it's a wonderful world, with a lot of strange men // who are standing around, and they all wearing towels</span></span></code> </pre><br>  É assim que os comentários deixados nos jogos pelos desenvolvedores nos últimos anos 90 se parecem ... Aliás, Doug Church - designer-chefe do System Shock, também estava ocupado escrevendo código.  Quem sabe, talvez alguns desses comentários tenham sido escritos por ele?  Espero que coisas de homens de toalha não sejam obra dele :) <br><br><h2>  Conclusão </h2><br>  Concluindo, gostaria de agradecer aos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meus colegas</a> por procurarem novos bugs e escrever sobre eles em artigos.  Obrigado pessoal!  Sem você, este artigo não seria tão interessante. <br><br>  Também gostaria de contar um pouco sobre nossas realizações, já que durante todo o ano não estivemos ocupados apenas pesquisando erros.  Também desenvolvemos e melhoramos o analisador, o que resultou em mudanças significativas. <br><br>  Por exemplo, adicionamos suporte a vários novos compiladores e expandimos a lista de regras de diagnóstico.  Também implementamos o suporte inicial dos padrões <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MISRA C e MISRA C ++</a> .  O novo recurso mais importante e demorado foi o suporte a um novo idioma.  Sim, agora podemos analisar o código em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java</a> !  E mais, temos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ícone renovado</a> :) <br><br>  Também quero agradecer aos nossos leitores.  Obrigado por ler nossos artigos e escrever para nós!  Você é tão sensível e tão importante para nós! <br><br>  Nossos 10 principais erros de C ++ de 2018 chegaram ao fim.  Quais fragmentos você mais gostou e por quê?  Você encontrou alguns exemplos interessantes em 2018? <br><br>  Tudo de bom, até a próxima! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444568/">https://habr.com/ru/post/pt444568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444558/index.html">Novidades do CUBA 7</a></li>
<li><a href="../pt444560/index.html">Convidamos você para a conferência “Clouds. Fashion Trends ”26 de março de 2019</a></li>
<li><a href="../pt444562/index.html">Modernização da GHIDRA. Carregadeira para rum Sega Mega Drive</a></li>
<li><a href="../pt444564/index.html">Desenvolvimento de produtos digitais com modelos mentais</a></li>
<li><a href="../pt444566/index.html">Sikorsky realizou uma demonstração de um helicóptero não tripulado com um homem a bordo</a></li>
<li><a href="../pt444570/index.html">Os 10 principais erros nos projetos C ++ para 2018</a></li>
<li><a href="../pt444572/index.html">LED piscando</a></li>
<li><a href="../pt444574/index.html">Miniatura Macintosh Plus</a></li>
<li><a href="../pt444576/index.html">Como o sistema de tipos aprimora seu código JavaScript</a></li>
<li><a href="../pt444578/index.html">Top 3D Expo 2019: Yousef Hesuani, da 3dbio - impressão 3D de órgãos e tecidos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>