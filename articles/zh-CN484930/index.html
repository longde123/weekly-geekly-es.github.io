<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👺 😡 🧝🏾 让我们像专业人士一样快速编码 🚱 🛎️ ↪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="给我一个杠杆，支点，腿部空间和加固胶带 



 即使您尝试，也无法简洁地描述无底兔子洞在等着您。 这是一种罕见的情况，为了意识到所要讨论的内容，必须听完语音直到最后。 在研究了本手册中的步骤之后，每个人都会为自己找到一些东西：深奥的“文本”编辑器Leo Editor本质上要求以最惊人的方式使用它。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>让我们像专业人士一样快速编码</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484930/"><a name="-3721286893347102143"></a><br>  <i>给我一个杠杆，支点，腿部空间和加固胶带</i> <br><br><img src="https://habrastorage.org/webt/bs/wp/d5/bswpd5ybplisrptr7ccagqpxzeq.png"><br><br> 即使您尝试，也无法简洁地描述无底兔子洞在等着您。 这是一种罕见的情况，为了意识到所要讨论的内容，必须听完语音直到最后。 在研究了本手册中的步骤之后，每个人都会为自己找到一些东西：深奥的“文本”编辑器Leo Editor本质上要求以最惊人的方式使用它。 <br><a name="habracut"></a><br><br><hr><br><a name="6536789276955976413"></a><h3> 目录内容 </h3><br><pre>  1.序言.................................................. 2 </pre><pre>  2.安装Leo Editor ..................... 2 </pre><pre>  3.设置.............................................. 4 </pre><pre>  4.了解界面....................... 7 </pre><pre>  5.创建外部文件................. 14 </pre><pre>  6.使用命名节........ 18 </pre><pre>  7.贪婪的包容........................ 21 </pre><pre>  8.简单的魔法...................... 24 </pre><pre>  9.狼人的反面... 30 </pre><pre>  10.可视化........................ 33 </pre><pre>  11.内容和形式................................ 36 </pre><pre>  12.我将为自己构建一个IDE ................................... 39 </pre><pre>  13.思想自由.................................... 49 </pre><pre>  14.万岁，结束.................................... 58 </pre><pre>  15. UPD。 应用实例................. 58 </pre><br><br><hr><br><a name="-8062973727183538081"></a><h3> 序言 </h3><br> 当您使用任何编程语言编写程序时，Smalltalk总是会严重短缺类浏览器，无休止地让人感到您的双手被绑住，双腿潮湿。 碰巧的是，您经常在Internet上查找一件事，却发现完全不同的事物，但它是如此美丽，以至于在不断发展的视野中迷失了开始搜索的原因。 搜索短语“ python类浏览器”会产生大量垃圾，但是一颗未切割的钻石躺在这座山上，朦胧地闪闪发光，没有引起广泛的兴趣，等待着细心的眼睛和好奇的头脑注意到并捡起它。 <br><br><hr><br><a name="2880776877099406402"></a><h3> 安装Leo编辑器 </h3><br> 该项目是跨平台的，为Windows平台提供了安装过程。 要启动编辑器，您需要Python和Qt库。 对于没有准备好遭受痛苦的用户来说，所描述的安装选项是最简单的，专业人员可以自行决定采取行动。 <br><br> 安装Miniconda python程序员工作区管理器。 该解决方案使您能够严重降低获取南瓜而不是正确连接组件的能力，并且在出现任意死锁的情况下，可以轻松回滚到零状态并快速切换到测试其他调整选项。 <br><br> 从<a href="https://docs.conda.io/en/latest/miniconda.html" rel="nofollow">下载</a>页面，我们<a href="https://docs.conda.io/en/latest/miniconda.html" rel="nofollow">下载</a> Python 3.7 Miniconda3 Windows 64位安装程序。 我们设置何时出现有关复选标记的问题，同时激活两个。 <br><br> 接下来，运行命令行（键[Win + R]，“ cmd”和[Enter]）。 我们输入： <br><br><pre><code class="python hljs">conda</code> </pre> <br><img src="https://habrastorage.org/webt/ha/cu/c8/hacuc8cazut2uy63obxfpyge0sg.png" alt="返回图片"><br><br> 没有错误，可以直接访问conda。 我们检查所需语言执行程序版本的可用性： <br><br><pre> <code class="python hljs">python -V</code> </pre> <br><img src="https://habrastorage.org/webt/r4/hx/ay/r4hxay-rr-yikcwtoekbpmu6cxw.png" alt="返回图片"><br><br> 当场。 <br><br> 我们看一下可以安装哪些版本的编辑器： <br><br><pre> <code class="python hljs">pip install leo==</code> </pre> <br> 我们更喜欢数字中不包含字母的最新版本： <br><br><pre> <code class="python hljs">pip install leo==<span class="hljs-number"><span class="hljs-number">6.1</span></span></code> </pre> <br> 完成下载，解压缩和安装后，我们会碰碰运气：我们启动python解释器，连接到编辑器的组件，启动编辑器 <br><br><pre> <code class="python hljs">python &gt;&gt;&gt;<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> leo &gt;&gt;&gt;leo.run()</code> </pre> <br><img src="https://habrastorage.org/webt/2e/dk/ny/2edkny_aonp4og2ro4hnt7tr-1y.png" alt="返回图片"><br><br><hr><br><a name="4776649687880223128"></a><h3> 客制化 </h3><br> 如果启动快捷方式未出现在桌面上，请自行添加： <br><br> 编辑<b>器启动器的</b>路径： <b>％USERPROFILE％\ Miniconda3 \ Scripts \ leo.exe</b> <br>  <b>图标</b>路径： <b>％USERPROFILE％\ Miniconda3 \ Lib \ site-packages \ leo \ Icons \ SplashScreen_trans.ico</b> <br><br><img src="https://habrastorage.org/webt/bc/yd/bo/bcydbogdz6nbi07ge4xcsvvgn-a.png" alt="返回图片"><br><br> 我不太喜欢原生视觉主题的外观，因此必须自己制作。 要使用它，您必须首先<a href="" rel="nofollow">下载它</a> 。 无病毒1000％。  <b>python.py</b>文件是用于区分python语法元素的颜色的描述。 必须将它放在<b>％USERPROFILE％\ Miniconda3 \ Lib \ site-packages \ leo \ modes \中</b> ，并替换先前的文件。 为了让您投降python语言，稍后会变得更加清楚。 存档中的其余文件必须复制到<b>％USERPROFILE％\ Miniconda3 \ Lib \ site-packages \ leo \ themes \</b>文件夹中。 <br><br> 现在，您需要在用户设置中启用主题。 <br><br><img src="https://habrastorage.org/webt/vi/8b/5p/vi8b5p_zzoakhqtcp7s-z_p-mjk.png" alt="返回图片"><br><br> 单击@settings元素，然后使用[Insert]键添加一个新的嵌套元素。 粘贴文字： <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@string theme-name = monokai.leo</span></span></code> </pre> <br> 要保存更改，请按[Enter]。 如果不经意地禁用了编辑元素名称的操作，则可以通过双击元素或按组合键[Ctrl + h]来启用它。 <br><br><img src="https://habrastorage.org/webt/ra/6c/sn/ra6csntglplwfyymwmkvogjg33m.png" alt="返回图片"><br><br> 重新开始保存更改。 <br><br><img src="https://habrastorage.org/webt/pd/8k/iw/pd8kiwspzu7g6r6so-kog-bcmn0.png" alt="返回图片"><br><br> 与“ .leo”文件的关联应该自动发生，但是如果没有关联，那么我们将使用内置解决方案。 <br><br><img src="https://habrastorage.org/webt/8j/m7/vk/8jm7vkgfspuic_vtvixambayksi.png" alt="返回图片"><br><br> 直到最近，如果不进行修改，这是行不通的，现在，它们已经修复了，好象呵呵。 <br><br><hr><br><a name="-4747586124033388480"></a><h3> 了解界面 </h3><br><img src="https://habrastorage.org/webt/qo/sx/ht/qosxhtzii3tqpke-cuatygnju04.png" alt="返回图片"><br><br> 乍一看，我们面前有一个普通的结构化文本编辑器（英语大纲编辑器，大纲概述），是许多人钟爱的<a href="http://www.treepad.com/download/" rel="nofollow">树状目录</a>的克隆版本（不幸的是，由于开发人员的财务问题，该网站的离线文档已被禁用）。 实际上，有一棵树，并且存在一个用于输入属于所选树节点的文本的区域。 带有简单名称Tabs的多功能区域，除了日志外，还可以得出其他有用的信息，让我们从搜索文本开始。 <br><br><img src="https://habrastorage.org/webt/s_/le/1f/s_le1fvceqursn2l0drhjju8jnm.png" alt="返回图片"><br><br> 这似乎是一种定型观念，但是有些怪异，建议您按键盘上的按键，而不是屏幕上的按钮。 并且find-all命令根本没有分配的键。 现在所有的注意力都在窗口的最底部。 <br><br><img src="https://habrastorage.org/webt/2l/ql/ea/2lqleaipeb__rfzxyh6evxkj7ym.png" alt="返回图片"><br><br>  Tru-geeks一定已经on了啤酒。 是的，这是从emacs直接借来的。 可以使用内置命令行启动大多数编辑器操作。 <br><br><img src="https://habrastorage.org/webt/1_/3k/ou/1_3kousf5qtse2sbt64atbhgch4.png" alt="返回图片"><br><br><img src="https://habrastorage.org/webt/vr/qb/zu/vrqbzuk25oc1cvgy1kidr6l53vc.png" alt="返回图片"><br><br><img src="https://habrastorage.org/webt/gk/dp/o3/gkdpo31sx-err8br6ijunch0f0w.png" alt="返回图片"><br><br> 所有出现的单词“ the”的搜索结果将显示在故意创建的新树节点中。 集体农场！  （不必担心，像健康的叔叔一样，逐元素搜索会“遍历”检测到的事件）。 <br><br><img src="https://habrastorage.org/webt/h6/3h/ml/h63hmlg2u-yz3qymcmgjbdvkzwi.png" alt="返回图片"><br><br> 青春，不要分散！ 有必要摇动入睡的水泡。 您总是可以绕过这个暗区Leo Editor的边缘。 该程序看起来很像Linux：热情，各种发烧友为自己完成的一切工作，都需要经过深思熟虑的研究，一个的性能与另一个的实现不同，发现有人放置但没有真正描述的新芯片总是令人惊讶的，并且尽管如此，冰山的一角很舒适，就在上面，如果您不愿冒险，就不能陷入阴暗的深渊。 <br><br><img src="https://habrastorage.org/webt/cj/w-/kv/cjw-kvo65so7hbqsc6y11mria0o.png" alt="返回图片"><br><br> 标签区域允许您将标签分配给节点，然后再使用它们。 显然是用来增加新的维度到混乱秩序的深度。 我们选择节点，编写标签标识符，然后单击“ +”。 我们选择另一个节点，只需在其上按“ +”，将分配活动标签。 我们选择第三个节点，输入“ Schmucker”，然后按“ +”。 当前，我们有两个带有标签“ zutsker”的节点和一个带有标签“ shmutsker”的节点。 <br><br><img src="https://habrastorage.org/webt/ch/lr/hf/chlrhfbmj325z-h6vck3ybz7qt8.png" alt="返回图片"><br><br> 从标签列表中选择一个标签会导致一个与标签相关联的节点列表，其中包含您可以浏览的名称。 为了从节点中选择标签，请右键单击它。 <br><br><img src="https://habrastorage.org/webt/og/tv/yn/ogtvyneaexeyihffhqfxu0zekly.png" alt="返回图片"><br><br> 接下来是极为有用的Nav面板。 它有助于快速忽略出现某个单词的节点。 由于维护.leo文件的方式与组织的高度混乱，因此通过搜索导航适合应用程序的自然循环。 <br><br><img src="https://habrastorage.org/webt/_c/wb/ut/_cwbutedkrqmfvf1wjqq4outla0.png" alt="返回图片"><br><br> 结构化文本的编辑者的普遍用途是积累个人知识库。 第二个最常见的用途是维护任务列表。 下一个标签有助于使该过程具有优先级，截止日期和实施状态。 <br><br><img src="https://habrastorage.org/webt/wc/hl/yz/wchlyzsaykdqr4hyqlhkb4yi-yc.png" alt="返回图片"><br><br> 节点的上下文菜单允许您使用“任务”选项卡的大部分功能。 <br><br><img src="https://habrastorage.org/webt/wu/rv/bs/wurvbsy7uqpfmwqbsmaykrnwzqc.png" alt="返回图片"><br><br><hr><br><a name="8676585719944597034"></a><h3> 创建外部文件 </h3><br> 如何自行编辑文本和使用树将很容易，所以我们将深入探讨将抽象转移到现实世界的无限可能性。 创建一个新文件。 <br><br><img src="https://habrastorage.org/webt/bc/ij/42/bcij428cc79akn0eyavalxli2zg.png" alt="返回图片"><br><br> 单节点<code>NewHeadline</code>的名称更改为<code>@file 1.txt</code> <br><br><img src="https://habrastorage.org/webt/__/sl/z4/__slz4h4dcm72wdd6jpkiwrezyy.png" alt="返回图片"><br><br> 在节点的内容中添加一些文本。 <br><br><img src="https://habrastorage.org/webt/w4/i3/xq/w4i3xqq_xbl13vwenzkxjs38sa0.png" alt="返回图片"><br><br> 将.leo文件保存在某处。 打开.leo文件所在的文件夹。 我们注意到那里1.txt。 我们打开它。 <br><br><img src="https://habrastorage.org/webt/7c/jq/in/7cjqinybukhwzgj-ygtkw6fn0zi.png" alt="返回图片"><br><br> 我们建造了什么？ 我们配置了将.leo文件的节点之一导出到外部文件的配置。 <br> 我们的文字周围有什么垃圾？ 当您将文件重新加载到Leo编辑器中时，允许您重新创建结构的元数据，如果要在外部的某个地方修改文件，这是必需的。 可以将Leo Editor源代码中的大多数python文件拖放到编辑器中，并发现它们包含对结构的描述： <br><br><img src="https://habrastorage.org/webt/tb/pq/2w/tbpq2wftvfbxui1ep3mtmnuwnm4.png" alt="返回图片"><br><br> 但是，如果我们根本不需要反向上传功能，但是相反地希望文件不包含多余的字节，则可以通过将<code>@file</code>指令替换为<code>@file-nosent</code> （没有哨兵）来实现。 <br><br><img src="https://habrastorage.org/webt/3g/rs/zm/3grszmu_9y8ecpimh7c8uup2u5c.png" alt="返回图片"><br><br> 将更改保存在.leo文件中后，外部文件将自动更新。 <br><br><img src="https://habrastorage.org/webt/kt/mm/s7/ktmms7lvxrgbg7on3qwn_ztv50q.png" alt="返回图片"><br><br><hr><br><a name="8660274410618002191"></a><h3> 使用命名部分 </h3><br> 每个节点都是一个单独的独立实体，默认情况下，它不具有有关其邻居的信息。 如果我们尝试将新结构添加到附加到外部文件的节点上，然后单击“保存”，则会发生错误。 <br><br><img src="https://habrastorage.org/webt/h3/ni/l3/h3nil34qcymcbqmujd-rrgdo9oc.png" alt="返回图片"><br><br> 我们收到两个问题的通知： <br><br><ol><li> 我们有一个“测试”节点悬在空中（相对于外部文件，因为.leo结构内部有一个节点，但是我们没有指出应如何将其添加到外部文件中，因此会出现错误）。 </li><li> 在解决悬挂节点的问题之前， <code>@file-nosent 1.txt</code>内部的其他更改都不会保存到磁盘。 </li></ol><br> 在节点之间添加链接的第一种方法是通过部分。 节名称的特殊格式如下所示： <br><br><pre> <code class="python hljs">&lt;&lt;my_name&gt;&gt;</code> </pre> <br> 这使您可以将嵌套节点声明为命名节，必须在要放置从属节点内容的外部节点的位置指定相同的名称。 <br><br><img src="https://habrastorage.org/webt/nw/fz/yc/nwfzyca8yzogl68dvzyakpovwga.png" alt="返回图片"><br><br><img src="https://habrastorage.org/webt/re/wf/f5/rewff5m9lk-8m-eeakceca1rinq.png" alt="返回图片"><br><br> 结果文件： <br><br><img src="https://habrastorage.org/webt/xd/nh/eq/xdnheqggz3e--z0yi-rknc-1gm8.png" alt="返回图片"><br><br> 在真实文件中的同一示例中，外部依赖项的import部分显式分配给单独的节点。 <br><br><img src="https://habrastorage.org/webt/6a/sz/dz/6aszdzhcjnepvok_w38civmpzru.png" alt="返回图片"><br><br><hr><br><a name="-8905995785252255061"></a><h3> 贪婪包容 </h3><br> 但是，如果我们想在嵌套部分中构建一个嵌套部分并在其中放置另一个部分，该怎么办？ 您可以天真地采取行动： <br><br><img src="https://habrastorage.org/webt/2t/la/1z/2tla1zlk_6wfkdrzvamjcjr-_wm.png" alt="返回图片"><br><br> 但是对于这种自然的需求，有多达两个指令： <code>@all</code>和<code>@others</code> 。 <br><br>  <code>@all</code>指令无味地连接所有嵌套节点的文本。 <br><br><img src="https://habrastorage.org/webt/ig/ba/98/igba98h0g3i_jnw9uvfyaoxyam4.png" alt="返回图片"><br><br> 当然，这完全取决于您在输出中所需的文件格式，但是您可能会喜欢<code>@others</code>指令<code>@others</code> ，它允许您以期望的形式实现设计的结构。 渴望的选择： <br><br><img src="https://habrastorage.org/webt/jc/zv/yx/jczvyxyegvbjfzj6fz4duni0plu.png" alt="返回图片"><br><br> 用关键字包装部分： <br><br><img src="https://habrastorage.org/webt/so/gq/vy/sogqvy6rnt2bdbsxazcunqpwvti.png" alt="返回图片"><br><br> 缩进格式： <br><br><img src="https://habrastorage.org/webt/z6/7g/ri/z67gricobxjhc-u8jbqj2qwsxh4.png" alt="返回图片"><br><br> 怎么了 它开始成形了吗？ 我们几乎没有真正的乐趣。 <code>:: ::</code> <br><br><hr><br><a name="-3833477485645352909"></a><h3> 简单的魔术 </h3><br> 最后，我们开始编写代码。 该任务将很愚蠢，但包含有用程序的典型基本元素。 在现有文件或新文件中的任何位置创建一个新节点。 第一行指示<code>@language</code>指令以启用代码突出显示。 如果在文件夹<b>USERPROFILE％\ Miniconda3 \ Lib \ site-packages \ leo \ modes \</b> no下以突出显示的语言显示，则没有人禁止自己添加它。 <br><br><img src="https://habrastorage.org/webt/tg/jb/hr/tgjbhrwjoomtqekvklfjj-ogs94.png" alt="返回图片"><br><br> 假设我们要处理的信息是由平板存储在csv文件中的。 <br><br> 我们需要：计算在计数列中找到的字符“ 0”的数目 <br><br> 我们必须： <br><br><ol><li> 将文本转换为样本数据结构 </li><li> 用计数执行迭代 </li></ol><br><img src="https://habrastorage.org/webt/0q/m4/-n/0qm4-nyl5k7sx6zjch6wmrl4lri.png" alt="返回图片"><br><br> 我们根据开发的算法对程序进行分解。 读取文件后的第二步，将文本分成几行。 第一步是移至“读取”从属节点。 <br><br><img src="https://habrastorage.org/webt/eo/ft/sl/eoftslelbk5jfbojmgbj2pvltdo.png" alt="返回图片"><br><br> 接下来，创建一个与表中数据相对应的字典数组。 该节点在上层。 <br><br><img src="https://habrastorage.org/webt/up/wz/2d/upwz2dsukhgrbm-hzenv_lzax5i.png" alt="返回图片"><br><br> 最后一步。 <br><br><img src="https://habrastorage.org/webt/ou/di/wf/oudiwfouo9kzssifvj4vhw68m9o.png" alt="返回图片"><br><br> 同时，生成的main.py文件将在磁盘上形成。 <br><br><img src="https://habrastorage.org/webt/bs/ll/2f/bsll2fsk2zh79nuc9s4dpktnue0.png" alt="返回图片"><br><br> 万岁，我们很棒。 但是突然之间，我们就产生了一个难以理解的愿望：要计算同一csv文件中的有效行数。 没问题，请在主节点上执行copy.paste，更改输出文件的名称，修改最后一步的代码。 我们得到结果。 <br><br><img src="https://habrastorage.org/webt/z7/ss/l0/z7ssl0j-eqbg5odezgmowymj8fy.png" alt="返回图片"><br><br> 在这里，我们的喜悦变成了悲伤，因为CSV文件的名称可能会有所不同，这意味着，如果我们在一个程序中对其进行更正，那么在第二个程序中，我们肯定会看不到它，从而降低重用代码的乐趣。 <br><br> 悲伤又漂亮，它是狮子座编辑器！ 它具有节点的同步副本。 什么啊 代替复制节点的内容，可以将复制的节点粘贴到“克隆”，“幻像”模式下，然后更改链接的节点之一将显示在其他节点上。 这是一个非常强大的概念，可让您解决树状信息组织中固有的矛盾。 <br><br> 复制节点。 <br><br><img src="https://habrastorage.org/webt/er/xw/pn/erxwpnkkqejwxpb2s517n9njurk.png" alt="返回图片"><br><br> 我们将其插入为“幻像”。 <br><br><img src="https://habrastorage.org/webt/14/qs/ja/14qsjab2ynqn0vfnbtk4qivnh1q.png" alt="返回图片"><br><br> 幻像具有不同的图标。 名称，内容或从属节点的任何更改都会反映在副本中。 我们删除旧的“读取”节点，并验证是否已在所有位置同步执行文件名的修改。 <br><br><img src="https://habrastorage.org/webt/0s/cl/vn/0sclvnrov4vkh3cws1od-bzzxhm.png" alt="返回图片"><br><br> 用数学语言来说，“幻像”使您可以从树上切换到完整的无环图。 狮子座的一棵树可以有多个根！ <br><br><img src="https://habrastorage.org/webt/rw/au/01/rwau011gadnk7enqqz5al7gjoxm.png" alt="返回图片"><br><br> 这使您可以做奇妙的事情：处理信息表示，绑定异构数据容器，在一个项目中拥有无限数量的实际数据副本，将数据加载到无法放在常规树中的Leo树中。 <br><br><hr><br><a name="8303075129098866152"></a><h3> 狼人逆转 </h3><br> 让我们做一个实验。 创建一个新节点。 向其添加文本。 <br><br><pre> <code class="python hljs">g.es( len(<span class="hljs-string"><span class="hljs-string">"This is test"</span></span>.split()) )</code> </pre> <br><img src="https://habrastorage.org/webt/qc/qo/y3/qcqoy38akv77okkyyfntatxwcky.png" alt="返回图片"><br><br> 按[Ctrl] + [b]。 <br><br><img src="https://habrastorage.org/webt/mp/yz/vi/mpyzviirkgybwg_0b6j27dbpdxi.png" alt="返回图片"><br><br>  Chpok，晚上好。 是的，事实证明，Python解释器是内置的，可以将节点的文本作为代码执行。 如果根据将节连接到外部文件的规则将节连接到节点，则还将执行节中的代码，这意味着没有力量可以阻止我们陷入混乱。 <br><br><img src="https://habrastorage.org/webt/a2/bc/d8/a2bcd8zf38syhiikpjjevvefsmg.png" alt="返回图片"><br><br> 生活示例：教程的代码非常不愿意正常编写，但是如果它超过50行，则可以保证第二天变得不可读的混乱。 值得补充的是，许多培训师使用相同的源数据集，并对它们执行各种操作。 以上适用于任何“原型”或“工具实用程序1-2次”。 在这里，描述的Leo Editor芯片非常有用。 <br><br><img src="https://habrastorage.org/webt/o6/16/pq/o616pqawiqhh-ez8j50flfiurgm.png" alt="返回图片"><br><br> 就是这些-这些代码可以在Leo编辑器中执行某些操作，而无需将其上传到.py文件。 <br><br> 与图片中的意大利面条表不同，您可以立即了解正在发生的事情的一般本质。 例如，在“ 4线性回归”程序中，来自Internet的数据首先被写入文件。 然后对根据该文件构建的“ OLS回归”数值模型进行各种操作。 此外，如果我们需要使用其他数据或模型的其他设置，则只需在一个节点上进行更改就足够了，因为程序的重用部分是由“幻像”实现的。 该程序分为6个独立的部分，每个部分分别启动，但是同时它们从一个共同点开始执行。 <br><br> 如果将相似主题的代码有条理地存储在一个地方，即使很长时间也很方便，然后使用导航搜索可以快速找到一些特定方法，结构化组织将有助于导航正在发生的事情。  “幻影”使您可以将复杂的非线性代码转换为一组顺序的动作，而“克隆”实体不会乘以熵，而是会减少熵，因为重复被绑定所取代，并且不会创建附加的抽象层次。 <br><br> 具有源文件的50个分散文件是50个分散文件。 具有源代码的50个节点是一个具有内部自组织愿望的知识库。 <br><br><hr><br><a name="6489739171880902750"></a><h3> 可视化 </h3><br> 在开始噩梦难度级别之前，让我们回到界面。 <br><br> 可以拖动编辑器面板以最佳方式组织工作区。 每个文件保留其自己的外观设置。 您可以关闭除树以外的所有面板。 为了返回面板，请右键单击树标题。 <br><br><img src="https://habrastorage.org/webt/mw/02/fn/mw02fnk_x9vyosnaysilvtrjofy.png" alt="返回图片"><br><br> 在同一菜单中有一个特定的“渲染”。 这个小东西是根据其名称设计的，可以显示世界上的一切。 <br><br> 默认情况下，渲染尝试将节点的文本渲染为<a href="https://ru.wikipedia.org/wiki/ReStructuredText" rel="nofollow">reStructuredText</a> 。 通过强制节点名称中的内容类型，可以包括其其他操作模式。 <br><div class="scrollable-table"><table><tbody><tr><th> 编号 </th><th> 内容类型 </th><th> 注意事项 </th></tr><tr><td> <code>@asciidoc</code> </td> <td>  Asciidoctor文档标记 </td><td> 需要安装Asciidoctor </td></tr><tr><td> <code>@html</code> </td> <td>  HTML标记 </td><td></td></tr><tr><td> <code>@graphics-script</code> </td> <td> 通过QT类QGraphicsView，QGraphicsScene的自定义GUI绘图 </td><td></td></tr><tr><td> <code>@image</code> </td> <td> 显示流行格式的图片 </td><td> 图片的路径显示在正文中 </td></tr><tr><td> <code>@svg</code> </td> <td>  SVG映射 </td><td> 主体指示图像的路径或源SVG </td></tr><tr><td> <code>@jupyter</code> </td> <td> 显示Jupyter互动会议 </td><td> 无法正常运作 </td></tr><tr><td> <code>@latex</code> </td> <td>  LaTeX标记显示 </td><td> 无法正常运作 </td></tr><tr><td> <code>@md, @markdown</code> </td> <td> 降价标记显示 </td><td> 需要安装Markdown处理器 </td></tr><tr><td> <code>@movie</code> </td> <td> 视频展示 </td><td> 视频的路径在正文中指定 </td></tr><tr><td> <code>@pyplot</code> </td> <td> 使用Matplotlib Python显示图表 </td><td> 需要安装Matplotlib Python </td></tr></tbody></table></div><br> 从表中可以看到，Render的功能不是很强大，好消息是Leo Editor可以使用包括可视插件在内的插件进行扩展。 例如，我需要将数字加载到表格中并绘制图形，同时将初始数据更改一千倍。 <br><br><img src="https://habrastorage.org/webt/ch/r4/wo/chr4wogoa2al2lkxoemc7sbwgai.png" alt="返回图片"><br><br> 最小的可视插件代码如下所示： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> leo.core.leoQt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtCore, QtGui, QtWidgets <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> leo.core.leoGlobals <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> g <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">My_Plugin_Widget</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(QtWidgets.QWidget)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parent=None, leo_com=None)</span></span></span><span class="hljs-function">:</span></span> super(My_Plugin_Widget, self).__init__(parent) c = leo_com self.c = c self.layout = QtWidgets.QVBoxLayout() self.message = QtWidgets.QLabel(<span class="hljs-string"><span class="hljs-string">"Hello there!"</span></span>, self) self.layout.addWidget(self.message) self.setLayout(self.layout) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> g.registerHandler(<span class="hljs-string"><span class="hljs-string">"after-create-leo-frame"</span></span>, onCreate) g.plugin_signon(__name__) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tag, keys)</span></span></span><span class="hljs-function">:</span></span> c = keys.get(<span class="hljs-string"><span class="hljs-string">"c"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> c: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dw = c.frame.top dock = g.app.gui.create_dock_widget(closeable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, moveable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, height=<span class="hljs-number"><span class="hljs-number">150</span></span>, name=<span class="hljs-string"><span class="hljs-string">'My plugin'</span></span>) dw.leo_docks.append(dock) dock.setWidget(My_Plugin_Widget(leo_com=c)) dw.splitDockWidget(dw.body_dock, dock, QtCore.Qt.Horizontal) dock.show()</code> </pre><br> 该插件是必需的： <br><br><ol><li> 保存到<code>%USERPROFILE%\Miniconda3\Lib\site-packages\leo\plugins\</code> </li><li> 在<code>@settings\@enabled-plugins</code>节点的myLeoSettings.leo文件中注册 </li></ol><br><img src="https://habrastorage.org/webt/6b/h_/ki/6bh_kilslo6qhcrockexd6hda-y.png" alt="返回图片"><br><br> 您可以<a href="https://leoeditor.com/writingPlugins.html" rel="nofollow">在此处</a>阅读有关如何制作插件的<a href="https://leoeditor.com/writingPlugins.html" rel="nofollow">信息</a> ，如果急于获取更多信息，那么唯一的方法是亲自研究viewrendered.py插件。 <br><br> 为什么这一切呢？ 再次以无限的可能性。 完全访问QT允许您以任意方式重现信息，或者以最意外的方式输入信息。 <br><br><hr><br><a name="7875362295725291402"></a><h3> 内容和形式 </h3><br> 上面描述的所有内容看起来都像是一种便捷的工具，可以解决有限的屏幕任务，仅此而已。 从树到外部文件的转换是线性的，并且受到严格帧的限制。 甚至节点的名称也起注释的作用，但不具有其他有用的功能。 但实际上，事实证明，用树描述人类思维的复杂实体非常合适，但与此同时，机器的格式可能看起来不像任何东西和/或可能根本没有任何不同的结构。 对于一个简单的示例，采用HTML。 以这种形式准备标记将非常方便和容易（价值判断）： <br><br><img src="https://habrastorage.org/webt/aw/xz/dk/awxzdkeoklyjunjupqouj-vwn28.png" alt="返回图片"><br><br> 一切在结构上都是一致的，可视的，不可能犯不关闭标签或错误放置标签的错误，并且进行任何规模的更改都是基本的。 尽管HTML输出文件将与该虚拟结构成“线性比例”，但是节附加机制无法产生以下内容： <br><br><ol><li> 开闭标签 </li><li> 将节点文本分配为标签属性 </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 具有特殊名称“&gt; &lt;”的节点的文本放置在相应的标记内 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，当然，Leo Editor允许从节点代码无限制地访问树。</font><font style="vertical-align: inherit;">用于阅读和写作。</font><font style="vertical-align: inherit;">这使得可以对人机信息进行任意修改。</font><font style="vertical-align: inherit;">可以根据您的喜好在任何方向和次数上。</font><font style="vertical-align: inherit;">您可以下载某种格式，将其重建为您可以理解的树，进行更改并将其转换回。</font><font style="vertical-align: inherit;">如果输出格式不重要，则可以使用Python编写外部文件。</font><font style="vertical-align: inherit;">如果格式很复杂和/或存在大量数据，那么花时间将数据转移到具有节的文件节点是有利的，因为这极大地方便了转换的调试。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用树的功能说明：</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 团队 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 效果 </font></font></th></tr><tr><td> <code>g.es('text')</code> </td> <td>  <code>print('text')</code>  Leo Editor </td></tr><tr><td> <code>n = g.findNodeAnywhere(c, 'TITLE')</code> </td> <td>      'TITLE' </td></tr><tr><td> <code>for node in n.children():</code> </td> <td>     </td></tr><tr><td> <code>node.h</code> </td> <td>   /    </td></tr><tr><td> <code>node.b</code> </td> <td>   /    </td></tr><tr><td> <code>node.parent()</code> </td> <td>    </td></tr><tr><td> <code>p</code> </td> <td>        () </td></tr><tr><td> <code>c.selectPosition(p)</code> </td> <td>      </td></tr><tr><td> <code>root_node = p.findRootPosition()</code> </td> <td>     </td></tr><tr><td> <code>for node in root_node.following_siblings():</code> </td> <td>      </td></tr><tr><td> <code>if node.h.startswith('OUTPUT'):</code> </td> <td> ,      'OUTPUT' </td></tr><tr><td> <code>new_node = node.insertAsLastChild()</code> </td> <td>     </td></tr><tr><td> <code>if node.hasChildren():</code> </td> <td>     </td></tr><tr><td> <code>new_node = node.insertAfter()</code> </td> <td>    </td></tr><tr><td> <code>node.deleteAllChildren()</code> </td> <td>     </td></tr><tr><td> <code>c.redraw_now()</code> </td> <td>       </td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以从Leo Editor源文件和完整的.leo文件中选择其他功能，但</font><font style="vertical-align: inherit;">实际上没有任何</font><font style="vertical-align: inherit;">文档（</font></font><a href="https://leoeditor.com/scripting-miscellany.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除此页面外</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）=（</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一下，本文是用Leo Editor编写的。</font></font><br><br><img src="https://habrastorage.org/webt/7c/jy/se/7cjysejdovoiwaupkykrghhac3k.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下代码用于将树导出为HTML：</font></font><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@language python from pathlib import Path @others path = Path('C:\\Projects\\article\\') / 'out.html' out_text = '&lt;body&gt;&lt;script&gt;document.body.style.fontSize = 20;&lt;/script&gt;' n = g.findNodeAnywhere(c, 'TITLE') assert nh == ('TITLE') tag = f'&lt;h1&gt;{nb}&lt;/h1&gt; ' out_text = out_text + tag + '\n\n' n = g.findNodeAnywhere(c, 'TEXT') assert nh == ('TEXT') for header_node in n.children(): anchor_id = hash(header_node.h) tag = f'&lt;anchor&gt;{anchor_id}&lt;/anchor&gt;&lt;h3&gt;{header_node.h}&lt;/h3&gt;' out_text = out_text + tag + '\n' if '' == header_node.h: text = make_toc(header_node) tag = f'{text}' out_text = out_text + tag + '\n' for content_node in header_node.children(): if '@image' in content_node.h: tag = f' &lt;img src="{content_node.b}" alt="  "&gt; ' else: text = content_node.b if not 'table' in content_node.h: content_node.h = ' '.join(content_node.b.split()[:3]) text = text.replace('\n', ' ') tag = f'{text}' out_text = out_text + tag + '\n' tag = ' &lt;hr/&gt;' out_text = out_text + tag + '\n' out_text = out_text + '&lt;/body&gt;' + '\n' with open(path, 'w', encoding='utf-8') as f: f.write(out_text) g.es('.')</span></span></code> </pre><br><hr><br><a name="8959787350272421010"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我将为自己构建一个IDE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是一个单一的python，所以让我们尝试在...任何东西下面装备一个角落。首先，最后按下脚本按钮。</font></font><br><br><img src="https://habrastorage.org/webt/-m/49/cy/-m49cyjd2z2j4fqqgz-_nzvevu8.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此操作将导致在主菜单下出现带有当前节点名称的新按钮。逻辑建议单击此新建按钮将导致尝试从与该按钮关联的节点执行代码。重新启动编辑器后，按钮蒸发很方便，但很不方便。要使按钮始终保持在其位置，您需要在节点名称中添加特殊拼写，</font></font><code>@button</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后重新启动Leo Editor。</font></font><br><br><img src="https://habrastorage.org/webt/0o/yl/41/0oyl41iawam8pr3cjpxoxxp7iz0.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以为每个用户按钮分配一个使用以下表达式的热键：</font></font><code>@key=</code> <br><br><img src="https://habrastorage.org/webt/n-/tn/3z/n-tn3zjwrwb7okkir_6xpwbgeyw.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了从一个脚本运行另一个脚本，您必须调用该函数</font></font><code>c.executeMinibufferCommand('FIRE')</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">每个带有链接按钮的脚本都以该按钮的名称落入编辑器命令的常规库中，也就是说，您的脚本也可以从编辑器的命令行运行。</font></font><br><br><img src="https://habrastorage.org/webt/bi/da/7a/bida7a2uekcu64nnltxvua3wqxu.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了从另一个脚本（就像通过按[Ctrl] + [b]）执行当前关注的节点的脚本，请使用命令</font></font><code>c.executeMinibufferCommand('execute-script')</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设我们准备了一些代码。</font><font style="vertical-align: inherit;">从Leo Editor执行它将是有益的，并且从控制台获取所有错误将是很棒的。</font><font style="vertical-align: inherit;">让我们看一下使用著名的Black实用程序在节点内自动格式化Python代码的示例。</font></font><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@language python import subprocess import re c.frame.log.selectTab('Log') c.frame.log.clearLog() python_src = [] for line in pbsplitlines(): if re.match(r'@', line) is not None: line = line.replace('@', '# special_comment@') elif re.match(r'&lt;&lt;', line) is not None: line = line.replace('&lt;&lt;', '# special_comment&lt;&lt;') python_src.append(line) text = '\n'.join(python_src) proc = subprocess.Popen( ['black', '-', '-q', '--skip-string-normalization'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE, bufsize=0, shell=True, ) proc.stdin.write(text.encode()) proc.stdin.close() s = proc.stdout.read() if s: text = s.decode('utf-8') text = text.replace('# special_comment&lt;&lt;', '&lt;&lt;') text = text.replace('# special_comment@', '@') if 'error: cannot format -: Cannot parse:' in text: z = re.search(r'Cannot parse:.*', text) g.error(z.group(0)) else: undoData = c.undoer.beforeChangeNodeContents(p) pb = text.strip() c.undoer.afterChangeNodeContents(p,'Format with black', undoData) c.executeMinibufferCommand('execute-script')</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完成以下操作： </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们从节点取文本 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们在注释中添加了特殊的Leo Editor说明 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 启动控制台实用程序 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将文本传递给实用程序 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 阅读其结论 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 回到地方特别的指示 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果没有错误，则将当前文本替换为格式化的 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 运行节点代码 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该样本足以在其基础上启动任何操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们看一下Leo Editor实际使用的漂亮清晰版本。</font><font style="vertical-align: inherit;">Python生态系统提供了几种用于创建GUI应用程序的解决方案，其中一种是Kivy框架。</font><font style="vertical-align: inherit;">该框架的重要功能是能够从文本文件中以特殊语言加载接口描述。</font><font style="vertical-align: inherit;">Leo Editor将帮助我们，首先，将接口的代码和描述存储在一个空间中，其次，它将用树形编辑代替文本编辑，从某种意义上讲，这将使我们更接近所见即所得的接口草图。</font></font><br><br><img src="https://habrastorage.org/webt/o-/gq/rg/o-gqrg4uvpddphqvftujiz05flm.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以从上面的屏幕截图中提取哪些事实：</font></font><br><br><ol><li> Leo Editor    Kivy </li><li>      </li><li>  RUN      make_GUI,     make_py,      </li><li>              </li></ol><br><img src="https://habrastorage.org/webt/mp/vr/ge/mpvrgej71jkeh-bvw8xkf3rbkj8.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面，您可以看一下接口的描述以组装形式的样子。这可能很有趣，但左侧的集体农场似乎是一个更易于管理的工业解决方案。正确的版本要求在周五晚上输入错字。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将代码传递给分支。</font></font><br><br><img src="https://habrastorage.org/webt/f5/rw/e0/f5rwe0vhvybyqv9osa-pdpnawby.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很干净很明显。我们不关注DATAGRAPH。那班呢？</font></font><br><br><img src="https://habrastorage.org/webt/a1/eh/la/a1ehlaquqct8gruy50gmpx7kwka.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">圈子已经关闭，然后这个故事发生了，是针对Python的类浏览器的临时实现形式。节点头不只是注释；它们的内容在生成.py文件时使用。类嵌套级别自动形成继承层次结构。我们崇拜的一切。</font></font><br><br><img src="https://habrastorage.org/webt/6t/ub/qb/6tubqbt6umotvj6rujzcbgtv6mm.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KA-EE-FF !!!不要专注于正在发生的事情的意义，会为屏幕截图抛出类。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在文件部分的裸露功能上可以执行类似的操作，但是您必须显式指定所有语言结构（def，class ...），并且进行任何更改都必须记住在那里进行大量更正（以及节点的无用的悬挂头） ）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样，关于代码和接口的单个​​空间。</font><font style="vertical-align: inherit;">首先，请记住导航搜索，它使您可以快速搜索视觉元素和代码中视觉元素的代码处理程序。</font></font><br><br><img src="https://habrastorage.org/webt/sv/sv/sw/svsvswebrliyo8tfxspju7przvm.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，还有一个非常值得期待的功能，即附加的文本编辑器。</font></font><br><br><img src="https://habrastorage.org/webt/mt/7s/js/mt7sjs8p7munil0hdbhrdlq1gks.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跳！</font></font><br><br><img src="https://habrastorage.org/webt/w3/-a/u0/w3-au0zc7cc3fmpwaaee7hru2j0.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，无需在节点之间进行复杂的相互编辑来回运行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句：</font></font><br><br><img src="https://habrastorage.org/webt/vk/xp/dj/vkxpdjrmkfsuu3gjkkggfa0r19o.png" alt="返回图片"><br><br><hr><br><a name="1741732274806814329"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 思想自由 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终会有一点不自然。下文所述的所有内容均不应被视为良好工程实践的证明，而这仅仅是使您的个人想法具体化的种子。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个实验的起点：如果大多数程序都涉及多次从单个数据阵列重复生成其他数据阵列，那么为什么不创建一个通用类描述的带有统一数据接收/输出接口的简单构造块，以便在图形（功能块）上的编程图像中，将Leo Editor树中的相似块可视地链接在一起。区别在于它将是混合块类系统，并且将根据最大的长期利益来使用每种描述代码的方式。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本功能单元应：具有用于接收信息的输入，能够响应其类型，处理初始信息，将处理结果打包为用于传输的格式以及将结果转换出来。</font></font><br><br><img src="https://habrastorage.org/webt/l3/k9/0v/l3k90vzmhaql6vapmopg8evtvqq.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设解析站点有一项艰巨的任务。</font><font style="vertical-align: inherit;">我们将需要以下块：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 网络组件 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 网页解析器 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用于接收数据和图形界面通讯的块 </font></font></li></ol><br><img src="https://habrastorage.org/webt/k8/ks/pq/k8kspqkxa7cbvlwrcdtkxl5putm.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面显示了适合类分支的通用块的最小实际实现。</font></font><br><br><img src="https://habrastorage.org/webt/er/t0/it/ert0itsy50tprqo0uu8lhs_ivqi.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，如果严格遵守以下两个规则，则每个具体模块都可以使用其自身重新加载典型方法：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在每个块中，decode方法必须调用process，然后依次调用encoding </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编码方法在所有注册为输出的块上调用解码方法。 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即：保证了结构统一的可用性和信息交换的同质性。</font></font><br><br><img src="https://habrastorage.org/webt/f3/kx/zm/f3kxzmqcyfdg2rckhlkfzpiqbxq.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同，但更清楚：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 原始产品位于左板上。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 解码准备产品进行处理 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 之后，块在处理方法中执行其主要功能 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 产品通过编码打包 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 包装产品转移到后续单元 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，每个模块都是非常独立的，他唯一需要了解的外部环境是分析输入数据的特定方法。通用代码负责将块连接在一起的特定实现。结果，如果我们有几个可用的类似管道，则只需对过程方法的特定实现进行更正，就可以简单地将它们整体复制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下一张图片中，您可以观察到与上一节中描述的类非常相似的工作。区别在于节点的嵌套不是建立父子关系，而是建立相应块的输入-输出关系。为了组织与不相邻块的数据交换，使用拐杖以明确宣布退出的形式使用，这种情况很少见，这是合理的。</font></font><br><br><img src="https://habrastorage.org/webt/zb/5x/gz/zb5xgzphvzuurxow5ardidmum5k.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用这种方法，流水线的数量变得无关紧要：其中两个或50个。信息处理的阶段数量也微不足道（在合理的范围内），与文本模块的膨胀相比，这不会影响理解的简单性。一站式复制输送机时，便形成了一条全新的链条。一切都安排得完全相同，即使经过5年也很容易进行更改，组织功能的方法学原理是相同的，无需从抽象的头脑中创建空灵的城堡。</font></font><br><br><img src="https://habrastorage.org/webt/mb/6v/ls/mb6vls0l3kkyjuvc7wsjmvtl-_e.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附加自定义管道不会使整体图像失真，因为处理任意数据的逻辑总是相同的。</font></font><br><br><img src="https://habrastorage.org/webt/ky/k4/nc/kyk4nc_ebxmutrdk0fgfsvefcw8.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个荒诞的故事。我需要制作一个Kvent游戏（对于使用标准纸牌的游戏，它甚至可以在更广为人知的游戏中直接模仿知名游戏）。有许多不同的方法来组织游戏周期，其中一个简单的选择就是状态机。使用状态机，从理论上讲，一切都很好而且很简单，实际上，在任何实际程序中支持7个以上的状态逐渐变得乏味，而无需添加几层抽象。在这一点上，我认为以树的形式对状态机进行视觉维护是一个有趣的选择。</font></font><br><br><img src="https://habrastorage.org/webt/wc/tg/ff/wctgffnuapm1vq9q4pstbrzzmde.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们从树上编写程序代码生成器，它产生以下结果：</font></font><br><br><img src="https://habrastorage.org/webt/kj/xo/k8/kjxok87jjgtl-g6czgmir7jtlmq.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不用担心。</font></font><br><br><img src="https://habrastorage.org/webt/sh/vv/1l/shvv1lu8jwdess_y87enu9gfoas.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来是条件的变化。这是可疑的。</font></font><br><br><img src="https://habrastorage.org/webt/gl/rj/5k/glrj5khdiyejfz2e-ux5-5aclj8.png" alt="返回图片"><br><br><img src="https://habrastorage.org/webt/wc/1p/fs/wc1pfshoaikl7pehhies00u4fi8.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它只是一张纸牌，可以替换成对的任意一张纸牌。</font><font style="vertical-align: inherit;">好的，将一台计算机共享到多台计算机中。</font></font><br><br><img src="https://habrastorage.org/webt/m-/zj/ga/m-zjgaxbk680obe6afsshjpshlq.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，处理游戏回合的逻辑就产生了。</font></font><br><br><img src="https://habrastorage.org/webt/7p/nl/bk/7pnlbkpzubhsdgulyorjbja2tfq.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这一点上，这种状态机描述的实际适用性受到了限制，尽管仅当有意地将树100％部署时，树才显得令人毛骨悚然。</font><font style="vertical-align: inherit;">但是，带有图片的卡片影响游戏过程的效果仍然完全没有实现。</font><font style="vertical-align: inherit;">可以假定，用于此类任务的事件机将是更好的解决方案。</font><font style="vertical-align: inherit;">再说一次，很容易把它放在树上；）</font></font><br><br><hr><br><a name="-1224494674503101437"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 万岁，结局 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Leo Editor中，严重缺少常规自动完成功能，并且所选单词没有多次突出显示（记事本++中为“智能突出显示”）。但是，即使存在这些严重的缺陷，也很容易忍受，因为一旦您尝试过，没有这种方便的工具就已经无法实现，在该工具中您可以毫不费力地绘制自己的个人环境来完成任何任务。世界上有类似或更好的东西吗？ IDE中有很多怪物，它们充满了智能智能功能，但是其中哪个对信息具有类似的控制权，哪个在组织工作流方面提供了很大的自由度？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">想法，材料，工具，产品。在工程界，上一代工具使您可以继续使用下一代更复杂的工具。我们已经从手电钻发展到以猫为食的成长型设备。在好的车床阶段，编程工作就停了下来，但是我们没有深入研究，而是争论哪种合金更好地适合刀具，您应该从上方或从侧面进刀。 Leo Editor并不是明天问题的答案，而是一个可以做得更好的信号。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键不是一个程序员可以通过编写代码来解决问题，而另一个程序员（有条件地）“推动”同一件事。</font><font style="vertical-align: inherit;">您可以（有条件地）“有条件地”单击其中的工具，将使您解决以前在时间和复杂性方面无法访问的问题。</font><font style="vertical-align: inherit;">将来，我们将需要能够实时编写数百万个相关程序的程序，而我们无力管理这种规模的复杂性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，创建您的现实，如果没有为此所需的工具，请执行它们，它会起作用。</font></font><br><br><hr><br><a name="-6501470618194411030"></a><br><h3>  UPD<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 应用实例 </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">管理员</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：命令库。</font><font style="vertical-align: inherit;">您可以只存储它，可以按原样运行它，也可以在树中使用参数设置。</font><font style="vertical-align: inherit;">例如，组织使用多个数据库的工作。</font></font><br><br><img src="https://habrastorage.org/webt/oq/8n/qm/oq8nqm60bc-93eatt0tilwin03q.png" alt="返回图片"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音乐的算法合成</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：轨道的组织</font></font><br><br><img src="https://habrastorage.org/webt/vx/xz/79/vxxz79cqxvt-nfv650hyt9-l8ya.png" alt="返回图片"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嵌入器</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：万一您的环境受到限制，可以任意组织代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两种选择：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.以最有利的顺序将程序分成几部分</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.如果该语言没有功能，则可以使用幻象对它们进行仿真。</font></font><br><br><img src="https://habrastorage.org/webt/9u/3z/ck/9u3zckhnn37izbuny6rkrfq3qlm.png" alt="返回图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有三种方式来组织代码执行顺序：五</font></font><br><br><img src="https://habrastorage.org/webt/ec/__/mw/ec__mwgxmyd5ifpmytv5y-wwwhw.png" alt="返回图片"><br><br><img src="https://habrastorage.org/webt/ti/nu/fy/tinufyq8lzwhfctwxjnje2ejnae.png" alt="返回图片"><br><br><img src="https://habrastorage.org/webt/_r/of/fv/_roffvpcmlyvr7tdr30viqn6adq.png" alt="返回图片"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分期</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：将您常用的军械库转移到您的个人“钴罢工”中”</font></font><br><br><img src="https://habrastorage.org/webt/he/bq/ug/hebqugs6c8zkrd7dyfhnxrupgno.png" alt="返回图片"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484930/">https://habr.com/ru/post/zh-CN484930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484906/index.html">远程的分布式团队和团队负责人</a></li>
<li><a href="../zh-CN484908/index.html">HighLoad ++，Eugene Kuzovlev（EcommPay IT）：一分钟的停机成本为100,000美元时该怎么办</a></li>
<li><a href="../zh-CN484910/index.html">保罗·格雷厄姆：仇恨者</a></li>
<li><a href="../zh-CN484918/index.html">增量注释处理可加快gradle构建</a></li>
<li><a href="../zh-CN484920/index.html">如何理解您是铣床操作员？</a></li>
<li><a href="../zh-CN484932/index.html">软件需求的双重性质</a></li>
<li><a href="../zh-CN484934/index.html">在TeamLead Conf上进行为期两天的从个人发展到XXXL规模的敏捷</a></li>
<li><a href="../zh-CN484936/index.html">团队中的知识和能力：查找，查看，提升</a></li>
<li><a href="../zh-CN484944/index.html">我的ACID是什么或不适合我们</a></li>
<li><a href="../zh-CN484946/index.html">GPR建模</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>