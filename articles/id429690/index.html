<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😄 👩🏻‍🚀 👌🏼 Errorx - pustaka untuk bekerja dengan kesalahan di Go 🥖 🍓 😵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa itu Errorx dan bagaimana itu berguna 


 Errorx adalah pustaka untuk menangani kesalahan di Go. Ini menyediakan alat untuk memecahkan masalah yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Errorx - pustaka untuk bekerja dengan kesalahan di Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/joom/blog/429690/"><h1 id="chto-takoe-errorx-i-chem-on-polezen">  Apa itu Errorx dan bagaimana itu berguna </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Errorx</a> adalah pustaka untuk menangani kesalahan di Go.  Ini menyediakan alat untuk memecahkan masalah yang terkait dengan mekanisme kesalahan dalam proyek-proyek besar, dan satu sintaks untuk bekerja dengan mereka. </p><br><p><img src="https://habrastorage.org/webt/wq/c2/aw/wqc2awx3pmke-loujb4ea0yngya.jpeg" alt="gambar"></p><br><p>  Sebagian besar komponen server Joom telah ditulis di Go sejak perusahaan didirikan.  Pilihan ini terbayar pada tahap awal pengembangan dan masa pakai layanan, dan mengingat <a href="">pengumuman</a> tentang prospek Go 2, kami yakin bahwa kami tidak akan menyesalinya di masa mendatang.  Salah satu kebajikan utama Go adalah kesederhanaan, dan pendekatan terhadap kesalahan menunjukkan prinsip ini tidak seperti yang lain.  Tidak setiap proyek mencapai skala yang memadai sehingga kemampuan perpustakaan standar tidak cukup, mendorong Anda untuk mencari solusi Anda sendiri di bidang ini.  Kami kebetulan mengalami beberapa evolusi dalam pendekatan untuk mengatasi kesalahan, dan pustaka errorx mencerminkan hasil dari evolusi ini.  Kami yakin itu dapat bermanfaat bagi banyak orang, termasuk mereka yang belum merasa tidak nyaman bekerja dengan kesalahan pada proyek mereka. </p><a name="habracut"></a><br><h2 id="oshibki-v-go">  Kesalahan dalam Go </h2><br><p>  Sebelum beralih ke cerita tentang errorx, beberapa klarifikasi harus dibuat.  Pada akhirnya, apa yang salah dengan bug? </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Error() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Sangat sederhana bukan?  Dalam praktiknya, suatu implementasi seringkali benar-benar tidak membawa apa-apa selain deskripsi kesalahan.  Minimalisme seperti itu dihubungkan dengan pendekatan yang menurutnya kesalahan tidak selalu berarti sesuatu yang "luar biasa".  Kesalahan yang paling umum digunakan. Baru () dari perpustakaan standar benar untuk ide ini: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;errorString{text} }</code> </pre> <br><p>  Jika kita ingat bahwa kesalahan dalam suatu bahasa tidak memiliki status khusus dan merupakan objek biasa, muncul pertanyaan: apa kekhasan bekerja dengan mereka? </p><br><p>  Kesalahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak terkecuali</a> .  Bukan rahasia lagi bahwa banyak, ketika mereka berkenalan dengan Go, memenuhi perbedaan ini dengan beberapa perlawanan.  Ada banyak publikasi, baik yang menjelaskan maupun mendukung, dan mengkritik pendekatan yang dipilih dalam Go.  Salah satu cara atau yang lain, kesalahan dalam Go melayani banyak tujuan, dan setidaknya satu di antaranya persis sama dengan pengecualian dalam beberapa bahasa lain: pemecahan masalah.  Akibatnya, wajar untuk mengharapkan dari mereka kekuatan ekspresif yang sama, bahkan jika pendekatan dan sintaksis yang terkait dengan penggunaannya sangat berbeda. </p><br><h3 id="chto-ne-tak">  Apa yang salah </h3><br><p>  Banyak proyek memanfaatkan bug di Go, sebagaimana adanya, dan tidak memiliki kesulitan sedikit pun tentang ini.  Namun, ketika kompleksitas sistem tumbuh, sejumlah masalah mulai muncul yang menarik perhatian bahkan tanpa adanya harapan yang tinggi.  Ilustrasi yang baik adalah baris yang serupa dalam log layanan Anda: </p><br><p> <code>Error: duplicate key</code> </p> <br><p>  Di sini, masalah pertama langsung menjadi jelas: jika Anda tidak sengaja melakukan hal ini, maka dalam sistem yang besar, hampir tidak mungkin untuk memahami apa yang salah, hanya dengan pesan awal.  Posting ini tidak memiliki detail dan konteks masalah yang lebih luas.  Ini adalah kesalahan programmer, tetapi terlalu sering mengabaikannya.  Kode yang ditujukan untuk cabang "positif" dari grafik kontrol selalu layak mendapat perhatian lebih dalam praktik dan lebih baik dicakup oleh tes daripada kode "negatif" yang terkait dengan gangguan eksekusi atau masalah eksternal.  Seberapa sering mantra <code>if err != nil {return err}</code> diulang dalam program Go menjadikan pengawasan ini lebih mungkin. </p><br><p>  Sebagai penyimpangan kecil, pertimbangkan contoh ini: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *Manager)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyToUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(User)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Data, error)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ids</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserID</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { users, err := m.LoadUsers(ids) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actionData []*Data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, user := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> users { data, err := action(user) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } ok, err := m.validateData(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { log.Error(<span class="hljs-string"><span class="hljs-string">"Validation failed for %v"</span></span>, data) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } actionData = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(actionData, data) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.Apply(actionData) }</code> </pre> <br><p>  Seberapa cepat Anda melihat kesalahan dalam kode ini?  Tapi itu dilakukan setidaknya sekali, mungkin oleh programmer Go.  Petunjuk: kesalahan dalam ekspresi <code>if err != nil { return nil }</code> . </p><br><p>  Jika kita kembali ke masalah dengan pesan cadel di log, maka dalam situasi ini, tentu saja, semua orang juga terjadi.  Mulai memperbaiki kode penanganan kesalahan sudah pada saat masalah terjadi sangat tidak menyenangkan;  Selain itu, menurut data awal dari log, tidak jelas pihak mana yang harus mulai mencari bagian kode tersebut, yang, pada kenyataannya, perlu ditingkatkan.  Ini mungkin tampak seperti kerumitan yang dibuat-buat untuk proyek-proyek yang kecil dalam kode dan dalam jumlah ketergantungan eksternal.  Namun, untuk proyek skala besar ini adalah masalah yang benar-benar nyata dan menyakitkan. </p><br><p>  Misalkan pemrogram pengalaman pahit ingin menambahkan konteks terlebih dahulu untuk kesalahan yang kembali.  Cara naif untuk melakukan ini adalah sesuatu seperti ini: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := usersTable.Insert(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"failed to insert user %s: %v"</span></span>, u.Name, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Itu menjadi lebih baik.  Konteks yang lebih luas masih belum jelas, tetapi sekarang jauh lebih mudah untuk menemukan setidaknya di mana kode kesalahan terjadi.  Namun, setelah menyelesaikan satu masalah, kami secara tidak sengaja membuat yang lain.  Kesalahan yang dibuat di sini membuat pesan diagnostik tetap asli, tetapi segala sesuatu yang lain, termasuk jenis dan konten tambahannya, hilang. </p><br><p>  Untuk melihat mengapa ini berbahaya, pertimbangkan kode serupa di driver database: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrDuplicateKey = errors.New(<span class="hljs-string"><span class="hljs-string">"duplicate key"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *Table)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// returns ErrDuplicateKey if a unique constraint is violated by insert } func IsDuplicateKeyError(err error) bool { return err == ErrDuplicateKey }</span></span></code> </pre> <br><p>  Sekarang pemeriksaan <code>IsDuplicateKeyError()</code> dihancurkan, meskipun pada saat kami menambahkan teks kami ke kesalahan, kami tidak berniat mengubah semantiknya.  Ini, pada gilirannya, akan memecah kode yang bergantung pada pemeriksaan ini: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := InsertUser(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> db.IsDuplicateKeyError(err) { <span class="hljs-comment"><span class="hljs-comment">// find existing user, handle conflict } else { return err } }</span></span></code> </pre> <br><p>  Jika kita ingin melakukan yang lebih cerdas dan menambahkan jenis kesalahan kita sendiri, yang akan menyimpan kesalahan asli dan dapat mengembalikannya, katakanlah, melalui metode <code>Cause() error</code> , maka kita juga akan menyelesaikan masalah hanya sebagian. </p><br><ol><li>  Sekarang di tempat pemrosesan kesalahan Anda perlu tahu bahwa alasan sebenarnya terletak pada <code>Cause()</code> </li><li>  Tidak ada cara untuk mengajarkan perpustakaan eksternal pengetahuan ini, dan fungsi pembantu yang tertulis di dalamnya akan tetap tidak berguna </li><li>  Implementasi kami dapat mengharapkan <code>Cause()</code> mengembalikan penyebab kesalahan (atau nihil jika tidak), sedangkan implementasi di perpustakaan lain akan mengharapkan metode untuk mengembalikan penyebab non-nil root;  kurangnya alat standar atau kontrak yang diterima secara umum mengancam kejutan yang sangat tidak menyenangkan </li></ol><br><p>  Namun, solusi parsial ini digunakan di banyak pustaka galat, termasuk, sampai batas tertentu, milik kami.  Ada rencana dalam Go 2 untuk mempopulerkan pendekatan ini - jika ini terjadi, akan lebih mudah untuk menangani masalah yang dijelaskan di atas. </p><br><h2 id="errorx">  Errorx </h2><br><p>  Di bawah ini kita akan berbicara tentang apa yang ditawarkan errorx, tetapi pertama-tama coba merumuskan pertimbangan yang mendasari perpustakaan. </p><br><ul><li>  <strong>Diagnostik lebih penting daripada menghemat sumber daya.</strong>  Kinerja membuat dan menampilkan kesalahan penting.  Namun demikian, mereka mewakili jalur negatif daripada positif, dan dalam kebanyakan kasus mereka berfungsi sebagai sinyal masalah, oleh karena itu keberadaan informasi diagnostik dalam kesalahan bahkan lebih penting. </li><li>  <strong>Tumpukan jejak secara default.</strong>  Agar kesalahan hilang dengan kepenuhan diagnosis, upaya tidak harus dilakukan.  Sebaliknya, justru untuk mengecualikan beberapa informasi (untuk singkatnya atau untuk alasan kinerja) tindakan tambahan mungkin diperlukan. </li><li>  <strong>Semantik kesalahan.</strong>  Seharusnya ada cara yang sederhana dan dapat diandalkan untuk memeriksa arti kesalahan: jenis, ragam, sifat-sifatnya. </li><li>  <strong>Kemudahan penambahan.</strong>  Menambahkan informasi diagnostik ke kesalahan yang lewat harus sederhana, dan tidak boleh merusak verifikasi semantiknya. </li><li>  <strong>Kesederhanaan.</strong>  Kode yang ditujukan untuk kesalahan sering dan secara rutin ditulis, jadi sintaksis manipulasi dasar dengannya harus sederhana dan ringkas.  Ini mengurangi jumlah bug dan membuatnya lebih mudah dibaca. </li><li>  <strong>Lebih sedikit lebih banyak.</strong>  Kelengkapan dan keseragaman kode lebih penting daripada fitur opsional dan opsi ekspansi (yang, mungkin, tidak ada yang akan menggunakan). </li><li>  <strong>Semantik kesalahan adalah bagian dari API.</strong>  Kesalahan yang memerlukan pemrosesan terpisah dalam kode panggilan adalah bagian dari paket API publik.  Anda tidak perlu mencoba menyembunyikannya atau membuatnya kurang eksplisit, tetapi Anda bisa membuat pemrosesan lebih nyaman, dan ketergantungan eksternal kurang rapuh. </li><li>  <strong>Sebagian besar bug bersifat buram.</strong>  Semakin banyak jenis kesalahan untuk pengguna eksternal tidak dapat dibedakan satu sama lain, semakin baik.  Pemuatan jenis kesalahan API yang memerlukan penanganan khusus, serta memuat kesalahan sendiri dengan data yang diperlukan untuk memprosesnya adalah cacat desain yang harus dihindari. </li></ul><br><p>  Pertanyaan yang paling sulit bagi kami adalah ekstensibilitas: haruskah errorx memberikan primitif untuk melembagakan jenis kesalahan khusus yang berbeda dalam perilaku, atau adakah implementasi yang memungkinkan Anda untuk mendapatkan semua yang Anda butuhkan di luar kotak?  Kami telah memilih opsi kedua.  Pertama, errorx memecahkan masalah yang sangat praktis - dan pengalaman kami menggunakannya menunjukkan bahwa untuk tujuan ini lebih baik untuk memiliki solusi, daripada suku cadang untuk membuatnya.  Kedua, pertimbangan tentang kesederhanaan sangat signifikan: karena sedikit perhatian diberikan pada kesalahan, kode harus dirancang sedemikian rupa sehingga membuatnya sulit untuk bekerja dengannya.  Praktek telah menunjukkan bahwa untuk ini penting bahwa semua kode tersebut terlihat dan berfungsi sama. </p><br><h4 id="tldr-po-osnovnym-ficham-biblioteki">  TL; DR oleh fitur perpustakaan utama: </h4><br><ul><li>  Tumpuk jejak lokasi pembuatan di semua kesalahan secara default </li><li>  Ketik cek kesalahan, beberapa varietas </li><li>  Kemampuan untuk menambahkan informasi ke kesalahan yang ada tanpa merusak apa pun </li><li>  Ketik kontrol visibilitas jika Anda ingin menyembunyikan alasan asli dari pemanggil </li><li>  Kesalahan dalam menangani mekanisme generalisasi kode (tipe hierarki, sifat) </li><li>  Kustomisasi kesalahan oleh properti dinamis </li><li>  Jenis kesalahan standar </li><li>  Utilitas sintaks untuk meningkatkan keterbacaan kode penanganan kesalahan </li></ul><br><h3 id="vvedenie">  Pendahuluan </h3><br><p>  Jika kita ulang contoh yang kita analisis di atas menggunakan errorx, kita mendapatkan yang berikut: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( DBErrors = errorx.NewNamespace(<span class="hljs-string"><span class="hljs-string">"db"</span></span>) ErrDuplicateKey = DBErrors.NewType(<span class="hljs-string"><span class="hljs-string">"duplicate_key"</span></span>) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *Table)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... return ErrDuplicateKey.New("violated constraint %s", details) } func IsDuplicateKeyError(err error) bool { return errorx.IsOfType(err, ErrDuplicateKey) }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *User)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { err := usersTable.Insert(u) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.Decorate(err, <span class="hljs-string"><span class="hljs-string">"failed to insert user %s"</span></span>, u.Name) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Kode pemanggil menggunakan <code>IsDuplicateKeyError()</code> tidak akan berubah. </p><br><p>  Apa yang berubah dalam contoh ini? </p><br><ul><li>  <code>ErrDuplicateKey</code> menjadi tipe, bukan turunan kesalahan;  memeriksa apakah itu tahan terhadap kesalahan penyalinan, tidak ada ketergantungan yang rapuh pada kesetaraan yang tepat </li><li>  Ada ruang nama untuk kesalahan basis data;  kemungkinan besar akan memiliki kesalahan lain, dan pengelompokan seperti itu berguna untuk keterbacaan dan dalam beberapa kasus dapat digunakan dalam kode </li><li>  Sisipkan mengembalikan kesalahan baru untuk setiap panggilan: <br><ul><li>  Kesalahan tersebut berisi lebih banyak detail;  ini, tentu saja, dimungkinkan tanpa errorx, tetapi tidak mungkin jika instance kesalahan yang sama dikembalikan setiap kali, yang sebelumnya diperlukan untuk <code>IsDuplicateKeyError()</code> </li><li>  Kesalahan ini dapat membawa jejak tumpukan yang berbeda, yang berguna karena  tidak untuk semua panggilan ke fungsi Sisipkan situasi ini dapat diterima </li></ul></li><li>  <code>InsertUser()</code> melengkapi teks kesalahan, tetapi menerapkan kesalahan asli, yang dipertahankan secara keseluruhan untuk operasi selanjutnya </li><li>  <code>IsDuplicateKeyError()</code> sekarang berfungsi: ia tidak dapat dimanjakan baik dengan menyalin kesalahan, maupun dengan sebanyak mungkin lapisan yang Anda suka dengan Hiasi () </li></ul><br><p>  Tidak perlu selalu mengikuti skema seperti itu: </p><br><ul><li>  Jenis kesalahan jauh dari selalu unik: jenis yang sama dapat digunakan di banyak tempat </li><li>  Jika diinginkan, koleksi jejak tumpukan dapat dinonaktifkan, dan Anda tidak dapat membuat kesalahan baru setiap kali, tetapi kembalikan yang sama seperti pada contoh asli;  ini disebut kesalahan sentinel, dan kami tidak merekomendasikan penggunaannya, tetapi ini bisa berguna jika kesalahan hanya digunakan sebagai penanda dalam kode, dan Anda ingin menghemat pembuatan objek </li><li>  Ada cara untuk membuat <code>errorx.IsOfType(err, ErrDuplicateKey)</code> berhenti bekerja jika Anda ingin menyembunyikan semantik dari akar masalah dari mata yang mengintip </li><li>  Ada cara lain untuk memeriksa jenis itu sendiri selain membandingkan dengan jenis yang tepat </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Godoc</a> berisi informasi terperinci tentang semua ini.  Di bawah ini kita akan membahas lebih dalam fitur-fitur utama, yang cukup untuk pekerjaan sehari-hari. </p><br><h3 id="tipy">  Jenis </h3><br><p>  Kesalahan errorx termasuk dalam beberapa tipe.  Ketik masalah karena  properti kesalahan yang diwarisi dapat dilewati;  itu melalui dia atau sifat-sifatnya bahwa pengujian semantik akan dilakukan jika perlu.  Selain itu, nama ekspresif jenis melengkapi pesan kesalahan dan dalam beberapa kasus mungkin menggantinya. </p><br><pre> <code class="go hljs">AuthErrors = errorx.NewNamespace(<span class="hljs-string"><span class="hljs-string">"auth"</span></span>) ErrInvalidToken = AuthErrors.NewType(<span class="hljs-string"><span class="hljs-string">"invalid_token"</span></span>)</code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ErrInvalidToken.NewWithNoMessage()</code> </pre> <br><p>  Pesan kesalahan akan berisi <code>auth.invalid_token</code> .  Deklarasi kesalahan mungkin terlihat berbeda: </p><br><pre> <code class="go hljs">ErrInvalidToken = AuthErrors.NewType(<span class="hljs-string"><span class="hljs-string">"invalid_token"</span></span>).ApplyModifiers(errorx.TypeModifierOmitStackTrace)</code> </pre> <br><p>  Dalam perwujudan ini, menggunakan pengubah tipe, pengumpulan kumpulan jejak dinonaktifkan.  Kesalahan memiliki semantik penanda: tipenya diberikan kepada pengguna eksternal layanan, dan tumpukan panggilan dalam log tidak akan berguna, karena  ini bukan masalah yang harus diperbaiki. </p><br><p>  Di sini kita dapat membuat reservasi bahwa kesalahan memiliki sifat ganda dalam beberapa aspeknya.  Isi kesalahan digunakan baik untuk diagnostik dan, kadang-kadang, sebagai informasi untuk pengguna eksternal: klien API, pengguna perpustakaan, dll.  Kesalahan digunakan dalam kode baik sebagai sarana untuk menyampaikan semantik tentang apa yang terjadi, dan sebagai mekanisme untuk mentransfer kontrol.  Saat menggunakan jenis kesalahan, ini harus diingat. </p><br><h3 id="sozdanie-oshibki">  Pembuatan galat </h3><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyType.New(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>)</code> </pre> <br><p>  Mendapatkan jenis Anda sendiri untuk setiap kesalahan sepenuhnya opsional.  Setiap proyek dapat memiliki paket sendiri untuk kesalahan tujuan umum, dan beberapa set dipasok sebagai bagian dari namespace bersama bersama dengan errorx.  Ini berisi kesalahan yang dalam banyak kasus tidak melibatkan pemrosesan dalam kode dan cocok untuk situasi "luar biasa" ketika terjadi kesalahan. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.IllegalArgument.New(<span class="hljs-string"><span class="hljs-string">"negative value %d"</span></span>, value)</code> </pre> <br><p>  Dalam kasus tertentu, rantai panggilan dirancang sehingga kesalahan dibuat di bagian paling akhir rantai, dan diproses di awal.  Dalam Go, bukannya tanpa alasan dianggap sebagai bentuk buruk untuk memproses kesalahan dua kali, mis., Misalnya, menulis kesalahan ke log dan mengembalikannya lebih tinggi ke tumpukan.  Namun, Anda dapat menambahkan informasi ke kesalahan itu sendiri sebelum memberikannya: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.Decorate(err, <span class="hljs-string"><span class="hljs-string">"failed to upload '%s' to '%s'"</span></span>, filename, location)</code> </pre> <br><p>  Teks yang ditambahkan ke kesalahan akan muncul di log, tetapi tidak ada salahnya untuk memeriksa jenis kesalahan aslinya. </p><br><p>  Terkadang muncul kebutuhan yang berlawanan: apa pun sifat kesalahannya, pengguna luar paket tidak boleh mengetahuinya.  Jika dia mendapat kesempatan seperti itu, dia bisa membuat ketergantungan yang rapuh pada bagian dari implementasi. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> service.ErrBadRequest.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to load user data"</span></span>)</code> </pre> <br><p>  Perbedaan penting yang menjadikan Wrap lebih disukai daripada New adalah kesalahan asli sepenuhnya tercermin dalam log.  Dan, khususnya, itu akan membawa setumpuk panggilan awal yang berguna. </p><br><p>  Trik lain yang berguna yang memungkinkan Anda untuk menyimpan semua informasi yang mungkin tentang tumpukan panggilan terlihat seperti ini: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.EnhanceStackTrace(err, <span class="hljs-string"><span class="hljs-string">"operation fail"</span></span>)</code> </pre> <br><p>  Jika kesalahan asli berasal dari goroutine lain, hasil dari panggilan seperti itu akan berisi jejak tumpukan kedua goroutine, yang secara tidak biasa meningkatkan kegunaannya.  Kebutuhan untuk melakukan panggilan seperti itu jelas karena masalah kinerja: kasus ini relatif jarang, dan ergonomi yang akan mendeteksi sendiri akan memperlambat Bungkus biasa, di mana tidak diperlukan sama sekali. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Godoc</a> berisi lebih banyak informasi dan juga menjelaskan fitur-fitur tambahan seperti DecorateMany. </p><br><h3 id="obrabotka-oshibok">  Menangani kesalahan </h3><br><p>  Terbaik jika penanganan kesalahan diturunkan sebagai berikut: </p><br><pre> <code class="go hljs">log.Error(<span class="hljs-string"><span class="hljs-string">"Error: %+v"</span></span>, err)</code> </pre> <br><p>  Semakin sedikit kesalahan yang perlu Anda buat, kecuali untuk mencetaknya ke log pada lapisan sistem proyek, semakin baik.  Pada kenyataannya, ini terkadang tidak cukup, dan Anda harus melakukan ini: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errorx.IsOfType(err, MyType) { <span class="hljs-comment"><span class="hljs-comment">/* handle */</span></span> }</code> </pre> <br><p>  Pemeriksaan ini akan berhasil pada kesalahan tipe <code>MyType</code> dan pada jenis anaknya, dan tahan terhadap <code>errorx.Decorate()</code> .  Namun, di sini ada ketergantungan langsung pada jenis kesalahan, yang cukup normal di dalam paket, tetapi dapat menjadi tidak menyenangkan jika digunakan di luarnya.  Dalam beberapa kasus, jenis kesalahan seperti itu adalah bagian dari API eksternal yang stabil, dan kadang-kadang kami ingin mengganti cek ini dengan pemeriksaan properti, dan bukan jenis kesalahan yang tepat. </p><br><p>  Dalam kesalahan Go klasik, ini akan dilakukan melalui antarmuka, ketik gips di mana akan berfungsi sebagai indikator dari jenis kesalahan.  Jenis Errorx tidak mendukung ekstensi ini, tetapi Anda dapat menggunakan mekanisme <code>Trait</code> sebagai gantinya.  Sebagai contoh: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTemporary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HasTrait(err, Temporary()) }</code> </pre> <br><p>  Fungsi ini dibangun ke errorx memeriksa apakah kesalahan memiliki properti standar <code>Temporary</code> , yaitu  apakah itu sementara.  Menandai jenis kesalahan dengan sifat adalah tanggung jawab sumber kesalahan, dan melaluinya dapat mengirimkan sinyal yang berguna tanpa membuat jenis internal tertentu menjadi bagian dari API eksternal. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorx.IgnoreWithTrait(err, errorx.NotFound())</code> </pre> <br><p>  Sintaks ini berguna ketika jenis kesalahan tertentu diperlukan untuk mengganggu aliran kontrol, tetapi tidak boleh diteruskan ke fungsi panggilan. </p><br><p>  Terlepas dari banyaknya alat pemrosesan, tidak semuanya terdaftar di sini, penting untuk diingat bahwa penanganan kesalahan harus tetap sesederhana mungkin.  Contoh aturan yang kami coba patuhi: </p><br><ul><li>  Kode yang menerima kesalahan harus selalu mencatatnya secara keseluruhan;  jika bagian dari informasi tersebut berlebihan, biarkan kode yang menghasilkan kesalahan mengurus ini </li><li>  Anda tidak boleh menggunakan teks kesalahan atau hasil dari fungsi <code>Error()</code> untuk memprosesnya dalam kode;  hanya pemeriksaan jenis / sifat yang cocok untuk ini, atau ketik pernyataan jika terjadi kesalahan non-errorx </li><li>  Kode pengguna tidak boleh rusak karena fakta bahwa beberapa jenis kesalahan tidak diproses dengan cara khusus, bahkan jika pemrosesan tersebut dimungkinkan dan memberikannya fitur tambahan </li><li>  Kesalahan yang diperiksa oleh properti lebih baik daripada yang disebut kesalahan sentinel, karena  cek semacam itu kurang rapuh </li></ul><br><h3 id="vne-errorx">  Di luar errorx </h3><br><p>  Di sini kami menggambarkan apa yang tersedia untuk pengguna perpustakaan di luar kotak, tetapi di Joom penetrasi kode terkait kesalahan sangat besar.  Modul logging secara eksplisit menerima kesalahan dalam tanda tangannya dan mencetak sendiri untuk menghilangkan kemungkinan pemformatan yang salah, serta mengekstrak informasi kontekstual yang tersedia opsional dari rantai kesalahan.  Modul yang bertanggung jawab untuk kerja aman panik dengan goroutin membongkar kesalahan jika ia datang dengan panik, dan juga tahu bagaimana menyajikan panik menggunakan sintaks kesalahan tanpa kehilangan jejak tumpukan asli.  Beberapa di antaranya, mungkin kami juga akan menerbitkan. </p><br><h2 id="voprosy-sovmestimosti">  Masalah kompatibilitas </h2><br><p>  Terlepas dari kenyataan bahwa kami sangat senang dengan bagaimana errorx memungkinkan kami untuk bekerja dengan kesalahan, situasi dengan kode perpustakaan yang dikhususkan untuk topik ini masih jauh dari ideal.  Kami di Joom memecahkan masalah praktis yang cukup spesifik dengan errorx, tetapi dari sudut pandang ekosistem Go, akan lebih baik untuk memiliki seluruh rangkaian alat ini di perpustakaan standar.  Kesalahan, sumber yang sebenarnya atau berpotensi milik paradigma lain, harus dianggap sebagai alien, yaitu  berpotensi tidak membawa informasi dalam bentuk yang diterima dalam proyek. </p><br><p>  Namun, beberapa hal telah dilakukan agar tidak bertentangan dengan solusi lain yang ada. </p><br><p>  Format <code>'%+v'</code> digunakan untuk mencetak kesalahan bersama dengan jejak tumpukan, jika ada.  Ini adalah standar de facto di ekosistem Go dan bahkan termasuk dalam rancangan desain untuk Go 2. </p><br><p>  <code>Cause() error</code>  errorx ,  ,   ,    Causer,       errorx      Wrap(). </p><br><h2 id="buduschee">  </h2><br><p>  <a href=""></a>   ,    Go 2,      .  <a href="">   </a>       . </p><br><p> ,    errorx     Go 1.      ,    Go 2,     .       ,            ,        errorx. </p><br><p> Check-handle      ,   errorx , a <code>Unwrap() error</code>       <code>Wrap()</code>  errorx (.. ,        ,    <code>Wrap</code> ),    .     ,      ,  . </p><br><p>     design draft   Go 2,    <code>errorx.Is()</code>  <code>errorx.As()</code>   ,      errors   . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>   ,   ,   ,    -      ,        .      ,      API     :  ,   ,       .  1.0      ,           Joom. ,  -       . </p><br><p> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/joomcode/errorx</a> </p><br><p>   ,    ! </p><br><p><img src="https://habrastorage.org/webt/nk/hv/el/nkhvelss5upmybktmbpy68ozo_a.jpeg" alt="gambar"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429690/">https://habr.com/ru/post/id429690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429680/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 17: Otentikasi Pengguna, Bagian 1</a></li>
<li><a href="../id429682/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 17: Otentikasi Pengguna, Bagian 2</a></li>
<li><a href="../id429684/index.html">Firebase Summit 2018: secara singkat tentang hal utama</a></li>
<li><a href="../id429686/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 17: "Otentikasi Pengguna", bagian 3</a></li>
<li><a href="../id429688/index.html">Cara membuat pahlawan yang akan dipercaya</a></li>
<li><a href="../id429692/index.html">Optimasi penanganan acara di Angular</a></li>
<li><a href="../id429694/index.html">Mail.Ru menyebut peringkat Yandex "tidak masuk akal" dan menuntut untuk menghapus mereknya dari sana</a></li>
<li><a href="../id429696/index.html">Laporan video dengan MOSDROID # 13 Aluminium</a></li>
<li><a href="../id429698/index.html">Cara bekerja dengan Lebedev Studio: pengalaman Tutu.ru</a></li>
<li><a href="../id429700/index.html">Definisi angka menurut telinga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>