<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👮 👨🏻‍⚖️ 🏮 Package Manager untuk Kubernetes - Helm: Past, Present, Future 🏴‍☠️ 🛬 🗨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Dengan artikel ini kami membuka serangkaian publikasi tentang manajer paket untuk Kubernetes, yang kami gunakan secara aktif dalam pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Package Manager untuk Kubernetes - Helm: Past, Present, Future</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/417079/">  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Dengan artikel ini kami membuka serangkaian publikasi tentang manajer paket untuk Kubernetes, yang kami gunakan secara aktif dalam pekerjaan sehari-hari, - Helm.</i>  <i>Penulis asli materi ini adalah Matt Butcher, salah satu pendiri proyek Helm, yang mengerjakan proyek Open Source di Microsoft dan menulis 8 buku teknis (khususnya, "Go in Practice").</i>  <i>Namun, artikel ini dilengkapi dengan komentar kami (terkadang ekstensif), dan akan segera diperluas dengan catatan baru tentang Helm dengan fokus yang lebih praktis.</i>  <i><b>UPDATE</b> (09/03/2018): sekuelnya keluar - " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kenalan praktis dengan manajer paket untuk Kubernetes - Helm</a> ".</i> <br><br><img src="https://habrastorage.org/webt/ff/1x/js/ff1xjsnvdlnfinirlwb-0p42tlo.png"><br><br>  Pada bulan Juni, Helm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pindah</a> dari status proyek utama Kubernetes ke Cloud Native Computing Foundation (CNCF).  CNCF menjadi organisasi induk untuk yang terbaik dari jenis alat cloud asli open source.  Karena itu, merupakan kehormatan besar bagi Helm untuk menjadi bagian dari yayasan semacam itu.  Dan proyek signifikan pertama kami di bawah naungan CNCF benar-benar berskala besar: kami menciptakan Helm 3. <a name="habracut"></a><br><br><h2>  Sejarah Singkat Helm </h2><br>  Helm awalnya muncul sebagai proyek Deis Open Source.  Itu dimodelkan setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Homebrew</a> <i>(manajer paket untuk macOS - <b>kira</b> - <b>kira. Terjemahan</b> )</i> , Dan tugas yang Helm 1 miliki adalah kesempatan yang dipermudah bagi pengguna untuk dengan cepat menginstal beban kerja pertama mereka di Kubernetes.  Pengumuman resmi Helm berlangsung di konferensi KubeCon San Francisco pertama pada tahun 2015. <br><br>  <i><b>Catatan</b></i>  <i><b>trans.:</b> Dari versi pertama, yang disebut dm (Deployment Manager), sintaks YAML dipilih untuk menggambarkan sumber daya Kubernetes, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">templat Jinja</a> dan skrip Python didukung saat menulis konfigurasi.</i> <br><br>  <i>Templat aplikasi web sederhana mungkin terlihat seperti ini:</i> <br><br><div class="spoiler">  <b class="spoiler_title">Yaml</b> <div class="spoiler_text"><pre><code class="plaintext hljs">resources: - name: frontend type: github.com/kubernetes/application-dm-templates/common/replicatedservice:v1 properties: service_port: 80 container_port: 80 external_service: true replicas: 3 image: gcr.io/google_containers/example-guestbook-php-redis:v3 - name: redis type: github.com/kubernetes/application-dm-templates/storage/redis:v1 properties: null</code> </pre> </div></div><br>  <i>Saat menggambarkan komponen aplikasi yang diluncurkan, nama, templat yang digunakan, dan juga parameter yang diperlukan dari templat ini ditunjukkan.</i>  <i>Dalam contoh di atas, <code>redis</code> <code>frontend</code> dan <code>redis</code> menggunakan templat dari repositori resmi.</i> <br><br>  <i>Sudah dalam versi ini, Anda dapat menggunakan sumber daya dari basis pengetahuan umum, membuat repositori templat Anda sendiri dan membangun aplikasi yang kompleks karena parameter dan bersarangnya templat.</i> <br><br>  <i>Arsitektur Helm 1 terdiri dari tiga komponen.</i>  <i>Diagram berikut menggambarkan hubungan di antara mereka:</i> <br><br><img src="https://habrastorage.org/webt/66/f8/l_/66f8l_blo_rfzohvo1wpobchuzg.png"><br><br><ol><li>  <i><code>Manager</code> melakukan fungsi server web (komunikasi dengan klien terjadi melalui API REST), mengelola penyebaran di kluster Kubernetes dan digunakan sebagai gudang data.</i> </li><li>  <i>Komponen <code>expandybird</code> membawa konfigurasi pengguna ke bentuk datar, mis.</i>  <i>berlaku templat Jinja dan jalankan skrip Python.</i> </li><li>  <i>Setelah menerima konfigurasi datar, <code>resourcifier</code> melakukan panggilan yang diperlukan ke kubectl dan mengembalikan pesan status dan kesalahan, jika ada, ke <code>manager</code> .</i> </li></ol><br>  <i>Untuk memahami kemampuan versi pertama Helm, saya akan memberikan bantuan pada perintah <code>dm</code></i> : <div class="spoiler">  <b class="spoiler_title">Bantuan keluaran dari dm</b> <div class="spoiler_text"><pre> <code class="bash hljs">Usage: ./dm [&lt;flags&gt;] &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt; [(&lt;template-name&gt; | &lt;deployment-name&gt; | (&lt;configuration&gt; [&lt;import1&gt;...&lt;importN&gt;]))] Commands: expand Expands the supplied configuration(s) deploy Deploys the named template or the supplied configuration(s) list Lists the deployments <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster get Retrieves the supplied deployment manifest Lists manifests <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deployment or retrieves the supplied manifest <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the form (deployment[/manifest]) delete Deletes the supplied deployment update Updates a deployment using the supplied configuration(s) deployed-types Lists the types deployed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster deployed-instances Lists the instances of the named <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> deployed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the cluster templates Lists the templates <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a given template registry (specified with --registry) registries Lists the registries available describe Describes the named template <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a given template registry getcredential Gets the named credential used by a registry setcredential Sets a credential used by a registry createregistry Creates a registry that holds charts Flags: -apitoken string Github api token that overrides GITHUB_API_TOKEN environment variable -binary string Path to template expansion binary (default <span class="hljs-string"><span class="hljs-string">"../expandybird/expansion/expansion.py"</span></span>) -httptest.serve string <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> non-empty, httptest.NewServer serves on this address and blocks -name string Name of deployment, used <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deploy and update commands (defaults to template name) -password string Github password that overrides GITHUB_PASSWORD environment variable -properties string Properties to use when deploying a template (eg, --properties k1=v1,k2=v2) -regex string Regular expression to filter the templates listed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a template registry -registry string Registry name (default <span class="hljs-string"><span class="hljs-string">"application-dm-templates"</span></span>) -registryfile string File containing registry specification -service string URL <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> deployment manager (default <span class="hljs-string"><span class="hljs-string">"http://localhost:8001/api/v1/proxy/namespaces/dm/services/manager-service:manager"</span></span>) -serviceaccount string Service account file containing JWT token -stdin Reads a configuration from the standard input -timeout int Time <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seconds to <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> response (default 20) -username string Github user name that overrides GITHUB_USERNAME environment variable --stdin requires a file name and either the file contents or a tar archive containing the named file. a tar archive may include any additional files referenced directly or indirectly by the named file.</code> </pre></div></div><br>  <i>Dan sekarang kembali ke teks asli tentang sejarah Helm ...</i> <br><br>  Beberapa bulan kemudian, kami bergabung dengan tim Kubernetes Deployment Manager dari Google dan mulai mengerjakan Helm 2. Tujuannya agar Helm mudah digunakan dengan menambahkan yang berikut: <br><br><ol><li>  templat bagan <i>("bagan" - analog dari paket dalam ekosistem Helm - <b>kira</b> - <b>kira terjemahan.</b> )</i> untuk penyesuaian; </li><li>  manajemen cluster untuk tim; </li><li>  repositori grafik penuh; </li><li>  format paket yang stabil dan ditandatangani; </li><li>  komitmen kuat untuk versi semantik dan menjaga kompatibilitas dari versi ke versi. </li></ol><br>  Untuk mencapai tujuan ini, komponen kedua telah ditambahkan ke ekosistem Helm.  Itu menjadi cluster Tiller di dalam, yang menyediakan pemasangan grafik Helm dan manajemen mereka. <br><br>  <i><b>Catatan</b></i>  <i><b>perev.:</b> Dengan demikian, dalam versi kedua Helm, satu-satunya komponen yang tersisa di kluster yang bertanggung jawab atas siklus hidup instalasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis</a> ), dan persiapan konfigurasi diserahkan kepada klien Helm.</i> <br><br>  <i>Jika me-reboot cluster ketika menggunakan versi pertama dari Helm menyebabkan hilangnya data layanan (karena mereka disimpan dalam RAM), maka di Helm 2 semua data disimpan di <code>ConfigMaps</code> , mis.</i>  <i>sumber daya di dalam Kubernetes.</i>  <i>Langkah penting lainnya adalah transisi dari API sinkron (di mana setiap permintaan diblokir) untuk menggunakan gRPC asinkron.</i> <br><br>  Sejak peluncuran Helm 2 pada 2016, proyek Kubernetes telah mengalami pertumbuhan eksplosif dan peluang baru yang signifikan.  Kontrol Akses Berbasis Peran (RBAC) telah ditambahkan.  Banyak tipe sumber daya baru diperkenalkan.  Menciptakan sumber daya pihak ketiga (Custom Resource Definition, CRD).  Dan yang paling penting, ada praktik terbaik.  Melalui semua perubahan ini, Helm terus melayani kebutuhan pengguna Kubernetes.  Tetapi menjadi jelas bagi kami bahwa sudah waktunya untuk melakukan perubahan besar sehingga kebutuhan ekosistem yang berkembang ini tetap terpenuhi. <br><br>  Jadi kami datang ke Helm 3. Selanjutnya saya akan berbicara tentang beberapa inovasi yang ditampilkan pada roadmap proyek. <br><br><h2>  Salam Lua </h2><br>  Di Helm 2, kami memperkenalkan template.  Pada tahap awal pengembangan Helm 2, kami mendukung Go, template Jinja, kode Python bersih, dan kami bahkan memiliki prototipe dukungan ksonnet.  Tetapi kehadiran banyak mesin untuk templat memunculkan lebih banyak masalah daripada yang dipecahkan.  Karena itu, kami sampai pada titik memilih satu. <br><br>  Templat Go memiliki empat keunggulan: <br><br><ol><li>  perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibangun ke Go</a> ; </li><li>  templat dieksekusi dalam lingkungan kotak pasir yang sangat terbatas; </li><li>  kita bisa memasukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi dan objek yang sewenang-wenang</a> ke dalam mesin; </li><li>  mereka bekerja dengan baik dengan YAML. </li></ol><br>  Meskipun kami mempertahankan antarmuka di Helm untuk mendukung mesin template lain, template Go telah menjadi standar standar kami.  Dan beberapa tahun ke depan pengalaman menunjukkan bagaimana insinyur dari banyak perusahaan membuat ribuan grafik menggunakan templat Go. <br><br>  Dan kami belajar tentang kekecewaan mereka: <br><br><ol><li>  Sintaksnya sulit dibaca dan kurang didokumentasikan. </li><li>  Masalah bahasa, seperti variabel yang tidak dapat diubah, tipe data yang rumit, dan aturan visibilitas terbatas, telah mengubah hal-hal sederhana menjadi hal yang kompleks. </li><li>  Ketidakmampuan untuk mendefinisikan fungsi di dalam templat membuat pembuatan pustaka yang dapat digunakan kembali menjadi lebih sulit. </li></ol><br>  Yang paling penting, dengan menggunakan bahasa templat, kami "memotong" objek Kubernet ke representasi garis mereka.  (Dengan kata lain, pengembang template harus mengelola sumber daya Kubernetes sebagai dokumen teks dalam format YAML.) <br><br><h2>  Kerjakan objek, bukan potongan YAML </h2><br>  Berkali-kali, kami mendengar dari pengguna permintaan kemampuan untuk memeriksa dan memodifikasi sumber daya Kubernetes sebagai objek, bukan string.  Pada saat yang sama, mereka bersikeras bahwa tidak peduli cara penerapan apa yang kami pilih untuk ini, itu harus mudah dipelajari dan dipelihara dengan baik di ekosistem. <br><br>  Setelah berbulan-bulan penelitian, kami memutuskan untuk menyediakan bahasa skrip bawaan yang dapat dikemas dalam kotak pasir dan disesuaikan.  Di antara 20 bahasa teratas, hanya ada satu kandidat yang memenuhi persyaratan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lua</a> . <br><br>  Pada tahun 1993, sekelompok insinyur IT Brasil menciptakan bahasa scripting ringan untuk disematkan dalam alat mereka.  Lua memiliki sintaksis yang sederhana, ia didukung secara luas dan telah ditampilkan dalam daftar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">20 bahasa teratas</a> untuk waktu yang lama.  Didukung oleh IDE dan editor teks, ada banyak manual dan tutorial.  Pada ekosistem yang ada, kami ingin mengembangkan solusi kami. <br><br>  Pekerjaan kami pada Helm Lua masih pada tahap pembuktian konseptual, dan kami mengharapkan sintaksis yang akrab dan fleksibel.  Membandingkan pendekatan lama dan baru, Anda bisa melihat di mana kita bergerak. <br><br>  Berikut adalah <a href="">contoh</a> templat perapian dengan Alpine in Helm 2: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod metadata: name: {{ template "alpine.fullname" . }} labels: heritage: {{ .Release.Service }} release: {{ .Release.Name }} chart: {{ .Chart.Name }}-{{ .Chart.Version }} app: {{ template "alpine.name" . }} spec: restartPolicy: {{ .Values.restartPolicy }} containers: - name: waiter image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}" imagePullPolicy: {{ .Values.image.pullPolicy }} command: ["/bin/sleep", "9000"]</code> </pre> <br>  Dalam templat langsung ini, Anda dapat langsung melihat semua arahan templat <code>{{ .Chart.Name }}</code> , seperti <code>{{ .Chart.Name }}</code> . <br><br>  Dan inilah definisi perapian yang sama dalam versi awal kode Lua: <br><br><pre> <code class="lua hljs">unction create_alpine_pod(_) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pod = { apiVersion = <span class="hljs-string"><span class="hljs-string">"v1"</span></span>, kind = <span class="hljs-string"><span class="hljs-string">"Pod"</span></span>, metadata = { name = alpine_fullname(_), labels = { heritage = _.Release.Service <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"helm"</span></span>, release = _.Release.Name, chart = _.Chart.Name .. <span class="hljs-string"><span class="hljs-string">"-"</span></span> .. _.Chart.Version, app = alpine_name(_) } }, spec = { restartPolicy = _.Values.restartPolicy, containers = { { name = waiter, image = _.Values.image.repository .. <span class="hljs-string"><span class="hljs-string">":"</span></span> .. _.Values.image.tag, imagePullPolicy = _.Values.image.pullPolicy, command = { <span class="hljs-string"><span class="hljs-string">"/bin/sleep"</span></span>, <span class="hljs-string"><span class="hljs-string">"9000"</span></span> } } } } } _.resources.add(pod) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Tidak perlu melihat setiap baris dari contoh ini untuk memahami apa yang terjadi.  Segera jelas bahwa dalam kode itu didefinisikan di bawah.  Tetapi alih-alih menggunakan string YAML dengan arahan template bawaan, kami mendefinisikannya sebagai objek di Lua. <br><br><h2>  Mari kita persingkat kode ini </h2><br>  Karena kita bekerja secara langsung dengan objek (alih-alih memanipulasi gumpalan besar teks), kita dapat memanfaatkan skrip sepenuhnya.  Peluang untuk membuat perpustakaan bersama yang muncul di sini terlihat sangat menarik.  Dan kami berharap bahwa dengan memperkenalkan perpustakaan khusus (atau memungkinkan komunitas untuk membuatnya), kami dapat mengurangi kode di atas menjadi sesuatu seperti ini: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pods = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"mylib.pods"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_alpine_pod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_)</span></span></span></span> myPod = pods.new(<span class="hljs-string"><span class="hljs-string">"alpine:3.7"</span></span>, _) myPod.spec.restartPolicy = <span class="hljs-string"><span class="hljs-string">"Always"</span></span> <span class="hljs-comment"><span class="hljs-comment">-- set any other properties _.Manifests.add(myPod) end</span></span></code> </pre> <br>  Dalam contoh ini, kami menggunakan kemampuan untuk bekerja dengan definisi sumber daya sebagai objek, yang mudah untuk mengatur properti, sambil mempertahankan keringkasan dan keterbacaan kode. <br><br><h2>  Template ... Lua ... Kenapa tidak semuanya? </h2><br>  Meskipun templat tidak begitu bagus untuk semua tugas, mereka masih memiliki kelebihan tertentu.  Templat di Go adalah teknologi stabil dengan basis pengguna yang mapan dan banyak bagan yang ada.  Banyak pengembang bagan mengklaim suka menulis templat.  Karena itu, kami tidak akan menghapus dukungan template. <br><br>  Sebagai gantinya, kami ingin mengizinkan templat dan Lua untuk digunakan secara bersamaan.  Skrip Lua akan memiliki akses ke templat Helm sebelum dan sesudah diberikan, yang akan memungkinkan pengembang bagan tingkat lanjut untuk melakukan transformasi kompleks pada bagan yang ada, sambil mempertahankan kemampuan sederhana untuk membuat bagan Helm dengan templat. <br><br>  Kami sangat didorong oleh dukungan skrip pada Lua, tetapi pada saat yang sama kami menyingkirkan bagian penting dari arsitektur Helm ... <br><br><h2>  Ucapkan selamat tinggal pada Tiller </h2><br>  Selama pengembangan Helm 2, kami memperkenalkan Tiller sebagai komponen integrasi dengan Deployment Manager.  Tiller memainkan peran penting bagi tim yang bekerja pada kluster yang sama: memungkinkan untuk berinteraksi dengan serangkaian rilis yang sama untuk banyak administrator yang berbeda. <br><br>  Namun, Tiller bertindak sebagai server sudo raksasa, memberikan berbagai macam hak kepada semua orang yang memiliki akses ke Tiller.  Dan skema instalasi default kami adalah konfigurasi permisif.  Oleh karena itu, para insinyur DevOps dan SRE harus mempelajari langkah-langkah tambahan untuk menginstal Tiller di kluster multi-tenant. <br><br>  Selain itu, dengan munculnya CRD, kami tidak lagi dapat diandalkan mengandalkan Tiller untuk mempertahankan status atau fungsi sebagai pusat hub untuk informasi rilis Helm.  Kami hanya dapat menyimpan informasi ini sebagai entri terpisah di Kubernetes. <br><br>  Tujuan utama Tiller dapat dicapai tanpa Tiller itu sendiri.  Oleh karena itu, salah satu keputusan pertama yang dibuat selama fase perencanaan Helm 3 adalah sepenuhnya meninggalkan Tiller. <br><br><h2>  Peningkatan keamanan </h2><br>  Tanpa Tiller, model keamanan Helm secara radikal disederhanakan.  Otentikasi pengguna didelegasikan oleh Kubernetes.  Dan otorisasi juga.  Hak-hak helm didefinisikan sebagai hak Kubernetes (melalui RBAC), dan administrator cluster dapat membatasi hak Helm pada tingkat rincian yang disyaratkan. <br><br><h2>  Rilis, ReleaseVersions, dan Penyimpanan Negara </h2><br>  Dengan tidak adanya Tiller, untuk mempertahankan keadaan berbagai rilis di dalam kluster, kami membutuhkan cara baru untuk semua klien untuk berinteraksi (tentang manajemen rilis). <br><br>  Untuk melakukan ini, kami memperkenalkan dua entri baru: <br><br><ol><li>  <code>Release</code> - untuk instalasi spesifik dari grafik tertentu.  Jika kita menjalankan <code>helm install my-wordpress stable/wordpress</code> , rilis yang disebut <code>my-wordpress</code> akan dibuat dan dikelola sepanjang umur instalasi WordPress ini. </li><li>  <code>ReleaseVersion</code> - setiap kali Anda memperbarui grafik Helm, Anda harus mempertimbangkan apa yang telah berubah dan apakah perubahan itu berhasil.  <code>ReleaseVersion</code> terkait dengan rilis dan hanya menyimpan catatan dengan informasi tentang memperbarui, memutar kembali, dan menghapus.  Ketika kami menjalankan <code>helm upgrade my-wordpress stable/wordpress</code> , objek <code>Release</code> asli tetap sama, tetapi objek <code>ReleaseVersion</code> anak <code>ReleaseVersion</code> dengan informasi tentang operasi pembaruan. </li></ol><br>  <code>Releases</code> dan <code>ReleaseVersions</code> akan disimpan dalam ruang nama yang sama dengan objek grafik. <br><br>  Dengan fitur-fitur ini, tim pengguna Helm akan dapat melacak catatan instalasi Helm di cluster tanpa perlu Tiller. <br><br><h2>  Tapi tunggu, itu belum semuanya! </h2><br>  Pada artikel ini saya mencoba berbicara tentang beberapa perubahan besar pada Helm 3. Namun, daftar ini sama sekali tidak lengkap.  <a href="">Rencana Helm 3 juga</a> mencakup perubahan lain, seperti peningkatan dalam format bagan, peningkatan kinerja untuk repositori bagan, dan sistem acara baru yang dapat digunakan pengembang bagan.  Kami juga membuat Eric Raymond disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode arkeologi dengan</a> membersihkan basis kode dan memperbarui komponen yang telah kehilangan relevansi dalam tiga tahun terakhir. <br><br>  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Ini sebuah paradoks, tetapi manajer paket Helm 2, ketika <code>install</code> atau <code>upgrade</code> berhasil, mis.</i>  <i>memiliki rilis dalam keadaan <code>success</code> tidak menjamin bahwa sumber daya aplikasi telah berhasil diluncurkan (misalnya, tidak ada kesalahan seperti <code>ImagePullError</code> ).</i>  <i>Mungkin model acara baru akan memungkinkan Anda untuk menambahkan kait tambahan untuk sumber daya dan lebih baik mengontrol proses peluncuran - kami akan segera mengetahuinya.</i> <br><br>  Dengan aksesi Helm ke CNCF, tidak hanya Helm 3, tetapi juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chart Museum</a> , utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chart Testing</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori grafik resmi</a> dan proyek lainnya di bawah naungan Helm di CNCF menginspirasi kami.  Kami yakin bahwa manajemen paket yang baik untuk Kubernetes sama pentingnya bagi ekosistem asli cloud seperti halnya manajer paket yang baik untuk Linux. <br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar praktis untuk manajer paket untuk Kubernetes - Helm</a> "; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berlatihlah dengan dapp.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Penempatan gambar Docker di Kubernetes menggunakan Helm</a> "; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bangun dan instal aplikasi di Kubernet menggunakan dapp dan GitLab CI</a> ”; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktik CI / CD Terbaik dengan Kubernetes dan GitLab</a> ” <i>(ulasan dan laporan video)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengalaman kami dengan Kubernetes dalam proyek-proyek kecil</a> " <i>(laporan video, yang mencakup pengantar perangkat teknis Kubernetes).</i> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417079/">https://habr.com/ru/post/id417079/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417065/index.html">Splunk How-to, atau How dan Where to Learn Splunk</a></li>
<li><a href="../id417069/index.html">Sekali lagi tentang OpenSSL</a></li>
<li><a href="../id417071/index.html">Jumat PHP: Webinar Skillbox Gratis</a></li>
<li><a href="../id417073/index.html">Hari Pengembang Seluler Uber</a></li>
<li><a href="../id417075/index.html">API Cat CSS</a></li>
<li><a href="../id417081/index.html">Utara, akan, berharap, negara tanpa batas, atau Bagaimana proyek dibuat dalam kondisi Siberia yang parah</a></li>
<li><a href="../id417083/index.html">Banyak sekali Piala Dunia 2018</a></li>
<li><a href="../id417085/index.html">Browser membisukan suara dalam aplikasi WebRTC Anda. Hentikan apa?</a></li>
<li><a href="../id417087/index.html">HPE Digitize 2018: acara dan siaran langsung</a></li>
<li><a href="../id417089/index.html">Komputer kuantum: satu foton untuk memerintah semua</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>