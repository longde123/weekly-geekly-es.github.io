<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîã üéæ üçΩÔ∏è Perintah Cepat Siri üßóüèø üë©üèΩ‚Äçüç≥ üßìüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu fitur iOS 12 yang berguna (menurut saya) yang diperkenalkan di WWDC 2018 adalah Siri Shortcuts . 


 Pintasan ( pintasan ) - perintah cepat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perintah Cepat Siri</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/414677/"><p><img src="https://habrastorage.org/webt/ge/mr/un/gemrunsbwx7gf07v5htwy9lytpu.png"></p><br><p>  Salah satu fitur iOS 12 yang berguna (menurut saya) yang diperkenalkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://">WWDC 2018</a> adalah <strong>Siri Shortcuts</strong> . </p><br><p>  Pintasan ( <em>pintasan</em> ) - perintah cepat, cara singkat untuk melakukan tindakan apa pun yang melewati skrip standar. </p><br><p>  Di aplikasi Anda, Anda dapat mengambil pintasan untuk beberapa tindakan.  Mempelajari bagaimana dan kapan pengguna mengimplementasikannya, Siri memulai dengan cerdas, pada waktu dan tempat yang tepat, untuk menawarkan kepadanya pintasan ini dan, yang paling penting, pengguna dapat memanggil mereka dengan frasa yang akan dilampirkan padanya!  Di bawah kucing lebih banyak. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Bagaimana cara kerjanya </h2><br><p>  Kami menggunakan aplikasi yang, dengan tindakan tertentu, membuat dan mengirimkan pintasan ke sistem. </p><br><p>  Anda dapat melihat pintasan ini di <strong>Pengaturan ‚Üí Siri dan Cari</strong> . <br><img src="https://habrastorage.org/webt/vp/z2/fd/vpz2fdo_rakpjpl-imiuvzkbyly.png"><br>  Tangkapan layar di atas menunjukkan tiga pintasan terakhir yang ditangkap sistem dari berbagai aplikasi.  Jika kita mengklik tombol ‚ÄúLebih banyak jalan pintas‚Äù, kita akan melihat semua jalan pintas yang dikirimkan ke sistem oleh setiap aplikasi. </p><br><p>  Dengan pengaturan tertentu dalam kode pembuatan pintasan, Siri akan menawarkan pintasan ini kepada pengguna di layar yang terkunci, di pusat notifikasi dan pencarian, dengan fokus pada seberapa sering kita menggunakan tindakan ini, pada jam berapa, pada hari apa dalam seminggu, dan di mana faktor-faktor lainnya. </p><br><p>  Sebagai contoh, jika pada Jumat malam Anda biasanya mencari ATM, kemudian setelah dilatih, Siri akan menawarkan Anda jalan pintas dengan tindakan ini pada Jumat malam. </p><br><p><img src="https://habrastorage.org/webt/ef/my/gu/efmyguxaczsetehquug_nyp7vnc.png"></p><br><p>  Kita dapat menambahkan perintah suara ke setiap pintasan jika kita mengeklik ikon " <strong>+</strong> ". </p><br><p>  Kami mengucapkan perintah suara, tekan "Selesai", dan sekarang kita dapat melakukan tindakan di belakang pintasan menggunakan suara melalui Siri.  <em>Ternyata pengguna akan dapat melakukan fungsionalitas aplikasi Anda melalui Siri tanpa membuka aplikasi itu sendiri.</em>  Pintasan dengan frasa tersebut disimpan dalam "Pintasan saya". </p><br><h2 id="sozdanie-shortkatov">  Membuat Pintasan </h2><br><p> Untuk pengembangan, kita akan memerlukan Xcode 10 dan iOS 12. Pada saat penulisan, keduanya berada pada tahap <strong>Beta</strong> . </p><br><p> Pintasan dapat dibuat baik melalui <code>NSUserActivity</code> atau melalui <code>Intent</code> . </p><br><p>  Kasus pertama: </p><br><p>  Pengguna mengklik pintasan, yang melewati perintah dengan parameter ( <code>NSUserActivity</code> ) ke aplikasi kami, dan memutuskan bagaimana perintah ini harus diproses (buka jendela kurs USD saat ini, atau jendela pesanan pizza favorit kami).  Ini adalah jalan pintas Spotlight tua yang baik yang kita semua tahu, tetapi ditawarkan dengan cerdas oleh Siri. </p><br><p>  Kasus kedua: </p><br><p>  Pintasan yang dibuat melalui <code>Intent</code> lebih menarik - pintasan memungkinkan Anda untuk menjalankan perintah langsung di antarmuka Siri tanpa meluncurkan aplikasi Anda.  Sebelumnya, perangkat <code>Intent</code> sangat sulit untuk Apple: mentransfer uang, mengirim pesan, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lainnya</a> .  Sekarang, kami para pengembang memiliki kesempatan untuk membuat <code>Intent</code> kami! </p><br><p>  Terlepas dari bagaimana cara pintas dibuat, ia melewati 3 tahap siklus hidup: </p><br><ol><li>  Pengumuman ( <strong><em>Tentukan</em></strong> ) </li><li>  Pengiriman ke sistem ( <strong><em>Sumbang</em></strong> ) </li><li>  Diproses dengan aplikasi ( <strong><em>Menangani</em></strong> ) </li></ol><br><p><img src="https://habrastorage.org/webt/ie/7b/6z/ie7b6zoy5fd9mkx5ivjddp0agxc.png"></p><br><p>  Penelitian saya menunjukkan bahwa satu aplikasi dapat mengirimkan tidak lebih dari 20 pintasan ke sistem. </p><br><p>  Selanjutnya kita akan mempertimbangkan bagaimana memberi aplikasi kita kemampuan untuk membuat cara pintas dan bagaimana cara bekerja dengan mereka di dalamnya. </p><br><h2 id="sozdanie-shortkatov-cherez-nsuseractivity">  Membuat Pintasan Melalui <code>NSUserActivity</code> </h2><br><p>  Mari kita menganalisis yang pertama, jenis cara pintas sederhana yang terbuka melalui <code>NSUserActivity</code> . </p><br><p>  Misalnya, dalam aplikasi bank seluler, kami memiliki layar pencarian ATM dan saya sering mencarinya.  Untuk sampai ke layar dengan kartu ATM, saya harus meluncurkan aplikasi, buka tab "Lainnya" di tab, pilih bagian "Info" dan klik tombol "ATM" di sana. <br>  Jika kita membuat pintasan yang langsung mengarah ke layar ini, pengguna akan dapat masuk ke dalamnya dengan satu sentuhan ketika Siri menawarkannya kepadanya, misalnya, pada layar yang terkunci. </p><br><h3 id="obyavlyaem-shortkat-declare">  Nyatakan pintasan </h3><br><p>  Langkah pertama adalah mendeklarasikan tipe seperti <code>NSUserActivity</code> kami (kami dapat mengatakan bahwa ini adalah pengenalnya) di <em>info.playlist</em> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSUserActivityTypes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>ru.tinkoff.demo.show-cashMachine<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Diumumkan </p><br><h3 id="dostavlyaem-shortkat-v-sistemu-donate">  Kirimkan pintasan ke sistem (Sumbang) </h3><br><p>  Setelah deklarasi, kita dapat membuat <code>NSUserActivity</code> dalam kode aplikasi kita dengan tipe yang kita atur di <strong>info.playlist</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> activity = NSUserActivity(activityType: <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span>)</code> </pre> <br><p>  Agar aktivitas masuk ke daftar pintasan sistem, itu harus diatur ke <code>title</code> , dan setel properti <code>isEligibleForSearch</code> menjadi <code>true</code> .  Properti lain tidak diperlukan untuk menambahkan pintasan, tetapi keberadaannya membuat pintasan lebih mudah dibaca dan ramah pengguna. </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   (     ,   ) activity.title = " " if #available(iOS 12.0, *) { // ,             activity.suggestedInvocationPhrase = "  " //           activity.isEligibleForPrediction = true // (     ,   ) activity.isEligibleForSearch = true } //       let attributes = CSSearchableItemAttributeSet(itemContentType: "NSUserActivity.searchableItemContentType") ///    if let image = UIImage(named: "siriAtmIcon") { attributes.thumbnailData = UIImagePNGRepresentation(image) } ///   attributes.contentDescription = "     " ///     activity.contentAttributeSet = attributes</span></span></code> </pre> <br><p>  Api!  <code>NSUserActivity</code> adalah, untuk mengirimkannya ke sistem, ia masih harus mengambil langkah terakhir. </p><br><p>  <code>ViewConroller</code> memiliki properti <code>userActivity</code> , yang kami perlukan untuk menetapkan <code>activity</code> dibuat di atas: </p><br><pre> <code class="javascript hljs">self.userActivity = activity</code> </pre> <br><p>  Segera setelah baris ini dieksekusi, jalan pintas akan dibuat dari aktivitas ini.  Ini akan dikirimkan ke sistem dan ditampilkan dalam pengaturan Siri ( <strong>Pengaturan ‚Üí Siri dan Pencarian</strong> ).  Kemudian Siri akan dapat menawarkannya kepada pengguna, dan pengguna akan dapat menetapkan perintah suaranya. </p><br><p>  <em><strong>Catatan</strong> : Dokumentasi Apple mengatakan bahwa alih-alih menugaskan aktivitas ke pengontrol tampilan, itu sudah cukup untuk memanggil metode <code>becomeCurrent()</code> pada <code>becomeCurrent()</code> .</em>  <em>Namun, tindakan ini tidak mengirimkan aktivitas ke sistem saya dan jalan pintas tidak muncul dalam daftar</em> </p><br><blockquote>  Selanjutnya, panggil metode <code>becomeCurrent()</code> pada objek aktivitas pengguna untuk menandainya sebagai arus, yang menyumbangkan aktivitas ke Siri.  Atau, Anda dapat melampirkan objek ke objek UIViewController atau UIResponder, yang juga menandai aktivitas sebagai arus. </blockquote><p>  Untuk memeriksa apakah semuanya berfungsi, buka <strong>Pengaturan&gt; Siri dan cari</strong> - pintasan berdasarkan aktivitas kami harus ada dalam daftar. </p><br><h3 id="obrabotka-shortkata-prilozheniem-handle">  Memproses Pintasan berdasarkan Aplikasi (Pegangan) </h3><br><p>  Ketika pengguna menavigasi pintasan dari pusat notifikasi atau mengaktifkannya dengan suara, aplikasi akan dimulai, dan kita harus memproses pintasan ini. </p><br><p>  <code>activity</code> dilemparkan kepada kami di <code>AppDelegate</code> 'metode: </p><br><pre> <code class="javascript hljs">func application(_ application: UIApplication, <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> userActivity: NSUserActivity, <span class="hljs-attr"><span class="hljs-attr">restorationHandler</span></span>: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userActivity.activityType == <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,     handleShowCashMachineActivity() return true } return false }</span></span></code> </pre> <br><h3 id="itogo">  Total </h3><br><p>  <code>NSUserActivity</code> NSUserActivity dibuat sebagai berikut: </p><br><ol><li>  Nyatakan tipe (pengidentifikasi) <code>NSUserActivity</code> di <code>NSUserActivity</code> . </li><li>  Kami membuat <code>NSUserActivity</code> dalam kode dan kami mengonfigurasi </li><li>  <code>viewController'</code> . </li></ol><br><h2 id="sozdanie-golosovyh-komand-iz-prilozheniya">  Membuat perintah suara dari suatu aplikasi </h2><br><p>  Jadi, jika pengguna membuka <strong>Pengaturan&gt; Siri dan mencari</strong> , ia akan melihat daftar pintasannya, yang dibuat oleh berbagai aplikasi, termasuk aplikasi kami.  Dengan mengklik " <strong>+</strong> ", pengguna dapat membuat perintah suara apa saja dan mengaitkannya dengan pintasan yang dipilih.  Namun, setiap kali memasuki pengaturan tidak nyaman bagi pengguna, banyak yang bahkan tidak menyadari tentang kemungkinan ini. </p><br><p>  Sangat keren bahwa Anda dapat melampirkan perintah suara ke tindakan tertentu langsung di dalam aplikasi. </p><br><p>  Misalkan seorang pengguna melakukan beberapa tindakan, itu dikirim ke sistem, ia ingin menyimpannya.  Kita dapat menambahkan tombol " <em>tambahkan tindakan ke Siri</em> " (Anda dapat memberi nama dan menggambar tombol sesuka Anda) pada layar aplikasi kami, maka pengguna, dengan mengkliknya, akan dapat mengaitkan tindakan ini dengan perintah suara dari dalam aplikasi tanpa masuk ke pengaturan. </p><br><p>  Dengan mengklik tombol, Anda harus membuka layar untuk menambahkan perintah suara ke cara pintas di Siri <code>INUIAddVoiceShortcutViewController</code> , atau layar untuk mengedit perintah suara <code>INUIEditVoiceShortcutViewController</code> , jika sudah dibuat.  Tindakan yang tidak bereaksi <code>action</code> tombol tersebut akan kira-kira sebagai berikut: </p><br><pre> <code class="hljs julia"> <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> func addToSiriAction() { // <span class="hljs-number"><span class="hljs-number">1.</span></span>   ,       INVoiceShortcutCenter.shared.getAllVoiceShortcuts { (shortcuts, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> guard error == nil, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcuts = shortcuts <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // TODO: Handle error <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } // <span class="hljs-number"><span class="hljs-number">2.</span></span>     ,      <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> donatedShortcut: INVoiceShortcut? = shortcuts.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { (shorcut) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shorcut.__shortcut.userActivity?.activityType == <span class="hljs-string"><span class="hljs-string">"com.ba"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = donatedShortcut { // <span class="hljs-number"><span class="hljs-number">3.</span></span>     -     . //         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> editVoiceShortcutViewController = INUIEditVoiceShortcutViewController(voiceShortcut: shortcut) editVoiceShortcutViewController.delegate = self self.present(editVoiceShortcutViewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: nil) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-number"><span class="hljs-number">4.</span></span>         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = INShortcut(userActivity: self.userActivity!) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addVoiceShortcutViewController = INUIAddVoiceShortcutViewController(shortcut: shortcut) addVoiceShortcutViewController.delegate = self } } }</code> </pre> <br><p>  Jadi, layar untuk menambahkan dan mengedit perintah suara untuk cara pintas Siri terlihat: </p><br><p><img src="https://habrastorage.org/webt/ez/lk/ai/ezlkaihh3q9gvj4syqkizbwqy4c.png"></p><br><p>  Kita juga harus menerapkan metode delegasi dari viewControllers ini, di mana mereka perlu menyembunyikan <code>dismiss(animated: true, completion: nil)</code> dan, jika perlu, perbarui layar saat ini.  Misalnya, jika sebelumnya ada tombol ‚Äútambahkan perintah suara‚Äù di layar, maka setelah menambahkan perintah suara, tombol ini akan hilang atau berubah menjadi ‚Äúedit perintah suara‚Äù. </p><br><h2 id="shortkaty-sozdannye-pri-pomoschi-intent">  Pintasan Intent </h2><br><p>  Sejauh ini, kami hanya berbicara tentang cara pintas yang membuka aplikasi dan meneruskan data <code>NSUserActivity</code> ke <code>NSUserActivity</code> . </p><br><p>  Tetapi kembali ke pintasan yang dibuat melalui <code>Intent</code> , yang memungkinkan Anda melakukan beberapa tindakan tanpa membuka aplikasi.  Di sini kesenangan dimulai. </p><br><p>  Bayangkan seorang pengguna memesan pizza favoritnya.  Dia akan memesannya berkali-kali kapan pun dia mau, dan dia bahkan menambahkan perintah suara ke pintasan pizza ini - dan ini menyederhanakan hidupnya.  Tetapi kita dapat melakukan lebih banyak untuknya - kita dapat memastikan bahwa dengan memberikan perintah suara Siri, sistem tidak membuangnya ke dalam aplikasi, tetapi menampilkan informasi pesanan dan memesan pizza segera di antarmuka Siri!  Ini hanya terjadi ketika pengguna tidak perlu membuka aplikasi itu sendiri untuk melakukan beberapa tindakan. </p><br><p>  Pertama, buka pengaturan proyek, pilih target utama, tab <code>Capabilities</code> dan aktifkan akses ke Siri. </p><br><p>  Aplikasi kita dapat berinteraksi dengan Siri, tetapi ini tidak terjadi pada kode utama aplikasi, tetapi dalam target-ekstensi yang terpisah <strong>Intents Extensions</strong> </p><br><p>  Untuk memulai, target ini harus dibuat: <strong>File ‚Üí Baru ‚Üí Target</strong> , pilih <strong>Intents Extensions</strong> .  Xcode akan menawarkan untuk membuat ekstensi target lain untuk jendela yang menampilkan tindakan Anda di Siri, jika ada kebutuhan untuk ini, maka kami setuju. </p><br><p><img src="https://habrastorage.org/webt/ia/o_/pp/iao_pphchyfpr33hj6jluyy-ozc.jpeg"></p><br><h3 id="obyavlyaem-shortkat-declare-1">  Nyatakan pintasan </h3><br><p>  Inovasi utama SiriKit di iOS 12 adalah kemampuan untuk membuat <code>Inetnts</code> Anda, bagi yang sebelumnya. </p><br><p><img src="https://habrastorage.org/webt/5a/66/6m/5a666mqkcm0li-cujpl7yexzrgm.png"></p><br><p>  Untuk melakukan ini, buat file baru: <strong>File ‚Üí Baru ‚Üí File</strong> , pilih <strong>SiriKit Intent Definition File</strong> dari bagian <strong>Resource</strong> . </p><br><p><img src="https://habrastorage.org/webt/qz/8l/lx/qz8llxznc1o05palhxxxcskrcbq.png"></p><br><p>  Akibatnya, sebuah file dengan ekstensi <em>.intentdefinition muncul</em> , di mana Anda dapat membuat <code>Intents</code> Anda sendiri.  Kami membuka file, dan di mana tertulis " <strong>No Intents</strong> " di bagian bawah ada ikon " <strong>+</strong> " - klik di atasnya.  " <strong>Niat Baru</strong> ".  Niat akan muncul dalam daftar yang dapat Anda tambahkan parameter.  Dalam hal pemesanan pizza, Anda dapat menambahkan jumlah pizza dan jenis pizza yang dipesan sebagai parameter.  Untuk kuantitas kami memilih tipe <code>Integer</code> , dan untuk tipe pizza kami memilih tipe <code>Custom</code> , yang dalam kode akan diwakili oleh kelas <code>INObject</code> . </p><br><p>  Sekarang beberapa garis frustrasi: </p><br><p>  <strong>Pengguna tidak akan dapat mengirimkan parameter yang berbeda ke perintah suara yang disimpan sama.</strong>  <strong>Sayang!</strong> </p><br><p><img src="https://habrastorage.org/webt/kn/z4/y-/knz4y-oo1kns8ehvzoojslxqycq.jpeg"></p><br><p>  Apa parameter untuk: </p><br><p>  Misalkan Anda membuat entitas "Tampilkan nilai <code>%currency</code> ", di mana <code>currency</code> adalah parameter entitas.  Ini tidak berarti bahwa pengguna dapat mengatakan frasa ‚ÄúTampilkan nilai tukar dolar‚Äù, ‚ÄúTampilkan nilai tukar Bitcoin‚Äù, dll.  Di luar kotak, ini tidak akan berfungsi seperti itu.  Tetapi ini berarti bahwa jika pengguna melihat nilai tukar dolar, pintasan "Tampilkan kurs USD" telah dibuat, maka ketika ia melihat pada nilai tukar Bitcoin, pintasan "Tampilkan kurs BTC" telah dibuat, dll.  Dengan kata lain, dia mungkin memiliki beberapa shorkata yang didasarkan pada tujuan yang sama, tetapi dengan parameter yang berbeda.  Setiap pintasan, pengguna akan dapat meminta perintah suaranya. </p><br><p>  Nah, dengan membuat maksud dalam file <em>.intentdefinition</em> , <em>Xcode</em> akan secara otomatis menghasilkan kelas untuk maksud itu (catatan: itu tidak akan muncul dalam file proyek, tetapi akan tersedia untuk digunakan). File yang dibuat secara otomatis ini hanya akan berada di target yang memiliki file <em>.intentdefinition</em> . </p><br><p>  Setelah membuat maksud dalam file .intentdefinition <em>,</em> kita dapat membuat niat kita dalam kode. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intent = <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span>()</code> </pre> <br><h3 id="dostavlyaem-shortkat-v-sistemu-donate-1">  Kirimkan pintasan ke sistem (Sumbang) </h3><br><p>  Agar entitas ini dimasukkan dalam daftar cara pintas, Anda harus menyematkannya.  Untuk melakukan ini, objek <code>INInteraction</code> dibuat dengan instance niat Anda, dan metode .donate dipanggil pada <code>.donate</code> ini </p><br><pre> <code class="hljs lua">let intent = OrderPizzaIntentf() // ...   let interaction = INInteraction(intent: intent, response: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) interaction.donate { (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> // ...   /  }</code> </pre> <br><p>  Setelah menjalankan kode ini, pintasan berbasis maksud akan dikirimkan ke sistem dan ditampilkan dalam Pengaturan Siri. </p><br><h3 id="obrabatyvaem-shortkat-prilozheniem-handle">  Kami memproses aplikasi pintasan (Menangani) </h3><br><p>  Langkah selanjutnya adalah memproses maksud ketika pengguna mengkliknya di sirjest Siri atau menyebutnya dengan perintah suara. </p><br><p>  Kami telah membuat ekstensi target untuk Siri dan memiliki kelas IntentHandler yang telah dibuat sebelumnya, yang memiliki satu metode tunggal - `` handle (untuk maksud) `` </p><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intent: INIntent)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Any</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> intent <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unhandled intent type: \(intent)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntentHandler</span></span>() } }</code> </pre> <br><blockquote>  Catatan: Jika kompiler tidak melihat kelas maksud Anda, maka Anda belum menambahkan file ekstensi target <em>.intentdefinition</em> untuk Siri. </blockquote><p>  Dalam metode ini, kami menentukan jenis niat masuk dan untuk setiap jenis kami membuat objek penangan yang akan memproses niat ini.  Buat penangan untuk <code>OrderPizzaIntent</code> kami, dan terapkan protokol <code>OrderPizzaIntentHandling</code> di dalamnya, yang sudah dihasilkan secara otomatis setelah membuat Intent di <em>.intentdefinition Anda</em> . </p><br><p>  Protokol berisi dua metode <code>confirm</code> dan <code>handle</code> .  Pertama, <code>confirm</code> disebut di mana semua data diperiksa dan ketersediaan tindakan diperiksa.  Kemudian <code>handle</code> akan bekerja dalam aksi singkat yang akan dilakukan. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandling</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(intent: OrderPizzaIntent, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(OrderPizzaIntentResponse)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.ready, userActivity: nil)) } public func handle(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { //     // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.success, userActivity: nil)) } }</span></span></code> </pre> <br><p>  Kedua metode ini pasti harus memanggil <code>completion</code> dengan respons <code>OrderPizzaIntentResponse</code> (ini juga dibuat secara otomatis), jika tidak, Siri hanya akan menunggu lama dan kemudian memberikan kesalahan. </p><br><h3 id="bolee-podrobnye-otvety-ot-siri">  Jawaban lebih rinci dari Siri </h3><br><p>  Ada seperangkat kode respons standar yang dibuat secara otomatis - <code>enum OrderPizzaIntentResponseCode</code> , tetapi mungkin tidak cukup untuk antarmuka yang ramah.  Misalnya, pada tahap <code>confirm</code> , beberapa kesalahan dapat terjadi - pizza telah habis, pizzeria tidak berfungsi saat ini, dll.  dan pengguna harus belajar tentang fakta-fakta ini, alih-alih pesan standar "Kesalahan Aplikasi".  Ingat kami membuat <code>Intent</code> di file <em>.intentdefinition</em> ?  Bersamaan dengan maksud itu sendiri, <code>Response</code> di mana Anda dapat menambahkan opsi Anda sendiri untuk kesalahan dan jawaban yang berhasil, dan mengonfigurasinya dengan parameter: </p><br><p><img src="https://habrastorage.org/webt/xz/zg/fa/xzzgfawljagfnruxp_zjjdeug2m.png"></p><br><p>  Sekarang kami dapat memberi tahu pengguna lebih banyak kesalahan dan jawaban informatif: </p><br><pre> <code class="hljs lua">public func confirm(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { guard let pizzaKindId = intent.kind?.identifier <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         -     completion(OrderPizzaIntentResponse(code: .failure, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.isPizzeriaClosed == <span class="hljs-literal"><span class="hljs-literal">true</span></span> { ///     -     completion(OrderPizzaIntentResponse(code: .failurePizzeriaClosed, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.menu.isPizzaUnavailable(identifier: pizzaKindId) { ///      -     completion(OrderPizzaIntentResponse(code: .failurePizzaUnavailable(kind: intent.kind), userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } //     -    completion(OrderPizzaIntentResponse(code: .ready, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) }</code> </pre> <br><h3 id="otrisovka-intenta">  <code>Intent</code> rendering </h3><br><p>  Jika kami membuat <strong>ekstensi</strong> target <strong>UI Intent Extension</strong> , maka kami dapat menggambar tampilan khusus di Siri untuk maksud yang kami butuhkan.  Kami memiliki <code>MainInterface.storyboard</code> dan <code>IntentViewController</code> di mana kami dapat membuat sketsa desain mereka.  Pengontrol tampilan ini mengimplementasikan protokol INUIHostedViewControlling dan tampilan <code>configureView</code> dalam metode <code>configureView</code> </p><br><pre> <code class="hljs sql">// <span class="hljs-keyword"><span class="hljs-keyword">Prepare</span></span> your <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the interaction <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> handle. func configureView(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> interaction: INInteraction, interactiveBehavior: INUIInteractiveBehavior, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: INUIHostedViewContext, completion: @escaping (<span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, CGSize) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Void</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> configuration here, <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> preparing views <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> calculating a desired <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> presentation. completion(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>, self.desiredSize) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desiredSize: CGSize { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.extensionContext!.hostedViewMaximumAllowedSize }</code> </pre> <br><p>  Agar metode ini dipanggil, Anda perlu menambahkan nama maksud kami ke array <code>NSExtension</code> -&gt; <code>NSExtensionAttributes</code> -&gt; <code>IntentsSupported</code> , yang merujuk pada ekstensi target Intents UI </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtension<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtensionAttributes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>IntentsSupported<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>OrderPizzaIntent<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Bergantung pada desain tampilan Anda di Siri dan <code>interaction.intent</code> yang masuk ke metode, Anda bisa menggambar tampilan ini seperti yang Anda inginkan.  Di bawah ini adalah tangkapan layar tentang bagaimana maksud kami di Siri, dalam pencarian, dan pada layar yang terkunci. </p><br><p><img src="https://habrastorage.org/webt/wr/gh/sa/wrghsafmpp3qz3fiih1afdkrrou.png"></p><br><p>  Perlu dipertimbangkan bahwa pengguna tidak akan dapat berinteraksi dengan tombol, pengguliran dan kontrol lain pada tampilan Anda, karena metode ini disebut dengan parameter <code>interactiveBehavior = .none</code> , ini tentu saja memberlakukan sejumlah batasan. </p><br><h3 id="itogo-1">  Total </h3><br><p>  Pintasan berbasis <code>Intent</code> dapat di-render di antarmuka siri atau di pusat notifikasi dan melakukan tindakan tanpa membuka aplikasi.  Untuk membuatnya, Anda perlu: </p><br><ol><li>  Aktifkan <strong>Kemampuan</strong> untuk Menggunakan Siri </li><li>  Buat <strong>Intents Extensions</strong> dan <strong>Intents Extensions UI</strong> </li><li>  Buat <strong>File Definisi Intensi SiriKit</strong> </li><li>  Kami membuat <code>Intent</code> kami di file ini dan menetapkan parameter untuknya. </li><li>  Buat <code>IntentHandler</code> tempat kami menerapkan metode <code>confirm</code> dan <code>hanlde</code> </li></ol><br><h2 id="rekomendacii">  Rekomendasi </h2><br><h3 id="obschiy-kod-v-targete-rasshirenii-siri-i-v-osnovnom-prilozhenii">  Kode generik dalam target ekstensi Siri dan aplikasi utama </h3><br><p>  Jika Anda memiliki kode yang digunakan di target untuk Siri dan di target proyek utama - ada 2 cara untuk mengatasi masalah ini: </p><br><ol><li>  Sorot kelas umum menambahkannya ke kedua target.  ( <strong>Lihat ‚Üí Utilites ‚Üí Tampilkan Inspektur File</strong> , di bagian <strong>Keanggotaan Target</strong> tambahkan tanda centang ke target yang membutuhkan akses ke file yang dipilih) </li><li>  Buat satu atau beberapa kerangka kerja target dan ambil kode umum di sana. </li></ol><br><p>  Metode yang terakhir lebih disukai, karena Anda kemudian dapat menggunakan kerangka kerja ini di ekstensi dan proyek lain.  Perlu juga dicatat bahwa untuk kerangka kerja ini disarankan untuk menetapkan bendera <code>Allow app extension API only</code> , kemudian, ketika mengembangkan kerangka kerja, kompiler akan bersumpah jika Anda mencoba menggunakan API yang ilegal dalam mengembangkan ekstensi (misalnya, <code>UIApplication</code> ). </p><br><p>  Sumber daya bersama dapat digeledah antara target melalui <strong>Grup Aplikasi</strong> </p><br><h3 id="otladka">  Debugging </h3><br><p>  Menguji pintasan akan membantu untuk membantu: </p><br><ol><li>  <strong>Pengaturan</strong> telepon <strong>Pengaturan ‚Üí Pengembang</strong> : <strong>Menampilkan Pintasan Terbaru</strong> dan <strong>Menampilkan Sumbangan pada</strong> sakelar <strong>Layar Kunci</strong> : </li></ol><br><p><img src="https://habrastorage.org/webt/lv/0s/v8/lv0sv8rxfrdw7tgeqaql7p9yyhy.png"></p><br><ol><li>  Untuk menguji Intens, Anda dapat segera meluncurkan ekstensi target dengan menentukan dalam Xcode frase yang dibuka dengan Siri.  Untuk melakukan ini, pilih skema untuk ekstensi target Siri </li></ol><br><p><img src="https://habrastorage.org/webt/lc/lf/vj/lclfvj0e18-jx73zrxkf0tasnyq.png"></p><br><p>  Klik pada target ini, klik <strong>Edit Skema ...</strong> </p><br><p><img src="https://habrastorage.org/webt/de/fq/8n/defq8nu0ptzrcaib4bcbwrpfa0k.png"></p><br><p>  Di bidang <strong>Siri Intent Query</strong> , masukkan frasa yang Siri akan memulai, seolah-olah Anda sudah mengatakannya. </p><br><h2 id="itogo-2">  Total </h2><br><p>  Saya mengusulkan untuk berhenti dan merangkum apa yang kami lakukan: </p><br><ol><li>  Pintasan dapat dibuat melalui <code>NSUserActivity</code> , atau melalui <code>INIntent</code> </li><li>  Pintasan perlu dinyatakan (dinyatakan), dilaporkan ke sistem (donasi), dan diproses (ditangani). </li><li>  Anda dapat menambahkan tombol " <em>Tambahkan ke Siri</em> " ke aplikasi, dengan mengklik di mana pengguna dapat menambahkan frasa untuk tindakan dan selanjutnya menyebutnya dengan suaranya. </li><li>  Anda dapat membuat <code>Intents</code> Anda sendiri di samping built-in. </li><li>  Melalui <code>Intents</code> berbasis Intents <code>Intents</code> Anda dapat membuat tindakan yang akan dilakukan melalui antarmuka Siri (baik pada layar yang terkunci atau dalam pencarian) tanpa perlu membuka aplikasi itu sendiri. </li></ol><br><p>  Dalam dokumentasi Apple ada tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek Demo</a> , yang berguna untuk mengunduh dan memfokuskannya selama pengembangan. </p><br><p>  Saya ingin menekankan bahwa pada saat penulisan artikel ini adalah API pada tahap <code>beta</code> .  Dan saya sering mengalami masalah dan bug.  Selama bekerja, saya secara berkala menemukan hal-hal berikut: </p><br><ul><li>  ,  Intent  Siri,  . </li><li>   Siri     . </li><li>        Siri. </li></ul><br><h2 id="ssylki">  Referensi </h2><br><ol><li> WWDC 2018, session 211: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Introduction to Siri Shortcuts</a> </li><li> WWDC 2018, session 214: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Building for Voice with Siri Shortcuts</a> </li><li> Apple Developer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SiriKit</a> </li><li> Apple Developer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">INUIHostedViewControlling</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Demo  <strong><em>Soup Chef</em></strong>  Apple</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414677/">https://habr.com/ru/post/id414677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414663/index.html">Kelelahan profesional: sepatah kata untuk para ahli</a></li>
<li><a href="../id414667/index.html">[Mini fan theme] Tabel kejuaraan FIFA di terminal</a></li>
<li><a href="../id414669/index.html">Pengembangan analisa statis baru: PVS-Studio Java</a></li>
<li><a href="../id414673/index.html">Tidak lagi Abibas: keajaiban teknologi China</a></li>
<li><a href="../id414675/index.html">Karier Manajer TI: Dari Baris Perintah ke Kerja Tim</a></li>
<li><a href="../id414679/index.html">Box-shadows.css</a></li>
<li><a href="../id414683/index.html">Kisah menciptakan aplikasi seluler untuk anak-anak yang memungkinkan Anda mendapatkan uang dengan pikiran Anda. Lanjutan</a></li>
<li><a href="../id414687/index.html">Cara mengelola tim dan diri Anda sendiri: 15 buku untuk manajer proyek</a></li>
<li><a href="../id414689/index.html">Buka pelajaran "Aplikasi Web dan Layanan Mikro di Spring Boot 2.0"</a></li>
<li><a href="../id414691/index.html">Latar belakang YouTube Music dan YouTube Premium: apa itu dan bagaimana perbedaannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>