<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÄ ‚ö´Ô∏è ü§∞üèæ Sobre el modelo de red en juegos para principiantes üèõÔ∏è üê∏ üéôÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante las √∫ltimas dos semanas he estado trabajando en un motor de red para mi juego. Antes de eso, no sab√≠a nada sobre las tecnolog√≠as de red en los...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sobre el modelo de red en juegos para principiantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467025/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/de3/6bb/69ede36bb7e48411280ffad409751c0d.png" alt="imagen"></div><br>  Durante las √∫ltimas dos semanas he estado trabajando en un motor de red para mi juego.  Antes de eso, no sab√≠a nada sobre las tecnolog√≠as de red en los juegos, as√≠ que le√≠ muchos art√≠culos y realic√© muchos experimentos para comprender todos los conceptos y poder escribir mi propio motor de red. <br><br>  En esta gu√≠a, me gustar√≠a compartir contigo varios conceptos que debes aprender antes de escribir tu propio motor de juego, as√≠ como los mejores recursos y art√≠culos para aprenderlos. <br><br>  En general, hay dos tipos principales de arquitecturas de red: punto a punto y cliente-servidor.  En la arquitectura peer-to-peer (p2p), los datos se transfieren entre cualquier par de jugadores conectados, y en la arquitectura cliente-servidor, los datos se transmiten solo entre los jugadores y el servidor. <br><br>  Aunque la arquitectura peer-to-peer todav√≠a se usa en algunos juegos, el est√°ndar es cliente-servidor: es m√°s f√°cil de implementar, requiere un ancho de canal m√°s peque√±o y facilita la protecci√≥n contra las trampas.  Por lo tanto, en esta gu√≠a, nos centraremos en la arquitectura cliente-servidor. <br><a name="habracut"></a><br>  En particular, estamos m√°s interesados ‚Äã‚Äãen servidores autoritarios: en tales sistemas, el servidor siempre tiene la raz√≥n.  Por ejemplo, si un jugador piensa que est√° en coordenadas (10, 5), y el servidor le dice que est√° en (5, 3), entonces el cliente debe reemplazar su posici√≥n con la transmitida por el servidor, y no al rev√©s.  El uso de servidores autoritarios facilita el reconocimiento de los tramposos. <br><br>  Hay tres componentes principales para los sistemas de red de juegos: <br><br><ul><li>  Protocolo de transporte: c√≥mo se transfieren los datos entre los clientes y el servidor. </li><li>  Protocolo de aplicaci√≥n: qu√© se transfiere de los clientes al servidor y del servidor a los clientes y en qu√© formato. </li><li>  L√≥gica de la aplicaci√≥n: c√≥mo se utilizan los datos transmitidos para actualizar el estado de los clientes y el servidor. </li></ul><br>  Es muy importante comprender el papel de cada parte y las dificultades asociadas con ellas. <br><br><h1>  Protocolo de transporte </h1><br>  El primer paso es elegir un protocolo para transportar datos entre el servidor y los clientes.  Hay dos protocolos de Internet para esto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TCP</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UDP</a> .  Pero puede crear su propio protocolo de transporte basado en uno de ellos o usar la biblioteca en la que se usan. <br><br><h2>  Comparaci√≥n de TCP y UDP </h2><br>  Tanto TCP como UDP est√°n basados ‚Äã‚Äãen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IP</a> .  IP le permite transferir un paquete desde la fuente al destinatario, pero no garantiza que el paquete enviado tarde o temprano llegue al destinatario, que lo alcanzar√° al menos una vez y que la secuencia de paquetes llegar√° en el orden correcto.  Adem√°s, un paquete puede contener solo un tama√±o de datos limitado especificado por el valor de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MTU</a> . <br><br>  UDP es solo una capa delgada sobre IP.  Por lo tanto, tiene las mismas limitaciones.  En contraste, TCP tiene muchas caracter√≠sticas.  Proporciona una conexi√≥n confiable y ordenada entre dos nodos con comprobaci√≥n de errores.  Por lo tanto, TCP es muy conveniente y se usa en muchos otros protocolos, por ejemplo, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HTTP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FTP</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SMTP</a> .  Pero todas estas caracter√≠sticas tienen un precio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>retraso</em></a> . <br><br>  Para comprender por qu√© estas funciones pueden causar un retraso, debe comprender c√≥mo funciona TCP.  Cuando el nodo emisor reenv√≠a el paquete al nodo receptor, espera recibir un acuse de recibo (ACK).  Si despu√©s de cierto tiempo no lo recibe (porque se perdi√≥ el paquete o la confirmaci√≥n, o por alguna otra raz√≥n), reenv√≠a el paquete.  Adem√°s, TCP garantiza que los paquetes se reciban en el orden correcto, por lo tanto, hasta que se reciba un paquete perdido, todos los dem√°s paquetes no pueden procesarse, incluso si ya han sido recibidos por el nodo receptor. <br><br>  Pero como probablemente entiendas, la demora en los juegos multijugador es muy importante, especialmente en g√©neros tan activos como FPS.  Es por eso que muchos juegos usan UDP con su propio protocolo. <br><br>  Un protocolo nativo basado en UDP puede ser m√°s eficiente que TCP por varias razones.  Por ejemplo, puede marcar algunos paquetes como confiables y otros como no confiables.  Por lo tanto, no le importa si el paquete no confiable lleg√≥ al receptor.  O puede procesar varias secuencias de datos para que un paquete perdido en una secuencia no ralentice las secuencias restantes.  Por ejemplo, puede haber una transmisi√≥n para la entrada del jugador y otra transmisi√≥n para mensajes de chat.  Si se pierde un mensaje de chat que no es informaci√≥n urgente, no ralentizar√° la entrada, lo cual es urgente.  O bien, un protocolo propietario puede implementar la confiabilidad de manera diferente que en TCP para ser m√°s eficiente en los videojuegos. <br><br>  Entonces, si TCP es tan malo, ¬øcrearemos nuestro propio protocolo de transporte basado en UDP? <br><br>  Todo es un poco m√°s complicado.  Aunque el TCP es casi sub√≥ptimo para los sistemas en red de juegos, puede funcionar bien en su juego y ahorrar su valioso tiempo.  Por ejemplo, el retraso puede no ser un problema para un juego por turnos o un juego que solo se puede jugar en LAN, donde hay mucho menos retrasos y p√©rdida de paquetes que en Internet. <br><br>  Muchos juegos exitosos, incluidos World of Warcraft, Minecraft y Terraria, usan TCP.  Sin embargo, la mayor√≠a de los FPS utilizan protocolos patentados basados ‚Äã‚Äãen UDP, por lo que hablaremos m√°s sobre ellos a continuaci√≥n. <br><br>  Si decide usar TCP, aseg√∫rese de que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el algoritmo de Nagle est√©</a> desactivado, ya que almacena los paquetes antes de enviarlos, lo que significa que aumenta el retraso. <br><br>  Para obtener m√°s informaci√≥n sobre las diferencias entre UDP y TCP en el contexto de los juegos multijugador, puede leer el art√≠culo de Glenn Fiedler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823015049/"><em>UDP vs.</em></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823015049/"><em>TCP</em></a> <br><br><h2>  Protocolo propio </h2><br>  Entonces, ¬ødesea crear su propio protocolo de transporte, pero no sabe por d√≥nde empezar?  Tienes suerte, porque Glenn Fiedler escribi√≥ dos art√≠culos incre√≠bles sobre esto.  Encontrar√°s muchos pensamientos inteligentes en ellos. <br><br>  El primer art√≠culo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823012240/"><em>Networking for Game Programmers</em></a> 2008, es m√°s simple que el segundo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823014904/"><em>Building A Game Network Protocol</em></a> 2016.  Te recomiendo que comiences con una m√°s antigua. <br><br>  Tenga en cuenta que Glenn Fiedler es un gran defensor del uso de su propio protocolo UDP.  Y despu√©s de leer sus art√≠culos, seguramente superar√° su opini√≥n de que TCP tiene serios inconvenientes en los videojuegos, y desea implementar su propio protocolo. <br><br>  Pero si eres nuevo en redes, hazte un favor y usa TCP o una biblioteca.  Para implementar con √©xito su propio protocolo de transporte, primero debe aprender mucho. <br><br><h2>  Bibliotecas de red </h2><br>  Si necesita algo m√°s eficiente que TCP, pero no quiere molestarse en implementar su propio protocolo y entrar en muchos detalles, puede usar la biblioteca de red.  Hay muchos de ellos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">yojimbo</a> Glenn Fiedler </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RakNet</a> , que ya no es compatible, pero su bifurcaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SLikeNet</a> parece estar todav√≠a activa. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ENet</a> es una biblioteca creada para el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cubo</a> FPS multiusuario </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Juego de Valvulas</a> </li></ul><br>  No los he probado todos, pero prefiero ENet, porque es f√°cil de usar y confiable.  Adem√°s, ella tiene documentaci√≥n clara y un tutorial para principiantes. <br><br><h2>  Protocolo de transporte: conclusi√≥n </h2><br>  Para resumir: hay dos protocolos principales de transporte: TCP y UDP.  TCP tiene muchas caracter√≠sticas √∫tiles: confiabilidad, orden de paquetes, detecci√≥n de errores.  UDP no tiene todo esto, pero TCP, por su naturaleza, ha aumentado los retrasos que son inaceptables para algunos juegos.  Es decir, para garantizar bajas latencias, puede crear su propio protocolo basado en UDP o utilizar una biblioteca que implemente el protocolo de transporte UDP y que est√© adaptada para videojuegos para m√∫ltiples jugadores. <br><br>  La elecci√≥n entre TCP, UDP y la biblioteca depende de varios factores.  En primer lugar, seg√∫n las necesidades del juego: ¬ønecesita bajas latencias?  En segundo lugar, a partir de los requisitos del protocolo de aplicaci√≥n: ¬ønecesita un protocolo confiable?  Como veremos en la siguiente parte, puede crear un protocolo de aplicaci√≥n para el cual un protocolo poco confiable es bastante adecuado.  Finalmente, tambi√©n debe tener en cuenta la experiencia del desarrollador del motor de red. <br><br>  Tengo dos consejos: <br><br><ul><li>  Maximice el protocolo de transporte del resto de la aplicaci√≥n para que pueda reemplazarse f√°cilmente sin tener que volver a escribir todo el c√≥digo. </li><li>  No hagas una optimizaci√≥n prematura.  Si no es un especialista en redes y no est√° seguro de si necesita su propio protocolo de transporte basado en UDP, puede comenzar con TCP o una biblioteca que brinde confiabilidad, y luego probar y medir el rendimiento.  Si tiene problemas y est√° seguro de que la raz√≥n radica en el protocolo de transporte, quiz√°s haya llegado el momento de crear su propio protocolo de transporte. </li></ul><br>  Al final de esta parte, le recomiendo que lea la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20190519135537/"><em>Introducci√≥n a la programaci√≥n de juegos multijugador de</em></a> Brian Hook, que cubre muchos de los temas discutidos aqu√≠. <br><br><h1>  Protocolo de aplicaci√≥n </h1><br>  Ahora que podemos intercambiar datos entre clientes y el servidor, debemos decidir qu√© datos transferir y en qu√© formato. <br><br>  El esquema cl√°sico es que los clientes env√≠an entradas o acciones al servidor, y el servidor env√≠a el estado actual del juego a los clientes. <br><br>  El servidor no env√≠a un estado completo, pero filtrado, con entidades que est√°n al lado del jugador.  Lo hace por tres razones.  Primero, el estado general puede ser demasiado grande para la transmisi√≥n de alta frecuencia.  En segundo lugar, los clientes est√°n interesados ‚Äã‚Äãprincipalmente en datos visuales y de audio, porque la mayor parte de la l√≥gica del juego se simula en el servidor del juego.  En tercer lugar, en algunos juegos el jugador no necesita conocer ciertos datos, por ejemplo, la posici√≥n del oponente en el otro extremo del mapa, porque de lo contrario puede oler paquetes y saber exactamente d√≥nde moverse para matarlo. <br><br><h2>  Serializaci√≥n </h2><br>  El primer paso es convertir los datos que queremos enviar (entrada o estado del juego) a un formato adecuado para la transmisi√≥n.  Este proceso se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>serializaci√≥n</em></a> . <br><br>  La idea viene inmediatamente a la mente para usar un formato legible por humanos, como JSON o XML.  Pero ser√° completamente ineficaz y en vano ocupar√° la mayor parte del canal. <br><br>  En cambio, se recomienda que utilice un formato binario que sea mucho m√°s compacto.  Es decir, los paquetes contendr√°n solo unos pocos bytes.  Aqu√≠ debe considerar el problema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>del orden de bytes</em></a> , que puede diferir en diferentes computadoras. <br><br>  Puede usar una biblioteca para serializar datos, por ejemplo: <br><br><ul><li>  Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FlatBuffers</a> </li><li>  Tormenta de arena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap'n Proto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cereal de</a> Shane Grant y Randolph Voorhees </li></ul><br>  Solo aseg√∫rese de que la biblioteca cree archivos port√°tiles y se encargue del orden de los bytes. <br><br>  Una soluci√≥n independiente puede ser una implementaci√≥n independiente, no es particularmente complicada, especialmente si utiliza un enfoque orientado a datos en el c√≥digo.  Adem√°s, le permitir√° realizar optimizaciones que no siempre son posibles al usar la biblioteca. <br><br>  Glenn Fiedler ha escrito dos art√≠culos sobre serializaci√≥n: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823004533/"><em>paquetes de lectura y escritura</em></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823015044/"><em>estrategias de serializaci√≥n</em></a> . <br><br><h2>  Compresi√≥n </h2><br>  La cantidad de datos transferidos entre los clientes y el servidor est√° limitada por el ancho de banda del canal.  La compresi√≥n de datos le permite transferir m√°s datos en cada instant√°nea, aumentar la frecuencia de actualizaci√≥n o simplemente reducir los requisitos del canal. <br><br><h3>  Poco de embalaje </h3><br>  La primera t√©cnica es un poco de embalaje.  Consiste en usar exactamente el n√∫mero de bits que es necesario para describir el valor deseado.  Por ejemplo, si tiene una enumeraci√≥n que puede tener 16 valores diferentes, en lugar de un byte completo (8 bits), puede usar solo 4 bits. <br><br>  Glenn Fiedler explica c√≥mo implementar esto en la segunda parte del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823004533/"><em>Paquetes de lectura y escritura</em></a> . <br><br>  El empaque de bits funciona especialmente bien con el muestreo, que ser√° el tema de la pr√≥xima secci√≥n. <br><br><h3>  Discreci√≥n </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>La discretizaci√≥n</em></a> es una t√©cnica de compresi√≥n con p√©rdida que usa solo un subconjunto de los valores posibles para codificar un valor.  La forma m√°s f√°cil de implementar la discretizaci√≥n es redondear los n√∫meros de coma flotante. <br><br>  Glenn Fiedler (¬°otra vez!) Muestra c√≥mo aplicar el muestreo en la pr√°ctica en su art√≠culo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823021121/">Compresi√≥n de instant√°neas</a> . <br><br><h3>  Algoritmos de compresi√≥n </h3><br>  La siguiente t√©cnica ser√°n los algoritmos de compresi√≥n sin p√©rdidas. <br><br>  Aqu√≠, en mi opini√≥n, los tres algoritmos m√°s interesantes que necesita saber: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Codificaci√≥n de Huffman</a> con c√≥digo precalculado que es extremadamente r√°pido y puede dar buenos resultados.  Se us√≥ para comprimir paquetes en el motor de red Quake3. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">zlib</a> es un algoritmo de compresi√≥n de prop√≥sito general que nunca aumenta la cantidad de datos.  Como se puede ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , se ha utilizado en muchas aplicaciones.  Puede ser redundante actualizar estados.  Pero puede ser √∫til si necesita enviar activos, textos largos o ayuda a los clientes desde el servidor. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copiar longitudes de series</a> es probablemente el algoritmo de compresi√≥n m√°s simple, pero es muy efectivo para ciertos tipos de datos y puede usarse como un paso de preprocesamiento antes de zlib.  Es especialmente adecuado para comprimir terrenos que consisten en azulejos o v√≥xeles, en los que se repiten muchos elementos vecinos. </li></ul><br><h3>  Compresi√≥n Delta </h3><br>  La √∫ltima t√©cnica de compresi√≥n es la compresi√≥n delta.  Se basa en el hecho de que solo se transmiten las diferencias entre el estado actual del juego y el √∫ltimo estado recibido por el cliente. <br><br>  Se utiliz√≥ por primera vez en el motor de red Quake3.  Aqu√≠ hay dos art√≠culos que explican c√≥mo usarlo: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20190628180906/"><em>El modelo de red Quake3 de</em></a> Brian Hook </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Revisi√≥n del C√≥digo Fuente del</em></a> Terremoto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>3: Modelo de red</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n del</a> art√≠culo sobre Habr√©, ver la secci√≥n "Modelo de red"] </li></ul><br>  Glenn Fiedler tambi√©n lo us√≥ en la segunda parte de su art√≠culo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823021121/"><em>Compresi√≥n de instant√°neas</em></a> . <br><br><h2>  Cifrado </h2><br>  Adem√°s, es posible que deba cifrar la transferencia de informaci√≥n entre los clientes y el servidor.  Hay varias razones para esto: <br><br><ul><li>  privacidad / confidencialidad: los mensajes solo pueden ser le√≠dos por el destinatario, y ninguna otra persona que detecte la red puede leerlos. </li><li>  autenticaci√≥n: una persona que quiere desempe√±ar el papel de un jugador debe conocer su clave. </li><li>  prevenci√≥n de trampas: ser√° mucho m√°s dif√≠cil para los jugadores maliciosos crear sus propios paquetes de trampas, tendr√°n que jugar el esquema de cifrado y encontrar la clave (que cambia con cada conexi√≥n). </li></ul><br>  Recomiendo usar la biblioteca para esto.  Sugiero usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libsodium</a> porque es especialmente simple y tiene excelentes tutoriales.  De particular inter√©s es el tutorial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intercambio de claves</a> , que le permite generar nuevas claves con cada nueva conexi√≥n. <br><br><h2>  Protocolo de aplicaci√≥n: conclusi√≥n </h2><br>  Terminaremos con el protocolo de aplicaci√≥n.  Creo que la compresi√≥n es completamente opcional y la decisi√≥n de usarla depende solo del juego y del ancho de banda requerido.  El cifrado, en mi opini√≥n, es obligatorio, pero en el primer prototipo puedes hacerlo sin √©l. <br><br><h1>  L√≥gica de aplicaci√≥n </h1><br>  Ahora podemos actualizar el estado en el cliente, pero podemos encontrar problemas con demoras.  Una vez ingresado, el jugador debe esperar la actualizaci√≥n del estado del juego desde el servidor para ver qu√© impacto tuvo en el mundo. <br><br>  Adem√°s, entre dos actualizaciones de estado, el mundo es completamente est√°tico.  Si la frecuencia de actualizaci√≥n de los estados es baja, entonces los movimientos ser√°n muy nerviosos. <br><br>  Existen varias t√©cnicas para reducir el impacto de este problema, y ‚Äã‚Äãen la siguiente secci√≥n hablar√© sobre ellas. <br><br><h2>  T√©cnicas de suavizado diferido </h2><br>  Todas las t√©cnicas descritas en esta secci√≥n se analizan en detalle en la serie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Multijugador de ritmo r√°pido</em></a> de Gabriel Gambetta.  Recomiendo leer esta gran serie de art√≠culos.  Tambi√©n tiene una demostraci√≥n interactiva que le permite ver c√≥mo funcionan estas t√©cnicas en la pr√°ctica. <br><br>  La primera t√©cnica es aplicar la entrada directamente, sin esperar una respuesta del servidor.  Esto se llama <em>predicci√≥n del lado del cliente</em> .  Sin embargo, cuando el cliente recibe la actualizaci√≥n del servidor, debe asegurarse de que su pron√≥stico sea correcto.  Si esto no es as√≠, entonces solo necesita cambiar su estado de acuerdo con el recibido del servidor, porque el servidor es autoritario.  Esta t√©cnica se us√≥ por primera vez en Quake.  Puede leer m√°s al respecto en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Revisi√≥n del c√≥digo de Quake Engine por</em></a> Fabien Sanglar [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> al Habr√©]. <br><br>  El segundo conjunto de t√©cnicas se utiliza para suavizar el movimiento de otras entidades entre dos actualizaciones de estado.  Hay dos formas de resolver este problema: interpolaci√≥n y extrapolaci√≥n.  En el caso de la interpolaci√≥n, se toman los dos √∫ltimos estados y se muestra la transici√≥n de uno a otro.  Su desventaja es que causa una peque√±a fracci√≥n de la demora, porque el cliente siempre ve lo que sucedi√≥ en el pasado.  La extrapolaci√≥n predice d√≥nde las entidades ahora deber√≠an basarse en el √∫ltimo estado recibido por el cliente.  Su desventaja es que si la entidad cambia completamente la direcci√≥n del movimiento, entonces habr√° un gran error entre el pron√≥stico y la posici√≥n real. <br><br>  La √∫ltima t√©cnica m√°s avanzada, √∫til solo en FPS es la <em>compensaci√≥n de retraso</em> .        ,     . ,       ,      -     ,           - .      ,   ,   ,  ,      ,        . <br><br>   ( !)   2004   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823005028/"><em>Network Physics (2004)</em></a> ,           .  2014       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823004853/"><em>Networking Physics</em></a> ,         . <br><br>   wiki  Valve   , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Source Multiplayer Networking</em></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization</em></a>     . <br><br><h2>   </h2><br>      . <br><br> :     .   ,      . <br><br> :      //.         ,    .               . <br><br><h2>  :  </h2><br>           ,          ,         .       . <br><br><h1>    </h1><br>      ,   ,     : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20190328001900/">  </a> ‚Äî     ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20180823014743/"></a>      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Awesome Game Networking</a>  M. Fatih MAR ‚Äî          . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki  r/gamedev</a>     . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467025/">https://habr.com/ru/post/467025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467015/index.html">JWT: ataque de firma digital frente a ataque MAC</a></li>
<li><a href="../467017/index.html">¬øQu√© es HED / MRSD y para qu√© sirve?</a></li>
<li><a href="../467019/index.html">Dise√±o de paneles de control para el sitio de comercio electr√≥nico de an√°lisis web. Parte 3: Canal SEO</a></li>
<li><a href="../467021/index.html">C√≥mo se comunica el robot de conciencia con los clientes</a></li>
<li><a href="../467023/index.html">Creamos un complemento en Grafana para monitorear k8s: ya en la tienda oficial de Grafana</a></li>
<li><a href="../467029/index.html">Grigory Petrov: trabajando con una red en Ruby</a></li>
<li><a href="../467033/index.html">Una selecci√≥n de documentos t√©cnicos geniales de Chaos Communication Camp 2019</a></li>
<li><a href="../467035/index.html">Dise√±o de paneles de control para el sitio de comercio electr√≥nico de an√°lisis web. Parte 4: Canal de Youtube</a></li>
<li><a href="../467037/index.html">Factoring: c√≥mo obtener dinero para sillas</a></li>
<li><a href="../467039/index.html">C√≥mo realizar una revisi√≥n de c√≥digo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>