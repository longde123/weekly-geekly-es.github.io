<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåüèº üéá ü•™ Schreiben eines weiteren Kubernetes-Template-Tools üç± ü¶Ö üëã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie mit der Kubernetes-Umgebung arbeiten, verwenden Sie wahrscheinlich mehrere vorhandene Vorlagen-Tools, von denen einige Teil von Paketmanagern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben eines weiteren Kubernetes-Template-Tools</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437682/"><p><img src="https://habrastorage.org/webt/hj/xp/t7/hjxpt7lglfmyiz9ut7xcy2ndpl4.png"></p><br><p>  Wenn Sie mit der Kubernetes-Umgebung arbeiten, verwenden Sie wahrscheinlich mehrere vorhandene Vorlagen-Tools, von denen einige Teil von Paketmanagern wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ksonnet</a> sind oder nur Vorlagen-Sprachen (Jinja2, Go-Vorlage usw.).  Alle haben ihre eigenen Nachteile und Vorteile, und wir werden sie durchgehen und unser eigenes Tool schreiben, das versucht, die besten Funktionen zu kombinieren. </p><a name="habracut"></a><br><h2 id="so-why-not-helm">  Warum also nicht Helm? </h2><br><p> Es gibt eine Reihe von Artikeln, die Helm kritisieren (z. B. nur einen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberlegen Sie zweimal, bevor Sie Helm verwenden</a> ).  Das Hauptproblem bei Helm ist, dass es mit <em>Zeichenfolgendarstellungen</em> funktioniert und Kubernetes-Manifeste <em>(json) Objekte sind</em> .  Die wahre H√∂lle f√ºr einen Helm-Diagrammentwickler beginnt, wenn er <code>yaml</code> f√ºr ein <code>yaml</code> Manifest berechnen <code>yaml</code> . Manchmal sieht es so aus (es ist ein echtes Beispiel aus meinem Diagramm): </p><br><pre> <code class="plaintext hljs">spec: jobTemplate: spec: template: spec: containers: - name: my-awesome-container resources: {{ toYaml .Values.resources | indent 14 }}</code> </pre> <br><p><img src="https://habrastorage.org/webt/oh/iw/cz/ohiwczwzpduep0hfxrghx0xtook.jpeg"></p><br><p>  Aber Helm ist heute de facto der Standard f√ºr Kubernetes-Anwendungsverpackungen.  Der Hauptvorteil von Helm ist eine gro√üe Community und eine gro√üe Anzahl √∂ffentlicher Repositories mit Diagrammen.  Und k√ºrzlich haben Helm-Entwickler einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm-Hub</a> angek√ºndigt.  Helm ist heute wie Docker - es ist nicht der einzige, aber es hat Gemeinschaft und Unterst√ºtzung. </p><br><p>  Es gibt vielversprechende √Ñnderungen mit der Ver√∂ffentlichung von Helm 3, aber niemand wei√ü, wann es sein k√∂nnte. </p><br><p>  Abschlie√üend Helm Vorteile: </p><br><ul><li>  Gro√üe Community und eine Reihe von √∂ffentlichen Charts </li><li>  (Relativ) menschenfreundliche Syntax.  Zumindest ist es yaml + go template;) </li></ul><br><p>  Nachteile: </p><br><ul><li>  Arbeiten mit Zeichenfolgen und nicht mit Objekten </li><li>  Begrenzte Anzahl von Operatoren und Funktionen, die Sie verwenden k√∂nnen </li></ul><br><h2 id="ok-then-maybe-ksonnet">  OK, dann vielleicht Ksonnet? </h2><br><p>  Wenn Sie Helm mit Ksonnet vergleichen, hat letzteres einen gro√üen Vorteil, n√§mlich, dass es mit Objekten funktioniert.  Ksonnet ist ein Tool, das auf der JSON-Vorlagensprache Jsonnet basiert.  Ein weiteres cooles Feature von Ksonnet ist, dass es Kubernetes-API-kompatible Jsonnet-Bibliotheken enth√§lt, die Sie in Ihre Vorlage importieren und mit Kubernetes-Objekten wie in jeder OOP-Sprache arbeiten k√∂nnen: </p><br><pre> <code class="json hljs">local k = import <span class="hljs-string"><span class="hljs-string">"k.libsonnet"</span></span>; local deployment = k.apps.v<span class="hljs-number"><span class="hljs-number">1</span></span>beta<span class="hljs-number"><span class="hljs-number">1</span></span>.deployment; local appDeployment = deployment .new( params.name, params.replicas, container .new(params.name, params.image) .withPorts(containerPort.new(targetPort)), labels);</code> </pre> <br><p>  Sieht beeindruckend aus, nicht wahr? <br>  Es ist etwas weniger ordentlich, wenn Sie nicht mit API-Objekten arbeiten, sondern nur mit <code>yaml</code> Objekten, die aus der <code>yaml</code> / <code>json</code> Datei importiert wurden: </p><br><pre> <code class="json hljs">{ global: {}, components: { <span class="hljs-attr"><span class="hljs-attr">"deployment-nginx-deployment-dkecx"</span></span>+: { spec+: { replicas: <span class="hljs-number"><span class="hljs-number">10</span></span>, template+: { spec+: { containers+: [ { name: <span class="hljs-string"><span class="hljs-string">"nginx"</span></span>, image: <span class="hljs-string"><span class="hljs-string">"nginx:latest"</span></span>, ports: [ { containerPort: <span class="hljs-number"><span class="hljs-number">80</span></span>, }, ], }, ], }, }, }, }, }, }</code> </pre> <br><p>  Aber es ist immer noch etwas und es ist besser als mit Saiten in Helm zu arbeiten.  Der Nachteil von Ksonnet ist, dass es eine kleinere Community und weniger Pakete als Helm hat (obwohl Sie Helm-Diagramme in Ihr Ksonnet-Projekt importieren k√∂nnen, aber Sie werden mit ihnen als json-Objekte arbeiten, nicht als jsonnet-Bibliotheksobjekte).  Und aufgrund einer kleineren Community und eines kleineren Beitrags fehlen einige Funktionen, wenn Sie versuchen, Ihr eigenes Diagramm zu schreiben.  Eine davon habe ich selbst erlebt: Sie wissen, dass Sie in Helm eine <code>ConfigMap</code> aus einem Verzeichnis <code>ConfigMap</code> k√∂nnen, das eine Reihe von Konfigurationsdateien enth√§lt: </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: ConfigMap metadata: name: conf data: {{- (.Files.Glob "foo/*").AsConfig | nindent 2 }}</code> </pre> <br><p>  Sie k√∂nnen sich meine Frustration vorstellen, als ich herausfand, dass es in Ksonnet keine solche Funktion gibt.  Es gibt jedoch Problemumgehungen.  Aber der Punkt ist, dass es nur ein Beispiel f√ºr die Situation ist, in der Sie gl√ºcklich Ihr Diagramm schreiben und dann pl√∂tzlich ein Mangel an einer Funktion Sie auf halbem Weg aufh√§lt. <br>  Insgesamt Vorteile von Ksonnet: </p><br><ul><li>  Arbeiten mit Objekten </li><li>  Kubernetes-API-kompatible Jsonnet-Bibliotheken </li><li>  Unterst√ºtzung f√ºr den Import von Helmdiagrammen </li></ul><br><p>  Nachteile: </p><br><ul><li>  Kleinere Community und geringere Anzahl von Ksonnet-nativen Paketen </li><li>  Fehlende Funktionen, die Sie in Helm verwenden k√∂nnen </li><li>  Neue Syntax =&gt; erh√∂hte Lernzeit =&gt; erh√∂hter Busfaktor </li><li>  Syntax kann manchmal h√§sslich und weniger lesbar werden (insbesondere, wenn Problemumgehungen f√ºr fehlende Funktionen vorgenommen werden). </li></ul><br><h2 id="lets-think-of-an-ideal-templating-tool">  Stellen wir uns ein ideales Vorlagenwerkzeug vor </h2><br><p>  Hier sind einige Kriterien f√ºr das "ideale" Vorlagenwerkzeug: </p><br><ul><li>  Es sollte mit Objekten funktionieren, nicht mit Strings </li><li>  Es sollte in der Lage sein, mit Kubernetes-API-kompatiblen Objekten zu arbeiten </li><li>  Es sollte einen anst√§ndigen Satz von Funktionen f√ºr die Arbeit mit Strings haben </li><li>  Es sollte gut mit json- und yaml-Formaten funktionieren </li><li>  Es sollte menschenfreundlich sein </li><li>  Es sollte einfach sein </li><li>  Es sollte die M√∂glichkeit haben, vorhandene Helm-Diagramme zu importieren (da dies Realit√§t ist und wir die Helm-Community nutzen m√∂chten). </li></ul><br><p>  Das reicht f√ºrs Erste.  Ich ging diese Liste in meinem Kopf durch und dachte mir: Okay, warum nicht Python ausprobieren?  Mal sehen, ob es unseren Kriterien entspricht: </p><br><ul><li>  <em>Arbeiten Sie mit Objekten, nicht mit Zeichenfolgen</em> .  Ja, wir k√∂nnen daf√ºr <code>dict</code> und <code>dict</code> verwenden. </li><li>  <em>Sie k√∂nnen mit Kubernetes-API-kompatiblen Objekten arbeiten</em> .  Ja, <code>from kubernetes import client</code> </li><li>  <em>Haben Sie einen anst√§ndigen Satz von Funktionen f√ºr die Arbeit mit Zeichenfolgen</em> .  Viel! </li><li>  <em>Arbeiten Sie gut mit den Formaten json und yaml</em> .  Sehr sch√∂n. </li><li>  <em>Menschenfreundlich</em>  Keine Schei√üe. </li><li>  <em>Einfach</em>  Ja </li><li>  <em>M√∂glichkeit zum Importieren vorhandener Helmdiagramme</em> .  Das werden wir uns hinzuf√ºgen. </li></ul><br><p>  Ok, sieht vielversprechend aus.  Ich habe mich entschlossen, ein einfaches Template-Tool auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Python-Client-Bibliothek f√ºr Kubernetes zu schreiben,</a> und jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">m√∂chte</a> ich Ihnen zeigen, was dabei herausgekommen ist. </p><br><h2 id="meet-karavel">  Treffen Sie Karavel </h2><br><p>  Dieses Tool ist weder besonders noch kompliziert.  Ich habe gerade die Kubernetes-Bibliothek (die mir die M√∂glichkeit gab, mit Kubernetes-Objekten zu arbeiten) genommen und einige grundlegende Funktionen f√ºr vorhandene Helm-Diagramme geschrieben (damit man sie abrufen und in ein eigenes Diagramm einf√ºgen kann).  Also, lass uns eine Tour machen. <br>  Zuallererst ist dieses Tool bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github Repo verf√ºgbar</a> und dort finden Sie ein Verzeichnis mit Beispielen. </p><br><h2 id="quick-start-with-docker-image">  Schnellstart mit Docker-Image </h2><br><p>  Wenn Sie es ausprobieren m√∂chten, verwenden Sie am einfachsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Docker-Image</a> : </p><br><pre> <code class="plaintext hljs">$ docker run greegorey/karavel -h usage: karavelcli.py [-h] subcommand ... optional arguments: -h, --help show this help message and exit list of subcommands: subcommand template generates manifests from template ensure ensure helm dependencies</code> </pre> <br><p>  Wenn Sie Diagramme vorlegen m√∂chten, m√ºssen Sie nat√ºrlich das Verzeichnis Ihres Diagramms bereitstellen: </p><br><pre> <code class="plaintext hljs">$ cd example $ docker run -v $PWD:/chart greegorey/karavel template .</code> </pre> <br><p>  Schauen wir uns also die Diagrammstruktur an.  Es ist einem von Helm sehr √§hnlich: </p><br><pre> <code class="plaintext hljs">$ cd example $ tree . . ‚îú‚îÄ‚îÄ dependencies ‚îú‚îÄ‚îÄ prod.yaml ‚îú‚îÄ‚îÄ requirements.yaml ‚îú‚îÄ‚îÄ templates ‚îÇ  ‚îú‚îÄ‚îÄ custom-resource.py ‚îÇ  ‚îú‚îÄ‚îÄ deployment.py ‚îÇ  ‚îî‚îÄ‚îÄ service-helm.py ‚îî‚îÄ‚îÄ values.yaml 2 directories, 6 files</code> </pre> <br><p>  Wie Helm hat es die Datei require.yaml mit demselben Layout: </p><br><pre> <code class="plaintext hljs">dependencies: - name: mysql version: 0.13.1 repository: https://kubernetes-charts.storage.googleapis.com/</code> </pre> <br><p>  Hier listen Sie einfach Ihre Helm-Abh√§ngigkeiten auf, die Sie in Ihr Diagramm importieren m√∂chten.  Die Abh√§ngigkeiten werden in das <code>dependencies</code> verschoben.  Verwenden Sie zum Abrufen oder Aktualisieren den Befehl verify: </p><br><pre> <code class="plaintext hljs">$ karavel ensure .</code> </pre> <br><p>  Danach sieht Ihr <code>dependencies</code> aus: </p><br><pre> <code class="plaintext hljs">$ tree dependencies dependencies ‚îî‚îÄ‚îÄ mysql-0.13.1 ‚îî‚îÄ‚îÄ mysql ‚îú‚îÄ‚îÄ Chart.yaml ‚îú‚îÄ‚îÄ README.md ‚îú‚îÄ‚îÄ templates ‚îÇ  ‚îú‚îÄ‚îÄ NOTES.txt ‚îÇ  ‚îú‚îÄ‚îÄ _helpers.tpl ‚îÇ  ‚îú‚îÄ‚îÄ configurationFiles-configmap.yaml ‚îÇ  ‚îú‚îÄ‚îÄ deployment.yaml ‚îÇ  ‚îú‚îÄ‚îÄ initializationFiles-configmap.yaml ‚îÇ  ‚îú‚îÄ‚îÄ pvc.yaml ‚îÇ  ‚îú‚îÄ‚îÄ secrets.yaml ‚îÇ  ‚îú‚îÄ‚îÄ svc.yaml ‚îÇ  ‚îî‚îÄ‚îÄ tests ‚îÇ  ‚îú‚îÄ‚îÄ test-configmap.yaml ‚îÇ  ‚îî‚îÄ‚îÄ test.yaml ‚îî‚îÄ‚îÄ values.yaml 4 directories, 13 files</code> </pre> <br><p>  Nachdem wir nun unsere Abh√§ngigkeiten sichergestellt haben, schauen wir uns die Vorlagen an.  Zun√§chst erstellen wir eine einfache Nginx-Bereitstellung: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kubernetes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> karavel.helpers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Values <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> values = Values().values <span class="hljs-comment"><span class="hljs-comment"># Configure Pod template container container = client.V1Container( name='nginx', image='{}:{}'.format(values.nginx.image.repository, values.nginx.image.tag), ports=[client.V1ContainerPort(container_port=80)]) # Create and configurate a spec section template = client.V1PodTemplateSpec( metadata=client.V1ObjectMeta(labels={'app': 'nginx'}), spec=client.V1PodSpec(containers=[container])) # Create the specification of deployment spec = client.ExtensionsV1beta1DeploymentSpec( replicas=3, template=template) # Instantiate the deployment object deployment = client.ExtensionsV1beta1Deployment( api_version='extensions/v1beta1', kind='Deployment', metadata=client.V1ObjectMeta(name='nginx-deployment'), spec=spec) return deployment # [deployment], (deployment, deployment) are valid</span></span></code> </pre> <br><p>  Damit die Vorlage g√ºltig ist, ben√∂tigen Sie die Funktion <code>template()</code> , die entweder ein einzelnes Kubernetes-Objekt oder eine <code>list</code> / ein <code>tuple</code> davon zur√ºckgibt.  Die Liste der API-Objekte f√ºr den Python-Client finden Sie <a href="">hier</a> . <br>  Wie Sie sehen k√∂nnen, ist der Code sauber, einfach und lesbar.  Sie k√∂nnen sich fragen, woher von <code>values.nginx.image.repository</code> kommt?  Es erh√§lt Werte aus den <code>karavel template -f one.yaml --values two.yaml</code> des Diagramms √ºbergeben, genau wie in Helm: <code>karavel template -f one.yaml --values two.yaml</code> .  Wir werden sie uns sp√§ter ansehen. </p><br><h2 id="okay-what-about-helm-charts">  Okay, was ist mit Helm-Charts? </h2><br><p>  Jetzt haben wir unsere eigene Bereitstellung erstellt.  Aber was ist, wenn wir ein Helmdiagramm oder einen Teil eines Diagramms importieren m√∂chten?  <code>templates/service-helm.py</code> wir einen Blick auf <code>templates/service-helm.py</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kubernetes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> karavel.helm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HelmChart <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> karavel.helpers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Values <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> values = Values().values <span class="hljs-comment"><span class="hljs-comment"># Initialize the chart (== helm template --values) chart = HelmChart(name='mysql', version='0.13.1', values=values.mysql.helm) # Get the desired object from chart service = chart.get(name='svc', obj_class=client.V1Service) # Create custom objects to add custom_ports = [ client.V1ServicePort( name='my-custom-port', protocol=values.mysql.protocol, port=values.mysql.port, target_port=39000, ) ] # Add custom objects to the service service.spec['ports'] = custom_ports # Change Helm-generated label service.metadata['labels']['release'] += '-suffix' # Delete Helm-generated label `heritage: Tiller` del service.metadata['labels']['heritage'] return service # [service], (service, service) are valid</span></span></code> </pre> <br><p>  Einfach, oder?  Beachten Sie diese Zeile: <code>service = chart.get(name='svc', obj_class=client.V1Service)</code> - Wir haben ein Objekt der Klasse <code>V1Service</code> aus der Helm- <code>yaml</code> Datei erstellt.  Wenn Sie das nicht wollen / m√ºssen, k√∂nnen Sie immer nur mit <code>dict</code> . </p><br><h2 id="what-if-i-want-to-create-custom-resource">  Was ist, wenn ich eine benutzerdefinierte Ressource erstellen m√∂chte? </h2><br><p>  Nun, damit gibt es ein kleines Problem.  Die Kubernetes-API f√ºgt der swagger json-Definition unter <code>/openapi/v2</code> keine CRD-Objekte <code>/openapi/v2</code> , und Python-Client-Objekte bauen auf dieser Definition auf.  Sie k√∂nnen jedoch problemlos mit <code>dict</code> .  So: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kubernetes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> client <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> resource = { <span class="hljs-string"><span class="hljs-string">'apiVersion'</span></span>: <span class="hljs-string"><span class="hljs-string">'stable.example.com/v1'</span></span>, <span class="hljs-string"><span class="hljs-string">'kind'</span></span>: <span class="hljs-string"><span class="hljs-string">'Whale'</span></span>, <span class="hljs-string"><span class="hljs-string">'metadata'</span></span>: client.V1ObjectMeta( name=<span class="hljs-string"><span class="hljs-string">'my-object'</span></span>, ), <span class="hljs-string"><span class="hljs-string">'spec'</span></span>: { <span class="hljs-string"><span class="hljs-string">'image'</span></span>: <span class="hljs-string"><span class="hljs-string">'my-whale-image:0.0.1'</span></span>, <span class="hljs-string"><span class="hljs-string">'tail'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'fins'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resource <span class="hljs-comment"><span class="hljs-comment"># [resource], (resource, resource) are valid</span></span></code> </pre> <br><p>  Sieht immer noch gut aus, nicht wahr? </p><br><h2 id="can-i-have-values-for-different-environments-eg-devprod">  Kann ich Werte f√ºr verschiedene Umgebungen haben, z. B. dev / prod? </h2><br><p>  Ja, das kannst du! <br>  Schauen wir <code>values.yaml</code> zuerst <code>values.yaml</code> : </p><br><pre> <code class="plaintext hljs">nginx: image: repository: nginx tag: 1.15-alpine mysql: port: 3307 protocol: TCP helm: releaseName: my-release namespace: prod imageTag: '5.7.14' service: type: NodePort</code> </pre> <br><p>  Beachten Sie den <code>chart = HelmChart(name='mysql', version='0.13.1', values=values.mysql.helm)</code> dict: Wir haben ihn verwendet, um Werte f√ºr helm chart <code>chart = HelmChart(name='mysql', version='0.13.1', values=values.mysql.helm)</code> .  Einige Helm-Diagramme ben√∂tigen <code>releaseName</code> f√ºr die Anwendungsbenennung und den <code>namespace</code> f√ºr RBAC-Richtlinien.  Diese beiden Werte werden als Argumente <code>--namespace</code> und <code>NAME</code> in der <code>--namespace</code> an Helm <code>--namespace</code> . </p><br><p>  Jetzt k√∂nnen Sie eine zus√§tzliche Datei f√ºr prod env angeben und alle unsere Beispiele vorlegen: </p><br><pre> <code class="plaintext hljs">$ karavel template -f values.yaml -f prod.yaml . --- # Source: templates/custom-resource.py apiVersion: stable.example.com/v1 kind: Whale metadata: name: my-object spec: fins: 4 image: my-whale-image:0.0.1 tail: 1 --- # Source: templates/deployment.py apiVersion: extensions/v1beta1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 3 template: metadata: labels: app: nginx spec: containers: - image: nginx:1.14-alpine name: nginx ports: - containerPort: 80 --- # Source: templates/service-helm.py apiVersion: v1 kind: Service metadata: annotations: null labels: app: prod-release-mysql chart: mysql-0.13.1 release: prod-release-suffix name: prod-release-mysql spec: ports: - name: my-custom-port port: 3308 protocol: TCP targetPort: 39000 selector: app: prod-release-mysql type: NodePort</code> </pre><br><p>  Danach k√∂nnen Sie <code>kubeclt apply</code> und diese Objekte im Cluster bereitstellen. </p><br><h3 id="cool-what-about-encoding-and-base64">  Cool!  Was ist mit Codierung und base64? </h3><br><p> <code>import base64</code> </p> <br><h3 id="what-about-using-vault-for-secrets">  Was ist mit Vault f√ºr Geheimnisse? </h3><br><p> <code>import hvac</code> </p> <br><h3 id="fetching-urls">  URLs abrufen? </h3><br><p> <code>import importlib</code> </p> <br><h3 id="secure-hash-functions">  Sichere Hash-Funktionen? </h3><br><p> <code>import Crypto</code> </p> <br><p>  Du hast es verstanden.  Mit Python k√∂nnen Sie viele Dinge mit Ihren Kubernetes-Manifesten tun. </p><br><h2 id="is-it-nih-syndrome">  Ist es das NIH-Syndrom? </h2><br><p>  Nein :) <br>  Ich bin <del>  gl√ºcklich </del>  mit Helm in meinen aktuellen Projekten.  Es gibt Dinge, die ich vermisse.  Ich habe Ksonnet auch in einigen meiner Projekte verwendet. <br>  Ich m√∂chte dieses Tool als Proof-of-Concept betrachten, dass wir Vorlagen-Tools besser als Helm haben k√∂nnen und es nicht sehr schwierig ist, sie mit Python zu entwickeln.  Wenn ein Gemeinschaftsinteresse / -bed√ºrfnis an einem solchen Tool besteht, k√∂nnen wir es gemeinsam weiterentwickeln.  Oder wir k√∂nnen auf die Ver√∂ffentlichung von Helm 3 warten;) </p><br><h2 id="conclusion">  Fazit </h2><br><p>  Ich habe Ihnen ein Python-basiertes Template-Tool f√ºr Kubernetes gezeigt, das Unterst√ºtzung f√ºr Kubernetes-API-kompatible Objekte und Unterst√ºtzung f√ºr den Import von Helm-Diagrammen bietet.  Alle Kommentare und Diskussionen aus der Community sind willkommen und auch im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repo</a> willkommen. </p><br><p>  Vielen Dank f√ºr das Lesen und einen sch√∂nen Tag! </p><br><h3 id="references">  Referenzen </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Python-Client-Bibliothek f√ºr Kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ksonnet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Artikel √ºber Medium</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437682/">https://habr.com/ru/post/de437682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437670/index.html">MSVC-Backend-Updates in Visual Studio 2019 Vorschau 2: Neue Optimierungen, OpenMP- und Build-Durchsatzverbesserungen</a></li>
<li><a href="../de437672/index.html">cyberd: Berechnung des Wissens aus web3</a></li>
<li><a href="../de437674/index.html">3D-Objekterkennungsmethoden f√ºr unbemannte Fahrzeuge. Yandex-Bericht</a></li>
<li><a href="../de437676/index.html">Universit√§ten und Corporate Accelerators als Hebel f√ºr den Start eines B2B-Startups in den USA</a></li>
<li><a href="../de437680/index.html">Meine DIY-Sammlung auf Youtube</a></li>
<li><a href="../de437684/index.html">Oberster Algorithmus - Voreingenommenes Kompendium</a></li>
<li><a href="../de437686/index.html">Learning go: Schreiben eines P2P-Messenger mit End-to-End-Verschl√ºsselung</a></li>
<li><a href="../de437688/index.html">OpenSceneGraph: Grundlegende Programmiertechniken</a></li>
<li><a href="../de437694/index.html">Analyse des Dienstprogramms Files.walkFileTree ();</a></li>
<li><a href="../de437696/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 283 (vom 21. bis 27. Januar)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>