<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âœŒğŸ¼ ğŸ‡ ğŸ¥ª Schreiben eines weiteren Kubernetes-Template-Tools ğŸ± ğŸ¦… ğŸ‘‹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie mit der Kubernetes-Umgebung arbeiten, verwenden Sie wahrscheinlich mehrere vorhandene Vorlagen-Tools, von denen einige Teil von Paketmanagern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben eines weiteren Kubernetes-Template-Tools</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437682/"><p><img src="https://habrastorage.org/webt/hj/xp/t7/hjxpt7lglfmyiz9ut7xcy2ndpl4.png"></p><br><p>  Wenn Sie mit der Kubernetes-Umgebung arbeiten, verwenden Sie wahrscheinlich mehrere vorhandene Vorlagen-Tools, von denen einige Teil von Paketmanagern wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ksonnet</a> sind oder nur Vorlagen-Sprachen (Jinja2, Go-Vorlage usw.).  Alle haben ihre eigenen Nachteile und Vorteile, und wir werden sie durchgehen und unser eigenes Tool schreiben, das versucht, die besten Funktionen zu kombinieren. </p><a name="habracut"></a><br><h2 id="so-why-not-helm">  Warum also nicht Helm? </h2><br><p> Es gibt eine Reihe von Artikeln, die Helm kritisieren (z. B. nur einen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ãœberlegen Sie zweimal, bevor Sie Helm verwenden</a> ).  Das Hauptproblem bei Helm ist, dass es mit <em>Zeichenfolgendarstellungen</em> funktioniert und Kubernetes-Manifeste <em>(json) Objekte sind</em> .  Die wahre HÃ¶lle fÃ¼r einen Helm-Diagrammentwickler beginnt, wenn er <code>yaml</code> fÃ¼r ein <code>yaml</code> Manifest berechnen <code>yaml</code> . Manchmal sieht es so aus (es ist ein echtes Beispiel aus meinem Diagramm): </p><br><pre> <code class="plaintext hljs">spec: jobTemplate: spec: template: spec: containers: - name: my-awesome-container resources: {{ toYaml .Values.resources | indent 14 }}</code> </pre> <br><p><img src="https://habrastorage.org/webt/oh/iw/cz/ohiwczwzpduep0hfxrghx0xtook.jpeg"></p><br><p>  Aber Helm ist heute de facto der Standard fÃ¼r Kubernetes-Anwendungsverpackungen.  Der Hauptvorteil von Helm ist eine groÃŸe Community und eine groÃŸe Anzahl Ã¶ffentlicher Repositories mit Diagrammen.  Und kÃ¼rzlich haben Helm-Entwickler einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm-Hub</a> angekÃ¼ndigt.  Helm ist heute wie Docker - es ist nicht der einzige, aber es hat Gemeinschaft und UnterstÃ¼tzung. </p><br><p>  Es gibt vielversprechende Ã„nderungen mit der VerÃ¶ffentlichung von Helm 3, aber niemand weiÃŸ, wann es sein kÃ¶nnte. </p><br><p>  AbschlieÃŸend Helm Vorteile: </p><br><ul><li>  GroÃŸe Community und eine Reihe von Ã¶ffentlichen Charts </li><li>  (Relativ) menschenfreundliche Syntax.  Zumindest ist es yaml + go template;) </li></ul><br><p>  Nachteile: </p><br><ul><li>  Arbeiten mit Zeichenfolgen und nicht mit Objekten </li><li>  Begrenzte Anzahl von Operatoren und Funktionen, die Sie verwenden kÃ¶nnen </li></ul><br><h2 id="ok-then-maybe-ksonnet">  OK, dann vielleicht Ksonnet? </h2><br><p>  Wenn Sie Helm mit Ksonnet vergleichen, hat letzteres einen groÃŸen Vorteil, nÃ¤mlich, dass es mit Objekten funktioniert.  Ksonnet ist ein Tool, das auf der JSON-Vorlagensprache Jsonnet basiert.  Ein weiteres cooles Feature von Ksonnet ist, dass es Kubernetes-API-kompatible Jsonnet-Bibliotheken enthÃ¤lt, die Sie in Ihre Vorlage importieren und mit Kubernetes-Objekten wie in jeder OOP-Sprache arbeiten kÃ¶nnen: </p><br><pre> <code class="json hljs">local k = import <span class="hljs-string"><span class="hljs-string">"k.libsonnet"</span></span>; local deployment = k.apps.v<span class="hljs-number"><span class="hljs-number">1</span></span>beta<span class="hljs-number"><span class="hljs-number">1</span></span>.deployment; local appDeployment = deployment .new( params.name, params.replicas, container .new(params.name, params.image) .withPorts(containerPort.new(targetPort)), labels);</code> </pre> <br><p>  Sieht beeindruckend aus, nicht wahr? <br>  Es ist etwas weniger ordentlich, wenn Sie nicht mit API-Objekten arbeiten, sondern nur mit <code>yaml</code> Objekten, die aus der <code>yaml</code> / <code>json</code> Datei importiert wurden: </p><br><pre> <code class="json hljs">{ global: {}, components: { <span class="hljs-attr"><span class="hljs-attr">"deployment-nginx-deployment-dkecx"</span></span>+: { spec+: { replicas: <span class="hljs-number"><span class="hljs-number">10</span></span>, template+: { spec+: { containers+: [ { name: <span class="hljs-string"><span class="hljs-string">"nginx"</span></span>, image: <span class="hljs-string"><span class="hljs-string">"nginx:latest"</span></span>, ports: [ { containerPort: <span class="hljs-number"><span class="hljs-number">80</span></span>, }, ], }, ], }, }, }, }, }, }</code> </pre> <br><p>  Aber es ist immer noch etwas und es ist besser als mit Saiten in Helm zu arbeiten.  Der Nachteil von Ksonnet ist, dass es eine kleinere Community und weniger Pakete als Helm hat (obwohl Sie Helm-Diagramme in Ihr Ksonnet-Projekt importieren kÃ¶nnen, aber Sie werden mit ihnen als json-Objekte arbeiten, nicht als jsonnet-Bibliotheksobjekte).  Und aufgrund einer kleineren Community und eines kleineren Beitrags fehlen einige Funktionen, wenn Sie versuchen, Ihr eigenes Diagramm zu schreiben.  Eine davon habe ich selbst erlebt: Sie wissen, dass Sie in Helm eine <code>ConfigMap</code> aus einem Verzeichnis <code>ConfigMap</code> kÃ¶nnen, das eine Reihe von Konfigurationsdateien enthÃ¤lt: </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: ConfigMap metadata: name: conf data: {{- (.Files.Glob "foo/*").AsConfig | nindent 2 }}</code> </pre> <br><p>  Sie kÃ¶nnen sich meine Frustration vorstellen, als ich herausfand, dass es in Ksonnet keine solche Funktion gibt.  Es gibt jedoch Problemumgehungen.  Aber der Punkt ist, dass es nur ein Beispiel fÃ¼r die Situation ist, in der Sie glÃ¼cklich Ihr Diagramm schreiben und dann plÃ¶tzlich ein Mangel an einer Funktion Sie auf halbem Weg aufhÃ¤lt. <br>  Insgesamt Vorteile von Ksonnet: </p><br><ul><li>  Arbeiten mit Objekten </li><li>  Kubernetes-API-kompatible Jsonnet-Bibliotheken </li><li>  UnterstÃ¼tzung fÃ¼r den Import von Helmdiagrammen </li></ul><br><p>  Nachteile: </p><br><ul><li>  Kleinere Community und geringere Anzahl von Ksonnet-nativen Paketen </li><li>  Fehlende Funktionen, die Sie in Helm verwenden kÃ¶nnen </li><li>  Neue Syntax =&gt; erhÃ¶hte Lernzeit =&gt; erhÃ¶hter Busfaktor </li><li>  Syntax kann manchmal hÃ¤sslich und weniger lesbar werden (insbesondere, wenn Problemumgehungen fÃ¼r fehlende Funktionen vorgenommen werden). </li></ul><br><h2 id="lets-think-of-an-ideal-templating-tool">  Stellen wir uns ein ideales Vorlagenwerkzeug vor </h2><br><p>  Hier sind einige Kriterien fÃ¼r das "ideale" Vorlagenwerkzeug: </p><br><ul><li>  Es sollte mit Objekten funktionieren, nicht mit Strings </li><li>  Es sollte in der Lage sein, mit Kubernetes-API-kompatiblen Objekten zu arbeiten </li><li>  Es sollte einen anstÃ¤ndigen Satz von Funktionen fÃ¼r die Arbeit mit Strings haben </li><li>  Es sollte gut mit json- und yaml-Formaten funktionieren </li><li>  Es sollte menschenfreundlich sein </li><li>  Es sollte einfach sein </li><li>  Es sollte die MÃ¶glichkeit haben, vorhandene Helm-Diagramme zu importieren (da dies RealitÃ¤t ist und wir die Helm-Community nutzen mÃ¶chten). </li></ul><br><p>  Das reicht fÃ¼rs Erste.  Ich ging diese Liste in meinem Kopf durch und dachte mir: Okay, warum nicht Python ausprobieren?  Mal sehen, ob es unseren Kriterien entspricht: </p><br><ul><li>  <em>Arbeiten Sie mit Objekten, nicht mit Zeichenfolgen</em> .  Ja, wir kÃ¶nnen dafÃ¼r <code>dict</code> und <code>dict</code> verwenden. </li><li>  <em>Sie kÃ¶nnen mit Kubernetes-API-kompatiblen Objekten arbeiten</em> .  Ja, <code>from kubernetes import client</code> </li><li>  <em>Haben Sie einen anstÃ¤ndigen Satz von Funktionen fÃ¼r die Arbeit mit Zeichenfolgen</em> .  Viel! </li><li>  <em>Arbeiten Sie gut mit den Formaten json und yaml</em> .  Sehr schÃ¶n. </li><li>  <em>Menschenfreundlich</em>  Keine ScheiÃŸe. </li><li>  <em>Einfach</em>  Ja </li><li>  <em>MÃ¶glichkeit zum Importieren vorhandener Helmdiagramme</em> .  Das werden wir uns hinzufÃ¼gen. </li></ul><br><p>  Ok, sieht vielversprechend aus.  Ich habe mich entschlossen, ein einfaches Template-Tool auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Python-Client-Bibliothek fÃ¼r Kubernetes zu schreiben,</a> und jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mÃ¶chte</a> ich Ihnen zeigen, was dabei herausgekommen ist. </p><br><h2 id="meet-karavel">  Treffen Sie Karavel </h2><br><p>  Dieses Tool ist weder besonders noch kompliziert.  Ich habe gerade die Kubernetes-Bibliothek (die mir die MÃ¶glichkeit gab, mit Kubernetes-Objekten zu arbeiten) genommen und einige grundlegende Funktionen fÃ¼r vorhandene Helm-Diagramme geschrieben (damit man sie abrufen und in ein eigenes Diagramm einfÃ¼gen kann).  Also, lass uns eine Tour machen. <br>  Zuallererst ist dieses Tool bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github Repo verfÃ¼gbar</a> und dort finden Sie ein Verzeichnis mit Beispielen. </p><br><h2 id="quick-start-with-docker-image">  Schnellstart mit Docker-Image </h2><br><p>  Wenn Sie es ausprobieren mÃ¶chten, verwenden Sie am einfachsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Docker-Image</a> : </p><br><pre> <code class="plaintext hljs">$ docker run greegorey/karavel -h usage: karavelcli.py [-h] subcommand ... optional arguments: -h, --help show this help message and exit list of subcommands: subcommand template generates manifests from template ensure ensure helm dependencies</code> </pre> <br><p>  Wenn Sie Diagramme vorlegen mÃ¶chten, mÃ¼ssen Sie natÃ¼rlich das Verzeichnis Ihres Diagramms bereitstellen: </p><br><pre> <code class="plaintext hljs">$ cd example $ docker run -v $PWD:/chart greegorey/karavel template .</code> </pre> <br><p>  Schauen wir uns also die Diagrammstruktur an.  Es ist einem von Helm sehr Ã¤hnlich: </p><br><pre> <code class="plaintext hljs">$ cd example $ tree . . â”œâ”€â”€ dependencies â”œâ”€â”€ prod.yaml â”œâ”€â”€ requirements.yaml â”œâ”€â”€ templates â”‚  â”œâ”€â”€ custom-resource.py â”‚  â”œâ”€â”€ deployment.py â”‚  â””â”€â”€ service-helm.py â””â”€â”€ values.yaml 2 directories, 6 files</code> </pre> <br><p>  Wie Helm hat es die Datei require.yaml mit demselben Layout: </p><br><pre> <code class="plaintext hljs">dependencies: - name: mysql version: 0.13.1 repository: https://kubernetes-charts.storage.googleapis.com/</code> </pre> <br><p>  Hier listen Sie einfach Ihre Helm-AbhÃ¤ngigkeiten auf, die Sie in Ihr Diagramm importieren mÃ¶chten.  Die AbhÃ¤ngigkeiten werden in das <code>dependencies</code> verschoben.  Verwenden Sie zum Abrufen oder Aktualisieren den Befehl verify: </p><br><pre> <code class="plaintext hljs">$ karavel ensure .</code> </pre> <br><p>  Danach sieht Ihr <code>dependencies</code> aus: </p><br><pre> <code class="plaintext hljs">$ tree dependencies dependencies â””â”€â”€ mysql-0.13.1 â””â”€â”€ mysql â”œâ”€â”€ Chart.yaml â”œâ”€â”€ README.md â”œâ”€â”€ templates â”‚  â”œâ”€â”€ NOTES.txt â”‚  â”œâ”€â”€ _helpers.tpl â”‚  â”œâ”€â”€ configurationFiles-configmap.yaml â”‚  â”œâ”€â”€ deployment.yaml â”‚  â”œâ”€â”€ initializationFiles-configmap.yaml â”‚  â”œâ”€â”€ pvc.yaml â”‚  â”œâ”€â”€ secrets.yaml â”‚  â”œâ”€â”€ svc.yaml â”‚  â””â”€â”€ tests â”‚  â”œâ”€â”€ test-configmap.yaml â”‚  â””â”€â”€ test.yaml â””â”€â”€ values.yaml 4 directories, 13 files</code> </pre> <br><p>  Nachdem wir nun unsere AbhÃ¤ngigkeiten sichergestellt haben, schauen wir uns die Vorlagen an.  ZunÃ¤chst erstellen wir eine einfache Nginx-Bereitstellung: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kubernetes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> karavel.helpers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Values <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> values = Values().values <span class="hljs-comment"><span class="hljs-comment"># Configure Pod template container container = client.V1Container( name='nginx', image='{}:{}'.format(values.nginx.image.repository, values.nginx.image.tag), ports=[client.V1ContainerPort(container_port=80)]) # Create and configurate a spec section template = client.V1PodTemplateSpec( metadata=client.V1ObjectMeta(labels={'app': 'nginx'}), spec=client.V1PodSpec(containers=[container])) # Create the specification of deployment spec = client.ExtensionsV1beta1DeploymentSpec( replicas=3, template=template) # Instantiate the deployment object deployment = client.ExtensionsV1beta1Deployment( api_version='extensions/v1beta1', kind='Deployment', metadata=client.V1ObjectMeta(name='nginx-deployment'), spec=spec) return deployment # [deployment], (deployment, deployment) are valid</span></span></code> </pre> <br><p>  Damit die Vorlage gÃ¼ltig ist, benÃ¶tigen Sie die Funktion <code>template()</code> , die entweder ein einzelnes Kubernetes-Objekt oder eine <code>list</code> / ein <code>tuple</code> davon zurÃ¼ckgibt.  Die Liste der API-Objekte fÃ¼r den Python-Client finden Sie <a href="">hier</a> . <br>  Wie Sie sehen kÃ¶nnen, ist der Code sauber, einfach und lesbar.  Sie kÃ¶nnen sich fragen, woher von <code>values.nginx.image.repository</code> kommt?  Es erhÃ¤lt Werte aus den <code>karavel template -f one.yaml --values two.yaml</code> des Diagramms Ã¼bergeben, genau wie in Helm: <code>karavel template -f one.yaml --values two.yaml</code> .  Wir werden sie uns spÃ¤ter ansehen. </p><br><h2 id="okay-what-about-helm-charts">  Okay, was ist mit Helm-Charts? </h2><br><p>  Jetzt haben wir unsere eigene Bereitstellung erstellt.  Aber was ist, wenn wir ein Helmdiagramm oder einen Teil eines Diagramms importieren mÃ¶chten?  <code>templates/service-helm.py</code> wir einen Blick auf <code>templates/service-helm.py</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kubernetes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> karavel.helm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HelmChart <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> karavel.helpers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Values <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> values = Values().values <span class="hljs-comment"><span class="hljs-comment"># Initialize the chart (== helm template --values) chart = HelmChart(name='mysql', version='0.13.1', values=values.mysql.helm) # Get the desired object from chart service = chart.get(name='svc', obj_class=client.V1Service) # Create custom objects to add custom_ports = [ client.V1ServicePort( name='my-custom-port', protocol=values.mysql.protocol, port=values.mysql.port, target_port=39000, ) ] # Add custom objects to the service service.spec['ports'] = custom_ports # Change Helm-generated label service.metadata['labels']['release'] += '-suffix' # Delete Helm-generated label `heritage: Tiller` del service.metadata['labels']['heritage'] return service # [service], (service, service) are valid</span></span></code> </pre> <br><p>  Einfach, oder?  Beachten Sie diese Zeile: <code>service = chart.get(name='svc', obj_class=client.V1Service)</code> - Wir haben ein Objekt der Klasse <code>V1Service</code> aus der Helm- <code>yaml</code> Datei erstellt.  Wenn Sie das nicht wollen / mÃ¼ssen, kÃ¶nnen Sie immer nur mit <code>dict</code> . </p><br><h2 id="what-if-i-want-to-create-custom-resource">  Was ist, wenn ich eine benutzerdefinierte Ressource erstellen mÃ¶chte? </h2><br><p>  Nun, damit gibt es ein kleines Problem.  Die Kubernetes-API fÃ¼gt der swagger json-Definition unter <code>/openapi/v2</code> keine CRD-Objekte <code>/openapi/v2</code> , und Python-Client-Objekte bauen auf dieser Definition auf.  Sie kÃ¶nnen jedoch problemlos mit <code>dict</code> .  So: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> kubernetes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> client <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> resource = { <span class="hljs-string"><span class="hljs-string">'apiVersion'</span></span>: <span class="hljs-string"><span class="hljs-string">'stable.example.com/v1'</span></span>, <span class="hljs-string"><span class="hljs-string">'kind'</span></span>: <span class="hljs-string"><span class="hljs-string">'Whale'</span></span>, <span class="hljs-string"><span class="hljs-string">'metadata'</span></span>: client.V1ObjectMeta( name=<span class="hljs-string"><span class="hljs-string">'my-object'</span></span>, ), <span class="hljs-string"><span class="hljs-string">'spec'</span></span>: { <span class="hljs-string"><span class="hljs-string">'image'</span></span>: <span class="hljs-string"><span class="hljs-string">'my-whale-image:0.0.1'</span></span>, <span class="hljs-string"><span class="hljs-string">'tail'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'fins'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resource <span class="hljs-comment"><span class="hljs-comment"># [resource], (resource, resource) are valid</span></span></code> </pre> <br><p>  Sieht immer noch gut aus, nicht wahr? </p><br><h2 id="can-i-have-values-for-different-environments-eg-devprod">  Kann ich Werte fÃ¼r verschiedene Umgebungen haben, z. B. dev / prod? </h2><br><p>  Ja, das kannst du! <br>  Schauen wir <code>values.yaml</code> zuerst <code>values.yaml</code> : </p><br><pre> <code class="plaintext hljs">nginx: image: repository: nginx tag: 1.15-alpine mysql: port: 3307 protocol: TCP helm: releaseName: my-release namespace: prod imageTag: '5.7.14' service: type: NodePort</code> </pre> <br><p>  Beachten Sie den <code>chart = HelmChart(name='mysql', version='0.13.1', values=values.mysql.helm)</code> dict: Wir haben ihn verwendet, um Werte fÃ¼r helm chart <code>chart = HelmChart(name='mysql', version='0.13.1', values=values.mysql.helm)</code> .  Einige Helm-Diagramme benÃ¶tigen <code>releaseName</code> fÃ¼r die Anwendungsbenennung und den <code>namespace</code> fÃ¼r RBAC-Richtlinien.  Diese beiden Werte werden als Argumente <code>--namespace</code> und <code>NAME</code> in der <code>--namespace</code> an Helm <code>--namespace</code> . </p><br><p>  Jetzt kÃ¶nnen Sie eine zusÃ¤tzliche Datei fÃ¼r prod env angeben und alle unsere Beispiele vorlegen: </p><br><pre> <code class="plaintext hljs">$ karavel template -f values.yaml -f prod.yaml . --- # Source: templates/custom-resource.py apiVersion: stable.example.com/v1 kind: Whale metadata: name: my-object spec: fins: 4 image: my-whale-image:0.0.1 tail: 1 --- # Source: templates/deployment.py apiVersion: extensions/v1beta1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 3 template: metadata: labels: app: nginx spec: containers: - image: nginx:1.14-alpine name: nginx ports: - containerPort: 80 --- # Source: templates/service-helm.py apiVersion: v1 kind: Service metadata: annotations: null labels: app: prod-release-mysql chart: mysql-0.13.1 release: prod-release-suffix name: prod-release-mysql spec: ports: - name: my-custom-port port: 3308 protocol: TCP targetPort: 39000 selector: app: prod-release-mysql type: NodePort</code> </pre><br><p>  Danach kÃ¶nnen Sie <code>kubeclt apply</code> und diese Objekte im Cluster bereitstellen. </p><br><h3 id="cool-what-about-encoding-and-base64">  Cool!  Was ist mit Codierung und base64? </h3><br><p> <code>import base64</code> </p> <br><h3 id="what-about-using-vault-for-secrets">  Was ist mit Vault fÃ¼r Geheimnisse? </h3><br><p> <code>import hvac</code> </p> <br><h3 id="fetching-urls">  URLs abrufen? </h3><br><p> <code>import importlib</code> </p> <br><h3 id="secure-hash-functions">  Sichere Hash-Funktionen? </h3><br><p> <code>import Crypto</code> </p> <br><p>  Du hast es verstanden.  Mit Python kÃ¶nnen Sie viele Dinge mit Ihren Kubernetes-Manifesten tun. </p><br><h2 id="is-it-nih-syndrome">  Ist es das NIH-Syndrom? </h2><br><p>  Nein :) <br>  Ich bin <del>  glÃ¼cklich </del>  mit Helm in meinen aktuellen Projekten.  Es gibt Dinge, die ich vermisse.  Ich habe Ksonnet auch in einigen meiner Projekte verwendet. <br>  Ich mÃ¶chte dieses Tool als Proof-of-Concept betrachten, dass wir Vorlagen-Tools besser als Helm haben kÃ¶nnen und es nicht sehr schwierig ist, sie mit Python zu entwickeln.  Wenn ein Gemeinschaftsinteresse / -bedÃ¼rfnis an einem solchen Tool besteht, kÃ¶nnen wir es gemeinsam weiterentwickeln.  Oder wir kÃ¶nnen auf die VerÃ¶ffentlichung von Helm 3 warten;) </p><br><h2 id="conclusion">  Fazit </h2><br><p>  Ich habe Ihnen ein Python-basiertes Template-Tool fÃ¼r Kubernetes gezeigt, das UnterstÃ¼tzung fÃ¼r Kubernetes-API-kompatible Objekte und UnterstÃ¼tzung fÃ¼r den Import von Helm-Diagrammen bietet.  Alle Kommentare und Diskussionen aus der Community sind willkommen und auch im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repo</a> willkommen. </p><br><p>  Vielen Dank fÃ¼r das Lesen und einen schÃ¶nen Tag! </p><br><h3 id="references">  Referenzen </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Python-Client-Bibliothek fÃ¼r Kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ksonnet</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Artikel Ã¼ber Medium</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437682/">https://habr.com/ru/post/de437682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437670/index.html">MSVC-Backend-Updates in Visual Studio 2019 Vorschau 2: Neue Optimierungen, OpenMP- und Build-Durchsatzverbesserungen</a></li>
<li><a href="../de437672/index.html">cyberd: Berechnung des Wissens aus web3</a></li>
<li><a href="../de437674/index.html">3D-Objekterkennungsmethoden fÃ¼r unbemannte Fahrzeuge. Yandex-Bericht</a></li>
<li><a href="../de437676/index.html">UniversitÃ¤ten und Corporate Accelerators als Hebel fÃ¼r den Start eines B2B-Startups in den USA</a></li>
<li><a href="../de437680/index.html">Meine DIY-Sammlung auf Youtube</a></li>
<li><a href="../de437684/index.html">Oberster Algorithmus - Voreingenommenes Kompendium</a></li>
<li><a href="../de437686/index.html">Learning go: Schreiben eines P2P-Messenger mit End-to-End-VerschlÃ¼sselung</a></li>
<li><a href="../de437688/index.html">OpenSceneGraph: Grundlegende Programmiertechniken</a></li>
<li><a href="../de437694/index.html">Analyse des Dienstprogramms Files.walkFileTree ();</a></li>
<li><a href="../de437696/index.html">Die Zusammenfassung interessanter Materialien fÃ¼r den mobilen Entwickler # 283 (vom 21. bis 27. Januar)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>