<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈁 💅🏻 🙍 .NET：用于处理多线程和异步的工具。 第二部分 🏭 🤲🏽 🚬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我在Habr上发表了原始文章，其翻译发布在Codingsight博客上。 

 我将继续在多线程会议上创建我的演讲的文本版本。 第一部分可以在此处或此处找到， 这里有更多有关启动线程或任务的基本工具集，查看其状态的方法以及PLinq之类的一些小工具。 在本文中，我希望更多地关注多线程环境中可能出现的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET：用于处理多线程和异步的工具。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459514/">  <i>我在Habr上发表了原始文章，其翻译发布在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Codingsight</a>博客上。</i> <br><br> 我将继续在多线程会议上创建我的演讲的文本版本。 第一部分可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>有更多有关启动线程或任务的基本工具集，查看其状态的方法以及PLinq之类的一些小工具。 在本文中，我希望更多地关注多线程环境中可能出现的问题以及解决这些问题的一些方法。 <br><br><h2> 目录内容 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于共享资源</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在多线程环境中工作时可能出现的问题</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">死锁</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">比赛条件</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">忙碌中</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">线程饥饿</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">同步工具</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">联锁</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Monitor.Enter，Monitor.Exit，锁定</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SpinLock，SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Monitor.Wait，Monitor.Pulse [全部]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ResetEvent系列</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </li></ul><br><a name="habracut"></a><br><a name="SharedResources"></a><br><h2> 关于共享资源 </h2><br> 不可能编写一个可以在多个线程中工作的程序，但是同时不会有一个共享资源： 即使它在您的抽象级别上可以解决，但如果跌至该级别下的一个或多个级别，则表明仍然存在一个公共资源。 我将举一些例子： <br><br>  <b>范例1：</b> <br><br> 担心可能出现的问题，您使线程可以使用不同的文件。 通过文件流。 在您看来，该程序没有单个公共资源。 <br><br> 深入到下面几个级别后，我们了解到只有一个硬盘驱动器，并且其驱动程序或操作系统将必须解​​决确保对其进行访问的问题。 <br><br>  <b>范例2：</b> <br><br> 阅读<i>示例</i> 1之后，您决定将文件放置在具有两个物理上不同的铁件和操作系统的两个不同的远程计算机上。 我们通过FTP或NFS保持2个不同的连接。 <br><br> 在下面的几个级别中，我们了解到什么都没有改变，并且网卡驱动程序或运行该程序的计算机的操作系统必须解决竞争性访问的问题。 <br><br>  <b>范例3：</b> <br><br> 试图证明编写多线程程序的可能性使您大失所望，您完全拒绝了文件，并将计算分解为两个不同的对象，每个对象的链接仅对一个流可用。 <br><br> 我将最后一钉钉在这个想法的棺材上：一个运行时和垃圾回收器，线程调度程序，实际上一个RAM和内存，一个处理器仍是共享资源。 <br><br> 因此，我们发现在整个技术堆栈的整个宽度的所有抽象级别上，如果没有单个共享资源就不可能编写多线程程序。 幸运的是，每个抽象级别通常都能部分或完全解决竞争性访问的问题或完全禁止竞争性访问（例如：任何UI框架均禁止使用来自不同线程的元素），因此问题最常出现在共享资源上您的抽象水平。 为了解决它们，引入了同步的概念。 <br><a name="Problems"></a><br><h2> 在多线程环境中工作时可能出现的问题 </h2><br> 软件中的错误可以分为几类： <br><br><ol><li> 该程序不会产生结果。 崩溃或冻结。 </li><li> 程序返回不正确的结果。 </li><li> 该程序产生正确的结果，但不满足一个或另一个非功能性要求。 运行时间过长或消耗太多资源。 </li></ol><br> 在多线程环境中，导致错误1和2的两个主要问题是<b>死锁</b>和<b>竞争条件</b> 。 <br><a name="Deadlock"></a><br><h3> 死锁 </h3><br> 死锁-死锁。 有许多不同的变化。 最常见的是以下几种： <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  <b>线程1</b>做某事时， <b>线程2</b>阻止了资源<b>B</b> ，稍后<b>线程1</b>阻止了资源<b>A</b>并试图锁定资源<b>B</b> ，不幸的是，这永远不会发生，因为  <b>线程＃2</b>仅在锁定资源<b>A</b>后才释放资源<b>B。</b> <br><a name="RaceCondition"></a><br><h3> 比赛条件 </h3><br> 竞赛条件-竞赛条件。 程序执行的计算的行为和结果的情况取决于运行时线程调度程序的工作。 <br> 这种情况的令人不快之处在于，您的程序可能只运行一次，甚至不到一百甚至一百万。 <br><br> 问题可能并存，这使情况更加恶化，例如：线程调度程序的某些行为会导致死锁。 <br><br> 除了这两个导致程序中明显错误的问题外，还有一些可能不会导致错误的计算结果的问题，但是要花费更多的时间或处理能力。 其中两个问题是： <b>忙等待</b>和<b>线程饥饿</b> 。 <br><a name="BusyWait"></a><br><h3> 忙碌中 </h3><br> 忙等待问题是程序消耗处理器资源而不是用于计算，而是用于等待的问题。 <br><br> 代码中的此类问题通常看起来像这样： <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br> 这是一个极差代码的示例，因为 这样的代码完全占据了处理器的一个核心，而没有任何用处。 仅当在另一个线程中处理某些值的更改至关重要时，才有理由。 快速地说，我是在谈论您什至不能等待几纳秒的情况。 在其他情况下，也就是说，在可以产生健康大脑的所有事物中，使用ResetEvent品种及其Slim版本更为合理。 关于他们下面。 <br><br> 也许有一位读者会建议通过向循环添加诸如Thread.Sleep（1）之类的结构来解决无休止地完全加载一个内核的问题。 这确实可以解决问题，但会产生另一个问题：对更改的响应时间平均为半毫秒，虽然可能不多，但比使用ResetEvent系列的同步原语要多得多。 <br><a name="ThreadStarvation"></a><br><h3> 线程饥饿 </h3><br> 线程匮乏是程序同时有太多线程在工作的问题。 这到底意味着那些正在忙于计算的流，而不仅仅是等待任何IO的响应。 由于存在此问题，因此失去了使用线程获得的所有可能的性能提升，因为 处理器花费大量时间切换上下文。 <br> 使用各种探查器查找此类问题很方便，下面是在时间轴模式下启动的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dotTrace</a>探查器的屏幕截图示例。 <br><br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>（图片可点击）</i> <br><br> 在不受流媒体饥饿困扰的程序中，反映流的图形上不会出现粉红色。 此外，在“子系统”类别中，很明显，有30.6％的程序正在等待CPU。 <br><br> 诊断出这样的问题后，解决起来非常简单：您一次启动了太多线程，一次启动的线程很少或没有全部启动。 <br><a name="SyncPrimitives"></a><br><h2> 同步工具 </h2><br><a name="Interlocked"></a><br><h3> 联锁 </h3><br> 这也许是最轻量的同步方式。 互锁是简单原子操作的集合。 原子操作称为什么时候都不会发生的操作。 在.NET中，互锁由具有多个方法的同名静态类表示，每个方法都实现一个原子操作。 <br><br> 要实现非原子操作的恐怖，请尝试编写一个程序以启动10个线程，每个线程使同一变量递增一百万，并在工作结束时打印该变量的值-不幸的是，它与1000万个变量的值将有很大不同每次程序启动时，都会有所不同。 发生这种情况是因为，即使像增量这样的简单操作也不是原子的，而是涉及从内存中提取值，计算新值并写回。 因此，两个线程可以同时执行这些操作中的每一个，在这种情况下，增量将丢失。 <br><br>  Interlocked类提供了Increment / Decrement方法；很容易猜测它们的作用。 如果您要在多个线程中处理数据并考虑某些事项，它们将很方便使用。 这样的代码将比经典锁更快地工作。 如果对上一段所述的情况使用“互锁”，则该程序将在任何情况下稳定地提供1000万。 <br><br> 乍看之下，CompareExchange方法执行的功能相当不明显，但是它的全部存在使您可以实现许多有趣的算法，尤其是无锁家族。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br> 该方法采用三个值：第一个值通过引用传递，这是将更改为第二个值的值，如果在比较时location1与comparand相匹配，则将返回location1的原始值。 这听起来很混乱，因为编写与CompareExchange进行相同操作的代码更加容易： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br> 只有Interlocked类中的实现是原子的。 也就是说，如果我们自己编写这样的代码，则可能已经满足了location1 ==比较条件的情况，但是到执行位置1 = value表达式时，另一个线程已经更改了location1的值，并且它将丢失。 <br><br> 我们可以在编译器为任何C＃事件生成的代码中找到一个使用此方法的好例子。 <br><br> 让我们用一个MyEvent事件编写一个简单的类： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">让我们</a>在Release配置中构建项目，并使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dotPeek</a>打开Show Compiler Generated Code选项，打开程序集： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br> 在这里您可以看到，在后台，编译器生成了一个相当复杂的算法。 当多个线程同时订阅该事件时，该算法可以防止丢失事件订阅的情况。 让我们更详细地编写add方法，并记住CompareExchange方法在后台执行的操作 <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br> 尽管它可能仍需要解释，但这已经有些清楚了。 换句话说，我将这种算法描述如下： <br><br>  <i>如果MyEvent与开始运行Delegate.Combine时的状态相同，请在其中写下Delegate.Combine返回的内容，如果没有，则无所谓，让我们再试一次，直到出现为止。</i> <i><br></i> <br><br> 因此，任何事件订阅都不会丢失。 如果您突然想实现动态线程安全的无锁数组，则必须解决类似的问题。 如果有多个流急于向其添加元素，那么最后都必须添加它们很重要。 <br><a name="Lock"></a><br><h3>  Monitor.Enter，Monitor.Exit，锁定 </h3><br> 这些是线程同步的最常用构造。 它们实现了关键部分的思想：即在对一个资源的Monitor.Enter，Monitor.Exit调用之间编写的代码只能在一个线程中一次执行。  lock语句是围绕try / finally包装的Enter / Exit调用的语法糖。 在.NET中实现关键部分的一个不错的功能是可以为同一流重新输入该部分。 这意味着此类代码将执行而不会出现问题： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br> 当然，不太可能有人用这种方式编写代码，但是如果您将此代码拖入深度调用堆栈的几种方法中，则此功能可以为您节省一些ifs。 为了使这种技巧成为可能，.NET开发人员必须添加一个限制-只能将引用类型的实例用作同步对象，并将几个字节隐式添加到将要写入流标识符的每个对象中。 <br><br>  c＃中关键部分的此功能对lock语句的操作施加了一个有趣的限制：您不能在lock语句内使用await语句。 起初，这让我感到惊讶，因为最终会尝试类似的Monitor.Enter / Exit构造进行编译。 怎么了 在这里，有必要再次仔细阅读最后一段，然后向其添加一些有关异步/等待原理的知识：等待后的代码不一定与等待前的代码在同一线程上执行，这取决于同步上下文以及是否存在。没有调用ConfigureAwait。 因此，Monitor.Exit可以在Monitor.Enter以外的线程上执行，这将引发<b>SynchronizationLockException</b> 。 如果您不相信它，则可以在控制台应用程序中执行以下代码：它会引发SynchronizationLockException。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br> 值得注意的是，在WinForms或WPF应用程序中，如果从主线程调用此代码，它将可以正常工作。 将有一个同步上下文，该上下文会在等待后实现返回UI-Thread的操作。 无论如何，您都不应在包含await运算符的代码上下文中使用关键部分。 在这些情况下，最好使用同步原语，这将在后面讨论。 <br><br> 谈到.NET中关键部分的工作，值得一提的是其实现的另一个功能。  .NET中的关键部分以两种模式运行：自旋等待模式和内核模式。 旋转等待算法方便地表示为以下伪代码： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br> 此优化基于以下假设：如果资源现在很忙，那么它将很快释放自己，因此可以在短时间内最快捕获关键部分。 如果这不是在短时间内发生，则线程将以内核模式等待，这与从线程模式返回一样需要时间。  .NET开发人员已尽可能地优化了短锁方案，不幸的是，如果许多线程开始中断它们之间的关键部分，则可能会导致CPU负载突然升高。 <br><a name="SpinLock"></a><br><h3>  SpinLock，SpinWait </h3><br> 由于我提到了旋转等待算法，因此值得一提的是BCL SpinLock和SpinWait结构。 如果有理由相信总会有机会非常迅速地锁定，则应使用它们。 另一方面，在剖析结果表明使用其他同步原语成为程序的瓶颈之前，几乎不值得记住它们。 <br><a name="Pulse"></a><br><h3>  Monitor.Wait，Monitor.Pulse [全部] </h3><br> 这两种方法应一起考虑。 在他们的帮助下，可以实现各种生产者-消费者方案。 <br><br>  <i>生产者－消费者-一种多进程/多线程设计模式，假定存在一个或多个生成数据的线程/进程以及一个或多个处理该数据的进程/线程。</i>  <i>通常使用共享集合。</i> <br><br> 这两个方法只有在导致它们的线程当前具有锁的情况下才能被调用。  Wait方法释放锁定并挂起，直到另一个线程调用Pulse。 <br><br> 为了演示这项工作，我写了一个小例子： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>（我使用图像而不是文本来直观地显示指令的执行顺序）</i> <br><br>  <u>解析：</u>在第二个流的开始处设置100ms的延迟，以确保稍后开始执行。 <br>  -T1：第2行流开始 <br>  -T1：第3行流进入关键部分 <br>  -T1：6号线，流进入睡眠状态 <br>  -T2：第3行流开始播放 <br>  -T2：＃4号线在等待关键部分时冻结 <br>  -T1：7号线释放关键部分，并在等待Pulse退出时冻结 <br>  -T2：第8行进入临界区 <br>  -T2：第11行使用Pulse方法通知T1 <br>  -T2：第14行退出关键部分。 在此之前，T1无法继续执行。 <br>  -T1：15号线醒来 <br>  -T1：16号线离开临界区 <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MSDN</a>关于使用Pulse / Wait / Wait方法有一个重要说明，即：Monitor不存储状态信息，这意味着如果在调用Wait方法之前调用Pulse方法，则可能导致死锁。</i>  <i>如果可能出现这种情况，则最好使用ResetEvent系列的类之一。</i> <br><br> 前面的示例清楚地说明了Monitor类的Wait / Pulse方法是如何工作的，但是仍然存在关于何时使用它的问题。 一个很好的例子是BlockingQueue &lt;T&gt;的这种实现，另一方面，System.Collections.Concurrent中的BlockingCollection &lt;T&gt;的实现使用SemaphoreSlim进行同步。 <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br> 这是我钟爱的同步原语，由同名的System.Threading命名空间类表示。 在我看来，如果许多程序的开发人员使用此类而不是通常的锁，它们会更好地工作。 <br><br>  <i>想法：许多线程可以读取，只有一个写入。</i>  <i>一旦流声明要写入，就无法开始新的读取，但会等待记录完成。</i>  <i>还有一个可升级读取锁定的概念，如果您在读取过程中了解到需要写东西，可以使用此概念，这样的锁定将在一个原子操作中转换为写入锁定。</i> <br><br>  <i>System.Threading命名空间中还有一个ReadWriteLock类，但是强烈建议在新开发中使用它。</i>  <i>Slim版本可以避免许多情况下导致死锁的情况，此外，它还可以使您快速捕获锁，因为</i>  <i>支持在旋转等待模式下进行同步，然后再进入内核模式。</i> <br><br> 如果在阅读本文时您还不了解此类，那么我想您现在已经回想起最近编写的代码中的许多示例，其中使用这种锁定方法可以使程序有效地工作。 <br><br>  ReaderWriterLockSlim类的接口非常简单明了，但很难称其使用方便： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br> 我喜欢将其用法包装在一个类中，这使使用它更加方便。 <br> 想法：使用Dispose方法使Read / WriteLock方法返回一个对象，这将允许它们在使用中使用，并且其行数与通常的锁几乎没有区别。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br> 这种技巧使您可以简单地进一步写： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  ResetEvent系列 </h3><br> 我将此类包括ManualResetEvent，ManualResetEventSlim，AutoResetEvent类。 <br>  ManualResetEvent类，其Slim版本和AutoResetEvent类可以处于两种状态： <br>  -在此状态下，处于阻塞状态（未信号通知）的所有调用WaitOne的线程都将冻结，直到事件转换为已通知状态为止。 <br>  -降低状态（带信号），在此状态下，挂在WaitOne调用上的所有流都将释放。 发生故障事件时，所有新的WaitOne调用都会立即有条件通过。 <br><br>  AutoResetEvent类与ManualResetEvent类的不同之处在于，它在完全释放一个线程后会自动进入锁定状态。 如果有多个线程挂起等待AutoResetEvent，则与ManualResetEvent不同，Set调用将只释放一个任意线程。  ManualResetEvent将释放所有线程。 <br><br> 让我们看一下AutoResetEvent如何工作的示例： <br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br><br> 该示例显示，仅通过释放挂在WaitOne调用上的线程，事件才能自动进入锁定状态（未信号通知）。 <br><br> 与ReaderWriterLock不同，ManualResetEvent类未标记为已弃用，并且不建议在其Slim版本出现后使用。 此类的瘦身版可有效地用于短期期望，因为 它发生在Spin-Wait模式下，常规版本适用于长版本。 <br><br> 除了ManualResetEvent和AutoResetEvent类之外，还存在CountdownEvent类。 该类对于算法的实现非常方便，在该算法中，要进行并行化的部分后面是将结果放在一起的部分。 这种方法称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">fork-join</a> 。 一篇出色的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>专门介绍了该类的工作，因此在此我将不对其进行详细分析。 <br><a name="Conclusions"></a><br><h2> 结论 </h2><br><ul><li> 使用线程时，导致不正确或丢失结果的两个问题是竞争状况和死锁 </li><li> 导致程序花费更多时间或资源的问题-线程饥饿和繁忙等待 </li><li>  .NET具有丰富的线程同步功能 </li><li> 有2种锁定等待模式-旋转等待，核心等待。 某些.NET线程同步原语同时使用 </li><li> 互锁是一组原子操作，用于无锁算法中，是最快的同步原语 </li><li> 锁操作符和Monitor.Enter / Exit实现了关键部分的概念-一段代码一次只能由一个线程执行 </li><li>  Monitor.Pulse / Wait方法对于实现Producer-Consumer脚本很方便 </li><li> 在可以并行读取的脚本中，ReaderWriterLockSlim可能比常规锁定更有效率 </li><li>  ResetEvent类家族可能对线程同步很有用。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459514/">https://habr.com/ru/post/zh-CN459514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459500/index.html">HTML是网络</a></li>
<li><a href="../zh-CN459502/index.html">我们将继续为俄罗斯人开发一个冒险平台：界面功能和夏季偏好</a></li>
<li><a href="../zh-CN459504/index.html">青年游戏设计师课程：如何在没有数学的情况下计算角色和装备的平衡</a></li>
<li><a href="../zh-CN459506/index.html">难以捉摸的马尔瓦里历险记，第三部分：复杂的VBA脚本，为笑声和利润</a></li>
<li><a href="../zh-CN459508/index.html">经验丰富的演示者忽略的5张幻灯片</a></li>
<li><a href="../zh-CN459518/index.html">面试中的Python任务说明</a></li>
<li><a href="../zh-CN459520/index.html">一个自然数列及其元素的模型。 菱形</a></li>
<li><a href="../zh-CN459528/index.html">我们如何教法国生态学和收集瓶子</a></li>
<li><a href="../zh-CN459530/index.html">微生物群。 研究历史和研究方法</a></li>
<li><a href="../zh-CN459532/index.html">如何从1到10中选择一个随机数</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>