<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš‡ ğŸ—³ï¸ ğŸ‘¨â€âš–ï¸ Setidaknya satu trik Vim yang tidak Anda ketahui â˜ğŸ¿ ğŸ‘¨ğŸ»â€ğŸ³ ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya telah bekerja di Vim selama delapan tahun dan terus-menerus menemukan sesuatu yang baru. Itu dianggap sebagai kebajikan Vim. Bagi saya, ini adala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Setidaknya satu trik Vim yang tidak Anda ketahui</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454742/"> Saya telah bekerja di Vim selama delapan tahun dan terus-menerus menemukan sesuatu yang baru.  Itu dianggap sebagai kebajikan Vim.  Bagi saya, ini adalah kurangnya keterbukaan: banyak fungsi tersembunyi tersembunyi terlalu dalam. <br><br>  Mereka berbicara tentang keindahan pengeditan modal dan objek teks, tetapi bagi saya sepertinya esensi Vim bukanlah itu.  Vim adalah selimut tambal sulam dari subsistem yang tersumbat dengan alat tambahan.  Hanya dalam mode pengeditan normal lebih dari seratus pintasan keyboard!  Kerapatan toolkit ini sebagian besar menjelaskan mengapa Vim sangat berguna.  Jika "tampilkan semua tag untuk kata kunci" hanya <code>g]</code> , maka perintah ini akan lebih sering digunakan. <br><br>  Dalam sistem dengan kurangnya keterbukaan, seseorang harus mengandalkan kepemimpinan.  Tetapi bagi Vim tidak banyak dari mereka.  Ada artikel untuk pemula, seperti <code>ciw</code> (jangan bingung dengan CIA, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual CIA untuk Vim</a> ) dan sejenisnya.  Dan ada artikel para ahli yang terbenam dalam subsistem.  Tapi tidak ada yang benar-benar berbicara tentang trik khusus yang membuat Anda berseru: sial, seperti yang saya butuhkan selama enam tahun terakhir! <br><a name="habracut"></a><br>  Artikel ini adalah tentang beberapa trik kecil yang saya gunakan di Vim.  Tak satu pun dari mereka dibongkar dalam semua detail, jadi jika ada yang tertarik, saya sarankan menggali informasi tambahan.  Mereka juga tidak berhubungan satu sama lain.  Tapi ini normal.  Secara umum, ada lebih dari cukup untuk benar-benar membantu hampir semua orang. <br><br><h1>  Struktur artikel </h1><br>  Sangat kasar, pengguna Vim terbagi dalam dua kategori.  <b>Puritan</b> menghargai ukuran kecil dan di mana-mana.  Sebagai aturan, mereka meminimalkan konfigurasi jika Anda harus bekerja pada komputer yang tidak dikenal (misalnya, melalui ssh).  Ekstensor, di sisi lain, mengisi Vim dengan plugins, fungsi, dan pemetaan homegrown dalam upaya yang sia-sia untuk berpura-pura menggunakan Emacs.  Jika Anda mengambil vimrc dari mereka, maka orang-orang akan tetap benar-benar tak berdaya. <br><br>  Seperti yang mungkin Anda tebak, saya jauh lebih dekat ke ekspander daripada puritan.  Saya membagi trik menjadi dua bagian tergantung pada apakah perubahan diperlukan di dasar Vim. <br><br><h1>  Puritan </h1><br>  Untuk perintah modal, tampilan bantuan standar digunakan, yaitu, <code>&lt;cr&gt;</code> berarti menekan tombol Enter.  Saat Anda membutuhkan bantuan <code>:h</code> untuk baris tertentu, misalnya <code>:h E676</code> , baris akan berada dalam tanda kurung. <br><br><h2>  Berbagai perintah dalam mode normal </h2><br><h4>  ": dan @: </h4><br>  <code>":</code> adalah register yang memegang perintah terakhir dieksekusi. Anda dapat mengetik <code>":p</code> untuk mencetaknya ke buffer.  <code>@:</code> mengulangi perintah terakhir. <br><br><h4>  "= </h4><br>  Daftar untuk "ekspresi."  Di sini Anda dapat memasukkan ekspresi vimL dan menyisipkannya, gunakan dengan ctrl-R, dll. Jadi, misalnya, cap waktu lokal dimasukkan dengan mengetikkan <code>"=strftime("%c")&lt;cr&gt;p</code> . <br><br><h4>  ma, 'A </h4><br>  <code>m{letter}</code> menempatkan tanda pada posisi kursor.  Kemudian <code>'{letter}</code> akan menuju ke baris ini.  Untuk huruf kecil, ini berfungsi pada buffer, sehingga cocok untuk navigasi.  Ini berfungsi secara global untuk huruf besar: bahkan jika Anda berada di file lain, <code>'A</code> akan pergi ke file berlabel <code></code>  Anda dapat melihat semua tag Anda dengan perintah <code>:marks:</code> <br><br><h4>  ctrl-A dan ctrl-X </h4><br>  Menambah dan mengurangi angka berikutnya dalam barisan di lokasi kursor atau di sebelah kanannya.  Karena langsung menuju ke nomor, kombinasi dapat digunakan dari mana saja.  <code>10c-A</code> jauh lebih sederhana daripada <code>wwwwwciw20</code> . <br><br><h4>  q: </h4><br>  Membuka sejarah tim sebelumnya.  Anda dapat menggunakannya dengan teks Vim apa pun, tetapi perubahannya tidak disimpan.  Namun, Anda dapat menjalankan perintah yang dimodifikasi menggunakan <code>&lt;CR&gt;</code> .  Ini memungkinkan Anda untuk dengan cepat mengubah dan memulai kembali perintah atau mencari yang lama untuk digunakan kembali. <br><br><h4>  q /, q? </h4><br>  Sama seperti <code>q:</code> kecuali pencarian. <br><br><h4>  ctrl-I, ctrl-O </h4><br>  Pindah ke lokasi berikutnya atau sebelumnya di jumplist.  Berguna untuk pemeriksaan cepat dan kemudian mundur.  Sangat bagus untuk membaca file bantuan. <br><br><h2>  Makro </h2><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting ini</a> untuk wawasan lebih dalam tentang penggunaan makro. <br><br><h2>  Mode visual </h2><br><h4>  gv </h4><br>  Memilih item visual sebelumnya. <br><br><h4>  v_o </h4><br>  Pergi ke sisi lain dari blok visual.  Berguna jika Anda memulai satu baris terlalu rendah atau sesuatu seperti itu.  Dalam mode blok, ia pergi ke sudut diagonal yang berlawanan, dan menggunakan <code>v_O</code> untuk beralih ke <code>v_O</code> horizontal yang berlawanan. <br><br><h4>  g ctrl-A / ctrl-X </h4><br>  Dalam mode visual, ctrl-A hanya menambah angka pertama pada setiap baris.  Di sisi lain, <code>g ctrl-A</code> akan bertambah satu baris dengan setiap baris.  Ini jauh lebih mudah untuk dijelaskan dalam tabel: <br><br><div class="scrollable-table"><table><thead><tr><th>  <strong>dipilih</strong> </th><th> <code>ctrl-A</code> </th> <th> <code>g ctrl-A</code> </th> <th> <code>2 g ctrl-A</code> </th> </tr></thead><tbody><tr><td><pre>  a 0
 b 0
 c
 d 0 </pre></td><td><pre>  a 1
 b 1
 c
 d 1 </pre></td><td><pre>  a 1
 b 2
 c
 d 3 </pre></td><td><pre>  a 2
 b 4
 c
 d 6 </pre></td></tr></tbody></table></div><br><h4>  Operator: v, V, cv (: h o_v) </h4><br>  Anda mungkin tahu bahwa dalam mode visual Anda dapat memilih karakter (v), garis (V) dan blok (ctrl-V).  Tetapi ketiga kombinasi ini dapat digunakan sebagai operator gerak untuk fragmen yang sesuai.  Misalnya, Anda memiliki teks berikut: <br><br> <code>abc <br> abc <br> abc</code> <br> <br>  Jika Anda meletakkan kursor di atas <code>b</code> dan menekan <code>d2j</code> , itu akan menghapus ketiga baris, karena <code>j</code> memindahkan baris demi baris.  Jika <code>d&lt;cV&gt;2j</code> ditekan sebagai gantinya, gerakan menjadi blok demi blok dan hanya kolom tengah dengan tiga huruf <code>b</code> yang dihapus. <br><br>  Satu use case adalah delete in search.  Normal <code>d/</code> memindahkan karakter demi karakter.  Oleh karena itu, saya menggunakan <code>dV/</code> untuk gerakan baris demi baris dengan penghapusan.  Ada cara lain untuk melakukan ini: <br><br><h4>  / regex / {n} </h4><br>  Gerakan n garis di bawah pasangan, atau sebanyak baris jika nilainya negatif.  Sebagai efek samping, gerakan terjadi garis demi garis.  Jadi, jika Anda ingin menghapus baris pertama yang berkaitan dengan <code>regex</code> , Anda dapat memasukkan <code>d/regex//0</code> . <br><br><h2>  Mantan tim </h2><br>  Anda memasukkan ex-command dalam mode perintah, misalnya, perintah <code>:s</code> .  Selain penggantian, ada banyak perintah berguna lainnya.  Semua contoh ini memerlukan rentang, seperti <code>%</code> . <br><br><h4>  : g / regex / ex </h4><br>  Menjalankan perintah hanya pada baris yang cocok dengan ekspresi reguler.  Misalnya, Anda dapat memasukkan <code>g/regex/d</code> untuk menghapus semua baris yang cocok dengan regex.  Perintah <code>v</code> mirip dengan <code>g</code> , tetapi bekerja pada semua baris yang <i>tidak</i> cocok dengan ekspresi reguler. <br><br>  Trik menjadi lebih kuat dengan norma dan beberapa yang lain. <br><br><h4>  : norm {Vim} </h4><br>  Bertindak seolah-olah Anda menjalankan {Vim} di setiap baris rentang.  Sebagai contoh, <code>g/regex/norm f dw</code> akan menghapus kata pertama setelah spasi pertama di setiap baris yang berhubungan dengan ekspresi reguler regex.  Ini seringkali jauh lebih sederhana daripada makro. <br><br>  <code>norm</code> mematuhi semua perbandingan Anda.  Sebagai contoh, jika Anda menetapkan <code>jk</code> ke <code>&lt;esc&gt;</code> dalam mode insert, maka <code>norm I jk$diw</code> akan menambahkan spasi ke awal baris, <i>tinggalkan mode insert</i> , lalu hapus kata terakhir di baris tersebut.  Saya sangat suka fungsi ini, tetapi jika Anda memilih untuk tidak menggunakan pemetaan, maka Anda dapat menerapkan <code>norm!</code>  . <br><br><h4>  : co. </h4><br>  Menyalin rentang ke garis saat ini.  Anda juga dapat menentukan nilai arbitrer alih-alih suatu periode, misalnya, <code>+3</code> atau <code>'a. mv</code>  <code>'a. mv</code> untuk pindah. <br><br><h4>  : y {reg} </h4><br>  Menyalin rentang ke register <code>{reg}</code> .  Jika <code>{reg}</code> dikapitalisasi, ditambahkan ke kas yang ada.  yaitu tim seperti itu <br><br> <code>let @a = '' | %g/regex/y A</code> <br> <br>  akan menyalin ke semua baris yang sesuai dengan <code>regex</code> di seluruh file.  Ini membantu untuk mengekstrak teks yang rusak dari file dan menyalinnya ke clipboard sistem (menggunakan <code>let @+ = @a</code> ). <br><br><h4>  : windo {ex} </h4><br>  Menjalankan perintah di semua jendela.  Sebagai contoh <code>:windo $</code> semua jendela ke bawah.  Ada <code>bufdo</code> , <code>tabdo</code> , <code>tabdo</code> dan lainnya. <br><br>  Bekerja sangat baik dengan <code>g</code> dan <code>s</code> .  Untuk mengganti semua kombinasi <code>AA</code> dengan <code>BB</code> dengan pratinjau penggantian, Anda dapat memasukkan <code>vimgrep AA</code> dengan memuat semua pertandingan dalam perbaikan cepat dan kemudian <code>cdo s/AA/BB/cge</code> untuk mencari / mengganti semua pertandingan. <br><br><h2>  Vim untuk Extender </h2><br>  Tercantum di sini adalah trik yang memerlukan penyimpanan dalam pengaturan atau mengubah sesi Vim.  Hipotetis, mereka dapat digunakan dalam mode "puritan", hanya dengan memasukkan perintah, tetapi beberapa melibatkan perubahan yang cukup serius yang bertentangan dengan semangat purisme. <br><br>  Ini hanya yang paling tidak biasa.  Banyak orang menugaskan <code>H</code> pada tutup <code>^</code> , sehingga hal-hal seperti itu tidak layak disebutkan.  Juga, tidak masuk akal untuk berbicara tentang <code>vim-sensible</code> sense atau <code>vim-surround</code> , tetapi hanya tentang plugin yang lebih eksotis. <br><br>  Jika Anda terus-menerus mengkonfigurasi vimrc Anda, silakan sendiri dan tambahkan perintah terpisah untuk ini: <br><br> <code>command! Vimrc :vs $MYVIMRC</code> <br> <br><h2>  Pengaturan </h2><br>  Saya memiliki semua pengaturan, binding kunci dan fungsi yang disimpan dalam satu file vimrc.  Membagi menjadi beberapa file membuat pencarian menjadi sulit. <br><br>  Sebagian besar pengaturan sebenarnya bukan "trik".  Cara terbaik untuk melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vim-masuk akal</a> : hampir semua pengaturan dari sana akan sesuai dengan vimrc Anda. <br><br><h4>  atur lazyredraw </h4><br>  Jangan menggambar ulang layar di tengah makro (untuk meningkatkan kinerja). <br><br><h4>  atur smartcase / ignorecase </h4><br>  Dengan dua pengaturan ini, pencarian tanpa huruf kapital menjadi tidak peka huruf besar kecil, dan pencarian dengan huruf besar sensitif huruf besar-kecil. <br><br><h4>  atur undofile </h4><br>  Menyimpan tindakan, bahkan jika Anda menutup dan membuka Vim, sehingga tindakan undo selalu tersedia.  Sangat berguna dalam kombinasi dengan plugin undotree. <br><br><h4>  atur kolom lipat = {n} </h4><br>  Kolom sisi dengan blok yang diciutkan.  Semakin besar <code>n</code> , semakin banyak blok yang diciutkan ditampilkan di kolom, dan sisanya ditunjukkan. <br><br><h4>  set suffixesadd = {str} </h4><br>  <code>gf</code> biasanya berarti "pergi ke file di bawah kursor", tetapi membutuhkan ekstensi file di baris.  <code>suffixesadd</code> menambahkan ekstensi yang ditentukan.  Jika <code>suffixesadd=.md</code> , maka perintah <code>gf</code> pada baris 'foo' akan mencari file <code>foo</code> dan <code>foo.md</code> <br><br><h4>  set inccommand = nosplit </h4><br>  Hanya untuk Neovim.  <code>incommand</code> menunjukkan waktu nyata perubahan apa yang akan dilakukan tim.  Hanya <code>s</code> yang saat ini didukung, tetapi bahkan ini sangat berguna.  Jika Anda memasukkan <code>:s/regex</code> , semua kecocokan disorot.  Jika Anda kemudian menambahkan <code>/change</code> , itu akan menampilkan semua penggantian.  Bekerja dengan semua properti regex, termasuk backlink dan grup. <br><br><h3>  atur statusline (: h statusline) </h3><br>  Menentukan apa yang akan ditampilkan di panel di bagian bawah setiap jendela.  Di sini pemformatan jauh lebih rumit dan rumit daripada di pengaturan lain, jadi Anda harus menghabiskan waktu untuk menjelaskannya.  Ada beberapa trik sederhana.  Pertama, lihat bilah status Vim default: <br><br> <code>:set statusline=%&lt;%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P</code> <br> <br>  Di sini lebih mudah untuk mengganti <code>%P</code> (persentase file di atas kursor).  Format bilah status adalah nilai setelah tanda persen di kawat gigi.  Oleh karena itu, untuk file Penurunan harga, Anda dapat menulis ini: <br><br> <code>:set statusline=%&lt;%f\ %h%m%r%=%-14.(%l,%c%V%)\ %{wordcount()[\"words\"]}</code> <br> <br>  Dan ganti persentase file dengan jumlah kata dalam dokumen. <br><br>  Atau pasang <code>tabline</code> .  Jika Anda tidak menggunakan tab, maka baris ini dapat dibuat "garis status global".  Sebagai contoh <br><br> <code>set tabline=%{strftime('%c')}</code> <br> <br>  akan selalu menampilkan tanggal di atas. <br><br><h2>  Ikatan Kunci </h2><br>  Saya punya <i>banyak</i> ikatan. <br><br>  Banyak tombol praktis di Vim secara bodoh ditugaskan secara default.  Misalnya, menyimpan keystroke <code>s</code> identik dengan <code>cl</code> (saving one keystroke), dan <code>U</code> sama dengan <code>u</code> , kecuali untuk tulisan undo sebagai perubahan baru, yang secara fungsional tidak berguna.  <code>Q</code> identik dengan <code>gQ</code> dan bagaimanapun jebakan yang luar biasa.  <code>Z</code> hanya digunakan untuk <code>ZZ</code> dan <code>ZQ</code> .  Astaga, bahkan manual Vim merekomendasikan penugasan kembali <code>_</code> dan kunci untuk beberapa fungsi, karena "Anda mungkin tidak pernah menggunakannya."  Saya lebih suka tidak menyimpan satu klik, tetapi untuk menambahkan fungsi yang sama sekali baru ke keyboard.  Inilah beberapa ikatan saya: <br><br><h4>  nnoremap Q @@ </h4><br>  Tanpa memperlambat transisi ke mode ex, ulangi makro terakhir. <br><br><h4>  nnoremap s "_d </h4><br>  Itu membuat kunci <code>s</code> (dengan pengaturan yang sesuai untuk <code>ss</code> dan <code>S</code> ) berfungsi seperti d, hanya tanpa menyimpan teks yang dihapus dalam register.  Berguna agar tidak menyumbat register. <br><br><h4>  nnoremap &lt;cj&gt; &lt;cw&gt; j </h4><br>  Buka jendela di bawah ini.  Penugasan yang sesuai untuk <code>h</code> , <code>k</code> , <code>l</code> .  Bekerja dengan windows jauh lebih mudah. <br><br><h4>  nnoremap &lt;leader&gt; e: exe getline (line ('.')) &lt;cr&gt; </h4><br>  Jalankan baris saat ini seolah-olah itu adalah perintah.  Dalam eksperimen, seringkali lebih nyaman daripada <code>q:</code> <br><br><h2>  Argumen khusus (: argumen peta h) </h2><br>  Perintah <code>map &lt;buffer&gt; lhs rhs</code> mengaktifkan pemetaan kunci untuk buffer ini saja.  Ini benar-benar bekerja dengan nyaman dengan perintah otomatis sebagai kombinasi tombol sementara atau ketika mendefinisikan tugas melalui suatu fungsi.  Tugas penyangga diutamakan daripada tugas global, yaitu, Anda dapat mengabaikan perintah umum yang lebih berguna dalam situasi tertentu. <br><br>  <code>map &lt;expr&gt; {lhs} {expr}</code> memeriksa <code>{expr}</code> dan menggunakan nilai kembali sebagai pemetaan ulang kunci.  Satu use case sederhana adalah mengikat berdasarkan kondisi.  Saya punya ini: <br><br> <code>nnoremap &lt;expr&gt; k (v:count == 0 ? 'gk' : 'k') <br> nnoremap &lt;expr&gt; j (v:count == 0 ? 'gj' : 'j')</code> <br> <br>  Yang membuat <code>j</code> dan <code>k</code> bergerak sepanjang garis <i>sampai</i> angka ditemukan, dan setelah itu kunci dibatalkan.  Oleh karena itu, saya dapat menavigasi paragraf panjang prosa tanpa melanggar kombinasi seperti <code>10j</code> . <br><br>  Argumen <code>&lt;silent&gt;</code> membantu jika ada binding yang menjalankan perintah ex. <br><br><h2>  inoremaps </h2><br>  Berkat <code>inoremap</code> binding berfungsi dalam mode insert.  Di sana mereka mulai bekerja, jadi <code>inoremap ;a aaaa</code> akan memperkenalkan 'aaaa' bukan '; a'.  Jika Anda ingin melakukan sesuatu dalam mode normal, gunakan <code>&lt;cO&gt;</code> .  Misalnya, kalau sudah <br><br> <code>inoremap ;1 &lt;co&gt;ma</code> <br> <br>  maka <code>;1</code> mengatur <code>'a</code> . <br><br>  Saya suka menentukan untuk menggunakan titik koma sebagai kunci untuk penugasan kembali, karena dalam teks normal hampir selalu ada spasi atau baris baru setelah titik koma. <br><br><h2>  autocmd </h2><br>  Perintah otomatis sangat bagus untuk konfigurasi.  Biasanya Anda mengonfigurasinya seperti ini: <br><br><pre> <code class="plaintext hljs">augroup {name} autocmd! " Prevents duplicate autocommands au {events} {file regex} {command} augroup END</code> </pre> <br>  Kemudian, jika salah satu peristiwa {events} terjadi di file {file regex}, perintah {command} akan menyala.  Acara terdaftar <code>:h event</code> .  Misalnya, jika Anda menulis <br><br><pre> <code class="plaintext hljs">augroup every autocmd! au InsertEnter * set norelativenumber au InsertLeave * set relativenumber augroup END</code> </pre> <br>  maka vim akan menonaktifkan relativenumber hanya untuk mode penyisipan. <br><br>  Perintah <code>au {event} &lt;buffer&gt; {ex}</code> berlaku perintah otomatis untuk buffer saat ini.  Terkadang saya menggunakan ini untuk menambahkan event handler jangka pendek ke file tertentu. <br><br><h3>  BufNewFile, BufRead </h3><br>  <code>BufnewFile</code> dimulai ketika file baru dibuat, <code>BufRead</code> - ketika buffer pertama kali dibuka.  Mereka biasanya digunakan untuk menambahkan parameter dan memetakan kembali ke tipe file tertentu.  Saya punya satu seperti: <br><br><pre> <code class="plaintext hljs">augroup md autocmd! au BufNewFile,BufRead *.md syntax keyword todo TODO au BufNewFile,BufRead *.md inoremap &lt;buffer&gt; ;` ```&lt;cr&gt;&lt;cr&gt;```&lt;Up&gt;&lt;Up&gt; augroup END</code> </pre> <br>  Hanya dalam file Penurunan harga adalah garis TODO disorot, dan karakter <code>;`</code> dalam mode insert menambahkan notasi kode. <br><br>  Tim otomatis memungkinkan Anda melakukan hal-hal yang jauh lebih rumit.  Sebagai contoh, <code>au</code> untuk <code>BufWriteCmd</code> mengesampingkan penghematan standar, memungkinkan Anda untuk mengimplementasikan logika khusus.  Ini melampaui "trik" dan masuk ke ranah "sihir gelap". <br><br><h2>  Plugin </h2><br>  Kebanyakan orang tahu tentang plugin populer seperti <code>vim-surround</code> dan <code>NERDtree</code> .  Berikut adalah daftar dari beberapa yang sedikit diketahui yang menurut saya sangat berguna. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Undotree</a> </h3><br>  Di sebagian besar editor teks, tindakan undo terjadi secara linear.  Jika Anda membuat perubahan ke A, batalkan, lalu buat perubahan ke B, maka A hilang selamanya.  Namun, Vim menyimpan seluruh pohon tindakan yang dibatalkan.  Perintah <code>u</code> memutar kembali tindakan di cabang pohon saat ini, dan <code>g</code> pergi ke versi <i>kronologis</i> sebelumnya.  Anda dapat melihat daftar tindakan yang dibatalkan dengan perintah <code>:undolist</code> . <br><br>  Tetapi format ini tidak begitu jelas.  Adalah jauh lebih baik untuk melihat pohon yang sebenarnya.  Inilah yang <code>Undotree</code> lakukan: memaparkan representasi ASCII yang baik dari pohon tindakan yang dibatalkan dengan navigasi yang mudah. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vim.swap</a> </h3><br>  Plugin ini menyediakan perintah untuk bertukar argumen, sehingga Anda dapat mengganti <code>(a, f(b, c))</code> dengan <code>(f(b, c), a)</code> dalam beberapa penekanan tombol.  Saya secara teratur harus melakukan penyuntingan, jadi ini adalah peningkatan besar dalam kualitas hidup. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Neoterm</a> </h3><br>  Menghubungkan API tingkat lebih tinggi ke terminal tertanam neo / vim.  Sebagai contoh <code>:T {text}</code> mengirim {text} ke konsol.  Baik untuk menciptakan lingkungan yang interaktif. <br><br><h2>  "TODO {{{ </h2><br>  Banyak topik tidak tercakup dalam artikel ini karena terlalu teknis atau perlu dijelaskan secara rinci, seperti penulisan fungsi atau sistem sintaksis.  Dan saya tidak tahu banyak.  Saya ingin mempelajari topik-topik berikut secara lebih rinci: <br><br><h3>  Pratinjau, Perbaikan Cepat, dan Daftar jendela </h3><br>  Terkadang saya menggunakan alat dengan windows ini, tetapi saya tidak tahu bagaimana cara memanipulasi mereka.  Saya ingin menambahkan kesalahan perbaikan cepat ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin TLA +</a> saya.  Saya juga menyukai gagasan untuk meletakkan informasi pendukung dan perintah panggilan balik di jendela pratinjau.  Ini membuka beberapa kemungkinan yang sulit untuk direproduksi dalam IDE. <br><br><h2>  API Neovim </h2><br>  Neovim menawarkan API canggih untuk mengintegrasikan Vim dengan program eksternal.  Skrip Python Anda dapat mengirim perintah ke instance Neovim, dan Anda dapat mengontrol editor melalui server, misalnya.  Saya melihat beberapa demo konseptual keren di mana pelengkapan otomatis terjadi berdasarkan informasi di browser.  Sepertinya sangat keren! <br><br><h2>  Objek teks </h2><br>  Tidak pernah dibuat seperti itu. <br><br><hr><br>  Jadi, ini adalah gambaran singkat dari beberapa fungsi implisit Vim.  Semoga Anda menemukan sesuatu yang bermanfaat! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454742/">https://habr.com/ru/post/id454742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454732/index.html">5 Teknik Prioritas yang Kuat untuk Tim TI</a></li>
<li><a href="../id454734/index.html">Cadangan, Bagian 4: Tinjauan Umum dan Pengujian zbackup, restic, borgbackup</a></li>
<li><a href="../id454736/index.html">Dukungan Visual Studio 2019 di PVS-Studio</a></li>
<li><a href="../id454738/index.html">Dukungan Visual Studio 2019 dalam PVS-Studio</a></li>
<li><a href="../id454740/index.html">Mei 2019 Pencernaan Joomla</a></li>
<li><a href="../id454744/index.html">Tinjauan Java Track Reports dari RigaDevDays Conference</a></li>
<li><a href="../id454748/index.html">Panduan Kelangsungan Hidup MongoDB</a></li>
<li><a href="../id454750/index.html">UI cepat - berlari kencang di seluruh Eropa</a></li>
<li><a href="../id454754/index.html">Kapan perlu memeriksa hipotesis efektivitas yang tidak kalah pentingnya?</a></li>
<li><a href="../id454756/index.html">Memeriksa efektivitas pengaturan situs dan iklan, biaya menarik pelanggan dari perusahaan grosir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>