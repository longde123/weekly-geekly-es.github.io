<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§’ğŸ¼ ğŸ ğŸ‘ğŸ¾ Membalikkan cornice listrik AM82TV ğŸ¤¸ğŸ» ğŸ‘©â€âœˆï¸ ğŸ‘¨â€ğŸ‘§â€ğŸ‘§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya punya beberapa batang tirai listrik Akko - AM82TV. Model ini menonjol dari saudara-saudaranya dengan set antarmuka manajemen yang paling lengkap....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membalikkan cornice listrik AM82TV</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464657/"> Saya punya beberapa batang tirai listrik Akko - AM82TV.  Model ini menonjol dari saudara-saudaranya dengan set antarmuka manajemen yang paling lengkap.  Tirai dapat dikontrol oleh radio, ada "kontak kering", kontrol fase-demi-fase (dengan menyingkat kabel kontrol ke jaringan).  Ada antarmuka RS485 - ini jika Anda ingin menghubungkan tirai ke "rumah pintar".  Anda juga dapat membuka / menutup tirai hanya dengan menariknya dengan tangan ke arah yang diinginkan.  "Out of the box" hilang, mungkin, hanya antarmuka berbasis web, well, dan MQTT. <br><br>  Saya sudah lama memiliki batang tirai listrik yang bekerja dengan baik, tetapi dari waktu ke waktu keinginan mulai muncul untuk membongkar mereka - karena penasaran untuk melihat apa yang ada di dalamnya dan apakah mungkin untuk memasukkan ESP8266 (atau ESP32) ke dalamnya untuk menambahkan yang hilang.  Anda tentu saja dapat menghubungkan segala sesuatu dari luar, tetapi lebih baik jika tampilannya tetap sama dan semuanya tersembunyi di dalam. <br><br>  Jangan memperbaiki apa yang tidak rusak - ini bukan tentang saya.  Pada awalnya saya mencoba mengusir ide-ide buruk dari diri saya sendiri, tetapi seiring waktu, rasa gatal semakin intensif dan sekarang, saatnya tiba ketika sudah tidak mungkin untuk melawannya.  Saya mengambil motor dari atap dan membongkarnya.  Inspeksi awal seharusnya memberikan jawaban untuk dua pertanyaan: apakah ada ruang untuk ESP8266 dan apakah mungkin untuk menggunakan catu daya bawaan.  Semuanya beres dengan mudah.  Cukup dengan membuka beberapa sekrup dari ujung motor.  Satu-satunya hal adalah bahwa slot sekrup tidak dibuat dengan obeng, tetapi dengan kunci pas hex torx.  Setelah itu, Anda dapat mengekstraksi konten - motor pengumpul di satu rumah dengan gearbox dan sensor poros motor, catu daya 24 volt dan papan kontrol. <br><a name="habracut"></a><br>  Ada tempat untuk ESP, catu daya dirancang untuk motor yang kuat dan tidak akan melihat beban tambahan kecil.  Saya mulai mempertimbangkan papan kontrol dan pemikiran tentang ESP mulai memudar ke latar belakang - mikrokontroler atmega168 adalah jantung dari papan.  Jika tidak ada kontak di papan tulis untuk memasang konektor ISP (antarmuka pemrograman dalam-sirkuit mikrokontroler) ini tidak akan menghentikan saya, tetapi mereka ada di sana.  Agar Anda mengerti saya dengan benar, saya bukan penggemar avr sama sekali.  Saya tidak punya programmer dan saya belum menulis satu baris kode untuk atmega mikrokontroler.  Saya sangat membutuhkan programmer untuk mencoba membaca firmware, tetapi itu di malam hari dan tidak ada cara untuk membeli sesuatu di toko sekarang.  Agar tidak menunggu sampai pagi, saya mengumpulkan programmer Gromov.  Kemudian dia menyolder konektor ISP pada papan kontrol, menghubungkan programmer dan mencoba membaca firmware - dan itu dihitung. <br><br>  Tidak mungkin untuk mencoba memahami sesuatu dalam firmware mikrokontroler tanpa memahami diagram rangkaian.  Karena itu, pada papan sirkuit tercetak, saya memulihkan sirkuit.  Saya tidak sering harus menggambar diagram.  Agar tidak menggambar elemen yang ada di papan tulis, tetapi tidak di perpustakaan standar, saya menggambar diagram di easyeda.  Ya, ternyata tidak sesuai dengan GOST (tetapi mikrokontroler digambarkan seperti dalam dokumentasi, yang nyaman).  Sebuah fragmen sudah cukup untuk memahami: <br><br> <a href=""><img src="https://habrastorage.org/webt/wi/ir/m7/wiirm7nkx-rp1gz5smrd9ojrvqu.png"></a> <br><br>  Selanjutnya, sebagian besar gambar dapat diklik. <br><br>  Jika mau, Anda dapat membiasakan diri dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema lengkap</a> . <br><br>  Setelah itu, saya siap untuk meneliti firmware.  Cukup menerjemahkan kode mesin ke mnemonik assembler tidak cukup untuk analisis.  Anda perlu melihat status register dan memori di setiap titik dalam program.  Sayangnya, debugging pada mikrokontroler itu sendiri tidak dimungkinkan dengan atmega168, tetapi Anda dapat memuat firmware ke dalam simulator.  Sangat tidak nyaman jika Anda ingin "merasakan" setrika asli dari pengikat mikrokontroler, tetapi mari kita selesaikan dengan apa yang kita miliki.  Saya tidak menginstal Atmel Studio 7. Saya memutuskan bahwa AVR Studio 4 yang lebih ringkas sudah cukup. Pada prinsipnya, satu Studio sudah cukup untuk analisis, tetapi dimungkinkan untuk mentransfer beberapa operasi rutin ke perangkat lunak lain.  Pada bulan Maret, alat reverse engineering <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, Ghidra,</a> diterbitkan.  Saya membutuhkan alasan, beberapa tugas praktis, untuk mengenalnya.  Ini hanya sebuah peluang.  Setiap alat secara individual - AVR Studio 4 dan Ghidra saya mendapat sedikit buggy.  AVR Studio, dengan beberapa transisi subprogram bersarang, mungkin tiba-tiba berhenti menampilkan alamat transisi yang benar dalam perintah (alamat menjadi nol).  Ghidra terkadang tersesat dalam analisis pengindeksannya.  Tetapi menggunakan kedua alat sekaligus memungkinkan untuk dengan cepat mengidentifikasi penyebab keanehan ini. <br><br>  Menggali tanpa tujuan dalam firmware tidak terlalu menarik.  Lebih baik jika ada tugas tertentu.  Di atas, penasaran mungkin adalah analisis protokol pertukaran untuk RS485 dan protokol kontrol melalui udara.  Saya memutuskan untuk mempelajari protokol radio. <br><br>  Sekali waktu, saya telah mengambil sinyal yang dikirim oleh remote control radio dan menganalisisnya. <br><br>  Saluran radio satu arah.  Motor hanya dapat menerima sinyal dan tidak mengkonfirmasi penerimaan perintah.  Tidak mungkin untuk menginterogasi keadaan cornice listrik di udara.  Pada level fisik, hanya ada penerima sinyal radio.  Tidak ada pemancar di motor.  Sinyal ditransmisikan oleh remote control radio pada frekuensi 433,92 MHz.  Dikodekan oleh manipulasi amplitudo.  Perintah terdiri dari bit mulai bentuk khusus, alamat + saluran dan perintah itu sendiri.  Secara grafis, seluruh sinyal dapat direpresentasikan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/ca/6g/mg/ca6gmgjm3gdp9dkji_5elztulks.png"><br><br>  Saluran dapat dianggap sebagai bagian dari alamat.  Jika Anda mengirim perintah pada saluran nol, itu akan dieksekusi oleh semua perangkat dengan alamat yang diberikan, tetapi dengan saluran yang berbeda.  Lebih mudah jika Anda perlu mentransfer perintah segera ke kelompok batang tirai listrik. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca lebih lanjut tentang protokol radio</a> . <br><br>  Menganalisis bagaimana remote control mentransmisikan perintah, saya sudah tahu kode dari empat tim.  Tidak terlalu banyak, jika dibandingkan dengan kemungkinan mengendalikan tirai listrik melalui RS485.  Saya ingin memastikan bahwa semua tim diidentifikasi dan bahwa tidak ada "telur Paskah" atau tim layanan. <br><br>  Pendekatan analisisnya sederhana.  Diagram sirkuit menunjukkan port mana dari mikrokontroler yang terhubung ke perangkat fisik.  File firmware diuraikan dalam Ghidra.  Ini nyaman - banyak operasi rutin dilakukan secara otomatis.  Setelah menganalisis operasi sepotong kode atau subprogram tertentu, diberikan nama yang bermakna.  Selanjutnya, cuplikan kode dan tangkapan layar akan saya bawa dari Ghidra.  Ketika tumpul, jalankan kode dalam simulator.  Dalam situasi yang sangat rumit, Anda harus menggambar. <br><br>  Untuk memastikan bahwa nama-nama register perangkat atmega168 ditampilkan dengan benar selama pembongkaran, saya mengoreksi file avr8.pspec.  Dalam cara yang baik, akan perlu untuk membuat file dengan nama yang berbeda, tetapi saya tidak memerlukan file ini dalam bentuk aslinya dan saya mengoreksi yang sebelumnya. <br>  Firmware dimulai dengan vektor interupsi.  Yang pertama adalah vektor transisi ke awal program.  Ini terlihat seperti ini: <br><br> <a href=""><img src="https://habrastorage.org/webt/wd/xm/sj/wdxmsj86gebhtuz_wpne3yamgyc.png"></a> <br><br>  Kebanyakan interupsi tidak digunakan.  Jika karena alasan tertentu gangguan seperti itu terjadi, perintah kembali akan segera dieksekusi.  Selain memproses interupsi untuk reset, interupsi untuk meluap Timer 0, penyelesaian penerimaan, dan kesiapan mentransmisikan byte data berikutnya ke USART juga diproses.  Pertukaran RS485 tidak menarik bagi kami sekarang, tetapi timer overflow perlu ditinjau. <br><br>  Tentu saja, sebelum interupsi timer diaktifkan, timer itu sendiri harus dikonfigurasi.  Saya tidak mulai mencari di kode yang dibongkar untuk tempat inisialisasi terjadi.  Dalam simulator, saya menetapkan breakpoint di alamat 0x1fc - ini adalah alamat yang dicatat dalam interrupt handler.  Saya memulai program, mendapat lonjakan dan hanya melihat apa yang tertulis di register.  Kunci pilihan untuk timr0 diatur ke clk / 8.  Dengan kuarsa pada papan 8 MHz, pulsa dengan frekuensi 1 MHz tiba di timer. <br><br>  Mulai dari interrupt handler: <br><br> <a href=""><img src="https://habrastorage.org/webt/mp/ag/-k/mpag-kzg9d5owsklnddy4smfhwe.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">Grafik fungsi penangan interrupt birdwatch</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vt/o0/nc/vto0ncy5nmggxhbccz-3hw-slm4.png" alt="gambar"><br></div></div><br>  Timer meluap setiap 107 Î¼s.  Antara lain, pengendali interupsi memproses sinyal dari output penerima sinyal radio.  Jika sinyal berhasil lulus tes, data yang diterima ditulis ke buffer pada 0x4af.  Ukuran buffer adalah 6 byte.  Ini satu byte lebih dari yang diperlukan untuk menerima empat byte alamat + saluran dan byte perintah.  Mungkin byte keenam dari protokol radio dimaksudkan untuk checksum, tetapi berhenti berkembang.  Terkadang itu terjadi.  Mungkin dimaksudkan untuk melengkapi data beberapa perintah.  Dalam protokol kontrol cornice listrik RS485, ada perintah untuk menutup sebagian gorden.  Dalam hal ini, byte tambahan ditransmisikan dengan data tentang jumlah penutupan dalam persen.  Tim serupa bisa ada dalam protokol radio.  Program utama diinformasikan tentang kesiapan data dengan menetapkan bendera - unit ditulis ke alamat 0x4bd. <br><br>  Ini melengkapi analisis interupsi dan melanjutkan ke program utama. <br><br>  Grafik fungsi saat bernavigasi ke alamat 0x1304 ringkas dan sederhana: <br><br><img src="https://habrastorage.org/webt/an/5s/m9/an5sm9h8f8cpzqgbrmnd4degjr4.png" alt="gambar"><br><br>  Kita perlu di "utama".  Kami telah menganalisis interupsi dan memahami bahwa jika karena alasan tertentu kami tiba-tiba kembali dari main dan masuk ke "go_to_sleep", maka mimpi ini akan lesu - tirai listrik akan berhenti melakukan sesuatu yang bermanfaat.  Mungkin, saat menulis firmware, templat yang sudah jadi digunakan dan artefak tetap ada setelahnya. <br><br>  Secara utama, kita perlu menemukan tempat di mana buffer 0x4af diakses.  Anda tidak harus mencari untuk waktu yang lama.  Secara harfiah setelah beberapa perintah, sebuah subrutin dipanggil, dimulai dengan alamat 0x11b3, di mana buffer ini disalin dan diproses. <br><br>  Grafik fungsi dari prosedur rf_signal_buffer_processing (0x11b3): <br><br> <a href=""><img src="https://habrastorage.org/webt/iy/nk/iu/iynkiuxnofmxm32ouji-qfbfzdy.png"></a> <br><br>  Ini persis tempat yang kita butuhkan, tetapi terlihat agak rumit.  Untuk mengerti, saya mulai menggambar.  Sesuatu seperti bagan alur. <br><br>  Hal pertama yang terjadi di sini adalah bahwa data dari buffer 0x4af disalin ke alamat baru - 0x49f dan flag 0x4bd diatur ulang: <br><br> <a href=""><img src="https://habrastorage.org/webt/op/bh/lj/opbhljbg5zjnsxr4_pqriv6zk0s.png"></a> <br><br>  Cuplikan berikut adalah yang paling menarik: <br><br> <a href=""><img src="https://habrastorage.org/webt/-u/03/uf/-u03ufrcwodmxwpiyp6u0p-xzya.png"></a> <br><br>  Faktanya, ini adalah keseluruhan verifikasi dari perintah yang diterima melalui udara.  Meskipun ini tidak jelas, tetapi analisis lebih lanjut menunjukkan bahwa transisi ke cabang berikutnya adalah pemrosesan perintah radio berikut jika perintah 0xcc diterima sebelum itu - beralih ke mode pengaturan.  Saya tertarik pada kode baru dari tim itu sendiri.  Apakah ada sesuatu selain kode perintah 0x11, 0x33, 0x55 dan 0xcc. <br><br>  Baik di sini maupun lebih jauh saya tidak dapat menemukan pemrosesan byte terakhir - keenam dari perintah.  Dalam gambar, dicoret dengan warna merah.  Jadi semua tim terdiri dari lima byte.  Setidaknya dalam firmware AM82TV. <br><br>  Hal pertama yang kita lihat adalah memeriksa byte kelima dari buffer - kode dari perintah itu sendiri.  Di sini, tampaknya, ada kode perintah baru - 0xad dan 0xda.  Perintah dari buffer berhasil lulus tes jika bidang alamat cocok dengan salah satu alamat yang sudah direkam dalam eeprom, atau jika kode perintah adalah 0xad, atau 0xda dan bidang alamat == 0xaaaaaaaa. <br><br><div class="spoiler">  <b class="spoiler_title">Gambar yang tersisa</b> <div class="spoiler_text"> <a href=""><img src="https://habrastorage.org/webt/of/6n/yd/of6nydabymjwd0-ysfdbwkyfcxk.png"></a> <br><br> <a href=""><img src="https://habrastorage.org/webt/-9/00/tp/-900tp2w_m-zrbzpagx5okojagq.png"></a> <br><br> <a href=""><img src="https://habrastorage.org/webt/zb/fq/uj/zbfqujb6gxqybjtotgbkws3as_q.png"></a> <br><br> <a href=""><img src="https://habrastorage.org/webt/jw/dp/1l/jwdp1lmpmdf97sikdteuuauxovc.png"></a> <br><br><img src="https://habrastorage.org/webt/so/nx/u5/sonxu5zkskxkpw_c_mgultqp7ic.png" alt="gambar"><br></div></div><br>  Ya, kami akan mempertimbangkan bahwa kami berhasil lulus tes berikutnya.  Sekarang kode perintah terletak di 0x4bf.  Kita perlu menemukan bagaimana isi byte ini diproses.  Ada beberapa cara untuk melakukan ini.  Yang paling sederhana adalah pencarian teks pada kode yang dibongkar di Ghidra.  Tetap melihat persis di mana isi byte ini dibaca.  Ini bukan cara yang dijamin untuk menemukan semua panggilan, tetapi dalam kasus khusus ini akan berfungsi.  Jadi, pertama, kita akan melihat pembacaan byte dalam prosedur mulai dari 0x1262: <br><br><img src="https://habrastorage.org/webt/cz/pf/in/czpfinnhxrqxoghowvdcrkamj8i.png" alt="gambar"><br><br>  Akses yang berasal dari satu tempat - tim yang terletak di 0x5e0. <br><br>  Grafik fungsi: <br><br><img src="https://habrastorage.org/webt/d_/mi/wy/d_miwyhmpmtxxuktt97yhnlvh6o.png" alt="gambar"><br><br>  Sayang sekali, tetapi semua kode perintah, kecuali yang sudah dikenal: 0x11, 0x33, 0x55 dan 0xcc dibuang dalam prosedur ini.  Bahkan kode 0xad dan 0xda ditemukan pada langkah sebelumnya.  Setidaknya saya tidak berhasil menemukan kode baru perintah radio di firmware cornice listrik AM82TV. <br><br>  Namun demikian, ada akses ke firmware, dapat dibongkar, lihat bagaimana fungsi spesifik diimplementasikan dan mengubah sesuatu untuk Anda sendiri.  Atau bahkan menambahkan sesuatu. <br><br>  Firmware dan file avr8.pspec yang dimodifikasi untuk atmega168 diposting di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464657/">https://habr.com/ru/post/id464657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464645/index.html">Bagaimana mengkonfigurasi PVS-Studio di Travis CI menggunakan emulator konsol game PSP sebagai contoh</a></li>
<li><a href="../id464647/index.html">Surat Kabar Harry Potter</a></li>
<li><a href="../id464649/index.html">Sistem Kolaborasi Dokumen untuk Zimbra Open-Source Edition</a></li>
<li><a href="../id464651/index.html">Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 5</a></li>
<li><a href="../id464655/index.html">Bagaimana gaji dan popularitas bahasa pemrograman telah berubah selama 2 tahun terakhir</a></li>
<li><a href="../id464659/index.html">Keamanan Aplikasi, atau Cara Menanamkan Keamanan dalam Pengembangan Kustom. Pengalaman pribadi di AGIMA</a></li>
<li><a href="../id464661/index.html">Kepada siapa dipercayakan desain peralatan teknis dan fasilitas rekonstruksi</a></li>
<li><a href="../id464665/index.html">Partisi dalam SQL Server</a></li>
<li><a href="../id464671/index.html">Menerima SMS biasa ke Viber dan Telegram instant messenger (menggunakan gateway GoIP)</a></li>
<li><a href="../id464673/index.html">TinyFL - driver senter mikrokontroler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>