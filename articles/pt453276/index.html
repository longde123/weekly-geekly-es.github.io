<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🏭 🤞🏼 🏂🏿 Arduino e interrupções do timer 🌅 🎻 🧓🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Apresento a você a tradução do artigo "Timer interrompe" por E. 
 Prefácio 


 A placa Arduino permite que você resolva rápida e minimamente...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduino e interrupções do timer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453276/"><p>  Olá Habr!  Apresento a você a tradução do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Timer interrompe"</a> por E. </p><br><h3 id="predislovie">  Prefácio </h3><br><p>  A placa Arduino permite que você resolva rápida e minimamente uma variedade de problemas.  Mas onde são necessários intervalos de tempo arbitrários (pesquisa periódica de sensores, sinais PWM de alta precisão, pulsos de longa duração), as funções padrão de atraso da biblioteca não são convenientes.  Durante a duração da ação, o esboço é suspenso e torna-se impossível gerenciá-lo. </p><br><p>  Em uma situação semelhante, é melhor usar os temporizadores AVR integrados.  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo bem-sucedido</a> informa como fazer isso e não se perde na natureza técnica das planilhas de dados, cuja tradução é trazida à sua atenção. </p><br><p><img src="https://habrastorage.org/webt/3g/n_/iw/3gn_iwqe-tubwgqslsclzuaznki.png"></p><a name="habracut"></a><br><p>  Este artigo discute os temporizadores AVR e Arduino e como usá-los em projetos e circuitos do usuário do Arduino. </p><br><h3 id="chto-takoe-taymer">  O que é um temporizador? </h3><br><p> Como na vida cotidiana dos microcontroladores, um timer é algo que pode sinalizar no futuro, no momento que você definir.  Quando esse momento chegar, o microcontrolador será interrompido, lembrando-o de fazer algo, por exemplo, para executar um determinado pedaço de código. </p><br><p>  Os temporizadores, como interrupções externas, funcionam independentemente do programa principal.  Em vez de fazer um loop ou repetir a chamada de atraso <em>millis ()</em> , você pode atribuir um timer para fazer seu trabalho enquanto seu código faz outras coisas. </p><br><p>  Portanto, suponha que exista um dispositivo que precise fazer algo, por exemplo, piscar um LED a cada 5 segundos.  Se você não usa temporizadores, mas escreve um código normal, precisa definir uma variável no momento em que o LED acende e verificar constantemente se o momento de sua comutação chegou.  Com uma interrupção do cronômetro, você só precisa configurar a interrupção e iniciar o cronômetro.  O LED piscará exatamente na hora certa, independentemente das ações do programa principal. </p><br><h3 id="kak-rabotaet-taymer">  Como o temporizador funciona? </h3><br><p>  Ele atua incrementando uma variável chamada <em>registro de contagem</em> .  O registro de contagem pode contar até um determinado valor, dependendo do seu tamanho.  O temporizador incrementa seu contador repetidamente até atingir seu valor máximo; nesse ponto, o contador transborda e redefine para zero.  Um cronômetro geralmente define um bit de sinalizador para que você saiba que ocorreu um estouro. </p><br><p>  Você pode verificar esse sinalizador manualmente ou pode alternar o temporizador - causar uma interrupção automaticamente quando o sinalizador estiver definido.  Como qualquer outra interrupção, você pode atribuir uma <em>ISR</em> ( <em>Interrupt Service Routine</em> ) para executar o código especificado quando o timer estourar.  O próprio ISR limpará o sinalizador de estouro, portanto, usar interrupções geralmente é a melhor opção devido à sua simplicidade e velocidade. </p><br><p>  Para aumentar os valores do contador em intervalos de tempo exatos, o temporizador deve estar conectado à fonte do relógio.  A fonte do relógio gera um sinal constantemente repetido.  Cada vez que o timer detecta esse sinal, ele aumenta o valor do contador em um.  Como o timer funciona em uma fonte de relógio, a menor unidade de tempo mensurável é o período do ciclo.  Se você conectar um sinal de clock de 1 MHz, a resolução do timer (ou período do timer) será: </p><br><p>  T = 1 / f (f é a frequência do relógio) <br>  T = 1/1 MHz = 1/10 ^ 6 Hz <br>  T = (1 ∗ 10 ^ -6) s </p><br><p>  Assim, a resolução do cronômetro é um milionésimo de segundo.  Embora você possa usar uma fonte de relógio externa para temporizadores, na maioria dos casos a fonte interna do próprio chip é usada. </p><br><h3 id="tipy-taymerov">  Tipos de temporizador </h3><br><p>  Nas placas Arduino padrão em um chip AVR de 8 bits, existem vários temporizadores ao mesmo tempo.  Os chips Atmega168 e Atmega328 possuem três temporizadores Timer0, Timer1 e Timer2.  Eles também têm um cronômetro de vigilância que pode ser usado para proteger contra falhas ou como um mecanismo de redefinição de software.  Aqui estão alguns recursos de cada timer. </p><br><p>  Timer0: <br>  Timer0 é um timer de 8 bits, o que significa que seu registro de contagem pode armazenar números de até 255 (ou seja, um byte não assinado).  O Timer0 é usado pelas funções temporárias padrão do Arduino, como <em>delay ()</em> e <em>millis ()</em> , portanto, é melhor não confundi-lo se você se importar com as consequências. </p><br><p>  Timer1: <br>  Timer1 é um timer de 16 bits com um valor máximo de contagem de 65535 (número inteiro não assinado).  Esse timer usa a biblioteca Servo Arduino, lembre-se disso se você o usar em seus projetos. </p><br><p>  Timer2: <br>  O Timer2 é de 8 bits e é muito semelhante ao Timer0.  É usado na função <em>tone ()</em> do Arduino. </p><br><p>  Timer3, Timer4, Timer5: <br>  Os chips ATmega1280 e ATmega2560 (instalados nas variantes Arduino Mega) possuem três temporizadores adicionais.  Todos eles são de 16 bits e funcionam de maneira semelhante ao Timer1. </p><br><h3 id="konfiguraciya-registrov">  Registrar a configuração </h3><br><p>  Para usar esses temporizadores, o AVR possui registros de configurações.  Os temporizadores contêm muitos desses registros.  Dois deles - registros de controle de timer / contador contêm variáveis ​​de configuração e são chamados de TCCRxA e TCCRxB, onde x é o número do timer (TCCR1A e TCCR1B, etc.).  Cada registro contém 8 bits e cada bit armazena uma variável de configuração.  Aqui estão os detalhes da folha de dados do Atmega328: </p><br><div class="scrollable-table"><table><thead><tr><th>  TCCR1A </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>  Bit </td><td>  7 </td><td>  6 </td><td>  5 </td><td>  4 </td><td>  3 </td><td>  2 </td><td>  1 </td><td>  0 0 </td></tr><tr><td>  0x80 </td><td>  COM1A1 </td><td>  COM1A0 </td><td>  COM1B1 </td><td>  COM1B0 </td><td>  - </td><td>  - </td><td>  Wgm11 </td><td>  Wgm10 </td></tr><tr><td>  Readwrite </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  R </td><td>  R </td><td>  Rw </td><td>  Rw </td></tr><tr><td>  Valor inicial </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  TCCR1B </th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>  Bit </td><td>  7 </td><td>  6 </td><td>  5 </td><td>  4 </td><td>  3 </td><td>  2 </td><td>  1 </td><td>  0 0 </td></tr><tr><td>  0x81 </td><td>  ICNC1 </td><td>  CIEM1 </td><td>  - </td><td>  Wgm13 </td><td>  Wgm12 </td><td>  CS12 </td><td>  CS11 </td><td>  CS10 </td></tr><tr><td>  Readwrite </td><td>  Rw </td><td>  Rw </td><td>  R </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td><td>  Rw </td></tr><tr><td>  Valor inicial </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr></tbody></table></div><br><p>  Os mais importantes são os últimos três bits no TCCR1B: CS12, CS11 e CS10.  Eles determinam a frequência do relógio do temporizador.  Escolhendo-os em diferentes combinações, você pode ordenar que o timer atue em velocidades diferentes.  Aqui está uma tabela de dados descrevendo o efeito dos bits selecionados: </p><br><div class="scrollable-table"><table><thead><tr><th>  CS12 </th><th>  CS11 </th><th>  CS10 </th><th>  Acção </th></tr></thead><tbody><tr><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  Nenhuma fonte de relógio (temporizador / contador parado) </td></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  1 </td><td>  clk_io / 1 (sem divisão) </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  clk_io / 8 (divisor de frequência) </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  clk_io / 64 (divisor de frequência) </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  0 0 </td><td>  clk_io / 256 (divisor de frequência) </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  clk_io / 1024 (divisor de frequência) </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  Fonte de relógio externo no pino T1.  Clock de recessão </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td><td>  Fonte de relógio externo no pino T1.  Relógio Frontal </td></tr></tbody></table></div><br><p>  Por padrão, todos esses bits são definidos como zero. </p><br><p>  Suponha que você queira que o Timer1 seja executado em uma frequência de relógio com uma amostra por período.  Quando estiver cheio, você deseja chamar a rotina de interrupção, que alterna o LED conectado à perna 13 para o estado ligado ou desligado.  Neste exemplo, escreveremos o código do Arduino, mas usaremos os procedimentos e funções da biblioteca avr-libc sempre que isso não tornar as coisas muito complicadas.  Os apoiadores do AVR puro podem adaptar o código como desejarem. </p><br><p>  Primeiro, inicialize o cronômetro: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// avr-libc library includes #include &lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #define LEDPIN 13 void setup() { pinMode(LEDPIN, OUTPUT); //  Timer1 cli(); //    TCCR1A = 0; //  TCCR1A   0 TCCR1B = 0; //   Timer1 overflow: TIMSK1 = (1 &lt;&lt; TOIE1); //  CS10  ,      : TCCR1B |= (1 &lt;&lt; CS10); sei(); //    }</span></span></code> </pre> <br><p>  O registro TIMSK1 é um registro de máscara de interrupção do temporizador / contador1.  Controla a interrupção que o temporizador pode causar.  A configuração do bit TOIE1 indica ao cronômetro que interrompa quando o cronômetro exceder.  Mais sobre isso mais tarde. </p><br><p>  Quando você define o bit CS10, o timer começa a contar e, assim que ocorre uma interrupção de estouro, o ISR (TIMER1_OVF_vect) é chamado.  Isso sempre acontece quando o temporizador transborda. </p><br><p>  Em seguida, definimos a função de interrupção ISR: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_OVF_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</code> </pre> <br><p>  Agora podemos definir o ciclo loop () e alternar o LED, independentemente do que acontece no programa principal.  Para desligar o timer, defina TCCR1B = 0 a qualquer momento. </p><br><h3 id="kak-chasto-budet-migat-svetodiod">  Com que frequência o LED pisca? </h3><br><p>  Timer1 está definido para interromper a transbordamento e vamos supor que você esteja usando um Atmega328 com uma frequência de clock de 16 MHz.  Como o temporizador é de 16 bits, pode contar até o valor máximo (2 ^ 16 - 1) ou 65535. Em 16 MHz, o ciclo executa 1 / (16 × 10 ^ 6) segundos ou 6,25e-8 s.  Isso significa que 65535 amostras ocorrerão em (65535 ± 6,25e-8 s) e o ISR será chamado após aproximadamente 0,0041 s.  E assim, vez após vez, a cada quatro milésimos de segundo.  É muito rápido para ver cintilação. </p><br><p>  Se aplicarmos um sinal PWM muito rápido com 50% de cobertura ao LED, o brilho parecerá contínuo, mas menos brilhante que o normal.  Esse experimento mostra o incrível poder dos microcontroladores - mesmo um chip de 8 bits barato pode processar informações muito mais rapidamente do que podemos detectar. </p><br><h3 id="delitel-taymera-i-rezhim-ctc">  Divisor do temporizador e modo CTC </h3><br><p>  Para controlar o período, você pode usar um divisor, que permite dividir o sinal do relógio em diferentes graus de dois e aumentar o período do timer.  Por exemplo, você deseja que o LED pisque em intervalos de um segundo.  Existem três bits CS no registro TCCR1B configurando a resolução mais apropriada.  Se você definir os bits CS10 e CS12 usando: </p><br><pre> <code class="cpp hljs">TCCR1B |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; CS10); TCCR1B |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; CS12);</code> </pre> <br><p>  então a frequência da fonte do relógio será dividida por 1024. Isso fornece uma resolução de timer de 1 / (16 × 10 ^ 6/1024) ou 6,4e-5 s.  Agora o temporizador transbordará a cada (65535 ∗ 6,4e-5s) ou por 4,194s.  É muito longo. </p><br><p>  Mas há outro modo de timer AVR.  É chamado de reset coincidente do temporizador ou CTC.  Em vez de contar para transbordar, o timer compara seu contador com a variável que foi armazenada anteriormente no registro.  Quando a contagem corresponde a essa variável, o cronômetro pode definir um sinalizador ou causar uma interrupção, como no caso de um estouro. </p><br><p>  Para usar o modo CTC, você precisa entender quantos ciclos são necessários para obter um intervalo de um segundo.  Suponha que a taxa de divisão ainda seja 1024. </p><br><p>  O cálculo será o seguinte: </p><br><pre> <code class="plaintext hljs">(target time) = (timer resolution) * (# timer counts + 1) (# timer counts + 1) = (target time) / (timer resolution) (# timer counts + 1) = (1 s) / (6.4e-5 s) (# timer counts + 1) = 15625 (# timer counts) = 15625 - 1 = 15624</code> </pre> <br><p>  Você deve adicionar uma unidade adicional ao número de amostras, porque no modo CTC, se o contador corresponder ao valor definido, ele será redefinido para zero.  A redefinição leva um período de relógio, que deve ser levado em consideração nos cálculos.  Em muitos casos, um erro em um período não é muito significativo, mas em tarefas de alta precisão, pode ser crítico. </p><br><p>  A função setup () será assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ pinMode(LEDPIN, OUTPUT); <span class="hljs-comment"><span class="hljs-comment">//  Timer1 cli(); //    TCCR1A = 0; //    0 TCCR1B = 0; OCR1A = 15624; //    TCCR1B |= (1 &lt;&lt; WGM12); //   CTC  //   CS10  CS12    1024 TCCR1B |= (1 &lt;&lt; CS10); TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; OCIE1A); //     sei(); //    }</span></span></code> </pre> <br><p>  Você também precisa substituir a interrupção de estouro por uma interrupção coincidente: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_COMPA_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</code> </pre> <br><p>  Agora o LED acende e apaga por exatamente um segundo.  E você pode fazer qualquer coisa em um loop loop ().  Até você alterar as configurações do timer, o programa não tem nada a ver com interrupções.  Você não tem restrições quanto ao uso de um timer com diferentes modos e configurações do divisor. </p><br><p>  Aqui está um exemplo inicial completo que você pode usar como base para seus próprios projetos: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Arduino  CTC  // avr-libc library includes #include &lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #define LEDPIN 13 void setup() { pinMode(LEDPIN, OUTPUT); //  Timer1 cli(); //    TCCR1A = 0; //    0 TCCR1B = 0; OCR1A = 15624; //    TCCR1B |= (1 &lt;&lt; WGM12); //  CTC  TCCR1B |= (1 &lt;&lt; CS10); //      1024 TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; OCIE1A); //      sei(); //    } void loop() { //   } ISR(TIMER1_COMPA_vect) { digitalWrite(LEDPIN, !digitalRead(LEDPIN)); }</span></span></code> </pre> <br><p>  Lembre-se de que você pode usar as funções ISR integradas para estender as funções do timer.  Por exemplo, você precisa pesquisar o sensor a cada 10 segundos.  Mas não há configurações de timer que forneçam uma contagem tão longa sem estouros.  No entanto, você pode usar o ISR para incrementar a variável de contagem uma vez por segundo e, em seguida, pesquisar o sensor quando a variável atingir 10. Usando o modo STS do exemplo anterior, a interrupção pode ficar assim: </p><br><pre> <code class="cpp hljs">ISR(TIMER1_COMPA_vect) { seconds++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(seconds == <span class="hljs-number"><span class="hljs-number">10</span></span>) { seconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; readSensor(); } }</code> </pre> <br><p>  Como a variável será modificada dentro do ISR, ela deverá ser declarada como <em>volátil</em> .  Portanto, ao descrever variáveis ​​no início do programa, você precisa escrever: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> byte seconds;</code> </pre> <br><h3 id="posleslovie-perevodchika">  Posfácio do tradutor </h3><br><p>  Ao mesmo tempo, este artigo me salvou muito tempo ao desenvolver um protótipo de gerador de medição.  Espero que seja útil para outros leitores. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453276/">https://habr.com/ru/post/pt453276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453260/index.html">Recursos de configuração de DPI</a></li>
<li><a href="../pt453262/index.html">Onde estão suas constantes armazenadas no microcontrolador CortexM (usando o compilador C ++ IAR como exemplo)</a></li>
<li><a href="../pt453264/index.html">Virtuali-tee: uma "camiseta médica" que não cobre, mas expõe</a></li>
<li><a href="../pt453272/index.html">Patrocinadores do GitHub: uma nova maneira de contribuir com o código aberto</a></li>
<li><a href="../pt453274/index.html">Comissão oculta Yandex.Money no Samsung Pay</a></li>
<li><a href="../pt453278/index.html">Por que os engenheiros não se preocupam com o monitoramento de aplicativos?</a></li>
<li><a href="../pt453280/index.html">Dívida técnica</a></li>
<li><a href="../pt453286/index.html">O erro mais caro da minha vida: detalhes sobre o ataque à porta do cartão SIM</a></li>
<li><a href="../pt453290/index.html">Data Science Digest (maio de 2019)</a></li>
<li><a href="../pt453292/index.html">"Um livrinho sobre buracos negros"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>