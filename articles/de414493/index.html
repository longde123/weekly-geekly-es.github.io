<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç• ü§º üë©‚Äçüé§ So schreiben Sie in 5 Minuten einen intelligenten Vertrag f√ºr ICO üëí üç£ üÜí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! In diesem Artikel werde ich Ihnen erkl√§ren, wie Sie in 5 Minuten einen intelligenten Geldsammelvertrag f√ºr Ihr ICO auf Ethereum und ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So schreiben Sie in 5 Minuten einen intelligenten Vertrag f√ºr ICO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414493/"><img src="https://habrastorage.org/webt/rv/6d/_c/rv6d_cyxk3ix-su6le9q4lyqntc.png"><br><br>  Hallo allerseits!  In diesem Artikel werde ich Ihnen erkl√§ren, wie Sie in 5 Minuten einen intelligenten Geldsammelvertrag f√ºr Ihr ICO auf Ethereum und mehrere Befehle im Terminal abschlie√üen k√∂nnen.  Mit diesem Aufsatz sparen Sie m√∂glicherweise Zehntausende US-Dollar, da jeder Programmierer - und nicht auch ein Programmierer - einen gepr√ºften und sicheren Smart-Vertrag abschlie√üen kann (anstatt 15.000 bis 75.000 US-Dollar f√ºr die Entwicklung zu zahlen).  Kurz gesagt, Sie k√∂nnen Geld an diesen intelligenten Vertrag senden und ERC20-Token daf√ºr erhalten.  Man kann sagen, dass dieser Artikel eine Sammlung aller Erfahrungen ist, die ich durch die Einf√ºhrung eines ICO f√ºr mein Projekt gesammelt habe. <br><br>  Im Internet sind diese bereits voll von Artikeln √ºber intelligente Vertr√§ge, aber sobald Sie anfangen, einen zu schreiben, sto√üen Sie auf die Tatsache, dass die Informationen √ºberall wiederholt werden und es einfach keine Tutorials gibt, wie Sie Ihren ERC20 zum Narren halten k√∂nnen, oder sie sind bereits veraltet.  √úbrigens, damit dieser Artikel relevant bleibt, werde ich versuchen, m√∂gliche Stellen anzugeben, an denen er veraltet sein k√∂nnte (und wie man ihn behebt).  Lass uns gehen! <br><a name="habracut"></a><br><h2>  Festigkeit </h2><br>  Dies ist der Name der Hauptsprache, die das Kefir-Team entwickelt hat, um intelligente Vertr√§ge abzuschlie√üen.  Wenn Sie ein Programmierer sind, gehen Sie einfach die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation der Sprache durch</a> - es ist unanst√§ndig einfach.  √úbrigens haben sie es einfach gemacht, so dass es schwieriger war, einen Fehler beim Schreiben eines intelligenten Vertrags zu machen.  So kann <b>absolut jeder</b> Programmierer, zumindest auf der Junior-Ebene, es herausfinden.  <b>Es macht absolut keinen</b> Sinn, Entwicklern, die sich mit Solidit√§t auskennen, riesige Geldbetr√§ge zu zahlen - es wird eine Gr√∂√üenordnung billiger sein, einen vorhandenen Entwickler auszubilden. <br><br><h2>  Intelligente Vertr√§ge </h2><br>  ... und alles was Sie √ºber sie wissen m√ºssen.  √úberspringen Sie diesen Abschnitt, wenn Sie kein Programmierer sind.  Ein intelligenter Vertrag ist ein St√ºck Code.  Im Prinzip ist dies eine Klasse in Solidit√§t (OOP, ja), die zwei Arten von Funktionen hat: Zustands√§nderung und Nicht-Zustands√§nderung.  Nun, um Funktionen in einem intelligenten Vertrag auszuf√ºhren, indem Sie nur Kefir an ihn senden, m√ºssen Sie diese Funktion als <code>payable</code> markieren. <br><br>  State ist ein Data Warehouse, Blockchain, EPT.  Vertr√§ge k√∂nnen die Blockchain (Status, Speicher) √§ndern. Um die Blockchain zu √§ndern, m√ºssen Sie den Bergleuten Kefir zahlen.  Wie sie Kefir teilen, wird im Rahmen dieses Artikels nicht analysiert.  Die Zahlung an Bergleute f√ºr die Ausf√ºhrung des Codes zur √Ñnderung des Status wird als Gas bezeichnet.  Wenn jemand von au√üerhalb Kefir an die Adresse eines Smart-Vertrags wirft und eine Funktion <code>payable</code> , die als <code>payable</code> aber nicht als <code>Constant</code> , <code>View</code> oder <code>Pure</code> , wird der f√ºr die Zahlung an Bergleute erforderliche Kefir-Betrag von dem gesendeten Betrag abgezogen.  In ERC20-Token sind dies normalerweise Funktionen, die entweder den Token-Absender f√ºr Kefir ausgeben oder Token von einem Token-Inhaber auf einen anderen √ºbertragen. <br><br>  Und wenn Sie eine Funktion im Vertrag mit den Worten " <code>Constant</code> oder " <code>View</code> (sie bedeuten dasselbe, Sie k√∂nnen nur den Status lesen) oder " <code>Pure</code> (dasselbe, Sie lesen nicht einmal den Status) markieren, m√ºssen Sie nicht einmal Kefir f√ºr diese Funktion ausgeben!  Ich werde noch mehr sagen, dass diese Funktionen nicht durch Transaktionen aufgerufen werden m√ºssen - schlie√ülich kann jeder Joghurt-Client sie theoretisch zu Hause ausf√ºhren - und niemand muss mehr dar√ºber Bescheid wissen (schlie√ülich wird nichts in die Blockchain geschrieben). <br><br>  Bei der Solidit√§t gibt es zwei wichtige Dinge: Mehrfachvererbung und Funktionsmodifikatoren.  Sie m√ºssen auch √ºber sie wissen. <br><br>  Die ersten - nur Vertr√§ge k√∂nnen gleichzeitig von mehreren Klassen wie <code>TimedCrowdsale</code> , <code>CappedCrowdsale</code> , <code>MintedCrowdsale</code> , <code>Ownable</code> - gleichzeitig werden die Funktionen der Konstruktoren auch nacheinander gestartet - aber ich werde dies sp√§ter als Beispiel erl√§utern. <br><br>  Die zweite ist die M√∂glichkeit, Funktionen zu erstellen, die dann in andere Funktionen eingef√ºgt werden.  Es ist wie eine einfache Kapselung, nur ein bisschen flexibler - es ist buchst√§blich <b>eine</b> Funktionsvorlage.  Wenn Sie einen Modifikator erstellen, schreiben Sie das Sonderzeichen <code>_</code> wobei Sie den Code einer Funktion mit diesem Modifikator meinen.  Das hei√üt, Modifikatoren sind nicht nur gekapselte Funktionen, die einen Wert zur√ºckgeben.  Dies ist eine Funktionsvorlage, wenn Code aus einem Modifikator mit diesem Modifikator buchst√§blich in eine Funktion eingef√ºgt wird. <br><br>  Lass uns weiter √ºben. <br><br><h2>  Kochumgebung </h2><br>  Wenn Sie nicht wissen, was Terminal ist, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel hier</a> .  Wenn Sie unter Windows arbeiten, richten Sie sich √ºber WLS ein Terminal ein.  Wenn Sie bereits mit dem Terminal vertraut sind, fahren wir fort.  Stellen Sie sich auch sofort Node.js - es wird f√ºr die n√§chsten Schritte notwendig sein.  Es ist besser, LTS zu installieren, aber tats√§chlich macht es keinen Unterschied, welche der modernen Versionen des Knotens installiert werden soll. <br><br>  Das erste, was wir sofort installieren und den Block-Synchronisationsprozess starten, ist <code>geth</code> .  Kurz gesagt, dies ist ein in Go geschriebenes Dienstprogramm, mit dem wir den Ether-Knoten auf dem lokalen Computer ausf√ºhren und eine Verbindung zu den Test- und realen Netzwerken herstellen k√∂nnen.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber</a> Installationsprogramme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installieren</a> , ich empfehle jedoch dringend, dass Sie sofort im Terminal arbeiten, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beschrieben.  Sie k√∂nnen √ºberpr√ºfen, ob Ihre <code>geth</code> Standards festgelegt sind <code>geth</code> den Befehl im Terminal <code>geth</code> : <br><br><pre> <code class="bash hljs">geth version</code> </pre> <br>  Wenn Sie die Geth-Version ausgespuckt bekommen - alles ist in Openwork, fahren Sie mit dem Tutorial fort.  Wenn nicht - schlecht, richtig;  Es scheint, dass Sie mit dem Terminal und Ihrem Betriebssystem Liebesspiel machen m√ºssen - aber dies ist nicht das erste Mal, dass Sie es herausfinden.  So installieren Sie geth, f√ºhren Sie den Befehl im Terminal aus: <br><br><pre> <code class="bash hljs">geth --testnet console</code> </pre> <br>  Dadurch wird der Prozess der Synchronisierung Ihres Knotens mit dem Testserver gestartet, dessen Bl√∂cke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> angezeigt werden k√∂nnen.  Sie k√∂nnen √ºberpr√ºfen, ob Sie mit dem Netzwerk in der <code>geth</code> Konsole synchronisiert haben, indem Sie <code>geth</code> : <br><br><pre> <code class="bash hljs">eth.blockNumber <span class="hljs-comment"><span class="hljs-comment">#  0 ‚Äî     eth.syncing #     false,    </span></span></code> </pre> <br>  Der Synchronisationsprozess dauerte 1 bis 4 Stunden - wann wie.  Zus√§tzlich zur Blocksynchronisation m√ºssen Sie auch auf die Statussynchronisation warten - diese ist h√§ufig l√§nger als die Blocksynchronisation.  Sie k√∂nnen auch <code>geth</code> mit dem Flag <code>--light</code> verwenden. Die Synchronisierung dauert dann einige Sekunden bis eine Minute und Sie k√∂nnen weiterhin Vertr√§ge bereitstellen. <br><br>  Okay, wir haben das erste Dienstprogramm installiert - setzen Sie das n√§chste.  Wir m√ºssen ein Analogon von <code>geth</code> , nur eine sehr lokale Blockchain-Simulation - <code>testrpc</code> .  Ja, wir haben <b>3 Blockchains</b> : <br><br><ul><li>  <code>testrpc</code> - lokale Blockchain-Simulation;  schnell, aber gef√§lscht und nur auf Ihrem Computer gespeichert </li><li>  <code>geth --testnet</code> ist bereits eine echte Blockchain, aber Sie werden kein Geld verlieren, wenn Sie Kefir bekommen und alle <code>geth --testnet</code> kostenlos testen k√∂nnen </li><li>  <code>geth</code> - mainnet, main, echte Blockchain, echter Kefir;  Alles auf erwachsene Weise, die Fehler hier sind die Verluste von echtem Kefir </li></ul><br>  Dementsprechend werden wir den <code>testrpc</code> mit <code>testrpc</code> , ihn dann in <code>geth --testnet</code> installieren und dann direkt in <code>geth</code> . <br><br>  Wir <code>testrpc</code> indem wir den folgenden Befehl <code>testrpc</code> : <br><br><pre> <code class="bash hljs">npm install -g ethereumjs-testrpc</code> </pre> <br>  Nun, oder es steigt sofort mit einem Tr√ºffel auf, da sich jetzt <code>testrpc</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unter dem Tr√ºffelfl√ºgel befindet</a> und <code>ganache-cli</code> .  Obwohl der Teufel wei√ü, hat mit Vanilla <code>testrpc</code> alles <code>testrpc</code> .  Und wenn es funktioniert, fass es nicht an, da ich an der intergalaktischen Akademie unterrichtet wurde.  Sie k√∂nnen es auch ausf√ºhren, um die Installation zu √ºberpr√ºfen, indem Sie <code>truffle</code> in der Konsole registrieren. Die Testblockchain ist jedoch bereits mit uns synchronisiert. Lassen Sie uns das nicht st√∂ren. <br><br>  Nun, die Blockchains herausgefunden?  Es gibt jetzt Knoten und der Test ist sogar synchronisiert?  Mit dem folgenden Befehl haben wir ein praktisches Dienstprogramm f√ºr die Arbeit mit intelligenten Vertr√§gen f√ºr Kefir- <code>truffle</code> bereitgestellt: <br><br><pre> <code class="bash hljs">npm install -g truffle truffle version <span class="hljs-comment"><span class="hljs-comment">#  ,  ,  </span></span></code> </pre> <br>  Truffle ist ein Tool, mit dem Sie intelligente Vertr√§ge in verschiedenen Dateien speichern, andere Dateien importieren und Ihren intelligenten Vertragscode in einen gro√üen Bytecode kompilieren k√∂nnen (von einer Person nicht lesbar). Es findet automatisch ein lokal laufendes <code>geth</code> (Test und Real) ) oder <code>testrpc</code> , stellen Sie Ihren Smart-Vertrag in diesem Netzwerk <code>testrpc</code> .  √úberpr√ºfen Sie Ihren Smart-Vertragscode auf Fehler, und k√ºrzlich abgeschlossene Transaktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">helfen auch beim Debuggen</a> .  Kurz gesagt, Masthead. <br><br>  Zu diesem Zeitpunkt sollten Sie <code>testrpc</code> installiert haben: <code>testrpc</code> , <code>geth</code> , <code>truffle</code> - wenn etwas davon fehlt oder die Version auf Anfrage nicht auf die Konsole spuckt, korrigieren Sie dies;  Andernfalls werden Sie keinen Erfolg haben. <br><br><blockquote>  Au√üerdem habe ich ein einfaches <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bash-Skript erstellt</a> , das alles f√ºr Sie installiert.  So genannt: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">source</span></span> &lt;(curl -s https://raw.githubusercontent.com/backmeupplz/eth-installer/master/install.sh)</code> </pre> <br>  - aber ich habe es noch nie getestet, daher bin ich mir seiner Leistung nicht sicher.  Gerne ziehe ich jedoch Anfragen zur√ºck. </blockquote><br><h2>  Figash Vertrag </h2><br>  Alles wurde bereits f√ºr Sie erfunden und geschrieben - das ist gut.  Eine kleine Ammer wird egal sein - aber ich werde versuchen, sie f√ºr Sie zu minimieren.  Wir werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgefertigte ERC20-Vertr√§ge von OpenZeppelin verwenden</a> - dies ist jetzt der Industriestandard, sie haben das Audit bestanden und tats√§chlich verwenden alle ihren Code.  Vielen Dank f√ºr Ihren Beitrag zu Open Source. <br><br>  Machen Sie eine <code>cd</code> in einen sicheren Ordner und schreiben Sie dann: <br><br><pre> <code class="bash hljs">mkdir contract &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> contract</code> </pre> <br>  In diesem Ordner werden wir arbeiten.  Erstellen Sie hier einen Stub f√ºr unseren intelligenten Vertrag: <br><br><pre> <code class="bash hljs">truffle init</code> </pre> <br>  Stolpern, klar.  Wir haben jetzt zwei sehr wichtige Ordner, in die wir klettern werden: <code>contracts</code> und <code>migrations</code> .  Der erste ist der Code f√ºr unsere Vertr√§ge, der zweite ist der Code f√ºr Tr√ºffel, um zu wissen, was zu tun ist, wenn Vertr√§ge in der Blockchain bereitgestellt werden. <br><br>  Als n√§chstes m√ºssen wir den aktuellen Smart Contract Code von npm √ºbernehmen und das Projekt selbst starten: <br><br><pre> <code class="bash hljs">npm init -y <span class="hljs-comment"><span class="hljs-comment">#     ( -y) npm install -E openzeppelin-solidity #       ( -E)</span></span></code> </pre> <br>  Nun, der Code f√ºr intelligente Vertr√§ge von OpenZeppelin befindet sich in unserer Tasche im Ordner <code>node_modules/openzeppelin-solidity/contracts</code> .  Jetzt gehen wir zum Hauptvertragsordner, l√∂schen dort alle Dateien und f√ºgen die Dateien <code>MyToken.sol</code> und <code>MyCrowdsale.sol</code> - nat√ºrlich werden Sie Ihre Vertr√§ge anders benennen.  Der erste ist ein Vertrag f√ºr unser ERC20-Token, und der zweite ist ein Vertrag unseres ICO, der Kefir akzeptiert und <code>MyToken</code> verteilt.  Dieser Artikel ist m√∂glicherweise veraltet, aber Sie k√∂nnen jederzeit √ºberpr√ºfen, wie OpenZeppelin vorschl√§gt, Vertr√§ge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in ihrem Repository zu</a> erstellen.  So sieht <code>MyToken.sol</code> : <br><br><pre> <code class="javascript hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Imports import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol"; // Main token smart contract contract MyToken is MintableToken { string public constant name = "My Token"; string public constant symbol = "MTKN"; uint8 public constant decimals = 18; }</span></span></code> </pre> <br>  Sch√∂n - Sie haben einen intelligenten Vertrag mit Ihrem eigenen Token (√§ndern Sie einfach die Namen in den Konstanten)!  Sie k√∂nnen sehen, welche <code>MintableToken</code> Vererbung es von <code>MintableToken</code> - aber dort ist alles so einfach wie m√∂glich.  Dies ist ein Token, das ausgegeben werden kann (von der englischen "Mint" - bis Mint), und nur der Eigent√ºmer hat das Recht, es <code>MintableToken</code> , da das <code>MintableToken</code> auch von <code>Ownable</code> geerbt <code>Ownable</code> .  Au√üerdem erbt <code>MintableToken</code> auch von Klassen von ERC20-Token, die von OpenZeppelin geschrieben wurden und in denen die ERC20-Schnittstelle implementiert ist: <br><br><pre> <code class="javascript hljs">contract ERC20Basic { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">totalSupply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">balanceOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address who</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transfer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address to, uint256 value</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bool</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">event</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transfer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address indexed from, address indexed to, uint256 value</span></span></span><span class="hljs-function">); }</span></span></code> </pre> <br>  Ja, hier haben Sie die gesamte ERC20-Schnittstelle.  Ist es schwierig  Ich glaube nicht.  Sie haben die M√∂glichkeit, die Anzahl der ausgegebenen Token zu √ºberpr√ºfen, den Adresssaldo zu √ºberpr√ºfen und Token an eine andere Adresse zu √ºbertragen, indem Sie ein √úbertragungsereignis f√ºr Light Kefir-Kunden im Netzwerk ausspucken.  Und all das erhalten Sie dank der Arbeit von OpenZeppelin kostenlos in MyToken.sol - sie sind gro√üartig. <br><br>  Und jetzt kommen wir zum Hauptteil unseres ICO - wir m√ºssen Kefir akzeptieren und <code>MyToken</code> !  So <code>MyCrowdsale.sol</code> Ihre <code>MyCrowdsale.sol</code> aus: <br><br><pre> <code class="javascript hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Imports import "../node_modules/openzeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/crowdsale/distribution/RefundableCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol"; import "../node_modules/openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol"; contract MyCrowdsale is CappedCrowdsale, RefundableCrowdsale, MintedCrowdsale { constructor( uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, uint256 _cap, MintableToken _token, uint256 _goal ) public Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap) TimedCrowdsale(_openingTime, _closingTime) RefundableCrowdsale(_goal) { //   ,  ,    // ,     require(_goal &lt;= _cap); } }</span></span></code> </pre><br>  So lala, was ist mit uns?  Was, Jungs, kluge Vertr√§ge?  Unser √∂ffentlicher Verkauf von Token erbt drei der beliebtesten Immobilien: Es hat eine Hard-Cap, die nicht mehr gesammelt werden kann;  weiche Kappe, die nicht sammelt, welche Ester zur√ºckgegeben werden;  Zeitpunkt des Beginns und des Endes des Verkaufs von Token.  Was braucht man eigentlich noch f√ºr das Gl√ºck? <br><br>  Programmierer beachten, wie die Konstruktoren mehrerer Vererbungsklassen in einer Reihe angeordnet sind, und erhalten Argumente vom Hauptkonstruktor von <code>MyCrowdsale</code> .  Au√üerdem √ºberpr√ºfen wir, ob der Hardkey h√∂her ist als der Softkey - Ales Gut!  <code>MyCrowdsale</code> Sie sich auch nicht <code>MyCrowdsale</code> Parametern im <code>MyCrowdsale</code> Konstruktor <code>MyCrowdsale</code> - wir werden sie in der Phase der Vertragsbereitstellung in der Tr√ºffel √ºbergeben. <br><br>  Das ist alles - Sie haben vorgefertigte Vertr√§ge mit Ihrem eigenen ERC20-Token und sogar einen ICO-Smart-Vertrag, der nach Ihren W√ºnschen konfiguriert wird und Ihre Token f√ºr Kefir ausgibt.  Au√üerdem wird es von allen ERC20-Geldb√∂rsen unterst√ºtzt - ein Fehler!  Fahren wir mit manuellen Tests und der Bereitstellung fort. <br><br><h2>  Migrationen </h2><br>  Wie ich bereits sagte, werden wir nacheinander in drei Blockchain-Netzwerken testen, aber der Testprozess mit Stiften wird immer der gleiche sein.  Beginnen wir mit <code>testrpc</code> , fahren <code>testrpc</code> dann mit <code>geth --testnet</code> und fahren mit <code>geth</code> .  Sou Scheinwerfer, wir haben gerade den Code geschrieben, versuchen wir es zu kompilieren.  Schreiben Sie im Projektordner: <br><br><pre> <code class="bash hljs">truffle compile</code> </pre> <br>  Wenn alles ohne Probleme kompiliert wurde, sehen Sie den <code>build</code> , der das Krakozyab f√ºr die Tr√ºffel enth√§lt, damit der Bytecode Ihrer Smart-Vertr√§ge in die Blockchain eingebettet werden kann.  Bevor wir intelligente Vertr√§ge bereitstellen, m√ºssen wir dem Tr√ºffel mitteilen, was √ºberhaupt zu tun ist.  Die Tr√ºffelbereitstellung intelligenter Vertr√§ge wird als Migration bezeichnet. Halten wir uns an diese Terminologie.  Gehen Sie zu <code>migrations/1_initial_migration.js</code> und √§ndern Sie es folgenderma√üen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = artifacts.require(<span class="hljs-string"><span class="hljs-string">"../contracts/MyToken.sol"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crowdsale = artifacts.require(<span class="hljs-string"><span class="hljs-string">"../contracts/MyCrowdsale.sol"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">deployer, network, accounts</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> openingTime = <span class="hljs-number"><span class="hljs-number">1514764800</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 15  2018 const closingTime = 1561939200; // 1  2019 const rate = new web3.BigNumber(1); // 1   1  const wallet = '0x281055afc982d96fab65b3a49cac8b878184cb16'; // - const cap = 200 * 1000000; //  const goal = 100 * 1000000; //  return deployer .then(() =&gt; { return deployer.deploy(token); }) .then(() =&gt; { return deployer.deploy( crowdsale, openingTime, closingTime, rate, wallet, cap, token.address, goal ); }) .then(() =&gt; { // Crowdsale    var tokenContract = web3.eth.contract(token.abi).at(token.address); web3.eth.defaultAccount = web3.eth.accounts[0]; tokenContract.transferOwnership(crowdsale.address); }); };</span></span></code> </pre> <br>  Dies ist dieselbe Datei, die von der Tr√ºffel zum Bereitstellen von Vertr√§gen verwendet wird.  Was machen wir hier?  Zuerst haben wir <code>MyToken</code> und <code>MyCrowdsale</code> kompiliert <code>MyCrowdsale</code> .  Danach setzen wir die Konstanten mit allen Argumenten unseres ICO - setzen die Start- und Endzeiten;  Wie viele Token erhalten Personen f√ºr 1 Vey Kefir (0,000000000000000001 eth = 1 Wei; das Setzen von <code>decimals</code> gibt an, wie viele Wei-Bestellungen erforderlich sind, um 1 Ihrer neu hergestellten Token zu erhalten).  Brieftasche, wo Kefir aus dem Verkauf kommen wird;  harte Kappe und weiche Kappe.  Bitte beachten Sie, dass die <code>openingTime</code> immer nach dem Zeitpunkt des aktuellen Blocks in der Blockchain liegen sollte. Andernfalls wird Ihr Smart-Vertrag nicht blockiert, da der Zustand in <code>TimedCrowdsale</code> .  Ich bin auf diesen Rechen getreten, und fehlgeschlagene Transaktionen k√∂nnen √ºberhaupt nicht belastet werden.  √Ñndern Sie diese Konstanten nach Ihren W√ºnschen. <br><br>  Der n√§chste Schritt ist genau die Bereitstellung intelligenter Vertr√§ge.  Hier gibt es nichts Interessantes: Wir haben ein <code>deployer</code> Objekt, das intelligente Vertragsartefakte <code>deployer</code> und dort Argumente √ºbergibt.  Beachten Sie, dass MyToken zuerst und erst dann <code>MyCrowdsale</code> - und die Adresse des ersten als Argument im zweiten √ºbergeben wird. <br><br>  Das Interessanteste ist dann, wor√ºber sie weder in der Dokumentation noch in den B√ºchern schreiben.  Wenn Sie ein <code>MyToken</code> aus einer Brieftasche erstellen, wird diese Brieftasche Eigent√ºmer von <code>MyToken</code> in der Superklasse <code>Ownable</code> - dasselbe passiert mit <code>MyCrowdsale</code> .  Wenn Sie tief in das <code>MintableToken</code> , k√∂nnen Sie sehen, dass nur der <code>Owner</code> M√ºnzen pr√§gen kann!  Und wer ist der Besitzer von <code>MyToken</code> ?  Das ist richtig: die Adresse, die ihn ver√§rgerte.  Und wer wird Anfragen zur M√ºnzpr√§gung senden?  Richtig: <code>MyCrowdsale</code> Smart Contract.  Ich <code>MyToken</code> Sie daran erinnern, dass die Adresse, die <code>MyToken</code> und <code>MyCrowdsale</code> zwei verschiedene Adressen sind. <br><br>  <code>MyToken</code> diesem <code>MyCrowdsale</code> <code>MyToken</code> wir den nicht-orthodoxen dritten Bereitstellungsschritt hinzu, bei dem die Adresse, die sich den Vertr√§gen widersetzt hat ( <code>web3.eth.accounts[0]</code> ), die Funktion <code>transferOwnership</code> f√ºr den <code>MyToken</code> Vertrag <code>MyToken</code> <code>MyCrowdsale</code> besitzt und M√ºnzen pr√§gen kann.  Und <code>MyCrowdsale</code> ist immer noch im Besitz von <code>web3.eth.accounts[0]</code> - also ist alles geb√ºndelt. <br><br><blockquote>  Hinweis zu <code>web3.eth.accounts[0]</code> : <code>web3.eth.accounts[0]</code> beim Bereitstellen eines intelligenten Vertrags sicher, dass geth oder testrpc die richtige Brieftasche in <code>web3.eth.accounts[0]</code> haben. Verlieren Sie nicht den privaten Schl√ºssel, obwohl dies Ihnen in keiner Weise schadet. aber pl√∂tzlich muss der Besitzer sp√§ter etwas tun, aber der Schl√ºssel ist nicht mehr da? </blockquote><blockquote>  In <code>testrpc</code> werden Konten in der Regel sofort beim Start erstellt und sofort entsperrt.  Bei einer Test- und Real Air-Blockchain lohnt es sich jedoch, ein Konto √ºber <code>personal.newAccount()</code> zu erstellen. Geben Sie diese Adresse dann √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Faucet</a> in der Test-Blockchain oder Real Kefir in der Real Blockchain wieder ein.  Verlieren Sie nicht Ihr Passwort und Ihre privaten Schl√ºssel. </blockquote><blockquote>  Sie k√∂nnen Ihren Konten auch eine vorhandene Brieftasche hinzuf√ºgen, indem Sie <code>web3.personal.importRawKey('pvt_key', 'password')</code> aufrufen. <code>geth</code> m√ºssen Sie jedoch <code>geth</code> mit dem zus√§tzlichen Parameter <code>--rpcapi="db,eth,net,web3,personal,web3"</code> .  Ich denke, Sie werden es herausfinden. </blockquote><br><h2>  Testen und Bereitstellen </h2><br>  Ja, die Vertr√§ge sind fertig, die Migrationen sind geschrieben, es bleibt nur die Bereitstellung und √úberpr√ºfung.  Sowohl <code>geth</code> (test und real) als auch <code>testrpc</code> auf die gleiche Weise √ºber die <code>truffle console</code> verwaltet. <code>testrpc</code> werde ich die √úberpr√ºfungsmethode f√ºr <code>testrpc</code> und Ihnen nur <code>testrpc</code> , wie Sie <code>geth</code> nachher aktivieren <code>geth</code> .  Und so starten wir die lokale Test-Kefir-Blockchain: <br><br><pre> <code class="bash hljs">testrpc</code> </pre> <br>  √Ñhm ... das ist alles.  Sie simulieren die Kefir-Blockchain lokal. <br><br><blockquote>  Und um diese in der <code>geth --testnet --rpc</code> , erhalten Sie anstelle dieses Befehls <code>geth --testnet --rpc</code> .  Und um in der realen Blockchain von Ether <code>geth --rpc</code> werden, <code>geth --rpc</code> Sie einfach <code>geth --rpc</code> .  Das Flag <code>--rpc</code> ben√∂tigt, damit die Tr√ºffel eine Verbindung herstellen kann.  Die folgenden Bereitstellungs- und Testschritte sind f√ºr alle drei Blockchain-Typen mehr oder weniger gleich.  Das einzige ist, dass nach dem Ausf√ºhren des Tests oder der echten Blockchain √ºber <code>geth</code> die Synchronisierung der Bl√∂cke beginnt - und dies kann bei einer guten Internetverbindung bis zu 4-5 Stunden dauern.  Eine Bemerkung dazu war ganz am Anfang des Artikels.  Ich empfehle, vor der Bereitstellung intelligenter Vertr√§ge auf die vollst√§ndige Synchronisierung zu warten.  Au√üerdem wiegt die Blockchain im Bereich von 60 bis 100 Gigabyte. Bereiten Sie also den Speicherplatz daf√ºr vor. </blockquote><blockquote>  <code>web3.eth.accounts[0]</code> au√üerdem sicher, dass <code>web3.eth.accounts[0]</code> entsperrt ist.  Normalerweise k√∂nnen Sie <code>testrpc</code> in der Konsole registrieren, die sofort ge√∂ffnet wird, oder in einem separaten Terminalfenster in der Konsole, das √ºber die <code>geth console</code> : <code>eth.unlockAccount(eth.accounts[0], ",    ", 24*3600)</code> - Dadurch wird Ihr Konto freigeschaltet, wodurch ein intelligenter Vertrag erstellt werden sollte </blockquote><br>  √ñffnen Sie nun ein neues Terminalfenster ( <code>testrpc</code> schlie√üen <code>testrpc</code> - es sollte funktionieren) und schreiben Sie es in den Projektordner: <br><br><pre> <code class="bash hljs">truffle migrate --reset</code> </pre> <br>  Dieser magische Befehl kompiliert einen intelligenten Vertrag (dh Sie m√ºssen nicht jedes Mal eine <code>truffle compile</code> schreiben) und stellt ihn auf dem lokal ge√∂ffneten Blockchain-Mikroserver bereit.  Es ist erw√§hnenswert, dass, wenn <code>testrpc</code> dies sofort tut, der Test und die realen Blockchains die Transaktion in den n√§chsten Bl√∂cken viel l√§nger enthalten.  Danach sollten Sie so etwas in der Konsole ausspucken: <br><br><pre> <code class="bash hljs">Using network <span class="hljs-string"><span class="hljs-string">'development'</span></span>. Running migration: 1_initial_migration.js Running step... Replacing MyToken... ... 0x86a7090b0a279f8befc95b38fa8bee6918df30928dda0a3c48416454e2082b65 MyToken: 0x2dc35f255e56f06bd2935f5a49a0033548d85477 Replacing MyCrowdsale... ... 0xf0aab5d550f363478ac426dc2aff570302a576282c6c2c4e91205a7a3dea5d72 MyCrowdsale: 0xaac611907f12d5ebe89648d6459c1c81eca78151 ... 0x459303aa0b79be2dc2c8041dd48493f2d0e109fac19588f50c0ac664f34c7e30 Saving artifacts...</code> </pre> <br>  Ich denke, Sie haben bereits erkannt, dass die Konsole Ihnen die Adressen der Smart-Vertr√§ge <code>MyToken</code> und <code>MyCrowdsale</code> .  Das ist alles!  Der Smart-Vertrag ist in die Blockchain eingebettet, deren Mikroserver Sie ge√∂ffnet haben.  Es bleibt nur zu √ºberpr√ºfen, ob die Token tats√§chlich an Benutzer verteilt werden, die Kefir an den <code>MyCrowdsale</code> Smart-Vertrag senden.  Wir schreiben Folgendes in das Terminal, um die Tr√ºffelkonsole zu betreten: <br><br><pre> <code class="bash hljs">truffle console</code> </pre> <br>  Wir schreiben folgendes in den jetzt Tr√ºffel (nur kein Kommentar): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   - t="0x2dc35f255e56f06bd2935f5a49a0033548d85477" //     MyToken ="0xaac611907f12d5ebe89648d6459c1c81eca78151" //     MyCrowdsale //   - token=MyToken.at(t) crowdsale=MyCrowdsale.at(c) //       account=web3.eth.accounts[0] // ,      token.balanceOf(account) //   0 //    - web3.eth.sendTransaction({from: account, to:c, value: web3.toWei(0.1, 'ether'), gas: 900000})</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Fall von k√∂nnen </font></font><code>testrpc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie den Kontostand unserer Brieftasche sofort erneut √ºberpr√ºfen. Im Fall des Tests und der echten Blockchain m√ºssen Sie jedoch warten, bis unsere Transaktion im Block enthalten ist. In der Regel erhalten Sie in diesem Fall von der Tr√ºffel die Transaktionsnummer. Hast du gewartet √úberpr√ºfen Sie noch einmal unser Guthaben in </font></font><code>MyToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,      token.balanceOf(account) //    </span></span></code> </pre> <br>  Das ist alles!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testen Sie zuerst Ihren Vertrag am </font></font><code>testrpc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dann am </font></font><code>geth --testnet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann am </font></font><code>geth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie haben also Ihr eigenes ICO gestartet! Und Sie mussten nicht zehn Kilobaks f√ºr Audit und Start ausgeben. Es ist eigentlich sehr schwierig, mit dem, was uns die Jungs von OpenZeppelin zur Verf√ºgung gestellt haben, durcheinander zu bringen. Und wenn Sie es benutzen </font></font><code>truffle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- so wird Solidarit√§tsentwicklung im Allgemeinen zu einem M√§rchen. Nun, au√üer in F√§llen, in denen Transaktionen w√§hrend der Ausf√ºhrung eines intelligenten Vertrags r√ºckg√§ngig gemacht werden - deb√ºtieren Sie ihre H√∂lle. Aber das Debuggen von intelligenten Vertr√§gen verdient wirklich einen separaten Artikel.</font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank f√ºr das Lesen bis zum Ende dieses Artikels! Wenn ich Ihnen Zeit oder Geld gespart habe oder wenn Sie aus diesem Artikel etwas Neues gelernt haben, werde ich mich sehr dar√ºber freuen. Ich w√§re auch sehr dankbar, wenn Sie diesen Artikel mit Ihren Freunden oder Bekannten teilen w√ºrden, die einen ICO durchf√ºhren m√∂chten - sparen Sie 75.000 US-Dollar f√ºr Unterprogrammierer, die wie Parasiten Geld aus dem Kryptomarkt heraussaugen und dieselben 25 Codezeilen kopieren . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel Gl√ºck bei der Entwicklung intelligenter Vertr√§ge! Haben Sie noch Fragen? Ich frage Sie in Kommentaren - ich beantworte gerne alles und versuche, bei Problemen zu helfen.</font></font><br><br><h2>  Bonus </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was aber, wenn Sie die Logik √§ndern m√∂chten, nach der der Kaufpreis von Token ber√ºcksichtigt wird? </font><font style="vertical-align: inherit;">Nat√ºrlich k√∂nnen Sie es richtig √§ndern </font></font><code>rate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder eine der Vertragsklassen von OpenZeppelin verwenden, aber was ist, wenn Sie etwas noch Perverseres wollen? </font><font style="vertical-align: inherit;">In einem intelligenten Vertrag k√∂nnen Sie die Funktion </font></font><code>getTokenAmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie folgt </font><font style="vertical-align: inherit;">√ºberschreiben </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getTokenAmount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256 _weiAmount</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint256</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (block.timestamp &lt; <span class="hljs-number"><span class="hljs-number">1533081600</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// August 1st, 2018 rate = rate * 4; } else if (block.timestamp &lt; 1546300800) { // January 1st, 2019 rate = rate * 2; } return _weiAmount.mul(rate); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen kann dies den Preis des Tokens vom Zeitpunkt des Kaufs abh√§ngig machen - je weiter im Wald, desto teurer die Token. </font><font style="vertical-align: inherit;">Haben Sie keine Angst, einige der Funktionen intelligenter Vertr√§ge zu experimentieren und neu zu schreiben - es macht Spa√ü!</font></font><br><br><img src="https://habrastorage.org/webt/3a/mp/lk/3amplkx2fhpeplqauietmgshkc8.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414493/">https://habr.com/ru/post/de414493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414481/index.html">Das PHP-Quiz am Freitag: einige Abenteuer des Programmierers Brad, eine seltsame Sequenz und Preise</a></li>
<li><a href="../de414483/index.html">Geben Sie Safe SQL in Kotlin ein</a></li>
<li><a href="../de414485/index.html">GNMT, episches Versagen oder Feinheiten der maschinellen √úbersetzung</a></li>
<li><a href="../de414487/index.html">Ein seltener Vertreter des Brute-Force-Typs: die Geschichte eines Angriffs</a></li>
<li><a href="../de414489/index.html">Die USA planen, das Problem der Weltraumm√ºll ernsthaft anzugehen</a></li>
<li><a href="../de414495/index.html">toString: Gro√üartig und schrecklich</a></li>
<li><a href="../de414497/index.html">Consulo UI API von der Idee bis zum Prototyp</a></li>
<li><a href="../de414499/index.html">Bericht des Club of Rome 2018, Kapitel 1.1.3: ‚ÄûEine leere Welt gegen einen vollen Frieden‚Äú</a></li>
<li><a href="../de414501/index.html">Bericht des Club of Rome 2018, Kapitel 3.11: ‚ÄûReformen des Finanzsektors‚Äú</a></li>
<li><a href="../de414503/index.html">Intel NUC Hades Canyon mit AMD Vega Graphics - VR oder nicht VR?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>