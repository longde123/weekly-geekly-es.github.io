<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüè´ üîì ü§±üèΩ La evoluci√≥n de un algoritmo √∫nico. üí† üò∑ üôéüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace alg√∫n tiempo, mi colega me pidi√≥ que lo ayudara con un problema. Resolv√≠ el problema por √©l, pero adem√°s, me pareci√≥ que al resolver este problem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La evoluci√≥n de un algoritmo √∫nico.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454850/"><p> Hace alg√∫n tiempo, mi colega me pidi√≥ que lo ayudara con un problema.  Resolv√≠ el problema por √©l, pero adem√°s, me pareci√≥ que al resolver este problema se podr√≠an explicar varios algoritmos y t√©cnicas de programaci√≥n.  Y tambi√©n muestra la aceleraci√≥n del tiempo de ejecuci√≥n del algoritmo de 25 segundos a 40 ms. </p><a name="habracut"></a><br><h1 id="postanovka-zadachi">  Declaraci√≥n del problema. </h1><br><p>  Para un proyecto personal, mi colega necesitaba un algoritmo para encontrar cincuenta videos m√°s similares para un video dado.  Se supon√≠a que la similitud se estimaba por el n√∫mero de etiquetas expuestas coincidentes.  Cuantas m√°s etiquetas coincida con el video, m√°s se parecen.  De esto podemos sacar inmediatamente varias conclusiones: </p><br><ul><li>  Todas las etiquetas debajo del video se pueden combinar en un grupo; </li><li>  definitivamente no habr√° m√°s grupos de este tipo que los videos mismos; </li><li>  si el video es similar a otro video de un determinado grupo de etiquetas, entonces es igualmente similar a otros videos de este grupo; </li></ul><br><p>  Resulta que es suficiente trabajar solo con grupos de etiquetas.  En la primera versi√≥n, un colega decidi√≥ almacenar etiquetas en una tabla de etiquetas: cada video tiene un enlace a la ID del grupo de etiquetas, y los grupos mismos son una secuencia de valores booleanos que indican si la etiqueta correspondiente est√° configurada.  En C #, un grupo de etiquetas se ve as√≠: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><p>  Un colega sugiri√≥ que en el sitio no tendr√≠a m√°s de un mill√≥n de videos, y varias etiquetas no m√°s de 4000, para una cuenta redonda puede tomar 4096 = 2 ^ 12. <br>  Entonces la clase <code>TagsGroup</code> se puede representar as√≠: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = innerTags; } }</code> </pre> <br><p>  Ahora debe verificar la similitud de los dos grupos de etiquetas.  En las condiciones actuales, esto se convierte en una simple verificaci√≥n de verdadero en los elementos correspondientes de las matrices <code>InnerTags</code> de dos grupos de etiquetas: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Ahora solo queda calcular la similitud del grupo de etiquetas deseado con cada grupo existente y seleccionar los cincuenta m√°s similares.  Me puse otra condici√≥n para asegurar la estabilidad de la muestra, es decir  en la muestra final, habr√° cincuenta grupos de etiquetas para los cuales <code>MeasureSimilarity</code> dio el resultado m√°s alto, mientras que los grupos de etiquetas con la misma <code>MeasureSimilarity</code> √≠ndice m√°s bajo para aquellos que ten√≠an un √≠ndice m√°s bajo en el grupo existente original.  Se pueden encontrar m√°s detalles, por ejemplo, aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://ru.wikipedia.org/wiki/Sustainable_Sort</a> . <br>  Para resolver este problema, decid√≠ hacer la clase <code>SimilarTagsCalculator</code> , aqu√≠ est√° su c√≥digo: </p><br><div class="spoiler">  <b class="spoiler_title">Etiquetas similaresCalculador</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimilarTagsCalculator</span></span> { TagsGroup[] Groups { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimilarTagsCalculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] groups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groups == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(groups)); Groups = groups; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,          var list = new List&lt;TagsSimilarityInfo&gt;(resultLength); //      for (int groupIndex = 0; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; //      int similarityValue = TagsGroup.MeasureSimilarity(value, tagsGroup); // -  TagsSimilarityInfo newInfo = new TagsSimilarityInfo(groupIndex, similarityValue); //    ,     , if (list.Count == resultLength &amp;&amp; list[resultLength - 1].CompareTo(newInfo) == -1) { continue; //     } //   ,    -  int index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); // if (list.Count &gt; resultLength) { //    , //   , ..    list.RemoveAt(resultLength); } } // -   TagsGroup[] result = new TagsGroup[resultLength]; for (int i = 0; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } return result; } }</span></span></code> </pre> </div></div><br><p>  y la estructura <code>TagsSimilarityInfo</code> : </p><br><div class="spoiler">  <b class="spoiler_title">EtiquetasSimilaridadInfo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TagsSimilarityInfo : IComparable&lt;TagsSimilarityInfo&gt;, IComparable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Similarity { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsSimilarityInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> similarity</span></span></span><span class="hljs-function">)</span></span> { Index = index; Similarity = similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Index == other.Index &amp;&amp; Similarity == other.Similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other &amp;&amp; Equals(other); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Index * <span class="hljs-number"><span class="hljs-number">397</span></span>) ^ Similarity; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityComparison = other.Similarity.CompareTo(Similarity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> similarityComparison != <span class="hljs-number"><span class="hljs-number">0</span></span> ? similarityComparison : Index.CompareTo(other.Index); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ReferenceEquals(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, obj)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other ? CompareTo(other) : <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">$"Object must be of type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(TagsSimilarityInfo)}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> </div></div><br><p>  Prepar√© tres puntos de referencia para este algoritmo: </p><br><ul><li>  punto de referencia completamente al azar, es decir  el n√∫mero de etiquetas establecidas en los grupos es aleatorio y el grupo de etiquetas con el que compararemos tambi√©n es aleatorio; </li><li>  el n√∫mero de etiquetas establecidas en grupos est√° aumentando, lo compararemos con el grupo en el que se configuran todas las etiquetas.  Resulta que algunos de los √∫ltimos grupos de etiquetas deber√≠an ser los m√°s adecuados; </li><li>  igual que el anterior, pero el n√∫mero de etiquetas expuestas est√° disminuyendo.  Los primeros 50 grupos de etiquetas ser√°n los m√°s adecuados; </li></ul><br><p>  Estos son los resultados de referencia para un mill√≥n de grupos: </p><br><p>  BenchmarkDotNet = v0.11.5, OS = Windows 10.0.17134.765 (1803 / April2018Update / Redstone4) <br>  Intel Core i7-6700 CPU 3.40GHz (Skylake), 1 CPU, 8 n√∫cleos l√≥gicos y 4 f√≠sicos <br>  Frecuencia = 3328126 Hz, Resoluci√≥n = 300.4694 ns, Temporizador = TSC <br>  .NET Core SDK = 3.0.100-preview5-011568 <br>  [Host]: .NET Core 3.0.0-preview5-27626-15 (CoreCLR 4.6.27622.75, CoreFX 4.700.19.22408), RyuJIT de 64 bits </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Asignado </th></tr></thead><tbody><tr><td>  Prueba aleatoria </td><td>  25,054 s </td><td>  0.1786 s </td><td>  0.1670 s </td><td>  1,53 KB </td></tr><tr><td>  Prueba ascendente </td><td>  4.180 s </td><td>  0,0174 s </td><td>  0,0162 s </td><td>  1,53 KB </td></tr><tr><td>  Prueba descendiente </td><td>  4.147 s </td><td>  0,0118 s </td><td>  0,0104 s </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  La extensi√≥n del tiempo de ejecuci√≥n es muy grande, adem√°s de 25 segundos es un tiempo muy largo, mi colega no acepta esperar tanto.  Entonces hagamos optimizaciones.  Ahora hay tres √°reas principales para acelerar el programa: </p><br><ul><li>  <code>MeasureSimilarity</code> M√©todo de <code>MeasureSimilarity</code> ; </li><li>  un algoritmo en el cuerpo del bucle en <code>GetFiftyMostSimilarGroups</code> ; </li><li>  el propio bucle en <code>GetFiftyMostSimilarGroups</code> ; </li></ul><br><p>  Consideraremos cada una de las tres direcciones en secuencia. </p><br><h1 id="predskazanie-vetvleniy">  Predicci√≥n de rama </h1><br><p>  Primero, considere el m√©todo <code>MeasureSimilarity</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  En el punto de referencia anterior, hubo una gran variaci√≥n en el tiempo de ejecuci√≥n entre la prueba aleatoria y cualquiera de las secuenciales.  Los grupos de etiquetas para pruebas secuenciales fueron creados por el siguiente principio: </p><br><ul><li>  el n√∫mero requerido de grupos se dividi√≥ en paquetes.  N√∫mero de paquetes: el n√∫mero m√°ximo de etiquetas en el grupo; </li><li>  para cada grupo en el paquete i-th, se establecieron las primeras etiquetas i; </li></ul><br><p>  Resulta que cada grupo de etiquetas en estas pruebas consta de dos partes consecutivas de etiquetas expuestas y no expuestas.  <code>MeasureSimilarity</code> tiene todos los requisitos previos para que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">predicci√≥n de la rama</a> del procesador tenga un efecto significativo en las condiciones actuales.  Para verificar esto, simplemente escriba un punto de referencia que compare el tiempo de ejecuci√≥n de MeasureSimilarity para datos aleatorios y secuenciales: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSimilaritySum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] tagsGroups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TagsGroup tagsGroup <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tagsGroups) { result += TagsGroup.MeasureSimilarity(tagsGroup, etalon); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(sortedGroups); [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(unsortedGroups);</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Ordenados </td><td>  3.704 s </td><td>  0,0411 s </td><td>  0,0364 s </td></tr><tr><td>  Sin clasificar </td><td>  8.211 s </td><td>  0,0381 s </td><td>  0,0338 s </td></tr></tbody></table></div><br><p>  Se probaron un mill√≥n de grupos de etiquetas, pero en <code>Sorted</code> en cada grupo al principio hab√≠a varias etiquetas expuestas, y luego no expuestas, y en <code>Unsorted</code> la misma cantidad de etiquetas expuestas se dispersaron al azar en todo el grupo. <br>  La diferencia de 5 segundos es impresionante, y hay que hacer algo.  Para deshacerse de la influencia de la predicci√≥n de ramas y, en general, acelerar el m√©todo, debe deshacerse de las ramas mismas.  Solo hay una rama en <code>MeasureSimilarity</code> : verificar que las etiquetas correspondientes est√©n configuradas en dos grupos.  Vamos a estimar en qu√© casos la condici√≥n ser√° verdadera, para esto haremos una tabla de la verdad de la condici√≥n: </p><br><div class="scrollable-table"><table><thead><tr><th>  a.InnerTags [i] </th><th>  b.InnerTags [i] </th><th>  Resultado </th></tr></thead><tbody><tr><td>  Falso </td><td>  Falso </td><td>  Falso </td></tr><tr><td>  Falso </td><td>  Cierto </td><td>  Falso </td></tr><tr><td>  Cierto </td><td>  Falso </td><td>  Falso </td></tr><tr><td>  Cierto </td><td>  Cierto </td><td>  Cierto </td></tr></tbody></table></div><br><p>  La tabla de verdad coincide completamente con el l√≥gico "Y", es decir.  el resultado es verdadero si y solo si ambas etiquetas son verdaderas, entonces la condici√≥n puede reducirse a: <code>if (a.InnerTags[i] &amp;&amp; b.InnerTags[i])</code> .  Pero de esta manera la condici√≥n a√∫n permanece.  En el siguiente paso, nos aseguraremos de que siempre se realice la suma al resultado, para esto reescribiremos el cuerpo del bucle de esta manera: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp;&amp; b.InnerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; result += t;</code> </pre> <br><p>  Todav√≠a no eliminamos la condici√≥n e incluso hicimos el m√©todo m√°s lento.  Pero ahora es obvio que si el tipo de <code>InnerTags</code> cambia de bool a byte (1 para verdadero y 0 para falso), puede deshacerse de la condici√≥n en el operador ternario.  Entonces la clase <code>TagsGroup</code> se ver√° as√≠: </p><br><div class="spoiler">  <b class="spoiler_title">EtiquetasGrupo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[TagsGroupLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { InnerTags[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (innerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> </div></div><br><p>  Estos son los resultados de referencia para el <code>MeasureSimilarity</code> actualizado: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Ordenados </td><td>  3.180 s </td><td>  0,0118 s </td><td>  0,0111 s </td></tr><tr><td>  Sin clasificar </td><td>  3.236 s </td><td>  0,0622 s </td><td>  0,0764 s </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">fue:</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Ordenados </td><td>  3.704 s </td><td>  0,0411 s </td><td>  0,0364 s </td></tr><tr><td>  Sin clasificar </td><td>  8.211 s </td><td>  0,0381 s </td><td>  0,0338 s </td></tr></tbody></table></div></div></div><br><p>  pero para el bechmark principal actualizado: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Asignado </th></tr></thead><tbody><tr><td>  Prueba aleatoria </td><td>  3.219 s </td><td>  0,0492 s </td><td>  0,0436 s </td><td>  1,53 KB </td></tr><tr><td>  Prueba ascendente </td><td>  3.223 s </td><td>  0,0117 s </td><td>  0.0110 s </td><td>  1,53 KB </td></tr><tr><td>  Prueba descendiente </td><td>  3.422 s </td><td>  0,0697 s </td><td>  0,0999 s </td><td>  1,53 KB </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">fue:</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Asignado </th></tr></thead><tbody><tr><td>  Prueba aleatoria </td><td>  25,054 s </td><td>  0.1786 s </td><td>  0.1670 s </td><td>  1,53 KB </td></tr><tr><td>  Prueba ascendente </td><td>  4.180 s </td><td>  0,0174 s </td><td>  0,0162 s </td><td>  1,53 KB </td></tr><tr><td>  Prueba descendiente </td><td>  4.147 s </td><td>  0,0118 s </td><td>  0,0104 s </td><td>  1,53 KB </td></tr></tbody></table></div></div></div><br><p>  En mi opini√≥n, ya era genial.  Para aquellos que estaban convencidos de que toda la aceleraci√≥n ocurri√≥ solo porque el tipo booleano fue reemplazado por un byte, lanc√© un punto de referencia para dicho cuerpo de bucle: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-number"><span class="hljs-number">1</span></span>) result += t;</code> </pre> <br><p>  y estos son los resultados: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Ordenados </td><td>  3.760 s </td><td>  0,0746 s </td><td>  0.1541 s </td></tr><tr><td>  Sin clasificar </td><td>  8.628 s </td><td>  0.1699 s </td><td>  0.2382 s </td></tr></tbody></table></div><br><h1 id="upakovyvanie-dannyh">  Embalaje de datos </h1><br><p>  Cada grupo tiene muchas etiquetas, y su n√∫mero no se puede reducir de ninguna manera.  Adem√°s, debe comparar las etiquetas con el mismo √≠ndice, y no puede dar una respuesta final sin verificar todas las etiquetas.  Entonces, en cualquier caso, tendremos que iterar sobre todo el grupo de etiquetas.  Ser√≠a genial poder paralelizar esta tarea de alguna manera, de modo que sea posible procesar varias etiquetas en una operaci√≥n condicional.  Puede hacerlo a trav√©s de la paralelizaci√≥n real, o puede hacerlo a trav√©s de un paquete especial de datos, que usaremos.  Cada etiqueta ahora representa 1 o 0. En el <code>result</code> resultado de la operaci√≥n "Y" simplemente se acumula.  Pero la misma operaci√≥n l√≥gica se puede aplicar no solo a n√∫meros de un solo bit.  C # le permite hacer esto sin problemas hasta n√∫meros de 64 bits (puede hacer m√°s a trav√©s de <code>BitArray</code> , pero eso no es todo).  Si representamos dos grupos de etiquetas como un conjunto de n√∫meros de 64 bits con el conjunto de bits correspondiente, entonces ser√° posible llevar a cabo una operaci√≥n "Y" en cada grupo de n√∫meros de 64 bits.  No est√° claro qu√© hacer con el resultado.  Veamos nuevamente el cuerpo del bucle: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t;</code> </pre> <br><p>  el resultado aumenta en 1 cada vez que t == 1 y no cambia cuando t == 0. Como resultado, el resultado ser√° igual a cu√°ntas veces el resultado de <code>a.InnerTags[i] &amp; b.InnerTags[i]</code> fue uno.  En consecuencia, ser√≠a posible guardar todos los resultados de <code>a.InnerTags[i] &amp; b.InnerTags[i]</code> en alguna matriz, y en el resultado escribir solo el n√∫mero de unidades en esta matriz.  Al realizar la operaci√≥n AND en m√°s de n√∫meros de n bits, se obtendr√° un resultado de n bits y ser√° suficiente solo para saber cu√°ntos bits se establecen entre n.  El n√∫mero de bits establecido en el n√∫mero no cambia, lo que significa que puede contar estos n√∫meros.  No tiene sentido contar 64 bits, ya que  No encontraremos tanta RAM.  Para 32 bits, ya puedes encontrar espacio en las computadoras modernas, pero esto sigue siendo mucho.  La memoria de menos de 16 bits no es dif√≠cil de encontrar, pero el c√°lculo ser√° relativamente largo.  Como compromiso, calculemos para n√∫meros de 8 bits: </p><br><div class="spoiler">  <b class="spoiler_title">GenerateCountOfSettedBits</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] CountOfSettedBits = GenerateCountOfSettedBits(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateCountOfSettedBits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  result   i      i- . byte[] result = new byte[256]; //  ,      i   , //        int[] b = new int[8]; //     for (int i = 1; i &lt; 256; i++) { //       int settedBitsCount = 0; //,       int m = 1; //   for (int j = 0; j &lt; 8; j++) { //     b[j] += m; //  ,       2. m = b[j] &gt;&gt; 1; //        b[j] = b[j] &amp; 1; //,        settedBitsCount += b[j]; } result[i] = (byte) settedBitsCount; //   } return result; }</span></span></code> </pre> </div></div><br><p>  ahora el constructor de TagsGroup se ve as√≠: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    InnerTags = new byte[TagsGroupLength / BucketSize]; //   for (int i = 0; i &lt; TagsGroupLength / BucketSize; i++) { //     for (int j = 0; j &lt; BucketSize; j++, index++) { //    2,      InnerTags[i] &lt;&lt;= 1; //    InnerTags[i] += (byte) (innerTags[index] ? 1 : 0); } } }</span></span></code> </pre> <br><p>  Y <code>MeasureSimilarity</code> comenz√≥ a verse as√≠: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Puede ejecutar un punto de referencia grande y asegurarse de que todo est√© mejor: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Asignado </th></tr></thead><tbody><tr><td>  Prueba aleatoria </td><td>  560,5 ms </td><td>  8,285 ms </td><td>  7,344 ms </td><td>  1,53 KB </td></tr><tr><td>  Prueba ascendente </td><td>  570,1 ms </td><td>  4,108 ms </td><td>  3,431 ms </td><td>  1,53 KB </td></tr><tr><td>  Prueba descendiente </td><td>  608,1 ms </td><td>  5.691 ms </td><td>  5.324 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  ¬øEs posible hacer que el m√©todo <code>MeasureSimilarity</code> a√∫n m√°s r√°pido?  Por supuesto!  Para hacer esto, es suficiente darse cuenta del hecho de que los registros de prop√≥sito general ahora son en su mayor√≠a de 64 bits, y manejamos datos de ocho bits en ellos.  Para hacer esto, aumente el tama√±o del paquete en el que se empaquetan las etiquetas originales, aumente a 64 bits y vuelva a escribir los m√©todos necesarios: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; BucketSize / <span class="hljs-number"><span class="hljs-number">8</span></span>; j++) { result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  y resulta que: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Asignado </th></tr></thead><tbody><tr><td>  Prueba aleatoria </td><td>  533,3 ms </td><td>  4,802 ms </td><td>  4,492 ms </td><td>  1,53 KB </td></tr><tr><td>  Prueba ascendente </td><td>  550,9 ms </td><td>  5.435 ms </td><td>  5.084 ms </td><td>  1,53 KB </td></tr><tr><td>  Prueba descendiente </td><td>  567,6 ms </td><td>  3,879 ms </td><td>  3,439 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Luego puede expandir el bucle interno: </p><br><div class="spoiler">  <b class="spoiler_title">Medida Similitud</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Asignado </th></tr></thead><tbody><tr><td>  Prueba aleatoria </td><td>  370,5 ms </td><td>  2.802 ms </td><td>  2,484 ms </td><td>  1,53 KB </td></tr><tr><td>  Prueba ascendente </td><td>  395,8 ms </td><td>  2.682 ms </td><td>  2.509 ms </td><td>  1,53 KB </td></tr><tr><td>  Prueba descendiente </td><td>  419,5 ms </td><td>  3.352 ms </td><td>  2.971 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  ¬øEs a√∫n m√°s r√°pido?  Si!  Si usa las innovaciones de .NET Core 3.0.  Aunque esta versi√≥n todav√≠a est√° en la vista previa, desde el principio hay una implementaci√≥n de algunos intr√≠nsecos.  La Gu√≠a intr√≠nseca de Intel tiene el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>_mm_popcnt_u64</code></a> intr√≠nseco.  Que, como se describe: " <em>Cuente el n√∫mero de bits establecido en 1 en un entero de 64 bits sin signo a, y devuelva ese recuento en dst</em> ".  ¬°Esto es exactamente lo que estamos tratando de lograr!  En .NET Core 3.0 Preview 5, este intr√≠nseco se implementa en <code>System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount</code> (Como se se√±al√≥ correctamente en los comentarios de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">a-tk</a> , debe verificar que el procesador los admita antes de usar intr√≠nsecos. En este caso, verifique la condici√≥n del <code>System.Runtime.Intrinsics.X86.Popcnt.X64.IsSupported</code> ).  Al <code>MeasureSimilarity</code> , el c√≥digo del m√©todo <code>MeasureSimilarity</code> ser√° as√≠: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount(t); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  y tiempo de ejecuci√≥n: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Asignado </th></tr></thead><tbody><tr><td>  Prueba aleatoria </td><td>  59,33 ms </td><td>  1.148 ms </td><td>  0,9585 ms </td><td>  1,53 KB </td></tr><tr><td>  Prueba ascendente </td><td>  74,87 ms </td><td>  1,479 ms </td><td>  1,99748 ms </td><td>  1,53 KB </td></tr><tr><td>  Prueba descendiente </td><td>  119,46 ms </td><td>  2.321 ms </td><td>  2,8509 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Impresionante <br>  No conozco las formas que pueden acelerar significativamente <code>MeasureSimilarity</code> y, al mismo tiempo, no estropear en gran medida la legibilidad.  Creo que puedes terminar este m√©todo. </p><br><h1 id="struktury-dannyh">  Estructuras de datos </h1><br><p>  Ahora trataremos el cuerpo del bucle en el m√©todo <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroups</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Perm√≠tanme recordar brevemente lo que est√° sucediendo aqu√≠: </p><br><ul><li>  dentro de la lista, se almacena una lista ordenada de los cincuenta grupos de etiquetas m√°s adecuados, de hecho de menor a mayor, si compara <code>TagsSimilarityInfo</code> ; </li><li>  inserte el nuevo grupo en cuesti√≥n en la lista mientras conserva la clasificaci√≥n; </li><li>  si hay m√°s de cincuenta elementos en la lista, elimine el grupo menos similar (su objeto de informaci√≥n ser√° el m√°s grande y estar√° al final de la <code>list</code> ); </li></ul><br><p>  Es decir  Resulta que necesitamos encontrar r√°pidamente el elemento m√°s grande de la colecci√≥n, poder insertarlo y eliminarlo r√°pidamente.  Para resolver tales problemas, hay estructuras de datos especiales.  Lo primero que viene a la mente es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mont√≥n</a> .  Su inserci√≥n se realiza en O (log N), obteniendo el m√°ximo en O (1), eliminando un elemento en O (log N).  El √∫nico problema es que el mont√≥n no puede ser iterado por los elementos crecientes sin modificarlo.  No hay un mont√≥n binario en BCL, as√≠ que lo escrib√≠ yo mismo: </p><br><div class="spoiler">  <b class="spoiler_title">Binaryheap</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BinaryHeap</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;:<span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span> : <span class="hljs-title"><span class="hljs-title">IComparable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;T&gt; innerList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryHeap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity</span></span></span><span class="hljs-function">)</span></span> { innerList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(capacity); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count =&gt; innerList.Count; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Max =&gt; innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { innerList.Add(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; innerList[parent].CompareTo(innerList[i]) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { Swap(i, parent); i = parent; parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { T temp = innerList[a]; innerList[a] = innerList[b]; innerList[b] = temp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Heapify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftChild = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightChild = (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> largestChild = i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftChild &lt; Count &amp;&amp; innerList[leftChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = leftChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightChild &lt; Count &amp;&amp; innerList[rightChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = rightChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (largestChild == i) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Swap(i, largestChild); i = largestChild; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveMax</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>] = innerList[Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; innerList.RemoveAt(Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Heapify(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerList.GetEnumerator(); } IEnumerator IEnumerable.GetEnumerator() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((IEnumerable) innerList).GetEnumerator(); } }</code> </pre> </div></div><br><p>  La implementaci√≥n correspondiente del m√©todo <code>GetFiftyMostSimilarGroups</code> se puede encontrar en el c√≥digo fuente del art√≠culo (enlace a continuaci√≥n). <br>  Adem√°s del mont√≥n, puede aparecer un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rbol de b√∫squeda binario</a> .  Un √°rbol de b√∫squeda binario equilibrado puede proporcionar inserci√≥n para O (log N), obteniendo un m√°ximo para O (log N), eliminando un elemento para O (log N).  La ventaja de dicha estructura es que puede iterarse en orden ascendente y, adem√°s, el √°rbol de b√∫squeda rojo-negro en BCL se implementa dentro de SortedSet (en un marco grande, obtener un m√°ximo es mucho m√°s lento que en .netcore 3.0 y asigna memoria).  La implementaci√≥n de <code>GetFiftyMostSimilarGroups</code> para SortedSet se puede encontrar en el c√≥digo fuente del art√≠culo. <br>  Resultados de referencia para las tres implementaciones de <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Algoritmo de clasificaci√≥n </th><th>  Media </th><th>  Asignado </th></tr></thead><tbody><tr><td>  Prueba aleatoria </td><td>  Lista </td><td>  60,06 ms </td><td>  1704 B </td></tr><tr><td>  Prueba aleatoria </td><td>  Conjunto ordenado </td><td>  65,46 ms </td><td>  24384 B </td></tr><tr><td>  Prueba aleatoria </td><td>  Mont√≥n </td><td>  60,55 ms </td><td>  2912 B </td></tr><tr><td>  Prueba ascendente </td><td>  Lista </td><td>  75,42 ms </td><td>  1704 B </td></tr><tr><td>  Prueba ascendente </td><td>  Conjunto ordenado </td><td>  16,12 ms </td><td>  9833424 B </td></tr><tr><td>  Prueba ascendente </td><td>  Mont√≥n </td><td>  86,87 ms </td><td>  2912 B </td></tr><tr><td>  Prueba descendiente </td><td>  Lista </td><td>  119,23 ms </td><td>  880 B </td></tr><tr><td>  Prueba descendiente </td><td>  Conjunto ordenado </td><td>  125,03 ms </td><td>  3024 B </td></tr><tr><td>  Prueba descendiente </td><td>  Mont√≥n </td><td>  118,62 ms </td><td>  2088 B </td></tr></tbody></table></div><br><p>  La implementaci√≥n original con una hoja gana casi en todas partes en el tiempo, y ciertamente en todas partes en la memoria.  Esto sucede debido al hecho de que para un algoritmo con una hoja, la inserci√≥n se realiza en O (log N) para la b√∫squeda, y casi O (1) para la inserci√≥n, porque  copiar un n√∫mero tan peque√±o de elementos ocurre muy r√°pidamente, obteniendo un m√°ximo para O (1), eliminando un elemento tambi√©n para O (1), porque  en .net, la eliminaci√≥n del √∫ltimo elemento de la hoja se reemplaza escribiendo en el √∫ltimo elemento un valor vac√≠o (en .net core no se escribe nada en las estructuras).  Si fuera necesario dar no 50, pero digamos 1000 de los grupos m√°s similares, lo m√°s probable es que un algoritmo con una hoja no funcione.  De hecho, todo esto es un peque√±o razonamiento especulativo, porque  Todav√≠a puede ajustar cada uno de los algoritmos. </p><br><h1 id="mnogopotochnost">  Multithreading </h1><br><p>  Ahora queda por tratar de mejorar el bucle en <code>GetFiftyMostSimilarGroups</code> .  Solo me viene a la mente el multihilo.  La idea es dividir la lista completa de grupos en varios paquetes.  En cada paquete, encuentre los 50 grupos de etiquetas m√°s similares, y luego entre ellos encuentre los 50 grupos finales m√°s similares. <br>  La versi√≥n multiproceso de <code>GetFiftyMostSimilarGroups</code> ve as√≠: </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThread</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,     const int threadsCount = 4; //   int bucketSize = Groups.Length / threadsCount; var tasks = new Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { int leftIndex = i * bucketSize; //    int rightIndex = (i + 1) * bucketSize; //    //    tasks[i] = Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;.Factory.StartNew(() =&gt; GetFiftyMostSimilarGroupsMultiThreadCore(value, leftIndex, rightIndex)); } Task.WaitAll(tasks); //    var taskResults = new List&lt;TagsSimilarityInfo&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { taskResults[i] = tasks[i].Result; } //      return MergeTaskResults(resultLength, threadsCount, taskResults); }</span></span></code> </pre> </div></div><br><p>  <code>GetFiftyMostSimilarGroupsMultiThreadCore</code>       <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler"> <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThreadCore</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;TagsSimilarityInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThreadCore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leftIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rightIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(resultLength); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = leftIndex; groupIndex &lt; rightIndex; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> </div></div><br><p>     <code>MergeTaskResults</code> .   -    taskResults    . ,  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> .     ,  <code>threadsCount</code> ,     :         ,     ,    ,    : </p><br><div class="spoiler"> <b class="spoiler_title">MergeTaskResults</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MergeTaskResults</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resultLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadsCount, List&lt;TagsSimilarityInfo&gt;[] taskResults</span></span></span><span class="hljs-function">)</span></span> { TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[threadsCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; TagsSimilarityInfo currentBest = taskResults[minIndex][indices[minIndex]]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; threadsCount; j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = taskResults[j][indices[j]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.CompareTo(currentBest) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { minIndex = j; currentBest = taskResults[minIndex][indices[minIndex]]; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = currentBest.Index; result[i] = Groups[groupIndex]; indices[minIndex]++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  <code>indices</code>      <code>taskResults</code> ; </li><li> <code>minIndex</code> ‚Äî   <code>taskResults</code> ,         ; </li><li> <code>currentBest</code> ‚Äî -      ; </li><li> <code>current</code> ‚Äî -    ; </li></ul><br><p>    : </p><br><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 28.76 ms </td><td> 0.5677 ms </td><td> 1.414 ms </td><td> 1.4 KB </td></tr><tr><td> AscendantTest </td><td> 32.36 ms </td><td> 0.8930 ms </td><td> 2.591 ms </td><td> 1.4 KB </td></tr><tr><td> DescendantTest </td><td> 41.36 ms </td><td> 0.8908 ms </td><td> 2.626 ms </td><td> 1.4 KB </td></tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title">     :</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 25054 ms </td><td> 1786 ms </td><td> 1670 ms </td><td> 1.53 KB </td></tr><tr><td> AscendantTest </td><td> 4180 ms </td><td> 174 ms </td><td> 162 ms </td><td> 1.53 KB </td></tr><tr><td> DescendantTest </td><td> 4147 ms </td><td> 118 ms </td><td> 104 ms </td><td> 1.53 KB </td></tr></tbody></table></div></div></div><br><p>            .   .    ,    ,       4  50. , ,   . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454850/">https://habr.com/ru/post/454850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454830/index.html">3 cualidades clave para un gerente de producto exitoso: Alexander Belyaev</a></li>
<li><a href="../454832/index.html">¬øPor qu√© una semana laboral de cuatro d√≠as es una mala historia?</a></li>
<li><a href="../454834/index.html">Los t√©rminos reales del estudio de la escritura t√°ctil con baja motivaci√≥n.</a></li>
<li><a href="../454840/index.html">Cuidado de mudarse a los Pa√≠ses Bajos con su esposa e hipoteca. Parte 2: preparar documentos y mudarse</a></li>
<li><a href="../454844/index.html">Odigest: interesante para los dise√±adores de la semana.</a></li>
<li><a href="../454856/index.html">Analizamos vulnerabilidades de validaci√≥n de certificados SSL / TLS en software que no es de navegador</a></li>
<li><a href="../454860/index.html">Ayudemos a QueryProvider a lidiar con cadenas interpoladas</a></li>
<li><a href="../454864/index.html">¬øC√≥mo son los procesos de desarrollo en diversas empresas?</a></li>
<li><a href="../454868/index.html">Compilaci√≥n de C en WebAssembly sin Emscripten</a></li>
<li><a href="../454872/index.html">Space Invaders: ahora en 512 bytes (ensamblador x86)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>