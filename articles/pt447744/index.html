<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê≥ üõ¥ üë¥üèº Escalada Elbrus - Reconhecimento em batalha. Parte t√©cnica 2. Interrup√ß√µes, exce√ß√µes, temporizador do sistema üíÖ ‚¨õÔ∏è üë∏üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos a explorar Elbrus portando a Embox . 

 Este artigo √© parte dois de um artigo t√©cnico sobre arquitetura Elbrus. A primeira parte tratou de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escalada Elbrus - Reconhecimento em batalha. Parte t√©cnica 2. Interrup√ß√µes, exce√ß√µes, temporizador do sistema</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447744/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  Continuamos a explorar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Elbrus</a> portando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Embox</a> . <br><br>  Este artigo √© parte dois de um artigo t√©cnico sobre arquitetura Elbrus.  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte</a> tratou de pilhas, registros e assim por diante.  Antes de ler esta parte, recomendamos que voc√™ estude o primeiro, pois ele aborda as coisas b√°sicas da arquitetura Elbrus.  Esta se√ß√£o se concentrar√° em cron√¥metros, interrup√ß√µes e exce√ß√µes.  Novamente, isso n√£o √© documenta√ß√£o oficial.  Para isso, voc√™ deve entrar em contato com os desenvolvedores da Elbrus no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ICST</a> . <a name="habracut"></a><br>  Chegando ao estudo da Elbrus, quer√≠amos iniciar rapidamente o cron√¥metro, porque, como voc√™ sabe, a multitarefa preemptiva n√£o funciona sem ele.  Para fazer isso, parecia suficiente implementar o controlador de interrup√ß√£o e o pr√≥prio cron√¥metro, mas encontramos dificuldades esperadas <s>inesperadas</s> , para onde ir√≠amos sem elas.  Eles come√ßaram a procurar recursos de depura√ß√£o e descobriram que os desenvolvedores cuidavam disso introduzindo v√°rios comandos que permitem criar v√°rias situa√ß√µes excepcionais.  Por exemplo, voc√™ pode gerar uma exce√ß√£o de um tipo especial atrav√©s dos registros PSR (Processor Status Register) e UPSR (User processador status register).  Para PSR, o bit exc_last_wish √© o sinalizador de exce√ß√£o exc_last_wish ao retornar do procedimento e, para o UPSR, o exc_d_interrupt √© o sinalizador de interrup√ß√£o atrasada gerado pela opera√ß√£o VFDI (sinalizador de verifica√ß√£o de interrup√ß√£o atrasada). <br><br>  O c√≥digo √© o seguinte: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UPSR_DI (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   .h  */</span></span></span><span class="hljs-meta"> rrs %upsr, %r1 ors %r1, UPSR_DI, %r1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* upsr |= UPSR_DI; */</span></span></span><span class="hljs-meta"> rws %r1, %upsr vfdi </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span></span></code> </pre> <br>  Lan√ßado.  Mas nada aconteceu, o sistema travou em algum lugar, nada foi enviado para o console.  Na verdade, vimos isso quando tentamos iniciar a interrup√ß√£o a partir do timer, mas havia muitos componentes, e aqui ficou claro que algo interrompeu o progresso seq√ºencial do nosso programa e o controle foi transferido para a tabela de exce√ß√£o (em termos de arquitetura Elbrus, √© mais correto n√£o falar sobre a tabela interrup√ß√µes e sobre a tabela de exce√ß√µes).  Assumimos que o processador, no entanto, lan√ßou uma exce√ß√£o, mas havia algum "lixo" onde transferia o controle.  Como se viu, ele transfere o controle para o mesmo local em que colocamos a imagem da Embox, o que significa que havia um ponto de entrada - a fun√ß√£o de entrada. <br><br>  Para verifica√ß√£o, fizemos o seguinte.  Iniciou um contador de entradas na entrada ().  Inicialmente, todas as CPUs come√ßam com as interrup√ß√µes desativadas, entram na entrada (), ap√≥s as quais deixamos apenas um n√∫cleo ativo, e o restante entra em um loop sem fim.  Depois que o contador for igual ao n√∫mero de CPUs, consideramos que todos os hits subsequentes na entrada s√£o exce√ß√µes.  Lembro que antes era como descrito em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nosso primeiro artigo sobre Elbrus</a> <br><br><pre> <code class="cpp hljs"> cpuid = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;last_cpuid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpuid &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* copy of trap table */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;_t_entry, <span class="hljs-number"><span class="hljs-number">0x1800</span></span>); kernel_start();</code> </pre> <br>  Fez <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Since we enable exceptions only when all CPUs except the main one * reached the idle state (cpu_idle), we can rely that order and can * guarantee exceptions happen strictly after all CPUS entries. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt;= CPU_COUNT) { <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); ... } <span class="hljs-comment"><span class="hljs-comment">/* It wasn't exception, so we decide this usual program execution, * that is, Embox started on CPU0 or CPU1 */</span></span> e2k_wait_all(); entries_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;entries_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> cpu_idle(); } e2k_kernel_start(); }</code> </pre> <br>  E, finalmente, vimos a rea√ß√£o de entrar na interrup√ß√£o (apenas com a ajuda de printf, imprimimos uma linha). <br><br>  Aqui, vale a pena explicar que, inicialmente, na primeira vers√£o, esper√°vamos copiar a tabela de exce√ß√£o, mas, em primeiro lugar, verificou-se que estava em nosso endere√ßo e, em segundo lugar, n√£o conseguimos fazer a c√≥pia correta.  Eu tive que reescrever os scripts do vinculador, o ponto de entrada no sistema e o manipulador de interrup√ß√µes, ou seja, eu precisava da parte do montador, um pouco mais tarde. <br><br>  √â assim que a parte da parte modificada do vinculador de script agora se parece: <br><br><pre> <code class="cpp hljs">.text : { _start = .; _t_entry = .; <span class="hljs-comment"><span class="hljs-comment">/* Interrupt handler */</span></span> *(.ttable_entry0) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x800</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Syscall handler */</span></span> *(.ttable_entry1) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* longjmp handler */</span></span> *(.ttable_entry2) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1800</span></span>; _t_entry_end = .; *(.e2k_entry) *(.cpu_idle) <span class="hljs-comment"><span class="hljs-comment">/* text */</span></span> }</code> </pre><br>  isto √©, removemos a se√ß√£o de entrada da tabela de exce√ß√µes.  A se√ß√£o cpu_idle tamb√©m est√° localizada l√° para as CPUs que n√£o s√£o usadas. <br><br>  √â assim que a fun√ß√£o de entrada se parece com nosso kernel ativo, no qual a Embox ser√° executada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e2k_kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> psr; <span class="hljs-comment"><span class="hljs-comment">/*    CPU ‚Äú‚Äù */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (idled_cpus_count &lt; CPU_COUNT - <span class="hljs-number"><span class="hljs-number">1</span></span>) ; ... <span class="hljs-comment"><span class="hljs-comment">/*     ,     */</span></span> e2k_upsr_write(e2k_upsr_read() &amp; ~UPSR_FE); kernel_start(); <span class="hljs-comment"><span class="hljs-comment">/*   Embox */</span></span> }</code> </pre> <br>  Bem, de acordo com a instru√ß√£o VFDI, uma exce√ß√£o foi lan√ßada.  Agora voc√™ precisa obter o n√∫mero dele para garantir que esta seja a exce√ß√£o correta.  Para isso, a Elbrus possui registros de informa√ß√µes de interrup√ß√£o TIR (registros de informa√ß√µes de intercepta√ß√£o).  Eles cont√™m informa√ß√µes sobre os √∫ltimos comandos, ou seja, a parte final do rastreamento.  O rastreamento √© coletado durante a execu√ß√£o do programa e "congela" ao inserir uma interrup√ß√£o.  TIR inclui as partes baixa (64 bits) e alta (64 bits).  A palavra baixa cont√©m os sinalizadores de exce√ß√£o e a palavra alta cont√©m um ponteiro para a instru√ß√£o que levou √† exce√ß√£o e o n√∫mero TIR atual.  Assim, no nosso caso, exc_d_interrupt √© o quarto bit. <br><br>  Nota Ainda temos algum mal-entendido em rela√ß√£o √† profundidade (n√∫mero) de TIRs.  A documenta√ß√£o fornece: <br><blockquote>  ‚ÄúA profundidade da mem√≥ria TIR, ou seja, o n√∫mero de registros de informa√ß√µes de intercepta√ß√£o, √© determinada <br>  Macro TIR_NUM igual ao n√∫mero de est√°gios do pipeline do processador necess√°rios para <br>  emitir todas as situa√ß√µes especiais poss√≠veis.  TIR_NUM = 19; " </blockquote>  Na pr√°tica, vemos a profundidade = 1 e, portanto, usamos apenas o registro TIR0. <br><br>  Os especialistas do MCST nos explicaram que tudo est√° correto, e s√≥ haver√° TIR0 para interrup√ß√µes "precisas", mas para outras situa√ß√µes, pode haver algo mais.  Mas, enquanto estamos falando apenas de interrup√ß√µes no temporizador, isso n√£o nos incomoda. <br><br>  Ok, agora vamos ver o que √© necess√°rio para entrar / sair corretamente do manipulador de exce√ß√µes.  De fato, √© necess√°rio salvar na entrada e restaurar os 5 registros a seguir na sa√≠da.  Tr√™s registros de prepara√ß√£o de transfer√™ncia de controle s√£o ctpr [1,2,3] e dois registros de controle de ciclo s√£o ILCR (Registro de valores iniciais do contador de ciclo) e LSR (Registro de status do ciclo). <br><br><pre> <code class="cpp hljs">.type ttable_entry0,@function ttable_entry0: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">1</span></span>; rrd %ctpr1, %dr1 rrd %ctpr2, %dr2 rrd %ctpr3, %dr3 rrd %ilcr, %dr4 rrd %lsr, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* sizeof pt_regs */</span></span> getsp -(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>), %dr0 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + PT_CTRP1] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr1 = ctpr1 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + PT_CTRP2] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr2 = ctpr2 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + PT_CTRP3] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr3 = ctpr3 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + PT_ILCR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ilcr = ilcr */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + PT_LSR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;lsr = lsr */</span></span> disp %ctpr1, e2k_entry ct %ctpr1</code> </pre> <br>  Na verdade, √© tudo, depois de sair do manipulador de exce√ß√µes, voc√™ precisa restaurar esses 5 registros. <br><br>  Fazemos isso com uma macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_COMMON_REGS(regs) \ ({ \ uint64_t ctpr1 = regs-&gt;ctpr1, ctpr2 = regs-&gt;ctpr2, \ ctpr3 = regs-&gt;ctpr3, lsr = regs-&gt;lsr, \ ilcr = regs-&gt;ilcr; \ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ctpr2 is restored first because of tight time constraints \ * on restoring ctpr2 and aaldv. */</span></span></span><span class="hljs-meta"> \ E2K_SET_DSREG(ctpr1, ctpr1); \ E2K_SET_DSREG(ctpr2, ctpr2); \ E2K_SET_DSREG(ctpr3, ctpr3); \ E2K_SET_DSREG(lsr, lsr); \ E2K_SET_DSREG(ilcr, ilcr); \ })</span></span></code> </pre> <br>  Tamb√©m √© importante n√£o esquecer, ap√≥s a restaura√ß√£o dos registros, para invocar a opera√ß√£o DONE (Retorno do manipulador de interrup√ß√£o de hardware).  Esta opera√ß√£o √© necess√°ria, em particular, para processar corretamente as opera√ß√µes de transfer√™ncia de controle interrompidas.  Fazemos isso com uma macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_DONE \ do { \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"{nop 3} {done}"</span></span></span><span class="hljs-meta"> ::: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ctpr3"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  Na verdade, fazemos o retorno da interrup√ß√£o diretamente no c√≥digo C usando essas duas macros. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); RESTORE_COMMON_REGS(regs); E2K_DONE;</code> </pre> <br><h3>  Interrup√ß√µes externas </h3><br>  Vamos come√ßar com como habilitar interrup√ß√µes externas.  Em Elbrus, o APIC (ou melhor, seu an√°logo) √© usado como um controlador de interrup√ß√£o; a Embox j√° tinha esse driver.  Portanto, foi poss√≠vel escolher um cron√¥metro para o sistema.  Existem dois temporizadores, um muito parecido com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PIT</a> , o outro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LAPIC Timer</a> , tamb√©m √© bastante padr√£o, por isso n√£o faz sentido falar sobre eles.  Isso e aquilo pareciam simples, e aquilo e aquilo j√° existiam na Embox, mas o driver do temporizador LAPIC parecia mais perspectiva, al√©m da implementa√ß√£o do temporizador PIT nos parecia mais fora do padr√£o.  Portanto, parecia mais f√°cil concluir.  Al√©m disso, a documenta√ß√£o oficial descreveu os registros APIC e LAPIC, que eram ligeiramente diferentes dos originais.  Traz√™-los n√£o faz sentido, como voc√™ pode ver no original. <br><br>  Al√©m de permitir interrup√ß√µes no APIC, voc√™ deve habilitar o tratamento de interrup√ß√µes atrav√©s dos registros PSR / UPSR.  Ambos os registradores possuem sinalizadores para permitir interrup√ß√µes externas e interrup√ß√µes n√£o mascar√°veis.  <i>Mas</i> aqui √© muito importante observar que o registro PSR √© <i>local</i> para a fun√ß√£o (isso foi discutido na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte t√©cnica</a> ).  E isso significa que, se voc√™ a definir dentro de uma fun√ß√£o, quando voc√™ chamar todas as fun√ß√µes subseq√ºentes, ela ser√° herdada, mas quando voc√™ retornar da fun√ß√£o, ela retornar√° ao seu estado original.  Da√≠ a pergunta, mas como gerenciar interrup√ß√µes? <br><br>  Usamos a seguinte solu√ß√£o.  O registro PSR permite ativar o gerenciamento atrav√©s do UPSR, que j√° √© global (o que precisamos).  Portanto, habilitamos o controle via UPSR diretamente (importante!) Antes da fun√ß√£o de login do n√∫cleo da Embox: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* PSR is local register and makes sense only within a function, * so we set it here before kernel start. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rrs %%psr, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr) :)</span></span></span></span>; psr |= (PSR_IE | PSR_NMIE | PSR_UIE); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rws %0, %%psr"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ri"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr))</span></span></span></span>; kernel_start();</code> </pre> <br>  De alguma forma, por acaso, depois da refatora√ß√£o, peguei e coloquei essas linhas em uma fun√ß√£o separada ... E o registro √© local para a fun√ß√£o.  √â claro que tudo quebrou :) <br><br>  Ent√£o, tudo parece estar ativado no processador, v√° para o controlador de interrup√ß√£o. <br><br>  Como vimos acima, as informa√ß√µes sobre o n√∫mero da exce√ß√£o est√£o no registro TIR.  Al√©m disso, o 32¬∫ bit nesse registro relata que ocorreu uma interrup√ß√£o externa. <br><br>  Depois de ligar o cron√¥metro, alguns dias de tormento se seguiram, j√° que nenhuma interrup√ß√£o p√¥de ser obtida.  O motivo foi divertido o suficiente.  Existem indicadores de 64 bits no Elbrus, e o endere√ßo do registro no APIC entrou no uint32_t, por isso os usamos.  Por√©m, se voc√™ precisar, por exemplo, converter 0xF0000000 em um ponteiro, n√£o receber√° 0xF0000000, mas 0xFFFFFFFFF0000000.  Ou seja, o compilador expandir√° seu sinal int n√£o assinado. <br><br>  Aqui, √© claro, era necess√°rio usar o uintptr_t, porque, como se viu, no padr√£o C99, esse tipo de convers√£o foi definido como a implementa√ß√£o definida. <br><br>  Depois que finalmente vimos o 32¬∫ bit aumentado em TIR, come√ßamos a procurar como obter o n√∫mero de interrup√ß√£o.  Acabou sendo bastante simples, embora nem um pouco parecido com o x86, essa √© uma das diferen√ßas entre as implementa√ß√µes do LAPIC.  Para Elbrus, para obter o n√∫mero de interrup√ß√£o, voc√™ precisa entrar no registro LAPIC especial: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APIC_VECT (0xFEE00000 + 0xFF0)</span></span></code> </pre> <br>  onde 0xFEE00000 √© o endere√ßo base dos registros LAPIC. <br><br>  Acabou por pegar o temporizador do sistema e o temporizador LAPIC. <br><br><h3>  Conclus√£o </h3><br>  As informa√ß√µes fornecidas nas duas primeiras partes t√©cnicas do artigo sobre a arquitetura Elbrus s√£o suficientes para implementar interrup√ß√µes de hardware e multitarefa preemptiva em qualquer sistema operacional.  Na verdade, as capturas de tela fornecidas atestam isso. <br><br><img src="https://habrastorage.org/webt/qm/qz/3p/qmqz3pbvuvohscm_qon1edf5jno.png"><br><br>  Esta n√£o √© a √∫ltima parte t√©cnica sobre a arquitetura Elbrus.  Agora estamos dominando o gerenciamento de mem√≥ria (MMU) em Elbrus, esperamos falar sobre isso em breve.  Precisamos disso n√£o apenas para a implementa√ß√£o de espa√ßos de endere√ßo virtual, mas tamb√©m para o trabalho normal com perif√©ricos, porque, por meio desse mecanismo, voc√™ pode desativar ou ativar o cache de uma √°rea espec√≠fica do espa√ßo de endere√ßo. <br><br>  Tudo o que est√° escrito no artigo pode ser encontrado no reposit√≥rio da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Embox</a> .  Voc√™ tamb√©m pode criar e executar, se √© claro que existe uma plataforma de hardware.  √â verdade que um compilador √© necess√°rio para isso e s√≥ pode ser obtido no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MCST</a> .  A documenta√ß√£o oficial pode ser solicitada l√°. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt447744/">https://habr.com/ru/post/pt447744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt447732/index.html">Identificador da Ra√ßa Canina: Desenvolvimento do ciclo completo do programa Keras para o aplicativo Android. no mercado de jogo</a></li>
<li><a href="../pt447734/index.html">Por que o front-end deve entender os princ√≠pios da interface do usu√°rio</a></li>
<li><a href="../pt447736/index.html">V√≠deo Drone - uma nova tend√™ncia nas redes sociais</a></li>
<li><a href="../pt447738/index.html">Julian Assange preso pela pol√≠cia brit√¢nica</a></li>
<li><a href="../pt447742/index.html">Qual √© a metodologia DevOps e quem precisa dela</a></li>
<li><a href="../pt447746/index.html">L√≥gica de neg√≥cios do banco de dados com o SchemaKeeper</a></li>
<li><a href="../pt447748/index.html">Sistemas de arquivos virtuais Linux: por que eles s√£o necess√°rios e como eles funcionam? Parte 2</a></li>
<li><a href="../pt447750/index.html">Novos processadores para data centers - analisamos os an√∫ncios dos √∫ltimos meses</a></li>
<li><a href="../pt447752/index.html">Como fizemos o overclock do CAD COMPASS-3D ‚Üí Parte 3</a></li>
<li><a href="../pt447754/index.html">Aplicativo da barra de menus para o macOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>