<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐭 💴 👩🏿‍🌾 Memahami broker pesan. Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka. Bab 2. ActiveMQ 👩‍🏫 🐹 👨🏼‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kelanjutan dari terjemahan sebuah buku kecil: 
 "Memahami Pialang Pesan", 
 penulis: Jakub Korab, penerbit: O'Reilly Media, Inc., tanggal publikasi: J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memahami broker pesan. Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka. Bab 2. ActiveMQ</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471268/">  Kelanjutan dari terjemahan sebuah buku kecil: <br>  "Memahami Pialang Pesan", <br>  penulis: Jakub Korab, penerbit: O'Reilly Media, Inc., tanggal publikasi: Juni 2017, ISBN: 9781492049296. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terjemahan selesai</a></b> <br><br>  Bagian sebelumnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Pialang Pesan.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 1. Pendahuluan</a> <br><a name="habracut"></a><br><h2>  BAB 2 </h2><br><h2>  Activemq </h2><br>  ActiveMQ digambarkan sebagai sistem pesan klasik.  Itu ditulis pada tahun 2004 untuk mengisi kebutuhan pialang pesan sumber terbuka.  Pada saat itu, jika Anda ingin menggunakan pesan dalam aplikasi Anda, satu-satunya pilihan adalah produk komersial yang mahal. <br><br>  ActiveMQ dikembangkan sebagai implementasi dari spesifikasi Java Message Service (JMS).  Keputusan ini dibuat untuk memenuhi persyaratan untuk mengimplementasikan pesan yang sesuai dengan JMS di proyek Apache Geronimo, server aplikasi J2EE open source. <br>  Sistem pesan (atau middleware yang berorientasi pada pesan, seperti yang kadang-kadang disebut) yang mengimplementasikan spesifikasi JMS terdiri dari komponen-komponen berikut: <br><br>  <b>Pialang</b> <br><br>  Sepotong utama dari middleware mendistribusikan pesan. <br><br>  <b>Pelanggan</b> <br><br>  Sepotong perangkat lunak yang mengirim pesan melalui broker.  Ini, pada gilirannya, terdiri dari artefak berikut: <br><br><ul><li>  Kode menggunakan JMS API. </li><li>  API JMS adalah seperangkat antarmuka untuk berinteraksi dengan broker sesuai dengan jaminan yang ditetapkan dalam spesifikasi JMS. </li><li>  Pustaka klien dari sistem yang menyediakan implementasi API dan berinteraksi dengan broker. </li></ul><br>  Klien dan broker berkomunikasi satu sama lain melalui protokol lapisan aplikasi, juga dikenal sebagai <i>protokol interaksi</i> <a href="">(Gambar 2-1)</a> .  Spesifikasi JMS meninggalkan detail protokol ini ke implementasi spesifik. <br><br><img src="https://habrastorage.org/webt/u1/wi/za/u1wiza7rupveiqnyqktuqsa-mvs.png"><br>  <i>Gambar 2-1.</i>  <i>Ulasan JMS</i> <br><br>  JMS menggunakan <i>penyedia</i> istilah untuk menggambarkan implementasi vendor dari sistem pengiriman pesan yang mendasari JMS API, yang meliputi broker, serta perpustakaan kliennya. <br><br>  Pilihan yang mendukung implementasi JMS memiliki konsekuensi yang luas untuk keputusan implementasi yang dibuat oleh penulis ActiveMQ.  Spesifikasi itu sendiri memberikan panduan yang jelas tentang tanggung jawab klien dari sistem pengiriman pesan dan broker yang berkomunikasi dengannya, memberikan preferensi pada kewajiban broker untuk mendistribusikan dan mengirimkan pesan.  Tanggung jawab utama klien adalah berinteraksi dengan penerima (antrian atau topik) dari pesan yang dikirim olehnya.  Spesifikasi itu sendiri bertujuan untuk membuat interaksi API dengan broker relatif sederhana. <br><br>  Area ini, seperti yang akan kita lihat nanti, memiliki dampak signifikan pada kinerja ActiveMQ.  Selain kompleksitas broker, paket kompatibilitas untuk spesifikasi yang disediakan oleh Sun Microsystems memiliki banyak nuansa, dengan dampaknya sendiri pada kinerja.  Semua nuansa ini harus diperhitungkan agar ActiveMQ dianggap kompatibel dengan JMS. <br><br><h3>  Komunikasi </h3><br>  Meskipun API dan perilaku yang diharapkan didefinisikan dengan baik dalam spesifikasi JMS, protokol komunikasi klien-broker yang sebenarnya sengaja dikecualikan dari spesifikasi sehingga broker yang ada dapat dibuat memenuhi persyaratan JMS.  Dengan demikian, ActiveMQ bebas menentukan protokol interaksinya sendiri, OpenWire.  OpenWire digunakan oleh implementasi perpustakaan klien ActiveMQ JMS, serta rekan-rekannya di .Net dan C ++: NMS dan CMS, yang merupakan sub proyek ActiveMQ yang diselenggarakan oleh Apache Software Foundation. <br><br>  Seiring waktu, dukungan untuk protokol interaksi lainnya ditambahkan ke ActiveMQ, yang meningkatkan kemampuan untuk berinteraksi dengan bahasa dan lingkungan lain: <br><br>  <b>AMQP 1.0</b> <br><br>  Protokol Antrian Pesan Lanjutan (ISO / IEC 19464: 2014) tidak boleh dikacaukan dengan pendahulunya 0.X, yang diimplementasikan dalam sistem pesan lain, khususnya RabbitMQ, menggunakan 0.9.1.  AMQP 1.0 adalah protokol biner tujuan umum untuk bertukar pesan antara dua node.  Ia tidak memiliki konsep klien atau broker dan mencakup fungsi-fungsi seperti flow control, transaksi, dan berbagai QoS (tidak lebih dari sekali, setidaknya sekali, dan tepat sekali). <br><br>  <b>STOMP</b> <br><br>  Simple / Streaming Text Oriented Messaging Protocol, protokol yang mudah diterapkan yang memiliki lusinan implementasi klien dalam berbagai bahasa. <br><br>  <b>Xmpp</b> <br><br>  Perpesanan yang lebih luas dan protokol kehadiran.  (Perpanjangan Perpesanan dan Protokol Kehadiran).  Sebelumnya bernama Jabber, protokol berbasis XML ini pada awalnya dikembangkan untuk sistem obrolan, tetapi telah diperluas melampaui kasus penggunaan aslinya untuk menyertakan mempublikasikan pesan berlangganan. <br><br>  <b>MQTT</b> <br><br>  Protokol publikasi-berlangganan ringan (ISO / IEC 20922: 2016) digunakan untuk aplikasi Machine-to-Machine (M2M) dan Internet of Things (IoT). <br><br>  ActiveMQ juga mendukung pengenaan protokol di atas pada WebSockets, yang menyediakan pertukaran data dupleks penuh antara aplikasi di browser web dan tujuan di broker. <br><br>  Mengingat ini, sekarang ketika kita berbicara tentang ActiveMQ, kita tidak lagi merujuk secara eksklusif ke tumpukan interaksi berdasarkan perpustakaan JMS / NMS / CMS dan protokol OpenWire.  Kombinasi dan pemilihan bahasa, platform, dan perpustakaan eksternal yang paling cocok untuk aplikasi ini menjadi semakin populer.  Misalnya, aplikasi JavaScript dapat dijalankan di browser menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka Eclipse Paho</a> MQTT untuk mengirim pesan ke ActiveMQ melalui soket web, dan pesan ini dibaca oleh proses server C ++ yang menggunakan AMQP melalui perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Qpid Proton</a> .  Dari perspektif ini, lansekap perpesanan menjadi lebih beragam. <br><br>  Melihat ke masa depan, AMQP, khususnya, akan memiliki lebih banyak peluang daripada sekarang, karena komponen yang bukan klien maupun pialang menjadi bagian yang lebih akrab dari lanskap perpesanan.  Sebagai contoh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Qpid Dispatch Router</a> bertindak sebagai router pesan, di mana klien terhubung secara langsung, memungkinkan tujuan berbeda untuk memproses alamat yang berbeda, serta memberikan kemungkinan sharding (pemisahan). <br><br>  Saat bekerja dengan perpustakaan pihak ketiga dan komponen eksternal, harap dicatat bahwa mereka memiliki kualitas variabel dan mungkin tidak kompatibel dengan fungsi yang disediakan di ActiveMQ.  Sebagai contoh yang sangat sederhana - tidak mungkin mengirim pesan ke antrian melalui MQTT (tanpa mengatur perutean di broker).  Dengan demikian, Anda perlu meluangkan waktu bekerja dengan opsi untuk menentukan tumpukan sistem pengiriman pesan yang paling cocok untuk persyaratan aplikasi Anda. <br><br><h3>  Pertukaran antara kinerja dan keandalan </h3><br>  Sebelum kita mempelajari detail tentang cara pengiriman pesan titik-ke-titik di ActiveMQ, kita perlu berbicara sedikit tentang apa yang dihadapi semua sistem dengan pemrosesan data yang berat: pertukaran antara kinerja dan keandalan. <br><br>  Sistem apa pun yang menerima data, apakah itu perantara pesan atau database, harus diinstruksikan tentang cara memproses data ini jika terjadi kegagalan.  Kegagalan dapat mengambil banyak bentuk, tetapi untuk kesederhanaan kami akan mempersempitnya ke situasi di mana sistem kehilangan daya dan dimatikan segera.  Dalam situasi ini, kita perlu berspekulasi tentang apa yang akan terjadi pada data yang ada di sistem.  Jika data (dalam hal ini, pesan) ada di memori atau di bagian volatil dari besi, misalnya, di cache, maka data ini akan hilang.  Namun, jika data dikirim ke penyimpanan non-volatil, misalnya ke disk, itu akan tersedia lagi ketika sistem kembali berfungsi. <br><br>  Dari sudut pandang ini, masuk akal bahwa jika kita tidak ingin kehilangan pesan jika terjadi kegagalan broker, kita perlu menulisnya ke penyimpanan permanen.  Sayangnya, biaya solusi khusus ini cukup tinggi. <br><br>  Perhatikan bahwa perbedaan antara menulis satu megabyte data ke disk adalah 100-1000 kali lebih lambat daripada menulis ke memori.  Oleh karena itu, pengembang aplikasi harus memutuskan apakah keandalan pesan sepadan dengan hilangnya kinerja.  Keputusan seperti ini harus dibuat berdasarkan skenario penggunaan. <br><br>  Pertukaran antara kinerja dan keandalan didasarkan pada berbagai opsi.  Semakin tinggi keandalan, semakin rendah kinerjanya.  Jika Anda memutuskan untuk membuat sistem ini kurang dapat diandalkan, misalnya, menyimpan pesan hanya dalam memori, produktivitas Anda akan meningkat secara signifikan.  Secara default, JMS dikonfigurasi untuk memiliki ActiveMQ di luar kotak untuk keandalan.  Ada banyak mekanisme yang memungkinkan Anda untuk mengonfigurasi broker dan berinteraksi dengannya ke posisi dalam spektrum ini yang paling cocok untuk skenario spesifik menggunakan sistem pengiriman pesan. <br><br>  Kompromi ini diterapkan pada tingkat broker individu.  Namun, setelah menyelesaikan pengaturan broker individu, dimungkinkan untuk skala sistem pesan di luar titik ini dengan hati-hati memeriksa aliran pesan dan berbagi lalu lintas antara beberapa broker.  Ini dapat dicapai dengan memberikan penerima tertentu dengan broker mereka sendiri atau dengan membagi aliran pesan keseluruhan baik pada tingkat aplikasi atau menggunakan komponen perantara.  Nantinya, kami akan mempertimbangkan secara lebih rinci cara memperhitungkan topologi broker. <br><br><h3>  Menyimpan Pesan </h3><br>  ActiveMQ hadir dengan sejumlah strategi penyimpanan pesan pluggable.  Mereka datang dalam bentuk adapter kegigihan (persistence), yang dapat dianggap sebagai mesin penyimpan pesan.  Ini termasuk solusi berbasis disk seperti KahaDB dan LevelDB, serta kemampuan untuk menggunakan database melalui JDBC.  Karena yang pertama paling umum digunakan, kami akan memfokuskan diskusi kami pada mereka. <br><br>  Ketika broker menerima pesan persisten, mereka pertama kali ditulis ke disk dalam jurnal.  Jurnal adalah struktur data pada disk di mana Anda hanya dapat menambahkan data dan terdiri dari beberapa file.  Pesan yang masuk diserialkan oleh broker ke dalam representasi protokol-independen dari objek, dan kemudian disusun dalam bentuk biner, yang kemudian ditulis hingga akhir log.  Log berisi log semua pesan yang masuk, serta informasi tentang pesan-pesan yang telah dikonfirmasi telah dibaca oleh klien. <br><br>  Adaptor disk yang gigih mendukung file indeks yang melacak di mana pesan yang diteruskan berikut ini berada di log.  Ketika semua pesan dari file log dibaca, mereka akan dihapus atau diarsipkan oleh alur kerja latar belakang ActiveMQ.  Jika log ini rusak selama kegagalan broker, ActiveMQ akan membangunnya kembali berdasarkan informasi dalam file log. <br><br>  Pesan dari semua antrian ditulis ke file log yang sama, yang berarti bahwa jika satu pesan tidak dibaca, seluruh file (biasanya defaultnya adalah 32 MB atau 100 MB, tergantung pada adaptor persistensi) tidak dapat dihapus.  Ini dapat menyebabkan masalah dengan ruang disk rendah seiring waktu. <br><blockquote>  Pialang pesan klasik tidak dirancang untuk penyimpanan jangka panjang - baca pesan Anda! </blockquote>  Log adalah mekanisme yang sangat efisien untuk menyimpan dan kemudian mengambil pesan, karena akses disk berurutan untuk kedua operasi.  Pada hard disk konvensional, ini meminimalkan jumlah pencarian disk dengan silinder, karena kepala pada disk hanya terus membaca atau menulis sektor ke substrat berputar disk.  Demikian pula, pada SSD, akses berurutan jauh lebih cepat daripada akses acak, karena yang sebelumnya memanfaatkan halaman memori drive dengan lebih baik. <br><br><h3>  Faktor Kinerja Disk </h3><br>  Ada sejumlah faktor yang menentukan kecepatan di mana disk dapat bekerja.  Untuk memahami hal ini, pertimbangkan metode penulisan ke disk melalui model mental pipa yang disederhanakan ( <a href="">Gambar 2-2</a> ). <br><br><img src="https://habrastorage.org/webt/kv/wx/j_/kvwxj_wqzdn772kf0lb5yttf4i8.png"><br>  <i>Gambar 2-2.</i>  <i>Model Tabung Performa Disk</i> <br><br>  Sebuah pipa memiliki tiga dimensi: <br><br>  <b>Panjangnya</b> <br><br>  Sesuai dengan <i>latensi yang</i> diharapkan untuk menyelesaikan satu operasi.  Untuk sebagian besar drive lokal, ini cukup bagus, tetapi dapat menjadi faktor pembatas utama dalam lingkungan cloud di mana drive lokal sebenarnya online.  Misalnya, pada saat penulisan (April 2017), Amazon menjamin bahwa menulis ke penyimpanan EBS mereka akan "dalam waktu kurang dari 2 ms."  Jika kami merekam secara berurutan, ini memberikan throughput maksimum 500 catatan per detik. <br><br>  <b>Lebar</b> <br><br>  Menentukan <i>daya dukung atau bandwidth dari</i> satu operasi.  Cache sistem file menggunakan properti ini dengan menggabungkan banyak catatan kecil ke dalam set yang lebih kecil dari operasi penulisan yang lebih besar yang dilakukan pada disk. <br><br>  <b>Bandwidth seiring waktu</b> <br><br>  Idenya disajikan dalam bentuk serangkaian peristiwa yang dapat di pipa pada saat yang sama, diungkapkan oleh metrik yang disebut <i>IOPS (jumlah operasi I / O per detik)</i> .  IOPS umumnya digunakan oleh produsen penyimpanan dan penyedia cloud untuk mengukur kinerja.  Hard drive akan memiliki nilai IOPS yang berbeda dalam konteks yang berbeda: apakah beban kerjanya sebagian besar terdiri dari baca, tulis, atau kombinasi keduanya, dan apakah operasi ini berurutan, arbitrer, atau campuran.  Pengukuran IOPS yang paling menarik dari sudut pandang broker adalah operasi membaca dan menulis berurutan, karena mereka berhubungan dengan membaca dan menulis log dari sebuah log. <br><br>  Throughput maksimum broker pesan ditentukan oleh <i>pencapaian pembatasan pertama ini,</i> dan konfigurasi broker sebagian besar tergantung pada cara Anda berinteraksi dengan disk.  Ini bukan hanya faktor bagaimana, misalnya, broker dikonfigurasi, tetapi juga tergantung pada bagaimana produsen berinteraksi dengan broker.  Seperti halnya segala sesuatu yang berkaitan dengan kinerja, perlu untuk menguji broker pada beban kerja yang representatif (mis., Sedekat mungkin dengan pesan nyata) dan pada konfigurasi penyimpanan aktual yang akan digunakan dalam PROM.  Ini dilakukan untuk memahami bagaimana sistem akan berperilaku dalam kenyataan. <br><br><h3>  API JMS </h3><br>  Sebelum kita masuk ke perincian tentang bagaimana ActiveMQ berkomunikasi dengan klien, pertama-tama kita perlu mempelajari API JMS.  API mendefinisikan satu set antarmuka pemrograman yang digunakan oleh kode klien: <br><br>  <b>ConnectionFactory</b> <br><br>  Ini adalah antarmuka tingkat atas yang digunakan untuk membangun koneksi dengan broker.  Dalam aplikasi perpesanan biasa, hanya ada satu instance dari antarmuka ini.  Di ActiveMQ, ini adalah ActiveMQConnectionFactory.  Di tingkat atas, desain ini memberi tahu lokasi pialang pesan, bersama dengan detail tingkat rendah tentang cara berinteraksi dengannya.  Seperti namanya, ConnectionFactory adalah mekanisme dimana objek Connection dibuat. <br><br>  <b>Koneksi</b> <br><br>  Ini adalah objek berumur panjang yang kira-kira menyerupai koneksi TCP - setelah dibuat, biasanya ada sepanjang siklus hidup aplikasi hingga ditutup.  Koneksi aman, dan dapat bekerja dengan banyak utas secara bersamaan.  Objek koneksi memungkinkan Anda membuat objek Sesi. <br><br>  <b>Sesi</b> <br><br>  Ini adalah pegangan aliran saat berinteraksi dengan broker.  Objek sesi bukan thread aman, yang berarti mereka tidak dapat diakses oleh banyak utas pada saat yang sama.  Session adalah deskriptor transaksional utama yang dengannya programmer dapat melakukan dan mengembalikan pesan rollback jika dia dalam mode transaksional.  Menggunakan objek ini, Anda membuat objek Message, MessageConsumer, dan MessageProducer, dan juga mendapatkan pointer (deskriptor) ke objek Topik dan antrian. <br><br>  <b>MessageProducer</b> <br><br>  Antarmuka ini memungkinkan Anda untuk mengirim pesan ke penerima. <br><br>  <b>Konsumen pesan</b> <br><br>  Antarmuka ini memungkinkan pengembang untuk menerima pesan.  Ada dua mekanisme pengambilan pesan: <br><br><ul><li>  Daftarkan MessageListener.  Ini adalah antarmuka penangan pesan yang telah Anda terapkan, yang akan memproses secara berurutan setiap pesan yang dikeluarkan oleh broker menggunakan satu aliran. </li><li>  Polling untuk pesan menggunakan metode accept (). </li></ul><br>  <b>Pesan</b> <br><br>  Ini mungkin struktur yang paling penting karena mentransfer data Anda.  Pesan di JMS terdiri dari dua aspek: <br><br><ul><li>  Metadata pesan.  Pesan itu berisi tajuk dan properti.  Baik itu, dan itu bisa dianggap sebagai elemen peta.  Header adalah elemen terkenal yang ditentukan oleh spesifikasi JMS dan tersedia langsung melalui API, seperti JMSDestination dan JMSTimestamp.  Properti adalah bagian informasi pesan yang berubah-ubah yang disederhanakan untuk menyederhanakan pemrosesan atau perutean pesan tanpa harus membaca muatan pesan itu sendiri.  Anda dapat, misalnya, mengatur header ke AccountID atau OrderType. </li><li>  Badan pesan.  Beberapa jenis pesan dapat dibuat dari Sesi tergantung pada jenis konten yang akan dikirim dalam tubuh, yang paling umum adalah TextMessage untuk string dan BytesMessage untuk data biner. </li></ul><br><h3>  Bagaimana Antrian Bekerja: Kisah Dua Otak </h3><br>  Model kerja ActiveMQ yang bermanfaat, meskipun tidak akurat, adalah model dua bagian otak.  Satu bagian bertanggung jawab untuk menerima pesan dari produsen, dan yang lain mengirimkan pesan ini kepada konsumen.  Hubungan sebenarnya lebih kompleks untuk keperluan optimasi kinerja, tetapi model ini cukup untuk pemahaman dasar. <br><br><h4>  Mengirim pesan ke antrian </h4><br>  Mari kita lihat interaksi yang terjadi saat mengirim pesan. <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 2-3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menunjukkan kepada kita model proses yang disederhanakan dimana pesan diterima oleh broker. Ini tidak sepenuhnya sesuai dengan perilaku dalam setiap kasus, tetapi sangat cocok untuk mendapatkan pemahaman dasar. </font></font><br><br><img src="https://habrastorage.org/webt/u9/tc/_p/u9tc_p1dznwdwdajfxt19fsoxva.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 2-3. Mengirim Pesan ke JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam aplikasi klien, utas menerima pointer ke MessageProducer. Itu menciptakan Pesan dengan perkiraan muatan pesan dan panggilan MessageProducer.send ("pesanan", pesan), dengan antrian sebagai tujuan akhir pesan. Karena programmer tidak ingin kehilangan pesan jika brokernya rusak, header pesan JMSDeliveryMode diatur ke PERSISTENT (perilaku default).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini (1), aliran pengiriman memanggil perpustakaan klien dan mengatur pesan dalam format OpenWire. Kemudian pesan dikirim ke broker. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di broker, aliran yang diterima menghapus pesan dari baris dan mengosongkannya ke objek internal. Kemudian, objek pesan ditransmisikan ke adapter persistence, yang mengatur pesan menggunakan format Google Protocol Buffers dan menulisnya ke penyimpanan (2). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah merekam pesan di penyimpanan, adaptor persistensi harus menerima konfirmasi bahwa pesan itu benar-benar direkam (3). Ini biasanya merupakan bagian paling lambat dari keseluruhan interaksi; lebih lanjut tentang ini nanti.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segera setelah broker memastikan bahwa pesan telah disimpan, ia akan mengirim respons konfirmasi (4) kepada klien. Setelah itu, utas klien yang awalnya disebut operasi kirim () dapat melanjutkan pekerjaannya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfirmasi pesan persisten yang tertunda ini adalah dasar dari jaminan yang diberikan oleh JMS API - jika Anda ingin pesan disimpan, mungkin juga penting bagi Anda apakah pesan itu diterima oleh broker di tempat pertama. Ada sejumlah alasan mengapa hal ini tidak mungkin dilakukan, misalnya, batas memori atau disk telah tercapai. Alih-alih gagal, broker baik menunda operasi pengiriman, memaksa produsen untuk menunggu sampai sumber daya sistem yang cukup muncul untuk memproses pesan (proses yang disebut Producer Flow Control), atau dia akan mengirimkan konfirmasi negatif kepada produsen, mengeluarkan pengecualian. Perilaku yang tepat dapat disesuaikan untuk setiap broker.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam operasi sederhana ini, sejumlah besar interaksi I / O terjadi: dua operasi jaringan antara produsen dan broker, satu operasi simpan dan langkah konfirmasi. Operasi simpan dapat berupa penulisan sederhana ke disk atau transisi jaringan lain ke server penyimpanan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menimbulkan pertanyaan penting tentang pialang pesan: pekerjaan mereka dikaitkan dengan aliran operasi I / O yang sangat intensif dan mereka sangat sensitif terhadap infrastruktur yang digunakan, terutama pada disk.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita melihat lebih dekat pada langkah konfirmasi (3) dalam interaksi di atas. </font><font style="vertical-align: inherit;">Jika adaptor persistensi berbasis file, maka menyimpan pesan melibatkan penulisan ke sistem file. </font><font style="vertical-align: inherit;">Jika demikian, lalu mengapa saya perlu mengonfirmasi bahwa operasi penulisan telah selesai? </font><font style="vertical-align: inherit;">Apakah tindakan menyelesaikan rekaman benar-benar berarti bahwa rekaman telah terjadi?</font></font><br>  Tidak juga.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang biasanya terjadi, semakin dalam Anda mempelajari sesuatu, semakin kompleks ternyata. </font><font style="vertical-align: inherit;">Dalam kasus khusus ini, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caching</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah biang keladinya </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tembolok, tembolok di mana-mana </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika proses sistem operasi, seperti broker, menulis data ke disk, itu berinteraksi dengan sistem file. Sistem file adalah proses yang mengabstraksi rincian interaksi dengan media penyimpanan yang digunakan, menyediakan API untuk operasi file seperti OPEN, CLOSE, READ, dan WRITE. Salah satu fungsi ini adalah untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meminimalkan jumlah operasi tulis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan buffering data yang ditulis oleh sistem operasi ke dalam blok yang dapat disimpan ke disk dalam satu pendekatan. Operasi penulisan sistem file yang terlihat seperti berinteraksi dengan disk sebenarnya ditulis ke </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache buffer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ngomong-ngomong, itu sebabnya komputer Anda mengeluh ketika Anda mengeluarkan drive USB dengan tidak aman - file yang Anda salin mungkin sebenarnya belum ditulis! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segera setelah data melampaui cache buffer, ia pergi ke level caching berikutnya, kali ini di tingkat perangkat keras - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache controller disk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mereka sangat penting untuk sistem berbasis RAID dan melakukan fungsi yang sama seperti caching di tingkat sistem operasi: meminimalkan jumlah interaksi yang diperlukan untuk drive itu sendiri. Tembolok ini terbagi dalam dua kategori: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write-through Writes</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditransfer ke disk segera setelah diterima. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tulis kembali</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perekaman dilakukan pada disk hanya ketika buffer penuh mencapai nilai ambang tertentu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data yang disimpan dalam cache ini dapat dengan mudah hilang selama kegagalan daya, karena memori yang mereka gunakan biasanya tidak </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stabil (volatile)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kartu yang lebih mahal memiliki paket baterai yang berlebihan (BBU) yang mendukung daya cache hingga seluruh sistem dapat memulihkan daya, setelah itu data akan ditulis ke disk. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level cache terakhir ada di disk itu sendiri. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tembolok disk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terletak pada hard drive (baik pada hard drive standar dan pada solid state drive) dan dapat berupa write-through atau write-back. Sebagian besar drive komersial menggunakan cache write-back dan volatile, yang lagi-lagi berarti bahwa data dapat hilang jika terjadi kegagalan daya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kembali ke broker pesan, Anda harus menyelesaikan langkah konfirmasi untuk memastikan bahwa data telah benar-benar mencapai disk. Sayangnya, interaksi dengan buffer perangkat keras ini bergantung pada sistem file, sehingga yang dapat dilakukan oleh proses seperti ActiveMQ adalah mengirim sinyal ke sistem file yang ingin disinkronkan semua buffer sistem dengan perangkat yang digunakan. Untuk melakukan ini, broker memanggil metode java.io.FileDescriptor.sync (), yang, pada gilirannya, memulai operasi POSIX fsync ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perilaku sinkronisasi ini adalah persyaratan JMS untuk memastikan bahwa semua pesan yang ditandai sebagai persisten benar-benar disimpan ke disk dan oleh karena itu dieksekusi setelah setiap pesan atau set pesan terkait dalam suatu transaksi diterima. </font><font style="vertical-align: inherit;">Oleh karena itu, kecepatan di mana disk dapat melakukan sinkronisasi () sangat penting untuk kinerja broker.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konflik internal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan satu log untuk semua antrian menambah kompleksitas tambahan. Pada waktu tertentu, mungkin ada beberapa produsen mengirim pesan secara bersamaan. Pialang memiliki beberapa aliran yang menerima pesan-pesan ini dari soket masuk. Setiap utas harus menyimpan pesannya ke log. Karena beberapa utas tidak dapat menulis ke file yang sama pada saat yang sama, karena catatan akan bertentangan satu sama lain, maka catatan harus antri menggunakan mekanisme pengecualian bersama. Kami menyebutnya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konflik utas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap pesan harus direkam sepenuhnya dan disinkronkan sebelum memproses pesan berikutnya. Pembatasan ini memengaruhi semua antrian di broker secara bersamaan. Dengan demikian, kecepatan seberapa cepat suatu pesan dapat diterima adalah waktu yang diperlukan untuk menulis ke disk, ditambah waktu menunggu aliran lain untuk menyelesaikan rekaman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ActiveMQ termasuk buffer tulis, di mana aliran penerima menulis pesan mereka, menunggu selesainya rekaman sebelumnya. Kemudian buffer ditulis dalam satu tindakan ketika pesan tersedia. Setelah selesai, utas akan diberitahukan. Dengan demikian, broker memaksimalkan penggunaan bandwidth penyimpanan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk meminimalkan dampak konflik utas, set antrian dapat ditetapkan log mereka sendiri menggunakan adaptor mKahaDB. </font><font style="vertical-align: inherit;">Pendekatan ini mengurangi latensi penulisan, karena pada waktu tertentu, utas kemungkinan besar akan menulis ke jurnal yang berbeda dan mereka tidak perlu saling bersaing untuk mendapatkan akses eksklusif ke satu file log.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transaksi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keuntungan menggunakan jurnal tunggal untuk semua antrian adalah bahwa, dari sudut pandang penulis broker, jauh lebih mudah untuk mengimplementasikan transaksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat contoh di mana beberapa pesan dikirim oleh produser ke beberapa antrian. Menggunakan transaksi berarti bahwa seluruh rangkaian pesan yang akan dikirim harus dianggap sebagai satu operasi atom. Dalam interaksi ini, pustaka klien ActiveMQ mampu membuat beberapa optimasi yang secara signifikan akan meningkatkan kecepatan pengiriman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam operasi yang ditunjukkan pada </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 2-4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, produser mengirim tiga pesan, semuanya dalam antrian berbeda. </font><font style="vertical-align: inherit;">Alih-alih interaksi yang biasa dengan broker, ketika setiap pesan dikonfirmasi, klien mengirim ketiga pesan secara serempak, yaitu, tanpa menunggu jawaban. </font><font style="vertical-align: inherit;">Pesan-pesan ini disimpan dalam memori broker. </font><font style="vertical-align: inherit;">Segera setelah operasi selesai, produsen memberi tahu sesi tentang perlunya komitmen, yang pada gilirannya memaksa broker untuk melakukan satu catatan besar dengan satu operasi sinkronisasi. </font></font><br><br><img src="https://habrastorage.org/webt/i0/gl/tu/i0gltuz_gqybny3uyjrtpiot5bg.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 2-4. </font><font style="vertical-align: inherit;">Mengirim Pesan dalam Transaksi</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam jenis operasi ini, ActiveMQ menggunakan dua optimisasi untuk meningkatkan kecepatan:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menghapus waktu tunggu sebelum pengiriman berikutnya oleh produsen menjadi mungkin </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggabungkan banyak operasi disk kecil menjadi satu operasi besar - ini memungkinkan Anda untuk menggunakan seluruh bandwidth disk bus </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika kita membandingkan ini dengan situasi ketika setiap antrian disimpan dalam lognya sendiri, maka broker harus menyediakan sesuatu seperti koordinasi transaksi antara semua catatan. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengurangkan pesan dari antrian </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proses membaca pesan dimulai ketika konsumen menyatakan keinginan mereka untuk menerimanya baik dengan mengatur MessageListener untuk memproses pesan ketika mereka tiba, atau dengan memanggil metode MessageConsumer.receive () ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 2-5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/webt/eh/p7/-2/ehp7-2hesg0xjd1h4ynnqr46gqo.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 2-5. Membaca pesan melalui JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketika ActiveMQ mengetahui konsumen, ia (ActiveMQ) membaca (halaman) pesan halaman demi halaman dari penyimpanan ke memori distribusi (1). Kemudian pesan-pesan ini dialihkan (dikirim) ke akuntan (2), sering di beberapa bagian untuk mengurangi jumlah interaksi jaringan. Pialang melacak pesan mana yang telah dialihkan dan ke konsumen mana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesan yang diterima oleh konsumen tidak segera diproses oleh aplikasi, tetapi ditempatkan di area memori yang dikenal sebagai</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prefetch penyangga (prefetch buffer)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tujuan dari buffer ini adalah untuk merampingkan aliran pesan sehingga broker dapat mengeluarkan pesan kepada penyelia saat tersedia untuk dikirim, sementara konsumen dapat menerimanya secara tertib, satu per satu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik tertentu setelah masuk ke buffer prefetch, pesan dibaca oleh logika aplikasi (X) dan konfirmasi proofread dikirim ke broker (3). Waktu waktu antara pemrosesan pesan dan konfirmasi dikonfigurasikan menggunakan parameter sesi JMS yang disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mode pengakuan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang akan kita bahas sedikit kemudian.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segera setelah broker menerima konfirmasi pengiriman pesan, itu dihapus dari memori dan dari penyimpanan pesan (4). Istilah "penghapusan" agak menyesatkan, karena dalam kenyataannya catatan konfirmasi ditulis untuk jurnal dan indeks dalam indeks meningkat. Penghapusan aktual file log yang berisi pesan akan dilakukan oleh pengumpul Sampah di utas latar belakang berdasarkan informasi ini.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perilaku yang dijelaskan di atas adalah penyederhanaan untuk memfasilitasi pemahaman. </font><font style="vertical-align: inherit;">Sebenarnya, ActiveMQ tidak hanya halaman-demi-halaman membaca data dari disk, tetapi menggunakan mekanisme kursor antara bagian penerima dan pengalihan broker untuk meminimalkan interaksi dengan repositori broker sedapat mungkin. </font><font style="vertical-align: inherit;">Pagination, seperti dijelaskan di atas, adalah salah satu mode yang digunakan dalam mekanisme ini. </font><font style="vertical-align: inherit;">Kursor dapat dilihat sebagai cache tingkat aplikasi yang perlu disinkronkan dengan repositori broker. </font><font style="vertical-align: inherit;">Protokol koherensi yang digunakan adalah bagian penting dari apa yang membuat mekanisme pengiriman ActiveMQ jauh lebih kompleks daripada mekanisme Kafka yang dijelaskan dalam bab berikutnya.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mode Konfirmasi dan Transaksi </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbagai mode konfirmasi, yang menentukan urutan antara pengoreksian ulang dan konfirmasi, memiliki dampak signifikan pada logika apa yang perlu diterapkan di klien. Mereka adalah sebagai berikut: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AUTO_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini adalah mode yang paling umum digunakan, mungkin karena memiliki kata AUTO. Mode ini memaksa perpustakaan klien untuk mengakui pesan pada saat yang sama ketika pesan dibaca oleh panggilan accept (). Ini berarti bahwa jika logika bisnis yang diprakarsai oleh pesan melempar pengecualian, maka pesan tersebut hilang karena sudah dihapus pada broker. Jika pesan dibaca melalui pendengar, pesan akan dikonfirmasikan hanya setelah pendengar berhasil menyelesaikan pekerjaan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLIENT_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfirmasi akan dikirim hanya ketika kode konsumen secara eksplisit memanggil metode Message.acknowledge (). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DUPS_OK_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di sini konfirmasi akan disangga oleh konsumen sebelum mengirimkannya secara bersamaan untuk mengurangi jumlah lalu lintas jaringan. Namun, jika sistem klien dimatikan, konfirmasi akan hilang, dan pesan akan dikirim ulang dan diproses untuk kedua kalinya. Oleh karena itu, kode harus mempertimbangkan kemungkinan duplikat pesan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mode konfirmasi dilengkapi dengan alat bacaan transaksional. </font><font style="vertical-align: inherit;">Saat membuat Sesi, itu dapat ditandai sebagai transaksional. </font><font style="vertical-align: inherit;">Ini berarti bahwa pemrogram harus secara eksplisit memanggil Session.commit () atau Session.rollback (). </font><font style="vertical-align: inherit;">Di sisi konsumen, transaksi memperluas jangkauan interaksi yang dapat dilakukan kode sebagai satu operasi atom. </font><font style="vertical-align: inherit;">Misalnya, Anda dapat membaca dan memproses beberapa pesan secara keseluruhan, atau mengurangi pesan dari satu antrian, dan kemudian mengirimkannya ke yang lain menggunakan objek Sesi yang sama.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengiriman dan beberapa konsumen </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, kami telah membahas perilaku membaca pesan dengan satu konsumen. Sekarang mari kita lihat bagaimana model ini berlaku untuk beberapa konsumen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika beberapa konsumen berlangganan antrean, perilaku default broker adalah mengirim pesan setengah jadi kepada konsumen yang memiliki tempat di buffer prefetch. Pesan akan dikirim sesuai urutan kedatangannya dalam antrian - ini adalah satu-satunya jaminan FIFO yang disediakan (masuk pertama, keluar pertama; pertama masuk, pertama keluar). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika konsumen tiba-tiba dimatikan, semua pesan yang dikirim kepadanya, tetapi belum dikonfirmasi, akan dikirim kembali ke pelanggan lain yang tersedia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menimbulkan pertanyaan penting: bahkan di mana transaksi konsumen digunakan, tidak ada jaminan bahwa pesan tidak akan diproses beberapa kali. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan logika pemrosesan berikut di dalam konsumen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesan dikurangi dari antrian. </font><font style="vertical-align: inherit;">Transaksi dimulai.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Layanan web disebut dengan isi pesan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaksi dilakukan. </font><font style="vertical-align: inherit;">Konfirmasi dikirim ke broker.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika klien menyelesaikan antara langkah 2 dan 3, maka proofreading pesan telah mempengaruhi beberapa sistem lain dengan memanggil layanan web. Panggilan layanan web adalah permintaan HTTP dan, karenanya, tidak bersifat transaksional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perilaku ini berlaku untuk semua sistem antrian - bahkan jika mereka bersifat transaksional, mereka tidak dapat menjamin bahwa tidak akan ada efek samping saat memproses pesan di dalamnya. Setelah memeriksa pemrosesan pesan secara terperinci, kami dapat dengan yakin mengatakan bahwa: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada yang namanya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengiriman pesan hanya sekali</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Antrian memberikan jaminan pengiriman </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setidaknya satu kali</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan bagian sensitif dari kode harus selalu mempertimbangkan kemungkinan menerima pesan berulang. </font><font style="vertical-align: inherit;">Kami akan membahas nanti bagaimana klien perpesanan dapat menggunakan pembacaan idempoten untuk melacak pesan yang telah dilihat dan untuk menghindari duplikat.</font></font><br><br>
<h4>  Sortir pesan </h4><br>  Untuk satu set pesan yang tiba dalam urutan [A, B, C, D], dan untuk dua konsumen C1 dan C2, distribusi pesan yang normal adalah sebagai berikut: <br><br> <code>C1: [A, C] <br> C2: [B, D]</code> <br>  Karena broker tidak mengontrol operasi proses membaca dan urutan pemrosesan paralel, itu tidak deterministik.  Jika C1 lebih lambat dari C2, maka set pesan awal dapat diproses sebagai [B, D, A, C]. <br><br>  Perilaku ini dapat mengejutkan pemula yang mengharapkan pesan diproses secara berurutan dan, atas dasar ini, sedang mengembangkan aplikasi perpesanan mereka sendiri.  Persyaratan bahwa pesan yang dikirim oleh pengirim yang sama diproses dalam urutan relatif satu sama lain, juga dikenal sebagai <i>pemesanan kausal</i> , cukup umum. <br><br>  Ambil contoh penggunaan berikut yang diambil dari taruhan online sebagai contoh: <br><br><ol><li>  Akun pengguna sudah dikonfigurasikan. </li><li>  Uang dikreditkan ke akun. </li><li>  Taruhan dibuat yang menarik uang dari akun. </li></ol><br>  Masuk akal di sini bahwa pesan-pesan tersebut diproses sesuai urutan pengirimannya, sehingga keadaan umum akun diperhitungkan.  Hal-hal aneh dapat terjadi jika sistem mencoba mengeluarkan uang dari akun yang tidak memiliki dana.  Tentu saja ada beberapa cara untuk mengatasi hal ini. <br><br>  Model <i>pelanggan eksklusif</i> termasuk mengirim semua pesan dari antrian ke satu pelanggan.  Menggunakan pendekatan ini, ketika menghubungkan beberapa instance aplikasi atau utas ke antrian, mereka ditandatangani menggunakan parameter penerima khusus: <code>my.queue?consumer.exclusive=true</code> .  Ketika Anda menghubungkan konsumen monopoli, ia menerima semua pesan.  Ketika konsumen kedua terhubung, ia tidak akan menerima pesan apa pun sampai yang pertama terputus.  Konsumen kedua ini sebenarnya cadangan panas, sementara konsumen pertama sekarang akan menerima pesan persis dalam urutan di mana mereka direkam dalam jurnal - dalam urutan sebab-akibat. <br>  Kelemahan dari pendekatan ini adalah bahwa meskipun pemrosesan pesan konsisten, ini adalah hambatan kinerja karena semua pesan harus diproses oleh satu kompurator. <br><br>  Untuk memahami use case ini dengan lebih cerdas, Anda perlu mempertimbangkan kembali masalahnya.  Apakah semua pesan harus diproses secara berurutan?  Dalam hal memproses tawaran yang dijelaskan di atas, hanya perlu memproses pesan yang terkait dengan satu akun secara berurutan.  ActiveMQ menyediakan mekanisme untuk menangani situasi ini yang disebut <i>grup pesan JMS</i> . <br><br>  Grup pesan adalah semacam mekanisme partisi yang memungkinkan produsen untuk mendistribusikan pesan ke dalam grup yang akan diproses secara berurutan sesuai dengan kunci bisnis.  Kunci bisnis ini diatur dalam properti pesan yang disebut <code>JMSXGroupID</code> . <br><br>  Kunci alami dalam hal memproses tawaran akan menjadi pengidentifikasi akun. <br>  Untuk mengilustrasikan cara kerja pengiriman, pertimbangkan satu set pesan yang tiba dengan urutan sebagai berikut: <br><br><pre> <code class="plaintext hljs">[(A, Group1), (B, Group1), (C, Group2), (D, Group3), (E, Group2)]</code> </pre> <br>  Ketika pesan diproses oleh mekanisme pengiriman di ActiveMQ dan ia melihat <code>JMSXGroupID</code> yang tidak ada sebelumnya, kunci ini diberikan kepada konsumen berdasarkan siklus.  Mulai sekarang, semua pesan dengan kunci ini akan dikirim ke akuntan ini. <br><br>  Di sini grup akan ditugaskan di antara dua konsumen: C1 dan C2, sebagai berikut: <br><br><pre> <code class="plaintext hljs">C1: [Group1, Group3] C2: [Group2]</code> </pre> <br>  Pesan akan dialihkan dan diproses sebagai berikut: <br><br><pre> <code class="plaintext hljs">C2: [B, D] C2: [(C, Group2), (E, Group2)]</code> </pre> <br>  Jika konsumen mogok, maka semua grup yang ditugaskan kepadanya akan didistribusikan kembali di antara sisa konsumen dan pesan yang tidak dikonfirmasi akan diarahkan kembali.  Oleh karena itu, meskipun kami dapat menjamin bahwa semua pesan terkait akan diproses secara berurutan, kami tidak dapat mengklaim bahwa pesan tersebut akan diproses oleh konsumen yang sama. <br><br><h3>  Ketersediaan Tinggi </h3><br>  ActiveMQ menyediakan ketersediaan tinggi dengan master-slave berdasarkan penyimpanan bersama.  Dalam skema ini, dua atau lebih broker (walaupun biasanya dua) dikonfigurasikan pada server yang terpisah, dan pesan mereka disimpan di toko pesan yang terletak di lokasi eksternal.  Toko pesan tidak dapat digunakan secara bersamaan oleh beberapa contoh broker, oleh karena itu fungsi sekundernya (gudang) adalah bertindak sebagai mekanisme pemblokiran untuk menentukan broker mana yang akan mendapatkan akses eksklusif ( <a href="">Gambar 2-6</a> ). <br><br><img src="https://habrastorage.org/webt/bn/yn/d5/bnynd5kctkhlomy5nb7-gmckrws.png"><br>  <i>Gambar 2-6.</i>  <i>Broker A adalah pemimpinnya, broker B bersiaga sebagai budak</i> <br><br>  Untuk terhubung ke repositori, broker pertama (Broker A) mengambil peran sebagai pemimpin dan membuka port-nya untuk lalu lintas pesan.  Ketika broker kedua (Broker B) terhubung ke repositori, ia mencoba untuk mendapatkan kunci dan, karena ia tidak berhasil, berhenti untuk waktu yang singkat sebelum mencoba untuk mendapatkan kunci lagi.  Ini disebut kendali yang dikendalikan. <br><br>  Pada saat yang sama, klien berganti alamat dua broker dalam upaya untuk terhubung ke port inbound, yang dikenal sebagai konektor transportasi.  Segera setelah broker utama tersedia, klien terhubung ke port-nya dan dapat mengirim dan membaca pesan. <br>  Ketika Broker A, bertindak sebagai pemimpin, gagal karena kegagalan proses ( <a href="">Gambar 2-7</a> ), peristiwa berikut terjadi: <br><br><ol><li>  Klien terputus dan segera mencoba untuk menyambung kembali, bergantian alamat dua broker. </li><li>  Kunci dalam pesan dilepaskan.  Pengaturan waktu ini tergantung pada implementasi penyimpanan. </li><li>  Broker B, yang berada dalam mode slave, secara berkala mencoba mendapatkan kunci, akhirnya berhasil dan mengasumsikan peran master, membuka portalnya. </li><li>  Klien terhubung ke Broker B dan melanjutkan pekerjaannya. </li></ol><br><img src="https://habrastorage.org/webt/ks/wi/yd/kswiydyc5bffutft06ck-1sm4zq.png"><br>  <i>Gambar 2-7.</i>  <i>Broker A berakhir dengan kehilangan koneksi ke repositori.</i>  <i>Broker B yang memimpin</i> <br><blockquote>  Logika pergantian antara beberapa alamat pialang tidak dijamin untuk dibangun ke pustaka klien, seperti halnya dalam implementasi JMS / NMS / CMS.  Jika perpustakaan hanya menyediakan koneksi ulang ke satu alamat, maka Anda mungkin perlu menempatkan beberapa broker di belakang penyeimbang beban, yang juga harus sangat tersedia. </blockquote>  Kerugian utama dari pendekatan ini adalah bahwa untuk menyederhanakan pekerjaan satu broker logis, diperlukan beberapa server fisik.  Dalam hal ini, salah satu dari dua server broker menganggur, menunggu pemutusan mitra sebelum dapat mulai bekerja. <br><br>  Pendekatan ini juga memiliki kompleksitas tambahan yang digunakan penyimpanan broker, apakah itu sistem file jaringan bersama atau database, juga harus sangat mudah diakses.  Ini mengarah pada biaya tambahan untuk peralatan dan administrasi pengaturan broker.  Dalam skenario ini, tergoda untuk menggunakan kembali repositori ketersediaan tinggi yang ada yang digunakan oleh bagian lain dari infrastruktur, seperti database, tetapi ini adalah kesalahan. <br><br>  Penting untuk diingat bahwa disk adalah pembatas utama pada keseluruhan kinerja broker.  Jika disk itu sendiri secara bersamaan digunakan oleh proses selain dari pialang pesan, maka interaksi proses ini dengan disk mungkin memperlambat perekaman dari pialang dan, oleh karena itu, kecepatan di mana pesan dapat melalui sistem.  Perlambatan seperti itu sulit untuk didiagnosis dan satu-satunya cara mengatasinya adalah dengan memisahkan kedua proses menjadi volume penyimpanan yang berbeda. <br><br>  Untuk memastikan operasi broker yang stabil, penyimpanan khusus dan berdedikasi diperlukan. <br><br><h3>  Penskalaan vertikal dan horizontal </h3><br>  Pada titik tertentu dalam kehidupan proyek, Anda mungkin menemukan batasan kinerja pada pialang pesan.  Batasan ini biasanya terkait dengan sumber daya, khususnya interaksi ActiveMQ dengan penyimpanan yang digunakan.  Masalah-masalah ini biasanya muncul karena konflik volume atau bandwidth pesan antara penerima, misalnya, ketika satu antrian meluap broker selama periode puncak. <br><br>  Ada beberapa cara untuk mendapatkan lebih banyak kinerja dari infrastruktur broker: <br><br><ul><li>  Jangan gunakan ketekunan jika tidak diperlukan.  Beberapa skenario penggunaan memungkinkan hilangnya pesan selama crash, terutama ketika satu sistem mengirim keadaan snapshot penuh lain ke yang lain melalui antrian, baik secara berkala atau sesuai permintaan. </li><li>  Jalankan broker pada drive yang lebih cepat.  Dalam kondisi nyata, perbedaan signifikan dalam perekaman bandwidth dicatat antara HDD standar dan alternatif berbasis memori. </li><li>  Manfaatkan ukuran disk sebaik mungkin.  Seperti yang ditunjukkan dalam model interaksi jalur pipa disk yang dijelaskan di atas, throughput yang lebih tinggi dapat dicapai dengan menggunakan transaksi untuk mengirim grup pesan, sehingga menggabungkan beberapa operasi penulisan menjadi satu yang lebih besar. </li><li>  Gunakan partisi lalu lintas.  Anda dapat mencapai throughput yang lebih tinggi dengan memisahkan tujuan dengan salah satu cara berikut: </li></ul><br><ol><li>  Beberapa disk dalam satu broker, misalnya, menggunakan adaptor persistensi mKahaDB untuk beberapa direktori, yang masing-masing dipasang pada disk terpisah. </li><li>  Beberapa broker, dan pembagian lalu lintas dilakukan secara manual oleh aplikasi klien.  ActiveMQ tidak menyediakan fungsi asli untuk tujuan ini. </li></ol><br>  Salah satu penyebab paling umum dari masalah kinerja broker hanyalah upaya untuk melakukan terlalu banyak dengan satu contoh.  Sebagai aturan, ini terjadi dalam situasi di mana broker secara naif dibagi antara beberapa aplikasi tanpa memperhitungkan beban yang ada pada broker atau memahami volume.  Seiring waktu, satu broker dimuat lebih dan lebih sampai dia berhenti berperilaku tepat. <br><br>  Masalahnya sering muncul selama fase desain sistem, ketika arsitek sistem dapat mengusulkan skema seperti pada <a href="">Gambar 2-8</a> . <br><br><img src="https://habrastorage.org/webt/86/2g/9m/862g9malnlxd6k8ryettpya_dwu.png"><br>  <i>Gambar 2-8.</i>  <i>Pandangan Konseptual tentang Infrastruktur Pesan</i> <br><br>  Tujuannya adalah agar beberapa aplikasi saling berkomunikasi secara asinkron melalui ActiveMQ.  Tujuannya tidak lagi ditentukan dan kemudian skema menentukan dasar dari konfigurasi broker nyata.  Pendekatan ini disebut Pipa Data Universal. <br><br>  Ini tidak memperhitungkan langkah fundamental analisis antara desain konseptual yang disebutkan di atas dan implementasi fisik.  Sebelum melanjutkan dengan konstruksi konfigurasi tertentu, perlu untuk melakukan analisis, yang kemudian akan digunakan untuk membenarkan proyek fisik.  Langkah pertama dalam proses ini adalah menentukan sistem yang berinteraksi satu sama lain - diagram yang cukup sederhana dengan persegi panjang dan panah ( <a href="">Gambar 2-9</a> ). <br><br><img src="https://habrastorage.org/webt/v_/wz/cz/v_wzczik2oi-menqrxjenakhs1e.png"><br>  <i>Gambar 2-9.</i>  <i>Pesan sketsa mengalir antar sistem</i> <br><br>  Setelah disetujui, Anda dapat pergi ke detail untuk menjawab pertanyaan-pertanyaan berikut: <br><br><ul><li>  Berapa banyak antrian dan topik yang akan digunakan? </li><li>  Volume pesan apa yang diharapkan untuk masing-masingnya? </li><li>  Seberapa besar pesan di masing-masing penerima?  Pesan besar dapat menyebabkan masalah dalam proses paging, menyebabkan melebihi batas memori dan memblokir broker. </li><li>  Apakah pesan mengalir seragam sepanjang hari atau akan ada lonjakan karena pekerjaan batch?  Batch besar dalam satu antrian yang kurang digunakan dapat mengganggu penulisan disk yang tepat waktu untuk tujuan berkinerja tinggi. </li><li>  Apakah sistem di pusat data yang sama atau berbeda?  Komunikasi jarak jauh melibatkan beberapa jenis pialang jaringan. </li></ul><br>  Idenya adalah untuk menentukan skenario perpesanan terpisah yang dapat digabungkan atau dibagi oleh masing-masing broker ( <a href="">Gambar 2-10</a> ). <br>  Setelah pemecahan seperti itu, skenario penggunaan dapat disimulasikan dengan menggabungkan satu sama lain menggunakan Modul Kinerja ActiveMQ untuk mengidentifikasi masalah. <br><br><img src="https://habrastorage.org/webt/nj/im/ry/njimryyhatcjfwhprygsdrrzqwc.png"><br>  <i>Gambar 2-10.</i>  <i>Identifikasi masing-masing broker</i> <br><br>  Setelah menentukan jumlah pialang logis yang tepat, Anda dapat menentukan bagaimana menerapkannya pada tingkat fisik menggunakan konfigurasi yang sangat mudah diakses dan jaringan pialang. <br><br><h3>  Ringkasan </h3><br>  Dalam bab ini, kami memeriksa mekanisme yang digunakan ActiveMQ untuk menerima dan mendistribusikan pesan.  Kami membahas fitur-fitur yang didukung oleh arsitektur ini, termasuk stick-load balancing pesan dan transaksi terkait.  Pada saat yang sama, kami memperkenalkan serangkaian konsep yang umum untuk semua sistem pengiriman pesan, termasuk protokol komunikasi dan majalah.  Kami juga memeriksa secara rinci kesulitan yang terlibat dalam penulisan ke disk dan bagaimana broker dapat menggunakan teknik seperti penulisan paket untuk meningkatkan kinerja.  Akhirnya, kami memeriksa bagaimana ActiveMQ dapat dibuat sangat tersedia dan bagaimana mengukurnya di luar kemampuan masing-masing broker. <br><br>  Pada bab selanjutnya, kita akan melihat Apache Kafka dan bagaimana arsitekturnya mendefinisikan kembali hubungan antara klien dan broker untuk memberikan pipa pesan yang sangat kuat dengan bandwidth yang berkali-kali lebih besar daripada broker pesan biasa.  Kami akan membahas fungsionalitas yang digunakannya untuk mencapai tujuan ini, dan secara singkat mempertimbangkan arsitektur aplikasi yang menyediakan fungsionalitas ini. <br><br>  Bagian selanjutnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Pialang Pesan.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 3. Kafka</a> <br><br>  <b>Terjemahan selesai: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tele.gg/middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471268/">https://habr.com/ru/post/id471268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471258/index.html">Sistem penyimpanan / pemuatan data</a></li>
<li><a href="../id471260/index.html">Kali Linux NetHunter di Android Bagian 2: serangan pada jaringan nirkabel</a></li>
<li><a href="../id471262/index.html">Holivar. Sejarah Runet. Bagian 5. Troll: Belajar, printer panik, Tembaga</a></li>
<li><a href="../id471264/index.html">Memilih alternatif untuk MailChimp: mengapa beralih dan produk mana yang harus dipilih</a></li>
<li><a href="../id471266/index.html">Masa depan ada di sini atau disandikan tepat di browser</a></li>
<li><a href="../id471270/index.html">Kami mengotomatiskan penerimaan data pada kecepatan memuat situs dari Google PageSpeed ​​Insights [templat]</a></li>
<li><a href="../id471272/index.html">Manfaat mengetik kuat di C ++: pengalaman langsung</a></li>
<li><a href="../id471278/index.html">Pembuatan teks dalam bahasa Rusia berdasarkan templat</a></li>
<li><a href="../id471282/index.html">Mencari pneumonia di rontgen dengan Fast.ai</a></li>
<li><a href="../id471288/index.html">Membuat wajah karakter untuk game "OnAir"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>