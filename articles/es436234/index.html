<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåµ ‚è¨ ü§ö Analizadores aplicativos de Haskell üíø üôéüèæ üõ∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Motivaci√≥n 


 Cuando comenc√© a aprender Haskell, me molest√≥ mucho el uso generalizado de abstracciones complejas en lugar de soluciones espec√≠ficas. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analizadores aplicativos de Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436234/"><p><img src="https://habrastorage.org/webt/tq/9u/iw/tq9uiw8d_nbb1bbwrfdg1euyvci.png"></p><br><h1 id="motivaciya">  Motivaci√≥n </h1><br><p>  Cuando comenc√© a aprender Haskell, me molest√≥ mucho el uso generalizado de abstracciones complejas en lugar de soluciones espec√≠ficas.  Me pareci√≥ que es mucho mejor seguir siempre el principio de KISS y escribir bicicletas usando construcciones de lenguaje elemental que comprender todas estas clases de tipos para escribir una construcci√≥n supuestamente conveniente en alguna parte. </p><br><p>  No ten√≠a un buen ejemplo en el que los esfuerzos dedicados al desarrollo del "material" valieran la pena.  Para m√≠, uno de los ejemplos m√°s exitosos fue el analizador sint√°ctico.  Ahora, a menudo hablo de ellos cuando me preguntan qu√© tareas comunes puedes usar Haskell. </p><br><p> Quiero ofrecer a los principiantes que tambi√©n vayan de esta manera y creen una peque√±a base de funciones desde cero para la implementaci√≥n conveniente de analizadores, y luego la utilicen para escribir su propio analizador, cuyo c√≥digo casi literalmente repetir√° la gram√°tica utilizada para analizar. </p><br><p>  Espero que esto ayude a alguien a superar el miedo a las abstracciones y les ense√±e c√≥mo usarlas <em>adecuadamente</em> (s√≠, todav√≠a creo que a veces es m√°s eficiente escribir una bicicleta). </p><a name="habracut"></a><br><p>  No tengo ning√∫n prop√≥sito y deseo hacer un curso de Haskell desde cero a partir de un art√≠culo, as√≠ que supongo que el lector est√° familiarizado con la sintaxis y los programas simples desarrollados independientemente.  Por si acaso, hablar√© brevemente sobre las clases de tipos antes de pasar a la descripci√≥n de la implementaci√≥n. </p><br><p>  Para aquellos que nunca han escrito a Haskell, pero quieren entender lo que est√° sucediendo aqu√≠, les recomiendo que primero consulten la p√°gina correspondiente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Learn X en Y minutos</a> .  Como excelente libro en ruso para principiantes, aconsejo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Acerca de Haskell como</a> ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">humano" de</a> Denis Shevchenko. </p><br><p>  Intentar√© usar las construcciones de lenguaje m√°s simples que los principiantes puedan entender.  Al final del art√≠culo, se proporciona un enlace al repositorio de origen, donde en algunas partes del c√≥digo se usa una entrada m√°s conveniente y m√°s corta, que puede ser menos clara a primera vista. </p><br><p>  Y s√≠, caballeros Haskellistas, muchas cosas se explican de manera muy simple y torpe, para casos especiales, no muy abstractos, sin usar t√©rminos de la teor√≠a de categor√≠as y otras palabras aterradoras.  Me alegra que los conozca y, por supuesto, los domine f√°cilmente.  Tambi√©n los conozco, pero no creo que sea necesario volcar esa cantidad de informaci√≥n en este contexto en lectores no preparados. </p><br><h1 id="klassy-tipov">  Clases de tipo </h1><br><p>  Las clases de tipo Haskell no tienen nada que ver con las clases en C ++ y otros lenguajes orientados a objetos.  Si dibujamos una analog√≠a con OOP, las clases de tipo son m√°s como una sobrecarga de m√©todos y funciones. </p><br><p> Las clases determinan qu√© acciones se pueden realizar con objetos de los tipos que componen la clase.  Por ejemplo, todos los n√∫meros se pueden comparar por igualdad, pero todo se puede ordenar, excepto los complejos, y en general, las funciones no se pueden comparar en absoluto.  La clase de tipos que se pueden comparar se llama <code>Eq</code> , ordenada - <code>Ord</code> (los tipos no tienen que ser num√©ricos).  Lo que se puede imprimir traduciendo a una cadena pertenece a la clase <code>Show</code> , tiene la clase de <code>Read</code> "opuesta", que determina c√≥mo convertir cadenas en objetos del tipo deseado. </p><br><p>  Para un conjunto de clases de tipo est√°ndar (como <code>Eq</code> , <code>Show</code> , <code>Read</code> ...), puede pedirle al compilador que implemente la funcionalidad requerida de manera est√°ndar, utilizando la palabra clave <code>deriving</code> despu√©s de determinar el tipo: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Puede definir sus propias clases de tipos: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint :: a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br><p>  Aqu√≠ <code>PrettyPrint</code> es el nombre de la clase, <code>a</code> es una variable de tipo.  La palabra clave <code>where</code> es seguida por una lista de los llamados m√©todos de clase, es decir,  funciones que se pueden aplicar a objetos de tipo de esta clase. </p><br><p>  Para indicar la pertenencia de un tipo de datos a una clase, se utiliza la siguiente construcci√≥n: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint (<span class="hljs-type"><span class="hljs-type">Point</span></span> xy) = <span class="hljs-string"><span class="hljs-string">"("</span></span> ++ show x ++ <span class="hljs-string"><span class="hljs-string">", "</span></span> ++ show y ++ <span class="hljs-string"><span class="hljs-string">")"</span></span></code> </pre> <br><p>  El lenguaje le permite especificar restricciones en las clases de tipo con las que deben relacionarse los argumentos de la funci√≥n: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">showVsPretty</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> a) =&gt; a -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) showVsPretty x = (show x, pPrint x)</code> </pre> <br><p>  Para cada llamada de funci√≥n, el compilador verifica si se cumplen estos requisitos de tipo y, si falla, muestra un error (por supuesto, esto sucede en la etapa de compilaci√≥n). </p><br><pre> <code class="haskell hljs">&gt;&gt;&gt; showVsPretty (<span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"Point {xCoord = 2.0, yCoord = 3.0}"</span></span>,<span class="hljs-string"><span class="hljs-string">"(2.0, 3.0)"</span></span>) &gt;&gt;&gt; showVsPretty <span class="hljs-string"><span class="hljs-string">"str"</span></span> error: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> [<span class="hljs-type"><span class="hljs-type">Char</span></span>]) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> 'showVsPretty'</code> </pre> <br><h1 id="realizaciya">  Implementaci√≥n </h1><br><p>  El analizador recibe una cadena de entrada que debe analizar de acuerdo con las reglas predefinidas y obtener el valor del tipo que necesitamos (por ejemplo, un entero).  En este caso, la l√≠nea de entrada puede no terminar y el resto servir√° como entrada para un an√°lisis posterior.  Adem√°s, nuestro analizador ser√° generalmente no determinista, es decir  devolver√° varios resultados de an√°lisis posibles como una lista. </p><br><p>  Una tupla de dos elementos <code>(String, a)</code> adecuada para describir un resultado de la operaci√≥n del analizador, donde <code>a</code> es una variable de tipo que puede denotar cualquier tipo de usuario. </p><br><p>  Como el analizador analiza la cadena de acuerdo con algunas reglas, la describimos como una funci√≥n que toma una cadena como entrada y devuelve una lista de resultados: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unParser</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)] }</span></span></code> </pre> <br><p>  Consideraremos el an√°lisis exitoso si la lista de resultados consta de un elemento y la cadena de entrada se ha procesado por completo.  Implementamos una funci√≥n auxiliar que intenta analizar de forma exclusiva toda la cadena: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parseString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a parseString s (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (ps) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [(<span class="hljs-string"><span class="hljs-string">""</span></span>, val)] -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> val _ -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><h2 id="prosteyshie-parsery">  Analizadores simples </h2><br><p>  Implementamos varios analizadores simples, que luego ser√°n √∫tiles para crear combinaciones m√°s complejas. </p><br><p>  Comenzamos analizando un solo car√°cter que debe satisfacer un predicado.  Si la cadena de entrada est√° vac√≠a, el resultado del trabajo es una lista vac√≠a.  De lo contrario, verificamos el valor del predicado en el primer car√°cter de la cadena.  Si <code>True</code> devuelve <code>True</code> , el resultado del an√°lisis es este car√°cter;  devu√©lvelo con el resto de la cadena.  De lo contrario, el an√°lisis tambi√©n falla. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">predP</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> predP p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f <span class="hljs-string"><span class="hljs-string">""</span></span> = [] f (c : cs) | pc = [(cs, c)] | otherwise = []</code> </pre> <br><p>  Ahora podemos escribir un analizador que tome un car√°cter espec√≠fico al comienzo de la l√≠nea.  Para hacer esto, use el <code>predP</code> reci√©n escrito y p√°selo como argumento, una funci√≥n que compara su argumento con el car√°cter que necesitamos: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">charP</span></span> :: <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> charP char = predP (\c -&gt; c == char)</code> </pre> <br><p>  El siguiente caso m√°s simple: un analizador que acepta solo una determinada cadena como un todo.  <code>stringP</code> .  La funci√≥n dentro del analizador compara la l√≠nea de entrada con la deseada y, si las l√≠neas son iguales, devuelve una lista de un elemento: un par de l√≠neas vac√≠as (no queda nada en la entrada) y la original.  De lo contrario, el an√°lisis fall√≥ y se devuelve una lista vac√≠a de resultados. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stringP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> stringP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs' | s == s' = [(<span class="hljs-string"><span class="hljs-string">""</span></span>, s)] | otherwise = []</code> </pre> <br><p>  Muy a menudo, debe omitir los caracteres que tienen una determinada propiedad mientras van al comienzo de la l√≠nea (por ejemplo, los espacios en blanco).  Adem√°s, el resultado del an√°lisis no es importante para nosotros y no ser√° √∫til en el futuro.  Escribimos una funci√≥n de <code>skip</code> que omite los caracteres iniciales de la cadena mientras se conserva el verdadero valor del predicado.  Como resultado del an√°lisis, usamos una tupla vac√≠a. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skip</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skip p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(dropWhile ps, ())])</code> </pre> <br><p>  Los siguientes dos analizadores son muy similares entre s√≠.  Ambos verifican el prefijo de la l√≠nea de entrada, solo el primero si tiene √©xito devuelve este prefijo, y el segundo devuelve una tupla vac√≠a, es decir  le permite omitir una l√≠nea arbitraria al comienzo de la entrada.  La implementaci√≥n utiliza la funci√≥n <code>isPrefixOf</code> definida en el m√≥dulo <code>Data.List</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prefixP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> prefixP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, s)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] skipString :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, ())] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> []</code> </pre> <br><p>  Un poco m√°s adelante consideraremos una implementaci√≥n m√°s simple de esta √∫ltima funci√≥n y eliminaremos la duplicaci√≥n de c√≥digo. </p><br><h2 id="parser-kak-funktor">  Analizador como functor </h2><br><p>  Podemos distinguir una clase completa de tipos de contenedores para los que se cumple lo siguiente: si sabe c√≥mo transformar objetos dentro de un contenedor, puede convertir los contenedores ellos mismos.  El ejemplo m√°s simple es una lista como contenedor y una funci√≥n de <code>map</code> , que est√° disponible en casi todos los idiomas de alto nivel.  De hecho, puede revisar todos los elementos de una lista de tipo <code>[a]</code> , aplicar <code>a -&gt; b</code> funci√≥n a <code>a -&gt; b</code> a cada uno y obtener una lista de tipo <code>[b]</code> . </p><br><p>  Esta clase de tipo se llama <code>Functor</code> ; la clase tiene un m√©todo <code>fmap</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  Supongamos que ya sabemos c√≥mo analizar cadenas en objetos de cierto tipo <code>a</code> y, adem√°s, sabemos c√≥mo convertir objetos de tipo a en objetos de tipo <code>b</code> .  ¬øEs posible decir que hay un analizador para objetos de tipo <code>b</code> ? </p><br><p>  Si se expresa en forma de una funci√≥n, tendr√° el siguiente tipo: </p><br><pre> <code class="haskell hljs">(a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Este tipo coincide con el tipo de la funci√≥n <code>fmap</code> , as√≠ que tratemos de hacer que el analizador sea un functor.  Creemos un analizador de valores de tipo <code>b</code> desde cero, que primero llamar√° al primer analizador (ya tenemos uno), y luego aplicaremos la funci√≥n a los resultados de su an√°lisis. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b fmap f (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> p2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p2 :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] p2 s = convert (p1 s) convert :: [(<span class="hljs-type"><span class="hljs-type">String</span></span>, a)] -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] convert results = map (\(s, val) -&gt; (s, f val)) results</code> </pre> <br><p>  La funci√≥n <code>fmap</code> tiene un conveniente sin√≥nimo infijo: <code>fmap fx == f &lt;$&gt; x</code> . </p><br><p>  Si usamos una funci√≥n como argumento para <code>fmap</code> que simplemente reemplaza su primer argumento con un nuevo valor, obtenemos otra operaci√≥n √∫til que ya est√° implementada para todos los functores, incluso en dos casos (difieren solo en el orden de los argumentos): </p><br><pre> <code class="plaintext hljs">(&lt;$) :: Functor f =&gt; a -&gt; fb -&gt; fa ($&gt;) :: Functor f =&gt; fa -&gt; b -&gt; fb</code> </pre> <br><p>  ¬øRecuerdas el analizador que omite una l√≠nea espec√≠fica ( <code>skipString</code> )?  Ahora puede implementarlo de la siguiente manera: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skipString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = () &lt;$ prefixP s</code> </pre> <br><h2 id="kombinacii-parserov">  Combinaciones de analizador </h2><br><p>  En Haskell, todas las funciones est√°n programadas por defecto y son parcialmente utilizables.  Esto significa que una funci√≥n de <code>n</code> argumentos es en realidad una funci√≥n de un argumento, devolviendo una funci√≥n de <code>n-1</code> argumentos: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">cons</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons = (:) cons1 :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons1 = cons <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">--  cons  </span></span></code> </pre> <br><p>  Aplicamos una funci√≥n de tres argumentos a alg√∫n valor dentro del analizador usando <code>fmap</code> .  Los tipos ser√°n los siguientes: </p><br><pre> <code class="plaintext hljs">f :: c -&gt; a -&gt; b p :: Parser c (fmap fp) :: Parser (a -&gt; b)</code> </pre> <br><p>  La funci√≥n analizador result√≥?!  Por supuesto, una situaci√≥n es posible cuando la representaci√≥n de la funci√≥n realmente est√° en la l√≠nea de entrada, pero me gustar√≠a poder usar esta funci√≥n, o m√°s bien combinar el <code>Parser (a -&gt; b)</code> y el <code>Parser a</code> para obtener el <code>Parser b</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  El tipo de esta funci√≥n es muy similar al tipo <code>fmap</code> , solo la funci√≥n en s√≠ que debe aplicarse tambi√©n est√° en el contenedor.  Esto proporciona una comprensi√≥n intuitiva de c√≥mo deber√≠a ser la implementaci√≥n de la funci√≥n <code>applyP</code> : obtener la funci√≥n del contenedor (como resultado de aplicar el primer analizador), obtener los valores a los que debe aplicarse la funci√≥n (resultado de aplicar el segundo analizador) y "empacar" los valores convertidos utilizando esta funci√≥n en el contenedor (cree un nuevo analizador).  En la implementaci√≥n, utilizaremos la comprensi√≥n de la lista: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b applyP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs = [ (sx, fx) | (sf, f) &lt;- p1 s, <span class="hljs-comment"><span class="hljs-comment">-- p1     (sx, x) &lt;- p2 sf] -- p2   ,    </span></span></code> </pre> <br><p>  Hay una clase <code>Applicative</code> que tiene un m√©todo con el mismo prototipo.  El segundo m√©todo de la clase se llama <code>pure</code> y se utiliza para "ajustar" o "levantar" ( <em>levantar</em> ) un valor, incluido uno funcional.  En el caso de la implementaci√≥n del analizador, la funci√≥n <code>pure</code> agrega su argumento al resultado del analizador, sin cambiar la cadena de entrada. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; fa -&gt; fb <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Applicative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pure x = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(s, x)]) pf &lt;*&gt; px = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [ (sx, fx) | (sf, f) &lt;- unParser pf $ s, (sx, x) &lt;- unParser px $ sf])</code> </pre> <br><p>  La funci√≥n <code>applyP</code> es el <code>&lt;*&gt;</code> de la clase <code>Applicative</code> .  Los tipos que pertenecen a esta clase se denominan functores aplicativos. </p><br><p>  Para los functores aplicativos, se implementan dos funciones auxiliares que nos ser√°n √∫tiles: </p><br><pre> <code class="haskell hljs">(*&gt;) :: fa -&gt; fb -&gt; fb (&lt;*) :: fa -&gt; fb -&gt; fa</code> </pre> <br><p>  Estas funciones realizan dos acciones consecutivas y devuelven el resultado de solo una de ellas.  Para los analizadores, pueden usarse, por ejemplo, para omitir los espacios iniciales antes de analizar una parte de una cadena que lleva una carga sem√°ntica. </p><br><p>  Al combinar <code>&lt;$&gt;</code> y <code>&lt;*&gt;</code> , puede crear dise√±os muy convenientes.  Considere el siguiente tipo de datos: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStructType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStruct</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type1</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type2</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field3</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type3</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  El constructor de valores <code>MyStruct</code> tambi√©n es una funci√≥n, en este caso es de tipo <code>Type1 -&gt; Type2 -&gt; Type3 -&gt; MyStructType</code> .  Puede trabajar con el constructor como con cualquier otra funci√≥n.  Supongamos que los analizadores ya se han escrito para los tipos de campos de estructura: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parser1</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type1</span></span> parser2 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type2</span></span> parser3 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type3</span></span></code> </pre> <br><p>  Usando la funci√≥n <code>fmap</code> , puede aplicar parcialmente <code>MyStruct</code> al primero de estos analizadores: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct'</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct' = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1</code> </pre> <br><p>  Intentemos aplicar la funci√≥n que ahora est√° "dentro" del analizador.  Para hacer esto, ya necesita usar <code>&lt;*&gt;</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct''</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct'' = parserStruct' &lt;*&gt; parser2 parserStruct :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = parserStruct'' &lt;*&gt; parser3</code> </pre> <br><p>  Como resultado, obtuvimos un analizador para toda la estructura (por supuesto, aqu√≠ usamos el supuesto de que en la l√≠nea original las representaciones de sus campos est√°n en una fila).  Lo mismo se puede hacer en una l√≠nea: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1 &lt;*&gt; parser2 &lt;*&gt; parser3</code> </pre> <br><p>  Tales construcciones se encontrar√°n a menudo en casos de uso. </p><br><p>  Ahora supongamos que estamos tratando de escribir un analizador sint√°ctico que analice expresiones aritm√©ticas simples en las que los enteros e identificadores pueden estar presentes como operandos.  Creemos un tipo separado de <code>Operand</code> para ellos: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IntOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdentOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre> <br><p>  Si ya sabemos c√≥mo analizar enteros e identificadores (por ejemplo, como en C), entonces necesitamos <em>un</em> analizador para los operandos que pueden analizar uno u otro.  Este analizador es una alternativa de los otros dos, por lo que necesitamos una funci√≥n que pueda combinar analizadores para que se combinen los resultados de su trabajo.  El resultado del analizador es una lista, y la combinaci√≥n de listas es su concatenaci√≥n.  Implementamos la funci√≥n <code>altP</code> combinando dos analizadores: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">altP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a altP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; p1 s ++ p2 s)</code> </pre> <br><p>  Luego, el analizador de operandos se puede implementar utilizando esta funci√≥n (aqu√≠ se supone que <code>parserInt</code> y <code>parserIdent</code> ya se describen en alguna parte: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserOperand</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Operand</span></span> parserOperand = altP parserIntOp parserIdentOp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> parserIntOp = <span class="hljs-type"><span class="hljs-type">IntOp</span></span> &lt;$&gt; parserInt parserIdentOp = <span class="hljs-type"><span class="hljs-type">IdentOp</span></span> &lt;$&gt; parserIdent</code> </pre> <br><p>  Por supuesto, para las alternativas ya hemos creado una clase separada, que se llama <code>Alternative</code> .  Tiene otro m√©todo, <code>empty</code> , que describe el elemento neutral para la operaci√≥n alternativa.  En nuestro caso, es un analizador que nunca analiza nada, es decir  siempre devuelve una lista vac√≠a de resultados.  Para el analizador, la implementaci√≥n de los m√©todos de la clase <code>Alternative</code> ve as√≠: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alternative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> empty :: fa (&lt;|&gt;) :: fa -&gt; fa -&gt; fa <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Alternative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> empty = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (const []) px &lt;|&gt; py = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; unParser px s ++ unParser py s)</code> </pre> <br><p>  La operaci√≥n <code>&lt;|&gt;</code> es la funci√≥n <code>altP</code> solo en notaci√≥n infija, que es m√°s conveniente de usar combinando varios analizadores en una fila. </p><br><p>  Para todos los tipos de esta clase, se implementan dos funciones, <code>some</code> y <code>many</code> tipo <code>fa -&gt; f [a]</code> .  Cada uno de ellos se puede expresar a trav√©s del otro: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">some</span></span> v = (:) &lt;$&gt; v &lt;*&gt; many v many v = some v &lt;|&gt; pure []</code> </pre> <br><p>  En t√©rminos de analizadores, estas funciones le permiten analizar secuencias de datos si sabe c√≥mo analizar un √∫nico elemento de datos.  En el caso de usar <code>some</code> secuencia no debe ser vac√≠a. </p><br><h1 id="primer-ispolzovaniya">  Ejemplo de uso </h1><br><p>  Ahora estamos listos para escribir su propio analizador, por ejemplo, para expresiones aritm√©ticas simples con la siguiente gram√°tica: </p><br><pre> <code class="plaintext hljs"> expr ::= constExpr | binOpExpr | negExpr const ::= int int ::= digit{digit} digit ::= '0' | ... | '9' binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binOp ::= '+' | '*' negExpr ::= '-' expr</code> </pre> <br><p>  La expresi√≥n consta de constantes enteras, el menos unario y dos operaciones binarias infijadas: suma y multiplicaci√≥n.  Se requieren corchetes alrededor de una expresi√≥n con una operaci√≥n binaria, el s√≠mbolo de la operaci√≥n est√° separado de los operandos por exactamente un espacio, no se permiten espacios iniciales y colgantes. </p><br><p>  Ejemplos de escritura de expresi√≥n correcta: </p><br><pre> <code class="plaintext hljs">"123" "-(10 + 42)" "(1 + ((2 + 3) * (4 + 5)))"</code> </pre> <br><p>  Ejemplos de entradas incorrectas: </p><br><pre> <code class="plaintext hljs">" 666 " "2 + 3" "(10 * 10)"</code> </pre> <br><p>  Declaramos los tipos de datos necesarios (la expresi√≥n en s√≠ y la operaci√≥n binaria): </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinaryExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NegateExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mul</span></span></span></span></code> </pre> <br><p>  ¬°Puedes comenzar a analizar!  La expresi√≥n misma consta de tres alternativas.  Entonces escribimos: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- expr ::= constExpr | binOpExpr | negExpr exprParser :: Parser Expr exprParser = constParser &lt;|&gt; binParser &lt;|&gt; negParser</span></span></code> </pre> <br><p>  Una constante es un entero positivo.  En nuestro tipo de datos, est√° "envuelto" en el constructor, por lo que no podemos usar el analizador para un entero directamente, pero podemos usar <code>fmap</code> para obtener el valor del tipo deseado. </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- const ::= int constParser :: Parser Expr constParser = ConstExpr &lt;$&gt; intParser</span></span></code> </pre> <br><p>  Un n√∫mero entero, seg√∫n la gram√°tica, se representa como una secuencia de n√∫meros no vac√≠a.  Para analizar un d√≠gito, utilizamos la funci√≥n auxiliar <code>predP</code> y el predicado <code>isDigit</code> del m√≥dulo <code>Data.Char</code> .  Ahora, para construir un analizador sint√°ctico para analizar una secuencia de d√≠gitos, usamos la funci√≥n <code>some</code> (no <code>many</code> , porque debe haber al menos un d√≠gito).  El resultado de dicho analizador devuelve una lista de todas las opciones de an√°lisis posibles, comenzando con el registro m√°s largo.  Por ejemplo, si la cadena de entrada es "123ab", la lista de resultados ser√° la siguiente: <code>[("ab", "123"), ("3ab", "12"), ("23ab", "1")]</code> .  Necesitamos analizar la secuencia m√°s larga de d√≠gitos y convertirla a tipo <code>Int</code> .  Toda la implementaci√≥n es la siguiente: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- int ::= digit{digit} -- digit ::= '0' | ... | '9' intParser :: Parser Int intParser = Parser $ \s -&gt; let res = unParser (some digitParser) s in case res of [] -&gt; [] ((rest, i) : xs) -&gt; [(rest, read i)] where digitParser = predP isDigit</span></span></code> </pre> <br><p>  La siguiente forma de escribir una expresi√≥n es usar una operaci√≥n binaria.  Seg√∫n la gram√°tica, el par√©ntesis de apertura debe incluir primero el par√©ntesis de apertura, el primer operando, el espacio, el s√≠mbolo de operaci√≥n, otro espacio, el segundo operando y el par√©ntesis de cierre.  Para analizar caracteres individuales (corchetes y espacios) utilizamos la funci√≥n <code>charP</code> .  Los operandos son expresiones, y ya hay un analizador ( <code>exprParser</code> ) para analizarlos.  Para analizar el s√≠mbolo de operaci√≥n binaria, describimos el analizador auxiliar justo debajo.  Queda por combinar perfectamente este conjunto de analizadores.  Debe haber corchetes al principio y al final de la expresi√≥n: debe verificar esto, pero descartar el resultado en s√≠.  Para hacer esto, use <code>*&gt;</code> y <code>&lt;*</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">binParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Expr</span></span> binParser = charP '(' *&gt; ??? &lt;* charP ')'</code> </pre> <br><p>  Entre estos analizadores para par√©ntesis, se debe construir una expresi√≥n usando el constructor <code>BinaryExpr</code> y analizadores para la expresi√≥n y la operaci√≥n.  No olvide los espacios alrededor del s√≠mbolo de operaci√≥n, utilizando el mismo m√©todo que para los corchetes.  Esta parte es la siguiente: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">BinaryExpr</span></span> &lt;$&gt; exprParser <span class="hljs-comment"><span class="hljs-comment">--   &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') -- ,   &lt;*&gt; exprParser --  </span></span></code> </pre> <br><p>  Sustituimos esta expresi√≥n en lugar de signos de interrogaci√≥n: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binParser :: Parser Expr binParser = charP '(' *&gt; (BinaryExpr &lt;$&gt; exprParser &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') &lt;*&gt; exprParser ) &lt;* charP ')'</span></span></code> </pre> <br><p>  Una operaci√≥n binaria es un car√°cter <code>+</code> que analiza el valor <code>Add</code> o <code>*</code> que analiza el <code>Mul</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOp ::= '+' | '*' binOpParser :: Parser Operator binOpParser = plusParser &lt;|&gt; multParser where plusParser = charP '+' $&gt; Add multParser = charP '*' $&gt; Mul</span></span></code> </pre> <br><p>  Lo que queda es la parte m√°s simple de la gram√°tica, la negaci√≥n de la expresi√≥n.  Con un s√≠mbolo <code>-</code> lo mismo que con corchetes y espacios.  A continuaci√≥n, aplique el constructor <code>NegateExpr</code> al resultado del an√°lisis recursivo: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- negExpr ::= '-' expr negParser = charP '-' *&gt; (NegateExpr &lt;$&gt; exprParser)</span></span></code> </pre> <br><p>  Por lo tanto, se implementan todas las partes del analizador.  El c√≥digo es muy parecido a una gram√°tica y coincide completamente con √©l en la estructura. </p><br><p>  El c√≥digo fuente est√° disponible en GitLab: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://gitlab.com/fierce-katie/applicative-parsers-demo</a> . </p><br><p>  All√≠ es m√°s f√°cil evaluar su volumen y grado de expresividad, ya que hay muchos menos comentarios.  Puede compilar el proyecto con la utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Stack</a> y ejecutar el int√©rprete primitivo utilizando el analizador que escribimos: </p><br><pre> <code class="plaintext hljs">$ stack build $ stack exec demo-parser</code> </pre> <br><p>  Para aquellos que quieran practicar m√°s por su cuenta, puedo aconsejar lo siguiente: </p><br><ul><li>  La gram√°tica se puede mejorar en todos los sentidos, por ejemplo, para permitir espacios iniciales y colgantes, agregar nuevas operaciones, etc. </li><li>  El analizador traduce la cadena en la representaci√≥n interna de la expresi√≥n.  Esta expresi√≥n se puede calcular y el int√©rprete convertido para que imprima no el resultado del an√°lisis, sino el resultado del c√°lculo. </li><li>  Explore las posibilidades de las <code>attoparsec</code> <code>parsec</code> , <code>attoparsec</code> , <code>optparse-applicative</code> y <code>optparse-applicative</code> e intente usarlas. </li></ul><br><p>  Gracias por su atencion! </p><br><h1 id="poleznye-materialy">  Materiales utiles </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprende Haskell en Y minutos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Denis Shevchenko.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Sobre Haskell como ser humano"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca Parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca Attoparsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca aplicativa-parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca de aplicaci√≥n selectiva</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436234/">https://habr.com/ru/post/es436234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436224/index.html">Escribimos nuestro lenguaje de programaci√≥n, parte 4: Representaci√≥n de estructuras y clases, generaci√≥n de asignadores.</a></li>
<li><a href="../es436226/index.html">Gu√≠a y hoja de trucos para Wireshark</a></li>
<li><a href="../es436228/index.html">Desarrollo de un equipo para consultar datos de la base de datos.</a></li>
<li><a href="../es436230/index.html">C√≥mo tomar el control de su infraestructura de red. Cap√≠tulo tres Seguridad de red. Parte dos</a></li>
<li><a href="../es436232/index.html">Estrategia de telepat√≠a</a></li>
<li><a href="../es436236/index.html">Utilizamos la ciencia de datos para determinar el ciclo de vida de un cliente.</a></li>
<li><a href="../es436238/index.html">Autenticaci√≥n en Kubernetes con GitHub OAuth y Dex</a></li>
<li><a href="../es436240/index.html">Automatizaci√≥n VS Caos</a></li>
<li><a href="../es436242/index.html">YOLO y otras metodolog√≠as sueltas</a></li>
<li><a href="../es436244/index.html">El nuevo cerebro del profesor Lawrence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>