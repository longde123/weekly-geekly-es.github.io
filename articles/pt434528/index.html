<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïó üí§ üë®üèø‚Äçüî¨ Descriptografia do ray tracer do tamanho de um cart√£o postal üòí ü¶á üßíüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúEle fez de novo!‚Äù - foi o que me ocorreu quando olhei para o verso do folheto da Pixar [1] , completamente preenchido com c√≥digo. Um conjunto de cons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Descriptografia do ray tracer do tamanho de um cart√£o postal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434528/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cr/xz/vj/crxzvjqqbw5gl4mv3wxxx2zw6wa.png"></div><br>  ‚ÄúEle fez de novo!‚Äù - foi o que me ocorreu quando olhei para o verso do folheto da Pixar <sup>[1]</sup> , completamente preenchido com c√≥digo.  Um conjunto de constru√ß√µes e express√µes foi assinado no canto inferior direito por ningu√©m menos que Andrew Kensler.  Para quem n√£o o conhece, direi: Andrew √© um programador que inventou um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ray tracer de</a> 1337 bytes em 2009. <br><br>  Desta vez, Andrew apresentou algo mais volumoso, mas com um resultado visual muito mais interessante.  Desde que terminei de escrever meus livros negros do Game Engine sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wolf3D</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DOOM</a> , tive tempo de aprender o interior de seu c√≥digo enigm√°tico.  E quase imediatamente, fiquei literalmente fascinado pelas t√©cnicas descobertas nele.  Eles eram muito diferentes do trabalho anterior de Andrew, baseado em um tra√ßador de raios "padr√£o".  Eu estava interessado em aprender sobre marchar com raios, recursos de geometria volum√©trica construtiva, renderiza√ß√£o / rastreamento de caminhos de Monte Carlo, bem como muitos outros truques que ele usou para espremer c√≥digo em um peda√ßo de papel t√£o pequeno. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/z4/nt/ycz4ntg3qh91i6m2wymfccaekvk.png"></div><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lf/2o/qv/lf2oqvd5d39pyfwxyixvjnrmlqq.png"></div><br><h2>  C√≥digo fonte </h2><br><hr><br>  A frente do folheto √© um an√∫ncio para o departamento de recrutamento da Pixar.  No verso, s√£o impressos 2.037 bytes de c√≥digo C ++, ofuscados para ocupar a menor superf√≠cie poss√≠vel. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; // card &gt; pixar.ppm #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define R return #define O operator typedef float F;typedef int I;struct V{F x,y,z;V(F v=0){x=y=z=v;}V(F a,F b,F c=0){x=a;y=b;z=c;}V O+(V r){RV(x+rx,y+ry,z+rz);}VO*(V r){RV(x*rx,y*r. y,z*rz);}FO%(V r){R x*r.x+y*r.y+z*rz;}VO!(){R*this*(1/sqrtf(*this%*this) );}};FL(F l,F r){R l&lt;r?l:r;}FU(){R(F)rand()/RAND_MAX;}FB(V p,V l,V h){l=p +l*-1;h=h+p*-1;RL(L(L(lx,hx),L(ly,hy)),L(lz,hz));}FS(V p,I&amp;m){F d=1\ e9;V f=p;fz=0;char l[]="5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_]OWW[WaOa_aW\ eWa_e_cWiO";for(I i=0;i&lt;60;i+=4){V b=V(l[i]-79,l[i+1]-79)*.5,e=V(l[i+2]-79,l [i+3]-79)*.5+b*-1,o=f+(b+e*L(-L((b+f*-1)%e/(e%e),0),1))*-1;d=L(d,o%o);}d=sq\ rtf(d);V a[]={V(-11,6),V(11,6)};for(I i=2;i--;){V o=f+a[i]*-1;d=L(d,ox&gt;0?f\ absf(sqrtf(o%o)-2):(o.y+=oy&gt;0?-2:2,sqrtf(o%o)));}d=powf(powf(d,8)+powf(pz, 8),.125)-.5;m=1;F r=L(-L(B(p,V(-30,-.5,-30),V(30,18,30)),B(p,V(-25,17,-25),V (25,20,25))),B(V(fmodf(fabsf(px),8),py,pz),V(1.5,18.5,-25),V(6.5,20,25))) ;if(r&lt;d)d=r,m=2;F s=19.9-py;if(s&lt;d)d=s,m=3;R d;}IM(V o,V d,V&amp;h,V&amp;n){I m,s= 0;F t=0,c;for(;t&lt;100;t+=c)if((c=S(h=o+d*t,m))&lt;.01||++s&gt;99)R n=!V(S(h+V(.01,0 ),s)-c,S(h+V(0,.01),s)-c,S(h+V(0,0,.01),s)-c),m;R 0;}VT(V o,V d){V h,n,r,t= 1,l(!V(.6,.6,1));for(I b=3;b--;){I m=M(o,d,h,n);if(!m)break;if(m==1){d=d+n*( n%d*-2);o=h+d*.1;t=t*.2;}if(m==2){F i=n%l,p=6.283185*U(),c=U(),s=sqrtf(1-c), g=nz&lt;0?-1:1,u=-1/(g+nz),v=nx*ny*u;d=V(v,g+ny*ny*u,-ny)*(cosf(p)*s)+V( 1+g*nx*nx*u,g*v,-g*nx)*(sinf(p)*s)+n*sqrtf(c);o=h+d*.1;t=t*.2;if(i&gt;0&amp;&amp;M(h +n*.1,l,h,n)==3)r=r+t*V(500,400,100)*i;}if(m==3){r=r+t*V(50,80,100);break;}} R r;}I main(){I w=960,h=540,s=16;V e(-22,5,25),g=!(V(-3,4,0)+e*-1),l=!V(gz, 0,-gx)*(1./w),u(gy*lz-gz*ly,gz*lx-gx*lz,gx*ly-gy*lx);printf("P\ 6 %d %d 255 ",w,h);for(I y=h;y--;)for(I x=w;x--;){V c;for(I p=s;p--;)c=c+T(e ,!(g+l*(xw/2+U())+u*(yh/2+U())));c=c*(1./s)+14./241;V o=c+1;c=V(cx/ox,c. y/oy,cz/oz)*255;printf("%c%c%c",(I)cx,(I)cy,(I)cz);}}// Andrew Kensler</span></span></span></span></code> </pre> <br><h2>  Ele trabalha mesmo? </h2><br><hr><br>  Com o c√≥digo, h√° uma instru√ß√£o para seu lan√ßamento.  A id√©ia √© redirecionar a sa√≠da padr√£o para um arquivo.  Por extens√£o, podemos assumir que o formato de sa√≠da √© um formato de imagem de texto chamado NetPBM <sup>[2]</sup> . <br><br><pre>  $ clang -o card2 -O3 raytracer.cpp
 $ time ./card&gt; pixar.ppm<font></font>
<font></font>
 2m58.524s reais
 usu√°rio 2m57.567s
 sys 0m0.415s </pre><br>  Ap√≥s dois minutos e cinquenta e oito segundos <sup>[3]</sup> , a seguinte imagem √© gerada.  √â incr√≠vel como pouco c√≥digo √© necess√°rio para isso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/b34/b5c/caeb34b5c6c57c4598adc8f6b3f28f38.webp"></div><br>  Voc√™ pode extrair muito da imagem acima.  Grit √© um sinal √≥bvio de um "rastreador de caminho".  Esse tipo de renderizador difere do rastreamento de raios, pois os raios n√£o s√£o rastreados de volta √†s fontes de luz.  Nesse m√©todo, milhares de raios por pixel s√£o emitidos das fontes e o programa os monitora, esperando que eles encontrem a fonte de luz.  Essa √© uma t√©cnica interessante que, muito melhor do que o tra√ßado de raios, pode lidar com a renderiza√ß√£o de oclus√£o ambiental, sombras suaves, c√°usticas e radiosidade. <br><br><h2>  Vamos dividir o c√≥digo em partes </h2><br><hr><br>  Passar entrada para o CLion formata o c√≥digo (veja a sa√≠da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ) e o divide em partes / tarefas menores. <br><br><pre>  <font color="grey">#include &lt;stdlib.h&gt; // cart√£o&gt; pixar.ppm</font> <font color="grey">
</font>  <font color="grey">#include &lt;stdio.h&gt;</font> <font color="grey">
</font>  <font color="grey">#include &lt;math.h&gt;</font> </pre><br><pre>  <font color="fuchsia">#define R return</font> <font color="fuchsia">
</font>  <font color="fuchsia">#define O operator</font> <font color="fuchsia">
</font>  <font color="fuchsia">typedef float F; typedef int I;</font> </pre><pre>  <font color="blue">struct V {F x, y, z; V (F v = 0) {x = y = z = v;} V (F a, F b, F</font> <font color="blue">
</font>  <font color="blue">c = 0) {x = a; y = b; z = c;} V O + (V r) {RV (x + rx, y + ry, z + rz);} VO * (V r) {RV ( x * rx, y * r.</font> <font color="blue">
</font>  <font color="blue">y, z * rz);} FO% (V r) {R x * r.x + y * r.y + z * rz;} VO! () {R * this * (1 / sqrtf (* this% * isto)</font> <font color="blue">
</font>  <font color="blue">);</font> </pre><pre>  <font color="orange">FL (F l, F r) {R l &lt;r? L: r;} FU () {R (F) rand () / RAND_MAX;} FB (V p, V l, V h) {l = p</font> <font color="orange">
</font>  <font color="orange">+ l * -1; h = h + p * -1; RL (L (L (L (lx, hx), L (ly, hy)), L (lz, hz));}</font> </pre><pre>  <font color="LimeGreen">FS (Vp, I &amp; m) {F d = 1 \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">e9; V f = p; fz = 0; char l [] = "5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_] OWW [WaOa_aW \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">eWa_e_cWiO "; para (I i = 0; i &lt;60; i + = 4) {V b = V (l [i] -79, l [i + 1] -79) *. 5, e = V (l [ i + 2] -79, l</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">[i + 3] -79) *. 5 + b * -1, o = f + (b + e * L (-L ((b + f * -1)% e / (e% e), 0), 1)) * - 1; d = L (d, o% o);} d = sq \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">rtf (d); V a [] = {V (-11,6), V (11,6)}; para (I i = 2; i -;) {V o = f + a [i] * -1; d = L (d, ox&gt; 0? F \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">absf (sqrtf (o% o) -2) :( o.y + = oy&gt; 0? -2: 2, sqrtf (o% o)));} d = powf (powf (d, 8) + powf (pz ,</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">8), 125) -. 5; m = 1; F r = L (-L (B (p, V (-30, -. 5, -30), V (30,18,30)), B (p, V (-25,17, -25), V</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">(25,20,25))), B (V (fmodf (fabsf (px), 8), py, pz), V (1,5,18,5, -25), V (6,5,20,25)))</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">; if (r &lt;d) d = r, m = 2; F s = 19,9-py; if (s &lt;d) d = s, m = 3; R d;}</font> </pre><pre>  <font color="black">IM (V o, V d, V e h, V e n) {I m, s =</font> <font color="black">
</font>  <font color="black">0; F t = 0, c; para (; t &lt;100; t + = c) se ((c = S (h = o + d * t, m)) &lt;. 01 || ++ s&gt; 99) R n =! V (S (h + V (0,01,0</font> <font color="black">
</font>  <font color="black">), s) -c, S (h + V (0, 01), s) -c, S (h + V (0,0, 0,01), s) -c), m; R 0;}</font> </pre><pre>  <font color="SkyBlue">VT (V o, V d) {V h, n, r, t =</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1, l (! V (.6, .6,1)); para (I b = 3; b -;) {I m = M (o, d, h, n); se (! M) quebrar ; se (m == 1) {d = d + n * (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">n% d * -2); o = h + d * .1; t = t * .2;} se (m == 2) {F i = n% l, p = 6,283185 * U (), c = U (), s = sqrtf (1-c),</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">g = nz &lt;0? -1: 1, u = -1 / (g + nz), v = nx * ny * u; d = V (v, g + ny * ny * u, -ny) * (cosf (p) * s) + V (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1 + g * nx * nx * u, g * v, -g * nx) * (sinf (p) * s) + n * sqrtf (c); o = h + d * .1; t = t *. 2; se (i&gt; 0 &amp;&amp; M (h</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">+ n * .1, l, h, n) == 3) r = r + t * V (500,400,100) * i;} se (m == 3) {r = r + t * V (50,80,100) ; break;}}</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">R r;</font> </pre><pre>  <font color="red">I main () {I w = 960, h = 540, s = 16; V e (-22,5,25), g =! (V (-3,4,0) + e * -1), l =! V (gz,</font> <font color="red">
</font>  <font color="red">0, -gx) * (1./w), u (gy * lz-gz * ly, gz * lx-gx * lz, gx * ly-gy * lx); printf ("P \</font> <font color="red">
</font>  <font color="red">6% d% d 255 ", w, h); para (I y = h; y -;) para (I x = w; x -;) {V c; para (I p = s; p- -;) c = c + T (e</font> <font color="red">
</font>  <font color="red">, (g + l * (xw / 2 + U ()) + u * (yh / 2 + U ()))); c = c * (1./s) + 14. / 241; V o = c + 1; c = V (cx / ox, c.</font> <font color="red">
</font>  <font color="red">y / oy, cz / oz) * 255; printf ("% c% c% c", (I) cx, (I) cy, (I) cz);}}</font> </pre><pre>  <font color="LightGray">// Andrew Kensler</font> </pre><br>  Cada uma das se√ß√µes √© descrita em detalhes no restante do artigo: <br>  <font color="fuchsia">‚ñ†</font> - truques comuns, <font color="blue">‚ñ†</font> - classe vetorial, <font color="orange">‚ñ†</font> - c√≥digo auxiliar, <font color="LimeGreen">‚ñ†</font> - banco de dados, <font color="black">‚ñ†</font> - marcha de raios, <font color="SkyBlue">‚ñ†</font> - amostragem, <font color="red">‚ñ†</font> - c√≥digo principal. <br><br><h2>  Truques comuns com #define e typedef </h2><br><hr><br>  Truques comuns est√£o usando #define e typedef para reduzir significativamente a quantidade de c√≥digo.  Aqui denotamos F = float, I = int, R = return e O = operador.  A engenharia reversa √© trivial. <br><br><h2>  Classe v </h2><br><hr><br>  Em seguida, vem a classe V, que renomeei para Vec (embora, como veremos abaixo, ela tamb√©m seja usada para armazenar canais RGB no formato float). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = y = z = v; } Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = a; y = b; z = c;} Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x + rx, y + ry, z + rz); } Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x * rx, y * ry, z * rz); } <span class="hljs-comment"><span class="hljs-comment">// dot product float operator%(Vec r) { return x * rx + y * ry + z * rz; } // inverse square root Vec operator!() {return *this * (1 / sqrtf(*this % *this) );} };</span></span></code> </pre> <br>  Observe que n√£o h√° operador de subtra√ß√£o (-); portanto, em vez de escrever "X = A - B", "X = A + B * -1" √© usado.  A raiz quadrada inversa √© √∫til mais tarde para normalizar os vetores. <br><br><h2>  Fun√ß√£o principal </h2><br><hr><br>  main () √© o √∫nico caractere que n√£o pode ser ofuscado porque √© chamado pela fun√ß√£o _start da biblioteca libc.  Geralmente, vale a pena come√ßar com isso, porque ser√° mais f√°cil trabalhar dessa maneira.  Demorei um pouco para descobrir o significado das primeiras letras, mas ainda assim consegui criar algo leg√≠vel. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">960</span></span>, h = <span class="hljs-number"><span class="hljs-number">540</span></span>, samplesCount = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">position</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-22</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Vec goal = !(Vec(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + position * <span class="hljs-number"><span class="hljs-number">-1</span></span>); Vec left = !Vec(goal.z, <span class="hljs-number"><span class="hljs-number">0</span></span>, -goal.x) * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / w); <span class="hljs-comment"><span class="hljs-comment">// Cross-product to get the up vector Vec up(goal.y * left.z - goal.z * left.y, goal.z * left.x - goal.x * left.z, goal.x * left.y - goal.y * left.x); printf("P6 %d %d 255 ", w, h); for (int y = h; y--;) for (int x = w; x--;) { Vec color; for (int p = samplesCount; p--;) color = color + Trace(position, !(goal + left * (x - w / 2 + randomVal())+ up * (y - h / 2 + randomVal()))); // Reinhard tone mapping color = color * (1. / samplesCount) + 14. / 241; Vec o = color + 1; color = Vec(color.x / ox, color.y / oy, color.z / oz) * 255; printf("%c%c%c", (int) color.x, (int) color.y, (int) color.z); } }</span></span></code> </pre> <br>  Observe que literais flutuantes n√£o cont√™m a letra "f" e a parte fracion√°ria √© descartada para economizar espa√ßo.  O mesmo truque √© usado abaixo, onde a parte inteira √© descartada (float x = 0,5).  Tamb√©m incomum √© a constru√ß√£o "for" com uma express√£o de itera√ß√£o inserida dentro da condi√ß√£o de interrup√ß√£o. <br><br>  Esta √© uma fun√ß√£o principal bastante padr√£o para um rastreador de raio / caminho.  Os vetores da c√¢mera s√£o definidos aqui e os raios s√£o emitidos para cada pixel.  A diferen√ßa entre o tra√ßador de raios e o tra√ßador de caminhos √© que v√°rios raios s√£o emitidos por pixel no TP, que s√£o levemente deslocados aleatoriamente.  Ent√£o a cor obtida para cada raio em um pixel √© acumulada em tr√™s canais de flutua√ß√£o R, B, G.  No final, √© realizada a corre√ß√£o tonal do resultado do m√©todo Reinhardt. <br><br>  A parte mais importante √© sampleCount, que teoricamente pode ser definido como 1 para acelerar a renderiza√ß√£o e a itera√ß√£o.  Aqui est√£o representa√ß√µes de amostra com valores de amostra de 1 a 2048. <br><br><div class="spoiler">  <b class="spoiler_title">T√≠tulo de spoiler</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/550/e66/b2b/550e66b2b1347f8cafdf18c50d89e40d.png"><br><br>  1 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f49/724/1f0/f497241f0e3bb43fcc9913d8a2745419.png"><br><br>  2 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f71/3f3/35c/f713f335c2842b995936db1499e307e5.png"><br><br>  4 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/6d4/f56/b4f6d4f56198a64b8e569a62f7159e8a.png"><br><br>  8 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/200/3c6/a702003c61d4080c2f92fe84844238cd.png"><br><br>  16 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcf/0d6/43c/bcf0d643c501839c2506c7c026bc445c.png"><br><br>  32. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f0/5cf/569/8f05cf5690fa3265a1a4fa6f60a35749.png"><br><br>  64 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebd/c87/660/ebdc87660263ff14eb6bf03a95865f34.png"><br><br>  128 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d17/0d3/1ae/d170d31aed20aeafc54d877ed447a1cc.png"><br><br>  256 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"><br><br>  512 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/460/50f/715/46050f71582834ddebbeb29dd86940fc.png"><br><br>  1024 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/947/ea8/88b/947ea888b63c32f0892cc1e25b187bf8.png"><br><br>  2048 </div></div><br><h2>  C√≥digo auxiliar </h2><br><hr><br>  Outro trecho simples de c√≥digo s√£o as fun√ß√µes auxiliares.  Nesse caso, temos uma fun√ß√£o trivial min (), um gerador de valor aleat√≥rio no intervalo [0,1] e um boxTest muito mais interessante, que faz parte do sistema Construct Solid Geometry (CSG) usado para cortar o mundo.  O CSG √© discutido na pr√≥xima se√ß√£o. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &lt; r ? l : r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) rand() / RAND_MAX; } <span class="hljs-comment"><span class="hljs-comment">// Rectangle CSG equation. Returns minimum signed distance from // space carved by lowerLeft vertex and opposite rectangle // vertex upperRight. float BoxTest(Vec position, Vec lowerLeft, Vec upperRight) { lowerLeft = position + lowerLeft * -1; upperRight = upperRight + position * -1; return -min( min( min(lowerLeft.x, upperRight.x), min(lowerLeft.y, upperRight.y) ), min(lowerLeft.z, upperRight.z)); }</span></span></code> </pre> <br><h2>  Fun√ß√µes da geometria volum√©trica construtiva </h2><br><hr><br>  N√£o h√° v√©rtices no c√≥digo.  Tudo √© feito usando as fun√ß√µes CSG.  Se voc√™ n√£o estiver familiarizado com elas, basta dizer que essas s√£o fun√ß√µes que descrevem se a coordenada est√° dentro ou fora do objeto.  Se a fun√ß√£o retornar uma dist√¢ncia positiva, o ponto estar√° dentro do objeto.  Uma dist√¢ncia negativa indica que o ponto est√° fora do objeto.  Existem muitas fun√ß√µes para descrever objetos diferentes, mas, para simplificar, tomemos, por exemplo, uma esfera e dois pontos, A e B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56f/424/13a/56f42413a77c51a3d06e12fd4b4b385e.svg" alt="imagem"></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to sphere(c,r) float testSphere(Vec p, Vec c, float r) { Vec delta = c - p; float distance = sqrtf(delta%delta); return radius - distance; } Vec A {4, 6}; Vec B {3, 2}; Vec C {4, 2}; float r = 2.; testSphere(A, C, r); // == -1 (outside) testSphere(B, C, r); // == 1 (inside)</span></span></code> </pre> <br>  A fun√ß√£o testSphere () retorna -1 para o ponto A (ou seja, est√° fora) e 1 para B (ou seja, est√° dentro).  Sinais a dist√¢ncias s√£o apenas um truque, permitindo que voc√™ obtenha duas informa√ß√µes em vez de uma no caso de um √∫nico valor.  Um tipo semelhante de fun√ß√£o pode ser escrito para descrever um paralelogramo (√© exatamente isso que √© executado na fun√ß√£o BoxTest). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/1cd/25b/7571cd25baa7d2f9cfbd01f62e84aef1.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to Box(c1,c2) float testRectangle(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testRectangle(A, C1, C2); // 1.41 (inside) testRectangle(B, C1, C2); // -2.23 (outside)</span></span></code> </pre> <br>  Agora vamos ver o que acontece se voc√™ virar o sinal do valor de retorno. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/017/bd8/dcd017bd89a9e9d3955c94be3645aa20.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to carved box(c1,c2) float testCarveBox(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return -min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testCarveBox(A, C1, C2); // == -1.41 (outside) testCarveBox(B, C1, C2); // == 2.23 (inside)</span></span></code> </pre> <br>  Agora n√£o descrevemos um objeto s√≥lido, mas declaramos o mundo inteiro s√≥lido e cortamos um espa√ßo vazio nele.  As fun√ß√µes podem ser usadas como tijolos de constru√ß√£o, que quando combinados podem descrever formas mais complexas.  Usando o operador de adi√ß√£o l√≥gica (fun√ß√£o min), podemos cortar um par de ret√¢ngulos um acima do outro e o resultado ser√° semelhante a este. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/f78/615/48bf786150f9d37af1f51fd12987162e.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point to room float testRoom(Vec p) { Vec C1 {2, 4}; Vec C2 {5, 2}; // Lower room Vec C3 {3, 5}; Vec C4 {4, 4}; // Upper room // min() is the union of the two carved volumes. return min(testCarvedBox(p, C1, C2), testCarvedBox(p, C3, C4)); } Vec A {3, 3}; Vec B {4, 6}; testRoom(A, C1, C2); // == -1.41 (outside) testRoom(B, C1, C2); // == 1.00 (inside)</span></span></code> </pre> <br>  Se voc√™ pensar bem, parece a sala que estamos estudando, porque a sala inferior √© expressa exatamente dessa maneira - com a ajuda de dois paralelogramos cortados. <br><br>  Agora, tendo dominado o poderoso conhecimento do CSG, podemos retornar ao c√≥digo e considerar a fun√ß√£o do banco de dados, que √© a mais dif√≠cil de lidar. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_NONE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_LETTER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_WALL 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_SUN 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Sample the world using Signed Distance Fields. float QueryDatabase(Vec position, int &amp;hitType) { float distance = 1e9; Vec f = position; // Flattened position (z=0) fz = 0; char letters[15*4+1] = // 15 two points lines "5O5_" "5W9W" "5_9_" // P (without curve) "AOEO" "COC_" "A_E_" // I "IOQ_" "I_QO" // X "UOY_" "Y_]O" "WW[W" // A "aOa_" "aWeW" "a_e_" "cWiO"; // R (without curve) for (int i = 0; i &lt; sizeof(letters); i += 4) { Vec begin = Vec(letters[i] - 79, letters[i + 1] - 79) * .5; Vec e = Vec(letters[i + 2] - 79, letters[i + 3] - 79) * .5 + begin * -1; Vec o = f + (begin + e * min(-min((begin + f * -1) % e / (e % e), 0), 1) ) * -1; distance = min(distance, o % o); // compare squared distance. } distance = sqrtf(distance); // Get real distance, not square distance. // Two curves (for P and R in PixaR) with hard-coded locations. Vec curves[] = {Vec(-11, 6), Vec(11, 6)}; for (int i = 2; i--;) { Vec o = f + curves[i] * -1; distance = min(distance, ox &gt; 0 ? fabsf(sqrtf(o % o) - 2) : (oy += oy &gt; 0 ? -2 : 2, sqrtf(o % o)) ); } distance = powf(powf(distance, 8) + powf(position.z, 8), .125) - .5; hitType = HIT_LETTER; float roomDist ; roomDist = min(// min(A,B) = Union with Constructive solid geometry //-min carves an empty space -min(// Lower room BoxTest(position, Vec(-30, -.5, -30), Vec(30, 18, 30)), // Upper room BoxTest(position, Vec(-25, 17, -25), Vec(25, 20, 25)) ), BoxTest( // Ceiling "planks" spaced 8 units apart. Vec(fmodf(fabsf(position.x), 8), position.y, position.z), Vec(1.5, 18.5, -25), Vec(6.5, 20, 25) ) ); if (roomDist &lt; distance) distance = roomDist, hitType = HIT_WALL; float sun = 19.9 - position.y ; // Everything above 19.9 is light source. if (sun &lt; distance)distance = sun, hitType = HIT_SUN; return distance; }</span></span></span></span></code> </pre> <br>  Voc√™ pode ver aqui a fun√ß√£o de "cortar" o paralelogramo, no qual apenas dois ret√¢ngulos s√£o usados ‚Äã‚Äãpara construir toda a sala (nosso c√©rebro faz o resto, representa paredes).  A escada horizontal √© uma fun√ß√£o CSG um pouco mais complexa usando a divis√£o restante.  E, finalmente, as letras da palavra PIXAR s√£o compostas por 15 linhas com um par "origem / delta" e dois casos especiais para curvas nas letras P e R. <br><br><h2>  Marcha de raio </h2><br><hr><br>  Tendo um banco de dados de fun√ß√µes CSG descrevendo o mundo, √© suficiente ignorarmos todos os raios emitidos na fun√ß√£o main ().  A marcha de raio usa a fun√ß√£o de dist√¢ncia.  Isso significa que a posi√ß√£o de amostragem se move para frente uma dist√¢ncia at√© o obst√°culo mais pr√≥ximo. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Perform signed sphere marching // Returns hitType 0, 1, 2, or 3 and update hit position/normal int RayMarching(Vec origin, Vec direction, Vec &amp;hitPos, Vec &amp;hitNorm) { int hitType = HIT_NONE; int noHitCount = 0; float d; // distance from closest object in world. // Signed distance marching for (float total_d=0; total_d &lt; 100; total_d += d) if ((d = QueryDatabase(hitPos = origin + direction * total_d, hitType)) &lt; .01 || ++noHitCount &gt; 99) return hitNorm = !Vec(QueryDatabase(hitPos + Vec(.01, 0), noHitCount) - d, QueryDatabase(hitPos + Vec(0, .01), noHitCount) - d, QueryDatabase(hitPos + Vec(0, 0, .01), noHitCount) - d) , hitType; // Weird return statement where a variable is also updated. return 0; }</span></span></code> </pre> <br>  A id√©ia de marchar com raios com base na dist√¢ncia √© avan√ßar uma dist√¢ncia at√© o objeto mais pr√≥ximo.  No final, o feixe se aproximar√° tanto da superf√≠cie que pode ser considerado um ponto de incid√™ncia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e99/774/398/e997743989aa1cb22fb65e6d5d8e93f2.svg"></div><br>  Observe que a marcha de raios n√£o retorna uma interse√ß√£o verdadeira com a superf√≠cie, mas uma aproxima√ß√£o.  √â por isso que a marcha para no c√≥digo quando d &lt;0,01f. <br><br><h2>  Juntando tudo: amostragem </h2><br><hr><br>  A investiga√ß√£o do tra√ßador de caminhos est√° quase completa.  Est√° faltando uma ponte que conecte a fun√ß√£o main () ao ray marcher.  Esta √∫ltima parte, que renomei de ‚ÄúTrace‚Äù, √© o ‚Äúc√©rebro‚Äù no qual os raios saltam ou param, dependendo do que encontram. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vec origin, Vec direction)</span></span></span><span class="hljs-function"> </span></span>{ Vec sampledPosition, normal, color, attenuation = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightDirection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!Vec(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Directional light for (int bounceCount = 3; bounceCount--;) { int hitType = RayMarching(origin, direction, sampledPosition, normal); if (hitType == HIT_NONE) break; // No hit. This is over, return color. if (hitType == HIT_LETTER) { // Specular bounce on a letter. No color acc. direction = direction + normal * ( normal % direction * -2); origin = sampledPosition + direction * 0.1; attenuation = attenuation * 0.2; // Attenuation via distance traveled. } if (hitType == HIT_WALL) { // Wall hit uses color yellow? float incidence = normal % lightDirection; float p = 6.283185 * randomVal(); float c = randomVal(); float s = sqrtf(1 - c); float g = normal.z &lt; 0 ? -1 : 1; float u = -1 / (g + normal.z); float v = normal.x * normal.y * u; direction = Vec(v, g + normal.y * normal.y * u, -normal.y) * (cosf(p) * s) + Vec(1 + g * normal.x * normal.x * u, g * v, -g * normal.x) * (sinf(p) * s) + normal * sqrtf(c); origin = sampledPosition + direction * .1; attenuation = attenuation * 0.2; if (incidence &gt; 0 &amp;&amp; RayMarching(sampledPosition + normal * .1, lightDirection, sampledPosition, normal) == HIT_SUN) color = color + attenuation * Vec(500, 400, 100) * incidence; } if (hitType == HIT_SUN) { // color = color + attenuation * Vec(50, 80, 100); break; // Sun Color } } return color; }</span></span></code> </pre> <br>  Eu experimentei um pouco com essa fun√ß√£o para alterar o n√∫mero m√°ximo de reflex√µes de feixe permitidas.  O valor "2" confere √†s letras uma cor Vantablack lacada surpreendentemente bela <sup>[4]</sup> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/940/a3e/d10940a3ed7efab3271097904ce50d77.png"></div><br>  <i>1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0c/8b2/c3b/e0c8b2c3b249057b1f5fd0d166e12014.png"></div><br>  <i>2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"></div><br>  <i>3</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/2f5/716/65c2f5716578caaa2fcc454a49376578.png"></div><br>  <i>4</i> <br><br><h2>  C√≥digo fonte completamente limpo </h2><br><hr><br>  Para juntar tudo, criei um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo fonte</a> completamente limpo. <br><br><h2>  Refer√™ncias </h2><br><hr><br>  [1] Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lexfrench post no Twitter em 8 de outubro de 2018.</a> <br><br>  [2] Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wikipedia: formato de imagem NetPBM</a> <br><br>  [3] Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">visualiza√ß√£o realizada no mais poderoso MacBook Pro, 2017</a> <br><br>  [4] Fonte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wikipedia: Vantablack</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434528/">https://habr.com/ru/post/pt434528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434514/index.html">DPAPI "Segredos" ou DPAPI para Pentesters</a></li>
<li><a href="../pt434516/index.html">Uma maneira f√°cil de lidar com suas aspira√ß√µes de carreira.</a></li>
<li><a href="../pt434518/index.html">Aplausos e aplausos: drama cuidadosamente controlado nas lojas da Apple</a></li>
<li><a href="../pt434522/index.html">Padr√µes de justifica√ß√£o de tarefas e antipadr√µes</a></li>
<li><a href="../pt434524/index.html">Kubernetes Ingress atrav√©s dos olhos de um iniciante</a></li>
<li><a href="../pt434530/index.html">Calend√°rio padr√£o, corre√ß√µes no LDAP e outras inova√ß√µes no Zimbra 8.8.11</a></li>
<li><a href="../pt434532/index.html">A hist√≥ria de um projeto: quando uma equipe n√£o tem um desenvolvedor s√™nior</a></li>
<li><a href="../pt434534/index.html">ONYX BOOX ‚ÄúMeu Primeiro Livro‚Äù: leitura inofensiva para m√£e e beb√™</a></li>
<li><a href="../pt434538/index.html">A luta pelo espa√ßo: o que est√° acontecendo no mercado da Internet via sat√©lite</a></li>
<li><a href="../pt434540/index.html">O que fazer com pessoas que ser√£o substitu√≠das por rob√¥s?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>