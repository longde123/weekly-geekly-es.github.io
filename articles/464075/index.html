<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïë üåÅ üç≠ Introducci√≥n a C. Mensaje del siglo pasado üë©‚Äç‚úàÔ∏è üßíüèª üßö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√≥logo 
 En mis comentarios, me refer√≠ varias veces al libro Dise√±o e implementaci√≥n de sistemas operativos, su primera edici√≥n, de Andrew Tanenbaum ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducci√≥n a C. Mensaje del siglo pasado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464075/"><h3>  Pr√≥logo </h3><br>  En mis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comentarios, me</a> refer√≠ varias veces al libro Dise√±o e implementaci√≥n de sistemas operativos, su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera edici√≥n, de</a> Andrew Tanenbaum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> y c√≥mo se representa a C en √©l.  Y estos comentarios siempre han sido de inter√©s.  Decid√≠ que era hora de publicar una traducci√≥n de esta introducci√≥n a C.  Sigue siendo relevante.  Aunque ciertamente hay quienes no han escuchado sobre el lenguaje de programaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PL / 1</a> , y tal vez incluso sobre el sistema operativo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Minix</a> . <br><br>  Esta descripci√≥n tambi√©n es interesante desde un punto de vista hist√≥rico y para comprender hasta d√≥nde ha llegado el lenguaje C desde su nacimiento y la industria de TI en general. <br><a name="habracut"></a><br>  Quiero hacer una reserva de inmediato de que mi segundo idioma es el franc√©s: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/467/5a3/9614675a3883bf417fa2505dada57690.png" alt="imagen"><br><br>  Pero esto se compensa con 46 a√±os de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">experiencia en programaci√≥n</a> . <br>  Entonces, comencemos, es el turno de Andrew Tanenbaum. <br><br><h3>  Introducci√≥n al lenguaje C (p√°gs. 350 - 362) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cx/s5/il/cxs5ilctyz8rybmfwoqyjahv5ty.png"></div><br><br>  El lenguaje de programaci√≥n C fue creado por Dennis Ritchie de AT&amp;T Bell Laboratories como un lenguaje de programaci√≥n de alto nivel para desarrollar el sistema operativo UNIX.  Actualmente, el lenguaje es ampliamente utilizado en varios campos.  C es especialmente popular entre los programadores de sistemas porque le permite escribir programas de manera simple y concisa. <br><br>  El libro principal que describe el lenguaje C es el libro del lenguaje de programaci√≥n C (1978) de Brian Kernigan y Dennis Ritchie.  Los libros sobre el lenguaje C fueron escritos por Bolon (1986), Gehani (1984), Hancock y Krieger (1986), Harbison y Steele (1984) y muchos otros. <br><br>  En esta aplicaci√≥n, intentaremos dar una introducci√≥n bastante completa a C, para que aquellos que est√©n familiarizados con lenguajes de alto nivel como Pascal, PL / 1 o Modula 2 puedan comprender la mayor parte del c√≥digo MINIX que se proporciona en este libro.  Las caracter√≠sticas de C que no se usan en MINIX no se analizan aqu√≠.  Numerosos puntos sutiles omitidos.  El √©nfasis est√° en leer programas en C, en lugar de escribir c√≥digo. <br><br><h3>  A.1  Conceptos b√°sicos de lenguaje C </h3><br>  Un programa en C consiste en un conjunto de procedimientos (a menudo llamados funciones, incluso si no devuelven valores).  Estos procedimientos contienen declaraciones, operadores y otros elementos que juntos le dicen a la computadora qu√© hacer.  La Figura A-1 muestra un peque√±o procedimiento en el que se declaran tres valores enteros y se les asignan valores.  El nombre del procedimiento es principal.  El procedimiento no tiene par√°metros formales, como lo indica la ausencia de identificadores entre los corchetes detr√°s del nombre del procedimiento.  El cuerpo del procedimiento est√° encerrado entre llaves ({}).  Este ejemplo muestra que C tiene variables y que estas variables deben declararse antes de su uso.  C tambi√©n tiene operadores, en este ejemplo, estos son operadores de asignaci√≥n.  Todas las declaraciones deben terminar con un punto y coma (a diferencia de Pascal, que usa dos puntos entre las declaraciones, no despu√©s de ellas). <br><br>  Los comentarios comienzan con los caracteres "/ *" y terminan con los caracteres "* /" y pueden abarcar varias l√≠neas. <br><br><pre><code class="cpp hljs">main () <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k; <span class="hljs-comment"><span class="hljs-comment">/*  3   */</span></span> i = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  i  10 ( ) */</span></span> j = i + <span class="hljs-number"><span class="hljs-number">015</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  j  i + 015 ( ) */</span></span> k = j * j + <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  k  j * j + 0xFF ( ) */</span></span> } . Al.    .</code> </pre> <br>  El procedimiento contiene tres constantes.  Constante 10 en la primera tarea <br>  Es una constante decimal ordinaria.  La constante 015 es una constante octal <br>  (igual a 13 en decimal).  Las constantes octales siempre comienzan en cero.  La constante 0xFF es una constante hexadecimal (igual a 255 decimales).  Las constantes hexadecimales siempre comienzan con 0x.  Los tres tipos se usan en C. <br><br><h3>  A.2  Tipos de datos b√°sicos </h3><br>  C tiene dos tipos principales de datos (variables): un entero y un car√°cter, declarados como int y char, respectivamente.  No hay una variable booleana separada.  La variable int se usa como una variable booleana.  Si esta variable contiene 0, significa falso / falso, y cualquier otro valor significa verdadero / verdadero.  C tambi√©n tiene tipos de coma flotante, pero MINIX no los usa. <br><br>  Puede aplicar "adjetivos" cortos, largos o sin signo a un tipo int que define un rango de valores (rango dependiente del compilador).  La mayor√≠a de los procesadores 8088 usan enteros de 16 bits para int y short int y enteros de 32 bits para int largo.  Los enteros sin signo (unsigned int) en el procesador 8088 tienen un rango de 0 a 65535, y no de -32768 a +32767, como es el caso de los enteros ordinarios (int).  Un personaje toma 8 bits. <br><br>  El especificador de registro tambi√©n est√° permitido tanto para int como para char, y es una pista para el compilador de que la variable declarada debe colocarse en el registro para que el programa funcione m√°s r√°pido. <br><br>  Algunos anuncios se muestran en la fig.  A - 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z1, z2; / *    */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag_poll; <span class="hljs-comment"><span class="hljs-comment">/* 'int'    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> . <span class="hljs-number"><span class="hljs-number">-2.</span></span>  .</code> </pre> <br>  Se permite la conversi√≥n entre tipos.  Por ejemplo, el operador <br><br><pre> <code class="cpp hljs">flag_pole = i;</code> </pre> <br>  permitido incluso si i es de tipo int y flag_pole es largo.  En muchos casos <br>  es necesario o √∫til forzar conversiones entre tipos de datos.  Para la conversi√≥n forzada, es suficiente poner el tipo de destino entre par√©ntesis delante de la expresi√≥n para la conversi√≥n.  Por ejemplo: <br><br><pre> <code class="cpp hljs"> ( (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) i);</code> </pre> <br>  instruye a convertir el entero i a largo antes de pasarlo como par√°metro al procedimiento p, que espera el par√°metro largo. <br><br>  Al convertir entre tipos, preste atenci√≥n al signo. <br>  Al convertir un car√°cter en un n√∫mero entero, algunos compiladores tratan los caracteres como si estuvieran firmados, es decir, de - 128 a +127, mientras que otros los tratan como <br>  sin signo, es decir, de 0 a 255. En MINIX, expresiones como <br><br><pre> <code class="cpp hljs">i = c &amp; <span class="hljs-number"><span class="hljs-number">0377</span></span>;</code> </pre> <br>  que convierte de (car√°cter) a un entero y luego realiza un AND l√≥gico <br>  (ampersand) con la constante octal 0377. El resultado es que los 8 bits altos <br>  se establecen en cero, lo que obliga a c a considerarse como un n√∫mero sin signo de 8 bits, en el rango de 0 a 255. <br><br><h3>  A.3  Tipos compuestos y punteros </h3><br>  En esta secci√≥n, veremos cuatro formas de construir tipos de datos m√°s complejos: matrices, estructuras, uniones y punteros.  Una matriz es una colecci√≥n / conjunto de elementos del mismo tipo.  Todas las matrices en C comienzan con el elemento 0. <br><br>  Anuncio <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a [<span class="hljs-number"><span class="hljs-number">10</span></span>];</code> </pre> <br>  declara que una matriz a con 10 enteros se almacenar√° en los elementos de la matriz desde [0] a a [9].  En segundo lugar, las matrices pueden tener tres o m√°s dimensiones, pero no se usan en MINIX. <br>  Una estructura es una colecci√≥n de variables, generalmente de varios tipos.  La estructura en C es similar al registro en Pascal.  Operador <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} s;</code> </pre> <br>  declara s como una estructura que contiene dos miembros, el entero i y el car√°cter c. <br><br>  Para asignar el miembro i de la estructura s a 6, escriba la siguiente expresi√≥n: <br><br><pre> <code class="cpp hljs">si = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  donde el operador de punto indica que el elemento i pertenece a la estructura s. <br>  Un sindicato es tambi√©n un conjunto de miembros, similar a una estructura, excepto que en cualquier momento solo uno de ellos puede estar en un sindicato.  Anuncio <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} u;</code> </pre> <br>  significa que puede tener un n√∫mero entero o car√°cter, pero no ambos.  El compilador debe asignar suficiente espacio para combinar de modo que pueda acomodar el elemento de combinaci√≥n m√°s grande (desde el punto de vista de la memoria ocupada).  Las uniones se usan solo en dos lugares en MINIX (para definir un mensaje como una uni√≥n de varias estructuras diferentes, y para definir un bloque de disco como una uni√≥n de un bloque de datos, bloque de nodo i, bloque de cat√°logo, etc.). <br><br>  Los punteros se utilizan para almacenar direcciones de m√°quinas en C.  Se usan muy, muy a menudo.  Se utiliza un asterisco (*) para indicar un puntero en los anuncios.  Anuncio <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, *pi, a [<span class="hljs-number"><span class="hljs-number">10</span></span>], *b[<span class="hljs-number"><span class="hljs-number">10</span></span>], **ppi;</code> </pre> <br>  declara un entero i, un puntero a un entero pi, una matriz a de 10 elementos, una matriz b de 10 punteros a enteros y un puntero a un puntero ppi a un entero. <br><br>  Las reglas de sintaxis exactas para declaraciones complejas que combinan matrices, punteros y otros tipos son algo complejas.  Afortunadamente, MINIX usa solo declaraciones simples. <br><br>  La Figura A-3 muestra la declaraci√≥n de una matriz z de estructuras de tabla de estructura, cada una de las cuales tiene <br>  tres miembros, entero i, puntero cp al caracter y caracter c. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; / *  */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, c; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } z [<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    20  */</span></span> .  - <span class="hljs-number"><span class="hljs-number">3.</span></span>  .</code> </pre> <br>  Las matrices de estructuras son comunes en MINIX.  Adem√°s, la tabla de nombres se puede declarar como una estructura de tabla de estructura que se puede utilizar en declaraciones posteriores.  Por ejemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  declara p un puntero a una estructura de tabla de estructura y sugiere guardarlo <br>  en el registro  Durante la ejecuci√≥n del programa, p puede indicar, por ejemplo, z [4] o <br>  a cualquier otro elemento en z, los 20 elementos de los cuales son estructuras de tipo struct table. <br><br>  Para hacer de p un puntero a z [4], solo escriba <br><br><pre> <code class="cpp hljs">p = &amp;z[<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br>  donde el comercial como operador unario (mon√°dico) significa "tomar la direcci√≥n de lo que sigue".  Copie el valor del miembro i a la variable entera n <br>  La estructura se√±alada por p se puede hacer de la siguiente manera: <br><br><pre> <code class="cpp hljs">n = p-&gt;i;</code> </pre> <br>  Tenga en cuenta que la flecha se utiliza para acceder a un miembro de la estructura a trav√©s de un puntero.  Si usamos la variable z, entonces debemos usar el operador de punto: <br><br><pre> <code class="cpp hljs">n = z [<span class="hljs-number"><span class="hljs-number">4</span></span>] .i;</code> </pre> <br>  La diferencia es que z [4] es una estructura, y el operador de punto selecciona los elementos <br>  de tipos compuestos (estructuras, matrices) directamente.  Usando punteros, no seleccionamos un participante directamente.  El puntero indica que primero seleccione una estructura y solo luego seleccione un miembro de esta estructura. <br><br>  A veces es conveniente dar un nombre a un tipo compuesto.  Por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unshort;</code> </pre> <br>  define unshort como short sin signo (entero corto sin signo).  Ahora se puede usar unshort en el programa como tipo principal.  Por ejemplo <br><br><pre> <code class="cpp hljs">unshort ul, *u2, u3[<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  declara un entero corto sin signo, un puntero a un entero corto sin signo y <br>  una matriz de enteros cortos sin signo. <br><br><h3>  A.4.  Operadores </h3><br>  Los procedimientos en C contienen declaraciones y declaraciones.  Ya hemos visto las declaraciones, por lo que ahora consideraremos los operadores.  El prop√≥sito de los operadores condicionales y de bucle es esencialmente el mismo que en otros idiomas.  La Figura A - 4 muestra varios ejemplos de ellos.  Lo √∫nico a lo que vale la pena prestar atenci√≥n es que las llaves se usan para agrupar operadores, y la instrucci√≥n while tiene dos formas, la segunda de las cuales es similar a la declaraci√≥n de repetici√≥n de Pascal. <br><br>  C tambi√©n tiene una declaraci√≥n for, pero no parece una declaraci√≥n for en ning√∫n otro lenguaje.  La declaraci√≥n for tiene la siguiente forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (&lt;&gt;; &lt;&gt;; &lt;&gt;) ;</code> </pre> <br>  Lo mismo se puede expresar a trav√©s de la declaraci√≥n while: <br><br><pre> <code class="cpp hljs">&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(&lt;&gt;) { &lt;&gt;; &lt;&gt; }</code> </pre> <br>  Como ejemplo, considere la siguiente declaraci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;n; i = i+l) a[i]=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Este operador establece los primeros n elementos de la matriz a en cero.  La ejecuci√≥n del operador comienza estableciendo i en cero (esto se realiza fuera del bucle).  Luego, el operador se repite hasta i &lt;n, mientras realiza la asignaci√≥n y el aumento de i.  Por supuesto, en lugar del operador de asignar un valor al elemento actual de una matriz cero, puede haber un operador compuesto (bloque) encerrado entre llaves. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) k = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; y) { <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j + l, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x + <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;y) { <span class="hljs-comment"><span class="hljs-comment">/*  if-else */</span></span> j = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  while */</span></span> k = k + k; n = n - l; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { / *    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> */ k = k + k; n = n - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); . A<span class="hljs-number"><span class="hljs-number">-4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>  C.</code> </pre> <br>  C tambi√©n tiene un operador similar al operador de caso en Pascal.  Esta es una declaraci√≥n de cambio.  Un ejemplo se muestra en la Figura A-5.  Dependiendo del valor de la expresi√≥n especificada en el interruptor, se selecciona una u otra declaraci√≥n de caso. <br><br>  Si la expresi√≥n no coincide con ninguna de las declaraciones de caso, se selecciona la declaraci√≥n predeterminada. <br><br>  Si la expresi√≥n no est√° asociada con ninguna declaraci√≥n de caso y la declaraci√≥n predeterminada est√° ausente, la ejecuci√≥n contin√∫a desde la siguiente declaraci√≥n despu√©s de la declaraci√≥n de cambio. <br><br>  Cabe se√±alar que para salir del bloque de casos, use la instrucci√≥n break.  Si no hay una declaraci√≥n de interrupci√≥n, se ejecutar√° el siguiente bloque de casos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (k) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: i = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   case 20, ..    switch */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>: i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; / *   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>* / <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: j = <span class="hljs-number"><span class="hljs-number">5</span></span>; } . A<span class="hljs-number"><span class="hljs-number">-5.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span></code> </pre> <br>  La instrucci√≥n break tambi√©n act√∫a dentro de los bucles for y while.  Debe recordarse que si la declaraci√≥n de ruptura est√° dentro de una serie de bucles anidados, la salida est√° solo un nivel arriba. <br><br>  Una declaraci√≥n relacionada es la declaraci√≥n de continuaci√≥n, que no sale del bucle, <br>  pero provoca la finalizaci√≥n de la iteraci√≥n actual y el comienzo de la siguiente iteraci√≥n <br>  inmediatamente  Esto es esencialmente un retorno a la parte superior del bucle. <br><br>  C tiene procedimientos que pueden llamarse con o sin par√°metros. <br>  Seg√∫n Kernigan y Ritchie (p. 121), no est√° permitido transferir matrices, <br>  estructuras o procedimientos como par√°metros, aunque pasando punteros a todo esto <br>  permitido.  ¬øHay un libro o no? (Aparecer√° en mi memoria: - ‚ÄúSi hay vida en Marte, si no hay vida en Marte‚Äù), muchos compiladores de C permiten estructuras como par√°metros. <br>  El nombre de la matriz, si est√° escrito sin un √≠ndice, significa un puntero a una matriz, lo que simplifica la transferencia de un puntero de matriz.  Por lo tanto, si a es el nombre de una matriz de cualquier tipo, se puede pasar a g escribiendo <br><br><pre> <code class="cpp hljs">g();</code> </pre> <br>  Esta regla se aplica solo a las matrices; esta regla no se aplica a las estructuras. <br>  Los procedimientos pueden devolver valores ejecutando una declaraci√≥n de devoluci√≥n.  Esta declaraci√≥n puede contener una expresi√≥n, cuyo resultado se devolver√° como el valor del procedimiento, pero la persona que llama puede ignorar con seguridad el valor devuelto.  Si el procedimiento devuelve un valor, el valor de tipo se escribe antes del nombre del procedimiento, como se muestra en la Fig.  A-6.  Al igual que los par√°metros, los procedimientos no pueden devolver matrices, estructuras o procedimientos, pero pueden devolverles punteros.  Esta regla est√° dise√±ada para una implementaci√≥n m√°s eficiente: todos los par√°metros y resultados siempre corresponden a una palabra de m√°quina (en la que se almacena la direcci√≥n).  Los compiladores que permiten el uso de estructuras como par√°metros generalmente tambi√©n permiten su uso como valores de retorno. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i, j </span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i + j); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } . <span class="hljs-number"><span class="hljs-number">-6.</span></span>   ,   .</code> </pre> <br>  C no tiene E / S incorporadas.  La entrada / salida se implementa llamando a funciones de biblioteca, las m√°s comunes se ilustran a continuaci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (¬´x=% dy = %oz = %x \n¬ª, x, y, z);</code> </pre> <br>  El primer par√°metro es la cadena de caracteres entre comillas (de hecho, esta es una matriz de caracteres). <br><br>  Cualquier car√°cter que no sea un porcentaje simplemente se imprime tal cual. <br><br>  Cuando se produce un porcentaje, el siguiente par√°metro se imprime en la forma definida por la letra que sigue al porcentaje: <br><blockquote>  d - imprimir como un entero decimal <br>  o - imprimir como un entero octal <br>  u - imprime como un entero decimal sin signo <br>  x - imprimir como un entero hexadecimal <br>  s - imprimir como una cadena de caracteres <br>  c - imprimir como un personaje </blockquote>  Las letras D, 0 y X tambi√©n est√°n permitidas para la impresi√≥n decimal, octal y hexadecimal de n√∫meros largos. <br><br><h3>  A.5.  Expresiones </h3><br>  Las expresiones se crean combinando operandos y operadores. <br><br>  Operadores aritm√©ticos como + y - y operadores relacionales como &lt; <br>  y&gt; similar a sus contrapartes en otros idiomas.  % Operador <br>  m√≥dulo usado.  Vale la pena se√±alar que el operador de igualdad es ==, ¬°y el operador de desigualdad es!  =.  Para verificar si ayb son iguales, puede escribir as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;&gt;;</code> </pre> <br>  C tambi√©n le permite combinar el operador de asignaci√≥n con otros operadores, por lo tanto <br><br><pre> <code class="cpp hljs">a += <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  equivalente a la grabaci√≥n <br><br><pre> <code class="cpp hljs"> =  + <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Otros operadores tambi√©n se pueden combinar de esta manera. <br><br>  C tiene operadores para manipular bits de una palabra.  Se permiten tanto los cambios como las operaciones l√≥gicas bit a bit.  Los operadores de desplazamiento izquierdo y derecho son &lt;&lt; <br>  y &gt;&gt; respectivamente.  Operadores l√≥gicos a nivel de bit y, |  y ^, que son l√≥gicos AND (AND), incluidos OR (OR) y OR exclusivo (XOP), respectivamente.  Si tengo el valor 035 (octal), entonces la expresi√≥n i &amp; 06 tiene el valor 04 (octal).  Otro ejemplo, si i = 7, entonces <br><br><pre> <code class="cpp hljs">j = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) | <span class="hljs-number"><span class="hljs-number">014</span></span>;</code> </pre> <br>  y obtener 074 para j. <br>  Otro grupo importante de operadores son los operadores unarios, cada uno de los cuales acepta solo un operando.  Como operador unario, ampersand &amp; obtiene la direcci√≥n de una variable. <br><br>  Si p es un puntero a un n√∫mero entero e i es un n√∫mero entero, el operador <br><br><pre> <code class="cpp hljs">p = &amp;i;</code> </pre> <br>  calcula la direcci√≥n i y la almacena en la variable p. <br>  Lo contrario de tomar una direcci√≥n es un operador que toma un puntero como entrada y calcula el valor en esa direcci√≥n.  Si acabamos de asignar la direcci√≥n i al puntero p, entonces * p tiene el mismo significado que i. <br><br>  En otras palabras, como operador unario, un asterisco es seguido por un puntero (o <br>  expresi√≥n que da un puntero) y devuelve el valor del elemento al que apunta.  Si tengo un valor de 6, entonces el operador <br><br><pre> <code class="cpp hljs">j = *;</code> </pre> <br>  asignar√° j el n√∫mero 6. <br>  El operador!  (el signo de exclamaci√≥n es el operador de negaci√≥n) devuelve 0 si su operando es distinto de cero y 1 si su operador es 0. <br><br>  Se utiliza principalmente en sentencias if, por ejemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x) k=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  comprueba el valor de x.  Si x es cero (falso), a k se le asigna el valor 0. En realidad, ¬°el operador!  cancela la condici√≥n que le sigue, al igual que el operador no en Pascal. <br><br>  El operador ~ es un operador de complemento bit a bit.  Cada 0 en su operando <br>  se convierte en 1 y cada 1 se convierte en 0. <br><br>  El operador sizeof informa el tama√±o de su operando en bytes.  En relaci√≥n a <br>  una matriz de 20 enteros a en una computadora con enteros de 2 bytes, por ejemplo, sizeof a tendr√° un valor de 40. <br><br>  El √∫ltimo grupo de operadores son los operadores de aumento y disminuci√≥n. <br><br>  Operador <br><br><pre> <code class="cpp hljs">++;</code> </pre> <br>  significa un aumento en p.  Cu√°nto aumentar√° p depende de su tipo. <br>  Los enteros o caracteres aumentan en 1, pero los punteros aumentan en <br>  el tama√±o del objeto se√±alado de esta manera, si a es una matriz de estructuras yp es un puntero a una de estas estructuras, y escribimos <br><br><pre> <code class="cpp hljs">p = &amp;a[<span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br>  para hacer que p apunte a una de las estructuras en la matriz, luego de aumentar p <br>  apuntar√° a un [4] sin importar cu√°n grandes sean las estructuras.  Operador <br><br><pre> <code class="cpp hljs">p--;</code> </pre> <br>  similar al operador p ++, excepto que disminuye en lugar de aumentar el valor del operando. <br><br>  En la declaraci√≥n <br><br><pre> <code class="cpp hljs">n = k++;</code> </pre> <br>  donde ambas variables son enteros, el valor original de k se asigna a ny <br>  solo entonces k aumenta.  En la declaraci√≥n <br><br><pre> <code class="cpp hljs">n = ++ k;</code> </pre> <br>  k aumenta primero, luego su nuevo valor se almacena en n. <br><br>  Por lo tanto, un operador ++ (o -) se puede escribir antes o despu√©s de su operando, lo que resulta en varios valores. <br><br>  La √∫ltima declaraci√≥n es esta?  (signo de interrogaci√≥n) que selecciona una de dos alternativas <br>  separados por dos puntos.  Por ejemplo, un operador, <br><br><pre> <code class="cpp hljs">i = (x &lt; y ? <span class="hljs-number"><span class="hljs-number">6</span></span> : k + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  compara x con y.  Si x es menor que y, entonces obtengo el valor 6;  de lo contrario, la variable i obtiene el valor k + 1. Los corchetes son opcionales. <br><br><h3>  A.6.  Estructura del programa </h3><br>  Un programa en C consta de uno o m√°s archivos que contienen procedimientos y declaraciones. <br>  Estos archivos se pueden compilar individualmente en archivos de objetos, que luego se vinculan entre s√≠ (utilizando el vinculador) para formar un programa ejecutable. <br>  A diferencia de Pascal, las declaraciones de procedimientos no pueden anidarse, por lo tanto, todas est√°n escritas en el "nivel superior" en el archivo del programa. <br><br>  Se permite declarar variables fuera de los procedimientos, por ejemplo, al comienzo del archivo antes de la primera declaraci√≥n del procedimiento.  Estas variables son globales y pueden usarse en cualquier procedimiento en todo el programa, a menos que la palabra clave est√°tica preceda a la declaraci√≥n.  En este caso, estas variables no se pueden usar en otro archivo.  Las mismas reglas se aplican a los procedimientos.  Las variables declaradas dentro de un procedimiento son locales al procedimiento. <br>  El procedimiento puede acceder a la variable entera v declarada en otro archivo (siempre que la variable no sea est√°tica), declar√°ndola externa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v;</code> </pre> <br>  Cada variable global debe declararse exactamente una vez sin el atributo extern para poder asignarle memoria. <br><br>  Las variables se pueden inicializar cuando se declaran: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  Las matrices y estructuras tambi√©n se pueden inicializar.  Las variables globales que no se inicializan expl√≠citamente reciben un valor predeterminado de cero. <br><br><h3>  A.7.  Preprocesador C </h3><br>  Antes de que el archivo fuente se transfiera al compilador de C, se procesa autom√°ticamente <br>  Un programa llamado preprocesador.  Es la salida del preprocesador, no <br>  El programa original se alimenta a la entrada del compilador.  El preprocesador realiza <br>  Tres conversiones b√°sicas en un archivo antes de pasarlo al compilador: <br><br>  1. Inclusi√≥n de archivos. <br>  2. Definici√≥n y reemplazo de macros. <br>  3. Compilaci√≥n condicional. <br><br>  Todas las directivas de preprocesador comienzan con un signo de n√∫mero (#) en la primera columna. <br>  Cuando una directiva de vista <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"prog.h"</span></span></span></span></code> </pre> <br>  cumplido por el preprocesador, incluye el archivo prog.h, l√≠nea por l√≠nea, en <br>  El programa que se pasar√° al compilador.  Cuando la directiva #include se escribe como <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;prog.h&gt;</span></span></span></span></code> </pre> <br>  entonces el archivo incluido se busca en el directorio / usr / include en lugar del directorio de trabajo.  Es una pr√°ctica com√∫n en C agrupar las declaraciones utilizadas por varios archivos en un archivo de encabezado (generalmente con el sufijo .h) e incluirlos cuando sea necesario. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El preprocesador tambi√©n permite definiciones de macro. </font></font> Por ejemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BLOCK_SIZE 1024</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define la macro BLOCK_SIZE y le asigna un valor de 1024. A partir de ahora, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada aparici√≥n de una cadena de 10 caracteres "BLOCK_SIZE" en el archivo ser√° </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reemplazada por una cadena de 4 caracteres "1024" antes de que el compilador vea el archivo con el programa. </font><font style="vertical-align: inherit;">Por convenci√≥n, los nombres de macro se escriben en may√∫sculas. </font><font style="vertical-align: inherit;">Las macros pueden tener par√°metros, pero en la pr√°ctica pocas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tercera caracter√≠stica del preprocesador es la compilaci√≥n condicional. </font><font style="vertical-align: inherit;">MINIX tiene varios </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugares donde el c√≥digo est√° escrito espec√≠ficamente para el procesador 8088, y este c√≥digo no debe incluirse al compilar para otro procesador. </font><font style="vertical-align: inherit;">Estas secciones se ven as√≠:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> i8088 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;   8088&gt; #endif</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si se define el car√°cter i8088, las declaraciones entre las dos directivas de preprocesador #ifdef i8088 y #endif se incluyen en la salida del preprocesador; </font><font style="vertical-align: inherit;">de lo contrario, se omiten. </font><font style="vertical-align: inherit;">Llamar al compilador con el comando</font></font><br><br><pre> <code class="cpp hljs">cc -c -Di8088 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o al incluir una declaraci√≥n en el programa </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> i8088</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definimos el s√≠mbolo i8088, por lo que se incluir√° todo el c√≥digo dependiente para 8088. </font><font style="vertical-align: inherit;">A medida que se desarrolla MINIX, puede adquirir un c√≥digo especial para 68000 y otros procesadores que tambi√©n se procesar√°n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ejemplo de c√≥mo funciona el preprocesador, considere el programa Fig. </font><font style="vertical-align: inherit;">A-7 (a). </font><font style="vertical-align: inherit;">Incluye un archivo prog.h, cuyo contenido es el siguiente:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXAELEMENTS 100</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Imagine que el compilador fue llamado por un comando </font></font><br><br><pre> <code class="bash hljs">cc -E -Di8088 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de que el archivo haya pasado por el preprocesador, la salida ser√° como se muestra en la Fig. </font><font style="vertical-align: inherit;">A-7 (b). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es esta salida, y no el archivo fuente, la que se proporciona como entrada al compilador de C.</font></font><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include prog.h int x; main () main (); { { int a[MAX_ELEMENTS]; int a [100];  = 4;  = 4; a[x] = 6; [] = 6; #ifdef i8088 printf("8088. a[x]:% d\n", a[x]); printf ("8088. a[x]:% d\n", a[x]); #endif } #ifdef m68000 printf ("68000. x=%d\n", x); #endif } () (b) . -7. (a)   prog.c. (b)  .</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que el preprocesador hizo su trabajo y elimin√≥ todas las l√≠neas que comienzan con el signo #. </font><font style="vertical-align: inherit;">Si el compilador se llamara as√≠</font></font><br><br><pre> <code class="bash hljs">cc -c -Dm68000 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entonces se incluir√≠a otra impresi√≥n. </font><font style="vertical-align: inherit;">Si se llamara as√≠:</font></font><br><br><pre> <code class="bash hljs">cc -c prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entonces no se incluir√≠a ninguna impresi√≥n. </font><font style="vertical-align: inherit;">(El lector puede reflexionar sobre lo que suceder√≠a si se llamara al compilador con ambos indicadores -D-flags).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A.8. </font><font style="vertical-align: inherit;">Modismos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta secci√≥n, veremos varias construcciones que son t√≠picas para C pero no comunes en otros lenguajes de programaci√≥n. </font><font style="vertical-align: inherit;">Primero, considere el ciclo:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n--) *p++ = *q++;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las variables p y q suelen ser punteros de caracteres, yn es un contador. </font><font style="vertical-align: inherit;">El bucle copia la cadena de n caracteres desde donde q apunta a donde p apunta. </font><font style="vertical-align: inherit;">En cada iteraci√≥n del ciclo, el contador disminuye hasta llegar a 0, y cada uno de los punteros aumenta, por lo que apuntan secuencialmente a las celdas de memoria con un n√∫mero mayor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro dise√±o com√∫n:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) a[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que establece los primeros N elementos de a en 0. Una forma alternativa de escribir este ciclo es la siguiente: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; p &lt; &amp;a[N]; p++) *p = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta declaraci√≥n, el puntero entero p se inicializa para apuntar al elemento cero de la matriz. </font><font style="vertical-align: inherit;">El ciclo contin√∫a hasta que p alcanza la direcci√≥n del en√©simo elemento de la matriz. </font><font style="vertical-align: inherit;">Una construcci√≥n de puntero es mucho m√°s eficiente que una construcci√≥n de matriz y, por lo tanto, generalmente se usa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los operadores de asignaci√≥n pueden aparecer en lugares inesperados.</font></font> Por ejemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = f (x)) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primero llama a la funci√≥n f, luego asigna el resultado de llamar a la funci√≥n a, y </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finalmente verifica si es verdadero (no cero) o falso (cero). </font><font style="vertical-align: inherit;">Si a no es igual a cero, entonces se cumple la condici√≥n.</font></font> Operador <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = b) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n, primero, el valor de la variable b de la variable a, y luego comprueba si el valor es distinto de cero. </font><font style="vertical-align: inherit;">Y este operador es completamente diferente de</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que compara dos variables y ejecuta el operador si son iguales. </font></font><br><br><h3>  Ep√≠logo </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eso es todo </font><font style="vertical-align: inherit;">No vas a creer lo mucho que disfrut√© preparando este texto. </font><font style="vertical-align: inherit;">Cu√°nto recordaba √∫til del mismo lenguaje C. </font><font style="vertical-align: inherit;">Espero que usted tambi√©n disfrute de sumergirse en el maravilloso mundo del lenguaje C.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464075/">https://habr.com/ru/post/464075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464053/index.html">Nota: Selecci√≥n de pista y algoritmo de rotaci√≥n</a></li>
<li><a href="../464055/index.html">Estudiamos los datos recopilados por Xiaomi Mi Band para el a√±o</a></li>
<li><a href="../464057/index.html">Hilbert, Lebesgue ... y el vac√≠o</a></li>
<li><a href="../464063/index.html">Cortando el cable en 2019</a></li>
<li><a href="../464071/index.html">¬øRevoluci√≥n o dolor? Informe Yandex React Hooks</a></li>
<li><a href="../464077/index.html">No, no necesita 50 km / s delta ve. Necesita tecnolog√≠as aditivas (Parte 1)</a></li>
<li><a href="../464079/index.html">C√≥mo hacer una nave espacial horizontal de despegue y aterrizaje sin tecnolog√≠a milagrosa</a></li>
<li><a href="../464083/index.html">C√≥mo ITSM ayudar√° y qui√©n aplica esta metodolog√≠a</a></li>
<li><a href="../464089/index.html">Automatizar solicitudes HTTP en el contexto de Spring</a></li>
<li><a href="../464091/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 311 (del 12 al 18 de agosto)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>