<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👥 🚕 👩🏽‍💻 Sebarkan daftar yang terhubung sendiri. Edisi cepat 🤞🏻 🤸 😘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bukan rahasia lagi bahwa salah satu hiburan favorit bagi pengembang perangkat lunak adalah mewawancarai pemberi kerja. Kita semua melakukan ini dari w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sebarkan daftar yang terhubung sendiri. Edisi cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455842/"> Bukan rahasia lagi bahwa salah satu hiburan favorit bagi pengembang perangkat lunak adalah mewawancarai pemberi kerja.  Kita semua melakukan ini dari waktu ke waktu dan untuk alasan yang sangat berbeda.  Dan yang paling jelas dari mereka - mencari pekerjaan - saya pikir, bukan yang paling umum.  Menghadiri wawancara adalah cara yang baik untuk tetap fit, mengulangi dasar-dasar yang terlupakan, dan mempelajari sesuatu yang baru.  Dan jika berhasil, tingkatkan juga rasa percaya diri.  Kami bosan, kami menetapkan sendiri status "terbuka untuk menawarkan" dalam beberapa jenis jaringan sosial "bisnis" seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"LinkedIn"</a> - dan pasukan manajer sumber daya manusia sudah menyerang kotak masuk kami untuk pesan yang masuk. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/bw/9r/mc/bw9rmcigk0k9beg-50tdq74sadw.jpeg" alt="gambar"><br><br>  Dalam prosesnya, sementara semua keributan ini terjadi, kita dihadapkan dengan banyak pertanyaan yang, seperti yang mereka katakan di sisi lain dari tirai yang runtuh secara implisit, adalah “cincin bel”, dan rinciannya tersembunyi di balik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kabut perang</a> .  Mereka paling sering dipanggil hanya dalam pengujian oleh algoritma dan struktur data (secara pribadi, saya tidak punya data sama sekali) dan sebenarnya wawancara. <br><br>  Salah satu pertanyaan paling umum dalam wawancara untuk programmer dari spesialisasi apa pun adalah daftar.  Misalnya, daftar yang ditautkan secara tunggal.  Dan algoritma dasar terkait.  Misalnya, putar balik.  Dan biasanya ini terjadi entah bagaimana seperti ini: "Bagus, tapi bagaimana Anda akan memperluas daftar yang terhubung sendiri?"  Hal utama adalah mengejutkan pelamar dengan pertanyaan ini. <br><br>  Sebenarnya, semua ini mendorong saya untuk menulis ulasan singkat ini untuk pengingat dan peneguhan yang konstan.  Jadi, bercanda, lihat! <br><br><h2>  Daftar tertaut tunggal </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar tertaut</a> adalah salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">struktur data</a> dasar.  Setiap elemen (atau node) terdiri dari, pada kenyataannya, data yang tersimpan dan tautan ke elemen tetangga.  Daftar tertaut tunggal hanya menyimpan tautan ke elemen berikutnya dalam struktur, dan daftar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tertaut dua kali</a> menyimpan tautan ke berikutnya dan sebelumnya.  Organisasi data semacam itu memungkinkan mereka untuk ditempatkan di area memori apa pun (tidak seperti, misalnya, sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">array</a> , semua elemen yang harusnya ditempatkan di memori satu demi satu). <br><br>  Ada banyak lagi yang bisa dikatakan tentang daftar, tentu saja: mereka bisa melingkar (mis., Elemen terakhir menyimpan tautan ke yang pertama) atau tidak (mis. Tidak ada tautan ke elemen terakhir).  Daftar dapat diketik, mis.  mengandung data dengan tipe yang sama atau tidak.  Dan seterusnya dan seterusnya. <br><br>  Lebih baik coba menulis beberapa kode.  Sebagai contoh, entah bagaimana Anda bisa membayangkan daftar simpul: <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payload: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(payload: <span class="hljs-type"><span class="hljs-type">T</span></span>, nextNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payload = payload <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.nextNode = nextNode } }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Generik" adalah</a> jenis yang mampu menyimpan muatan jenis apa pun di bidang <code>payload</code> . <br><br>  Daftar itu sendiri diidentifikasi secara mendalam oleh simpul pertama: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(firstNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.firstNode = firstNode } }</code> </pre><br>  Node pertama dinyatakan opsional, karena daftar mungkin kosong. <br><br>  <i>Secara teori, tentu saja, di kelas Anda perlu mengimplementasikan semua metode yang diperlukan - menyisipkan, menghapus, akses ke node, dll, tetapi kami akan melakukannya lain waktu.</i>  <i>Pada saat yang sama, kami akan memeriksa apakah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>struct</code></a> (yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apple</a> secara aktif mendorong kita dengan contoh kita) adalah pilihan yang lebih baik, dan mungkin mengingat pendekatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Copy-on-write"</a> .</i> <br><br><h2>  Penyebaran daftar tautan tunggal </h2><br><h3>  Cara pertama.  Siklus </h3><br>  Sudah waktunya untuk turun ke bisnis yang kita di sini hari ini!  Dan cara paling efektif untuk menghadapinya adalah dua cara.  Yang pertama adalah loop sederhana, dari yang pertama ke yang terakhir. <br><br>  Siklus bekerja dengan tiga variabel, yang sebelum awal diberi nilai node sebelumnya, saat ini dan berikutnya.  (Pada saat ini, nilai node sebelumnya secara alami kosong.) Siklus dimulai dengan memeriksa bahwa node berikutnya tidak kosong, dan jika demikian, tubuh siklus dieksekusi.  Tidak ada keajaiban yang terjadi di loop: pada simpul saat ini, bidang yang merujuk ke elemen berikutnya diberikan tautan ke yang sebelumnya (pada iterasi pertama, nilai tautan, masing-masing, diatur ulang, yang sesuai dengan keadaan hubungan di simpul terakhir).  Baik dan selanjutnya variabel yang sesuai dengan node sebelumnya, saat ini dan selanjutnya diberi nilai baru.  Setelah keluar dari loop, node saat ini (yaitu, iterable terakhir secara umum) ditugaskan nilai tautan baru ke node berikutnya, karena  keluar dari loop terjadi tepat pada saat simpul terakhir dalam daftar menjadi arus. <br><br>  Dalam kata-kata, tentu saja, semua ini terdengar aneh dan tidak dapat dipahami, jadi lebih baik untuk melihat kode: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previousNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentNode = firstNode <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextNode = firstNode?.nextNode <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nextNode != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { currentNode?.nextNode = previousNode previousNode = currentNode currentNode = nextNode nextNode = currentNode?.nextNode } currentNode?.nextNode = previousNode firstNode = currentNode } }</code> </pre><br>  Untuk verifikasi, kami menggunakan daftar node yang payloadnya merupakan pengidentifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">integer</a> sederhana.  Buat daftar sepuluh elemen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(payload: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// T == Int let list = SinglyLinkedList(firstNode: node) var currentNode = node var nextNode: Node&lt;Int&gt; for id in 1..&lt;10 { nextNode = Node(payload: id) currentNode.nextNode = nextNode currentNode = nextNode }</span></span></code> </pre><br>  Segalanya tampak baik-baik saja, tetapi kita adalah manusia, bukan komputer, dan akan menyenangkan bagi kita untuk mendapatkan bukti visual dari kebenaran daftar yang dibuat dan algoritma yang dijelaskan di atas.  Mungkin cetakan sederhana sudah cukup.  Untuk membuat output dapat dibaca, tambahkan implementasi protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>CustomStringConvertible</code></a> node dengan pengenal integer: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstPart = <span class="hljs-string"><span class="hljs-string">""" Node \(Unmanaged.passUnretained(self).toOpaque()) has id \(payload) and """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nextNode = nextNode { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstPart + <span class="hljs-string"><span class="hljs-string">" next node \(nextNode.payload)."</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstPart + <span class="hljs-string"><span class="hljs-string">" no next node."</span></span> } } }</code> </pre><br>  ... Dan daftar yang sesuai untuk menampilkan semua node secara berurutan: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description = <span class="hljs-string"><span class="hljs-string">""" List \(Unmanaged.passUnretained(self).toOpaque()) """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { description += <span class="hljs-string"><span class="hljs-string">" has nodes:\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { description += (node!.description + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) node = node!.nextNode } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> description } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> description + <span class="hljs-string"><span class="hljs-string">" has no nodes."</span></span> } } }</code> </pre><br>  Representasi string dari tipe kami akan berisi alamat di memori dan pengenal integer.  Dengan menggunakannya, kami mengatur pencetakan daftar sepuluh simpul yang dihasilkan: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e2380 has id 0 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 6. Node 0x00006000012e8900 has id 6 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 9. Node 0x00006000012e8820 has id 9 and no next node. */</span></span></code> </pre><br>  Luaskan daftar ini dan cetak lagi: <br><br><pre> <code class="swift hljs">list.<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e8820 has id 9 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 6. Node 0x00006000012e8900 has id 6 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 0. Node 0x00006000012e2380 has id 0 and no next node. */</span></span></code> </pre><br>  Anda mungkin memperhatikan bahwa alamat dalam memori daftar dan node tidak berubah, dan node daftar dicetak dalam urutan terbalik.  Referensi ke elemen berikutnya dari simpul sekarang menunjuk ke yang sebelumnya (yaitu, misalnya, elemen berikutnya dari simpul "5" sekarang bukan "6", tetapi "4").  Dan itu berarti kita berhasil! <br><br><h3>  Cara kedua.  Rekursi </h3><br>  Cara kedua yang diketahui untuk melakukan putar balik yang sama didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rekursi</a> .  Untuk mengimplementasikannya, kita akan mendeklarasikan fungsi yang mengambil simpul pertama dari daftar, dan mengembalikan simpul pertama "baru" (yang merupakan yang terakhir sebelum). <br><br>  Parameter dan nilai pengembalian adalah opsional, karena di dalam fungsi ini dipanggil lagi dan lagi pada setiap simpul berikutnya sampai kosong (mis. Sampai akhir daftar tercapai).  Oleh karena itu, dalam tubuh fungsi, perlu untuk memeriksa apakah simpul yang disebut fungsi kosong dan apakah simpul ini memiliki yang berikut.  Jika tidak, maka fungsi mengembalikan apa yang diteruskan ke argumen. <br><br>  Sebenarnya, saya jujur ​​mencoba menggambarkan algoritma lengkap dalam kata-kata, tetapi pada akhirnya saya menghapus hampir semuanya, karena hasilnya tidak mungkin untuk dipahami.  Untuk menggambar diagram alur dan secara formal menjelaskan langkah-langkah algoritma - juga, dalam hal ini, saya pikir itu tidak masuk akal, karena akan lebih nyaman bagi Anda dan saya untuk hanya membaca dan mencoba memahami kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swift</a> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverseRecursively</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node&lt;T&gt;?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = node <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> head.nextNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> head } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reversedHead = <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(head.nextNode) head.nextNode?.nextNode = head head.nextNode = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reversedHead } firstNode = <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(firstNode) } }</code> </pre><br>  Algoritme itu sendiri "dibungkus" oleh metode dari jenis daftar aktual, untuk kenyamanan panggilan. <br><br>  Itu terlihat lebih pendek, tetapi, menurut saya, lebih sulit untuk dipahami. <br><br>  Kami menyebut metode ini pada hasil dari penyebaran sebelumnya dan mencetak hasil baru: <br><br><pre> <code class="swift hljs">list.reverseRecursively() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e2380 has id 0 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 6. Node 0x00006000012e8900 has id 6 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 9. Node 0x00006000012e8820 has id 9 and no next node. */</span></span></code> </pre><br>  Dapat dilihat dari output bahwa semua alamat dalam memori tidak berubah lagi, dan node sekarang mengikuti dalam urutan asli (yaitu, mereka "dikerahkan" lagi).  Dan itu berarti kita melakukannya dengan benar lagi! <br><br><h3>  Kesimpulan </h3><br>  Jika Anda melihat metode pembalikan dengan hati-hati (atau melakukan percobaan dengan penghitungan panggilan), Anda akan melihat bahwa loop dalam kasus pertama dan panggilan metode internal (rekursif) dalam kasus kedua terjadi satu kali kurang dari jumlah node dalam daftar (dalam kasus kami, sembilan kali).  Anda juga dapat memperhatikan apa yang terjadi di sekitar loop dalam kasus pertama - urutan penugasan yang sama - dan untuk pemanggilan metode pertama, non-rekursif, dalam kasus kedua.  Ternyata dalam kedua kasus "lingkaran" diulang tepat sepuluh kali untuk daftar sepuluh node.  Dengan demikian, kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompleksitas</a> linier untuk kedua algoritma - <i>O (n)</i> . <br><br>  Secara umum, kedua algoritma yang dijelaskan ini dianggap paling efektif untuk menyelesaikan masalah ini.  Mengenai kompleksitas komputasi, tidak mungkin menghasilkan algoritma dengan nilai yang lebih rendah: dengan satu atau lain cara, Anda perlu "mengunjungi" setiap node untuk menetapkan nilai baru ke yang disimpan di dalam tautan. <br><br>  Fitur lain yang layak disebut adalah "kompleksitas memori yang dialokasikan".  Kedua algoritma yang diusulkan membuat sejumlah variabel baru (tiga dalam kasus pertama dan satu dalam yang kedua).  Ini berarti bahwa jumlah memori yang dialokasikan tidak tergantung pada karakteristik kuantitatif dari data input dan dijelaskan oleh fungsi konstan - O (1). <br><br>  Tetapi, pada kenyataannya, dalam kasus kedua ini tidak demikian.  Bahaya rekursi adalah memori tambahan dialokasikan untuk setiap panggilan rekursif pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stack</a> .  Dalam kasus kami, kedalaman rekursi sesuai dengan jumlah data input. <br><br>  Dan akhirnya, saya memutuskan untuk bereksperimen sedikit lebih: dengan cara yang sederhana dan primitif saya mengukur waktu eksekusi absolut dari dua metode untuk jumlah data input yang berbeda.  Seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startDate = <span class="hljs-type"><span class="hljs-type">Date</span></span>().timeIntervalSince1970 <span class="hljs-comment"><span class="hljs-comment">// list.reverse() / list.reverseRecursively() let finishDate = Date().timeIntervalSince1970 let runningTime = finishDate – startDate // Seconds</span></span></code> </pre><br>  Dan inilah yang saya dapatkan (ini adalah data mentah dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Playground</a> ): <br><br><img src="https://habrastorage.org/webt/kf/at/bf/kfatbfsxar9clyyokzu6beu3ios.png" alt="gambar"><br><br>  (Sayangnya, komputer saya belum menguasai nilai yang lebih besar.) <br><br>  Apa yang bisa dilihat dari tabel?  Belum ada yang istimewa.  Meskipun sudah terlihat bahwa metode rekursif berperilaku sedikit lebih buruk dengan jumlah node yang relatif kecil, tetapi di suatu tempat antara 100 dan 1000 mulai terlihat lebih baik. <br><br>  Saya juga mencoba tes sederhana yang sama di dalam proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Xcode"</a> lengkap.  Hasilnya adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/sr/vj/0d/srvj0dqmtgtse2wfuqq6llutte4.png" alt="gambar"><br><br>  Pertama, perlu disebutkan bahwa hasilnya diperoleh setelah mengaktifkan mode optimisasi "agresif" yang ditujukan untuk kecepatan eksekusi ( <code>-Ofast</code> ), yang sebagian karena jumlahnya sangat kecil.  Menarik juga bahwa dalam kasus ini metode rekursif menunjukkan dirinya sedikit lebih baik, sebaliknya, hanya pada ukuran data input yang sangat kecil, dan sudah ada dalam daftar 100 node, metode ini hilang.  Dari 100.000, ia membuat program berakhir secara tidak normal. <br><br><h2>  Kesimpulan </h2><br>  Saya mencoba untuk membahas topik yang agak klasik dari sudut pandang bahasa pemrograman favorit saya saat ini, dan saya harap Anda penasaran untuk mengikuti perkembangannya dan juga diri saya sendiri.  Saya juga sangat senang jika Anda berhasil mempelajari sesuatu yang baru - maka saya pasti membuang-buang waktu saya di artikel ini (bukannya duduk dan menonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">acara TV</a> ). <br><br>  <i>Jika seseorang memiliki keinginan untuk melacak aktivitas sosial saya, di sini ada tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Twitter" saya</a> , di mana pertama-tama ada tautan ke pos baru saya dan sedikit lagi.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455842/">https://habr.com/ru/post/id455842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455828/index.html">Para ilmuwan telah menemukan bentuk sinkronisasi baru yang eksotis</a></li>
<li><a href="../id455830/index.html">Pandangan melalui mata pengembang .NET. Minggu # 1</a></li>
<li><a href="../id455832/index.html">Sejarah investigasi SQL tunggal</a></li>
<li><a href="../id455834/index.html">Tolok ukur untuk server Linux: 5 alat terbuka</a></li>
<li><a href="../id455840/index.html">Cara bekerja dengan beberapa kueri. Komposisi, Peredam, FP</a></li>
<li><a href="../id455844/index.html">Membuat penganalisis Roslyn menggunakan pengujian enkapsulasi sebagai contoh</a></li>
<li><a href="../id455846/index.html">Komputasi Terdistribusi di Julia</a></li>
<li><a href="../id455848/index.html">Teknik untuk menghindari perilaku tidak terdefinisi saat mengakses singleton</a></li>
<li><a href="../id455850/index.html">Kotak Alat untuk Peneliti - Edisi Ketiga: Mencari dan Bekerja dengan Sumber</a></li>
<li><a href="../id455852/index.html">Pengangkatan sinus dan implantasi simultan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>