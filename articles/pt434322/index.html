<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåñ üßõüèø ‚ôæ Precis√£o de profundidade claramente üë©üèº‚Äçüíº ‚òùüèø üòÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A precis√£o da profundidade √© um problema que qualquer programador gr√°fico enfrentar√° mais cedo ou mais tarde. Muitos artigos e trabalhos foram escrito...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Precis√£o de profundidade claramente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434322/">  A precis√£o da profundidade √© um problema que qualquer programador gr√°fico enfrentar√° mais cedo ou mais tarde.  Muitos artigos e trabalhos foram escritos sobre esse assunto.  E em diferentes jogos e mecanismos, e em diferentes plataformas, voc√™ pode ver muitos formatos e configura√ß√µes diferentes para o <b>buffer de profundidade</b> . <br><br>  A convers√£o de profundidade em uma GPU parece n√£o √≥bvia por causa de como ela interage com a proje√ß√£o em perspectiva, e o estudo das equa√ß√µes n√£o esclarece a situa√ß√£o.  Para entender como isso funciona, √© √∫til desenhar algumas figuras. <br><br><img src="https://developer.nvidia.com/sites/default/files/styles/main_image/public/akamai/gameworks/blog/Depthprecision/graph.jpg?itok=tLMbXLov" alt="imagem"><br><br>  Este artigo est√° dividido em 3 partes: <br><br><ol><li>  Vou tentar explicar a motiva√ß√£o para a transforma√ß√£o de profundidade <b>n√£o linear</b> . </li><li>  Apresentarei v√°rios gr√°ficos que ajudar√£o voc√™ a entender como a convers√£o de profundidade n√£o linear funciona em diferentes situa√ß√µes, intuitiva e visualmente. </li><li>  Uma discuss√£o das principais descobertas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apertando a precis√£o da renderiza√ß√£o em perspectiva</a> [Paul Upchurch, Mathieu Desbrun (2012)] sobre o efeito dos erros de ponto flutuante na precis√£o da profundidade. </li></ol><br><a name="habracut"></a><br><h2>  Por que 1 / z? </h2><br>  Um <b>buffer de profundidade da</b> GPU de hardware geralmente n√£o armazena uma representa√ß√£o linear da dist√¢ncia entre o objeto e a c√¢mera, ao contr√°rio do que √© ingenuamente esperado dele na primeira reuni√£o.  Em vez disso, o buffer de profundidade armazena valores inversamente proporcionais √† profundidade do espa√ßo de visualiza√ß√£o.  Quero descrever brevemente a motiva√ß√£o para essa decis√£o. <br><br>  Neste artigo, usarei <b>d</b> para representar os valores armazenados no buffer de profundidade (no intervalo [0, 1] para DirectX) e <b>z</b> para representar o espa√ßo de visualiza√ß√£o em profundidade, ou seja,  A dist√¢ncia real da c√¢mera, em unidades mundiais, por exemplo, metros.  Em geral, o relacionamento entre eles tem a seguinte forma: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math1.jpg" alt="imagem"><br><br>  onde <b>a, b</b> s√£o as constantes associadas √†s configura√ß√µes de perto e de longe dos planos.  Em outras palavras, <b>d</b> √© sempre alguma transforma√ß√£o linear de <b>1 / z</b> . <br><br>  √Ä primeira vista, pode parecer que qualquer fun√ß√£o de <b>z</b> possa ser tomada como <b>d</b> .  Ent√£o, por que ela parece assim?  Existem duas raz√µes principais para isso. <br><br>  Em primeiro lugar, <b>1 / z</b> se encaixa naturalmente na proje√ß√£o em perspectiva.  E esta √© a classe mais b√°sica de transforma√ß√µes, garantida para preservar linhas.  Portanto, a proje√ß√£o em perspectiva √© adequada para rasteriza√ß√£o de hardware, pois as bordas retas dos tri√¢ngulos permanecem retas na tela.  Podemos obter uma transforma√ß√£o linear a partir de <b>1 / z</b> , aproveitando a divis√£o de perspectiva que a GPU j√° realiza: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math2.jpg" alt="imagem"><br><br>  Obviamente, a for√ßa real dessa abordagem √© que a matriz de proje√ß√£o pode ser multiplicada por outras matrizes, permitindo combinar muitas transforma√ß√µes em uma. <br><br>  A segunda raz√£o √© que <b>1 / z</b> √© linear no espa√ßo da tela, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como observou Emil Persson</a> .  Isso facilita a interpola√ß√£o de d no tri√¢ngulo durante a rasteriza√ß√£o, e coisas como <b>buffers Z hier√°rquicos</b> , <b>buffer de profundidade de compacta√ß√£o</b> e <b>sele√ß√£o antecipada de Z.</b> <br><br><div class="spoiler">  <b class="spoiler_title">Resumidamente do artigo</b> <div class="spoiler_text">  Embora o valor de <b>w (profundidade do espa√ßo de visualiza√ß√£o)</b> seja linear no espa√ßo de visualiza√ß√£o, ele n√£o √© linear no espa√ßo da tela.  <b>z (profundidade)</b> , n√£o linear no espa√ßo da vista, por outro lado linear no espa√ßo da tela.  Isso pode ser verificado facilmente com um simples shader DX10: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx = ddx(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dy = ddy(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000.0</span></span> * float4(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dx), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dy), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Aqui In.position √© SV_Position.  O resultado √© algo como isto: <br><br><img src="http://www.humus.name/News/ZGradient.png" alt="imagem"><br><br>  Observe que todas as superf√≠cies parecem monocrom√°ticas.  A diferen√ßa em <b>z</b> de pixel para pixel √© a mesma para qualquer primitivo.  Isso √© muito importante para a GPU.  Uma raz√£o √© que a interpola√ß√£o <b>z</b> √© mais barata que a interpola√ß√£o <b>w</b> .  Para <b>z, n√£o</b> h√° necessidade de executar a corre√ß√£o de perspectiva.  Com unidades de hardware mais baratas, voc√™ pode processar mais pixels por ciclo com o mesmo or√ßamento para transistores.  Naturalmente, isso √© muito importante para o <b>mapa</b> <b>pre-z pass</b> e <b>shadow</b> .  Com o hardware moderno, a linearidade no espa√ßo da tela tamb√©m √© um recurso muito √∫til para otimiza√ß√µes z.  Dado que o gradiente √© linear para toda a primitiva, tamb√©m √© relativamente f√°cil calcular a faixa exata de profundidade dentro do bloco para o <b>descarte Hi-z</b> .  Isso tamb√©m significa que <b>a compress√£o z</b> √© poss√≠vel.  Com uma constante <b>Œîz</b> em <b>x</b> e <b>y,</b> voc√™ n√£o precisa armazenar muitas informa√ß√µes para poder restaurar completamente todos os valores de <b>z</b> em um bloco, desde que o primitivo cubra todo o bloco. <br></div></div><br><h2>  Gr√°ficos de profundidade </h2><br>  As equa√ß√µes s√£o complicadas, vamos ver algumas fotos! <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph1.jpg" alt="imagem"><br><br>  A maneira de ler esses gr√°ficos √© da esquerda para a direita e depois para baixo.  Comece com <b>d</b> no eixo esquerdo.  Como <b>d</b> pode ser uma transforma√ß√£o linear arbitr√°ria de <b>1 / z</b> , podemos organizar 0 e 1 em qualquer local conveniente no eixo.  Marcas indicam diferentes valores de <b>buffer de profundidade</b> .  Para fins de clareza, modelo um <b>buffer de profundidade</b> normalizado inteiro de 4 bits, para que haja 16 marcas espa√ßadas igualmente. <br><br>  O gr√°fico acima mostra a convers√£o de profundidade de baunilha "padr√£o" para D3D e APIs semelhantes.  Voc√™ pode perceber imediatamente como, devido √† curva <b>1 / z</b> , os valores pr√≥ximos ao plano pr√≥ximo s√£o agrupados e os valores pr√≥ximos ao plano distante est√£o dispersos. <br><br>  Tamb√©m √© f√°cil entender por que perto de um avi√£o afeta tanto a precis√£o da profundidade.  A dist√¢ncia perto do plano levar√° a um r√°pido aumento nos valores de <b>d em</b> rela√ß√£o aos valores de <b>z</b> , o que levar√° a uma distribui√ß√£o ainda mais desigual de valores: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph2.jpg" alt="imagem"><br><br>  Da mesma forma, neste contexto, √© f√°cil ver por que mover o plano distante para o infinito n√£o tem um efeito t√£o grande.  Significa apenas expandir o intervalo de <b>d</b> para <b>1 / z = 0</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph3.jpg" alt="imagem"><br><br>  Mas e a profundidade de ponto flutuante?  O gr√°fico a seguir foi adicionado √†s marcas correspondentes ao formato flutuante com 3 bits do expoente e 3 bits da mantissa: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph4.jpg" alt="imagem"><br><br>  Agora, no intervalo [0,1], existem 40 valores diferentes - um pouco mais de 16 valores anteriores, mas a maioria deles √© agrupada inutilmente perto do plano pr√≥ximo (mais pr√≥ximo de 0 o flutuador tem maior precis√£o), onde realmente n√£o precisamos de muita precis√£o. <br><br>  Agora, um truque conhecido √© inverter a profundidade, exibindo o plano pr√≥ximo em <b>d = 1</b> e o plano distante em <b>d = 0</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph5.jpg" alt="imagem"><br><br>  Muito melhor!  Agora, a distribui√ß√£o quase-logar√≠tmica do flutuador de alguma forma compensa a n√£o linearidade de <b>1 / z</b> , enquanto mais pr√≥ximo do plano pr√≥ximo ele fornece uma precis√£o semelhante ao buffer de profundidade inteira e fornece uma precis√£o significativamente maior em outros lugares.  A precis√£o da profundidade se deteriora muito lentamente se voc√™ se afastar da c√¢mera. <br><br>  O truque do <b>Z reverso</b> pode ter sido reinventado de forma independente v√°rias vezes, mas pelo menos a primeira men√ß√£o foi no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo SIGGRAPH '99</a> [Eugene Lapidous e Guofang Jiao (infelizmente n√£o est√° dispon√≠vel ao p√∫blico)].  E, recentemente, ele foi mencionado novamente no blog por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Matt Petineo</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Brano Kemen</a> , e em um discurso de Emil Persson <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criando Vast Game Worlds</a> SIGGRAPH 2012. <br><br>  Todos os gr√°ficos anteriores assumiram uma faixa de profundidade [0,1] ap√≥s a proje√ß√£o, o que √© uma conven√ß√£o no D3D.  E o <b>OpenGL</b> ? <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph6.jpg" alt="imagem"><br><br>  <b>O OpenGL,</b> por padr√£o, assume uma faixa de profundidade [-1, 1] ap√≥s a proje√ß√£o.  Para formatos inteiros, nada muda, mas para ponto flutuante, toda a precis√£o est√° concentrada in√∫til no meio.  (O valor da profundidade √© mapeado para o intervalo [0,1] para armazenamento subseq√ºente no buffer de profundidade, mas isso n√£o ajuda, pois o mapeamento inicial para [-1,1] j√° destruiu toda a precis√£o na metade mais distante do intervalo.) E, devido √† simetria, o truque <b>Z reverso</b> n√£o funcionar√° aqui. <br><br>  Felizmente, na √°rea de trabalho OpenGL, isso pode ser corrigido usando a extens√£o amplamente suportada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ARB_clip_control</a> (tamb√©m come√ßando com o OpenGL 4.5, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">glClipControl</a> √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padr√£o</a> ).  Infelizmente, o GL ES est√° em voo. <br><br><h2>  O efeito de erros de arredondamento </h2><br>  A convers√£o <b>1 / z</b> e a escolha do <b>buffer de profundidade float x int</b> s√£o uma grande parte da hist√≥ria da precis√£o, mas n√£o todas.  Mesmo se voc√™ tiver precis√£o de profundidade suficiente para representar a cena que est√° tentando renderizar, √© f√°cil degradar a precis√£o com erros aritm√©ticos durante o processo de convers√£o de v√©rtices. <br><br>  No in√≠cio do artigo, foi mencionado que Upchurch e Desbrun estudaram esse problema.  Eles propuseram duas recomenda√ß√µes principais para minimizar os erros de arredondamento: <br><br><ol><li>  Use plano distante infinito. </li><li>  Mantenha a matriz de proje√ß√£o separada de outras matrizes e aplique-a como uma opera√ß√£o separada no shader de v√©rtice, em vez de combin√°-la com a matriz de vista. </li></ol><br>  Upchurch e Desbrun fizeram essas recomenda√ß√µes usando um m√©todo anal√≠tico baseado no processamento de erros de arredondamento como pequenos erros aleat√≥rios representados em cada opera√ß√£o aritm√©tica e rastreando-os at√© a primeira ordem no processo de convers√£o.  Eu decidi testar os resultados na pr√°tica. <br><br>  As fontes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> s√£o Python 3.4 e numpy.  O programa funciona da seguinte maneira: uma sequ√™ncia de pontos aleat√≥rios √© gerada, ordenada por profundidade, localizada linear ou logaritmicamente entre planos pr√≥ximos e distantes.  Em seguida, os pontos s√£o multiplicados pelas matrizes de vista e proje√ß√£o e a divis√£o de perspectiva √© realizada, usando flutuadores de 32 bits e, opcionalmente, o resultado final √© convertido em um int de 24 bits.  No final, ele passa pela sequ√™ncia e conta quantas vezes dois pontos vizinhos (que inicialmente tinham profundidades diferentes) se tornaram id√™nticos, porque tinham a mesma profundidade ou a ordem foi alterada.  Em outras palavras, o programa mede a frequ√™ncia com que erros de compara√ß√£o de profundidade ocorrem - o que corresponde a problemas como o <b>Z-fighting</b> - em v√°rios cen√°rios. <br><br>  Aqui est√£o os resultados para near = 0.1, far = 10K, com uma profundidade linear de 10K.  (Tentei o intervalo de profundidade logar√≠tmico e outras raz√µes perto / longe e, embora os n√∫meros espec√≠ficos variassem, as tend√™ncias gerais nos resultados eram as mesmas.) <br><br>  Na tabela, ‚Äúeq‚Äù - dois pontos com a profundidade mais pr√≥xima obt√™m o mesmo valor no buffer de profundidade e ‚Äúswap‚Äù - dois pontos com a profundidade mais pr√≥xima s√£o trocados. <br><table><tbody><tr><td colspan="1" rowspan="2"></td><td colspan="2" rowspan="1">  <b>Matriz composta de vista e proje√ß√£o</b> </td><td colspan="2" rowspan="1">  <b>Matrizes separadas de vista e proje√ß√£o</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>Valores Z inalterados (teste de controle)</b> </td><td colspan="1" rowspan="1">  0% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  0% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  0% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  0% eq <br>  Troca de 0% </td></tr><tr><td colspan="1" rowspan="1">  <b>Proje√ß√£o padr√£o</b> </td><td colspan="1" rowspan="1">  45% eq <br>  Swap de 18% </td><td colspan="1" rowspan="1">  45% eq <br>  Swap de 18% </td><td colspan="1" rowspan="1">  77% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  77% eq <br>  Troca de 0% </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinito longe</b> </td><td colspan="1" rowspan="1">  45% eq <br>  Swap de 18% </td><td colspan="1" rowspan="1">  45% eq <br>  Swap de 18% </td><td colspan="1" rowspan="1">  76% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  76% eq <br>  Troca de 0% </td></tr><tr><td colspan="1" rowspan="1">  <b>Z invertido</b> </td><td colspan="1" rowspan="1">  0% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  76% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  0% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  76% eq <br>  Troca de 0% </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinito + Z reverso</b> </td><td colspan="1" rowspan="1">  0% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  76% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  0% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  76% eq <br>  Troca de 0% </td></tr><tr><td colspan="1" rowspan="1">  <b>Padr√£o + estilo GL</b> </td><td colspan="1" rowspan="1">  56% eq <br>  Swap de 12% </td><td colspan="1" rowspan="1">  56% eq <br>  Swap de 12% </td><td colspan="1" rowspan="1">  77% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  77% eq <br>  Troca de 0% </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinito + estilo GL</b> </td><td colspan="1" rowspan="1">  59% eq <br>  Swap de 10% </td><td colspan="1" rowspan="1">  59% eq <br>  Swap de 10% </td><td colspan="1" rowspan="1">  77% eq <br>  Troca de 0% </td><td colspan="1" rowspan="1">  77% eq <br>  Troca de 0% </td></tr></tbody></table><br>  Pe√ßo desculpas pelo fato de que, sem um gr√°fico, h√° muita dimens√£o aqui e simplesmente n√£o √© poss√≠vel constru√≠-lo!  De qualquer forma, olhando os n√∫meros, as seguintes conclus√µes s√£o √≥bvias: <br><br><ul><li>  Na maioria dos casos, n√£o h√° diferen√ßa entre o <b>buffer</b> <b>int</b> e <b>float depth</b> .  Erros aritm√©ticos para calcular erros de substitui√ß√£o de profundidade na convers√£o para int.  Em parte porque float32 e int24 t√™m ULP quase igual (a unidade de menor precis√£o √© a dist√¢ncia do n√∫mero vizinho mais pr√≥ximo) por [0.5.1] (como o float32 tem uma mantissa de 23 bits), portanto, um erro de convers√£o n√£o √© adicionado em quase toda a faixa de profundidade em int. </li><li>  Na maioria dos casos, a separa√ß√£o das matrizes de <b>vis√£o</b> e <b>proje√ß√£o</b> (seguindo as recomenda√ß√µes de Upchurch e Desbrun) melhora o resultado.  Apesar do fato de a taxa de erro geral n√£o diminuir, os ‚Äúswaps‚Äù se tornam valores iguais, e este √© um passo na dire√ß√£o certa. </li><li>  O plano infinito distante altera ligeiramente a frequ√™ncia dos erros.  Upchurch e Desbrun previram uma redu√ß√£o de 25% na frequ√™ncia de erros num√©ricos (erros de precis√£o), mas isso n√£o parece levar a uma diminui√ß√£o na frequ√™ncia de erros de compara√ß√£o. </li></ul><br>  No entanto, as descobertas acima n√£o s√£o reais em compara√ß√£o com o <b>Z reverso</b> m√°gico.  Verifique: <br><br><ul><li>  O Z reverso com buffer de profundidade de flutua√ß√£o fornece uma <i>taxa de erro zero</i> no teste.  Agora, √© claro, voc√™ pode obter alguns erros se continuar aumentando o intervalo dos valores de profundidade de entrada.  No entanto, o Z reverso com flutua√ß√£o √© ridiculamente mais preciso do que qualquer outra op√ß√£o. </li><li>  O Z reverso com buffer de profundidade inteira √© t√£o bom quanto outras op√ß√µes inteiras. </li><li>  O Z reverso desfoca a distin√ß√£o entre matrizes de vis√£o / proje√ß√£o compostas e separadas e planos distantes finitos e infinitos.  Em outras palavras, com Z reverso, voc√™ pode multiplicar a proje√ß√£o com outras matrizes e usar qualquer plano distante que desejar, sem comprometer a precis√£o. </li></ul><br><h2>  Conclus√£o </h2><br>  Eu acho que a conclus√£o √© clara.  Em qualquer situa√ß√£o, ao lidar com proje√ß√£o em perspectiva, basta usar o <b>buffer de profundidade de flutua√ß√£o e o Z invertido</b> !  E se voc√™ n√£o conseguir usar o buffer de profundidade de flutua√ß√£o, ainda deve usar Z reverso.  Isso n√£o √© uma panac√©ia para todos os males, especialmente se voc√™ criar um ambiente de mundo aberto com faixas de profundidade extremas.  Mas este √© um √≥timo come√ßo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434322/">https://habr.com/ru/post/pt434322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434308/index.html">Como funciona o sistema de vigil√¢ncia por v√≠deo Ivideon: Vis√£o geral do software para PC</a></li>
<li><a href="../pt434312/index.html">Tempo de confer√™ncia! Resumindo 2018</a></li>
<li><a href="../pt434314/index.html">Alternativas ao LastPass. Avalia√ß√£o comparativa de seis gerenciadores de senhas</a></li>
<li><a href="../pt434316/index.html">Papai Noel secreto, miss√µes, question√°rio e pista de skate - como nos conhecemos no Ano Novo da ABBYY</a></li>
<li><a href="../pt434320/index.html">Como testamos o Sberbank Online no iOS</a></li>
<li><a href="../pt434326/index.html">Bal√© no ar: levita√ß√£o controlada de part√≠culas devido a ondas sonoras</a></li>
<li><a href="../pt434328/index.html">Assinatura eletr√¥nica para participa√ß√£o em compras</a></li>
<li><a href="../pt434330/index.html">O que h√° de novo no YouTrack 2018.4</a></li>
<li><a href="../pt434332/index.html">E mais uma vez sobre o KIB SearchInform: lidamos com as mais recentes</a></li>
<li><a href="../pt434334/index.html">Como baghunters interceptaram cartas de correio a√©reo no ZeroNights</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>