<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÄ ‚ôåÔ∏è üïò Mapas de Unity Hexagon: Agua, Monumentos y Muros de Fortaleza ü§∂ ü•ê üèÇüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malla, colores y alturas de celda 

 Partes 4-7: baches, r√≠os y caminos 

 Partes 8-11: agua, accidentes geogr√°ficos y murallas 

 Partes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas de Unity Hexagon: Agua, Monumentos y Muros de Fortaleza</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425463/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 1-3: malla, colores y alturas de celda</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 4-7: baches, r√≠os y caminos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 8-11: agua, accidentes geogr√°ficos y murallas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 12-15: guardar y cargar, texturas, distancias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 16-19: encontrar el camino, escuadrones de jugadores, animaciones</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 20-23: niebla de guerra, investigaci√≥n de mapas, generaci√≥n de procedimientos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 24-27: ciclo del agua, erosi√≥n, biomas, mapa cil√≠ndrico</a> <br><br><h1>  Parte 8: agua </h1><br><ul><li>  Agregue agua a las c√©lulas. </li><li>  Triangular la superficie del agua. </li><li>  Crea un surf con espuma. </li><li>  Combina agua y r√≠os. </li></ul><br>  Ya hemos agregado soporte de r√≠o, y en esta parte sumergiremos completamente las c√©lulas en agua. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/73c/b6e/2a973cb6eb97eba7d04a325f3ac89a3e.jpg"></div><br>  <i>Se acerca el agua.</i> <br><a name="habracut"></a><br><h2>  Nivel del agua </h2><br>  La forma m√°s f√°cil es implementar el soporte de agua al establecerlo en el mismo nivel.  Todas las celdas cuya altura est√° por debajo de este nivel est√°n sumergidas en agua.  Pero una forma m√°s flexible ser√≠a mantener el agua a diferentes alturas, as√≠ que hagamos que el nivel del agua cambie.  Para esto, <code>HexCell</code> necesita monitorear su nivel de agua. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel;</code> </pre> <br>  Si lo desea, puede asegurarse de que ciertas caracter√≠sticas del relieve no existieran bajo el agua.  Pero por ahora no har√© esto.  Cosas como caminos submarinos me convienen.  Pueden considerarse √°reas que se han inundado recientemente. <br><br><h3>  C√©lulas de inundaci√≥n </h3><br>  Ahora que tenemos niveles de agua, la pregunta m√°s importante es si las c√©lulas est√°n bajo el agua.  Una celda est√° debajo del agua si su nivel de agua est√° por encima de su altura.  Para obtener esta informaci√≥n, agregaremos una propiedad. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsUnderwater { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel &gt; elevation; } }</code> </pre> <br>  Esto significa que cuando el nivel y la altura del agua son iguales, la celda se eleva por encima del agua.  Es decir, la superficie real del agua est√° por debajo de esta altura.  Al igual que con las superficies de los r√≠os, agreguemos el mismo desplazamiento: <code>HexMetrics.riverSurfaceElevationOffset</code> .  Cambie su nombre a uno m√°s general. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public const float riverSurfaceElevationOffset = -0.5f; public const float waterElevationOffset = -0.5f;</span></span></code> </pre> <br>  Cambie <code>HexCell.RiverSurfaceY</code> para que use el nuevo nombre.  Luego agregamos una propiedad similar a la superficie del agua de la celda inundada. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.waterElevationOffset) * HexMetrics.elevationStep; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WaterSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (waterLevel + HexMetrics.waterElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3>  Edici√≥n de agua </h3><br>  Editar el nivel del agua es similar a cambiar la altura.  Por lo tanto, <code>HexMapEditor</code> debe monitorear el nivel de agua activo y si debe aplicarse a las celdas. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeElevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeWaterLevel; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyWaterLevel = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Agregue m√©todos para conectar estos par√°metros con la interfaz de usuario. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyWaterLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyWaterLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWaterLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeWaterLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; }</code> </pre> <br>  Y agregue el nivel de agua a <code>EditCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } ‚Ä¶ } }</code> </pre> <br>  Para agregar un nivel de agua a la interfaz de usuario, duplique la etiqueta y el control deslizante de altura, y luego c√°mbielos.  Recuerde adjuntar sus eventos a los m√©todos apropiados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42b/a13/de4/42ba13de4120b43e460628021c77d99f.png"></div><br>  <i>Control deslizante de nivel de agua.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete de la unidad</a> <br><br><h2>  Triangulaci√≥n de agua </h2><br>  Para triangular el agua, necesitamos una nueva malla con nuevo material.  Primero, crea un sombreador de <em>agua</em> , duplicando el sombreador de <em>r√≠o</em> .  C√°mbielo para que use la propiedad de color. <br><br><pre> <code class="hljs pgsql">Shader "Custom/Water" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Transparent" "Queue"="Transparent" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard alpha #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br>  Cree un nuevo material con este sombreador duplicando el material <em>Agua</em> y reemplaz√°ndolo con un sombreador.  Deja la textura de ruido, porque la usaremos m√°s tarde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd9/238/283/fd9238283d92bacd26a3ff5dce73b17b.png"></div><br>  <i>Material de agua.</i> <br><br>  Agregue un nuevo hijo al prefabricado duplicando el hijo de <em>Rivers</em> .  No necesita coordenadas UV, y debe usar <em>agua</em> .  Como de costumbre, haremos esto creando una instancia del prefab, cambi√°ndola y luego aplicando los cambios al prefab.  Despu√©s de eso, deshazte de la instancia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/6e6/82f/6ec6e682f16c604d75c0e5b835d5b03e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/3f3/eeb/7c53f3eeb282e533f9f0b8a20e813091.png"></div><br>  <i>Ni√±o Objeto Agua.</i> <br><br>  Luego, agregue soporte de malla de agua a <code>HexGridChunk</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); }</code> </pre> <br>  Y con√©ctelo al ni√±o prefabricado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/19a/76a/b4d19a76a745d550314b277fd2c0e13c.png"></div><br>  <i>El objeto Agua est√° conectado.</i> <br><br><h3>  Hex√°gonos de agua </h3><br>  Como el agua forma una segunda capa, demos nuestro propio m√©todo de triangulaci√≥n para cada una de las direcciones.  Necesitamos llamarlo solo cuando la celda est√° sumergida en agua. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { TriangulateWater(direction, cell, center); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Al igual que con los r√≠os, la altura de la superficie del agua no var√≠a mucho en las celdas con el mismo nivel de agua.  Por lo tanto, no parece que necesitemos costillas complejas.  Un tri√°ngulo simple ser√° suficiente. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { center.y = cell.WaterSurfaceY; Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction); water.AddTriangle(center, c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a51/72b/99b/a5172b99ba382c6e79abff653e4b7fb2.png"></div><br>  <i>Hex√°gonos de agua.</i> <br><br><h3>  Compuestos de agua </h3><br>  Podemos conectar c√©lulas vecinas con agua con un cuadr√°ngulo. <br><br><pre> <code class="cs hljs"> water.AddTriangle(center, c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 e1 = c1 + bridge; Vector3 e2 = c2 + bridge; water.AddQuad(c1, c2, e1, e2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a6/3af/949/0a63af9496da925e966b008f41f808a8.png"></div><br>  <i>Conexiones de los bordes del agua.</i> <br><br>  Y llena las esquinas con un tri√°ngulo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { ‚Ä¶ water.AddQuad(c1, c2, e1, e2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !nextNeighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } water.AddTriangle( c2, e2, c2 + HexMetrics.GetBridge(direction.Next()) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/37e/5b4/c3237e5b4e492f9a1c334f90aaa88ee4.png"></div><br>  <i>Articulaciones de esquinas de agua.</i> <br><br>  Ahora tenemos c√©lulas de agua conectadas cuando est√°n cerca.  Dejan un espacio entre ellos y las c√©lulas secas con una altura m√°s alta, pero lo dejaremos para m√°s adelante. <br><br><h3>  Niveles de agua armonizados </h3><br>  Presumimos que las c√©lulas submarinas vecinas tienen el mismo nivel de agua.  Si esto es as√≠, entonces todo se ve bien, pero si se viola esta suposici√≥n, se producen errores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcf/a8b/b4f/fcfa8bb4fb960ddc788d358e60f9023f.png"></div><br>  <i>Niveles de agua inconsistentes.</i> <br><br>  Podemos hacer que el agua permanezca en el mismo nivel.  Por ejemplo, cuando cambia el nivel de agua de una celda inundada, podemos propagar los cambios a las celdas vecinas para mantener los niveles sincronizados.  Sin embargo, este proceso debe continuar hasta que encuentre c√©lulas que no est√©n sumergidas en agua.  Estas celdas definen los l√≠mites de la masa de agua. <br><br>  El peligro de este enfoque es que puede salirse r√°pidamente de control.  Si la edici√≥n no se realiza correctamente, el agua puede cubrir todo el mapa.  Luego, todos los fragmentos deber√°n triangularse simult√°neamente, lo que dar√° lugar a un gran salto en los retrasos. <br><br>  As√≠ que no lo hagamos todav√≠a.  Esta caracter√≠stica se puede agregar en un editor m√°s complejo.  Si bien la consistencia de los niveles de agua, dejamos la conciencia del usuario. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Animacion de agua </h2><br>  En lugar de un color uniforme, crearemos algo parecido a las ondas.  Como en otros sombreadores, por ahora no buscaremos gr√°ficos hermosos, solo necesitamos designar las ondas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/a2f/1f9/ca1a2f1f978cd2f2993a96b44440227b.png"></div><br>  <i>Agua perfectamente plana.</i> <br><br>  Hagamos lo que hicimos con los r√≠os.  Probamos el ruido con la posici√≥n del mundo y lo agregamos a un color uniforme.  Para animar la superficie, agregue tiempo a la coordenada V. <br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise.z; fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Desplazamiento de agua, tiempo √ó 10.</i> <br><br><h3>  Dos direcciones </h3><br>  Hasta ahora esto no es para nada como olas.  Vamos a complicar la imagen agregando una segunda muestra de ruido <br>  y esta vez agregando la coordenada U. Usamos un canal de ruido diferente para obtener dos patrones diferentes como resultado.  Las olas terminadas ser√°n estas dos muestras apiladas juntas. <br><br><pre> <code class="hljs pgsql"> float2 uv1 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv1.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise1 = tex2D(_MainTex, uv1 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv2.x += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise1.z + noise2.x;</code> </pre> <br>  Al sumar ambas muestras, obtenemos resultados en el intervalo 0‚Äì2, por lo que debemos volver a escalarlo a 0‚Äì1.  En lugar de simplemente dividir las ondas por la mitad, podemos usar la funci√≥n de paso <code>smoothstep</code> para crear un resultado m√°s interesante.  Ponemos ¬æ - 2 en 0‚Äì1 para que no haya ondas visibles en la superficie del agua. <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waves = noise1.z + noise2.x; waves = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Dos direcciones, tiempo √ó 10.</i> <br><br><h3>  Olas de mezcla </h3><br>  Todav√≠a se nota que tenemos dos patrones de ruido en movimiento que en realidad no cambian.  Ser√≠a m√°s plausible si los patrones cambiaran.  Podemos darnos cuenta de esto interpolando entre diferentes canales de muestras de ruido.  Pero esto no se puede hacer de la misma manera, de lo contrario, toda la superficie del agua cambiar√° simult√°neamente, y esto es muy notable.  En cambio, crearemos una ola de confusi√≥n. <br><br>  Crearemos una onda de mezcla con la ayuda de una sinusoide, que se mueve diagonalmente a lo largo de la superficie del agua.  Haremos esto agregando las coordenadas mundiales X y Z y usando la suma como entrada a la funci√≥n <code>sin</code> .  Alejar para obtener bandas lo suficientemente grandes.  Y, por supuesto, agreguemos el mismo valor para animarlos. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin((<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + _Time.y);</code> </pre> <br>  Las ondas sinusoidales oscilan entre -1 y 1, y necesitamos un intervalo de 0-1.  Puedes conseguirlo cuadrando la ola.  Para ver un resultado aislado, √∫selo en lugar del color cambiado como valor de salida. <br><br><pre> <code class="hljs pgsql"> sin((<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + _Time.y); blendWave *= blendWave; <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise1.z + noise2.x; waves = smoothstep(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves); fixed4 c = blendWave; //saturate(_Color + waves);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/3d9/d70/aa33d9d70a022df57a0348423181b258.png"></div><br>  <i>Olas de mezcla.</i> <br><br>  Para que las ondas de mezcla sean menos visibles, agr√©gueles algo de ruido de ambas muestras. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin( (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (noise1.y + noise2.z) + _Time.y ); blendWave *= blendWave;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/c8f/697/618c8f697cd2e463d7349030277d1a82.png"></div><br>  <i>Ondas distorsionadas de mezcla.</i> <br><br>  Finalmente, usamos una onda de mezcla para interpolar entre los dos canales de ambas muestras de ruido.  Para una variaci√≥n m√°xima, tome cuatro canales diferentes. <br><br><pre> <code class="hljs lisp"> float waves = lerp(<span class="hljs-name"><span class="hljs-name">noise1</span></span>.z, noise1.w, blendWave) + lerp(<span class="hljs-name"><span class="hljs-name">noise2</span></span>.x, noise2.y, blendWave)<span class="hljs-comment"><span class="hljs-comment">; waves = smoothstep(0.75, 2, waves); fixed4 c = saturate(_Color + waves);</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Mezcla de olas, tiempo √ó 2.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  La costa </h2><br>  Hemos terminado con aguas abiertas, pero ahora necesitamos llenar el vac√≠o en el agua a lo largo de la costa.  Como debemos conformarnos a los contornos de la tierra, el agua costera requiere un enfoque diferente.  Dividamos <code>TriangulateWater</code> en dos m√©todos: uno para aguas abiertas y otro para la costa.  Para entender cu√°ndo trabajamos con la costa, tenemos que mirar la celda vecina.  Es decir, en <code>TriangulateWater</code> obtendremos un vecino.  Si hay un vecino y √©l no est√° bajo el agua, entonces estamos tratando con la costa. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { center.y = cell.WaterSurfaceY; HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; !neighbor.IsUnderwater) { TriangulateWaterShore(direction, cell, neighbor, center); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateOpenWater(direction, cell, neighbor, center); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction); water.AddTriangle(center, c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// HexCell neighbor = cell.GetNeighbor(direction); // if (neighbor == null || !neighbor.IsUnderwater) { // return; // } Vector3 bridge = HexMetrics.GetBridge(direction); ‚Ä¶ } } void TriangulateWaterShore ( HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center ) { }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f04/799/441/f0479944178dcb5646bbf935700a798e.png"></div><br>  <i>No hay triangulaci√≥n a lo largo de la costa.</i> <br><br>  Como la costa est√° distorsionada, debemos distorsionar los tri√°ngulos de agua a lo largo de la costa.  Por lo tanto, necesitamos la parte superior de los bordes y el abanico de los tri√°ngulos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/761/283/bbd76128386859bb388e6e2d3f105ff0.png"></div><br>  <i>Fans de tri√°ngulos a lo largo de la costa.</i> <br><br>  Lo siguiente es una tira de costillas, como en un alivio normal.  Sin embargo, no estamos obligados a limitarnos solo a ciertas √°reas, porque solo llamamos a <code>TriangulateWaterShore</code> cuando nos encontramos con la costa, para lo cual siempre se necesita la franja. <br><br><pre> <code class="cs hljs"> water.AddTriangle(center, e1.v4, e1.v5); Vector3 bridge = HexMetrics.GetBridge(direction); EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); water.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); water.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); water.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7da/fbc/aa9/7dafbcaa95a4b48509ab68fbf111c703.png"></div><br>  <i>Rayas de costillas a lo largo de la costa.</i> <br><br>  Del mismo modo, tambi√©n debemos agregar un tri√°ngulo angular cada vez. <br><br><pre> <code class="cs hljs"> water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { water.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/18f/8b1/06418f8b10cc0fc0a4e2276b86375385.png"></div><br>  <i>Las esquinas de las costillas a lo largo de la costa.</i> <br><br>  Ahora tenemos agua lista para la costa.  Parte de ella siempre est√° debajo de la malla de relieve, por lo que no hay agujeros. <br><br><h3>  Costa UV </h3><br>  Podemos dejar todo como est√°, pero ser√≠a interesante si el agua costera tuviera su propio horario.  Por ejemplo, el efecto de la espuma, que se agranda al acercarse a la costa.  Para implementarlo, el sombreador debe saber qu√© tan cerca est√° el fragmento de la costa.  Podemos transmitir esta informaci√≥n a trav√©s de coordenadas UV. <br><br>  El agua abierta no tiene coordenadas UV y no necesita espuma.  Solo se necesita para el agua cerca de la costa.  Por lo tanto, los requisitos para ambos tipos de agua son bastante diferentes.  Ser√≠a l√≥gico crear su propia malla para cada tipo.  Por lo tanto, agregamos soporte para otro objeto de malla a HexGridChunk. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water, waterShore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); }</code> </pre> <br>  Esta nueva malla usar√° <code>TriangulateWaterShore</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); } }</code> </pre> <br>  Duplique el objeto de agua, con√©ctelo al prefabricado y config√∫relo para que use coordenadas UV.  Tambi√©n creamos un sombreador y material para el agua costera, duplicando el sombreador y el material de agua existentes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/561/77e/e73/56177ee7331ce092a859a058645f0364.png"></div><br>  <i>Instalaciones de orilla de agua y material UV.</i> <br><br>  Cambie el sombreador <em>Water Shore</em> para que, en lugar de agua, muestre coordenadas UV. <br><br><pre> <code class="hljs lisp"> fixed4 c = fixed4(<span class="hljs-name"><span class="hljs-name">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Como todav√≠a no se han establecido coordenadas, mostrar√° un color s√≥lido.  Gracias a esto, es f√°cil ver que la costa en realidad usa una malla separada con material. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/45c/ec0/63045cec0f1f367bfee191f69cfa11ad.png"></div><br>  <i>Malla separada para la costa.</i> <br><br>  Pongamos la informaci√≥n de la costa en la coordenada V. En el lado del agua, as√≠gnele un valor de 0, en el lado de la tierra - valor 1. Dado que no necesitamos transmitir nada m√°s, todas las coordenadas U simplemente ser√°n 0. <br><br><pre> <code class="cs hljs"> waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f4/3fa/f86/8f43faf864c259e21c2ce731d08f43f6.png"></div><br>  <i>Las transiciones a las costas est√°n mal.</i> <br><br>  El c√≥digo anterior funciona para bordes, pero est√° mal en algunos √°ngulos.  Si el pr√≥ximo vecino est√° bajo el agua, entonces este enfoque ser√° correcto.  Pero cuando el pr√≥ximo vecino no est√° bajo el agua, el tercer pico del tri√°ngulo estar√° bajo tierra. <br><br><pre> <code class="cs hljs"> waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, nextNeighbor.IsUnderwater ? <span class="hljs-number"><span class="hljs-number">0f</span></span> : <span class="hljs-number"><span class="hljs-number">1f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/9e9/6e6/c2e9e96e63c161d0f71f81e31742af89.png"></div><br>  <i>Las transiciones a las costas son correctas.</i> <br><br><h3>  Espuma en la costa </h3><br>  Ahora que las transiciones a la costa se implementan correctamente, puede usarlas para crear un efecto de espuma.  La forma m√°s f√°cil es agregar el valor de la costa a un color uniforme. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = shore; fixed4 c = saturate(_Color + foam); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/502/a56/ef5502a56ab665732312be25a6961817.png"></div><br>  <i>Espuma lineal.</i> <br><br>  Para hacer la espuma m√°s interesante, multipl√≠quela por el cuadrado de la sinusoide. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin(shore * <span class="hljs-number"><span class="hljs-number">10</span></span>); foam *= foam * shore;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/acf/6d8/c2eacf6d83e9f7c1298cdd7a05e551d0.png"></div><br>  <i>Espuma cuadrada sinusoide de desvanecimiento.</i> <br><br>  Hagamos el frente de espuma m√°s grande cuando nos acercamos a la orilla.  Esto se puede hacer tomando su ra√≠z cuadrada antes de usar el valor de la costa. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; shore = sqrt(shore);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/762/675/e98/762675e987d119034cd5b643c86ca672.png"></div><br>  <i>La espuma se vuelve m√°s gruesa cerca de la orilla.</i> <br><br>  Agregue distorsi√≥n para que se vea m√°s natural.  Hagamos que la distorsi√≥n sea m√°s d√©bil cuando nos acercamos a la costa.  Por lo tanto, ser√° mejor alinear la costa. <br><br><pre> <code class="hljs pgsql"> float2 noiseUV = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin((shore + distortion) * <span class="hljs-number"><span class="hljs-number">10</span></span>); foam *= foam * shore;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31a/7fd/59a/31a7fd59ad215b200571133543f1406b.png"></div><br>  <i>Espuma con distorsi√≥n.</i> <br><br>  Y, por supuesto, estamos animando todo esto: tanto una sinusoide como distorsiones. <br><br><pre> <code class="hljs pgsql"> float2 noiseUV = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin((shore + distortion) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam *= foam * shore;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Espuma animada</i> <br><br>  Adem√°s de la espuma entrante, tambi√©n hay un retroceso.  Agreguemos una segunda sinusoide, que se mueve en la direcci√≥n opuesta, para simularla.  Hazlo m√°s d√©bil y agrega un cambio de tiempo.  La espuma terminada ser√° el m√°ximo de estos dos sinusoides. <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distortion1 = <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam1 = <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((shore + distortion1) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam1 *= foam1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distortion2 = <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.y * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam2 = <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((shore + distortion2) * <span class="hljs-number"><span class="hljs-number">10</span></span> + _Time.y + <span class="hljs-number"><span class="hljs-number">2</span></span>); foam2 *= foam2 * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam = <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(foam1, foam2) * shore;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Espuma de entrada y retroceso.</i> <br><br><h3>  Mezcla de olas y espuma </h3><br>  Hay una transici√≥n brusca entre el agua abierta y costera porque las olas de agua abierta no est√°n incluidas en el agua costera.  Para solucionar esto, debemos incluir estas ondas en el sombreador <em>Water Shore</em> . <br><br>  En lugar de copiar el c√≥digo de onda, <em>peg√©moslo</em> en el archivo de inclusi√≥n <em>Water.cginc</em> .  De hecho, insertamos c√≥digo para la espuma y las ondas, cada una como una funci√≥n separada. <br><br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo funcionan los archivos de inclusi√≥n de sombreador?</b> <div class="spoiler_text">  La creaci√≥n de sus propios archivos de sombreador de inclusi√≥n se trata en el tutorial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rendering 5, Luces m√∫ltiples</a> . </div></div><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> Foam (<span class="hljs-type"><span class="hljs-type">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { // <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; shore = sqrt(shore); float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(noiseTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion1 = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam1 = sin((shore + distortion1) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam1 *= foam1; <span class="hljs-type"><span class="hljs-type">float</span></span> distortion2 = noise.y * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam2 = sin((shore + distortion2) * <span class="hljs-number"><span class="hljs-number">10</span></span> + _Time.y + <span class="hljs-number"><span class="hljs-number">2</span></span>); foam2 *= foam2 * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(foam1, foam2) * shore; } <span class="hljs-type"><span class="hljs-type">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise1 = tex2D(noiseTex, uv1 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); float2 uv2 = worldXZ; uv2.x += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(noiseTex, uv2 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin( (worldXZ.x + worldXZ.y) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (noise1.y + noise2.z) + _Time.y ); blendWave *= blendWave; <span class="hljs-type"><span class="hljs-type">float</span></span> waves = lerp(noise1.z, noise1.w, blendWave) + lerp(noise2.x, noise2.y, blendWave); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> smoothstep(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves); }</code> </pre> <br>  Cambie el sombreador de <em>agua</em> para que use el nuevo archivo de inclusi√≥n. <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br>  En el sombreador <em>Water Shore</em> , los valores se calculan tanto para espuma como para olas.  Luego amortiguamos las olas a medida que nos acercamos a la orilla.  El resultado final ser√° un m√°ximo de espuma y olas. <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = Foam(shore, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); waves *= <span class="hljs-number"><span class="hljs-number">1</span></span> - shore; fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Una mezcla de espuma y olas.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  De nuevo sobre el agua costera </h2><br>  Parte de la malla costera est√° oculta debajo de la malla en relieve.  Esto es normal, pero solo una peque√±a parte est√° oculta.  Desafortunadamente, los acantilados empinados esconden la mayor parte del agua costera y, por lo tanto, la espuma. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/adf/7e3/deaadf7e3290f93b28ed6177c713bbaa.png"></div><br>  <i>Agua costera casi oculta.</i> <br><br>  Podemos manejar esto aumentando el tama√±o de la franja de la costa.  Esto se puede hacer reduciendo el radio de los hex√°gonos de agua.  Para esto, adem√°s del coeficiente de integridad, necesitamos un coeficiente de agua <code>HexMetrics</code> , as√≠ como m√©todos para obtener √°ngulos de agua. <br><br>  El coeficiente de integridad es 0.8.  Para duplicar el tama√±o de los compuestos de agua, necesitamos establecer el coeficiente de agua en 0.6. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waterFactor = <span class="hljs-number"><span class="hljs-number">0.6f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstWaterCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] * waterFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondWaterCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] * waterFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizaremos estos nuevos m√©todos </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para encontrar los √°ngulos del agua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { Vector3 c1 = center + HexMetrics.GetFirstWaterCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondWaterCorner(direction); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstWaterCorner(direction), center + HexMetrics.GetSecondWaterCorner(direction) ); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/b85/fcf/123b85fcffde7ae313f177f76f882ef5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando esquinas de agua. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distancia entre los hex√°gonos del agua en realidad se duplic√≥. </font><font style="vertical-align: inherit;">Ahora </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n deber√≠a tener un m√©todo para crear puentes en el agua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waterBlendFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> - waterFactor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWaterBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * waterBlendFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que use el nuevo m√©todo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 bridge = HexMetrics.GetWaterBridge(direction); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { ‚Ä¶ water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 bridge = HexMetrics.GetWaterBridge(direction); ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetWaterBridge(direction.Next()) ); ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99b/756/1fa/99b7561fad8556733ea1f10b2dcdd233.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Largos puentes en el agua.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entre las costillas de agua y tierra </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque esto nos da m√°s espacio para la espuma, ahora se oculta a√∫n m√°s debajo del relieve. </font><font style="vertical-align: inherit;">Idealmente, podremos usar una costilla de agua en el lado del agua y una costilla de tierra en el lado de tierra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No podemos usar un puente simple para encontrar el borde opuesto de la tierra, si comenzamos desde las esquinas del agua. </font><font style="vertical-align: inherit;">En cambio, podemos ir en la direcci√≥n opuesta, desde el centro del vecino. </font><font style="vertical-align: inherit;">Cambiar </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para usar este nuevo enfoque.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Vector3 bridge = HexMetrics.GetWaterBridge(direction); Vector3 center2 = neighbor.Position; center2.y = center.y; EdgeVertices e2 = new EdgeVertices( center2 + HexMetrics.GetSecondSolidCorner(direction.Opposite()), center2 + HexMetrics.GetFirstSolidCorner(direction.Opposite()) ); ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); if (nextNeighbor != null) { Vector3 center3 = nextNeighbor.Position; center3.y = center.y; waterShore.AddTriangle( e1.v5, e2.v5, center3 + HexMetrics.GetFirstSolidCorner(direction.Previous()) ); ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/3f2/01f/b293f201f065b7921f1098484e3b725d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquinas incorrectas de los bordes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto funcion√≥, solo que ahora nuevamente necesitamos considerar dos casos para tri√°ngulos angulares.</font></font><br><br><pre> <code class="cs hljs"> HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 center3 = nextNeighbor.Position; // center3.y = center.y; Vector3 v3 = nextNeighbor.Position + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); v3.y = center.y; waterShore.AddTriangle(e1.v5, e2.v5, v3); waterShore.AddTriangleUV( new Vector2(0f, 0f), new Vector2(0f, 1f), new Vector2(0f, nextNeighbor.IsUnderwater ? 0f : 1f) ); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e1/f64/db1/4e1f64db1a34a8e6cff0f402f5fc6bd8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las esquinas correctas de los bordes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto funcion√≥ bien, pero ahora que la mayor parte de la espuma es visible, se est√° volviendo bastante pronunciada. </font><font style="vertical-align: inherit;">Para compensar esto, haremos que el efecto sea un poco m√°s d√©bil al reducir la escala del valor de la costa en el sombreador.</font></font><br><br><pre> <code class="hljs lisp"> shore = sqrt(<span class="hljs-name"><span class="hljs-name">shore</span></span>) * <span class="hljs-number"><span class="hljs-number">0.9</span></span><span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listo de espuma. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√≠os submarinos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminamos con agua, al menos en aquellos lugares donde no fluyen r√≠os. </font><font style="vertical-align: inherit;">Como el agua y los r√≠os a√∫n no se notan, los r√≠os fluir√°n a trav√©s y debajo del agua.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/1ee/bc5/0511eebc5420c9203475b65ce5c478b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√≠os que fluyen en el agua. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El orden en que se representan los objetos transl√∫cidos depende de su distancia de la c√°mara. </font><font style="vertical-align: inherit;">Los objetos m√°s cercanos se representan en √∫ltimo lugar, por lo que est√°n en la parte superior. </font><font style="vertical-align: inherit;">Al mover la c√°mara, esto significar√° que a veces los r√≠os y el agua aparecer√°n uno encima del otro. </font><font style="vertical-align: inherit;">Comencemos haciendo constante el orden de representaci√≥n. </font><font style="vertical-align: inherit;">Los r√≠os deben dibujarse sobre el agua para que las cascadas se muestren correctamente. </font><font style="vertical-align: inherit;">Podemos implementar esto cambiando la cola del sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+1"</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bc/74e/d91/4bc74ed9179598f5b9e82c3ff0cde851.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dibujamos los r√≠os al final.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ocultando r√≠o submarino </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque el lecho del r√≠o bien puede estar bajo el agua, y el agua puede fluir a trav√©s de √©l, no deber√≠amos ver esta agua. </font><font style="vertical-align: inherit;">Y a√∫n m√°s, no debe representarse sobre una superficie de agua real. </font><font style="vertical-align: inherit;">Podemos deshacernos del agua de los r√≠os submarinos agregando segmentos de r√≠o solo cuando la celda actual no est√° bajo el agua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; ‚Ä¶ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comenzar, agregaremos un segmento de r√≠o cuando ni la celda actual ni la vecina est√°n bajo el agua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/0c7/cf6/8990c7cf6af7bf25596b4ffc05204817.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No m√°s r√≠os submarinos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cascadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya no hay r√≠os submarinos, pero ahora tenemos agujeros en esos lugares de los r√≠os donde se encuentran con la superficie del agua. Los r√≠os en el mismo nivel que el agua crean peque√±os agujeros o superposiciones. Pero las m√°s notables son las cascadas que faltan para los r√≠os que fluyen desde una altura mayor. Cuidemos de ellos primero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un segmento de r√≠o con una cascada sol√≠a pasar a trav√©s de la superficie del agua. Como resultado, se encontr√≥ parcialmente arriba y parcialmente debajo del agua. Necesitamos mantener una parte por encima del nivel del agua, descartando todo lo dem√°s. Tendr√°s que trabajar duro para esto, as√≠ que crea un m√©todo separado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nuevo m√©todo requiere cuatro picos, dos niveles de r√≠o y un nivel de agua. Lo configuraremos para que miremos en la direcci√≥n de la corriente, hacia abajo de la cascada. Por lo tanto, los dos primeros picos y los lados izquierdo y derecho estar√°n en la parte superior, y los inferiores seguir√°n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamaremos a este m√©todo </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando un vecino est√© bajo el agua y creamos una cascada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambi√©n necesitamos procesar las cascadas en la direcci√≥n opuesta, cuando la celda actual est√° bajo el agua, y la siguiente no. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ que nuevamente tenemos el quad del r√≠o original. </font><font style="vertical-align: inherit;">Luego necesitamos cambiar </font></font><code>TriangulateWaterfallInWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que eleve los picos m√°s bajos al nivel del agua. </font><font style="vertical-align: inherit;">Desafortunadamente, cambiar solo las coordenadas Y no ser√° suficiente. </font><font style="vertical-align: inherit;">Esto puede empujar la cascada desde el acantilado, que puede formar agujeros. </font><font style="vertical-align: inherit;">En su lugar, debe mover los v√©rtices inferiores a los superiores utilizando la interpolaci√≥n.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/11b/250/94211b250d95b614a5d6be6ff52c9e9e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolar </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mover los picos inferiores hacia arriba, divida su distancia debajo de la superficie del agua por la altura de la cascada. </font><font style="vertical-align: inherit;">Esto nos dar√° un valor de interpolador.</font></font><br><br><pre> <code class="cs hljs"> v1.y = v2.y = y1; v3.y = v4.y = y2; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = (waterY - y2) / (y1 - y2); v3 = Vector3.Lerp(v3, v1, t); v4 = Vector3.Lerp(v4, v2, t); rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtenemos una cascada acortada que tiene la misma orientaci√≥n. </font><font style="vertical-align: inherit;">Sin embargo, dado que las posiciones de los v√©rtices inferiores han cambiado, no se distorsionar√°n como los v√©rtices originales. </font><font style="vertical-align: inherit;">Esto significa que el resultado final a√∫n no coincidir√° con la cascada original. </font><font style="vertical-align: inherit;">Para resolver este problema, necesitamos distorsionar manualmente los v√©rtices antes de interpolar, y luego agregar el quad no distorsionado.</font></font><br><br><pre> <code class="cs hljs"> v1.y = v2.y = y1; v3.y = v4.y = y2; v1 = HexMetrics.Perturb(v1); v2 = HexMetrics.Perturb(v2); v3 = HexMetrics.Perturb(v3); v4 = HexMetrics.Perturb(v4); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = (waterY - y2) / (y1 - y2); v3 = Vector3.Lerp(v3, v1, t); v4 = Vector3.Lerp(v4, v2, t); rivers.AddQuadUnperturbed(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ya tenemos un m√©todo para agregar tri√°ngulos no distorsionados, realmente no necesitamos crear uno para quads. </font><font style="vertical-align: inherit;">Por lo tanto, agregamos el m√©todo necesario </font></font><code>HexMesh.AddQuadUnperturbed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4 </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); vertices.Add(v4); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc4/605/bdd/dc4605bdd24ed9460b0ca3a310a11fb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las cascadas terminan en la superficie del agua. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estuarios </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando los r√≠os fluyen a la misma altura que la superficie del agua, la malla del r√≠o toca la malla costera. Si fuera un r√≠o que fluye hacia el mar o hacia el oc√©ano, entonces habr√≠a una corriente del r√≠o con un oleaje. Por lo tanto, llamaremos a estas √°reas estuarios.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/27b/efa/ddd27befa12ec543e2969505365b0d91.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El r√≠o se encuentra con la costa sin distorsionar los picos.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora tenemos dos problemas con la boca. En primer lugar, los r√≠os cu√°druples conectan la segunda y cuarta parte superior de las costillas, omitiendo la tercera. Dado que la costa del agua no usa el tercer pico, puede crear un agujero o superposici√≥n. Podemos resolver este problema cambiando la geometr√≠a de las bocas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El segundo problema es que existe una fuerte transici√≥n entre la espuma y los materiales fluviales. Para resolverlo, necesitamos otro material que realice la mezcla de los efectos de un r√≠o y el agua. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto significa que las bocas requieren un enfoque especial, as√≠ que creemos un m√©todo separado para ellas. Debe llamarse </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando hay un r√≠o movi√©ndose en la direcci√≥n actual.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary(e1, e2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No se requiere una regi√≥n que mezcle ambos efectos para llenar toda la tira. </font><font style="vertical-align: inherit;">La forma trapezoidal ser√° suficiente para nosotros. </font><font style="vertical-align: inherit;">Por lo tanto, podemos usar dos tri√°ngulos costeros en los lados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ece/ca1/fc9/ececa1fc9852f7350a54e00fa71df0b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agujero trapezoidal para el √°rea de mezcla.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coordenadas UV2 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear un efecto de r√≠o, necesitamos coordenadas UV. </font><font style="vertical-align: inherit;">Pero para crear un efecto de espuma, tambi√©n necesita coordenadas UV. </font><font style="vertical-align: inherit;">Es decir, al mezclarlos, necesitamos dos conjuntos de coordenadas UV. </font><font style="vertical-align: inherit;">Afortunadamente, las mallas del motor Unity pueden soportar hasta cuatro conjuntos UV. </font><font style="vertical-align: inherit;">Solo necesitamos agregar </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soporte para el segundo conjunto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUV2Coordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">1</span></span>, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para agregar un segundo conjunto de UV, duplicamos los m√©todos de trabajo con UV y cambiamos la forma en que lo necesitamos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(uv1); uv2s.Add(uv2); uv2s.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(uv1); uv2s.Add(uv2); uv2s.Add(uv3); uv2s.Add(uv4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funci√≥n River Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como usaremos el efecto de r√≠o en dos sombreadores, moveremos el c√≥digo del sombreador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√≠o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a la nueva funci√≥n de archivo de inclusi√≥n de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agua</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> River (float2 riverUV, sampler2D noiseTex) { float2 uv = riverUV; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(noiseTex, uv); float2 uv2 = riverUV; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(noiseTex, uv2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noise.x * noise2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie el sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para usar esta nueva funci√≥n.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objetos bucales </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue una </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boca </font><font style="vertical-align: inherit;">para </font><font style="vertical-align: inherit;">apoyar el objeto de malla.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water, waterShore, estuaries; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); estuaries.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); estuaries.Apply(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crea un sombreador, material y un objeto de la boca, duplicando la costa y cambi√°ndola. </font><font style="vertical-align: inherit;">Con√©ctelo al fragmento y haga que use las coordenadas UV y UV2.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/77a/7fc/54077a7fc8653228cd723ca855330fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos Estuarties.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulaci√≥n de la boca </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos resolver el problema del agujero o la superposici√≥n colocando un tri√°ngulo entre el final del r√≠o y la mitad del borde del agua. </font><font style="vertical-align: inherit;">Dado que nuestro sombreador bucal es un duplicado del sombreador costero, establecemos las coordenadas UV para que coincidan con el efecto de espuma.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/bb6/f76/f02bb6f768f915d39c05296055cc0b83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri√°ngulo medio </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos llenar todo el trapecio agregando un quad a ambos lados del tri√°ngulo central.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuad(e1.v2, e1.v3, e2.v1, e2.v2); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef2/672/e7e/ef2672e7e62b9d66463e4fc44dc43b7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listo trapecio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Giremos la orientaci√≥n cu√°druple hacia la izquierda para que tenga una conexi√≥n diagonal acortada, y como resultado obtenemos geometr√≠a sim√©trica.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">// estuaries.AddQuadUV(0f, 0f, 0f, 1f);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/dd0/7d1/cd5dd07d1b9f1fb8126e6a5a7c1bc29b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quad girado, geometr√≠a sim√©trica</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flujo del rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para apoyar el efecto del r√≠o, necesitamos agregar coordenadas UV2. </font><font style="vertical-align: inherit;">La parte inferior del tri√°ngulo del medio est√° en el medio del r√≠o, por lo que su coordenada U debe ser igual a 0.5. </font><font style="vertical-align: inherit;">Como el r√≠o fluye en la direcci√≥n del agua, el punto izquierdo recibe la coordenada U igual a 1, y el derecho recibe la coordenada U con un valor de 0. Establecemos las coordenadas Y en 0 y 1, correspondientes a la direcci√≥n de la corriente.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los cuadr√°ngulos en ambos lados del tri√°ngulo deben coincidir con esta orientaci√≥n. </font><font style="vertical-align: inherit;">Mantenemos las mismas coordenadas U para puntos que exceden el ancho del r√≠o.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a98/475/d50/a98475d50fe84d16eeeff5397f6aa43f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trapecio UV2. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para asegurarse de que establecemos las coordenadas UV2 correctamente, haga que el sombreador del </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuario las</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procese. </font><font style="vertical-align: inherit;">Podemos acceder a estas coordenadas agregando a la estructura de entrada </font></font><code>float2 uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 uv2_MainTex; float3 worldPos; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = Foam(shore, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); waves *= <span class="hljs-number"><span class="hljs-number">1</span></span> - shore; fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/416/d95/efd416d95c7827f264f2f0e8360e6fde.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordenadas UV2. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo se ve bien, puedes usar un sombreador para crear un efecto de r√≠o.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, _MainTex); fixed4 c = saturate(_Color + river); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/2c9/fda/0e32c9fda58b356534c2070d0b74adae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usa UV2 para crear un efecto de r√≠o. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creamos los r√≠os de tal manera que al triangular las conexiones entre las celdas, las coordenadas del r√≠o V cambian de 0.8 a 1. Por lo tanto, aqu√≠ tambi√©n deber√≠amos usar este intervalo, y no de 0 a 1. Sin embargo, la conexi√≥n costera es un 50% m√°s que las conexiones de celda ordinarias . </font><font style="vertical-align: inherit;">Por lo tanto, para el mejor ajuste con el curso del r√≠o, debemos cambiar los valores de 0.8 a 1.1.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/beb/7c6/27dbeb7c67553163422fd560e64ddb03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/4d9/2e3/b0c4d92e3797274e2534a6921334d184.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flujo sincronizado del r√≠o y el estuario.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajuste de flujo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras el r√≠o se mueve en l√≠nea recta. </font><font style="vertical-align: inherit;">Pero cuando el agua fluye hacia un √°rea m√°s grande, se expande. </font><font style="vertical-align: inherit;">La corriente se curvar√°. </font><font style="vertical-align: inherit;">Podemos simular esto doblando las coordenadas UV2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de mantener constantes las coordenadas U superiores fuera del ancho del r√≠o, mu√©valas 0.5. </font><font style="vertical-align: inherit;">El punto m√°s a la izquierda es 1.5, el m√°s a la derecha es ‚àí0.5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al mismo tiempo, expandimos el flujo moviendo las coordenadas U de los puntos inferiores izquierdo y derecho. </font><font style="vertical-align: inherit;">Cambie el izquierdo de 1 a 0.7 y el derecho de 0 a 0.3.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); ‚Ä¶ estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/99d/976/85099d97610434a630621e9e06f885ad.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/567/f72/0c1567f72c979734719b298c7850b59e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expansi√≥n del r√≠o. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para completar el efecto de curvatura, cambie las coordenadas V de los mismos cuatro puntos. </font><font style="vertical-align: inherit;">Dado que el agua fluye desde el final del r√≠o, aumentaremos las coordenadas de V de los puntos superiores a 1. Y para crear una mejor curva, aumentaremos las coordenadas de V de los dos puntos inferiores a 1.15.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/86d/320/1fa86d32037da7fab579ce9a195d1e71.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/edb/dfe/b07edbdfeb3615b1a597712a6bda5c8e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El curso curvo del r√≠o.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mezcla de r√≠o y costa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo lo que nos queda es mezclar los efectos de la costa y el r√≠o. </font><font style="vertical-align: inherit;">Para hacer esto, usamos interpolaci√≥n lineal, tomando el valor de la costa como interpolador.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> shoreWater = max(foam, waves); <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> water = lerp(shoreWater, river, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x); fixed4 c = saturate(_Color + water);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque esto deber√≠a funcionar, puede obtener un error de compilaci√≥n. </font><font style="vertical-align: inherit;">El compilador se queja de la redefinici√≥n </font></font><code>_MainTex_ST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La raz√≥n es un error dentro del compilador de sombreador de superficie Unity causado por el uso simult√°neo de </font></font><code>uv_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Necesitamos encontrar una soluci√≥n alternativa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de usarlo </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tendremos que transferir las coordenadas UV secundarias manualmente. </font><font style="vertical-align: inherit;">Para hacer esto, cambie el nombre </font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>riverUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luego agregue una funci√≥n de v√©rtice al sombreador, que le asigna coordenadas.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert ‚Ä¶ struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; }; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.riverUV, _MainTex); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/904/b40/c98/904b40c98323b2e9f32bd16513344181.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolaci√≥n basada en el valor de la costa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La interpolaci√≥n funciona, con la excepci√≥n de los v√©rtices izquierdo y derecho en la parte superior. </font><font style="vertical-align: inherit;">En estos puntos el r√≠o deber√≠a desaparecer. </font><font style="vertical-align: inherit;">Por lo tanto, no podemos usar el valor de la costa. </font><font style="vertical-align: inherit;">Tendremos que usar un valor diferente, que en estos dos v√©rtices es 0. Afortunadamente, todav√≠a tenemos la coordenada U del primer conjunto UV, por lo que podemos almacenar este valor all√≠.</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">// estuaries.AddQuadUV(0f, 0f, 0f, 1f);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/e93/432/b34e93432248fb7be818b53aca4d8b20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La combinaci√≥n correcta </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora las bocas tienen una buena mezcla entre el r√≠o en expansi√≥n, el agua costera y la espuma. </font><font style="vertical-align: inherit;">Aunque esto no crea una coincidencia exacta con las cascadas, este efecto tambi√©n se ve bien con las cascadas.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Estuarios </font></a><i><font style="vertical-align: inherit;">en acci√≥n </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitpackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√≠os que fluyen de cuerpos de agua </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya tenemos r√≠os que fluyen hacia cuerpos de agua, pero no hay soporte para r√≠os que fluyan en una direcci√≥n diferente. </font><font style="vertical-align: inherit;">Hay lagos de los que fluyen los r√≠os, por lo que tambi√©n debemos agregarlos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando un r√≠o fluye de un cuerpo de agua, en realidad fluye hacia una altitud m√°s alta. </font><font style="vertical-align: inherit;">Esto actualmente no es posible. </font><font style="vertical-align: inherit;">Necesitamos hacer una excepci√≥n y permitir esta situaci√≥n si el nivel del agua corresponde a la altura del punto objetivo. </font><font style="vertical-align: inherit;">Agreguemos a un </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo privado que verifica de acuerdo con nuestro nuevo criterio si el vecino es el punto objetivo correcto para el r√≠o de salida.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidRiverDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor &amp;&amp; ( elevation &gt;= neighbor.elevation || waterLevel == neighbor.elevation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usaremos nuestro nuevo m√©todo para determinar si es posible crear un r√≠o saliente. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || elevation &lt; neighbor.elevation) { if (!IsValidRiverDestination(neighbor)) { return; } RemoveOutgoingRiver(); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, all√≠ debe verificar el r√≠o al cambiar la altura de la celda o el nivel del agua. </font><font style="vertical-align: inherit;">Creemos un m√©todo privado que haga esta tarea.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; !IsValidRiverDestination(GetNeighbor(outgoingRiver)) ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; !GetNeighbor(incomingRiver).IsValidRiverDestination(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) { RemoveIncomingRiver(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizaremos este nuevo m√©todo en las propiedades </font></font><code>Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// if ( // hasOutgoingRiver &amp;&amp; // elevation &lt; GetNeighbor(outgoingRiver).elevation // ) { // RemoveOutgoingRiver(); // } // if ( // hasIncomingRiver &amp;&amp; // elevation &gt; GetNeighbor(incomingRiver).elevation // ) { // RemoveIncomingRiver(); // } ValidateRivers(); ‚Ä¶ } } public int WaterLevel { ‚Ä¶ set { if (waterLevel == value) { return; } waterLevel = value; ValidateRivers(); Refresh(); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/ca4/b49/c04ca4b49ccff20e71dba70dc1a2bea7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salientes y entrantes de lagos fluviales</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambiar el rumbo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creamos </font></font><code>HexGridChunk.TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sugiriendo que los r√≠os solo pueden fluir hacia cuerpos de agua. </font><font style="vertical-align: inherit;">Por lo tanto, como resultado, el curso del r√≠o siempre se mueve en una direcci√≥n. </font><font style="vertical-align: inherit;">Necesitamos revertir el flujo cuando se trata de un r√≠o que fluye de un cuerpo de agua. </font><font style="vertical-align: inherit;">Para hacer esto, necesita </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saber sobre la direcci√≥n del flujo. </font><font style="vertical-align: inherit;">Por lo tanto, le damos un par√°metro booleano que determina si estamos tratando con un r√≠o entrante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasaremos esta informaci√≥n cuando llamemos a este m√©todo desde </font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary(e1, e2, cell.IncomingRiver == direction); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos expandir el flujo del r√≠o cambiando las coordenadas de UV2. </font><font style="vertical-align: inherit;">Las coordenadas U para los r√≠os salientes deben reflejarse: ‚àí0.5 se convierte en 1.5, 0 se convierte en 1, 1 se convierte en 0 y 1.5 se convierte en ‚àí0.5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con las coordenadas V, las cosas son un poco m√°s complicadas. </font><font style="vertical-align: inherit;">Si observa c√≥mo trabajamos con las conexiones fluviales invertidas, 0.8 deber√≠a ser 0 y 1 deber√≠a ser ‚àí0.2. </font><font style="vertical-align: inherit;">Esto significa que 1.1 se convierte en ‚àí0.3 y 1.15 se convierte en ‚àí0.35. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como en cada caso las coordenadas UV2 son muy diferentes, escribamos un c√≥digo separado para ellas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (incomingRiver) { estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2f</span></span>) ); } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El curso correcto de los r√≠os. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 9: caracter√≠sticas de alivio </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A√±adir objetos al relieve. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creamos soporte para niveles de densidad de objetos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usamos varios objetos en el nivel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mezcla tres tipos diferentes de objetos. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta parte hablaremos sobre agregar objetos al terreno. </font><font style="vertical-align: inherit;">Crearemos objetos como edificios y √°rboles.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8b/1ec/f84/b8b1ecf8496a03d50c881bbd47c262ad.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conflicto entre bosques, tierras agr√≠colas y urbanizaci√≥n.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar soporte para objetos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque la forma del relieve tiene variaciones, hasta ahora no est√° sucediendo nada. </font><font style="vertical-align: inherit;">Esta es una tierra sin vida. </font><font style="vertical-align: inherit;">Para darle vida, necesitas agregar tales objetos. </font><font style="vertical-align: inherit;">como √°rboles y casas. </font><font style="vertical-align: inherit;">Estos objetos no son parte de la malla en relieve, pero ser√°n objetos separados. </font><font style="vertical-align: inherit;">Pero esto no nos impide agregarlos al triangular el terreno. </font></font><br><br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No me importa c√≥mo funciona la malla. </font><font style="vertical-align: inherit;">Simplemente le ordena a uno de sus hijos que </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregue un tri√°ngulo o un quad. </font><font style="vertical-align: inherit;">Del mismo modo, puede tener un elemento hijo que se ocupe de la colocaci√≥n de objetos en ellos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Administrador de objetos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creemos un componente </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que cuide los objetos dentro de un solo fragmento. </font><font style="vertical-align: inherit;">Usamos el mismo esquema que en </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- darle m√©todos </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como el objeto debe colocarse en alg√∫n lugar, el m√©todo </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recibe el par√°metro de posici√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comenzaremos con una implementaci√≥n en blanco que no har√° nada por ahora.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexFeatureManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos agregar un enlace a dicho componente en </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luego puede incluirlo en el proceso de triangulaci√≥n, como todos los elementos secundarios </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexFeatureManager features; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); estuaries.Clear(); features.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); estuaries.Apply(); features.Apply(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comencemos colocando un objeto en el centro de cada celda </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } features.AddFeature(cell.Position); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos un administrador de objetos real. </font><font style="vertical-align: inherit;">Agregue </font><font style="vertical-align: inherit;">otro hijo al </font><font style="vertical-align: inherit;">prefabricado </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y dele un componente </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Entonces puedes conectarle un fragmento.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/1f4/626/eeb1f462652650c6dfe5e3cb34a2ec12.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51b/7ec/8f2/51b7ec8f20b4a79589fd2b464744230b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/c6f/8cd/620c6f8cd7c54c52597fcc289b160c57.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un administrador de objetos agregado al fragmento prefabricado.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objetos prefabricados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© objeto de terreno crearemos? </font><font style="vertical-align: inherit;">Para la primera prueba, un cubo es bastante adecuado. </font><font style="vertical-align: inherit;">Creemos un cubo lo suficientemente grande, por ejemplo, con una escala de (3, 3, 3), y convi√©rtalo en una casa prefabricada. </font><font style="vertical-align: inherit;">Tambi√©n crea material para √©l. </font><font style="vertical-align: inherit;">Us√© el material predeterminado con rojo. </font><font style="vertical-align: inherit;">Eliminemos su colisionador, porque no lo necesitamos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/1b1/315/a7a1b1315e7f2756ac2940dac661f95a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cubo prefabricado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los administradores de objetos necesitar√°n un enlace a este prefabricado, as√≠ que agr√©guelo </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y luego con√©ctelos. </font><font style="vertical-align: inherit;">Dado que se requiere acceso al componente de transformaci√≥n para colocar el objeto, lo usamos como el tipo de enlace.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform featurePrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfc/34d/e84/cfc34de84fbc12ac5fde17d7d1d09b58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Administrador de objetos con prefabricados.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear instancias de objetos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°La estructura est√° lista, y podemos comenzar a agregar caracter√≠sticas del terreno! </font><font style="vertical-align: inherit;">Simplemente cree una instancia del prefab en </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y establezca su posici√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); instance.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd8/59c/ae5/dd859cae56fa9439e91d0ccb5d659f62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instancias de caracter√≠sticas del terreno. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir de ahora, el terreno se llenar√° de cubos. </font><font style="vertical-align: inherit;">Al menos las mitades superiores de los cubos, porque el origen local de la malla del cubo en Unity est√° en el centro del cubo, y la parte inferior est√° debajo de la superficie del relieve. </font><font style="vertical-align: inherit;">Para colocar cubos en la topograf√≠a, necesitamos moverlos hasta la mitad de su altura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/6be/89b/bb06be89b647d5ff29f1894bfdcf199b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cubos en la superficie del relieve.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© pasa si usamos otra malla?</font></font></b> <div class="spoiler_text">       .     ,      ,        .       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, nuestras c√©lulas est√°n distorsionadas, por lo que debemos distorsionar la posici√≥n de los objetos. </font><font style="vertical-align: inherit;">As√≠ nos deshacemos de la perfecta repetibilidad de la malla.</font></font><br><br><pre> <code class="cs hljs"> instance.localPosition = HexMetrics.Perturb(position);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e5/7ec/a43/9e57eca43cf9127691cb5eb11bc6a11a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posiciones distorsionadas de objetos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Destrucci√≥n de objetos en relieve. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada vez que se actualiza un fragmento, creamos nuevos objetos de relieve. </font><font style="vertical-align: inherit;">Esto significa que mientras creamos m√°s y m√°s objetos en las mismas posiciones. </font><font style="vertical-align: inherit;">Para evitar duplicados, debemos deshacernos de los objetos viejos al limpiar un fragmento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s r√°pida de hacerlo es creando un objeto contenedor del juego y convirtiendo todos los objetos de relieve en sus elementos secundarios. </font><font style="vertical-align: inherit;">Luego, cuando se lo llame, </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destruiremos este contenedor y crearemos uno nuevo. </font><font style="vertical-align: inherit;">El contenedor en s√≠ ser√° hijo de su gerente.</font></font><br><br><pre> <code class="cs hljs"> Transform container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (container) { Destroy(container.gameObject); } container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Features Container"</span></span>).transform; container.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probablemente, es ineficiente crear y destruir objetos de alivio cada vez.</font></font></b> <div class="spoiler_text"> , ,   .       .      .   ,  ,      ,    .          <code>HexFeatureManager.Apply</code> .      .  ,    ,       . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colocaci√≥n de objetos en relieve. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras colocamos objetos en el centro de cada celda. </font><font style="vertical-align: inherit;">Para las celdas vac√≠as, esto parece normal, pero en las celdas que contienen r√≠os y carreteras, as√≠ como inundadas con agua, parece extra√±o.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/e88/ab8/01de88ab8777d38afeb4ca374571a2f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los objetos est√°n en todas partes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, verifiquemos antes de colocar el objeto </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si la celda est√° vac√≠a.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell.Position); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5db/b98/75f/5dbb9875f8510c7f9224f8ba10465ae4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alojamiento limitado.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un objeto por direccion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo un objeto por celda no es demasiado. </font><font style="vertical-align: inherit;">Todav√≠a hay mucho espacio para un mont√≥n de objetos. </font><font style="vertical-align: inherit;">Por lo tanto, agregamos un objeto adicional al centro de cada uno de los seis tri√°ngulos de la celda, es decir, uno por direcci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haremos esto con otro m√©todo </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cuando sepamos que no hay r√≠o en la celda. </font><font style="vertical-align: inherit;">Todav√≠a tenemos que verificar si estamos bajo el agua y si hay un camino en la celda. </font><font style="vertical-align: inherit;">Pero en este caso, solo nos interesan las carreteras que van en la direcci√≥n actual.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature((center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/b60/d4b/7e7b60d4b54d2f9a7b3119e78554507a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muchas instalaciones, pero no en las proximidades de los r√≠os. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Esto crea muchos m√°s objetos! </font><font style="vertical-align: inherit;">Aparecen cerca de las carreteras, pero a√∫n evitan los r√≠os. </font><font style="vertical-align: inherit;">Para colocar objetos a lo largo de los r√≠os, tambi√©n podemos agregarlos dentro </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero de nuevo solo cuando el tri√°ngulo no est√° bajo el agua y no hay camino en √©l.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature((center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/90a/f9f/30c90af9ffb31cec360ea027fc4f1815.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los objetos aparecieron al lado de los r√≠os.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øEs posible renderizar tantos objetos?</font></font></b> <div class="spoiler_text">       ,    dynamic batching  Unity.    ,       .         batch.     ¬´ ¬ª,       .    instancing,          dynamic batching. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variedad de objetos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos nuestros objetos en relieve tienen la misma orientaci√≥n, que parece completamente antinatural. </font><font style="vertical-align: inherit;">Vamos a darle a cada uno un giro al azar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b42/8bd/0bc/b428bd0bcb9b27676853f7bb1e491165.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turnos aleatorios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces el resultado se vuelve mucho m√°s diverso. </font><font style="vertical-align: inherit;">Desafortunadamente, cada vez que se actualiza un fragmento, los objetos reciben una nueva rotaci√≥n aleatoria. </font><font style="vertical-align: inherit;">La edici√≥n de celdas no deber√≠a cambiar los objetos en el vecindario, por lo que necesitamos un enfoque diferente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos una textura de ruido que siempre es la misma. </font><font style="vertical-align: inherit;">Sin embargo, esta textura contiene ruido de gradiente de Perlin y es localmente consistente. </font><font style="vertical-align: inherit;">Esto es exactamente lo que necesitamos al distorsionar las posiciones de los v√©rtices en las celdas. </font><font style="vertical-align: inherit;">Pero los giros no tienen que ser consistentes. </font><font style="vertical-align: inherit;">Todos los giros deben ser igualmente probables y mixtos. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos una textura con valores aleatorios sin gradiente, que se pueda muestrear sin filtrado bilineal. </font><font style="vertical-align: inherit;">Esencialmente, esta es una cuadr√≠cula hash que forma la base del ruido de gradiente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear una tabla hash </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos crear una tabla hash a partir de una matriz de valores flotantes y llenarla una vez con valores aleatorios. </font><font style="vertical-align: inherit;">Gracias a esto, no necesitamos una textura en absoluto. </font><font style="vertical-align: inherit;">A√±√°dalo a </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Un tama√±o de 256 por 256 es suficiente para una variaci√≥n suficiente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashGridSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] hashGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[hashGridSize * hashGridSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los valores aleatorios son generados por una f√≥rmula matem√°tica que siempre da los mismos resultados. </font><font style="vertical-align: inherit;">La secuencia resultante depende del n√∫mero de semillas, que por defecto es igual al valor actual del tiempo. </font><font style="vertical-align: inherit;">Es por eso que en cada sesi√≥n de juego obtendremos resultados diferentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para garantizar que se recrean siempre objetos id√©nticos, necesitamos agregar el par√°metro semilla al m√©todo de inicializaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[hashGridSize * hashGridSize]; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que hemos inicializado el flujo de n√∫meros aleatorios, siempre obtendremos la misma secuencia. </font><font style="vertical-align: inherit;">Por lo tanto, los eventos aparentemente aleatorios que ocurren despu√©s de la generaci√≥n del mapa tambi√©n ser√°n siempre los mismos. </font><font style="vertical-align: inherit;">Podemos evitar esto almacenando el estado del generador de n√∫meros aleatorios antes de inicializarlo. </font><font style="vertical-align: inherit;">Despu√©s de completar el trabajo, podemos preguntarle el estado anterior.</font></font><br><br><pre> <code class="cs hljs"> Random.State currentState = Random.state; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } Random.state = currentState;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tabla hash se inicializa </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al mismo tiempo que asigna la textura de ruido. </font><font style="vertical-align: inherit;">Es decir, en los m√©todos </font></font><code>HexGrid.Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lo hacemos para que los valores no se generen m√°s de lo necesario.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La variable semilla gen√©rica nos permite seleccionar el valor semilla para el mapa. </font><font style="vertical-align: inherit;">Cualquier valor servir√°. </font><font style="vertical-align: inherit;">Eleg√≠ 1234.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60c/8b3/5a3/60c8b35a3b6a92b61165ed3a00473076.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La elecci√≥n de la semilla.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando una tabla hash </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para usar la tabla hash, agregue al </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo de muestreo. </font><font style="vertical-align: inherit;">Al igual </font></font><code>SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utiliza las coordenadas de la posici√≥n XZ para obtener el valor. </font><font style="vertical-align: inherit;">El √≠ndice hash se encuentra restringiendo las coordenadas a valores enteros y luego obteniendo el resto de la divisi√≥n entera por el tama√±o de la tabla.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.x % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.z % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashGrid[x + z * hashGridSize]; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© hace%?</font></font></b> <div class="spoiler_text">   ,     ,    ‚Äî  . ,  ‚àí4, ‚àí3, ‚àí2, ‚àí1, 0, 1, 2, 3, 4 modulo 3   ‚àí1, 0, ‚àí2, ‚àí1, 0, 1, 2, 0, 1. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto funciona para coordenadas positivas, pero no para las negativas, porque para tales n√∫meros el resto ser√° negativo. </font><font style="vertical-align: inherit;">Podemos arreglar esto agregando el tama√±o de la tabla a los resultados negativos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.x % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.z % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { z += hashGridSize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora para cada unidad cuadrada creamos nuestro propio valor. </font><font style="vertical-align: inherit;">Sin embargo, de hecho, no necesitamos tal densidad de tabla. </font><font style="vertical-align: inherit;">Los objetos est√°n separados entre s√≠. </font><font style="vertical-align: inherit;">Podemos estirar la tabla reduciendo la escala de posici√≥n antes de calcular el √≠ndice. </font><font style="vertical-align: inherit;">Un valor √∫nico para un cuadrado de 4 por 4 ser√° suficiente para nosotros.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hashGridScale = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(position.x * hashGridScale) % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(position.z * hashGridScale) % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { z += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashGrid[x + z * hashGridSize]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regresemos </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y usemos nuestra nueva tabla hash para obtener el valor. </font><font style="vertical-align: inherit;">Despu√©s de aplicarlo para especificar la rotaci√≥n, los objetos permanecer√°n estacionarios al editar el terreno.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hash = HexMetrics.SampleHashGrid(position); Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umbral de colocaci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque los objetos tienen rotaciones diferentes, todav√≠a se nota un patr√≥n en su ubicaci√≥n. </font><font style="vertical-align: inherit;">Cada celda tiene siete objetos. </font><font style="vertical-align: inherit;">Podemos agregar caos a este esquema, omitiendo arbitrariamente algunos de los objetos. </font><font style="vertical-align: inherit;">¬øC√≥mo decidimos si agregar un objeto o no? </font><font style="vertical-align: inherit;">¬°Por supuesto, verificando otro valor aleatorio! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, ahora, en lugar de un valor hash, necesitamos dos. </font><font style="vertical-align: inherit;">Su soporte se puede agregar utilizando hashes en lugar de una </font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable </font><font style="vertical-align: inherit;">como el tipo de matriz de tabla </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero las operaciones vectoriales no tienen sentido para los valores hash, as√≠ que creemos una estructura especial para este prop√≥sito. </font><font style="vertical-align: inherit;">Solo necesitar√° dos valores flotantes. </font><font style="vertical-align: inherit;">Y agreguemos un m√©todo est√°tico para crear un par de valores aleatorios.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexHash { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo necesita ser serializado?</font></font></b> <div class="spoiler_text">        ,  ,        Unity. ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√°mbielo </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que use la nueva estructura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexHash[] hashGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexHash[hashGridSize * hashGridSize]; Random.State currentState = Random.state; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = HexHash.Create(); } Random.state = currentState; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene acceso a dos valores hash. </font><font style="vertical-align: inherit;">Usemos el primero para decidir si agregar un objeto u omitirlo. </font><font style="vertical-align: inherit;">Si el valor es igual o mayor que 0.5, omita. </font><font style="vertical-align: inherit;">Al hacerlo, eliminaremos aproximadamente la mitad de los objetos. </font><font style="vertical-align: inherit;">El segundo valor se usar√° como de costumbre para determinar la rotaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.a &gt;= <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.b, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/e69/761/e89e697613f8eef3d149b07720e8a26a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La densidad de los objetos se reduce en un 50%. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dibujar objetos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de colocar objetos en todas partes, hag√°moslos editables. </font><font style="vertical-align: inherit;">Pero no dibujaremos objetos separados, sino que agregaremos el nivel de objetos a cada celda. </font><font style="vertical-align: inherit;">Este nivel controlar√° la probabilidad de que aparezcan objetos en la celda. </font><font style="vertical-align: inherit;">Por defecto, el valor es cero, es decir, los objetos estar√°n ausentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que los cubos rojos en nuestro terreno no se ven como objetos naturales, llam√©moslos edificios. </font><font style="vertical-align: inherit;">Representar√°n la urbanizaci√≥n. </font><font style="vertical-align: inherit;">Agreguemos al </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nivel de urbanizaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UrbanLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (urbanLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { urbanLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urbanLevel;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos hacer que el nivel de urbanizaci√≥n para una celda submarina sea igual a cero, pero esto no es necesario, de todos modos omitimos la creaci√≥n de objetos submarinos. </font><font style="vertical-align: inherit;">Y quiz√°s en alg√∫n momento agregaremos cuerpos de agua de urbanizaci√≥n, como muelles y estructuras submarinas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Control deslizante de densidad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cambiar el nivel de urbanizaci√≥n, agregamos </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un control deslizante m√°s </font><font style="vertical-align: inherit;">en </font><font style="vertical-align: inherit;">apoyo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyUrbanLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyUrbanLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetUrbanLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeUrbanLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue otro control deslizante a la interfaz de usuario y comb√≠nelo con los m√©todos adecuados. </font><font style="vertical-align: inherit;">Colocar√© un nuevo panel en el lado derecho de la pantalla para evitar desbordar el panel izquierdo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°ntos niveles necesitamos? </font><font style="vertical-align: inherit;">Deteng√°monos en cuatro, denotando cero, baja, media y alta densidad.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/e64/996/02fe649968954603df834d2a3b5f633b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/9e4/6f5/95e9e46f5ff83a9b7d713e85db86d67a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de urbanizaci√≥n.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambio de umbral </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que tenemos el nivel de urbanizaci√≥n, necesitamos usarlo para determinar si colocar objetos. </font><font style="vertical-align: inherit;">Para hacer esto, necesitamos agregar el nivel de urbanizaci√≥n como un par√°metro adicional para </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Demos un paso m√°s y simplemente transfiramos la celda. </font><font style="vertical-align: inherit;">En el futuro, ser√° m√°s conveniente para nosotros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s r√°pida de usar el nivel de urbanizaci√≥n es multiplicarlo por 0.25 y usar el valor como el nuevo umbral para saltar objetos. </font><font style="vertical-align: inherit;">Debido a esto, la probabilidad de la aparici√≥n del objeto aumentar√° con cada nivel en un 25%.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.a &gt;= cell.UrbanLevel * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que esto funcione, pasemos las celdas a </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature(cell, (center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature(cell, (center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd8/7e9/de5/fd87e9de5b6b6ea4b4b490549ae5cbf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dibujo de niveles de densidad de urbanizaci√≥n. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varios prefabricados de objetos en relieve </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las diferencias en la probabilidad de que aparezcan objetos no son suficientes para crear una separaci√≥n clara entre los niveles bajos y altos de urbanizaci√≥n. En algunas celdas, simplemente habr√° m√°s o menos que el n√∫mero esperado de edificios. Podemos hacer la diferencia m√°s clara usando nuestro propio prefab para cada nivel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos deshacemos de los campos </font></font><code>featurePrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y sustituirla por una serie de casas prefabricadas urbanizaci√≥n. Para obtener el prefab apropiado, restaremos uno del nivel de urbanizaci√≥n y usaremos el valor como √≠ndice.</font></font><br><br><pre> <code class="cs hljs">&lt;del&gt;<span class="hljs-comment"><span class="hljs-comment">// public Transform featurePrefab;&lt;/del&gt; public Transform[] urbanPrefabs; public void AddFeature (HexCell cell, Vector3 position) { ‚Ä¶ Transform instance = Instantiate(urbanPrefabs[cell.UrbanLevel - 1]); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree dos duplicados de la prefabricaci√≥n del objeto, c√°mbieles el nombre y c√°mbielos para que indiquen tres niveles diferentes de urbanizaci√≥n. </font><font style="vertical-align: inherit;">El nivel 1 es de baja densidad, por lo que utilizamos un cubo con una unidad de longitud de un borde, que denota una choza. </font><font style="vertical-align: inherit;">Escalar√© el nivel 2 prefabricado a (1.5, 2, 1.5) para que parezca un edificio de dos pisos. </font><font style="vertical-align: inherit;">Para edificios altos de nivel 3, utilic√© la escala (2, 5, 2).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b83/4ad/cb6/b834adcb61a34d1e30cdec28925f066f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/41d/552/d4f41d5529d4716924345520ffc36280.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizando diferentes prefabricados para cada nivel de urbanizaci√≥n.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mezcla prefabricada </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No estamos obligados a limitarnos a una separaci√≥n estricta de los tipos de edificios. Puedes mezclarlos un poco, como sucede en el mundo real. En lugar de un umbral por nivel, usemos tres, uno para cada tipo de edificio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el nivel 1 usamos la colocaci√≥n de chozas en el 40% de los casos. No habr√° otros edificios aqu√≠ en absoluto. Para el nivel usamos los tres valores (0.4, 0, 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el nivel 2, reemplaza las chozas con edificios m√°s grandes y agrega un 20% de posibilidades de chozas adicionales. No haremos edificios altos. Es decir, usamos el umbral de tres valores (0.2, 0.4, 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el nivel 3, reemplazamos edificios medianos por edificios altos, reemplazamos chozas nuevamente y agregamos otro 20% de posibilidades de chozas. Los valores de umbral ser√°n iguales a (0.2, 0.2, 0.4).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, la idea es que con un aumento en el nivel de urbanizaci√≥n, mejoraremos los edificios existentes y agregaremos otros nuevos a los lugares vac√≠os. Para eliminar un edificio existente, necesitamos usar los mismos intervalos de valores hash. Si los hashes entre 0 y 0.4 en el nivel 1 eran chozas, entonces en el nivel 3 el mismo intervalo crear√° edificios altos. En el nivel 3, los edificios altos deben crearse con hashes en el rango de 0 a 0.4, edificios de dos pisos en el rango de 0.4 a 0.6 y chozas en el rango de 0.6 a 0.8. Si los verifica de mayor a menor, esto se puede hacer utilizando el triple de umbrales (0.4, 0.6, 0.8). Los umbrales de nivel 2 se convertir√°n en (0, 0.4, 0.6), y los umbrales de nivel 1 se convertir√°n en (0, 0, 0.4). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardemos estos umbrales en</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como una colecci√≥n de matrices con un m√©todo que le permite obtener umbrales para un cierto nivel. </font><font style="vertical-align: inherit;">Como solo estamos interesados ‚Äã‚Äãen niveles con objetos, ignoramos el nivel 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[][] featureThresholds = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFeatureThresholds</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> featureThresholds[level]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, agregue al </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo que utiliza el nivel y el valor hash para seleccionar el prefabricado. </font><font style="vertical-align: inherit;">Si el nivel es mayor que cero, entonces obtenemos umbrales usando un nivel reducido en uno. </font><font style="vertical-align: inherit;">Luego recorremos los umbrales hasta que uno de ellos exceda el valor hash. </font><font style="vertical-align: inherit;">Esto significar√° que hemos encontrado un prefabricado. </font><font style="vertical-align: inherit;">Si no lo encontramos, entonces devuelve nulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanPrefabs[i]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este enfoque requiere reordenar enlaces a prefabricados para que pasen de alta a baja densidad. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/eb5/80e/4dceb580e2410400a003b2ecad72d5c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orden prefabricado invertido. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usaremos nuestro nuevo m√©todo </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para seleccionar un prefabricado. </font><font style="vertical-align: inherit;">Si no lo recibimos, nos saltamos el objeto. </font><font style="vertical-align: inherit;">De lo contrario, cree una instancia y contin√∫e como antes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-comment"><span class="hljs-comment">// if (hash.a &gt;= cell.UrbanLevel * 0.25f) { // return; // } // Transform instance = Instantiate(urbanPrefabs[cell.UrbanLevel - 1]); Transform prefab = PickPrefab(cell.UrbanLevel, hash.a); if (!prefab) { return; } Transform instance = Instantiate(prefab); position.y += instance.localScale.y * 0.5f; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(0f, 360f * hash.b, 0f); instance.SetParent(container, false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d33/6f0/fcb/d336f0fcbf85285b38bb9c3de27ad77f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mezcla los prefabricados.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variaciones de nivel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos edificios bien mezclados, pero hasta ahora solo hay tres. </font><font style="vertical-align: inherit;">Podemos aumentar a√∫n m√°s la variabilidad al vincular una colecci√≥n de prefabricados a cada nivel de densidad de urbanizaci√≥n. </font><font style="vertical-align: inherit;">Despu√©s de eso, ser√° posible elegir uno de ellos al azar. </font><font style="vertical-align: inherit;">Esto requerir√° un nuevo valor aleatorio, as√≠ que agregue un tercer c </font></font><code>HexHash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convirt√°moslo </font></font><code>HexFeatureManager.urbanPrefabs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en una matriz de matrices y agreguemos un </font></font><code>PickPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metro </font><font style="vertical-align: inherit;">al m√©todo </font></font><code>choice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lo usamos para seleccionar el √≠ndice de la matriz incorporada, multiplic√°ndolo por la longitud de esta matriz y convirti√©ndolo en entero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[][] urbanPrefabs; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanPrefabs[i][(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(choice * urbanPrefabs[i].Length)]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Justifiquemos nuestra elecci√≥n sobre el valor del segundo hash (B). </font><font style="vertical-align: inherit;">Entonces debes pasar de B a C.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); Transform prefab = PickPrefab(cell.UrbanLevel, hash.a, hash.b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prefab) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Transform instance = Instantiate(prefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.c, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de continuar, debemos considerar qu√© </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podr√≠a devolver un valor de 1. Debido a esto, el √≠ndice de matriz puede ir m√°s all√°. </font><font style="vertical-align: inherit;">Para evitar que esto suceda, escalemos ligeramente los valores hash. </font><font style="vertical-align: inherit;">Simplemente los escalamos a todos para no preocuparnos por lo espec√≠fico que usamos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafortunadamente, el inspector no muestra matrices de matrices. </font><font style="vertical-align: inherit;">Por lo tanto, no podemos configurarlos. </font><font style="vertical-align: inherit;">Para evitar esta limitaci√≥n, cree una estructura serializable en la que encapsular la matriz incorporada. </font><font style="vertical-align: inherit;">Vamos a darle un m√©todo que convierta de elecci√≥n al √≠ndice de matriz y devuelva un prefabricado.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexFeatureCollection { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[] prefabs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pick</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefabs[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(choice * prefabs.Length)]; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar de las matrices incorporadas, </font><font style="vertical-align: inherit;">utilizamos </font><font style="vertical-align: inherit;">una matriz de tales colecciones.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Transform[][] urbanPrefabs; public HexFeatureCollection[] urbanCollections; ‚Ä¶ Transform PickPrefab (int level, float hash, float choice) { if (level &gt; 0) { float[] thresholds = HexMetrics.GetFeatureThresholds(level - 1); for (int i = 0; i &lt; thresholds.Length; i++) { if (hash &lt; thresholds[i]) { return urbanCollections[i].Pick(choice); } } } return null; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos asignar varios edificios a cada nivel de densidad. </font><font style="vertical-align: inherit;">Como son independientes, no tenemos que usar la misma cantidad por nivel. </font><font style="vertical-align: inherit;">Acabo de usar dos opciones por nivel, agregando una opci√≥n m√°s larga m√°s baja a cada uno. </font><font style="vertical-align: inherit;">Eleg√≠ las escalas para ellos (3.5, 3, 2), (2.75, 1.5, 1.5) y (1.75, 1, 1).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/a6e/c9f/b71a6ec9f2c379c223e007dda071c94b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a72/618/81d/a7261881d23703b54aaf22ba59942d2a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dos tipos de edificios por nivel de densidad. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Varios tipos de objetos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el esquema existente, podemos crear estructuras urbanas bastante dignas. </font><font style="vertical-align: inherit;">Pero el alivio puede contener no solo edificios. </font><font style="vertical-align: inherit;">¬øQu√© tal granjas o plantas? </font><font style="vertical-align: inherit;">Agreguemos a los </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">niveles y para ellos. </font><font style="vertical-align: inherit;">No son mutuamente excluyentes y pueden mezclarse.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FarmLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> farmLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (farmLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { farmLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PlantLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> plantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (plantLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { plantLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urbanLevel, farmLevel, plantLevel;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, esto requiere soporte en </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos controles deslizantes adicionales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel, activeFarmLevel, activePlantLevel; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel, applyFarmLevel, applyPlantLevel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyFarmLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyFarmLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFarmLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeFarmLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyPlantLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyPlantLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPlantLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activePlantLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyFarmLevel) { cell.FarmLevel = activeFarmLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyPlantLevel) { cell.PlantLevel = activePlantLevel; } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agr√©guelos a la IU. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/70b/f35/95670bf35594faa69fe46201b78080f7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tres controles deslizantes.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adem√°s, se necesitar√°n colecciones adicionales </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexFeatureCollection[] urbanCollections, farmCollections, plantCollections;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5d/001/cec/f5d001cecb2bee3c60a0dad637de7dc9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tres colecciones de objetos en relieve.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cre√© para granjas y plantas dos prefabricados por nivel de densidad, as√≠ como para construir colecciones. Para todos ellos, us√© cubos. Las granjas tienen material verde claro, las plantas tienen material verde oscuro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hice cubos de granja con una altura de 0.1 unidades para indicar parcelas cuadradas de tierra agr√≠cola. Como escalas de alta densidad, eleg√≠ (2.5, 0.1, 2.5) y (3.5, 0.1, 2). En promedio, los sitios tienen un √°rea de 1.75 y un tama√±o de 2.5 por 1.25. Se obtuvo un bajo nivel de densidad en el √°rea 1 y un tama√±o de 1,5 por 0,75. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las plantas prefabricadas denotan √°rboles altos y arbustos grandes. Los prefabricados de alta densidad son los m√°s grandes, (1.25, 4.5, 1.25) y (1.5, 3, 1.5). Las escalas promedio son (0.75, 3, 0.75) y (1, 1.5, 1). Las plantas m√°s peque√±as tienen tama√±os (0.5, 1.5, 0.5) y (0.75, 1, 0.75).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selecci√≥n de caracter√≠sticas de alivio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada tipo de objeto debe recibir su propio valor hash para que tengan diferentes patrones de creaci√≥n y pueda mezclarlos. </font><font style="vertical-align: inherit;">Agrega </font></font><code>HexHash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos valores adicionales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c, d, e; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.d = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.e = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tienes </font></font><code>HexFeatureManager.PickPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que trabajar con diferentes colecciones. </font><font style="vertical-align: inherit;">Agregue un par√°metro para simplificar el proceso. </font><font style="vertical-align: inherit;">Adem√°s, cambie el hash utilizado por la variante del prefabricado seleccionado a D, y el hash para la rotaci√≥n a E.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexFeatureCollection[] collection, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection[i].Pick(choice); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); Transform prefab = PickPrefab( urbanCollections, cell.UrbanLevel, hash.a, hash.d ); ‚Ä¶ instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.e, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualmente </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selecciona urbanizaci√≥n prefabricada. </font><font style="vertical-align: inherit;">Esto es normal, necesitamos m√°s opciones. </font><font style="vertical-align: inherit;">Por lo tanto, agregamos otro prefabricado de las granjas. </font><font style="vertical-align: inherit;">Como valor hash, use B. La elecci√≥n de la opci√≥n ser√° nuevamente D.</font></font><br><br><pre> <code class="cs hljs"> Transform prefab = PickPrefab( urbanCollections, cell.UrbanLevel, hash.a, hash.d ); Transform otherPrefab = PickPrefab( farmCollections, cell.FarmLevel, hash.b, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prefab) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© tipo de instancia prefabricada crearemos como resultado? </font><font style="vertical-align: inherit;">Si uno de ellos resulta nulo, entonces la elecci√≥n es obvia. </font><font style="vertical-align: inherit;">Sin embargo, si ambos existen, entonces debemos tomar una decisi√≥n. </font><font style="vertical-align: inherit;">Solo agreguemos el prefab con el valor hash m√°s bajo.</font></font><br><br><pre> <code class="cs hljs"> Transform otherPrefab = PickPrefab( farmCollections, cell.FarmLevel, hash.b, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baf/369/d71/baf369d71420a1ded309880b38d94c53.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una mezcla de objetos urbanos y rurales. </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, haga lo mismo con las plantas usando el valor del hash C.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } otherPrefab = PickPrefab( plantCollections, cell.PlantLevel, hash.c, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.c &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, no podemos simplemente copiar el c√≥digo. </font><font style="vertical-align: inherit;">Cuando elegimos el objeto rural en lugar del urbano, necesitamos comparar el hash de las plantas con el hash de las granjas, y no con el urbano. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos rastrear el hash que decidimos elegir y compararlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> usedHash = hash.a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; usedHash = hash.b; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; usedHash = hash.b; } otherPrefab = PickPrefab( plantCollections, cell.PlantLevel, hash.c, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.c &lt; usedHash) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8eb/2e2/215/8eb2e2215e6219b08e8bc42612b31493.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una mezcla de objetos urbanos, rurales y vegetales. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 10: paredes </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encerramos las celdas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Construimos muros a lo largo de los bordes de las celdas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pasemos por r√≠os y caminos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evite el agua y con√©ctese con los acantilados. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En esta parte agregaremos entre las celdas de la pared. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/924/d07/0cd/924d070cd67c3baccf02a0284ef9cdc4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay nada m√°s atractivo que un muro alto.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edici√≥n de pared </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para soportar las paredes, necesitamos saber d√≥nde colocarlas. </font><font style="vertical-align: inherit;">Los colocaremos entre las celdas a lo largo de los bordes que los conectan. </font><font style="vertical-align: inherit;">Como los objetos ya existentes se encuentran en la parte central de las celdas, no debemos preocuparnos de que las paredes los atraviesen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/bbb/c11/7a1bbbc1158301bb0091638858fa79fd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes a lo largo de los bordes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las paredes son objetos del terreno, aunque grandes. </font><font style="vertical-align: inherit;">Al igual que otros objetos, no los editaremos directamente. </font><font style="vertical-align: inherit;">En cambio, cambiaremos las celdas. </font><font style="vertical-align: inherit;">No tendremos segmentos separados de las paredes, pero nos ocuparemos de encerrar las celdas como un todo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Propiedad amurallada </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para admitir celdas cercadas, agregue a la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad </font></font><code>Walled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es un simple cambio. </font><font style="vertical-align: inherit;">Dado que los muros se encuentran entre las celdas, necesitamos actualizar tanto las celdas editadas como sus vecinas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Walled { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> walled; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (walled != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { walled = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> walled;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interruptor del editor </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cambiar el estado "cercado" de las celdas, necesitamos agregar </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soporte para el cambio. </font><font style="vertical-align: inherit;">Por lo tanto, agregamos otro campo </font></font><code>OptionalToggle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y un m√©todo para configurarlo.</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode, walledMode; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWalledMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { walledMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A diferencia de los r√≠os y las carreteras, los muros no van de celda en celda, sino que se encuentran entre ellos. </font><font style="vertical-align: inherit;">Por lo tanto, no necesitamos pensar en arrastrar y soltar. </font><font style="vertical-align: inherit;">Cuando el interruptor de pared est√° activo, simplemente establecemos el estado cercado de la celda actual en funci√≥n del estado de este interruptor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (walledMode != OptionalToggle.Ignore) { cell.Walled = walledMode == OptionalToggle.Yes; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { ‚Ä¶ } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duplicamos uno de los elementos anteriores de los interruptores de la interfaz de usuario y los cambiamos para que controlen el estado de "cercado". </font><font style="vertical-align: inherit;">Los pondr√© en el panel de la interfaz de usuario junto con otros objetos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ac/f7f/0ca/0acf7f0caaaae171e31d42141fa75947.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El interruptor "cercado". </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creando muros </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como las paredes siguen los contornos de las celdas, no deber√≠an tener una forma constante. </font><font style="vertical-align: inherit;">Por lo tanto, no podemos simplemente usar un prefabricado para ellos, como lo hicimos con otras caracter√≠sticas del terreno. </font><font style="vertical-align: inherit;">En cambio, necesitamos construir una malla, como hicimos con el relieve. </font><font style="vertical-align: inherit;">Esto significa que nuestro fragmento prefabricado necesita otro elemento hijo </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Duplique una de las otras mallas secundarias y haga que los nuevos objetos de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muros</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proyecten </font><font style="vertical-align: inherit;">sombras. </font><font style="vertical-align: inherit;">No necesitan nada excepto v√©rtices y tri√°ngulos, por lo que todas las opciones </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deben estar deshabilitadas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/615/387/31d/61538731d2eed271c9348c4da2f5d844.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bf/c6e/af5/2bfc6eaf5ff31f5467ab252c00b7bcce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes Prefabricadas Subsidiarias. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√° l√≥gico que las paredes sean un objeto urbano, as√≠ que para ellas utilic√© el material rojo de los edificios.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesti√≥n de la pared </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como las paredes son objetos de alivio, deben lidiar con ellas </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por lo tanto, le daremos al administrador de los objetos en relieve un enlace al objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muros</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y haremos que llame a los m√©todos </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh walls; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ walls.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { walls.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/8f9/0f3/31d8f90f315c7aa43910c67aab6b73cb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muros conectados al administrador de topograf√≠a.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo deber√≠an los muros ser hijos de las caracter√≠sticas?</font></font></b> <div class="spoiler_text">       ,   .             ,    <em>Walls</em>    <em>Hex Grid Chunk</em> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos agregar un m√©todo al administrador que nos permita agregarle muros. </font><font style="vertical-align: inherit;">Como las paredes est√°n a lo largo de los bordes entre las celdas, necesita conocer los v√©rtices correspondientes de los bordes y las celdas. </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lo har√° pasar </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en el momento de la triangulaci√≥n de la c√©lula y uno de sus vecinos. </font><font style="vertical-align: inherit;">Desde este punto de vista, la celda actual est√° en el lado cercano de la pared, y la otra est√° en el lado m√°s alejado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamaremos a este nuevo m√©todo </font></font><code>HexGridChunk.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">despu√©s de completar todos los dem√°s trabajos de conexi√≥n e inmediatamente antes de la transici√≥n al tri√°ngulo angular. </font><font style="vertical-align: inherit;">Dejaremos que el administrador de los objetos de relieve decida por s√≠ mismo d√≥nde deber√≠a ubicarse realmente el muro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ } features.AddWall(e1, cell, e2, neighbor); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ‚Ä¶ } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Construye un segmento de muro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toda la pared serpentear√° a trav√©s de varios bordes de las celdas. </font><font style="vertical-align: inherit;">Cada borde contiene solo un elemento de pared. </font><font style="vertical-align: inherit;">Desde el punto de vista de la celda cercana, el segmento comienza en el lado izquierdo de la costilla y termina en el derecho. </font><font style="vertical-align: inherit;">Agreguemos a un </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo separado que usa cuatro v√©rtices en las esquinas de un borde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/2a0/d7b/f322a0d7bc325b13f65c62cfb76b2d0c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lados cercanos y lejanos. </font></font></i> <br><br> <code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede llamar a este m√©todo con los bordes primero y √∫ltimo de los bordes. </font><font style="vertical-align: inherit;">Pero las paredes solo deben agregarse cuando tenemos una conexi√≥n entre una celda cercada y una celda no cercada. </font><font style="vertical-align: inherit;">No importa cu√°l de las celdas est√© adentro y cu√°l afuera, solo se tiene en cuenta la diferencia en sus estados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v5, far.v5); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El segmento m√°s simple de la pared es un quad, parado en el medio de la costilla. </font><font style="vertical-align: inherit;">Encontraremos sus picos m√°s bajos, interpolando al medio desde los picos m√°s cercanos a los m√°s lejanos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© tan alto debe ser el muro? </font><font style="vertical-align: inherit;">Vamos a establecer su altura a </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Los hice del tama√±o de un nivel de altura de celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallHeight = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br> <code>HexFeatureManager.AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede usar esta altura para colocar los v√©rtices tercero y cuarto del quad, y tambi√©n agregarlo a la malla </font></font><code>walls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 v1, v2, v3, v4; v1 = v3 = left; v2 = v4 = right; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos editar las paredes y se mostrar√°n como rayas cu√°druples. </font><font style="vertical-align: inherit;">Sin embargo, no veremos un muro continuo. </font><font style="vertical-align: inherit;">Cada quad es visible solo en un lado. </font><font style="vertical-align: inherit;">Su cara est√° dirigida hacia la c√©lula desde la que se agreg√≥.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/2f0/442/e5a2f0442a2d1812b73dd2977d80d565.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuadr√≠culas de un lado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos resolver r√°pidamente este problema agregando un segundo quad mirando hacia el otro lado.</font></font><br><br><pre> <code class="cs hljs"> walls.AddQuad(v1, v2, v3, v4); walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/302/e53/129/302e53129e87c3432848772688e9d896.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes bilaterales. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora todas las paredes son visibles en su totalidad, pero todav√≠a hay agujeros en las esquinas de las celdas donde se unen las tres celdas. </font><font style="vertical-align: inherit;">Los completaremos m√°s tarde.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paredes gruesas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque las paredes ya son visibles en ambos lados, no tienen grosor. </font><font style="vertical-align: inherit;">De hecho, las paredes son delgadas, como el papel, y casi invisibles en cierto √°ngulo. </font><font style="vertical-align: inherit;">As√≠ que hag√°moslos completos agregando grosor. </font><font style="vertical-align: inherit;">Establecer su grosor en </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eleg√≠ un valor de 0,75 unidades, me pareci√≥ adecuado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallThickness = <span class="hljs-number"><span class="hljs-number">0.75f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer dos paredes gruesas, debe separar dos quads a los lados. </font><font style="vertical-align: inherit;">Deben moverse en direcciones opuestas. </font><font style="vertical-align: inherit;">Un lado debe moverse hacia el borde cercano, el otro hacia el borde lejano. </font><font style="vertical-align: inherit;">El vector de desplazamiento para esto es igual </font></font><code>far - near</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero para dejar la parte superior de la pared plana, necesitamos establecer su componente Y en 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que esto debe hacerse para los lados izquierdo y derecho del segmento de pared, agreguemos un </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector de desplazamiento </font><font style="vertical-align: inherit;">al </font><font style="vertical-align: inherit;">m√©todo para calcular esto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallThicknessOffset</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { Vector3 offset; offset.x = far.x - near.x; offset.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; offset.z = far.z - near.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que la pared permanezca en el centro de la costilla, la distancia real de movimiento a lo largo de este vector debe ser igual a la mitad del grosor de cada lado. </font><font style="vertical-align: inherit;">Y para asegurarnos de que realmente nos movemos a la distancia correcta, normalizamos el vector de desplazamiento antes de escalarlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset.normalized * (wallThickness * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizamos este m√©todo </font></font><code>HexFeatureManager.AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para cambiar la posici√≥n de los quads. </font><font style="vertical-align: inherit;">Dado que el vector de desplazamiento va desde la celda m√°s cercana a la lejana, restarlo del quad cercano y sumar a la lejana.</font></font><br><br><pre> <code class="cs hljs"> Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 leftThicknessOffset = HexMetrics.WallThicknessOffset(nearLeft, farLeft); Vector3 rightThicknessOffset = HexMetrics.WallThicknessOffset(nearRight, farRight); Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4); v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/746/08b/df774608b2b06114b4afbc6ec2904e61.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes con compensaciones. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los quads ahora est√°n sesgados, aunque esto no es del todo notable.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øSon los espesores de pared iguales?</font></font></b> <div class="spoiler_text">    ,      ¬´-¬ª     .      ,    .       .       ,   .    ,    .  , -      ,     .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tapas de las paredes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer que el grosor de la pared sea visible desde arriba, necesitamos agregar un quad a la parte superior de la pared. </font><font style="vertical-align: inherit;">La forma m√°s f√°cil de hacer esto es recordar los dos v√©rtices superiores del primer quad y conectarlos con los dos v√©rtices superiores del segundo quad.</font></font><br><br><pre> <code class="cs hljs"> Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4); Vector3 t1 = v3, t2 = v4; v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v2, v1, v4, v3); walls.AddQuad(t1, t2, v3, v4);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/15d/627/1d715d627770a9e7a17bf135a461833d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes con encimeras.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arrinconar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todav√≠a tenemos agujeros en las esquinas de las celdas. </font><font style="vertical-align: inherit;">Para llenarlos, necesitamos agregar un segmento al √°rea triangular entre las celdas. </font><font style="vertical-align: inherit;">Cada esquina conecta tres celdas. </font><font style="vertical-align: inherit;">Cada celda puede o no tener una pared. </font><font style="vertical-align: inherit;">Es decir, son posibles ocho configuraciones.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/277/8ee/ed92778ee39106d3a448892a124d366c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuraciones de √°ngulo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colocamos paredes solo entre celdas con diferentes estados vallados. </font><font style="vertical-align: inherit;">Esto reduce el n√∫mero de configuraciones a seis. </font><font style="vertical-align: inherit;">En cada una de ellas, una de las celdas est√° dentro de la curva de las paredes. </font><font style="vertical-align: inherit;">Consideremos esta celda como un punto de referencia alrededor del cual se curva la pared. </font><font style="vertical-align: inherit;">Desde el punto de vista de esta celda, el muro comienza con un borde com√∫n con la celda izquierda y termina con un borde com√∫n con la celda derecha.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/f68/19a/48ef6819a839339a17d1513f7ca546b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roles celulares. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, necesitamos crear un m√©todo </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuyos par√°metros sean tres v√©rtices de la esquina. </font><font style="vertical-align: inherit;">Aunque podemos escribir c√≥digo para triangular este segmento, de hecho es un caso especial del m√©todo </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Un punto de anclaje juega el papel de ambos v√©rtices cercanos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, cree una variante del m√©todo </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para los tres v√©rtices del √°ngulo y sus celdas. </font><font style="vertical-align: inherit;">El objetivo de este m√©todo es determinar el √°ngulo, que es el punto de referencia, si existe. </font><font style="vertical-align: inherit;">Por lo tanto, debe considerar las ocho configuraciones posibles y solicitar </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seis de ellas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 c1, HexCell cell1, Vector3 c2, HexCell cell2, Vector3 c3, HexCell cell3 </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell1.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell2.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell3.Walled) { AddWallSegment(c3, cell3, c1, cell1, c2, cell2); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c2, cell2, c3, cell3, c1, cell1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallSegment(c1, cell1, c2, cell2, c3, cell3); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell2.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c1, cell1, c2, cell2, c3, cell3); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallSegment(c2, cell2, c3, cell3, c1, cell1); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c3, cell3, c1, cell1, c2, cell2); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para agregar segmentos de esquina, llame a este m√©todo al final </font></font><code>HexGridChunk.TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/e63/304/a8ee63304fce04d4db9dcdf46076b3a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes con esquinas, pero todav√≠a hay agujeros.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cerrar los agujeros </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todav√≠a hay agujeros en las paredes porque la altura de los segmentos de la pared es variable. Mientras que los segmentos a lo largo de los bordes son de altura constante, los segmentos de esquina est√°n entre dos bordes diferentes. Como cada borde puede tener su propia altura, aparecen agujeros en las esquinas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para solucionar esto, c√°mbielo </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que almacene por separado las coordenadas Y de los v√©rtices superiores izquierdo y derecho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> leftTop = left.y + HexMetrics.wallHeight; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rightTop = right.y + HexMetrics.wallHeight; Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = leftTop; v4.y = rightTop; walls.AddQuad(v1, v2, v3, v4); Vector3 t1 = v3, t2 = v4; v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = leftTop; v4.y = rightTop; walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/f1d/a88/9cdf1da889ce427e1d519a284532d6a8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muros cerrados.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las paredes ahora est√°n cerradas, pero probablemente todav√≠a veas agujeros en las sombras de la pared. Esto se debe al par√°metro </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal Bias</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font><font style="vertical-align: inherit;">configuraci√≥n de sombra direccional. Cuando es mayor que cero, los tri√°ngulos de los objetos que proyectan una sombra se mueven a lo largo de la superficie normal. Esto evita el sombreado autom√°tico, pero al mismo tiempo crea agujeros en los casos en que los tri√°ngulos miran en diferentes direcciones. En este caso, se pueden crear agujeros en las sombras de geometr√≠a fina, por ejemplo, como nuestras paredes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede deshacerse de estos artefactos de sombra reduciendo el sesgo normal a cero. O cambie el modo de </font><font style="vertical-align: inherit;">muro de representaci√≥n de malla </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cast Shadows</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two Sided</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto har√° que el objeto de sombra proyecte ambos lados de cada tri√°ngulo de pared para renderizar, lo que cerrar√° todos los agujeros.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/9d5/d0b/b149d5d0bb36f049faa5ca9d49261618.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay m√°s agujeros en las sombras. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pared de la repisa </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, nuestras paredes son lo suficientemente rectas. </font><font style="vertical-align: inherit;">Para un terreno plano, esto no es malo en absoluto, pero parece extra√±o cuando las paredes coinciden con las repisas. </font><font style="vertical-align: inherit;">Esto sucede cuando hay una diferencia de un nivel de altura entre celdas en lados opuestos de la pared.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/065/481/c1a/065481c1a0859ced22d0ae6568acbe86.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muros rectos en las repisas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sigue el borde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de crear un segmento para todo el borde, crearemos uno para cada parte de la tira de borde. </font><font style="vertical-align: inherit;">Podemos hacer esto llamando cuatro veces </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la versi√≥n de </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">borde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); AddWallSegment(near.v2, far.v2, near.v3, far.v3); AddWallSegment(near.v3, far.v3, near.v4, far.v4); AddWallSegment(near.v4, far.v4, near.v5, far.v5); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/8aa/0f9/a968aa0f984b31e81dc9edb12e8d31bb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muros curvos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las paredes ahora repiten la forma de los bordes distorsionados. </font><font style="vertical-align: inherit;">En combinaci√≥n con las repisas, se ve mucho mejor. </font><font style="vertical-align: inherit;">Adem√°s, crea paredes m√°s interesantes en un relieve plano.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colocar muros en el suelo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mirando las paredes en las repisas, puede encontrar un problema. ¬°Las paredes cuelgan sobre el suelo! Esto es cierto para los bordes planos inclinados, pero generalmente no es tan notable.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/039/8f0/a59/0398f0a59aca756824e162c3fba5a891.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes colgando en el aire.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para resolver el problema, necesitamos bajar las paredes. La forma m√°s f√°cil es bajar toda la pared para que su parte superior permanezca plana. Al mismo tiempo, una parte de la pared en la parte superior bajar√° ligeramente hacia el relieve, pero esto nos conviene. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para bajar la pared, necesitamos determinar qu√© lado es m√°s bajo, cerca o lejos. Podemos usar la altura del lado m√°s bajo, pero no necesitamos bajar tanto. Puede interpolar la coordenada Y de menor a mayor con un desplazamiento de poco menos de 0,5. Dado que las paredes solo ocasionalmente se vuelven m√°s altas que el escal√≥n inferior de la repisa, podemos usar el escal√≥n vertical de la repisa como compensaci√≥n. Un espesor de pared diferente de la configuraci√≥n de la repisa puede requerir un desplazamiento diferente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/960/61c/817/96061c817bfdc69db9682e0799ba3751.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El muro bajado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agreguemos al </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>WallLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que trata con esta interpolaci√≥n, adem√°s de promediar las coordenadas X y Z de los v√©rtices cercano y lejano. </font><font style="vertical-align: inherit;">Se basa en un m√©todo </font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallElevationOffset = verticalTerraceStepSize; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near.x += (far.x - near.x) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; near.z += (far.z - near.z) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = near.y &lt; far.y ? wallElevationOffset : (<span class="hljs-number"><span class="hljs-number">1f</span></span> - wallElevationOffset); near.y += (far.y - near.y) * v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> near; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuerce </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este m√©todo para determinar los v√©rtices izquierdo y derecho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { Vector3 left = HexMetrics.WallLerp(nearLeft, farLeft); Vector3 right = HexMetrics.WallLerp(nearRight, farRight); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/957/a4c/b49/957a4cb498eb8a712064a0b99a4041be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes de pie en el suelo.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambio de distorsi√≥n de la pared </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora nuestras paredes est√°n de acuerdo con las diferencias de altura. Pero todav√≠a no se corresponden completamente con los bordes distorsionados, aunque est√°n cerca de ellos. Esto sucedi√≥ porque primero determinamos la parte superior de las paredes y luego las distorsionamos. Dado que estos v√©rtices est√°n en alg√∫n lugar entre los v√©rtices de los bordes cercanos y lejanos, su distorsi√≥n ser√° ligeramente diferente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El hecho de que las paredes sigan incorrectamente las costillas no es un problema. Sin embargo, la distorsi√≥n de la parte superior de la pared cambia de otro modo el espesor relativamente uniforme. Si arreglamos los muros en base a v√©rtices distorsionados, y luego agregamos quads sin distorsi√≥n, su grosor no deber√≠a variar mucho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { nearLeft = HexMetrics.Perturb(nearLeft); farLeft = HexMetrics.Perturb(farLeft); nearRight = HexMetrics.Perturb(nearRight); farRight = HexMetrics.Perturb(farRight); ‚Ä¶ walls.AddQuadUnperturbed(v1, v2, v3, v4); ‚Ä¶ walls.AddQuadUnperturbed(v2, v1, v4, v3); walls.AddQuadUnperturbed(t1, t2, v3, v4); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/fa3/03d/b10fa303dc91a50665bf92b47feed5e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las partes superiores sin distorsiones de las paredes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias a este enfoque, las paredes ya no seguir√°n los bordes con tanta precisi√≥n como antes. </font><font style="vertical-align: inherit;">Pero a cambio se volver√°n menos rotos y tendr√°n un grosor m√°s constante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d38/7f6/b6f/d387f6b6f1c4fed424d2582a8ef5c12c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espesor de pared m√°s consistente. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agujeros en las paredes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, hemos ignorado la posibilidad de que un r√≠o o una carretera crucen el muro. </font><font style="vertical-align: inherit;">Cuando esto sucede, debemos hacer un agujero en la pared a trav√©s del cual pueda pasar un r√≠o o una carretera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, agregue </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos par√°metros booleanos para indicar si un r√≠o o camino pasa a trav√©s de un borde. </font><font style="vertical-align: inherit;">Aunque podemos manejarlos de manera diferente, simplemente eliminemos los dos segmentos medios en ambos casos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver || hasRoad) { <span class="hljs-comment"><span class="hljs-comment">// Leave a gap. } else { AddWallSegment(near.v2, far.v2, near.v3, far.v3); AddWallSegment(near.v3, far.v3, near.v4, far.v4); } AddWallSegment(near.v4, far.v4, near.v5, far.v5); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>HexGridChunk.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deber√≠a proporcionar los datos necesarios. </font><font style="vertical-align: inherit;">Como ya necesitaba la misma informaci√≥n, almac√©nela en variables booleanas y grabemos las llamadas a los m√©todos correspondientes solo una vez.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRiver = cell.HasRiverThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoad = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.Color, e2, neighbor.Color, hasRoad); } features.AddWall(e1, cell, e2, neighbor, hasRiver, hasRoad); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/d05/425/64cd0542540b5d9347a071d727fe2fa4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los agujeros en las paredes para el paso de r√≠os y caminos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cubrimos las paredes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estas nuevas aberturas crean lugares para completar las paredes. </font><font style="vertical-align: inherit;">Necesitamos cerrar estos puntos finales con quads para que no podamos mirar a trav√©s de los lados de las paredes. </font><font style="vertical-align: inherit;">Creemos un </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font><font style="vertical-align: inherit;">para este prop√≥sito </font></font><code>AddWallCap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Funciona como </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero solo necesita un par de picos cercanos y lejanos. </font><font style="vertical-align: inherit;">Haz que agregue un quad, yendo desde el lado m√°s cercano al m√°s alejado de la pared.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallCap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near = HexMetrics.Perturb(near); far = HexMetrics.Perturb(far); Vector3 center = HexMetrics.WallLerp(near, far); Vector3 thickness = HexMetrics.WallThicknessOffset(near, far); Vector3 v1, v2, v3, v4; v1 = v3 = center - thickness; v2 = v4 = center + thickness; v3.y = v4.y = center.y + HexMetrics.wallHeight; walls.AddQuadUnperturbed(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descubre que necesitamos un agujero, agregamos una cubierta entre el segundo y el cuarto par de bordes de los bordes. </font><font style="vertical-align: inherit;">Para el cuarto par de v√©rtices, debe cambiar la orientaci√≥n, de lo contrario, la cara cu√°druple se ver√° hacia adentro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver || hasRoad) { AddWallCap(near.v2, far.v2); AddWallCap(far.v4, near.v4); } ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/98c/828/41398c82892a2c1f706ca85c9230813a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agujeros cerrados en las paredes.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© pasa con los agujeros alrededor de los bordes del mapa?</font></font></b> <div class="spoiler_text">   ,     .        .    ,        . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar los acantilados y el agua. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, veamos los bordes que contienen acantilados o agua. </font><font style="vertical-align: inherit;">Dado que los acantilados son esencialmente paredes grandes, ser√≠a il√≥gico colocar una pared adicional sobre ellos. </font><font style="vertical-align: inherit;">Adem√°s, se ver√° mal. </font><font style="vertical-align: inherit;">Los muros submarinos tambi√©n son completamente il√≥gicos, como lo es la restricci√≥n de los muros de la costa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/94e/027/45a94e027094c6ebdae0763663d6eb8e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes en acantilados y en el agua. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos eliminar las paredes de estos bordes innecesarios con controles adicionales </font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Una pared no puede estar debajo del agua, y una costilla com√∫n con ella no puede ser un acantilado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( nearCell.Walled != farCell.Walled &amp;&amp; !nearCell.IsUnderwater &amp;&amp; !farCell.IsUnderwater &amp;&amp; nearCell.GetEdgeType(farCell) != HexEdgeType.Cliff ) { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/baf/75a/128baf75ace7d0cf4ed5f12ef380eec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se eliminaron las paredes obstructoras a lo largo de las costillas, pero las esquinas permanecieron en su lugar.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eliminar esquinas de la pared </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminar segmentos de esquina innecesarios requerir√° un poco m√°s de esfuerzo. </font><font style="vertical-align: inherit;">El caso m√°s simple es cuando la celda de soporte est√° bajo el agua. </font><font style="vertical-align: inherit;">Esto asegura que no haya segmentos de pared cercanos que puedan conectarse.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pivotCell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/475/9f3/ecc4759f38ced7802ad8743626f91d51.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay m√°s c√©lulas de soporte bajo el agua. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos que mirar otras dos celdas. </font><font style="vertical-align: inherit;">Si uno de ellos est√° bajo el agua o conectado a la celda de soporte por una ruptura, entonces no hay pared a lo largo de esta costilla. </font><font style="vertical-align: inherit;">Si esto es cierto para al menos un lado, entonces no deber√≠a haber un segmento de pared en esta esquina. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determinamos individualmente si hay una pared izquierda o derecha. </font><font style="vertical-align: inherit;">Ponemos los resultados en variables booleanas para que sea m√°s f√°cil trabajar con ellos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pivotCell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasLeftWall = !leftCell.IsUnderwater &amp;&amp; pivotCell.GetEdgeType(leftCell) != HexEdgeType.Cliff; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRighWall = !rightCell.IsUnderwater &amp;&amp; pivotCell.GetEdgeType(rightCell) != HexEdgeType.Cliff; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall &amp;&amp; hasRighWall) { AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/f17/82d/8cdf1782d522d5b9e19e461ee5253436.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se eliminaron todos los √°ngulos interferentes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cierra las esquinas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando no hay muro en el borde izquierdo o derecho, el trabajo se completa. </font><font style="vertical-align: inherit;">Pero si la pared est√° en una sola direcci√≥n, significa que hay otro agujero en la pared. </font><font style="vertical-align: inherit;">Por lo tanto, debe cerrarlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallSegment(pivot, left, pivot, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(pivot, left); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallCap(right, pivot); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20e/c4d/176/20ec4d17689500d123fc5fd41d447e88.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cerramos los muros.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conexi√≥n de paredes con acantilados. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En una situaci√≥n, las paredes se ven imperfectas. </font><font style="vertical-align: inherit;">Cuando la pared llega al fondo del acantilado, termina. </font><font style="vertical-align: inherit;">Pero como los acantilados no son completamente verticales, se crea un agujero estrecho entre la pared y el borde del acantilado. </font><font style="vertical-align: inherit;">En la cima del acantilado, tal problema no surge.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/5c6/9a7/6335c69a7f45dcd1c2a0609503b2504a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agujeros entre paredes y caras de acantilados. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√≠a mucho mejor si la pared continuara hasta el borde del acantilado. </font><font style="vertical-align: inherit;">Podemos hacer esto agregando otro segmento de pared entre el extremo actual de la pared y la esquina superior del acantilado. </font><font style="vertical-align: inherit;">Dado que la mayor√≠a de este segmento estar√° oculto dentro del acantilado, podemos hacerlo sin reducir el grosor de la pared dentro del acantilado a cero. </font><font style="vertical-align: inherit;">Por lo tanto, es suficiente para nosotros crear una cu√±a: dos quads que van al punto y un tri√°ngulo sobre ellos. </font><font style="vertical-align: inherit;">Creemos un m√©todo para este prop√≥sito </font></font><code>AddWallWedge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto se puede hacer copiando </font></font><code>AddWallCap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y agregando un punto de cu√±a.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallWedge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far, Vector3 point</span></span></span><span class="hljs-function">)</span></span> { near = HexMetrics.Perturb(near); far = HexMetrics.Perturb(far); point = HexMetrics.Perturb(point); Vector3 center = HexMetrics.WallLerp(near, far); Vector3 thickness = HexMetrics.WallThicknessOffset(near, far); Vector3 v1, v2, v3, v4; Vector3 pointTop = point; point.y = center.y; v1 = v3 = center - thickness; v2 = v4 = center + thickness; v3.y = v4.y = pointTop.y = center.y + HexMetrics.wallHeight; <span class="hljs-comment"><span class="hljs-comment">// walls.AddQuadUnperturbed(v1, v2, v3, v4); walls.AddQuadUnperturbed(v1, point, v3, pointTop); walls.AddQuadUnperturbed(point, v2, pointTop, v4); walls.AddTriangleUnperturbed(pointTop, v3, v4); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En las </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esquinas, llamaremos a este m√©todo cuando el muro va en una sola direcci√≥n y este muro est√° a una altura m√°s baja que el otro lado. </font><font style="vertical-align: inherit;">Es en estas condiciones que encontramos el borde de un acantilado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallSegment(pivot, left, pivot, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { AddWallWedge(pivot, left, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(pivot, left); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightCell.Elevation &lt; leftCell.Elevation) { AddWallWedge(right, pivot, left); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(right, pivot); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/30f/33a/b5c30f33ac93582e2ce319996d9ed1ac.png"></div><br> <i> ,   .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">unitypackage</a> <br><br><h1>  11:    </h1><br><ul><li>    . </li><li>     . </li><li>     . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a07/5ea/ef5a075ea4c14c810825388be274f817.jpg"></div><br> <i>  .</i> <br><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la parte anterior, agregamos soporte de pared. Estos son segmentos simples de pared recta sin diferencias aparentes. Ahora haremos que los muros sean m√°s interesantes agreg√°ndoles torres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los segmentos de muro deben crearse de manera procesal para que coincidan con el relieve. Esto no es necesario para las torres, podemos usar el prefabricado habitual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos crear una torre simple de dos cubos con material rojo. La base de la torre tiene un tama√±o de 2 por 2 unidades y una altura de 4 unidades, es decir, es m√°s gruesa y m√°s alta que la pared. Sobre este cubo colocaremos un cubo unitario que denota la parte superior de la torre. Como todos los otros prefabricados, estos cubos no requieren colisionadores.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como el modelo de la torre consta de varios objetos, los convertimos en hijos del objeto ra√≠z. </font><font style="vertical-align: inherit;">Col√≥quelos de modo que el origen local de la ra√≠z est√© en la base de la torre. </font><font style="vertical-align: inherit;">Gracias a esto, podemos colocar las torres sin preocuparnos por su altura.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f1/a54/335/2f1a54335d81a6682707e740107362c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Torre prefabricada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un enlace a este prefabricado </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y con√©ctelo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform wallTower;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f76/df1/c7e/f76df1c7e5b1c808d2ae636f7e823487.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlace a la torre prefabricada.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Construyendo torres </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos colocando torres en el medio de cada segmento de pared. </font><font style="vertical-align: inherit;">Para hacer esto, crearemos una torre al final del m√©todo </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Su posici√≥n ser√° el promedio de los puntos izquierdo y derecho del segmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/559/541/487/559541487b79dd6877b4456dbdf010b1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una torre por segmento de pared. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos muchas torres a lo largo del muro, pero su orientaci√≥n no cambia. </font><font style="vertical-align: inherit;">Necesitamos cambiar su rotaci√≥n para que se alineen con la pared. </font><font style="vertical-align: inherit;">Como tenemos los puntos derecho e izquierdo del muro, sabemos qu√© direcci√≥n es la correcta. </font><font style="vertical-align: inherit;">Podemos utilizar este conocimiento para determinar la orientaci√≥n del segmento del muro y, por lo tanto, de la torre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de calcular la rotaci√≥n nosotros mismos, simplemente asignamos un </font></font><code>Transform.right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vector a la </font><font style="vertical-align: inherit;">propiedad </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El c√≥digo de unidad cambiar√° la rotaci√≥n del objeto para que su direcci√≥n local derecha corresponda con el vector transmitido.</font></font><br><br><pre> <code class="cs hljs"> Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Vector3 rightDirection = right - left; rightDirection.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; towerInstance.transform.right = rightDirection; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/2c3/777/5d32c3777d5b63db90ddf9f8fbbf1dee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las torres est√°n alineadas con la pared.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo funciona la asignaci√≥n Transform.right?</font></font></b> <div class="spoiler_text">     <code>Quaternion.FromToRotation</code>   .   . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 right { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotation * Vector3.right; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { rotation = Quaternion.FromToRotation(Vector3.right, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduce la cantidad de torres </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una torre por segmento de pared es demasiado. </font><font style="vertical-align: inherit;">Hagamos que la adici√≥n de la torre sea opcional agregando un </font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metro </font><font style="vertical-align: inherit;">al </font><font style="vertical-align: inherit;">booleano. </font><font style="vertical-align: inherit;">Aj√∫stelo al valor predeterminado </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En este caso, todas las torres desaparecer√°n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addTower = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addTower) { Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Vector3 rightDirection = right - left; rightDirection.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; towerInstance.transform.right = rightDirection; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coloquemos las torres solo en las esquinas de las celdas. </font><font style="vertical-align: inherit;">Como resultado, obtenemos menos torres con distancias bastante constantes entre ellas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ AddWallSegment(pivot, left, pivot, right, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/823/d7b/d60823d7b381eccaf5916bf2bc636061.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las torres est√°n solo en las esquinas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ve lo suficientemente bien, pero es posible que necesitemos una colocaci√≥n menos peri√≥dica de las torres. </font><font style="vertical-align: inherit;">Al igual que con otras caracter√≠sticas del terreno, podemos usar la tabla hash para decidir si colocar la torre en una esquina. </font><font style="vertical-align: inherit;">Para hacer esto, usamos el centro de la esquina para muestrear la tabla, y luego compararemos uno de los valores hash con el valor umbral de las torres.</font></font><br><br><pre> <code class="cs hljs"> HexHash hash = HexMetrics.SampleHashGrid( (pivot + left + right) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasTower = hash.e &lt; HexMetrics.wallTowerThreshold; AddWallSegment(pivot, left, pivot, right, hasTower);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El valor umbral se refiere a </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Con un valor de 0.5, se crear√°n torres en la mitad de los casos, pero podemos crear muros con muchas torres o sin ellas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallTowerThreshold = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b54/40c/f0f/b5440cf0ffa4f615f2dcbf37532bbb0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Torres aleatorias.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quitamos las torres de las laderas. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora colocamos torres independientemente de la forma del terreno. </font><font style="vertical-align: inherit;">Sin embargo, en las laderas de la torre parece il√≥gico. </font><font style="vertical-align: inherit;">Aqu√≠ las paredes van en √°ngulo y pueden cortar la parte superior de la torre.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24c/c5e/2dd/24cc5e2ddb97b83d14e0826bc64e3f20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Torres en las laderas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar pendientes, verificaremos si las celdas de las esquinas derecha e izquierda est√°n a la misma altura. </font><font style="vertical-align: inherit;">Solo en este caso es posible colocar una torre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasTower = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation == rightCell.Elevation) { HexHash hash = HexMetrics.SampleHashGrid( (pivot + left + right) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>) ); hasTower = hash.e &lt; HexMetrics.wallTowerThreshold; } AddWallSegment(pivot, left, pivot, right, hasTower);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/770/1b4/fd9/7701b4fd9d0a4952fce2a9e00bbb4571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay m√°s torres en las paredes de las laderas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ponemos las paredes y torres en el suelo. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque evitamos las paredes en pendientes, el relieve en ambos lados de la pared puede tener alturas diferentes. </font><font style="vertical-align: inherit;">Las paredes pueden correr a lo largo de las repisas, y las celdas de la misma altura pueden tener diferentes posiciones verticales. </font><font style="vertical-align: inherit;">Debido a esto, la base de la torre puede estar en el aire.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/4d8/b10/cd24d8b1012804af5d073c3901c874ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Torres en el aire. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, las paredes en las pendientes tambi√©n pueden colgar en el aire, pero esto no es tan notable como en las torres.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b6/ae3/d24/8b6ae3d2489f253ae1a78593af0abd6c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las paredes est√°n en el aire. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se puede solucionar estirando la base de las paredes y torres hasta el suelo. </font><font style="vertical-align: inherit;">Para hacer esto, agregue el desplazamiento Y para las paredes </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Una unidad abajo ser√° suficiente. </font><font style="vertical-align: inherit;">Aumenta la altura de las torres en la misma cantidad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallHeight = <span class="hljs-number"><span class="hljs-number">4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallYOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo cambiamos </font></font><code>HexMetrics.WallLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que al determinar la coordenada Y, tenga en cuenta el nuevo desplazamiento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near.x += (far.x - near.x) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; near.z += (far.z - near.z) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = near.y &lt; far.y ? wallElevationOffset : (<span class="hljs-number"><span class="hljs-number">1f</span></span> - wallElevationOffset); near.y += (far.y - near.y) * v + wallYOffset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> near; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n tenemos que cambiar el prefabricado de la torre, ya que la base ahora estar√° a una unidad por debajo del suelo. </font><font style="vertical-align: inherit;">Por lo tanto, aumentamos la altura del cubo base en una unidad y, en consecuencia, cambiamos la posici√≥n local de los cubos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/e4e/503/f2de4e50398fbae4ee296737dbe3a922.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecd/5d7/0eb/ecd5d70ebb620e3bae84f17aedb4a2a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muros y torres en el suelo. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2>  Puentes </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta etapa, tenemos r√≠os y carreteras, pero las carreteras no pueden cruzar r√≠os de ninguna manera. </font><font style="vertical-align: inherit;">Es el momento adecuado para agregar puentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos con un cubo escalado simple que desempe√±ar√° el papel de un puente prefabricado. </font><font style="vertical-align: inherit;">El ancho de los r√≠os var√≠a, pero hay aproximadamente siete unidades de distancia entre los centros de carreteras en ambos lados. </font><font style="vertical-align: inherit;">Por lo tanto, le damos una escala aproximada (3, 1, 7). </font><font style="vertical-align: inherit;">Agregue material urbano rojo prefabricado y elimine su colisionador. </font><font style="vertical-align: inherit;">Al igual que con las torres, coloque el cubo dentro del objeto ra√≠z con la misma escala. </font><font style="vertical-align: inherit;">Debido a esto, la geometr√≠a del puente en s√≠ no ser√° importante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un enlace al prefabricado del puente </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y as√≠gnele un prefabricado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform wallTower, bridge;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/808/ac6/dc5/808ac6dc523d16d2005da48dcf4d1f65.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puente prefabricado asignado.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colocaci√≥n de puentes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para colocar el puente, necesitamos un m√©todo </font></font><code>HexFeatureManager.AddBridge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El puente debe ubicarse entre el centro del r√≠o y uno de los lados del r√≠o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 roadCenter1, Vector3 roadCenter2</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transmitiremos centros de carreteras no distorsionados, por lo que tendremos que distorsionarlos antes de colocar el puente. </font></font><br><br><pre> <code class="cs hljs"> roadCenter1 = HexMetrics.Perturb(roadCenter1); roadCenter2 = HexMetrics.Perturb(roadCenter2); Transform instance = Instantiate(bridge);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para alinear correctamente el puente, podemos usar el mismo enfoque que al girar las torres. </font><font style="vertical-align: inherit;">En este caso, los centros de carreteras definen el vector delantero del puente. </font><font style="vertical-align: inherit;">Dado que permanecemos dentro de la misma celda, este vector definitivamente ser√° horizontal, por lo que no necesitamos poner a cero su componente Y.</font></font><br><br><pre> <code class="cs hljs"> Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.forward = roadCenter2 - roadCenter1; instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Construimos puentes a trav√©s de r√≠os rectos. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las √∫nicas configuraciones de r√≠os que requieren puentes son rectas y curvas. Las carreteras pueden pasar por puntos finales, y en zigzag las carreteras solo pueden estar cerca. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para comenzar, descubramos r√≠os rectos. En el interior, el </font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primer operador </font></font><code>else if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">organiza caminos en las cercan√≠as de tales r√≠os. Por lo tanto, aqu√≠ agregaremos puentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estamos a un lado del r√≠o. El centro del camino se mueve desde el r√≠o, y luego el centro de la celda tambi√©n cambia. Para encontrar el centro de la carretera en el lado opuesto, necesitamos mover la direcci√≥n opuesta en la misma cantidad. Esto debe hacerse antes de cambiar el centro mismo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { ‚Ä¶ roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97c/c7f/420/97cc7f42004ba86c6cd0333af352f24b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puentes sobre r√≠os rectos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Han aparecido puentes! </font><font style="vertical-align: inherit;">Pero ahora tenemos una instancia de puentes para cada direcci√≥n a trav√©s de la cual el r√≠o no fluye. </font><font style="vertical-align: inherit;">Necesitamos asegurarnos de que solo se genere una instancia del puente en la celda. </font><font style="vertical-align: inherit;">Esto se puede hacer eligiendo una direcci√≥n relativa al r√≠o y sobre la base de generar un puente. </font><font style="vertical-align: inherit;">Puedes elegir cualquier direcci√≥n.</font></font><br><br><pre> <code class="cs hljs"> roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == direction.Next()) { features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, necesitamos agregar un puente solo cuando hay un camino a ambos lados del r√≠o. </font><font style="vertical-align: inherit;">Por el momento, ya estamos seguros de que hay un camino en el lado actual. </font><font style="vertical-align: inherit;">Por lo tanto, debe verificar si hay una carretera al otro lado del r√≠o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == direction.Next() &amp;&amp; ( cell.HasRoadThroughEdge(direction.Next2()) || cell.HasRoadThroughEdge(direction.Opposite()) )) { features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/635/a47/978/635a4797816f9f35297f67224a0ec449.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puentes entre las carreteras a ambos lados.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puentes sobre r√≠os curvos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los puentes sobre r√≠os curvos funcionan de manera similar, pero su topolog√≠a es ligeramente diferente. </font><font style="vertical-align: inherit;">Agregaremos un puente cuando estemos en el exterior de la curva. </font><font style="vertical-align: inherit;">Esto sucede en el √∫ltimo bloque </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Utiliza la direcci√≥n del medio para compensar el centro de la carretera. </font><font style="vertical-align: inherit;">Tendremos que usar este desplazamiento dos veces con diferentes escalas, as√≠ que gu√°rdelo en una variable.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La escala de desplazamiento en el exterior de la curva es de 0.25 y en el interior </font></font><code>HexMetrics.innerToOuter * 0.7f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lo usamos para colocar el puente.</font></font><br><br><pre> <code class="cs hljs"> Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/f9e/da9/612f9eda9f9e4cd31ba20dfe2db7687b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puentes sobre r√≠os curvos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ nuevamente necesitamos evitar puentes duplicados. </font><font style="vertical-align: inherit;">Podemos hacer esto agregando puentes solo desde la direcci√≥n media.</font></font><br><br><pre> <code class="cs hljs"> Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction == middle) { features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y nuevamente, debe asegurarse de que el camino est√© en el lado opuesto. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( direction == middle &amp;&amp; cell.HasRoadThroughEdge(direction.Opposite()) ) { features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/744/33c/275/74433c2750e413c44d17139982ecff3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puentes entre las carreteras a ambos lados.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escala del puente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como distorsionamos el terreno, la distancia entre los centros de las carreteras y los lados opuestos del r√≠o var√≠a. </font><font style="vertical-align: inherit;">A veces los puentes son demasiado cortos, a veces demasiado largos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/770/f2c/e53/770f2ce537ab16628c799eceb6ca4ad7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distintas distancias pero constantes longitudes de puente. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque hemos creado un puente con una longitud de siete unidades, puede escalarlo para que coincida con la distancia real entre los centros de las carreteras. </font><font style="vertical-align: inherit;">Esto significa que el modelo de puente est√° deformado. </font><font style="vertical-align: inherit;">Dado que las distancias no var√≠an mucho, la deformaci√≥n puede ser m√°s aceptable que los puentes no adecuados para la longitud. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para realizar una escala adecuada, necesitamos conocer la longitud inicial de la prefabricada del puente. </font><font style="vertical-align: inherit;">Almacenaremos esta longitud en </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bridgeDesignLength = <span class="hljs-number"><span class="hljs-number">7f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos asignar la escala a lo largo de la instancia Z del puente a la distancia entre los centros de las carreteras, dividida por la longitud original. </font><font style="vertical-align: inherit;">Dado que la ra√≠z del prefabricado del puente tiene la misma escala, el puente se estirar√° correctamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 roadCenter1, Vector3 roadCenter2</span></span></span><span class="hljs-function">)</span></span> { roadCenter1 = HexMetrics.Perturb(roadCenter1); roadCenter2 = HexMetrics.Perturb(roadCenter2); Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.forward = roadCenter2 - roadCenter1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> length = Vector3.Distance(roadCenter1, roadCenter2); instance.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, length * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / HexMetrics.bridgeDesignLength) ); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/b73/49c/21eb7349c5e7ae6d5480b2e61d19e046.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La longitud cambiante de los puentes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Construcci√≥n de puentes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de un cubo simple, podemos usar un modelo de puente m√°s interesante. </font><font style="vertical-align: inherit;">Por ejemplo, puede crear un puente arqueado en bruto de tres cubos rotados y escalados. </font><font style="vertical-align: inherit;">Por supuesto, puede crear modelos 3D mucho m√°s complejos, incluidas partes de la carretera. </font><font style="vertical-align: inherit;">Pero tenga en cuenta que todo el objeto estar√° ligeramente comprimido y estirado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eee/83f/3b6/eee83f3b67cf879abe3114117614af08.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/741/f7f/8a9741f7f024aa8914e29b12c1ae9d94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puentes arqueados de diferentes longitudes. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objetos especiales </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, nuestras c√©lulas pueden contener objetos urbanos, rurales y vegetales. Aunque cada uno de ellos tiene tres niveles, todos los objetos son bastante peque√±os en comparaci√≥n con el tama√±o de la celda. ¬øQu√© pasa si necesitamos un edificio grande, como un castillo? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agreguemos un tipo especial de objeto al terreno. Tales objetos son tan grandes que ocupan toda la celda. Cada uno de estos objetos es √∫nico y necesita su propio prefabricado. Por ejemplo, se puede crear un castillo simple a partir de un cubo central m√°s cuatro torres de esquina. La escala (6, 4, 6) para el cubo central crear√° un bloqueo lo suficientemente grande, que sin embargo cabe incluso en una celda fuertemente deformada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/9bf/0dc/7e19bf0dc5f1568bf4b21ec467ba9063.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefabricada del castillo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro objeto especial puede ser un zigurat, por ejemplo, construido con tres cubos colocados uno encima del otro. </font><font style="vertical-align: inherit;">Para el cubo inferior, la escala (8, 2.5, 8) es adecuada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ad/7d3/291/1ad7d3291224358562b3472f528973a1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zigurat prefabricado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los objetos especiales pueden ser cualquiera, no necesariamente arquitect√≥nicos. </font><font style="vertical-align: inherit;">Por ejemplo, un grupo de √°rboles masivos de hasta diez unidades de altura puede indicar una celda llena de megaflora.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bb/e91/907/1bbe91907deba70f6ab9d02cd13de795.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Megaflora prefabricada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue a la </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz para rastrear estos prefabricados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[] special;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primero, agregue un castillo a la matriz, luego zigurat y luego megaflora. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbc/2e3/e94/bbc2e3e949b25efc800a8f2e799490c7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personalizaci√≥n de objetos especiales.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Haciendo c√©lulas especiales </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se requiere un √≠ndice de objetos especiales, que determina el tipo de un objeto especial, si est√° all√≠.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> specialIndex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al igual que otros objetos de socorro, demos la posibilidad de recibir y establecer este valor. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por defecto, la celda no contiene un objeto especial. </font><font style="vertical-align: inherit;">Denotamos esto por el √≠ndice 0. Agregue una propiedad que use este enfoque para determinar si una celda es especial.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsSpecial { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialIndex &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para editar celdas, agregue soporte para el √≠ndice de objetos especiales en </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Funciona de manera similar a los niveles de las instalaciones urbanas, rurales y vegetales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel, activeFarmLevel, activePlantLevel, activeSpecialIndex; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel, applyFarmLevel, applyPlantLevel, applySpecialIndex; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplySpecialIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applySpecialIndex = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetSpecialIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeSpecialIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)index; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applySpecialIndex) { cell.SpecialIndex = activeSpecialIndex; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un control deslizante a la interfaz de usuario para controlar el objeto especial. </font><font style="vertical-align: inherit;">Como tenemos tres objetos, usamos el intervalo 0‚Äì3 en el control deslizante. </font><font style="vertical-align: inherit;">Cero significar√° la ausencia de un objeto, uno - un castillo, dos - zigurat, tres - megaflora.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab4/2ea/9bf/ab42ea9bf68565a294f4ded5d2d7ebf0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante para objetos especiales.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar objetos especiales </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos asignar objetos especiales a las celdas. </font><font style="vertical-align: inherit;">Para que aparezcan, necesitamos agregar a </font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otro m√©todo. </font><font style="vertical-align: inherit;">Simplemente crea una instancia del objeto especial deseado y lo coloca en la posici√≥n deseada. </font><font style="vertical-align: inherit;">Dado que cero indica la ausencia de un objeto, debemos restar la unidad del √≠ndice de objetos especiales de la celda antes de obtener acceso a la matriz de prefabricados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSpecialFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(special[cell.SpecialIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>]); instance.localPosition = HexMetrics.Perturb(position); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos a darle al objeto una rotaci√≥n arbitraria utilizando la tabla hash. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSpecialFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(special[cell.SpecialIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>]); instance.localPosition = HexMetrics.Perturb(position); HexHash hash = HexMetrics.SampleHashGrid(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.e, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al triangular una celda, </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verificaremos si la celda contiene un objeto especial. </font><font style="vertical-align: inherit;">Si es as√≠, llamamos a nuestro nuevo m√©todo, al igual que </font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b69/242/657/b692426576e292bbdc9ed0752624db51.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos especiales. </font><font style="vertical-align: inherit;">Son mucho m√°s grandes de lo habitual.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar los r√≠os </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dado que los objetos especiales se encuentran en el centro de las celdas, no se combinan con los r√≠os, ya que colgar√°n sobre ellos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a51/92f/cc2/a5192fcc2c5718f33bafc631f60a07a8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos en los r√≠os. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar que se creen objetos especiales en la parte superior de los r√≠os, cambiamos la propiedad </font></font><code>HexCell.SpecialIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cambiaremos el √≠ndice solo cuando no haya r√≠os en la celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp;&amp; !HasRiver) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, al agregar un r√≠o, necesitaremos deshacernos de todos los objetos especiales. </font><font style="vertical-align: inherit;">El r√≠o deber√≠a lavarlos. </font><font style="vertical-align: inherit;">Esto se puede hacer </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estableciendo el √≠ndice de objetos especiales en 0 </font><font style="vertical-align: inherit;">en el m√©todo </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; specialIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.specialIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitamos los caminos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que los r√≠os, los caminos tambi√©n van mal con objetos especiales, pero no todo es tan terrible. </font><font style="vertical-align: inherit;">Incluso puedes dejar las carreteras como est√°n. </font><font style="vertical-align: inherit;">Algunas instalaciones pueden ser compatibles con las carreteras, mientras que otras no. </font><font style="vertical-align: inherit;">Por lo tanto, puede hacer que dependan del objeto. </font><font style="vertical-align: inherit;">Pero lo haremos m√°s f√°cil.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3b/ebf/939/b3bebf9399ed016e8d79a4c1ee53ace8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos en el camino. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, deje que los objetos especiales derroten el camino. </font><font style="vertical-align: inherit;">Por lo tanto, al cambiar el √≠ndice de objetos especiales, tambi√©n eliminaremos todas las carreteras de la celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp;&amp; !HasRiver) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RemoveRoads(); RefreshSelfOnly(); } } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© pasa si eliminamos un objeto en particular?</font></font></b> <div class="spoiler_text">      0,   ,       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, esto significa que al agregar carreteras, tendremos que realizar verificaciones adicionales. </font><font style="vertical-align: inherit;">Agregaremos caminos solo cuando ninguna de las celdas sea una celda con un objeto especial.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; !IsSpecial &amp;&amp; !GetNeighbor(direction).IsSpecial &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar otros objetos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los objetos especiales no se pueden mezclar con otros tipos de objetos. </font><font style="vertical-align: inherit;">Si se superponen, entonces se ver√° desordenado. </font><font style="vertical-align: inherit;">Tambi√©n puede depender de un objeto en particular, pero usaremos el mismo enfoque.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03b/7f1/8fc/03b7f18fc9f9d7543bdb0d9c24a074e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un objeto que se cruza con otros objetos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, suprimiremos objetos m√°s peque√±os, como si estuvieran bajo el agua. </font><font style="vertical-align: inherit;">Esta vez nos registraremos </font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar el agua </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n tenemos un problema con el agua. </font><font style="vertical-align: inherit;">¬øLas caracter√≠sticas especiales persistir√°n durante las inundaciones? </font><font style="vertical-align: inherit;">Como destruimos objetos peque√±os en celdas inundadas, hagamos lo mismo con objetos especiales.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/479/e79/8d9479e79cb0555c81f562dc32937552.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objetos en el agua. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realizaremos la misma verificaci√≥n de inundaci√≥n para objetos especiales y ordinarios.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que ambos operadores </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora verifican si la celda est√° bajo el agua, podemos transferir la prueba y realizarla solo una vez.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para los experimentos, tal cantidad de objetos ser√° suficiente para nosotros. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425463/">https://habr.com/ru/post/es425463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425449/index.html">Actualizaci√≥n del enfoque de la publicidad contextual: Yandex.Direct Turbo Pages</a></li>
<li><a href="../es425453/index.html">De Space Invaders a Half Life 2: The Story of Game Dzdoks</a></li>
<li><a href="../es425457/index.html">Veinte rompecabezas (en geometr√≠a loca y sorprendente)</a></li>
<li><a href="../es425459/index.html">La actualizaci√≥n a Windows 1809 (a veces) destruye todos los archivos en un perfil</a></li>
<li><a href="../es425461/index.html">Devops y seguridad: entrevistas con Seth Wargo y Liz Rice</a></li>
<li><a href="../es425465/index.html">C√≥mo un dise√±ador puede ganar m√°s, una herramienta ideal para trabajar y buscar ideas</a></li>
<li><a href="../es425467/index.html">Motores Renault D4F> B4D (tambi√©n conocido como SCe). Cambio generacional. Mirada motorista</a></li>
<li><a href="../es425469/index.html">El autor de Python ya no lidera el desarrollo. ¬øMejorar√° o empeorar√° el idioma?</a></li>
<li><a href="../es425471/index.html">Trabajando con im√°genes en Python</a></li>
<li><a href="../es425473/index.html">Conferencia sobre Python y sobre comunicaci√≥n.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>