<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧡 🛕 🧗🏼 Apa itu Aliasing Ketat dan mengapa kita harus peduli? Bagian 2 👇🏻 ♥️ 🤚🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(ATAU quibble mengetik, perilaku dan penyelarasan yang samar, oh my God!) 

 Teman-teman, sangat sedikit waktu yang tersisa sebelum peluncuran utas ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa itu Aliasing Ketat dan mengapa kita harus peduli? Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443602/">  <b><i>(ATAU quibble mengetik, perilaku dan penyelarasan yang samar, oh my God!)</i></b> <br><br>  Teman-teman, sangat sedikit waktu yang tersisa sebelum peluncuran utas baru di kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengembang C ++"</a> .  Sudah waktunya untuk menerbitkan terjemahan dari bagian kedua dari materi, yang menceritakan tentang apa yang diketik pun. <br><br>  <b>Apa itu pelafalan kata benda?</b> <br><br>  Kami telah mencapai titik di mana kami mungkin bertanya-tanya mengapa kami mungkin perlu nama samaran sama sekali?  Biasanya untuk implementasi puns typing, tk.  metode yang sering digunakan melanggar aturan aliasing yang ketat. <br><br><img src="https://habrastorage.org/webt/dz/u-/cd/dzu-cdwp2tjct7bc-stnxfnptpe.png"><br><br>  Terkadang kita ingin menyiasati sistem tipe dan menafsirkan objek sebagai tipe lain.  Menafsirkan kembali segmen memori sebagai tipe lain disebut tipe <i>punning pun</i> .  Permainan mengetik berguna untuk tugas-tugas yang memerlukan akses ke representasi dasar dari suatu objek untuk melihat, memindahkan, atau memanipulasi data yang disediakan.  Area umum tempat kita dapat menemukan penggunaan permainan ketikan mengetik: kompiler, serialisasi, kode jaringan, dll. <a name="habracut"></a><br>  Secara tradisional, ini dicapai dengan mengambil alamat objek, menuangnya ke pointer ke jenis yang ingin kita tafsirkan, dan kemudian mengakses nilai, atau dengan kata lain, menggunakan alias.  Sebagai contoh: <br><br><pre><code class="bash hljs">int x = 1 ; //   C <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = (<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*)&amp;x ; //   //  C++ <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = reinterpret_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*&gt;(&amp;x) ; //   <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( “%f\n”, *fp ) ;</code> </pre> <br>  Seperti yang kita lihat sebelumnya, ini alias tidak dapat diterima, ini akan menyebabkan perilaku yang tidak terdefinisi.  Namun secara tradisional, kompiler tidak menggunakan aturan aliasing yang ketat, dan kode jenis ini biasanya hanya berfungsi, dan pengembang, sayangnya, terbiasa membiarkan hal-hal seperti itu.  Metode umum mengetik-mengetik adalah melalui gabungan, yang valid dalam C, tetapi akan menyebabkan perilaku tidak terdefinisi dalam C ++ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat contoh</a> ): <br><br><pre> <code class="bash hljs">union u1 { int n; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f; } ; union u1 u; uf = 1.0f; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n”, un ); // UB(undefined behaviour)  C++ “n is not the active member”</span></span></code> </pre> <br>  Ini tidak dapat diterima di C ++, dan beberapa percaya bahwa serikat pekerja dimaksudkan hanya untuk mengimplementasikan tipe varian, dan menganggap bahwa menggunakan serikat pekerja untuk mengetik permainan kata merupakan penyalahgunaan. <br><br>  <b>Bagaimana cara menerapkan permainan kata?</b> <br><br>  Metode standar yang diberkati untuk mengetik permainan kata dalam C dan C ++ adalah memcpy.  Ini mungkin tampak agak rumit, tetapi pengoptimal perlu mengenali penggunaan memcpy untuk permainan kata, mengoptimalkannya dan membuat register untuk mendaftarkan gerakan.  Misalnya, jika kita tahu bahwa int64_t berukuran sama dengan ganda: <br><br><pre> <code class="bash hljs">static_assert( sizeof( double ) == sizeof( int64_t ) ); // C++17   </code> </pre> <br>  Kita bisa menggunakan <code>memcpy</code> : <br><br><pre> <code class="bash hljs">void func1( double d ) { std::int64_t n; std::memcpy(&amp;n, &amp;d, sizeof d); //…</code> </pre><br>  Dengan tingkat optimisasi yang memadai, setiap kompiler modern yang layak menghasilkan kode yang identik dengan metode reinterpret_cast yang disebutkan sebelumnya atau metode bergabung untuk mendapatkan permainan kata-kata.  Mempelajari kode yang dihasilkan, kita melihat bahwa itu hanya menggunakan register mov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> ). <br><br>  <b>Jenis dan Array Pun</b> <br><br>  Tetapi bagaimana jika kita ingin mengimplementasikan permainan dari array char yang tidak ditandatangani ke dalam serangkaian unsigned int dan kemudian melakukan operasi pada masing-masing nilai int unsigned?  Kita dapat menggunakan memcpy untuk mengubah array char yang tidak ditandatangani menjadi tipe int yang tidak ditandai untuk sementara.  Pengoptimal masih akan dapat melihat semuanya melalui memcpy dan mengoptimalkan objek sementara dan salinan, dan bekerja secara langsung dengan data yang mendasarinya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> ): <br><br><pre> <code class="bash hljs">//  ,    int foo( unsigned int x ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x ; } // ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = 0; std::memcpy( &amp;ui, &amp;p[index], sizeof(unsigned int) ); result += foo( ui ) ; } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre><br>  Dalam contoh ini, kita ambil <code>char*p</code> , asumsikan itu menunjuk ke beberapa fragmen data <code>sizeof(unsigned int)</code> , menginterpretasikan setiap fragmen data sebagai <code>unsigned int</code> , menghitung <code>foo()</code> untuk setiap fragmen permainan kata, menjumlahkan hasilnya dan mengembalikan nilai akhir . <br><br>  Perakitan untuk loop body menunjukkan bahwa pengoptimal mengubah tubuh menjadi akses langsung ke array basis <code>unsigned char</code> sebagai <code>unsigned int</code> , menambahkannya langsung ke <code>eax</code> : <br><br><pre> <code class="bash hljs">add eax, dword ptr [rdi + rcx]</code> </pre> <br>  Kode yang sama, tetapi menggunakan <code>reinterpret_cast</code> untuk menerapkan permainan kata (melanggar aliasing yang ketat): <br><br><pre> <code class="bash hljs">// ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = *reinterpret_cast&lt;unsigned int*&gt;(&amp;p[index]); result += foo( ui ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre> <br>  <b>C ++ 20 dan bit_cast</b> <br><br>  Di C ++ 20, kami memiliki <code>bit_cast</code> , yang menyediakan cara yang mudah dan aman untuk menafsirkan, dan juga dapat digunakan dalam konteks <code>constexpr</code> . <br><br>  Berikut ini adalah contoh cara menggunakan <code>bit_cast</code> untuk menafsirkan integer yang tidak ditandai dalam <code>float</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> ): <br><br><pre> <code class="bash hljs">std::cout &lt;&lt; bit_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>&gt;(0x447a0000) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ; //,  sizeof(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) == sizeof(unsigned int)</code> </pre> <br>  Dalam kasus ketika tipe Ke dan Dari tidak memiliki ukuran yang sama, ini mengharuskan kami untuk menggunakan struktur perantara.  Kami akan menggunakan struktur yang berisi berbagai karakter array <code>sizeof(unsigned int)</code> (diasumsikan int unsigned 4-byte) sebagai tipe Dari, dan <code>unsigned int</code> sebagai Kepada. <br><br><pre> <code class="bash hljs">struct uint_chars { unsigned char arr[sizeof( unsigned int )] = {} ; //  sizeof( unsigned int ) == 4 }; //  len  4 int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { uint_chars f; std::memcpy( f.arr, &amp;p[index], sizeof(unsigned int)); unsigned int result = bit_cast&lt;unsigned int&gt;(f); result += foo( result ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result ; }</code> </pre> <br>  Sayangnya, kami membutuhkan jenis perantara ini - ini adalah batasan <code>bit_cast</code> saat ini. <br><br>  <b>Perataan</b> <br><br>  Dalam contoh sebelumnya, kami melihat bahwa pelanggaran aturan aliasing yang ketat dapat menyebabkan pengecualian penyimpanan selama optimisasi.  Pelanggaran aliasing yang ketat juga dapat menyebabkan pelanggaran persyaratan penyelarasan.  Baik standar C dan C ++ menyatakan bahwa objek tunduk pada persyaratan pelurusan yang membatasi tempat di mana objek dapat ditempatkan (dalam memori) dan karenanya dapat diakses.  <i>C11 bagian 6.2.8 Penyelarasan objek menyatakan</i> : <br><br>  Jenis objek yang lengkap memiliki persyaratan pelurusan yang memberlakukan batasan pada alamat tempat objek jenis ini dapat ditempatkan.  Alignment adalah nilai integer yang ditentukan implementasi yang mewakili jumlah byte antara alamat berurutan di mana objek ini dapat ditempatkan.  Jenis objek memaksakan persyaratan perataan pada setiap objek jenis ini: perataan yang lebih ketat dapat diminta menggunakan <code>_Alignas</code> . <br><br>  <b>Standar proyek C ++ 17 di bagian 1 [basic.align]</b> : <br><br>  Jenis objek memiliki persyaratan pelurusan (6.7.1, 6.7.2) yang memberikan batasan pada alamat tempat objek jenis ini dapat ditempatkan.  Alignment adalah nilai integer yang ditentukan implementasi yang mewakili jumlah byte antara alamat berurutan di mana objek yang diberikan dapat ditempatkan.  Jenis objek memaksakan persyaratan perataan pada setiap objek jenis ini;  Penjajaran yang lebih ketat dapat diminta menggunakan penjajaran penjajaran (10.6.2). <br><br>  Baik C99 dan C11 secara eksplisit menunjukkan bahwa konversi yang menghasilkan pointer yang tidak selaras adalah perilaku yang tidak ditentukan, bagian 6.3.2.3.  <i>Pointers</i> mengatakan: <br><blockquote>  Pointer ke objek atau tipe parsial dapat dikonversi ke pointer ke objek atau tipe parsial lain.  Jika pointer yang dihasilkan tidak selaras dengan benar untuk tipe pointer, perilaku tidak terdefinisi.  ... <br></blockquote>  Meskipun C ++ tidak begitu jelas, saya percaya bahwa kalimat ini dari ayat 1 <code>[basic.align]</code> cukup: <br><blockquote>  ... Jenis objek memaksakan persyaratan perataan pada setiap objek jenis ini;  ... </blockquote>  <i><b>Contoh</b></i> <br><br>  Jadi mari kita asumsikan: <br><br><ul><li>  alignof (char) dan alignof (int) masing-masing adalah 1 dan 4 </li><li>  sizeof (int) adalah 4 </li></ul><br>  Dengan demikian, menafsirkan array ar dengan ukuran 4 sebagai <code>int</code> melanggar aliasing yang ketat, dan juga dapat melanggar persyaratan penyelarasan jika array memiliki keselarasan 1 atau 2 byte. <br><br><pre> <code class="bash hljs">char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; //        1  2  int x = *reinterpret_cast&lt;int*&gt;(arr); // Undefined behavior  </code> </pre> <br>  Yang dapat mengakibatkan penurunan kinerja atau kesalahan bus dalam beberapa situasi.  Sedangkan menggunakan alignas untuk memaksa alignment yang sama untuk array di int akan mencegah persyaratan alignment dari melanggar: <br><br><pre> <code class="bash hljs">alignas(alignof(int)) char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; int x = *reinterpret_cast&lt;int*&gt;(arr);</code> </pre> <br>  <i><b>Atomicity</b></i> <br><br>  Hukuman lain yang tidak terduga untuk akses yang tidak seimbang adalah bahwa itu melanggar atomicity beberapa arsitektur.  Penyimpanan atom mungkin tidak muncul atom untuk utas lain di x86 jika tidak sejajar. <br><br>  <b>Menangkap pelanggaran alias ketat</b> <br><br>  Kami tidak memiliki banyak alat bagus untuk melacak alias ketat di C ++.  Alat yang kami miliki akan menangkap beberapa kasus pelanggaran dan beberapa kasus pemuatan dan penyimpanan yang tidak tepat. <br><br>  gcc menggunakan <code>-fstrict-aliasing</code> dan <code>-Wstrict-aliasing</code> dapat menangkap beberapa case, walaupun bukan tanpa false positive / masalah.  Misalnya, kasus-kasus berikut akan menghasilkan peringatan dalam gcc ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> ): <br><br><pre> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.f; //   ,   TIS ,         <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(&amp;a))); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;int*&gt;(&amp;f)));</code> </pre> <br>  meskipun dia tidak akan menangkap kasus tambahan ini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> ): <br><br><pre> <code class="bash hljs">int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(p)));</code> </pre><br>  Meskipun <code>clang</code> menyelesaikan bendera ini, tampaknya tidak benar-benar menerapkan peringatan tersebut. <br><br>  Alat lain yang kami miliki adalah ASan, yang dapat menangkap perekaman dan penyimpanan yang tidak selaras.  Meskipun mereka bukan pelanggaran langsung alias ketat, ini adalah hasil yang cukup umum.  Sebagai contoh, kasus-kasus berikut akan menghasilkan kesalahan runtime selama perakitan menggunakan dentang menggunakan <code>-fsanitize=address</code> <br><br><pre> <code class="bash hljs">int *x = new int[2]; // 8 : [0,7]. int *u = (int*)((char*)x + 6); //     x    *u = 1; //    [6-9] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *u ); //    [6-9]</code> </pre> <br>  Alat terakhir yang saya rekomendasikan adalah khusus untuk C ++ dan, pada kenyataannya, tidak hanya alat, tetapi juga praktik pengkodean yang tidak memungkinkan casting gaya C. Baik <code>gcc</code> dan <code>clang</code> akan melakukan diagnostik untuk <code>-Wold-style-cast</code> C menggunakan <code>-Wold-style-cast</code> .  Ini akan memaksa setiap permainan ketikan yang tidak ditentukan untuk menggunakan reinterpret_cast.  Secara umum, <code>reinterpret_cast</code> harus menjadi suar untuk analisis kode yang lebih menyeluruh. <br>  Juga lebih mudah untuk mencari basis kode untuk <code>reinterpret_cast</code> untuk melakukan audit. <br><br>  Untuk C, kami memiliki semua alat yang sudah dijelaskan, dan kami juga memiliki <code>tis-interpreter</code> , penganalisa statis yang secara mendalam menganalisis program untuk subset besar C. Diberikan versi C dari contoh sebelumnya, di mana menggunakan -fstrict-aliasing melewatkan satu kasus ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> ) <br><br><pre> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.0 ; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)&amp;a)); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((int*)&amp;f)); int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)p));</code> </pre><br>  TIS interpreter dapat mencegat ketiganya, contoh berikut memanggil kernel TIS sebagai juru TIS (output diedit untuk singkatnya): <br><br><pre> <code class="bash hljs">./bin/tis-kernel -sa example1.c ... example1.c:9:[sa] warning: The pointer (short *)(&amp; a) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int. ... example1.c:10:[sa] warning: The pointer (int *)(&amp; f) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>. Callstack: main ... example1.c:15:[sa] warning: The pointer (short *)p has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int.</code> </pre> <br>  Dan akhirnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TySan</a> , yang sedang dalam pengembangan.  Pembersih ini menambahkan tipe memeriksa informasi ke segmen memori bayangan dan memeriksa akses untuk menentukan apakah mereka melanggar aturan alias.  Alat ini berpotensi dapat melacak semua pelanggaran alias, tetapi mungkin memiliki overhead yang besar saat runtime. <br><br>  <b>Kesimpulan</b> <br><br>  Kami belajar tentang aturan aliasing dalam C dan C ++, yang berarti bahwa kompiler mengharapkan kita untuk secara ketat mengikuti aturan ini dan menerima konsekuensi dari tidak memenuhinya.  Kami telah mempelajari tentang beberapa alat yang dapat membantu kami mengidentifikasi beberapa penyalahgunaan nama samaran.  Kita telah melihat bahwa penggunaan aliasing yang biasa adalah permainan kata-kata.  Kami juga belajar cara mengimplementasikannya dengan benar. <br><br>  Pengoptimal secara bertahap meningkatkan analisis alias berbasis tipe dan telah melanggar beberapa kode yang didasarkan pada pelanggaran alias ketat.  Kita dapat mengharapkan optimasi untuk menjadi lebih baik dan memecahkan lebih banyak kode yang baru saja bekerja sebelumnya. <br><br>  Kami memiliki metode standar yang siap pakai untuk menafsirkan tipe.  Kadang-kadang untuk debug membangun metode ini harus abstraksi gratis.  Kami memiliki beberapa alat untuk mendeteksi pelanggaran aliasing yang parah, tetapi untuk C ++ mereka hanya akan menangkap sebagian kecil dari kasus, dan untuk C yang menggunakan tis-interpreter kami dapat melacak sebagian besar pelanggaran. <br><br>  Terima kasih kepada mereka yang mengomentari artikel ini: JF Bastien, Christopher Di Bella, Pascal Quoc, Matt P. Dziubinski, Patrice Roy dan Olafur Vaage <br>  Tentu saja, pada akhirnya, semua kesalahan adalah milik penulis. <br><br>  Jadi terjemahan dari bahan yang agak besar telah berakhir, bagian pertama dapat dibaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Dan kami secara tradisional mengundang Anda ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hari buka pintu</a> , yang akan diadakan pada 14 Maret oleh kepala departemen pengembangan teknologi di Rambler &amp; Co - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dmitry Shebordaev.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443602/">https://habr.com/ru/post/id443602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443590/index.html">Ilmu Data: memprediksi peristiwa bisnis untuk meningkatkan layanan</a></li>
<li><a href="../id443592/index.html">Standar ujung depan RFID ISO 11785 dari penerima FM lama dan serpihan lift</a></li>
<li><a href="../id443594/index.html">Persimpangan Pengujian dan Arsitektur: Wawancara dengan Neil Ford</a></li>
<li><a href="../id443598/index.html">Ada pencabutan massal sertifikat TLS dari banyak CA, keliru yang dihasilkan pada RNG 63-bit, bukan 64-bit</a></li>
<li><a href="../id443600/index.html">Tren terbaik dan terburuk MWC 2019</a></li>
<li><a href="../id443604/index.html">MOBILE FIRST: Hackathon di OZON</a></li>
<li><a href="../id443606/index.html">Jenkins untuk Android build menggunakan buruh pelabuhan</a></li>
<li><a href="../id443608/index.html">Smart Home / Pembaruan di Lazurite</a></li>
<li><a href="../id443612/index.html">Kami menggunakan HDD buruk lama</a></li>
<li><a href="../id443614/index.html">YouTrack 2019.1: pilih papan Agile, bidang kartu yang dapat disesuaikan pada papan Agile, dan banyak lagi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>