<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐠 👟 🎷 البحث عن الأخطاء في LLVM 8 باستخدام PVS-Studio 🎯 👀 🚚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="لقد مر عامان منذ آخر مرة قمنا فيها بالتحقق من رمز مشروع LLVM باستخدام PVS-Studio ، لذلك دعونا نرى ما إذا كان PVS-Studio لا يزال الرائد بين أدوات اكتشا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>البحث عن الأخطاء في LLVM 8 باستخدام PVS-Studio</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/450002/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/2f2/8d4/5bf/2f28d45bf369270d9330bfbe2ea78f00.png" alt="PVS-Studio و LLVM 8.0.0"></div><br>  لقد مر عامان منذ آخر مرة قمنا فيها بالتحقق من رمز مشروع LLVM باستخدام PVS-Studio ، لذلك دعونا نرى ما إذا كان PVS-Studio لا يزال الرائد بين أدوات اكتشاف الأخطاء ونقاط الضعف الأمنية.  سنفعل ذلك عن طريق فحص إصدار LLVM 8.0.0 بحثًا عن أخطاء جديدة. <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  المادة التي يجب أن تكتب </h2><br>  بصراحة ، لم أشعر أنني أحب كتابة هذا المقال.  ليس من المرح الحديث عن المشروع الذي فحصناه بالفعل أكثر من مرة ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">1</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">2</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">3</a> ).  أفضل شيء جديد بدلاً من ذلك ، لكن لم يكن لدي أي خيار. <br><br>  في كل مرة يتم إصدار نسخة جديدة من LLVM أو تحديث <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Clang Static Analyzer</a> ، نحصل على رسائل البريد الإلكتروني التي تقرأ على طول هذه الخطوط: <br><br>  <i>مهلا ، حصلت النسخة الجديدة من Clang Static Analyzer على تشخيصات جديدة!</i>  <i>يبدو أن PVS-Studio أصبح أقل أهمية.</i>  <i>يمكن لـ Clang اكتشاف المزيد من الأخطاء أكثر من ذي قبل وهو الآن يلحق ب PVS-Studio.</i>  <i>ماذا تقول؟</i> <br><br>  لذلك أود أن أرد بكل سرور: <br><br>  <b>لم نكن نستريح أيضًا!</b>  لقد قمنا بزيادة قدرات PVS-Studio بشكل كبير ، فلا تقلق - فنحن لا نزال الأفضل. <br><br>  ولكن هذا إجابة سيئة ، أخشى.  لا تقدم أي أدلة ، وهذا هو السبب في أنني أكتب هذه المقالة.  لذلك ، لقد راجعت LLVM مرة أخرى ووجدت الكثير من الأخطاء من جميع الأنواع.  تلك التي أعجبتني أكثر ستناقش أكثر.  يتعذر على Clang Static Analyzer اكتشاف هذه الأخطاء (أو يجعل العملية مزعجة للغاية) - ويمكننا ذلك.  وبالمناسبة ، استغرق الأمر مني ليلة واحدة فقط لأكتب كل تلك الأخطاء. <br><br>  المقالة ، رغم ذلك ، استغرقت عدة أسابيع حتى أكمل.  لم أستطع إحضار نفسي لوضع المواد المجمعة في نص :). <br><br>  بالمناسبة ، إذا كنت تتساءل عن التقنيات التي يستخدمها PVS-Studio للكشف عن الأخطاء ونقاط الضعف ، ألق نظرة على هذا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المنشور</a> . <br><br><h2 style=";text-align:right;direction:rtl">  التشخيصات الجديدة والقائمة </h2><br>  كما قلت سابقًا ، تم إجراء آخر فحصات عديدة لـ LLVM قبل عامين ، وتم إصلاح الأخطاء التي تم العثور عليها بعد ذلك بواسطة المؤلفين.  هذه المادة سوف تظهر جزء جديد من الأخطاء.  كيف تأتي هناك أخطاء جديدة على الإطلاق؟  هناك ثلاثة أسباب: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  مشروع LLVM يتطور ؛  المؤلفون تعديل التعليمات البرمجية الموجودة وإضافة رمز جديد.  كل من الأجزاء المعدلة والجديدة تحتوي بشكل طبيعي على أخطاء جديدة.  هذه الحقيقة هي حجة قوية لتشغيل التحليل الثابت بانتظام بدلاً من حين لآخر.  يعد تنسيق مقالاتنا مثاليًا لعرض إمكانيات PVS-Studio ، ولكن لا علاقة له بتحسين جودة الكود أو جعل إصلاح الأخطاء أقل تكلفة.  هل تستخدم التحليل الثابت بانتظام! </li><li style=";text-align:right;direction:rtl">  نقوم بتعديل التشخيصات الموجودة وتحسينها ، مما يتيح للمحلل اكتشاف الأخطاء التي لم يتمكن من اكتشافها من قبل. </li><li style=";text-align:right;direction:rtl">  تم تعزيز PVS-Studio بالتشخيصات الجديدة ، التي لم تكن موجودة قبل عامين.  قمت بتجميع هذه التحذيرات في قسم منفصل بحيث يتم رؤية تقدم PVS-Studio بشكل أكثر وضوحًا. </li></ol><br><h2 style=";text-align:right;direction:rtl">  العيوب الموجودة بواسطة التشخيصات الموجودة </h2><br>  <b>مقتطف لا.</b>  <b>1: نسخ ولصق</b> <br><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldUpgradeX86Intrinsic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function *F, StringRef Name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Name == <span class="hljs-string"><span class="hljs-string">"addcarryx.u32"</span></span> || <span class="hljs-comment"><span class="hljs-comment">// Added in 8.0 .... Name == "avx512.mask.cvtps2pd.128" || // Added in 7.0 Name == "avx512.mask.cvtps2pd.256" || // Added in 7.0 Name == "avx512.cvtusi2sd" || // Added in 7.0 Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name == "sse2.pmulu.dq" || // Added in 7.0 Name == "sse41.pmuldq" || // Added in 7.0 Name == "avx2.pmulu.dq" || // Added in 7.0 .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V501</a> [CWE-570] يوجد Name.startswith تعبيرات فرعية متطابقة ("avx512.mask.permvar.") "إلى اليسار وإلى يمين" || "  المشغل.  AutoUpgrade.cpp 73 <br><br>  حدوث "avx512.mask.permvar."  يتم فحص سلسلة فرعية مرتين.  كان الشرط الثاني هو التحقق من شيء آخر ، لكن المبرمج نسي تغيير الخط المنسوخ. <br><br>  <b>مقتطف لا.</b>  <b>2: الخطأ المطبعي</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CXNameRefFlags { CXNameRange_WantQualifier = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, CXNameRange_WantTemplateArgs = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, CXNameRange_WantSinglePiece = <span class="hljs-number"><span class="hljs-number">0x4</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnnotateTokensWorker::HandlePostPonedChildCursor( CXCursor Cursor, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> StartTokenIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> flags = CXNameRange_WantQualifier | CXNameRange_WantQualifier; .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: V501 هناك تعبيرات فرعية متطابقة 'CXNameRange_WantQualifier' إلى اليسار وإلى يمين "|"  المشغل.  CIndex.cpp 7245 <br><br>  يتم استخدام ثابت المسمى <i>CXNameRange_WantQualifier</i> مرتين بسبب خطأ مطبعي. <br><br>  <b>مقتطف لا.</b>  <b>3: الارتباك على أسبقية المشغل</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PPCTTIImpl::getVectorInstrCost(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Opcode, Type *Val, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Index) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V502</a> [CWE-783] ربما يعمل المشغل '؟: بطريقة مختلفة عما كان متوقعًا.  لدى المشغل '؟:' أولوية أقل من المشغل '=='.  PPCTargetTransformInfo.cpp 404 <br><br>  أجد هذا الخطأ لطيف جدا.  نعم ، أنا أعلم أن لدي طعم غريب :). <br><br>  كما تمليها <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أسبقية المشغل</a> ، يتم تقييم التعبير الأصلي على النحو التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; (Index == ST-&gt;isLittleEndian())) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  من الناحية العملية ، على الرغم من أن هذا الشرط لا معنى له حيث يمكن اختزاله إلى: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian())</code> </pre> <br>  من الواضح أن هذا خطأ.  يجب أن يكون المتغير <i>Index</i> الذي أراد المبرمج التحقق من 0/1.  لإصلاح الكود ، يجب إحاطة المشغل الثلاثي بأقواس: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == (ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre> <br>  المشغل الثلاثي هو في الواقع صعب للغاية وقد يؤدي إلى أخطاء منطقية.  استخدمه بعناية ولا تتردد في وضع أقواس إضافية حوله.  تمت مناقشة هذا الموضوع بمزيد من التفصيل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> ، في قسم "احذر من المشغل؟ وأرفقه بين قوسين". <br><br>  <b>قصاصات لا.</b>  <b>4 ، 5: مؤشر لاغية</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Init *TGParser::ParseValue(Record *CurRec, RecTy *ItemType, IDParseMode Mode) { .... TypedInit *LHS = dyn_cast&lt;TypedInit&gt;(Result); .... LHS = dyn_cast&lt;TypedInit&gt;( UnOpInit::get(UnOpInit::CAST, LHS, StringRecTy::get()) -&gt;Fold(CurRec)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LHS) { Error(PasteLoc, Twine(<span class="hljs-string"><span class="hljs-string">"can't cast '"</span></span>) + LHS-&gt;getAsString() + <span class="hljs-string"><span class="hljs-string">"' to string"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V522</a> [CWE-476] قد يتم إلغاء تنظيم المؤشر الخالي "LHS".  TGParser.cpp 2152 <br><br>  إذا صادف أن يكون مؤشر <i>LHS</i> خاليًا ، فمن المتوقع أن ينشئ البرنامج تحذيرًا.  بدلاً من ذلك ، سيتم dereference هذا المؤشر فارغة جداً: <i>LHS-&gt; getAsString ()</i> . <br><br>  من المعتاد جدًا احتواء معالجات الأخطاء على الأخطاء لأن المطورين لا يختبرونها بشكل صحيح.  يقوم المحللون الثابتون بفحص جميع التعليمات البرمجية القابلة للوصول بغض النظر عن عدد مرات تنفيذها بالفعل.  هذا مثال جيد على كيفية استكمال التحليل الثابت لوسائل الاختبار والحماية البرمجية الأخرى. <br><br>  تم العثور على معالج خاطئ مشابه لمؤشر <i>RHS</i> أكثر قليلاً: V522 [CWE-476] قد يتم إلغاء تحديد مؤشر الخالي من المؤشر "RHS".  TGParser.cpp 2186 <br><br>  <b>مقتطف لا.</b>  <b>6: استخدام المؤشر بعد التحرك</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; ExtractBlocks(....) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; ProgClone = CloneModule(BD.getProgram(), VMap); .... BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= MiscompiledFunctions.clear(); for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) { Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first); // &lt;= assert(NewF &amp;&amp; "Function not found??"); MiscompiledFunctions.push_back(NewF); } .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: V522 [CWE-476] قد تتم عملية إلغاء تأشير المؤشر الخالي "ProgClone".  Miscompilation.cpp 601 <br><br>  يقوم المؤشر الذكي <i>ProgClone</i> أولاً بإصدار ملكية الكائن: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone));</code> </pre> <br>  في الواقع ، أصبح <i>ProgClone</i> مؤشرًا خاليًا - لذلك ، من الناحية الفنية ، يتم <i>إلغاء تأشير</i> المؤشر الخالي قليلاً: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first);</code> </pre> <br>  لكن هذا لن يحدث!  لاحظ أن الحلقة لا تنفذ في الواقع على الإطلاق. <br><br>  يتم مسح الحاوية <i>MiscompiledFunctions</i> أولاً: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">MiscompiledFunctions.clear();</code> </pre> <br>  ثم يتم استخدام حجمها في حالة حلقة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, e = MisCompFunctions.size(); i != e; ++i) {</code> </pre> <br>  من الواضح أن الحلقة لن تبدأ.  أعتقد أنه خطأ ، وكان المقصود من الكود أن يبدو بطريقة مختلفة. <br><br>  أعتقد أن ما نراه هنا هو تماثل الخطأ السيئ السمعة ، حيث يعمل أحد الأخطاء كقناع لآخر :). <br><br>  <b>مقتطف لا.</b>  <b>7: استخدام المؤشر بعد التحرك</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; TestOptimizer(BugDriver &amp;BD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Test, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Safe) { outs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Optimizing functions being tested: "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Optimized = BD.runPassesOn(Test.get(), BD.getPassesToRun()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Optimized) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Error running this sequence of passes"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" on the input program!\n"</span></span>; BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Test)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= BD.EmitProgressBitcode(*Test, "pass-error", false); // &lt;= if (Error E = BD.debugOptimizerCrash()) return std::move(E); return false; } .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: V522 [CWE-476] قد تتم عملية إلغاء تأشير المؤشر الخالي "اختبار".  Miscompilation.cpp 709 <br><br>  هذا واحد يشبه الحالة السابقة.  يتم نقل محتويات الكائن أولاً ثم استخدامها كما لو لم يحدث شيء.  تزايد هذا الخطأ شيوعًا بعد إضافة دلالات النقل إلى C ++.  هذا ما يعجبني في هذه اللغة!  يتم منحك طرقًا جديدة لإطلاق النار على قدمك ، مما يعني أن PVS-Studio سيكون لديك دائمًا عمل للقيام به :). <br><br>  <b>مقتطف لا.</b>  <b>8: مؤشر لاغية</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FunctionDumper::dump(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PDBSymbolTypeFunctionArg &amp;Symbol) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TypeId = Symbol.getTypeId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type = Symbol.getSession().getSymbolById(TypeId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  رسالة تشخيص PVS-Studio: V522 [CWE-476] قد يتم إلغاء تحديد مؤشر "النوع".  PrettyFunctionDumper.cpp 233 <br><br>  تمامًا مثل معالجات الأخطاء ، لا تحصل وظائف اختبار طباعة بيانات تصحيح الأخطاء عادةً على تغطية اختبار كافية أيضًا ، وهذا مثال على ذلك.  بدلاً من مساعدة المستخدم على حل مشكلاته ، تنتظره الوظيفة لإصلاحها. <br><br>  كود ثابت: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>;</code> </pre> <br>  <b>مقتطف لا.</b>  <b>9: مؤشر لاغية</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SearchableTableEmitter::collectTableEntries( GenericTable &amp;Table, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Record *&gt; &amp;Items) { .... RecTy *Ty = resolveTypes(Field.RecType, TI-&gt;getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Ty) <span class="hljs-comment"><span class="hljs-comment">// &lt;= PrintFatalError(Twine("Field '") + Field.Name + "' of table '" + Table.Name + "' has incompatible type: " + Ty-&gt;getAsString() + " vs. " + // &lt;= TI-&gt;getType()-&gt;getAsString()); .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: V522 [CWE-476] قد يتم إلغاء تنظيم المؤشر الخالي "Ty".  SearchableTableEmitter.cpp 614 <br><br>  لا أعتقد أنك بحاجة إلى أي تعليقات على هذا واحد. <br><br>  <b>مقتطف لا.</b>  <b>10: خطأ مطبعي</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FormatTokenLexer::tryMergeCSharpNullConditionals() { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Identifier = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Question = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... Identifier-&gt;ColumnWidth += Question-&gt;ColumnWidth; Identifier-&gt;Type = Identifier-&gt;Type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= Tokens.erase(Tokens.end() - 1); return true; }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V570</a> يتم تعيين متغير "المعرف -&gt; النوع" لنفسه.  FormatTokenLexer.cpp 249 <br><br>  تعيين متغير لنفسه هو عملية لا معنى لها.  يجب أن يكون لدى المبرمج القيام بما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Identifier-&gt;Type = Question-&gt;Type;</code> </pre> <br>  <b>مقتطف لا.</b>  <b>11: استراحة مشبوهة</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SystemZOperand::print(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindToken: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Token:"</span></span> &lt;&lt; getToken(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindReg: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Reg:"</span></span> &lt;&lt; SystemZInstPrinter::getRegisterName(getReg()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V622</a> [CWE-478] النظر في فحص بيان "التبديل".  من المحتمل أن يكون مشغل "الحالة" الأول مفقودًا.  SystemZAsmParser.cpp 652 <br><br>  هناك بيان <i>استراحة</i> مشبوه للغاية في البداية.  لا ينبغي أن يكون هناك شيء آخر هنا؟ <br><br>  <b>مقتطف لا.</b>  <b>12: التحقق من المؤشر بعد إلغاء التسجيل</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">InlineCost AMDGPUInliner::getInlineCost(CallSite CS) { Function *Callee = CS.getCalledFunction(); Function *Caller = CS.getCaller(); TargetTransformInfo &amp;TTI = TTIWP-&gt;getTTI(*Callee); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> llvm::InlineCost::getNever(<span class="hljs-string"><span class="hljs-string">"undefined callee"</span></span>); .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V595</a> [CWE-476] تم استخدام مؤشر "Callee" قبل أن يتم التحقق منه ضد nullptr.  خطوط التحقق: 172 ، 174. AMDGPUInline.cpp 172 <br><br>  يتم أولاً <i>إلغاء تحديد</i> مؤشر <i>Callee</i> عند <i>استدعاء</i> دالة <i>getTTI</i> . <br><br>  ثم اتضح أنه يجب التحقق من المؤشر <i>بحثًا</i> عن <i>nullptr</i> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration())</code> </pre> <br>  بعد فوات الأوان ... <br><br>  <b>قصاصات لا.</b>  <b>13 - لا ....: التحقق من المؤشر بعد إلغاء التسجيل</b> <br><br>  المثال السابق ليس فريدًا.  تم العثور على نفس المشكلة في هذا المقتطف: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeDoubleFP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallInst *CI, IRBuilder&lt;&gt; &amp;B, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isBinary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isPrecise = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... Function *CalleeFn = CI-&gt;getCalledFunction(); StringRef CalleeNm = CalleeFn-&gt;getName(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= AttributeList CalleeAt = CalleeFn-&gt;getAttributes(); if (CalleeFn &amp;&amp; !CalleeFn-&gt;isIntrinsic()) { // &lt;= .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: V595 [CWE-476] تم استخدام مؤشر "CalleeFn" قبل أن يتم التحقق منه ضد nullptr.  خطوط التحقق: 1079 ، 1081. SimplifyLibCalls.cpp 1079 <br><br>  وهذا واحد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Sema::InstantiateAttrs(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MultiLevelTemplateArgumentList &amp;TemplateArgs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Decl *Tmpl, Decl *New, LateInstantiatedAttrVec *LateAttrs, LocalInstantiationScope *OuterMostScope) { .... NamedDecl *ND = dyn_cast&lt;NamedDecl&gt;(New); CXXRecordDecl *ThisContext = dyn_cast_or_null&lt;CXXRecordDecl&gt;(ND-&gt;getDeclContext()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(), ND &amp;&amp; ND-&gt;isCXXInstanceMember()); // &lt;= .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: V595 [CWE-476] تم استخدام مؤشر "ND" قبل أن يتم التحقق منه ضد nullptr.  خطوط التحقق: 532 ، 534. SemaTemplateInstantiateDecl.cpp 532 <br><br>  و هنا: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V595 [CWE-476] تم استخدام مؤشر "U" قبل أن يتم التحقق منه مقابل nullptr.  خطوط التحقق: 404 ، 407. DWARFFormValue.cpp 404 </li><li style=";text-align:right;direction:rtl">  V595 [CWE-476] تم استخدام مؤشر "ND" قبل أن يتم التحقق منه مقابل nullptr.  خطوط التحقق: 2149 ، 2151. SemaTemplateInstantiate.cpp 2149 </li></ul><br>  ثم فقدت الاهتمام بتتبع تحذيرات V595 ، لذا لا يمكنني أن أخبرك ما إذا كانت هناك أخطاء أخرى من هذا النوع إلى جانب تلك الموضحة أعلاه.  أراهن هناك. <br><br>  <b>قصاصات لا.</b>  <b>17 ، 18: تحول مشبوه</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processLogicalImmediate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Imm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;Encoding)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Size = RegSize; .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V629</a> [CWE-190] فكر في فحص تعبير '~ (الحجم - 1) &lt;&lt; 1'.  تحويل البت لقيمة 32 بت مع توسع لاحق إلى نوع 64 بت.  AArch64AddressingModes.h 260 <br><br>  قد يكون هذا الرمز صحيحًا بالفعل ، لكنه يبدو غريبًا ويحتاج إلى فحص. <br><br>  افترض أن متغير <i>الحجم</i> له قيمة 16 ؛  ثم من المتوقع أن يحصل متغير <i>NImms</i> على القيمة التالية: <br><br>  1111111111111111111111111111111111111111111111111111111111100000 <br><br>  ولكن في الواقع سوف تحصل على القيمة: <br><br>  0000000000000000000000000000000011111111111111111111111111100000 <br><br>  يحدث هذا لأن جميع العمليات الحسابية تتم على نوع 32 بت غير موقَّع ، وعندها فقط يتم الترويج لها ضمنيًا إلى <i>uint64_t</i> ، مع استبعاد البتات الأكثر أهمية. <br><br>  يمكن إصلاح المشكلة كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  خطأ آخر من هذا النوع: V629 [CWE-190] فكر في فحص تعبير "Immr &lt;&lt; 6".  تحويل البت لقيمة 32 بت مع توسع لاحق إلى نوع 64 بت.  AArch64AddressingModes.h 269 <br><br>  <b>مقتطف لا.</b>  <b>19: هل فقدت كلمة مفتاحية أخرى</b> <b>؟</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AMDGPUAsmParser::cvtDPP(MCInst &amp;Inst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OperandVector &amp;Operands) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Op.isReg() &amp;&amp; Op.Reg.RegNo == AMDGPU::VCC) { <span class="hljs-comment"><span class="hljs-comment">// VOP2b (v_add_u32, v_sub_u32 ...) dpp use "vcc" token. // Skip it. continue; } if (isRegOrImmWithInputMods(Desc, Inst.getNumOperands())) { // &lt;= Op.addRegWithFPInputModsOperands(Inst, 2); } else if (Op.isDPPCtrl()) { Op.addImmOperands(Inst, 1); } else if (Op.isImm()) { // Handle optional arguments OptionalIdx[Op.getImmTy()] = I; } else { llvm_unreachable("Invalid operand type"); } .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V646</a> [CWE-670] خذ بعين الاعتبار فحص منطق التطبيق.  من المحتمل أن الكلمة الرئيسية "أخرى" مفقودة.  AMDGPUAsmParser.cpp 5655 <br><br>  هذا واحد ليس خطأ.  منذ ذلك <i>الحين</i> ، <i>تستمر</i> المجموعة الأولى <i>إذا</i> انتهت العبارة ، فلا يهم إذا كانت تحتوي على كلمة رئيسية أخرى أم لا.  السلوك سيكون هو نفسه في أي حال.  ومع ذلك ، فإن <i>الشيء</i> المفقود يجعل الشفرة أقل قابلية للقراءة ، وبالتالي ، يحتمل أن تكون خطرة.  إذا اختفت المتابعة في يوم من الأيام ، فسيتغير السلوك بشكل كبير.  أوصي بشدة بإضافة <i>آخر</i> . <br><br>  <b>مقتطف لا.</b>  <b>20: أربعة أخطاء مطبعية</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">LLVM_DUMP_METHOD <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Symbol::dump(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUndefined()) Result += <span class="hljs-string"><span class="hljs-string">"(undef) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakDefined()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-def) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakReferenced()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-ref) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isThreadLocalValue()) Result += <span class="hljs-string"><span class="hljs-string">"(tlv) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SymbolKind::GlobalSymbol: Result + Name.str(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case SymbolKind::ObjectiveCClass: Result + "(ObjC Class) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCClassEHType: Result + "(ObjC Class EH) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCInstanceVariable: Result + "(ObjC IVar) " + Name.str(); // &lt;= break; } OS &lt;&lt; Result; }</span></span></code> </pre> <br>  رسائل تشخيص PVS-Studio: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V655 [CWE-480] كانت السلاسل متسلسلة ولكن غير مستخدمة.  النظر في فحص التعبير 'النتيجة + Name.str ()'.  Symbol.cpp 32 </li><li style=";text-align:right;direction:rtl">  V655 [CWE-480] كانت السلاسل متسلسلة ولكن غير مستخدمة.  النظر في فحص التعبير "النتيجة +" (فئة ObjC) "+ Name.str ()" التعبير.  Symbol.cpp 35 </li><li style=";text-align:right;direction:rtl">  V655 [CWE-480] كانت السلاسل متسلسلة ولكن غير مستخدمة.  النظر في فحص التعبير "النتيجة +" (ObjC Class EH) "+ Name.str ()" التعبير.  Symbol.cpp 38 </li><li style=";text-align:right;direction:rtl">  V655 [CWE-480] كانت السلاسل متسلسلة ولكن غير مستخدمة.  النظر في فحص التعبير "النتيجة +" (ObjC IVar) "+ Name.str ()" التعبير.  Symbol.cpp 41 </li></ul><br>  استخدم المبرمج بطريق الخطأ عامل التشغيل + بدلاً من + = وانتهى الأمر بأربعة بنى لا معنى لها. <br><br>  <b>مقتطف لا.</b>  <b>21: سلوك غير محدد</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReqFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;StringRef, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;FeaturesMap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Record *&gt; &amp;ReqFeatures)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;R : ReqFeatures) { StringRef AsmCondString = R-&gt;getValueAsString(<span class="hljs-string"><span class="hljs-string">"AssemblerCondString"</span></span>); SmallVector&lt;StringRef, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; Ops; SplitString(AsmCondString, Ops, <span class="hljs-string"><span class="hljs-string">","</span></span>); assert(!Ops.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"AssemblerCondString cannot be empty"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Op : Ops) { assert(!Op.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Empty operator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FeaturesMap.find(Op) == FeaturesMap.end()) FeaturesMap[Op] = FeaturesMap.size(); } } }</code> </pre> <br>  حاول اكتشاف الأخطاء بنفسك أولاً.  لقد أضفت الصورة حتى لا تطلع على الإجابة فورًا: <br><br><p style=";text-align:right;direction:rtl"></p><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/d5d/183/d4e/d5d183d4e2d3107bc512e52d893fda25.png" alt="؟؟؟"></div><br><br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V708</a> [CWE-758] يتم استخدام البناء الخطير: "FeaturesMap [Op] = FeaturesMap.size ()" ، حيث تكون "FeaturesMap" من فئة "map".  هذا قد يؤدي إلى سلوك غير محدد.  RISCVCompressInstEmitter.cpp 490 <br><br>  الخط الخاطئ هو هذا واحد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">FeaturesMap[Op] = FeaturesMap.size();</code> </pre> <br>  إذا لم يتم العثور على عنصر <i>Op</i> ، يقوم البرنامج بإنشاء عنصر جديد في الخريطة ويعين له إجمالي عدد العناصر في هذه الخريطة.  أنت لا تعرف ما إذا كان سيتم استدعاء وظيفة <i>الحجم</i> قبل أو بعد إضافة العنصر الجديد. <br><br>  <b>قصاصات لا.</b>  <b>22 - لا</b>  <b>24: تكرار المهام</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Error MachOObjectFile::checkSymbolTable() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MachO::nlist STE = getSymbolTableEntry(SymDRI); NType = STE.n_type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= NType = STE.n_type; // &lt;= NSect = STE.n_sect; NDesc = STE.n_desc; NStrx = STE.n_strx; NValue = STE.n_value; } .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V519</a> [CWE-563] تم تعيين متغير "NType" القيم مرتين على التوالي.  ربما هذا خطأ.  خطوط التحقق: 1663 ، 1664. MachOObjectFile.cpp 1664 <br><br>  لا أعتقد أنه خطأ حقيقي - إنه مهمة مكررة.  لكنه لا يزال عيب. <br><br>  حالتان أخريان: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V519 [CWE-563] تم تعيين متغير "B.NDesc" لقيم مرتين متتاليتين.  ربما هذا خطأ.  خطوط التحقق: 1488 ، 1489. llvm-nm.cpp 1489 </li><li style=";text-align:right;direction:rtl">  V519 [CWE-563] يتم تعيين قيم المتغير مرتين متتاليتين.  ربما هذا خطأ.  خطوط الفحص: 59 ، 61. coff2yaml.cpp 61 </li></ul><br>  <b>قصاصات لا.</b>  <b>25 - رقم</b>  <b>27: المزيد من المهام المكررة</b> <br><br>  تتعامل هذه الإصدارات مع إصدارات مختلفة قليلاً من المهام المكررة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Vectorizer::vectorizeLoadChain( ArrayRef&lt;Instruction *&gt; Chain, SmallPtrSet&lt;Instruction *, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; *InstructionsProcessed) { .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Alignment = getAlignment(L0); .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> NewAlign = getOrEnforceKnownAlignment(L0-&gt;getPointerOperand(), StackAdjustedAlignment, DL, L0, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, &amp;DT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NewAlign != <span class="hljs-number"><span class="hljs-number">0</span></span>) Alignment = NewAlign; Alignment = NewAlign; .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: V519 [CWE-563] تم تعيين متغير "المحاذاة" للقيم مرتين متتاليتين.  ربما هذا خطأ.  خطوط التحقق: 1158 ، 1160. LoadStoreVectorizer.cpp 1160 <br><br>  هذا مقتطف غريب جدًا ، وربما يحتوي على خطأ منطقي.  يتم تعيين قيمة " <i>المحاذاة"</i> أولاً على أساس الشرط ، ثم يتم تعيين القيمة مرة أخرى ، ولكن دون أي فحص مسبق. <br><br>  عيوب مماثلة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V519 [CWE-563] تم تعيين متغير "Effects" لقيم مرتين متتاليتين.  ربما هذا خطأ.  خطوط التحقق: 152 ، 165. WebAssemblyRegStackify.cpp 165 </li><li style=";text-align:right;direction:rtl">  V519 [CWE-563] تم تعيين متغير "ExpectNoDerefChunk" لقيم مرتين متتاليتين.  ربما هذا خطأ.  خطوط التحقق: 4970 ، 4973. SemaType.cpp 4973 </li></ul><br>  <b>مقتطف لا.</b>  <b>28: دائما الحالة الحقيقية</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrefixes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct InternalInstruction* insn)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byte = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> nextByte; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byte == <span class="hljs-number"><span class="hljs-number">0xf3</span></span> &amp;&amp; (nextByte == <span class="hljs-number"><span class="hljs-number">0x88</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0x89</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc6</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc7</span></span>)) { insn-&gt;xAcquireRelease = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextByte != <span class="hljs-number"><span class="hljs-number">0x90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// PAUSE instruction support // &lt;= break; } .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V547</a> [CWE-571] التعبير 'nextByte! = 0x90' صحيح دائمًا.  X86DisassemblerDecoder.cpp 379 <br><br>  الشيك لا معنى له.  لا <i>يكون</i> متغير <i>nextByte</i> مساوياً لـ <i>0x90</i> : إنه يتبع منطقياً فقط من الفحص السابق.  هذا يجب أن يكون بعض خطأ المنطق. <br><br>  <b>قصاصات لا.</b>  <b>29 - لا ....: دائمًا صحيح / خطأ</b> <br><br>  هناك العديد من التحذيرات حول شرط كامل ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V547</a> ) أو جزء من شرط ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V560</a> ) يكون دائمًا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">صوابًا</a> أو خطأ.  بدلاً من الأخطاء الأصلية ، غالبًا ما تكون هذه مجرد رموز سيئة وتأثيرات التوسع الكلي وما إلى ذلك.  ومع ذلك ، لا يزال يجب التحقق من كل هذه التحذيرات لأن بعضها قد يشير إلى أخطاء منطقية حقيقية.  على سبيل المثال ، لا يبدو المقتطف التالي صحيحًا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DecodeStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeGPRPairRegisterClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MCInst &amp;Inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegNo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Decoder)</span></span></span><span class="hljs-function"> </span></span>{ DecodeStatus S = MCDisassembler::Success; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RegNo &gt; <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCDisassembler::Fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((RegNo &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) || RegNo == <span class="hljs-number"><span class="hljs-number">0xe</span></span>) S = MCDisassembler::SoftFail; .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V560</a> [CWE-570] جزء من التعبير الشرطي خطأ دائمًا: RegNo == 0xe.  ARMDisassembler.cpp 939 <br><br>  ثابت <i>0xE</i> هو الرقم العشري 14. التحقق من <i>RegNo == 0xe</i> غير منطقي لأنه إذا كانت <i>RegNo&gt; 13</i> ، <i>فستعود</i> الوظيفة. <br><br>  لقد رأيت الكثير من تحذيرات V547 و V560 الأخرى ، لكن ، مثلما <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">حدث</a> مع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V595</a> ، لم أكن متحمسًا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لفحصها</a> نظرًا لأنني امتلكت بالفعل مادة كافية لمقال :).  لذلك ، لا توجد أرقام لإجمالي عدد الأخطاء من هذا النوع في LLVM. <br><br>  إليك مثال لتوضيح السبب في أن التحقق من هذه التحذيرات ممل.  المحلل هو الصحيح تماما عند إصدار تحذير على التعليمات البرمجية التالية.  لكنه ما زال ليس خطأ. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> UnwrappedLineParser::parseBracedList(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ContinueOnSemicolons, tok::TokenKind ClosingBraceKind) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasError = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... HasError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ContinueOnSemicolons) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !HasError; .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: V547 [CWE-570] التعبير '! HasError' غير صحيح دائمًا.  UnwrappedLineParser.cpp 1635 <br><br>  <b>مقتطف لا.</b>  <b>30: عودة مشبوهة</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isImplicitlyDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MachineRegisterInfo &amp;MRI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MachineRegisterInfo::def_instr_iterator It = MRI.def_instr_begin(Reg), E = MRI.def_instr_end(); It != E; ++It) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*It).isImplicitDef(); } .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V612</a> [CWE-670] "عودة" غير مشروطة داخل حلقة.  R600OptimizeVectorRegisters.cpp 63 <br><br>  إنها إما خطأ أو تقنية ترميز محددة تهدف إلى توصيل فكرة ما إلى زملائها في المبرمجين.  بالنسبة لي ، لا يخبرني أي شيء إلا أنه رمز مشبوه للغاية.  من فضلك لا تكتب رمز مثل هذا :). <br><br>  الشعور بالتعب؟  حسنا ، لقد حان الوقت لصنع بعض الشاي أو القهوة. <br><br><p style=";text-align:right;direction:rtl"></p><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/f86/58f/8a2f8658fdacb0dde918807666d1cd39.png" alt="قهوة"></div><br><br><h2 style=";text-align:right;direction:rtl">  العيوب التي عثر عليها التشخيص الجديد </h2><br>  أعتقد أن 30 مثالًا كافيًا للتشخيصات الحالية.  الآن ، لنرى ما إذا كان بإمكاننا العثور على أي شيء مثير للاهتمام من خلال التشخيصات الجديدة ، التي تمت إضافتها بعد الفحص <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">السابق</a> .  على مدى العامين الماضيين ، تم تمديد وحدة محلل C ++ مع 66 تشخيص جديد. <br><br>  <b>مقتطف لا.</b>  <b>31: رمز غير قابل للوصول</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Error CtorDtorRunner::run() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> CtorDtorMap = ES.lookup(JITDylibSearchList({{&amp;JD, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}}), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Names), NoDependenciesToRegister, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CtorDtorMap.takeError(); CtorDtorsByPriority.clear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V779</a> [CWE-561] تم اكتشاف رمز <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">يتعذر</a> الوصول إليه.  من الممكن وجود خطأ.  ExecuteUtils.cpp 146 <br><br>  كما ترى ، ينتهي كلا فرعي العبارة <i>if</i> ببيان <i>إرجاع</i> ، مما يعني <i>أنه</i> لن يتم مسح حاوية <i>CtorDtorsByPriority</i> أبدًا. <br><br>  <b>مقتطف لا.</b>  <b>32: رمز غير قابل للوصول</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LLParser::ParseSummaryEntry() { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Lex.getKind()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_gv: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseGVEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_module: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseModuleEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_typeid: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; // &lt;= default: return Error(Lex.getLoc(), "unexpected summary kind"); } Lex.setIgnoreColonInIdentifiers(false); // &lt;= return false; }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: V779 [CWE-561] تم اكتشاف رمز يتعذر الوصول إليه.  من الممكن وجود خطأ.  LLParser.cpp 835 <br><br>  هذا واحد مثير للاهتمام.  ألقِ نظرة على هذا الجزء أولاً: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br>  يبدو أنه لا يوجد شيء غريب حول هذا الرمز ؛  بيان <i>الاستراحة</i> غير ضروري ويمكن إزالته بأمان.  لكنها ليست بهذه البساطة. <br><br>  يتم تشغيل التحذير بواسطة الأسطر التالية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Lex.setIgnoreColonInIdentifiers(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  في الواقع ، هذا الرمز غير قابل للوصول.  جميع تسميات العلبة الخاصة ببيان <i>التبديل</i> تنتهي <i>بعودة</i> ، <i>والكسر</i> الوحيد الذي لا معنى له لا يبدو ضارًا بعد الآن!  ماذا لو كان من المفترض أن ينتهي أحد الفروع <i>باستراحة</i> بدلاً من <i>العودة</i> ؟ <br><br>  <b>مقتطف لا.</b>  <b>33: تطهير عرضي من البتات الأكثر أهمية</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStubAlignment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Arch == Triple::systemz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; RuntimeDyldImpl::emitSection(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjectFile &amp;Obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SectionRef &amp;Section, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCode) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> DataSize = Section.getSize(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StubBufSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V784</a> حجم قناع البت أقل من حجم المعامل الأول.  هذا سوف يسبب فقدان أعلى بت.  RuntimeDyld.cpp 815 <br><br>  لاحظ أن دالة <i>getStubAlignment</i> تُرجع قيمة <i>غير موقعة</i> .  دعونا نرى كيف سيتم تقييم التعبير ، على افتراض أن الدالة ستُرجع القيمة 8: <br><br>  ~ (getStubAlignment () - 1) <br><br>  ~ (8u-1) <br><br>  0xFFFFFFF8u <br><br>  لاحظ الآن أن نوع متغير <i>DataSize</i> غير 64 بت غير موقعة.  لذلك اتضح أن تنفيذ العملية DataSize &amp; 0xFFFFFFF8 سيؤدي إلى مسح جميع البتات الـ 32 الأكثر أهمية في القيمة.  لا أعتقد أن المبرمج أراد ذلك.  ربما قصدوها أن تكون DataSize &amp; 0xFFFFFFFFFFFFFFFFFF8u. <br><br>  لإصلاح الخطأ ، يجب إعادة كتابة الكود كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">DataSize &amp;= ~(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(getStubAlignment()) - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  أو مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1U</span></span>LL);</code> </pre> <br>  <b>مقتطف لا.</b>  <b>34: سيئة تحويل نوع صريح</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scaleShuffleMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Scale, ArrayRef&lt;T&gt; Mask, SmallVectorImpl&lt;T&gt; &amp;ScaledMask)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; Scale &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Unexpected scaling factor"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumElts = Mask.size(); ScaledMask.assign(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(NumElts * Scale), <span class="hljs-number"><span class="hljs-number">-1</span></span>); .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V1028</a> [CWE-190] احتمال تجاوز السعة.  النظر في صب المعاملات من عامل التشغيل "NumElts * Scale" إلى نوع "size_t" ، وليس النتيجة.  X86ISelLowering.h 1577 <br><br>  يتم استخدام تحويل النوع الصريح لتجنب حدوث تجاوز سعة عند ضرب متغيرات type <i>int</i> .  في هذه الحالة ، مع ذلك ، لا يعمل لأن الضرب سيحدث أولاً وعندها فقط سيتم ترقية النتيجة 32 بت لكتابة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><i>size_t</i></a> . <br><br>  <b>مقتطف لا.</b>  <b>35: نسخة سيئة لصق</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Instruction *InstCombiner::visitFCmpInst(FCmpInst &amp;I) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op0, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op0, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return &amp;I; } .... }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V778</a> [CWE-682] تم العثور على شظايا رمز مماثلة.  ربما ، هذا خطأ مطبعي ويجب استخدام متغير "Op1" بدلاً من "Op0".  InstCombineCompares.cpp 5507 <br><br>  يكتشف هذا التشخيص الرائع الجديد المواقف التي تتم فيها كتابة جزء من الشفرة باستخدام لصق النسخ ، مع تغيير جميع الأسماء باستثناء واحد. <br><br>  لاحظ أنه تم تغيير جميع <i>Op0</i> باستثناء واحد إلى <i>Op1</i> في الكتلة الثانية.  من المحتمل أن يبدو الرمز كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op1-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; }</code> </pre> <br>  <b>مقتطف لا.</b>  <b>36: متغيرات مختلطة</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode; Status() : Mask(<span class="hljs-number"><span class="hljs-number">0</span></span>), Mode(<span class="hljs-number"><span class="hljs-number">0</span></span>){}; Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { Mode &amp;= Mask; }; .... };</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V1001</a> [CWE-563] تم تعيين متغير "الوضع" ولكن لا يتم استخدامه بحلول نهاية الوظيفة.  SIModeRegister.cpp 48 <br><br>  من الخطر للغاية أن يكون لديك نفس أسماء وسيطات الدوال مثل أعضاء الفصل لأنك تخاطر باختلاطها.  ما تراه هنا هو مثال على ذلك.  التعبير التالي بلا معنى: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Mode &amp;= Mask;</code> </pre> <br>  يتم تغيير الحجة ولكن لم تستخدم بعد ذلك.  ربما يبدو هذا المقتطف كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Mode &amp;= Mask; };</code> </pre> <br>  <b>مقتطف لا.</b>  <b>37: متغيرات مختلطة</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionBase</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SymbolTableSection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SectionBase { .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SymbolTableSection::addSymbol(Twine Name, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Bind, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Type, SectionBase *DefinedIn, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Visibility, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Shndx, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size) { .... Sym.Value = Value; Sym.Visibility = Visibility; Sym.Size = Size; Sym.Index = Symbols.size(); Symbols.emplace_back(llvm::make_unique&lt;Symbol&gt;(Sym)); Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize; }</code> </pre> <br>  رسالة تشخيص PVS-Studio: V1001 [CWE-563] تم تعيين متغير "الحجم" ولكن لا يتم استخدامه بحلول نهاية الوظيفة.  Object.cpp 424 <br><br>  هذا واحد يشبه المثال السابق.  الإصدار الصحيح: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize;</code> </pre> <br>  <b>قصاصات لا.</b>  <b>38 - رقم</b>  <b>47: مفقود مؤشر الاختيار</b> <br><br>  نظرنا إلى بعض الأمثلة على تحذير <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V595</a> سابقًا.  ما يكتشفه هو موقف عندما يتم إلغاء تأشير المؤشر أولاً ثم يتم فحصه فقط.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V1004</a> التشخيصي الجديد هو عكس ذلك ، ويكتشف الكثير من الأخطاء أيضًا.  إنه يبحث عن مؤشرات تم اختبارها بالفعل ولا يتم اختبارها مرة أخرى عند الضرورة.  فيما يلي بعض الأخطاء من هذا النوع الموجودة في كود LLVM. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGEPCost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type *PointeeType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *Ptr, ArrayRef&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *&gt; Operands)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= assert(....); BaseGV = dyn_cast&lt;GlobalValue&gt;(Ptr-&gt;stripPointerCasts()); } bool HasBaseReg = (BaseGV == nullptr); auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType()); // &lt;= .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: V1004 [CWE-476] تم استخدام مؤشر "Ptr" بطريقة غير آمنة بعد أن تم التحقق منه ضد nullptr.  خطوط التحقق: 729 ، 738. TargetTransformInfoImpl.h 738 <br><br>  <i>Ptr</i> يمكن أن يكون <i>nullptr</i> ، والذي يشار إليه بواسطة الشيك: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)</code> </pre> <br>  ومع ذلك ، يتم إلغاء تأشير المؤشر نفسه دون إجراء هذا الفحص قليلاً: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType());</code> </pre> <br>  حالة أخرى مماثلة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">llvm::DISubprogram *CGDebugInfo::getFunctionFwdDeclOrStub(GlobalDecl GD, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Stub) { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *FD = dyn_cast&lt;FunctionDecl&gt;(GD.getDecl()); SmallVector&lt;QualType, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; ArgTypes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FD) <span class="hljs-comment"><span class="hljs-comment">// &lt;= for (const ParmVarDecl *Parm : FD-&gt;parameters()) ArgTypes.push_back(Parm-&gt;getType()); CallingConv CC = FD-&gt;getType()-&gt;castAs&lt;FunctionType&gt;()-&gt;getCallConv(); // &lt;= .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: V1004 [CWE-476] تم استخدام مؤشر 'FD' بشكل غير آمن بعد أن تم التحقق منه ضد nullptr.  خطوط التحقق: 3228 ، 3231. CGDebugInfo.cpp 3231 <br><br>  لاحظ مؤشر <i>FD</i> .  هذا الخطأ واضح ومباشر ، لذا لا توجد تعليقات على هذا. <br><br>  واحد آخر هنا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computePolynomialFromPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value &amp;Ptr, Polynomial &amp;Result, Value *&amp;BasePtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL)</span></span></span><span class="hljs-function"> </span></span>{ PointerType *PtrTy = dyn_cast&lt;PointerType&gt;(Ptr.getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PtrTy) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= Result = Polynomial(); BasePtr = nullptr; } unsigned PointerBits = DL.getIndexSizeInBits(PtrTy-&gt;getPointerAddressSpace()); // &lt;= .... }</span></span></code> </pre> <br>  رسالة تشخيص PVS-Studio: V1004 [CWE-476] تم استخدام مؤشر "PtrTy" بطريقة غير آمنة بعد أن تم التحقق منه ضد nullptr.  خطوط التحقق: 960 ، 965. InterleavedLoadCombinePass.cpp 965 <br><br>  كيف يمكنك تجنب أخطاء من هذا القبيل؟  كن حذرًا جدًا عند مراجعة الكود والتحقق منه بانتظام باستخدام PVS-Studio. <br><br>  لا أعتقد أننا يجب أن ندرس أمثلة أخرى من هذا النوع ، لذلك إليك مجرد قائمة بالتحذيرات: <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V1004 [CWE-476] تم استخدام مؤشر "Expr" بطريقة غير آمنة بعد أن تم التحقق منه ضد nullptr.  خطوط التحقق: 1049 ، 1078. DebugInfoMetadata.cpp 1078 </li><li style=";text-align:right;direction:rtl">  V1004 [CWE-476] تم استخدام مؤشر "PI" بطريقة غير آمنة بعد أن تم التحقق منه ضد nullptr.  خطوط التحقق: 733 ، 753. LegacyPassManager.cpp 753 </li><li style=";text-align:right;direction:rtl">  V1004 [CWE-476] تم استخدام مؤشر "StatepointCall" بطريقة غير آمنة بعد أن تم التحقق منه ضد nullptr.  خطوط التحقق: 4371 ، 4379. Verifier.cpp 4379 </li><li style=";text-align:right;direction:rtl">  V1004 [CWE-476] تم استخدام مؤشر "RV" بطريقة غير آمنة بعد أن تم التحقق منه ضد nullptr.  خطوط التحقق: 2263 ، 2268. TGParser.cpp 2268 </li><li style=";text-align:right;direction:rtl">  V1004 [CWE-476] تم استخدام مؤشر "CalleeFn" بشكل غير آمن بعد أن تم التحقق منه ضد nullptr.  خطوط التحقق: 1081 ، 1096. SimplifyLibCalls.cpp 1096 </li><li style=";text-align:right;direction:rtl">  V1004 [CWE-476] تم استخدام مؤشر "TC" بطريقة غير آمنة بعد أن تم التحقق منه ضد nullptr.  خطوط الفحص: 1819 ، 1824. Driver.cpp 1824 </li></ul><br>  <b>قصاصات لا.</b>  <b>48 - رقم</b>  <b>60: ليست حرجة ولكن لا يزال هناك عيب (تسرب ذاكرة محتمل)</b> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutator&gt; createISelMutator() { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutationStrategy&gt;&gt; Strategies; Strategies.emplace_back( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectorIRStrategy(InjectorIRStrategy::getDefaultOps())); .... }</code> </pre> <br>  رسالة تشخيص PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">V1023</a> [CWE-460] يضاف مؤشر بدون مالك إلى حاوية "الاستراتيجيات" بواسطة طريقة "emplace_back".  سوف يحدث تسرب للذاكرة في حالة حدوث استثناء.  llvm-isel-fuzzer.cpp 58 <br><br>  لا يمكنك ببساطة إرسال <i>xxx.push_back (جديد X)</i> لإلحاق عنصر بحاوية من النوع <i>std :: vector &lt;std :: unique_ptr &lt;X&gt;&gt;</i> لأنه لا يوجد <i>ممثل</i> ضمني من <i>X *</i> إلى <i>std :: unique_ptr &lt; X&gt;</i> . <br><br>  يتمثل الحل الشائع في كتابة <i>xxx.emplace_back (X جديدة)</i> نظرًا لأنه قابل <i>للترجمة</i> : تقوم الطريقة <i>emplace_back</i> بإنشاء العنصر مباشرةً من الوسيطات ، وبالتالي ، يمكنك استخدام <i>مُنشئين</i> صريحين. <br><br>  لكن هذا الحل ليس آمنا.  إذا كان المتجه ممتلئًا ، سيتم إعادة تخصيص الذاكرة.  قد تفشل هذه العملية وينتهي الأمر برفع استثناء <i>std :: bad_alloc</i> .  في هذه الحالة ، سيتم فقد المؤشر ولن يتمكن البرنامج من حذف الكائن الذي تم إنشاؤه. <br><br>  الحل الأكثر أمانًا هو إنشاء <i>unique_ptr</i> ، والذي سيحتفظ <i>بالمؤشر</i> حتى يحاول المتجه إعادة تخصيص الذاكرة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X))</code> </pre> <br>  يسمح لك معيار C ++ 14 باستخدام 'std :: make_unique': <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;X&gt;())</code> </pre> <br>  هذا النوع من العيوب ليس له أي تأثير في LLVM.  سيتم ببساطة إنهاء التجميع إذا فشل تخصيص الذاكرة.  ومع ذلك ، قد يكون الأمر بالغ الأهمية في التطبيقات ذات فترة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">التشغيل</a> الطويلة ، والتي لا يمكن ببساطة إنهاؤها عند حدوث فشل في تخصيص الذاكرة. <br><br>  لذا ، على الرغم من أن هذا الرمز ليس خطيرًا على LLVM ، فقد اعتقدت أنه لا يزال يتعين علي إخبارك بنمط الأخطاء هذا وحقيقة أن PVS-Studio يمكنه الآن اكتشافه. <br><br>  حالات مماثلة أخرى: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  V1023 [CWE-460] يضاف مؤشر بدون مالك إلى حاوية "التمريرات" بواسطة طريقة "emplace_back".  سوف يحدث تسرب للذاكرة في حالة حدوث استثناء.  PassManager.h 546 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'AAs' container by the 'emplace_back' method. A memory leak will occur in case of an exception. AliasAnalysis.h 324 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Entries' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DWARFDebugFrame.cpp 519 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'AllEdges' container by the 'emplace_back' method. A memory leak will occur in case of an exception. CFGMST.h 268 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'VMaps' container by the 'emplace_back' method. A memory leak will occur in case of an exception. SimpleLoopUnswitch.cpp 2012 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Records' container by the 'emplace_back' method. A memory leak will occur in case of an exception. FDRLogBuilder.h 30 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'PendingSubmodules' container by the 'emplace_back' method. A memory leak will occur in case of an exception. ModuleMap.cpp 810 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Objects' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DebugMap.cpp 88 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 60 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 685 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 686 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 688 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 689 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 690 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 691 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 692 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 693 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 694 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Operands' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 1911 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Stash' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2100 </li><li style=";text-align:right;direction:rtl"> V1023 [CWE-460] A pointer without owner is added to the 'Matchers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2702 </li></ul><br><h2 style=";text-align:right;direction:rtl">  استنتاج </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كتبت 60 تحذيراً وتوقفت عند ذلك. </font><font style="vertical-align: inherit;">هل عثر PVS-Studio على أي أخطاء أخرى في LLVM؟ </font><font style="vertical-align: inherit;">نعم فعلت. </font><font style="vertical-align: inherit;">لكن بينما كنت أكتب الأمثلة ، سقط الليل ، لذا قررت أن أتوقف. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أتمنى أن تستمتع بقراءة هذا المقال وشجعك على تجربة محلل PVS-Studio بنفسك. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تفضل بزيارة </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذه الصفحة</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لتنزيل المحلل والحصول على مفتاح تجريبي. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الأهم من ذلك ، استخدم التحليل الثابت بانتظام. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الشيكات لمرة واحدة</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، مثل تلك التي نقوم بها لتشجيع التحليل الثابت والترويج لـ PVS-Studio ، ليست هي السيناريو العادي. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نتمنى لك التوفيق في تحسين جودة الشفرة وموثوقيتها!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar450002/">https://habr.com/ru/post/ar450002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar449992/index.html">عرض NodeMCU لنموذج برنامج التشغيل البسيط (SDM): واجهة مستخدم ديناميكية</a></li>
<li><a href="../ar449994/index.html">ستساعدك القواعد الذهبية الثمانية لشنايدرمان على إنشاء واجهة أفضل</a></li>
<li><a href="../ar449996/index.html">فهم خوارزمية FFT</a></li>
<li><a href="../ar449998/index.html">أسئلة وأجوبة: ما يحتاج المسافر إلى معرفته حول اللقاحات قبل السفر</a></li>
<li><a href="../ar450000/index.html">(من اليمين إلى اليسار (من خلال النظر الزجاج</a></li>
<li><a href="../ar450004/index.html">سريع C / C ++ ذاكرة التخزين المؤقت ، وسلامة الموضوع</a></li>
<li><a href="../ar450006/index.html">تبريد مركز البيانات التبريد: أي المبرد للاختيار؟</a></li>
<li><a href="../ar450008/index.html">ابحث عن الأخطاء في LLVM 8 باستخدام محلل PVS-Studio</a></li>
<li><a href="../ar450010/index.html">تخزين ، النسخ الاحتياطي وفهرسة الصور</a></li>
<li><a href="../ar450016/index.html">إنشاء نظام تحقق رسمي من الصفر. الجزء 1: شخصية الجهاز الظاهري في PHP وبيثون</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>