<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚧 🙉 🤽🏿 10 nicht offensichtliche Vorteile der Verwendung von Rust 👨🏿‍🏭 🦏 👨🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust ist eine junge und ehrgeizige Systemprogrammiersprache. Es implementiert die automatische Speicherverwaltung ohne Garbage Collector und anderen A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 nicht offensichtliche Vorteile der Verwendung von Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/"><p>  Rust ist eine junge und ehrgeizige Systemprogrammiersprache.  Es implementiert die automatische Speicherverwaltung ohne Garbage Collector und anderen Aufwand für die Ausführung.  Darüber hinaus wird die Standardsprache in der Rust-Sprache verwendet, es gibt beispiellose Regeln für den Zugriff auf veränderbare Daten und die Lebensdauer der Verbindungen wird ebenfalls berücksichtigt.  Dies ermöglicht ihm die Gewährleistung der Speichersicherheit und erleichtert die Multithread-Programmierung aufgrund des Mangels an Datenrasen. </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p> All dies ist bereits jedem bekannt, der die Entwicklung moderner Programmiertechnologien zumindest ein wenig verfolgt.  Aber was ist, wenn Sie kein Systemprogrammierer sind und nicht viele Multithread-Codes in Ihren Projekten enthalten, Sie aber dennoch von der Leistung von Rust angezogen werden?  Erhalten Sie zusätzliche Vorteile aus der Verwendung in Anwendungen?  Oder alles, was er Ihnen zusätzlich geben wird, ist ein harter Kampf mit dem Compiler, der Sie dazu zwingt, das Programm so zu schreiben, dass es ständig den Regeln der Sprache für Ausleihe und Besitz folgt? </p><br><p>  Dieser Artikel hat ein Dutzend nicht offensichtlicher und nicht besonders beworbener Vorteile der Verwendung von Rust gesammelt, die Ihnen hoffentlich bei der Entscheidung über die Wahl dieser Sprache für Ihre Projekte helfen werden. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1. Die Universalität der Sprache </h2><br><p>  Trotz der Tatsache, dass Rust als Sprache für die Systemprogrammierung positioniert ist, eignet es sich auch zur Lösung von Problemen auf hoher Ebene.  Sie müssen nicht mit Rohzeigern arbeiten, es sei denn, Sie benötigen sie für Ihre Aufgabe.  Die Standard-Sprachbibliothek hat bereits die meisten Typen und Funktionen implementiert, die möglicherweise für die Anwendungsentwicklung erforderlich sind.  Sie können auch problemlos externe Bibliotheken verbinden und verwenden.  Das Typsystem und die verallgemeinerte Programmierung in Rust ermöglichen die Verwendung von Abstraktionen auf ziemlich hohem Niveau, obwohl OOP in der Sprache nicht direkt unterstützt wird. </p><br><p>  Schauen wir uns einige einfache Beispiele für die Verwendung von Rust an. </p><br><p>  Ein Beispiel für die Kombination von zwei Iteratoren zu einem Iterator über Elementpaare: </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><blockquote>  Hinweis: Ein Aufruf des Formatnamens <code>name!(...)</code> ist ein Aufruf eines Funktionsmakros.  Die Namen solcher Makros in Rust enden immer mit einem Symbol <code>!</code>  damit sie von Funktionsnamen und anderen Bezeichnern unterschieden werden können.  Die Vorteile der Verwendung von Makros werden unten erläutert. </blockquote><p>  Ein Beispiel für die Verwendung der externen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>regex</code></a> Bibliothek zum Arbeiten mit regulären Ausdrücken: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Ein Beispiel für die Implementierung des <code>Add</code> für die eigene <code>Point</code> , um den Additionsoperator zu überladen: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Ein Beispiel für die Verwendung eines generischen Typs in einer Struktur: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Auf Rust können Sie effiziente Systemdienstprogramme, große Desktopanwendungen, Microservices, Webanwendungen (einschließlich des Client-Teils, da Rust in Wasm kompiliert werden kann) und mobile Anwendungen schreiben (obwohl das Sprachökosystem in dieser Richtung noch schlecht entwickelt ist).  Diese Vielseitigkeit kann für Teams mit mehreren Projekten von Vorteil sein, da Sie in vielen verschiedenen Projekten dieselben Ansätze und dieselben Module verwenden können.  Wenn Sie daran gewöhnt sind, dass jedes Werkzeug für seinen engen Anwendungsbereich ausgelegt ist, versuchen Sie, Rust als Werkzeugkasten mit der gleichen Zuverlässigkeit und Bequemlichkeit zu betrachten.  Vielleicht haben Sie genau das vermisst. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2. Praktische Tools für das Build- und Abhängigkeitsmanagement </h2><br><p>  Dies wird eindeutig nicht angekündigt, aber viele bemerken, dass Rust über eines der besten Build- und Abhängigkeitsmanagementsysteme verfügt, die derzeit verfügbar sind.  Wenn Sie in C oder C ++ programmiert haben und die Frage der schmerzlosen Verwendung externer Bibliotheken für Sie ziemlich akut war, ist die Verwendung von Rust mit dem Build-Tool und dem Cargo-Abhängigkeits-Manager eine gute Wahl für Ihre neuen Projekte. </p><br><p>  Neben der Tatsache, dass Cargo Abhängigkeiten für Sie herunterlädt und deren Versionen verwaltet, Ihre Anwendungen erstellt und ausführt, Tests ausführt und Dokumentation generiert, kann es auch mit Plugins für andere nützliche Funktionen erweitert werden.  Beispielsweise gibt es Erweiterungen, mit denen Cargo die veralteten Abhängigkeiten Ihres Projekts ermitteln, eine statische Analyse des Quellcodes durchführen, Clientteile von Webanwendungen erstellen und erneut bereitstellen kann und vieles mehr. </p><br><p>  Die Cargo-Konfigurationsdatei verwendet die benutzerfreundliche und minimale Toml-Markup-Sprache, um die Projekteinstellungen zu beschreiben.  Hier ist ein Beispiel für eine typische Konfigurationsdatei von <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p>  Im Folgenden sind drei typische Befehle für die Verwendung von Cargo aufgeführt: </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p>  Mit ihrer Hilfe wird der Quellcode auf Kompilierungsfehler, die Zusammenstellung des Projekts und den Start von Tests sowie die Zusammenstellung und den Start des Programms zur Ausführung überprüft. </p><br><h2 id="3-vstroennye-testy">  3. Eingebaute Tests </h2><br><p>  Das Schreiben von Komponententests in Rust ist so einfach und unkompliziert, dass Sie es immer wieder tun möchten.  :) Oft ist es einfacher, einen Komponententest zu schreiben, als die Funktionalität auf andere Weise zu testen.  Hier ist ein Beispiel für Funktionen und Tests für sie: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Die Funktionen im <code>test</code> , die mit dem Attribut <code>#[test]</code> , sind Komponententests.  Sie werden parallel ausgeführt, wenn der <code>cargo test</code> aufgerufen wird.  Das bedingte Kompilierungsattribut <code>#[cfg(test)]</code> , das das gesamte Modul mit Tests kennzeichnet, führt dazu, dass das Modul nur kompiliert wird, wenn die Tests ausgeführt werden, aber nicht in die normale Assembly gelangt. </p><br><p>  Es ist sehr praktisch, die Tests im selben Modul wie die zu testende Funktion zu platzieren, indem Sie einfach das <code>test</code> Submodul hinzufügen.  Wenn Sie Integrationstests benötigen, platzieren Sie Ihre Tests einfach im Testverzeichnis im Stammverzeichnis des Projekts und verwenden Sie Ihre Anwendung darin als externes Paket.  Ein separates <code>test</code> und Anweisungen zur bedingten Kompilierung müssen in diesem Fall nicht hinzugefügt werden. </p><br><p>  Spezielle Beispiele für Dokumentationen, die als Tests ausgeführt werden, verdienen besondere Aufmerksamkeit, dies wird jedoch nachstehend erörtert. </p><br><p>  Integrierte Leistungstests (Benchmarks) sind ebenfalls verfügbar, jedoch noch nicht stabil. Daher sind sie nur in Compiler-Night-Assemblys verfügbar.  In stabilem Rust müssen Sie für diese Art von Tests externe Bibliotheken verwenden. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4. Gute Dokumentation mit aktuellen Beispielen </h2><br><p>  Die Standard-Rust-Bibliothek ist sehr gut dokumentiert.  Die HTML-Dokumentation wird automatisch aus dem Quellcode mit Markdown-Beschreibungen in den Dock-Kommentaren generiert.  Darüber hinaus enthalten die Dokumentkommentare im Rust-Code Beispielcode, der ausgeführt wird, wenn Tests ausgeführt werden.  Dies stellt die Relevanz der Beispiele sicher: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Die Dokumentation</em></a> </p><br><p>  Hier ist ein Beispiel für die Verwendung der <code>as_bytes</code> Methode vom Typ <code>String</code> </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p>  wird beim Teststart als Test ausgeführt. </p><br><p>  Darüber hinaus ist es für Rust-Bibliotheken üblich, Beispiele für ihre Verwendung in Form kleiner unabhängiger Programme zu erstellen, die sich im <code>examples</code> im Stammverzeichnis des Projekts befinden.  Diese Beispiele sind ebenfalls ein wichtiger Bestandteil der Dokumentation und werden auch während des Testlaufs kompiliert und ausgeführt. Sie können jedoch unabhängig von den Tests ausgeführt werden. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5. Intelligenter automatischer Abzug von Typen </h2><br><p>  In einem Rust-Programm können Sie den Ausdruckstyp nicht explizit angeben, wenn der Compiler ihn basierend auf dem Verwendungskontext automatisch ausgeben kann.  Dies gilt nicht nur für Orte, an denen Variablen deklariert werden.  Schauen wir uns ein Beispiel an: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Wenn wir die Typanmerkungen anordnen, sieht dieses Beispiel folgendermaßen aus: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  Das heißt, wir haben einen Vektor von String-Slices und eine Variable vom Typ String-Slice.  In diesem Fall ist die Angabe von Typen jedoch völlig redundant, da der Compiler sie selbst ausgeben kann (unter Verwendung der erweiterten Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hindley-Milner-</a> Algorithmus).  Die Tatsache, dass <code>vec</code> ein Vektor ist, wird bereits durch den Typ des Rückgabewerts von <code>Vec::new()</code> , aber es ist noch nicht klar, welcher Typ seiner Elemente sein wird.  Die Tatsache, dass der <code>text</code> ein String-Slice ist, ist dadurch verständlich, dass ihm ein Literal dieses Typs zugewiesen ist.  Somit wird nach <code>vec.push(text)</code> die Art der <code>vec.push(text)</code> offensichtlich.  Beachten Sie, dass der Typ der <code>vec</code> Variablen vollständig durch ihre Verwendung im Ausführungsthread und nicht in der Initialisierungsphase bestimmt wurde. </p><br><p>  Ein solches System der Typinferenz eliminiert das Rauschen des Codes und macht ihn so präzise wie den Code in einer dynamisch typisierten Programmiersprache.  Und das unter strikter statischer Typisierung! </p><br><p>  Natürlich können wir das Tippen in einer statisch typisierten Sprache nicht vollständig loswerden.  Das Programm muss Punkte haben, an denen die Objekttypen garantiert bekannt sind, damit diese Typen an anderen Stellen angezeigt werden können.  Solche Punkte in Rust sind Deklarationen von benutzerdefinierten Datentypen und Funktionssignaturen, in denen man nur die verwendeten Typen angeben kann.  Sie können jedoch mithilfe der allgemeinen Programmierung "Metavariablen von Typen" eingeben. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6. Mustervergleich an Variablendeklarationspunkten </h2><br><p>  <code>let</code> Operation </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p>  nicht wirklich darauf beschränkt, nur neue Variablen zu deklarieren.  Was sie tatsächlich tut, ist, den Ausdruck rechts vom Gleichheitszeichen mit dem Muster links abzugleichen.  Und neue Variablen können als Teil der Stichprobe eingeführt werden (und nur so).  Schauen Sie sich das folgende Beispiel an, und es wird Ihnen klarer: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Die Destrukturierung wird hier durchgeführt: Ein solcher Vergleich führt die Variablen <code>x</code> und <code>y</code> , die mit dem Wert der <code>x</code> und <code>y</code> Felder des Objekts der Punktstruktur initialisiert werden, der durch Aufrufen von <code>Point::new()</code> .  Gleichzeitig ist der Vergleich korrekt, da der Typ des Ausdrucks rechts dem Punktmuster vom Typ <code>Point</code> links entspricht.  Auf ähnliche Weise können Sie beispielsweise die ersten beiden Elemente eines Arrays verwenden: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  Und noch viel mehr zu tun.  Das Bemerkenswerteste ist, dass solche Vergleiche an allen Stellen durchgeführt werden, an denen neue Variablennamen in Rust eingegeben werden können, nämlich: in der <code>match</code> <code>let</code> , <code>if let</code> , <code>while let</code> <code>if let</code> , in der Kopfzeile der <code>for</code> Schleife, in den Argumenten von Funktionen und Abschlüssen.  Hier ist ein Beispiel für die elegante Verwendung des Pattern Matching in einer <code>for</code> Schleife: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Die <code>enumerate</code> , die für den Iterator aufgerufen wird, erstellt einen neuen Iterator, der nicht über die Anfangswerte, sondern über Tupel iteriert und "Ordnungsindex, Anfangswert" paart.  Jedes dieser Tupel während der Iteration des Zyklus wird dem angegebenen Muster <code>(i, ch)</code> , wodurch die Variable <code>i</code> den ersten Wert vom Tupel erhält - den Index und die Variable <code>ch</code> - den zweiten, dh das Zeichen der Zeichenfolge.  Weiter im Körper der Schleife können wir diese Variablen verwenden. </p><br><p>  Ein weiteres beliebtes Beispiel für die Verwendung eines Musters in einer <code>for</code> Schleife: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p>  Hier ignorieren wir einfach den Wert des Iterators unter Verwendung des <code>_</code> Musters.  Weil wir die Iterationsnummer im Hauptteil der Schleife nicht verwenden.  Das gleiche kann zum Beispiel mit einem Funktionsargument gemacht werden: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  Oder beim Matching in einer <code>match</code> Anweisung: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Der Mustervergleich macht den Code sehr kompakt und ausdrucksstark und ist in der <code>match</code> im Allgemeinen unersetzlich.  Der <code>match</code> ist ein Operator für die vollständige variable Analyse, sodass Sie nicht versehentlich vergessen können, einige der möglichen Übereinstimmungen für den darin enthaltenen analysierten Ausdruck zu überprüfen. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7. Syntaxerweiterung und benutzerdefiniertes DSL </h2><br><p>  Die Rostsyntax ist begrenzt, hauptsächlich aufgrund der Komplexität des in der Sprache verwendeten Typsystems.  Beispielsweise hat Rust keine benannten Funktionsargumente oder Funktionen mit einer variablen Anzahl von Argumenten.  Mit Makros können Sie diese und andere Einschränkungen umgehen.  Rust hat zwei Arten von Makros: deklarative und prozedurale.  Mit deklarativen Makros haben Sie nie die gleichen Probleme wie mit Makros in C, da sie hygienisch sind und nicht auf der Ebene der Textersetzung, sondern auf der Ebene der Ersetzung im abstrakten Syntaxbaum funktionieren.  Mit Makros können Sie Abstraktionen auf der Ebene der Sprachsyntax erstellen.  Zum Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p>  Zusätzlich zu der Tatsache, dass dieses Makro die syntaktischen Funktionen zum Aufrufen der "Funktion" zum Drucken einer formatierten Zeichenfolge erweitert, wird in seiner Implementierung auch überprüft, ob die Eingabeargumente zur Kompilierungszeit und nicht zur Laufzeit mit der angegebenen Formatzeichenfolge übereinstimmen.  Mithilfe von Makros können Sie eine präzise Syntax für Ihre eigenen Designanforderungen eingeben, DSL erstellen und verwenden.  Hier ist ein Beispiel für die Verwendung von JavaScript-Code in einem Rust-Programm, das in Wasm kompiliert wird: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p>  Makro <code>js!</code>  definiert im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>stdweb</code></a> Paket und ermöglicht es Ihnen, vollwertigen JavaScript-Code in Ihr Programm einzubetten (mit Ausnahme von Zeichenfolgen und Operatoren in einfachen Anführungszeichen und Operatoren, die nicht mit einem Semikolon vervollständigt sind) und Objekte aus dem Rust-Code mit der Syntax <code>@{expr}</code> . </p><br><p>  Makros bieten enorme Möglichkeiten, die Syntax von Rust-Programmen an die spezifischen Aufgaben eines bestimmten Themenbereichs anzupassen.  Sie sparen Zeit und Aufmerksamkeit bei der Entwicklung komplexer Anwendungen.  Nicht durch Erhöhen des Laufzeitaufwands, sondern durch Erhöhen der Kompilierungszeit.  :) :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8. Automatische Generierung von abhängigem Code </h2><br><p>  Rusts prozedurale Ableitungsmakros werden häufig verwendet, um Merkmale und andere Codegenerierungen automatisch zu implementieren.  Hier ist ein Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>  Da alle diese Typen ( <code>Copy</code> , <code>Clone</code> , <code>Debug</code> , <code>Default</code> , <code>PartialEq</code> und <code>Eq</code> ) aus der Standardbibliothek für den <code>i32</code> der <code>i32</code> Struktur implementiert sind, kann ihre Implementierung automatisch für die gesamte Struktur als Ganzes angezeigt werden.  Ein weiteres Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Hier werden unter Verwendung der <code>Deserialize</code> und <code>Deserialize</code> aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>serde</code></a> Bibliothek für die <code>Point</code> Struktur automatisch Methoden für deren Serialisierung und Deserialisierung generiert.  Anschließend können Sie eine Instanz dieser Struktur an verschiedene Serialisierungsfunktionen übergeben, z. B. indem Sie sie in eine JSON-Zeichenfolge konvertieren. </p><br><p>  Sie können Ihre eigenen prozeduralen Makros erstellen, die den benötigten Code generieren.  Oder verwenden Sie die vielen bereits erstellten Makros anderer Entwickler.  Makros ersparen dem Programmierer nicht nur das Schreiben von Boilerplate-Code, sondern haben auch den Vorteil, dass Sie nicht verschiedene Codeabschnitte in einem konsistenten Zustand halten müssen.  Wenn beispielsweise der Punktstruktur ein drittes Feld <code>z</code> hinzugefügt wird, müssen Sie nichts anderes tun, um die Serialisierung korrekt durchzuführen, wenn Sie ableiten verwenden.  Wenn wir selbst die notwendigen Merkmale für die Serialisierung von <code>Point</code> implementieren, müssen wir sicherstellen, dass diese Implementierung immer mit den neuesten Änderungen in der Struktur von <code>Point</code> übereinstimmt. </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9. Algebraischer Datentyp </h2><br><p>  Einfach ausgedrückt ist ein algebraischer Datentyp ein zusammengesetzter Datentyp, der eine Vereinigung von Strukturen darstellt.  Formal ist es eine Typensumme von Produkttypen.  In Rust wird dieser Typ mit dem Schlüsselwort <code>enum</code> definiert: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  Der Typ eines bestimmten Werts einer Variablen vom Typ <code>Message</code> kann nur einer der in <code>Message</code> aufgelisteten Strukturtypen sein.  Dies ist entweder eine einheitliche feldlose <code>Quit</code> Struktur, eine der <code>ChangeColor</code> oder <code>Write</code> <code>ChangeColor</code> mit namenlosen Feldern oder die übliche <code>Move</code> Struktur.  Ein traditioneller Aufzählungstyp kann als Sonderfall eines algebraischen Datentyps dargestellt werden: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p>  Mithilfe des Mustervergleichs können Sie herausfinden, welcher Typ in einem bestimmten Fall tatsächlich einen Wert angenommen hat: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  In Form von algebraischen Datentypen implementiert Rust so wichtige Typen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Option</code></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Result</code></a> , die verwendet werden, um den fehlenden Wert bzw. das korrekte / fehlerhafte Ergebnis darzustellen.  So wird <code>Option</code> in der Standardbibliothek definiert: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Rust hat keinen Nullwert, genau wie die nervigen Fehler eines unerwarteten Aufrufs.  Stattdessen wird <code>Option</code> verwendet, wenn es wirklich notwendig ist, die Möglichkeit eines fehlenden Werts anzugeben: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausführen</em></a> </p><br><p>  Der algebraische Datentyp ist ein leistungsstarkes und ausdrucksstarkes Werkzeug, das die Tür zur typgesteuerten Entwicklung öffnet.  Ein kompetent geschriebenes Programm in diesem Paradigma ordnet die meisten Überprüfungen der Richtigkeit seiner Arbeit dem Typensystem zu.  Wenn Ihnen in der täglichen industriellen Programmierung ein wenig Haskell fehlt, kann Rust Ihr Outlet sein.  :) :) </p><br><h2 id="10-legkiy-refaktoring">  10. Einfaches Refactoring </h2><br><p>  Das in Rust entwickelte strikte statische Typsystem und der Versuch, während der Kompilierung so viele Überprüfungen wie möglich durchzuführen, führen dazu, dass das Ändern und Umgestalten des Codes recht einfach und sicher wird.  Wenn das Programm nach den Änderungen kompiliert wurde, bedeutet dies, dass nur logische Fehler übrig blieben, die nicht mit der Funktionalität zusammenhängen, deren Überprüfung dem Compiler zugewiesen wurde.  In Kombination mit der einfachen Hinzufügung von Komponententests zur Testlogik führt dies zu ernsthaften Garantien für die Zuverlässigkeit von Programmen und zu einer Erhöhung des Vertrauens des Programmierers in den korrekten Betrieb seines Codes nach Änderungen. </p><br><hr><br><p>  Vielleicht ist das alles, worüber ich in diesem Artikel sprechen wollte.  Natürlich hat Rust viele andere Vorteile sowie eine Reihe von Nachteilen (etwas Feuchtigkeit in der Sprache, Mangel an vertrauten Programmiersprachen und „nicht literarische“ Syntax), die hier nicht erwähnt werden.  Wenn Sie etwas darüber zu erzählen haben, schreiben Sie in die Kommentare.  Versuchen Sie Rust im Allgemeinen in der Praxis.  Und vielleicht überwiegen seine Vorteile für Sie alle seine Mängel, wie es in meinem Fall passiert ist.  Und schließlich erhalten Sie genau die Werkzeuge, die Sie lange Zeit benötigt haben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430294/">https://habr.com/ru/post/de430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430282/index.html">9 von 10 Personen stimmen zu, weniger für sinnvollere Arbeit zu verdienen</a></li>
<li><a href="../de430284/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 275 (12. - 18. November)</a></li>
<li><a href="../de430286/index.html">Details zur chaotischen und dunklen Seite von Piratenspielen für Nintendo Switch</a></li>
<li><a href="../de430290/index.html">Ein Versuch, die vierte Iteration des SpaceX BFR-Projekts vorherzusagen</a></li>
<li><a href="../de430292/index.html">Electronic Frontier Foundation: Die Netzwerkleistung des US-Polizeikennzeichens beträgt 0,5%</a></li>
<li><a href="../de430296/index.html">Machen Sie Ihre Ideen App. Serverlose Anwendung - Schritt-für-Schritt-Anleitung</a></li>
<li><a href="../de430300/index.html">Microservices on Go mit dem Go-Kit: Einführung</a></li>
<li><a href="../de430302/index.html">Eine Einführung in ptrace oder Code Injection in sshd zum Spaß</a></li>
<li><a href="../de430304/index.html">Ein wunderbarer Außenposten im Orbit</a></li>
<li><a href="../de430306/index.html">Der erste Tunnel der Boring Company wurde von Ilona Mask gebohrt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>