<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöß üôâ ü§Ωüèø 10 nicht offensichtliche Vorteile der Verwendung von Rust üë®üèø‚Äçüè≠ ü¶è üë®üèΩ‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust ist eine junge und ehrgeizige Systemprogrammiersprache. Es implementiert die automatische Speicherverwaltung ohne Garbage Collector und anderen A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 nicht offensichtliche Vorteile der Verwendung von Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/"><p>  Rust ist eine junge und ehrgeizige Systemprogrammiersprache.  Es implementiert die automatische Speicherverwaltung ohne Garbage Collector und anderen Aufwand f√ºr die Ausf√ºhrung.  Dar√ºber hinaus wird die Standardsprache in der Rust-Sprache verwendet, es gibt beispiellose Regeln f√ºr den Zugriff auf ver√§nderbare Daten und die Lebensdauer der Verbindungen wird ebenfalls ber√ºcksichtigt.  Dies erm√∂glicht ihm die Gew√§hrleistung der Speichersicherheit und erleichtert die Multithread-Programmierung aufgrund des Mangels an Datenrasen. </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p> All dies ist bereits jedem bekannt, der die Entwicklung moderner Programmiertechnologien zumindest ein wenig verfolgt.  Aber was ist, wenn Sie kein Systemprogrammierer sind und nicht viele Multithread-Codes in Ihren Projekten enthalten, Sie aber dennoch von der Leistung von Rust angezogen werden?  Erhalten Sie zus√§tzliche Vorteile aus der Verwendung in Anwendungen?  Oder alles, was er Ihnen zus√§tzlich geben wird, ist ein harter Kampf mit dem Compiler, der Sie dazu zwingt, das Programm so zu schreiben, dass es st√§ndig den Regeln der Sprache f√ºr Ausleihe und Besitz folgt? </p><br><p>  Dieser Artikel hat ein Dutzend nicht offensichtlicher und nicht besonders beworbener Vorteile der Verwendung von Rust gesammelt, die Ihnen hoffentlich bei der Entscheidung √ºber die Wahl dieser Sprache f√ºr Ihre Projekte helfen werden. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1. Die Universalit√§t der Sprache </h2><br><p>  Trotz der Tatsache, dass Rust als Sprache f√ºr die Systemprogrammierung positioniert ist, eignet es sich auch zur L√∂sung von Problemen auf hoher Ebene.  Sie m√ºssen nicht mit Rohzeigern arbeiten, es sei denn, Sie ben√∂tigen sie f√ºr Ihre Aufgabe.  Die Standard-Sprachbibliothek hat bereits die meisten Typen und Funktionen implementiert, die m√∂glicherweise f√ºr die Anwendungsentwicklung erforderlich sind.  Sie k√∂nnen auch problemlos externe Bibliotheken verbinden und verwenden.  Das Typsystem und die verallgemeinerte Programmierung in Rust erm√∂glichen die Verwendung von Abstraktionen auf ziemlich hohem Niveau, obwohl OOP in der Sprache nicht direkt unterst√ºtzt wird. </p><br><p>  Schauen wir uns einige einfache Beispiele f√ºr die Verwendung von Rust an. </p><br><p>  Ein Beispiel f√ºr die Kombination von zwei Iteratoren zu einem Iterator √ºber Elementpaare: </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><blockquote>  Hinweis: Ein Aufruf des Formatnamens <code>name!(...)</code> ist ein Aufruf eines Funktionsmakros.  Die Namen solcher Makros in Rust enden immer mit einem Symbol <code>!</code>  damit sie von Funktionsnamen und anderen Bezeichnern unterschieden werden k√∂nnen.  Die Vorteile der Verwendung von Makros werden unten erl√§utert. </blockquote><p>  Ein Beispiel f√ºr die Verwendung der externen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>regex</code></a> Bibliothek zum Arbeiten mit regul√§ren Ausdr√ºcken: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Ein Beispiel f√ºr die Implementierung des <code>Add</code> f√ºr die eigene <code>Point</code> , um den Additionsoperator zu √ºberladen: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Ein Beispiel f√ºr die Verwendung eines generischen Typs in einer Struktur: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Auf Rust k√∂nnen Sie effiziente Systemdienstprogramme, gro√üe Desktopanwendungen, Microservices, Webanwendungen (einschlie√ülich des Client-Teils, da Rust in Wasm kompiliert werden kann) und mobile Anwendungen schreiben (obwohl das Sprach√∂kosystem in dieser Richtung noch schlecht entwickelt ist).  Diese Vielseitigkeit kann f√ºr Teams mit mehreren Projekten von Vorteil sein, da Sie in vielen verschiedenen Projekten dieselben Ans√§tze und dieselben Module verwenden k√∂nnen.  Wenn Sie daran gew√∂hnt sind, dass jedes Werkzeug f√ºr seinen engen Anwendungsbereich ausgelegt ist, versuchen Sie, Rust als Werkzeugkasten mit der gleichen Zuverl√§ssigkeit und Bequemlichkeit zu betrachten.  Vielleicht haben Sie genau das vermisst. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2. Praktische Tools f√ºr das Build- und Abh√§ngigkeitsmanagement </h2><br><p>  Dies wird eindeutig nicht angek√ºndigt, aber viele bemerken, dass Rust √ºber eines der besten Build- und Abh√§ngigkeitsmanagementsysteme verf√ºgt, die derzeit verf√ºgbar sind.  Wenn Sie in C oder C ++ programmiert haben und die Frage der schmerzlosen Verwendung externer Bibliotheken f√ºr Sie ziemlich akut war, ist die Verwendung von Rust mit dem Build-Tool und dem Cargo-Abh√§ngigkeits-Manager eine gute Wahl f√ºr Ihre neuen Projekte. </p><br><p>  Neben der Tatsache, dass Cargo Abh√§ngigkeiten f√ºr Sie herunterl√§dt und deren Versionen verwaltet, Ihre Anwendungen erstellt und ausf√ºhrt, Tests ausf√ºhrt und Dokumentation generiert, kann es auch mit Plugins f√ºr andere n√ºtzliche Funktionen erweitert werden.  Beispielsweise gibt es Erweiterungen, mit denen Cargo die veralteten Abh√§ngigkeiten Ihres Projekts ermitteln, eine statische Analyse des Quellcodes durchf√ºhren, Clientteile von Webanwendungen erstellen und erneut bereitstellen kann und vieles mehr. </p><br><p>  Die Cargo-Konfigurationsdatei verwendet die benutzerfreundliche und minimale Toml-Markup-Sprache, um die Projekteinstellungen zu beschreiben.  Hier ist ein Beispiel f√ºr eine typische Konfigurationsdatei von <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p>  Im Folgenden sind drei typische Befehle f√ºr die Verwendung von Cargo aufgef√ºhrt: </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p>  Mit ihrer Hilfe wird der Quellcode auf Kompilierungsfehler, die Zusammenstellung des Projekts und den Start von Tests sowie die Zusammenstellung und den Start des Programms zur Ausf√ºhrung √ºberpr√ºft. </p><br><h2 id="3-vstroennye-testy">  3. Eingebaute Tests </h2><br><p>  Das Schreiben von Komponententests in Rust ist so einfach und unkompliziert, dass Sie es immer wieder tun m√∂chten.  :) Oft ist es einfacher, einen Komponententest zu schreiben, als die Funktionalit√§t auf andere Weise zu testen.  Hier ist ein Beispiel f√ºr Funktionen und Tests f√ºr sie: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Die Funktionen im <code>test</code> , die mit dem Attribut <code>#[test]</code> , sind Komponententests.  Sie werden parallel ausgef√ºhrt, wenn der <code>cargo test</code> aufgerufen wird.  Das bedingte Kompilierungsattribut <code>#[cfg(test)]</code> , das das gesamte Modul mit Tests kennzeichnet, f√ºhrt dazu, dass das Modul nur kompiliert wird, wenn die Tests ausgef√ºhrt werden, aber nicht in die normale Assembly gelangt. </p><br><p>  Es ist sehr praktisch, die Tests im selben Modul wie die zu testende Funktion zu platzieren, indem Sie einfach das <code>test</code> Submodul hinzuf√ºgen.  Wenn Sie Integrationstests ben√∂tigen, platzieren Sie Ihre Tests einfach im Testverzeichnis im Stammverzeichnis des Projekts und verwenden Sie Ihre Anwendung darin als externes Paket.  Ein separates <code>test</code> und Anweisungen zur bedingten Kompilierung m√ºssen in diesem Fall nicht hinzugef√ºgt werden. </p><br><p>  Spezielle Beispiele f√ºr Dokumentationen, die als Tests ausgef√ºhrt werden, verdienen besondere Aufmerksamkeit, dies wird jedoch nachstehend er√∂rtert. </p><br><p>  Integrierte Leistungstests (Benchmarks) sind ebenfalls verf√ºgbar, jedoch noch nicht stabil. Daher sind sie nur in Compiler-Night-Assemblys verf√ºgbar.  In stabilem Rust m√ºssen Sie f√ºr diese Art von Tests externe Bibliotheken verwenden. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4. Gute Dokumentation mit aktuellen Beispielen </h2><br><p>  Die Standard-Rust-Bibliothek ist sehr gut dokumentiert.  Die HTML-Dokumentation wird automatisch aus dem Quellcode mit Markdown-Beschreibungen in den Dock-Kommentaren generiert.  Dar√ºber hinaus enthalten die Dokumentkommentare im Rust-Code Beispielcode, der ausgef√ºhrt wird, wenn Tests ausgef√ºhrt werden.  Dies stellt die Relevanz der Beispiele sicher: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Die Dokumentation</em></a> </p><br><p>  Hier ist ein Beispiel f√ºr die Verwendung der <code>as_bytes</code> Methode vom Typ <code>String</code> </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p>  wird beim Teststart als Test ausgef√ºhrt. </p><br><p>  Dar√ºber hinaus ist es f√ºr Rust-Bibliotheken √ºblich, Beispiele f√ºr ihre Verwendung in Form kleiner unabh√§ngiger Programme zu erstellen, die sich im <code>examples</code> im Stammverzeichnis des Projekts befinden.  Diese Beispiele sind ebenfalls ein wichtiger Bestandteil der Dokumentation und werden auch w√§hrend des Testlaufs kompiliert und ausgef√ºhrt. Sie k√∂nnen jedoch unabh√§ngig von den Tests ausgef√ºhrt werden. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5. Intelligenter automatischer Abzug von Typen </h2><br><p>  In einem Rust-Programm k√∂nnen Sie den Ausdruckstyp nicht explizit angeben, wenn der Compiler ihn basierend auf dem Verwendungskontext automatisch ausgeben kann.  Dies gilt nicht nur f√ºr Orte, an denen Variablen deklariert werden.  Schauen wir uns ein Beispiel an: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Wenn wir die Typanmerkungen anordnen, sieht dieses Beispiel folgenderma√üen aus: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  Das hei√üt, wir haben einen Vektor von String-Slices und eine Variable vom Typ String-Slice.  In diesem Fall ist die Angabe von Typen jedoch v√∂llig redundant, da der Compiler sie selbst ausgeben kann (unter Verwendung der erweiterten Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hindley-Milner-</a> Algorithmus).  Die Tatsache, dass <code>vec</code> ein Vektor ist, wird bereits durch den Typ des R√ºckgabewerts von <code>Vec::new()</code> , aber es ist noch nicht klar, welcher Typ seiner Elemente sein wird.  Die Tatsache, dass der <code>text</code> ein String-Slice ist, ist dadurch verst√§ndlich, dass ihm ein Literal dieses Typs zugewiesen ist.  Somit wird nach <code>vec.push(text)</code> die Art der <code>vec.push(text)</code> offensichtlich.  Beachten Sie, dass der Typ der <code>vec</code> Variablen vollst√§ndig durch ihre Verwendung im Ausf√ºhrungsthread und nicht in der Initialisierungsphase bestimmt wurde. </p><br><p>  Ein solches System der Typinferenz eliminiert das Rauschen des Codes und macht ihn so pr√§zise wie den Code in einer dynamisch typisierten Programmiersprache.  Und das unter strikter statischer Typisierung! </p><br><p>  Nat√ºrlich k√∂nnen wir das Tippen in einer statisch typisierten Sprache nicht vollst√§ndig loswerden.  Das Programm muss Punkte haben, an denen die Objekttypen garantiert bekannt sind, damit diese Typen an anderen Stellen angezeigt werden k√∂nnen.  Solche Punkte in Rust sind Deklarationen von benutzerdefinierten Datentypen und Funktionssignaturen, in denen man nur die verwendeten Typen angeben kann.  Sie k√∂nnen jedoch mithilfe der allgemeinen Programmierung "Metavariablen von Typen" eingeben. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6. Mustervergleich an Variablendeklarationspunkten </h2><br><p>  <code>let</code> Operation </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p>  nicht wirklich darauf beschr√§nkt, nur neue Variablen zu deklarieren.  Was sie tats√§chlich tut, ist, den Ausdruck rechts vom Gleichheitszeichen mit dem Muster links abzugleichen.  Und neue Variablen k√∂nnen als Teil der Stichprobe eingef√ºhrt werden (und nur so).  Schauen Sie sich das folgende Beispiel an, und es wird Ihnen klarer: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Die Destrukturierung wird hier durchgef√ºhrt: Ein solcher Vergleich f√ºhrt die Variablen <code>x</code> und <code>y</code> , die mit dem Wert der <code>x</code> und <code>y</code> Felder des Objekts der Punktstruktur initialisiert werden, der durch Aufrufen von <code>Point::new()</code> .  Gleichzeitig ist der Vergleich korrekt, da der Typ des Ausdrucks rechts dem Punktmuster vom Typ <code>Point</code> links entspricht.  Auf √§hnliche Weise k√∂nnen Sie beispielsweise die ersten beiden Elemente eines Arrays verwenden: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  Und noch viel mehr zu tun.  Das Bemerkenswerteste ist, dass solche Vergleiche an allen Stellen durchgef√ºhrt werden, an denen neue Variablennamen in Rust eingegeben werden k√∂nnen, n√§mlich: in der <code>match</code> <code>let</code> , <code>if let</code> , <code>while let</code> <code>if let</code> , in der Kopfzeile der <code>for</code> Schleife, in den Argumenten von Funktionen und Abschl√ºssen.  Hier ist ein Beispiel f√ºr die elegante Verwendung des Pattern Matching in einer <code>for</code> Schleife: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Die <code>enumerate</code> , die f√ºr den Iterator aufgerufen wird, erstellt einen neuen Iterator, der nicht √ºber die Anfangswerte, sondern √ºber Tupel iteriert und "Ordnungsindex, Anfangswert" paart.  Jedes dieser Tupel w√§hrend der Iteration des Zyklus wird dem angegebenen Muster <code>(i, ch)</code> , wodurch die Variable <code>i</code> den ersten Wert vom Tupel erh√§lt - den Index und die Variable <code>ch</code> - den zweiten, dh das Zeichen der Zeichenfolge.  Weiter im K√∂rper der Schleife k√∂nnen wir diese Variablen verwenden. </p><br><p>  Ein weiteres beliebtes Beispiel f√ºr die Verwendung eines Musters in einer <code>for</code> Schleife: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p>  Hier ignorieren wir einfach den Wert des Iterators unter Verwendung des <code>_</code> Musters.  Weil wir die Iterationsnummer im Hauptteil der Schleife nicht verwenden.  Das gleiche kann zum Beispiel mit einem Funktionsargument gemacht werden: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  Oder beim Matching in einer <code>match</code> Anweisung: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Der Mustervergleich macht den Code sehr kompakt und ausdrucksstark und ist in der <code>match</code> im Allgemeinen unersetzlich.  Der <code>match</code> ist ein Operator f√ºr die vollst√§ndige variable Analyse, sodass Sie nicht versehentlich vergessen k√∂nnen, einige der m√∂glichen √úbereinstimmungen f√ºr den darin enthaltenen analysierten Ausdruck zu √ºberpr√ºfen. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7. Syntaxerweiterung und benutzerdefiniertes DSL </h2><br><p>  Die Rostsyntax ist begrenzt, haupts√§chlich aufgrund der Komplexit√§t des in der Sprache verwendeten Typsystems.  Beispielsweise hat Rust keine benannten Funktionsargumente oder Funktionen mit einer variablen Anzahl von Argumenten.  Mit Makros k√∂nnen Sie diese und andere Einschr√§nkungen umgehen.  Rust hat zwei Arten von Makros: deklarative und prozedurale.  Mit deklarativen Makros haben Sie nie die gleichen Probleme wie mit Makros in C, da sie hygienisch sind und nicht auf der Ebene der Textersetzung, sondern auf der Ebene der Ersetzung im abstrakten Syntaxbaum funktionieren.  Mit Makros k√∂nnen Sie Abstraktionen auf der Ebene der Sprachsyntax erstellen.  Zum Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p>  Zus√§tzlich zu der Tatsache, dass dieses Makro die syntaktischen Funktionen zum Aufrufen der "Funktion" zum Drucken einer formatierten Zeichenfolge erweitert, wird in seiner Implementierung auch √ºberpr√ºft, ob die Eingabeargumente zur Kompilierungszeit und nicht zur Laufzeit mit der angegebenen Formatzeichenfolge √ºbereinstimmen.  Mithilfe von Makros k√∂nnen Sie eine pr√§zise Syntax f√ºr Ihre eigenen Designanforderungen eingeben, DSL erstellen und verwenden.  Hier ist ein Beispiel f√ºr die Verwendung von JavaScript-Code in einem Rust-Programm, das in Wasm kompiliert wird: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p>  Makro <code>js!</code>  definiert im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>stdweb</code></a> Paket und erm√∂glicht es Ihnen, vollwertigen JavaScript-Code in Ihr Programm einzubetten (mit Ausnahme von Zeichenfolgen und Operatoren in einfachen Anf√ºhrungszeichen und Operatoren, die nicht mit einem Semikolon vervollst√§ndigt sind) und Objekte aus dem Rust-Code mit der Syntax <code>@{expr}</code> . </p><br><p>  Makros bieten enorme M√∂glichkeiten, die Syntax von Rust-Programmen an die spezifischen Aufgaben eines bestimmten Themenbereichs anzupassen.  Sie sparen Zeit und Aufmerksamkeit bei der Entwicklung komplexer Anwendungen.  Nicht durch Erh√∂hen des Laufzeitaufwands, sondern durch Erh√∂hen der Kompilierungszeit.  :) :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8. Automatische Generierung von abh√§ngigem Code </h2><br><p>  Rusts prozedurale Ableitungsmakros werden h√§ufig verwendet, um Merkmale und andere Codegenerierungen automatisch zu implementieren.  Hier ist ein Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>  Da alle diese Typen ( <code>Copy</code> , <code>Clone</code> , <code>Debug</code> , <code>Default</code> , <code>PartialEq</code> und <code>Eq</code> ) aus der Standardbibliothek f√ºr den <code>i32</code> der <code>i32</code> Struktur implementiert sind, kann ihre Implementierung automatisch f√ºr die gesamte Struktur als Ganzes angezeigt werden.  Ein weiteres Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Hier werden unter Verwendung der <code>Deserialize</code> und <code>Deserialize</code> aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>serde</code></a> Bibliothek f√ºr die <code>Point</code> Struktur automatisch Methoden f√ºr deren Serialisierung und Deserialisierung generiert.  Anschlie√üend k√∂nnen Sie eine Instanz dieser Struktur an verschiedene Serialisierungsfunktionen √ºbergeben, z. B. indem Sie sie in eine JSON-Zeichenfolge konvertieren. </p><br><p>  Sie k√∂nnen Ihre eigenen prozeduralen Makros erstellen, die den ben√∂tigten Code generieren.  Oder verwenden Sie die vielen bereits erstellten Makros anderer Entwickler.  Makros ersparen dem Programmierer nicht nur das Schreiben von Boilerplate-Code, sondern haben auch den Vorteil, dass Sie nicht verschiedene Codeabschnitte in einem konsistenten Zustand halten m√ºssen.  Wenn beispielsweise der Punktstruktur ein drittes Feld <code>z</code> hinzugef√ºgt wird, m√ºssen Sie nichts anderes tun, um die Serialisierung korrekt durchzuf√ºhren, wenn Sie ableiten verwenden.  Wenn wir selbst die notwendigen Merkmale f√ºr die Serialisierung von <code>Point</code> implementieren, m√ºssen wir sicherstellen, dass diese Implementierung immer mit den neuesten √Ñnderungen in der Struktur von <code>Point</code> √ºbereinstimmt. </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9. Algebraischer Datentyp </h2><br><p>  Einfach ausgedr√ºckt ist ein algebraischer Datentyp ein zusammengesetzter Datentyp, der eine Vereinigung von Strukturen darstellt.  Formal ist es eine Typensumme von Produkttypen.  In Rust wird dieser Typ mit dem Schl√ºsselwort <code>enum</code> definiert: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  Der Typ eines bestimmten Werts einer Variablen vom Typ <code>Message</code> kann nur einer der in <code>Message</code> aufgelisteten Strukturtypen sein.  Dies ist entweder eine einheitliche feldlose <code>Quit</code> Struktur, eine der <code>ChangeColor</code> oder <code>Write</code> <code>ChangeColor</code> mit namenlosen Feldern oder die √ºbliche <code>Move</code> Struktur.  Ein traditioneller Aufz√§hlungstyp kann als Sonderfall eines algebraischen Datentyps dargestellt werden: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p>  Mithilfe des Mustervergleichs k√∂nnen Sie herausfinden, welcher Typ in einem bestimmten Fall tats√§chlich einen Wert angenommen hat: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  In Form von algebraischen Datentypen implementiert Rust so wichtige Typen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Option</code></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Result</code></a> , die verwendet werden, um den fehlenden Wert bzw. das korrekte / fehlerhafte Ergebnis darzustellen.  So wird <code>Option</code> in der Standardbibliothek definiert: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Rust hat keinen Nullwert, genau wie die nervigen Fehler eines unerwarteten Aufrufs.  Stattdessen wird <code>Option</code> verwendet, wenn es wirklich notwendig ist, die M√∂glichkeit eines fehlenden Werts anzugeben: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Ausf√ºhren</em></a> </p><br><p>  Der algebraische Datentyp ist ein leistungsstarkes und ausdrucksstarkes Werkzeug, das die T√ºr zur typgesteuerten Entwicklung √∂ffnet.  Ein kompetent geschriebenes Programm in diesem Paradigma ordnet die meisten √úberpr√ºfungen der Richtigkeit seiner Arbeit dem Typensystem zu.  Wenn Ihnen in der t√§glichen industriellen Programmierung ein wenig Haskell fehlt, kann Rust Ihr Outlet sein.  :) :) </p><br><h2 id="10-legkiy-refaktoring">  10. Einfaches Refactoring </h2><br><p>  Das in Rust entwickelte strikte statische Typsystem und der Versuch, w√§hrend der Kompilierung so viele √úberpr√ºfungen wie m√∂glich durchzuf√ºhren, f√ºhren dazu, dass das √Ñndern und Umgestalten des Codes recht einfach und sicher wird.  Wenn das Programm nach den √Ñnderungen kompiliert wurde, bedeutet dies, dass nur logische Fehler √ºbrig blieben, die nicht mit der Funktionalit√§t zusammenh√§ngen, deren √úberpr√ºfung dem Compiler zugewiesen wurde.  In Kombination mit der einfachen Hinzuf√ºgung von Komponententests zur Testlogik f√ºhrt dies zu ernsthaften Garantien f√ºr die Zuverl√§ssigkeit von Programmen und zu einer Erh√∂hung des Vertrauens des Programmierers in den korrekten Betrieb seines Codes nach √Ñnderungen. </p><br><hr><br><p>  Vielleicht ist das alles, wor√ºber ich in diesem Artikel sprechen wollte.  Nat√ºrlich hat Rust viele andere Vorteile sowie eine Reihe von Nachteilen (etwas Feuchtigkeit in der Sprache, Mangel an vertrauten Programmiersprachen und ‚Äûnicht literarische‚Äú Syntax), die hier nicht erw√§hnt werden.  Wenn Sie etwas dar√ºber zu erz√§hlen haben, schreiben Sie in die Kommentare.  Versuchen Sie Rust im Allgemeinen in der Praxis.  Und vielleicht √ºberwiegen seine Vorteile f√ºr Sie alle seine M√§ngel, wie es in meinem Fall passiert ist.  Und schlie√ülich erhalten Sie genau die Werkzeuge, die Sie lange Zeit ben√∂tigt haben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430294/">https://habr.com/ru/post/de430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430282/index.html">9 von 10 Personen stimmen zu, weniger f√ºr sinnvollere Arbeit zu verdienen</a></li>
<li><a href="../de430284/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 275 (12. - 18. November)</a></li>
<li><a href="../de430286/index.html">Details zur chaotischen und dunklen Seite von Piratenspielen f√ºr Nintendo Switch</a></li>
<li><a href="../de430290/index.html">Ein Versuch, die vierte Iteration des SpaceX BFR-Projekts vorherzusagen</a></li>
<li><a href="../de430292/index.html">Electronic Frontier Foundation: Die Netzwerkleistung des US-Polizeikennzeichens betr√§gt 0,5%</a></li>
<li><a href="../de430296/index.html">Machen Sie Ihre Ideen App. Serverlose Anwendung - Schritt-f√ºr-Schritt-Anleitung</a></li>
<li><a href="../de430300/index.html">Microservices on Go mit dem Go-Kit: Einf√ºhrung</a></li>
<li><a href="../de430302/index.html">Eine Einf√ºhrung in ptrace oder Code Injection in sshd zum Spa√ü</a></li>
<li><a href="../de430304/index.html">Ein wunderbarer Au√üenposten im Orbit</a></li>
<li><a href="../de430306/index.html">Der erste Tunnel der Boring Company wurde von Ilona Mask gebohrt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>