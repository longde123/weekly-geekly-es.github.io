<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÄ üî© üèóÔ∏è Kotlin: est√°tica que n√£o existe üì≤ ü§± üßìüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo ir√° falar sobre o uso de est√°tica no Kotlin. 
 Vamos come√ßar. 
 Kotlin n√£o tem est√°tica! 

 Isto √© afirmado na documenta√ß√£o oficial. 

 E ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: est√°tica que n√£o existe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/430836/"><img src="https://habrastorage.org/webt/a4/lt/ih/a4ltihdnjfobccfvjc3sx3j3bm0.png"><br>  Este artigo ir√° falar sobre o uso de est√°tica no Kotlin. <br>  Vamos come√ßar. <br>  Kotlin n√£o tem est√°tica! <br><br>  Isto √© afirmado na documenta√ß√£o oficial. <br><br>  E parece que isso poderia terminar o artigo.  Mas deixe-me, como assim?  Afinal, se no Android Studio voc√™ inserir c√≥digo Java em um arquivo Kotlin, o conversor inteligente far√° a m√°gica, transformar√° tudo em c√≥digo no idioma certo e funcionar√°!  Mas e a compatibilidade total com Java? <br><br>  Nesse momento, qualquer desenvolvedor, aprendendo sobre a falta de est√°tica no Kotlin, entrar√° na documenta√ß√£o e nos f√≥runs para lidar com esse problema.  Vamos nos reunir, pensativa e meticulosamente.  Tentarei manter o m√≠nimo de perguntas poss√≠vel at√© o final deste artigo. <a name="habracut"></a><br><br>  Qual √© a est√°tica em Java?  Existem: <br><ul><li>  campos est√°ticos de classe </li><li>  m√©todos de classe est√°tica </li><li>  classes aninhadas est√°ticas </li></ul><br><br>  Vamos fazer um experimento (esta √© a primeira coisa que vem √† mente). <br><br>  Crie uma classe Java simples: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassJava1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String value)</span></span></span></span>{ staticField = value; } }</code> </pre> <br>  Tudo √© f√°cil aqui: na classe, criamos um campo est√°tico e um m√©todo est√°tico.  Fazemos tudo publicamente para experimentos com acesso externo.  Conectamos o campo e o m√©todo logicamente. <br><br>  Agora crie uma classe Kotlin vazia e tente copiar todo o conte√∫do da classe SimpleClassJava1 para ela.  Respondemos "sim" √† pergunta resultante sobre convers√£o e vemos o que aconteceu: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: String)</span></span></span><span class="hljs-function"> </span></span>{ staticField = value } }</code> </pre><br>  Parece que isso n√£o √© exatamente o que precisamos ... Para garantir isso, converteremos o bytecode dessa classe em c√≥digo Java e veremos o que aconteceu: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(value, <span class="hljs-string"><span class="hljs-string">"value"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = value; } }</code> </pre><br>  Sim  Tudo est√° exatamente como parecia.  N√£o tem cheiro de est√°tica aqui.  O conversor simplesmente cortou o modificador est√°tico na assinatura, como se n√£o estivesse l√°.  Por via das d√∫vidas, chegaremos imediatamente a uma conclus√£o: n√£o confie cegamente no conversor, √†s vezes ele pode trazer surpresas desagrad√°veis. <br><br>  A prop√≥sito, cerca de seis meses atr√°s, a convers√£o do mesmo c√≥digo Java para Kotlin teria mostrado um resultado ligeiramente diferente.  Mais uma vez: tenha cuidado com a convers√£o autom√°tica! <br><br>  N√≥s experimentamos mais. <br><br>  Vamos a qualquer classe no Kotlin e tentamos chamar os elementos est√°ticos da classe Java: <br><pre> <code class="java hljs">SimpleClassJava1.setStaticValue(<span class="hljs-string"><span class="hljs-string">"hi!"</span></span>) SimpleClassJava1.staticField = <span class="hljs-string"><span class="hljs-string">"hello!!!"</span></span></code> </pre><br>  Aqui est√° como!  Tudo √© perfeitamente chamado, at√© o preenchimento autom√°tico do c√≥digo nos diz tudo!  Muito curioso. <br><br>  Agora vamos para a parte mais substancial.  De fato, os criadores de Kotlin decidiram se afastar da est√°tica na forma em que estamos acostumados a us√°-la.  Por que fizemos exatamente isso e n√£o discutiremos o contr√°rio - h√° muitas disputas e opini√µes sobre esse assunto na rede.  Vamos descobrir como viver com isso.  Naturalmente, n√£o fomos privados apenas de est√°tica.  Kotlin nos fornece um conjunto de ferramentas com as quais podemos compensar os perdidos.  Eles s√£o adequados para uso interno.  E a prometida compatibilidade total com o c√≥digo Java.  Vamos l√°! <br><br>  A coisa mais r√°pida e f√°cil que voc√™ pode perceber e come√ßar a usar √© a alternativa que nos √© oferecida, em vez de m√©todos est√°ticos - fun√ß√µes no n√≠vel do pacote.  O que √© isso  Esta √© uma fun√ß√£o que n√£o pertence a nenhuma classe.  Ou seja, esse tipo de l√≥gica que est√° no v√°cuo em algum lugar do espa√ßo do pacote.  Podemos descrev√™-lo em qualquer arquivo dentro do pacote que nos interessar.  Por exemplo, nomeie esse arquivo JustFun.kt e coloque-o no pacote <code>com.example.mytestapplication</code> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.<span class="hljs-function"><span class="hljs-function">mytestapplication fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br><br>  Converta o bytecode deste arquivo em Java e olhe dentro: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JustFunKt</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } }</span></span></code> </pre><br>  Vemos que em Java √© criada uma classe cujo nome leva em considera√ß√£o o nome do arquivo no qual a fun√ß√£o √© descrita e a pr√≥pria fun√ß√£o se transforma em um m√©todo est√°tico. <br><br>  Agora, se quisermos chamar a fun√ß√£o <code>testFun</code> no Kotlin a partir de uma classe (ou a mesma fun√ß√£o) localizada no <code>package com.example.mytestapplication</code> (ou seja, o mesmo pacote da fun√ß√£o), podemos simplesmente acess√°-la sem truques adicionais.  Se o chamarmos de outro pacote, devemos importar, o que √© familiar para n√≥s e geralmente aplic√°vel √†s classes: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.pavka.mytestapplication.testFun</code> </pre> <br>  Se falamos em chamar a fun√ß√£o <code>estFun</code> partir do c√≥digo Java, sempre precisamos importar a fun√ß√£o, independentemente de qual pacote a chamamos: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> com.example.pavka.mytestapplication.ForFunKt.testFun;</code> </pre> <br>  A documenta√ß√£o diz que, na maioria dos casos, em vez de m√©todos est√°ticos, basta usarmos as fun√ß√µes no n√≠vel do pacote.  No entanto, na minha opini√£o pessoal (que n√£o precisa coincidir com a opini√£o de todos os outros), esse m√©todo de implementa√ß√£o da est√°tica √© adequado apenas para pequenos projetos. <br>  Acontece que essas fun√ß√µes n√£o pertencem explicitamente a nenhuma classe.  Visualmente, a chamada deles parece uma chamada para o m√©todo de classe (ou seu pai) no qual estamos localizados, o que √†s vezes pode ser confuso.  Bem, e o principal - s√≥ pode haver uma fun√ß√£o com esse nome no pacote.  Mesmo se tentarmos criar a fun√ß√£o com o mesmo nome em outro arquivo, o sistema nos dar√° um erro.  Se falamos de grandes projetos, muitas vezes temos, por exemplo, diferentes f√°bricas com m√©todos est√°ticos com o mesmo nome. <br><br>  Vejamos outras alternativas para implementar m√©todos e campos est√°ticos. <br><br>  Lembre-se de qual √© o campo est√°tico de uma classe.  Este √© um campo de classe que pertence √† classe na qual √© declarado, mas n√£o pertence a uma inst√¢ncia espec√≠fica da classe, ou seja, √© criado em uma √∫nica inst√¢ncia para toda a classe. <br><br>  A Kotlin nos oferece para esses fins usar alguma entidade adicional, que tamb√©m existe em uma √∫nica c√≥pia.  Em outras palavras, singleton. <br><br>  Kotlin tem uma palavra-chave de objeto para declarar singletones. <br><br><pre> <code class="java hljs">object MySingltoneClass { <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre> <br><br>  Tais objetos s√£o inicializados pregui√ßosamente, ou seja, no momento da primeira chamada para eles. <br><br>  Ok, existem singletones em Java tamb√©m, onde est√£o as estat√≠sticas? <br><br>  Para qualquer classe no Kotlin, podemos criar um objeto complementar ou complementar.  Um singleton vinculado a uma classe espec√≠fica.  Isso pode ser feito usando duas palavras-chave <code>companion  object</code> juntas: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } } }</span></span></code> </pre><br><br>  Aqui temos a classe <code>SimpleClassKotlin1</code> , na qual declaramos um singleton com a palavra-chave object e o vinculamos ao objeto dentro do qual √© declarado com a palavra-chave complementar.  Aqui voc√™ pode prestar aten√ß√£o ao fato de que, diferentemente da declara√ß√£o singleton anterior (MySingltoneClass), o nome da classe singleton n√£o √© indicado.  Se o objeto for declarado complementar, √© permitido n√£o indicar seu nome.  Em seguida, ele ser√° automaticamente nomeado <code>Companion</code> .  Se necess√°rio, podemos obter uma inst√¢ncia da classe complementar desta maneira: <br><pre> <code class="java hljs">val companionInstance = SimpleClassKotlin1.Companion</code> </pre> <br>  No entanto, uma chamada para as propriedades e m√©todos de uma classe complementar pode ser feita diretamente, atrav√©s de uma chamada para a classe √† qual est√° anexada: <br><pre> <code class="java hljs">SimpleClassKotlin1.companionField SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>)</code> </pre><br>  J√° parece muito com a chamada de campos e classes est√°ticos, certo? <br><br>  Se necess√°rio, podemos dar um nome √† classe associada, mas na pr√°tica isso raramente √© feito.  Entre os recursos interessantes das classes acompanhantes, pode-se notar que, como qualquer classe comum, ele pode implementar interfaces, o que √†s vezes pode nos ajudar a adicionar um pouco mais de ordem ao c√≥digo: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactoryInterface</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: T } class SimpleClassKotlin1 </span></span>{ companion object : FactoryInterface&lt;MyClass&gt; { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: MyClass </span></span>= MyClass() } }</code> </pre> <br><br>  Uma classe complementar pode ter apenas uma classe.  No entanto, ningu√©m nos pro√≠be de declarar qualquer n√∫mero de objetos singleton dentro da classe, mas, neste caso, devemos especificar explicitamente o nome dessa classe e, portanto, indicar esse nome quando nos referirmos aos campos e m√©todos dessa classe. <br><br>  Falando de classes declaradas como objeto, podemos dizer que tamb√©m podemos declarar objetos aninhados nelas, mas n√£o podemos declarar objetos complementares nelas. <br><br>  √â hora de olhar "por baixo do cap√¥".  Fa√ßa nossa aula simples: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } } object OneMoreObject { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ } }</code> </pre><br><br>  Agora descompile seu bytecode em Java: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OneMoreObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.OneMoreObject INSTANCE; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ value = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { SimpleClassKotlin1.OneMoreObject var0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.OneMoreObject(); INSTANCE = var0; value = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SimpleClassKotlin1.companionField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); SimpleClassKotlin1.companionField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String vaue)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(vaue, <span class="hljs-string"><span class="hljs-string">"vaue"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } }</span></span></code> </pre><br>  N√≥s olhamos o que aconteceu. <br><br>  A propriedade do objeto complementar √© representada como um campo est√°tico da nossa classe: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>;</code> </pre> <br><br>  Isso parece ser exatamente o que quer√≠amos.  No entanto, esse campo √© privado e acessado por meio de getter e setter de nossa classe complementar, que √© apresentada aqui como uma <code>public static final class</code> e sua inst√¢ncia √© apresentada como uma constante: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre><br><br>  A fun√ß√£o companionFun n√£o se tornou o m√©todo est√°tico da nossa classe (provavelmente n√£o deveria).  Permaneceu a fun√ß√£o de um singleton inicializado na classe SimpleClassKotlin1.  No entanto, se voc√™ pensar sobre isso, logicamente isso √© a mesma coisa. <br><br>  Com a classe <code>OneMoreObject</code> situa√ß√£o √© muito semelhante.  √â importante observar apenas que aqui, diferentemente do companheiro, o campo da classe value n√£o foi movido para a classe <code>SimpleClassKotlin1</code> , mas permaneceu no <code>OneMoreObject</code> , mas tamb√©m se tornou est√°tico e recebeu o getter e o setter gerados. <br><br>  Vamos tentar compreender todas as op√ß√µes acima. <br>  Se queremos implementar campos est√°ticos ou m√©todos de classe no Kotlin, para isso devemos usar o objeto complementar declarado dentro desta classe. <br>  Chamar esses campos e fun√ß√µes do Kotlin ser√° exatamente o mesmo que chamar est√°tica em Java.  Mas e se tentarmos chamar esses campos e fun√ß√µes em Java? <br><br>  O preenchimento autom√°tico informa que as seguintes chamadas est√£o dispon√≠veis: <br><pre> <code class="java hljs">SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.setCompanionField(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.getCompanionField();</code> </pre><br>  Ou seja, aqui n√£o vamos indicar o nome do companheiro diretamente.  Assim, o nome que foi designado ao objeto complementar padr√£o √© usado aqui.  N√£o √© muito conveniente, certo? <br><br>  No entanto, os criadores do Kotlin tornaram poss√≠vel torn√°-lo mais familiar em Java.  E h√° v√°rias maneiras de fazer isso. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span></code> </pre> <br>  Se aplicarmos esta anota√ß√£o ao campo <code>companionField</code> do nosso objeto <code>companionField</code> , ao converter o bytecode em Java, veremos que o campo est√°tico <code>companionField</code> SimpleClassKotlin1 n√£o √© mais privado, mas p√∫blico, e o getter e setter para companionField desaparecer√£o na classe est√°tica <code>Companion</code> .  Agora podemos acessar o <code>companionField</code> partir do c√≥digo Java da maneira usual. <br><br>  A segunda maneira √© especificar um modificador <code>lateinit</code> para propriedades do <code>lateinit</code> complementar, propriedades com inicializa√ß√£o tardia.  N√£o esque√ßa que isso se aplica apenas √†s propriedades var, e seu tipo deve ser n√£o nulo e n√£o deve ser primitivo.  Bem, n√£o se esque√ßa das regras para lidar com essas propriedades. <br><br><pre> <code class="java hljs">lateinit <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lateinitField: String</code> </pre> <br>  E mais uma maneira: podemos declarar a propriedade do objeto complementar uma constante, especificando o modificador const.  √â f√°cil adivinhar que isso deve ser uma propriedade val. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val myConstant = <span class="hljs-string"><span class="hljs-string">"CONSTANT"</span></span></code> </pre> <br>  Em cada um desses casos, o c√≥digo Java gerado conter√° o campo est√°tico p√∫blico habitual; no caso de const, esse campo tamb√©m ser√° final.  Obviamente, vale a pena entender que cada um desses 3 casos tem seu pr√≥prio objetivo l√≥gico, e apenas o primeiro deles foi projetado especificamente para facilitar o uso com Java, o restante recebe esse "coque" como se estivesse em uma carga. <br><br>  Deve-se observar separadamente que o modificador const pode ser usado para propriedades de objetos, objetos complementares e propriedades do n√≠vel do pacote.  No √∫ltimo caso, obtemos o mesmo que usar as fun√ß√µes no n√≠vel do pacote e com as mesmas restri√ß√µes.  O c√≥digo Java √© gerado com um campo p√∫blico est√°tico na classe, cujo nome leva em considera√ß√£o o nome do arquivo no qual descrevemos a constante.  Um pacote pode ter apenas uma constante com o nome especificado. <br><br>  Se queremos que a fun√ß√£o do objeto complementar tamb√©m seja convertida em um m√©todo est√°tico ao gerar c√≥digo Java, para isso, precisamos aplicar a anota√ß√£o <code>@JvmStatic</code> a essa fun√ß√£o. <br>  Tamb√©m √© permitido aplicar a anota√ß√£o <code>@JvmStatic</code> √†s propriedades dos objetos complementares (e apenas objetos singleton).  Nesse caso, a propriedade n√£o se transformar√° em um campo est√°tico, mas um getter e setter est√°ticos para essa propriedade ser√£o gerados.  Para uma melhor compreens√£o, veja esta classe Kotlin: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre><br><br>  Nesse caso, as seguintes chamadas s√£o v√°lidas do Java: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); x = SimpleClassKotlin1.getStaticField(); SimpleClassKotlin1.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>); SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); x = SimpleClassKotlin1.Companion.getStaticField(); SimpleClassKotlin1.Companion.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br><br>  As seguintes chamadas s√£o v√°lidas do Kotlin: <br><pre> <code class="java hljs">SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.staticField SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.Companion.staticField</code> </pre> <br><br>  √â claro que para Java voc√™ deve usar os 3 primeiros e para o Kotlin os 2. primeiros. O restante das chamadas √© v√°lido. <br><br>  Agora resta esclarecer o √∫ltimo.  E as classes aninhadas est√°ticas?  Tudo √© simples aqui - o an√°logo dessa classe no Kotlin √© uma classe aninhada regular sem modificadores: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre><br><br>  Depois de converter o bytecode em Java, vemos: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre> <br><br>  De fato, √© disso que precisamos.  Se n√£o queremos que a classe seja final, no c√≥digo Kotlin especificamos o modificador aberto para ela.  Lembrei-me disso por precau√ß√£o. <br><br>  Eu acho que voc√™ pode resumir.  De fato, na pr√≥pria Kotlin, como foi dito, n√£o h√° est√°tica na forma em que estamos acostumados a v√™-la.  Mas o conjunto de ferramentas proposto nos permite implementar todos os tipos de est√°tica no c√≥digo Java gerado.  Tamb√©m √© fornecida total compatibilidade com Java, e podemos chamar diretamente campos est√°ticos e m√©todos de classes Java do Kotlin. <br>  Na maioria dos casos, a implementa√ß√£o de uma estat√≠stica no Kotlin requer mais algumas linhas de c√≥digo.  Talvez este seja um dos poucos, ou talvez o √∫nico caso em que voc√™ precise escrever mais em Kotlin.  No entanto, voc√™ se acostuma rapidamente. <br>  Penso que nos projetos em que os c√≥digos Kotlin e Java s√£o compartilhados, voc√™ pode abordar com flexibilidade a escolha da linguagem usada.  Por exemplo, parece-me que o Java √© mais adequado para armazenar constantes.  Mas aqui, como em muitas outras coisas, vale a pena ser guiado pelo bom senso e pelas regras para escrever c√≥digo no projeto. <br><br>  E no final do artigo, aqui est√° essa informa√ß√£o.  Talvez no futuro, o Kotlin ainda tenha um modificador est√°tico que elimine muitos problemas e facilita a vida dos desenvolvedores, e o c√≥digo √© mais curto.  Fiz essa suposi√ß√£o encontrando o texto apropriado no par√°grafo 17 das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descri√ß√µes dos recursos</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kotlin</a> . <br>  √â verdade que este documento data de maio de 2017 e no estaleiro j√° √© o fim de 2018. <br><br>  Isso √© tudo para mim.  Eu acho que o t√≥pico foi resolvido com alguns detalhes.  Perguntas escreva nos coment√°rios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430836/">https://habr.com/ru/post/pt430836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430826/index.html">Como desenvolver um gerente de desenvolvimento</a></li>
<li><a href="../pt430828/index.html">Experi√™ncia no uso de monitores LCD baseados em produtos MELT</a></li>
<li><a href="../pt430830/index.html">Sexta-feira negra, tradi√ß√µes e express√µes inglesas sobre compras</a></li>
<li><a href="../pt430832/index.html">Human Black Friday Pre√ßo</a></li>
<li><a href="../pt430834/index.html">Os 10 pecados capitais do falante</a></li>
<li><a href="../pt430838/index.html">As maravilhas do marketing de multid√£o ou como promover um neg√≥cio com cr√≠ticas</a></li>
<li><a href="../pt430840/index.html">Que evid√™ncia pode convencer os matem√°ticos se n√£o houver evid√™ncia rigorosa?</a></li>
<li><a href="../pt430842/index.html">Usamos blockchain para combater a corrup√ß√£o e o cyberbullying</a></li>
<li><a href="../pt430844/index.html">Como escolher uma bateria para UPS</a></li>
<li><a href="../pt430846/index.html">O que h√° de novo: detalhes sobre a implementa√ß√£o da nova arquitetura Zen 2 ficaram conhecidos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>