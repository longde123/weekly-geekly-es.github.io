<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏻 🆙 🤵🏼 EDA sous un angle différent 👨🏼‍💼 👨🏽‍🤝‍👨🏼 🔔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous ne parlerons pas de nourriture, mais d’ analyse exploratoire des données (EDA ), qui est un prélude obligatoire à tout ML sévère. 

 Soyons honnê...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EDA sous un angle différent</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480532/"><img src="https://habrastorage.org/webt/zr/g9/ed/zrg9ed_nsynok9a9aa2st6s0vjo.jpeg" alt="image"><br><br>  Nous ne parlerons pas de nourriture, mais d’ <a href="https://en.wikipedia.org/wiki/Exploratory_data_analysis">analyse exploratoire des données (EDA</a> ), qui est un prélude obligatoire à tout ML sévère. <br><br>  Soyons honnêtes, le processus est plutôt ennuyeux et afin d'obtenir au moins quelques informations significatives sur nos données, vous devez passer suffisamment de temps à utiliser activement votre bibliothèque de visualisation préférée. <br><br>  Imaginez maintenant que nous sommes assez paresseux (mais curieux) et suivrons ce postulat tout au long de cet article. <br><a name="habracut"></a><br>  Sur cette base, nous nous posons la question suivante: existe-t-il un outil si délicat dans la nature qui permettrait simplement d'appuyer sur CTRL + ENTRÉE dans votre IDE préféré et d'afficher sur un seul écran (sans faire défiler vers le bas et d'innombrables facettes microscopiques) une image complète avec des informations utiles sur notre jeu de données? <br><br>  En même temps, nous gardons à l'esprit une pensée différente - si un tel instrument existe, il ne remplacera pas l'EDA classique, mais il nous sera d'une grande aide dans les cas où vous n'avez pas à consacrer des heures à la visualisation pour souligner rapidement les principaux modèles de nos données. <br><br>  La structure de cet article: <br><br><ol><li>  <a href="https://habr.com/ru/post/480532/">Petit prétraitement</a> </li><li>  <a href="https://habr.com/ru/post/480532/">Visualisation des prédicteurs</a> </li><li>  <a href="https://habr.com/ru/post/480532/">Discrétisation des variables</a> </li><li>  <a href="https://habr.com/ru/post/480532/">Correlationfunnel</a> </li><li>  <a href="https://habr.com/ru/post/480532/">Corrélations croisées classées</a> </li><li>  <a href="https://habr.com/ru/post/480532/">easyalluvial</a> </li></ol><br>  Nous terminons avec l'introduction et prenons comme base un exemple pratique. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple d'approche</b> <div class="spoiler_text">  <sub><i>Au départ, je voulais prendre un tableau de données obscur, mais à la fin j'ai réalisé que, par exemple, ce ne serait pas très bon - les modèles trouvés peuvent sembler peu évidents et donc controversés, mais notre objectif est de préparer le tableau avec des algorithmes qui n'ont pas d'informations a priori et nous montreront ce que nous le savons déjà, confirmant ainsi notre viabilité.</i></sub> <sub><br></sub> <br></div></div><br>  Le Titanic m'a paru le plus pratique à titre d'exemple, sa taille n'est pas trop petite comme Iris, il a des variables non informatives, il est bien étudié et a des prédicteurs clairs et, surtout, une base historique. <br><br>  De plus, j'ai trouvé un article sur Habré où l'auteur a effectué un EDA plutôt méticuleux de cet ensemble de données et sur la base des photos, j'ai démontré les résultats.  Ce sera une sorte de référence. <br><br>  Lien vers l'article avec un grand nom pour notre "Baseline_EDA": <br>  <a href="https://habr.com/ru/company/mlclass/blog/270973/">Titanic sur Kaggle: Vous ne lirez pas cet article à la fin</a> . <br><br>  Afin de ne pas se soucier de télécharger / lire des fichiers csv depuis le réseau, nous capturons immédiatement l'ensemble de données d'origine de CRAN <br><br><pre><code class="plaintext hljs">install.packages("titanic") data("titanic_train",package="titanic")</code> </pre> <br><h1><a name="preprocess"></a>  Bref prétraitement </h1><br>  Cet exemple est tellement encerclé dans le réseau par le prétraitement de haut en bas que je ne vais pas particulièrement engloutir ce sujet, je fais des choses basiques: j'extrais le nom de la gonoratora (titre) comme un prédicteur important et je l'utilise pour combler les écarts d'âge. <br><br><pre> <code class="plaintext hljs">library(tidyverse) titanic_train %&gt;% str d &lt;- titanic_train %&gt;% as_tibble %&gt;% mutate(title=str_extract(Name,"\\w+\\.") %&gt;% str_replace(fixed("."),"")) %&gt;% mutate(title=case_when(title %in% c('Mlle','Ms')~'Miss', #   title=='Mme'~ 'Mrs', title %in% c('Capt','Don','Major','Sir','Jonkheer', 'Col')~'Sir', title %in% c('Dona', 'Lady', 'Countess')~'Lady', TRUE~title)) %&gt;% mutate(title=as_factor(title), Survived=factor(Survived,levels = c(0,1),labels=c("no","yes")), Sex=as_factor(Sex), Pclass=factor(Pclass,ordered = T)) %&gt;% group_by(title) %&gt;% #  -      mutate(Age=replace_na(Age,replace = median(Age,na.rm = T))) %&gt;% ungroup #             table(d$title,d$Sex)</code> </pre><br><div class="scrollable-table"><table><tbody><tr><th>  titre </th><th>  mâle </th><th>  femme </th></tr><tr><td>  Monsieur </td><td>  517 </td><td>  0 </td></tr><tr><td>  Madame </td><td>  0 </td><td>  126 </td></tr><tr><td>  Mlle </td><td>  0 </td><td>  185 </td></tr><tr><td>  Maître </td><td>  40 </td><td>  0 </td></tr><tr><td>  Monsieur </td><td>  8 </td><td>  0 </td></tr><tr><td>  Rev </td><td>  6 </td><td>  0 </td></tr><tr><td>  Dr </td><td>  6 </td><td>  1 </td></tr><tr><td>  Dame </td><td>  0 </td><td>  2 </td></tr></tbody></table></div><br><h1><a name="lessinform"></a>  Tous les yaourts ne sont pas également sains ... </h1><br>  Habituellement, au début de l'analyse, je mets de côté les variables non informatives (je mets de côté et ne supprime pas définitivement, car lorsque j'obtiens le maximum du modèle, l'ingénierie pour certaines des variables en attente donne un certain pourcentage du gain de qualité du modèle). <br><br>  Les métriques pour évaluer «l'utilité» d'une variable sont freqRatio (le rapport des fréquences de la valeur la plus populaire par rapport à la deuxième valeur en fréquence) et percentUnique (puissance ou cardinalité - la proportion d'un nombre unique de valeurs par rapport au nombre total de valeurs) <br>  Une aide détaillée peut être vue à partir du package caret <br> <code>?caret::nearZeroVar</code> <br> <br><pre> <code class="plaintext hljs">(feat.scan &lt;- caret::nearZeroVar(x = d,saveMetrics = T) %&gt;% rownames_to_column("featName") %&gt;% as_tibble)</code> </pre> <br><img src="https://habrastorage.org/webt/8q/hs/ji/8qhsji8_xsdpbtizf6bqvghdk3a.jpeg" alt="image"><br><br>  Il est plus pratique pour moi de surveiller les variables dans un plan bidimensionnel (en enregistrant les deux axes de sorte que les points ne se superposent pas dans un petit tas en raison de points aberrants). <br>  Je ne me suis jamais demandé si cette étape était l'EDA, mais en écrivant cet article, j'ai pensé: nous menons maintenant une analyse exploratoire de l'utilité des prédicteurs, leur évaluation visuelle, alors pourquoi n'est-ce pas l'EDA? <br><br><pre> <code class="plaintext hljs"># install.packages("ggrepel") library(ggrepel) ggplot(feat.scan,aes(x=percentUnique,y=freqRatio,label=featName,col=featName))+ geom_point(size=2)+ geom_text_repel(data = feat.scan,size=5)+scale_x_log10()+scale_y_log10()+theme_bw()</code> </pre><br><img src="https://habrastorage.org/webt/7v/fc/ec/7vfcecjnvcaog5hh93sbziy8ouc.jpeg" alt="image"><br><br>  Nous considérons les prédicteurs aberrants comme non informatifs en termes de puissance (axe X) ou de rapport de fréquence (axe Y) et, en conséquence, mis de côté: <br>  PassengerId  Nom;  Ticket  Cabine <br><br><pre> <code class="plaintext hljs">useless.feature &lt;- c("PassengerId","Name","Ticket","Cabin") d &lt;- d %&gt;% select_at(vars(-useless.feature))</code> </pre><br><h1><a name="discret"></a>  Cet univers est discret </h1><br>  Afin de comprendre comment les bibliothèques répertoriées ci-dessous préparent les données - dans cette section, nous montrons avec de petits exemples ce qui se passe dans ces bibliothèques au stade de la préparation des données. <br><br>  À la première étape, il est nécessaire de regrouper toutes les données dans un seul type - souvent, les données d'un même ensemble peuvent être catégoriques et numériques, de plus, les nombres peuvent avoir des valeurs aberrantes et les données catégorielles peuvent être des catégories rares. <br><br>  Pour convertir des variables continues en variables catégorielles, nous pouvons décomposer nos nombres en bacs avec une certaine période d'échantillonnage. <br><br>  L'exemple le plus simple de décomposition en 5 bacs: <br><br><pre> <code class="plaintext hljs">iris %&gt;% as_tibble %&gt;% mutate_if(is.numeric,.funs = ggplot2::cut_number,n=5)</code> </pre><br><img src="https://habrastorage.org/webt/mz/bf/wb/mzbfwb5-xy8iddrjy7gvh_4mfvk.jpeg" alt="image"><br><br>  Pour obtenir la force et la directivité des relations des éléments individuels entre les prédicteurs, une deuxième astuce est utilisée - <a href="https://hackernoon.com/what-is-one-hot-encoding-why-and-when-do-you-have-to-use-it-e3c6186d008f">un encodage à chaud</a> <br><br><pre> <code class="plaintext hljs">library(recipes) iris %&gt;% as_tibble %&gt;% mutate_if(is.numeric,cut_number,n=5) %&gt;% recipe(x = .) %&gt;% step_dummy(all_nominal(),one_hot = T) %&gt;% prep %&gt;% juice %&gt;% glimpse</code> </pre><br>  Au lieu de 5 prédicteurs, nous en avons maintenant 23, mais binaires: <br><br><img src="https://habrastorage.org/webt/tv/qw/c4/tvqwc4gibltq3lghux0zhjgzwhc.jpeg" alt="image"><br><br>  En général, les astuces de conversion s'arrêtent là, mais le travail de 2 bibliothèques sur 3 pour notre EDA «non classique» commence par ces étapes. <br><br>  Ensuite, je présente la fonctionnalité de 3 bibliothèques de visualisation: <br><br><ol><li>  <b>Correlationfunnel</b> - montre l'effet des valeurs individuelles des prédicteurs sur une cible (c'est-à-dire, vous pouvez l'appeler apprentissage supervisé par l'EDA) </li><li>  <b>Lares</b> - montre l'effet des valeurs des prédicteurs individuels sur les autres valeurs individuelles des autres prédicteurs (c'est-à-dire, vous pouvez l'appeler apprentissage non supervisé EDA) </li><li>  <b>easyalluvial</b> - montre la relation cumulative des valeurs groupées des prédicteurs «X» supérieurs par cible (c'est-à-dire, vous pouvez l'appeler apprentissage supervisé par l'EDA) </li></ol><br>  Il est évident que leur fonctionnalité est différente, par conséquent, en faisant la démonstration de ces bibliothèques, je citerai les conclusions de l'auteur de l' <a href="https://habr.com/ru/company/mlclass/blog/270973/">article de</a> notre "Baseline_EDA" en fonction de la fonctionnalité décrite ci-dessus de ce paquet.  (Par exemple, si l'auteur montre la dépendance de l'âge à la survie, je vais insérer une telle citation dans le Correlationfunnel, si l'âge est dans la classe, puis à Lares, etc.) <br><br>  La première bibliothèque est sur scène. <br><br><h1><a name="corfun"></a>  tunnel de corrélation </h1><br>  <a href="https://business-science.github.io/correlationfunnel/">correlationfunnel va accélérer l'analyse exploratoire des données (EDA)</a> <br><img src="https://habrastorage.org/webt/j3/9t/zb/j39tzbul1cekgctjk7znwkdszhu.jpeg" alt="image"><br><br>  La méthodologie est bien décrite dans la <a href="https://cran.r-project.org/web/packages/correlationfunnel/vignettes/key_considerations.html">vignette de</a> la bibliothèque; je vais donner un fragment de calcul de la corrélation par des valeurs binaires <br><br><img src="https://habrastorage.org/webt/hd/7d/li/hd7dliqgmjdcsufitigzylb7hvy.jpeg" alt="image"><br><br>  La bibliothèque suppose la présence d'une cible (variable dépendante) dans nos données et immédiatement sur une image montre la force et la direction de la relation et se classe également par ordre décroissant de cette force formant un entonnoir visuel (en fait, c'est de là que vient le nom). <br><br>  Les fonctions de binarisation intégrées à la bibliothèque vous permettent de réduire les petites catégories en Autres. <br><br>  Comme la bibliothèque ne fonctionne pas avec des variables entières, nous les convertirons en numérique et reviendrons sur notre Titanic. <br><br><pre> <code class="plaintext hljs">#install.packages("correlationfunnel") library(correlationfunnel) d &lt;- d %&gt;% mutate_if(is.integer,as.numeric) d %&gt;% binarize(n_bins = 5,thresh_infreq = .02,one_hot = T) %&gt;% #    correlate(target = Survived__yes) %&gt;% plot_correlation_funnel() # "interactive = T" - plotly!</code> </pre><br><img src="https://habrastorage.org/webt/-t/wj/l-/-twjl-woesnakv9rnym9ndugn5i.jpeg" alt="image"><br><br>  Sur l'axe X, nous avons la force et la direction de la corrélation, sur l'axe Y, nos prédicteurs sont classés par ordre décroissant.  Le premier reflète toujours l'objectif comme  il a la plus forte corrélation avec lui-même (-1; 1). <br><br>  Vérifions comment les conclusions de ce graphique se chevauchent avec les conclusions de l'auteur de notre "Baseline_EDA". <br><blockquote>  Le graphique suivant confirme la théorie selon laquelle plus la classe de cabine des passagers est élevée, plus les chances de survie sont grandes.  (Par "ci-dessus", je veux dire l'ordre inverse, car la première classe est plus élevée que la seconde et, surtout, la troisième.) </blockquote>  L'entonnoir montre que la classe est le troisième prédicteur en termes de force de corrélation, et en effet, dans la 3ème classe, la corrélation inverse, dans la 1ère, le fort positif. <br><blockquote>  Comparez les chances de survie des hommes et des femmes.  Les données confirment la théorie exprimée précédemment. <br><br>  (En général, on peut déjà dire que les principaux facteurs du modèle seront le sexe du passager) </blockquote><br>  L'entonnoir montre que le sexe du passager est le 2e selon le degré de corrélation, le sexe féminin est corrélé à la survie, le sexe masculin est corrélé à la mort. <br><blockquote>  Vous pouvez également tester l'hypothèse que les plus jeunes survivent, car  ils se déplacent plus vite, nagent mieux, etc. <br><br>  Comme vous pouvez le voir, une dépendance explicite n'est pas visible ici. </blockquote><br>  L'entonnoir parle vraiment de la faible signification de ce prédicteur (je me souviens que le gonorant / titre contient l'âge, c'est pourquoi l'âge n'est pas si important), mais même ici, l'entonnoir montre qu'il y a plus de chances de survivre dans les catégories «moins l'infini - 20 ans» (c'est-à-dire les enfants ) et 30-38 (personnes riches, éventuellement 1 classe). <br><blockquote>  Introduisons un indicateur tel que le pourcentage de survie et examinons sa dépendance à l'égard des groupes qui se sont révélés à l'étape précédente </blockquote><br>  (le groupe de l'auteur signifie le titre). <br><br>  L'entonnoir confirme pleinement les conclusions de l'auteur <br><blockquote>  Examinons maintenant les informations qui peuvent être obtenues à partir du nombre de proches sur le navire. <br><br>  Il est très probable que l'absence de parents, ainsi qu'un grand nombre, affecte négativement la survie. </blockquote><br>  SibSP dans l'entonnoir dit clairement la même chose. <br><br>  Et bien sûr, en plus des conclusions de l'auteur, ici vous pouvez voir d'autres schémas, je laisse le plaisir de la contemplation au lecteur <br><br><h1><a name="lrs"></a>  Lares </h1><br>  <a href="https://datascienceplus.com/find-insights-with-ranked-cross-correlations/">Trouvez des informations grâce aux corrélations croisées classées</a> <br><br><img src="https://habrastorage.org/webt/sd/yh/6g/sdyh6ghnnhtnjid9ay2k5s3d9we.png" alt="image"><br><br>  L'auteur de cette bibliothèque est allé encore plus loin - il montre les dépendances non seulement sur la cible, mais aussi sur tout. <br><br><blockquote>  Les corrélations croisées classées <u>expliquent non seulement les relations d'une entité cible spécifique avec les autres, mais la relation de toutes les valeurs de vos données</u> dans un format tabulaire facile à utiliser et à comprendre. <br><br>  Il convertit automatiquement les colonnes catégorielles en numériques avec un encodage à chaud (1 et 0) et d'autres regroupements intelligents tels que des étiquettes «autres» pour les valeurs peu fréquentes et les nouvelles fonctionnalités obsolètes. </blockquote><br><br>  En utilisant le lien ci-dessus, vous pouvez voir un exemple où l'auteur alimente le jeu de données Star Wars dans son package et montre les dépendances trouvées, je suis resté sur sa page, très bien. <br><br>  Essayons notre exemple. <br><br><pre> <code class="plaintext hljs"># ,     : # devtools::install_github("laresbernardo/lares") library(lares) corr_cross(df = d,top = 30)</code> </pre><br><img src="https://habrastorage.org/webt/wd/mu/pv/wdmupvkf00yjchynm1mmsj_nxog.jpeg" alt="image"><br><br>  En plus de l'intersection avec les conclusions basées sur des citations, dans Correlationfunnell, nous présentons quelques citations que nous pouvons voir ici indépendamment de la cible: <br><blockquote>  D'autres modèles peuvent également être trouvés.  Il existe une corrélation négative entre l'âge et la classe, ce qui est probablement dû aux passagers plus âgés qui pourraient plus souvent s'offrir une cabine plus chère. </blockquote><br>  Dans la citation ci-dessus, l'auteur tire une telle conclusion sur l'analyse de corrélation de 2 champs au total, mais au vu de One-Hot-Encoding, cela est évident à partir de la forte corrélation positive entre Age + P_Class_1. <br><blockquote>  De plus, le prix du billet et la classe sont étroitement liés (coefficient de corrélation élevé), ce qui est assez attendu. </blockquote><br>  Troisième ligne ci-dessus: Tarif + P_Classe_1 <br><br>  En plus de recouper les conclusions de l'auteur, ici on peut souligner des choses beaucoup plus intéressantes, je laisserai aussi le plaisir de la contemplation au lecteur. <br><br>  En plus de la sélection facultative des X idées les plus puissantes, vous pouvez également refléter l'image entière et la place de ces points importants dans la masse totale <br><br><pre> <code class="plaintext hljs">corr_cross(df = d,type=2)</code> </pre><br><img src="https://habrastorage.org/webt/us/pa/ud/uspaudtooaflobmfge5tgdi6h6q.jpeg" alt="image"><br><br><h1><a name="alluv"></a>  easyalluvial </h1><br>  <a href="https://www.datisticsblog.com/2018/10/intro_easyalluvial/">Exploration de données avec des parcelles alluviales</a> <br><br><img src="https://habrastorage.org/webt/gm/xg/fp/gmxgfpjhfzpqgqiulecylpd6fge.gif" alt="image"><br><br>  Ici, comme dans les 2 packages précédents, l'auteur effectue une binarisation des variables numériques au début, mais ensuite ses chemins avec ces bibliothèques divergent: au lieu de {One-HotEncoding + correlation}, la bibliothèque présente le X supérieur des prédicteurs les plus intéressants (l'utilisateur décide lesquels transférer) ) par valeurs, formant des flux dont la couleur dépend de la cible, et la largeur du flux sur le nombre d'observations dans ce flux. <br><br>  Les variables numériques sont décomposées en catégories HH (High High), MH (Medium High), M (Medium), ML (Medium Low), LL (Low Low) <br><br>  Tout d'abord, prenons les prédicteurs les plus significatifs basés sur le graphique de correlationfunnel: <br><br><pre> <code class="plaintext hljs">cor.feat &lt;- c("title","Sex","Pclass","Fare")</code> </pre><br>  Ensuite, nous faisons un calendrier <br><br><pre> <code class="plaintext hljs"># install.packages("easyalluvial") library(easyalluvial) al &lt;- d %&gt;% select(Survived,cor.feat) %&gt;% alluvial_wide(fill_by = "first_variable") add_marginal_histograms(p = al,data_input = d,keep_labels = F)</code> </pre><br><img src="https://habrastorage.org/webt/p5/rd/xd/p5rdxduvi-21s-xhwhvzxh5og88.jpeg" alt="image"><br><br>  Pour les citations de l'auteur, nous redessinons le graphique en utilisant les prédicteurs appropriés <br><br><pre> <code class="plaintext hljs">cor.feat &lt;- c("Sex","Pclass","Age") al &lt;- d %&gt;% select(Survived,cor.feat) %&gt;% alluvial_wide(fill_by = "first_variable") add_marginal_histograms(p = al,data_input = d,keep_labels = F)</code> </pre><br><img src="https://habrastorage.org/webt/yz/pb/o-/yzpbo-6q9x0relwi6ewtpyqwlke.jpeg" alt="image"><br><br><blockquote>  Par exemple, le graphique suivant montre clairement que les principaux groupes de survivants sont des femmes de première et deuxième années de tous âges. </blockquote><br>  Le graphique montre également que les femmes survivantes de 3e année ne sont pas non plus un petit groupe <br><br><blockquote>  Et parmi les hommes, tous les garçons de moins de 15 ans ont survécu, sauf la troisième classe de service et une petite proportion d'hommes plus âgés et principalement de la première classe. </blockquote><br>  Ce qui précède est confirmé, mais encore une fois, nous voyons les flux d'hommes de classe 3 survivants dans la catégorie d'âge LL, ML. <br><br>  Tout ce qui précède concernait le paquet «easyalluvial», mais l'auteur a écrit un deuxième paquet «parcats» qui, en haut de l'intrigue, rend le graphique ci-dessus interactif (comme dans le titre de cette section). <br>  Cela permet non seulement de voir le contexte de l'infobulle, mais aussi de réorienter les flux pour une meilleure perception visuelle.  (malheureusement, alors que la bibliothèque n'est pas très optimisée et qu'elle ralentit sur titanic) <br><br><pre> <code class="plaintext hljs"># install.packages("parcats") library(parcats) cor.feat &lt;- c("title","Sex","Pclass","Fare") a &lt;- d %&gt;% select(Survived,cor.feat) %&gt;% alluvial_wide(fill_by = "first_variable") parcats(p = a,marginal_histograms = T,data_input = d)</code> </pre><br><img src="https://habrastorage.org/webt/bt/bc/c4/btbcc4rkdkc6b6jwh9it_mk1y0a.jpeg" alt="image"><br><br><h2>  Bonus </h2><br>  La bibliothèque easyalluviale, en plus de l'analyse exploratoire des données, peut également être utilisée comme interprète pour les modèles de boîte noire (modèles analysant les paramètres dont on ne peut pas comprendre - par quelle logique le modèle donne une réponse basée sur certains prédicteurs). <br><br>  Lien vers l'article de l'auteur: <a href="https://www.datisticsblog.com/2019/04/visualising-model-response-with-easyalluvial/">Visualisez la réponse du modèle avec des graphiques alluviaux</a> <br>  Et la particularité est que de toutes les bibliothèques que j'ai vues, le maximum sur un graphique expliquait la réponse de la boîte noire dans un système de coordonnées pas plus de 2 dimensions (une pour chaque prédicteur), la couleur expliquait la réponse. <br><br>  La bibliothèque easyalluvial vous permet de faire cela sur plus de 2 prédicteurs en même temps (bien sûr, il vaut mieux ne pas se laisser emporter). <br><br>  Par exemple, entraînons une forêt aléatoire sur notre tableau de données et reflétons l'explication d'une forêt aléatoire à l'aide de 3 prédicteurs. <br><br><pre> <code class="plaintext hljs">library(ranger) m &lt;- ranger(formula = Survived~.,data = d,mtry = 6,min.node.size = 5, num.trees = 600, importance = "permutation") library(easyalluvial) (imp &lt;- importance(m) %&gt;% as.data.frame %&gt;% easyalluvial::tidy_imp(imp = .,df=d)) #      #  N-     (   .  !)   dspace &lt;- get_data_space(df = d,imp,degree = 3) #     pred = predict(m, data = dspace) alluvial_model_response(pred$predictions, dspace, imp, degree = 3)</code> </pre><br>  De plus, l'auteur a un connecteur pour les modèles CARET (je ne sais pas dans quelle mesure cela considère maintenant les tidymodels) <br><br><pre> <code class="plaintext hljs">library(caret) trc &lt;- trainControl(method = "none") m &lt;- train(Survived~.,data = d,method="rf",trControl=trc,importance=T) alluvial_model_response_caret(train = m,degree = 4,bins=5,stratum_label_size = 2.8)</code> </pre><br><img src="https://habrastorage.org/webt/qq/qf/iv/qqqfivwgoucmfoikmwhp9mdwelw.jpeg" alt="image"><br><br><h1>  Conclusion </h1><br>  Encore une fois, je répète que je n'appelle pas au remplacement de l'EDA classique, mais je conviens que c'est bien quand il existe une alternative qui fait gagner beaucoup de temps, d'autant plus que les gens sont naturellement assez paresseux, et c'est, comme vous le savez, le moteur du progrès :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480532/">https://habr.com/ru/post/fr480532/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480518/index.html">Tuteur de programmation: pourquoi vous devriez le devenir et comment le faire</a></li>
<li><a href="../fr480520/index.html">Programmation fonctionnelle du point de vue d'EcmaScript. Récursivité et ses types</a></li>
<li><a href="../fr480526/index.html">Les processeurs Intel crachent une clé privée, si vous jouez avec la tension</a></li>
<li><a href="../fr480528/index.html">Pourquoi Facebook vous permettra de transférer des données utilisateur vers d'autres services</a></li>
<li><a href="../fr480530/index.html">L'IoT n'est pas un jouet pour les enfants. Comment les attaques de pirates sur Internet des objets font peur non seulement aux grandes entreprises, mais aussi aux familles ordinaires</a></li>
<li><a href="../fr480534/index.html">16 conseils de développement pour Android dans Kotlin. 2e partie</a></li>
<li><a href="../fr480538/index.html">Quoi de mieux pour les jeux: Intel Optane ou SSD?</a></li>
<li><a href="../fr480540/index.html">Sortie d'Umbraco 8.4: le CMS est encore plus pratique</a></li>
<li><a href="../fr480542/index.html">Sensibilisation à la sécurité des adultes: comment supprimer une vulnérabilité de phishing</a></li>
<li><a href="../fr480544/index.html">5 secrets cachés en Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>