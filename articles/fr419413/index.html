<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèª üõåüèª üõë Chisel - (pas tout √† fait) une nouvelle approche du d√©veloppement de la logique num√©rique üôçüèº üîÜ üëçüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avec le d√©veloppement de la micro√©lectronique, les conceptions RTL sont devenues de plus en plus nombreuses. La r√©utilisation du code Verilog est tr√®s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chisel - (pas tout √† fait) une nouvelle approche du d√©veloppement de la logique num√©rique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419413/"><p><img src="https://habrastorage.org/webt/ka/wc/b5/kawcb52amqtfs9chlivqku8sj-a.jpeg"></p><br><p>  Avec le d√©veloppement de la micro√©lectronique, les conceptions RTL sont devenues de plus en plus nombreuses.  La r√©utilisation du code Verilog est tr√®s g√™nante, m√™me avec les puces Generate, Macros et System Verilog.  Chisel, cependant, permet d'appliquer toute la puissance de la programmation objet et fonctionnelle au d√©veloppement rtl, qui est une √©tape attendue depuis longtemps qui peut remplir les poumons des d√©veloppeurs ASIC et FPGA d'air frais. </p><br><p>  Cet article donnera un bref aper√ßu des fonctionnalit√©s principales et consid√©rera certains cas d'utilisation de l'utilisateur, nous parlerons √©galement des lacunes de cette langue.  √Ä l'avenir, si le sujet est int√©ressant, nous continuons l'article dans des tutoriels plus d√©taill√©s. </p><a name="habracut"></a><br><h3 id="sistemnye-trebovaniya">  Configuration requise </h3><br><ul><li>  niveau de base scala </li><li>  verilog et les principes de base de la conception num√©rique. </li><li>  garder la documentation de burin √† port√©e de main </li></ul><br><p>  Je vais essayer de comprendre les bases du burin √† l'aide d'exemples simples, mais si quelque chose n'est pas clair, vous pouvez jeter un ≈ìil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Quant √† la scala, cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">feuille de triche</a> peut aider pour une plong√©e rapide. </p><br><p>  Il en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">existe un</a> similaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour le burin</a> . </p><br><p>  Le code d'article complet (sous la forme d'un projet scala sbt) peut √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouv√© ici</a> . </p><br><h3 id="prostoy-schetchik">  Compteur simple </h3><br><p>  Comme son nom l'indique, le ciseau 'Constructing Hardware In a scala Embedded Language' est un langage de description du mat√©riel construit sur scala. </p><br><p>  Bri√®vement sur la fa√ßon dont tout fonctionne, alors: un graphique mat√©riel est construit √† partir de la description rtl sur ciseau, qui, √† son tour, se transforme en une description interm√©diaire dans le langage firrtl, puis l'interpr√©teur backend int√©gr√© est g√©n√©r√© √† partir de firrtl verilog. </p><br><p>  Regardons deux impl√©mentations d'un simple compteur. </p><br><p>  verilog: </p><br><pre><code class="plaintext hljs">module SimpleCounter #( parameter WIDTH = 8 )( input clk, input reset, input wire enable, output wire [WIDTH-1:0] out ); reg [WIDTH-1:0] counter; assign out = counter; always @(posedge clk) if (reset) begin counter &lt;= {(WIDTH){1'b0}}; end else if (enable) begin counter &lt;= counter + 1; end endmodule</code> </pre> <br><p>  ciseau: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleCounter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">width: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enable = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(width.<span class="hljs-type"><span class="hljs-type">W</span></span>)) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counter = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(width.<span class="hljs-type"><span class="hljs-type">W</span></span>)) io.out &lt;&gt; counter when(io.enable) { counter := counter + <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span> } }</code> </pre> <br><p>  Un peu de burin: </p><br><ul><li>  <code>Module</code> - conteneur pour la description du module rtl </li><li>  <code>Bundle</code> est une structure de donn√©es en ciseau, principalement utilis√©e pour d√©finir des interfaces. </li><li>  <code>io</code> - variable pour d√©terminer les ports </li><li>  <code>Bool</code> - type de donn√©es, signal simple sur un seul bit </li><li>  <code>UInt(width: Width)</code> - entier non sign√©, le constructeur accepte la profondeur de bits du signal en entr√©e. </li><li>  <code>RegInit[T &lt;: Data](init: T)</code> est un constructeur de registre; il prend une valeur de r√©initialisation √† l'entr√©e et a le m√™me type de donn√©es. </li><li>  <code>&lt;&gt;</code> - op√©rateur de connexion de signal universel </li><li>  <code>when(cond: =&gt; Bool) { /*...*/ }</code> - analogique <code>if</code> un Verilog </li></ul><br><p>  Nous parlerons de quel verilog g√©n√®re un burin un peu plus tard.  Comparez maintenant ces deux mod√®les.  Comme vous pouvez le voir, il n'y a aucune mention des signaux <code>clk</code> et <code>reset</code> dans le burin.  Le fait est que le burin ajoute ces signaux au module par d√©faut.  La valeur de r√©initialisation du registre de <code>counter</code> est <code>RegInit</code> constructeur de registre avec la r√©initialisation <code>RegInit</code> .  Chisel prend en charge les modules avec de nombreux signaux d'horloge, mais √† ce sujet un peu plus tard. </p><br><h3 id="schetchik-chut-poslozhnee">  Le compteur est un peu plus compliqu√© </h3><br><p>  Allons de l'avant et compliquons un peu la t√¢che, par exemple - nous allons cr√©er un compteur multicanal avec un param√®tre d'entr√©e sous la forme d'une s√©quence de bits pour chaque canal. </p><br><p>  Commen√ßons maintenant avec la version burin </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiChannelCounter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">width: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">] = </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">(32, 16, 8, 4</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enable = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Vec</span></span>(width.length, <span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(width.sum.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOut</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">UInt</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> right = width.dropRight(width.length - i).sum <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.out(right + width(i) - <span class="hljs-number"><span class="hljs-number">1</span></span>, right) } }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counters: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">SimpleCounter</span></span>] = width.map(x =&gt; <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SimpleCounter</span></span>(x)) ) io.out &lt;&gt; util.<span class="hljs-type"><span class="hljs-type">Cat</span></span>(counters.map(_.io.out)) width.indices.foreach { i =&gt; counters(i).io.enable &lt;&gt; io.enable(i) } }</code> </pre> <br><p>  Un peu sur la scala: </p><br><ul><li>  <code>width: Seq[Int]</code> - param√®tre d'entr√©e pour le constructeur de la classe <code>MultiChannelCounter</code> , a le type <code>Seq[Int]</code> - une s√©quence avec des √©l√©ments entiers. </li><li>  <code>Seq</code> est l'un des types de collections dans scala avec une s√©quence d'√©l√©ments bien d√©finie. </li><li>  <code>.map</code> est une fonction famili√®re pour les collections pour tout le monde, capable de convertir une collection en une autre en raison de la m√™me op√©ration sur chaque √©l√©ment, dans notre cas, une s√©quence de valeurs enti√®res se transforme en une s√©quence de <code>SimpleCounter</code> avec la profondeur de bits correspondante. </li></ul><br><p>  Un peu de burin: </p><br><ul><li>  <code>Vec[T &lt;: Data](gen: T, n: Int): Vec[T]</code> - type de donn√©es burin, est un analogue du tableau. </li><li>  <code>Module[T &lt;: BaseModule](bc: =&gt; T): T</code> est la m√©thode d'encapsulation requise pour les modules instanciables. </li><li>  <code>util.Cat[T &lt;: Bits](r: Seq[T]): UInt</code> - fonction de concat√©nation, analogique <code>{1'b1, 2'b01, 4'h0}</code> dans verilog </li></ul><br><p>  Faites attention aux ports: <br>  <code>enable</code> - d√©j√† d√©ploy√© dans <code>Vec[Bool]</code> *, en gros, dans un tableau de signaux √† un bit, un pour chaque canal, il √©tait possible de faire <code>UInt(width.length.W)</code> . <br>  <code>out</code> - il est √©tendu √† une largeur totale de tous nos canaux. </p><br><p>  Les <code>counters</code> variables sont un tableau de nos compteurs.  Nous connectons le signal d' <code>enable</code> de chaque compteur au port d'entr√©e correspondant, et combinons tous <code>out</code> signaux de <code>out</code> en un √† l'aide de la fonction <code>util.Cat</code> int√©gr√©e et le transmettons √† la sortie. </p><br><p>  Nous notons √©galement la fonction <code>getOut(i: Int)</code> - cette fonction calcule et retourne la plage de bits dans le signal de <code>out</code> pour le <code>i</code> canal.  Il sera tr√®s utile pour poursuivre les travaux avec un tel compteur.  L'impl√©mentation de quelque chose comme √ßa dans verilog ne fonctionnera pas </p><br><p>  * <code>Vec</code> ne doit pas √™tre confondu avec <code>Vector</code> , le premier est un tableau de donn√©es en ciseau, le second est une collection en scala. </p><br><p>  Essayons maintenant d'√©crire ce module sur verilog, pour plus de commodit√©, m√™me sur systemVerilog. </p><br><p>  Apr√®s avoir r√©fl√©chi, je suis arriv√© √† cette option (tr√®s probablement ce n'est pas la seule vraie et la plus optimale, mais vous pouvez toujours sugg√©rer votre mise en ≈ìuvre dans les commentaires). </p><br><div class="spoiler">  <b class="spoiler_title">verilog</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module MultiChannelCounter #( parameter TOTAL = 4, parameter integer WIDTH_SEQ [TOTAL] = {32, 16, 8, 4} )(clk, reset, enable, out); localparam OUT_WIDTH = get_sum(TOTAL, WIDTH_SEQ); input clk; input reset; input wire [TOTAL - 1 : 0] enable; output wire [OUT_WIDTH - 1 :0] out; genvar j; generate for(j = 0; j &lt; TOTAL; j = j + 1) begin : counter_generation localparam OUT_INDEX = get_sum(j, WIDTH_SEQ); SimpleCounter #( WIDTH_SEQ[j] ) SimpleCounter_unit ( .clk(clk), .reset(reset), .enable(enable[j]), .out(out[OUT_INDEX + WIDTH_SEQ[j] - 1: OUT_INDEX]) ); end endgenerate function automatic integer get_sum; input integer array_width; input integer array [TOTAL]; integer counter = 0; integer i; begin for(i = 0; i &lt; array_width; i = i + 1) counter = counter + array[i]; get_sum = counter; end endfunction endmodule</code> </pre> </div></div><br><p>  Cela semble d√©j√† beaucoup plus impressionnant.  Mais que se passe-t-il si, nous allons plus loin et vis sur l'interface populaire de wishbone avec acc√®s au registre. </p><br><h3 id="bundle-interfeysy">  Interfaces group√©es </h3><br><p>  Wishbone est un petit bus similaire √† AMBA APB, principalement utilis√© pour les c≈ìurs IP open source. </p><br><p>  Plus de d√©tails sur le wiki: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://ru.wikipedia.org/wiki/Wishbone</a> </p><br><p>  Parce que  ciseau nous donne un type de donn√©es de conteneur <code>Bundle</code> est logique pour envelopper le bus dans un tel r√©cipient, qui peut ensuite √™tre utilis√© dans des projets sur le ciseau. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneMasterSignals</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, gotTag: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = false</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adr = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(addrWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dat_master = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(dataWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dat_slave = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(dataWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stb = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> we = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cyc = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sel = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>((dataWidth / <span class="hljs-number"><span class="hljs-number">8</span></span>).<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ack_master = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ack_slave = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag_master: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gotTag) <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag_slave: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gotTag) <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbTransaction</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = cyc &amp;&amp; stb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbWrite</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = wbTransaction &amp;&amp; we <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbRead</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = wbTransaction &amp;&amp; !we <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneMasterSignals.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth, dataWidth, gotTag).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  Un peu sur la scala: </p><br><ul><li>  <code>Option</code> - un wrapper de donn√©es facultatif dans scala qui peut √™tre un √©l√©ment ou <code>None</code> , <code>Option[UInt]</code> est <code>Some(UInt(/*...*/))</code> ou <code>None</code> , utile lors du param√©trage des signaux. </li></ul><br><p>  Cela ne semble rien d'inhabituel.  Juste une description de l'interface par l'assistant, √† l'exception de quelques signaux et m√©thodes: </p><br><p>  <code>tag_master</code> et <code>tag_slave</code> sont des signaux universels facultatifs dans le protocole wishbone, nous les verrons si le param√®tre <code>gotTag</code> est <code>true</code> . </p><br><p>  <code>wbTransaction</code> , <code>wbWrite</code> , <code>wbRead</code> - fonctions pour simplifier le travail avec le bus. </p><br><p>  <code>cloneType</code> - m√©thode de clonage de type requise pour toutes les classes <code>[T &lt;: Bundle]</code> param√©tr√©es </p><br><p>  Mais nous avons √©galement besoin d'une interface esclave, voyons comment elle peut √™tre impl√©ment√©e. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlave</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, tagWidht: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 0</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb = <span class="hljs-type"><span class="hljs-type">Flipped</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth , dataWidth, tagWidht)) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneSlave.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(addrWidth, dataWidth, tagWidht).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  La m√©thode <code>Flipped</code> , comme vous pouvez le deviner d'apr√®s le nom, retourne l'interface, et maintenant notre interface d'assistant est devenue un esclave, nous ajoutons la m√™me classe pour l'assistant. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneMaster</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, tagWidht: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 0</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth , dataWidth, tagWidht) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneMaster.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMaster(addrWidth, dataWidth, tagWidht).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  Eh bien, c'est tout, l'interface est pr√™te.  Mais avant d'√©crire un gestionnaire, voyons comment nous pouvons utiliser ces interfaces au cas o√π nous aurions besoin de faire un changement ou quelque chose avec un grand ensemble d'interfaces de triangulation. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneCrossbarIo</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">n: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> slaves = <span class="hljs-type"><span class="hljs-type">Vec</span></span>(n, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(addrWidth, dataWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> master = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMaster(addrWidth, dataWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WBCrossBar</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">WishboneCrossbarIo</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>)) io.master &lt;&gt; io.slaves(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Ceci est un petit blanc pour le commutateur.  Il est pratique de d√©clarer une interface de type <code>Vec[wishboneSlave]</code> , et vous pouvez connecter les interfaces avec le m√™me op√©rateur <code>&lt;&gt;</code> .  Puces de burin utiles pour g√©rer un large ensemble de signaux. </p><br><h3 id="universalnyy-kontroller-shiny">  Contr√¥leur de bus universel </h3><br><p>  Comme mentionn√© pr√©c√©demment sur la puissance de la programmation fonctionnelle et objet, nous allons essayer de l'appliquer.  Plus loin, nous parlerons de la mise en ≈ìuvre du contr√¥leur de bus universel √† triangulation sous forme de <code>trait</code> , il s'agira d'une sorte de mixin pour tout module avec le bus <code>wishboneSlave</code> , pour le module dont vous avez juste besoin de d√©finir une carte m√©moire et de lui m√©langer le contr√¥leur de <code>trait</code> pendant la g√©n√©ration. </p><br><h4 id="realizaciya">  Impl√©mentation </h4><br><div class="spoiler">  <b class="spoiler_title">Pour ceux qui sont toujours enthousiastes</b> <div class="spoiler_text"><p>  Passons √† l'impl√©mentation du gestionnaire.  Il sera simple et r√©pondra imm√©diatement aux transactions uniques, en cas de chute hors du pool d'adresses, retournez z√©ro. </p><br><p>  Analysons en plusieurs parties: </p><br><ul><li><p>  chaque transaction doit recevoir une r√©ponse avec accus√© de r√©ception </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io : wishboneSlave = <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_ack = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) when(io.wb.wbTransaction) { wb_ack := <span class="hljs-literal"><span class="hljs-literal">true</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> }.otherwise { wb_ack := <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> } wb_ack &lt;&gt; io.wb.ack_slave</code> </pre> <br></li><li>  Nous r√©pondons √† la lecture avec des donn√©es <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_dat = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(io.wb.dat_slave.getWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// getWidth   when(io.wb.wbRead) { wb_dat := MuxCase(default = 0.U, Seq( (io.wb.addr === ADDR_1) -&gt; data_1, (io.wb.addr === ADDR_3) -&gt; data_2, (io.wb.addr === ADDR_3) -&gt; data_2 )) } wb_dat &lt;&gt; io.wb.dat_slave</span></span></code> </pre> <br><ul><li>  <code>MuxCase[T &lt;: Data] (default: T, mapping: Seq[(Bool, T)]): T</code> est le sch√©ma de coordination int√©gr√© du type de <code>case</code> dans verilog *. </li></ul></li></ul><br><p>  √Ä quoi cela ressemblerait-il dans verilog: </p><br><pre> <code class="plaintext hljs"> always @(posedge clock) if(reset) wb_dat_o &lt;= 0; else if(wb_read) case (wb_adr_i) `ADDR_1 : wb_dat_o &lt;= data_1; `ADDR_2 : wb_dat_o &lt;= data_2; `ADDR_3 : wb_dat_o &lt;= data_3; default : wb_dat_o &lt;= 0; endcase }</code> </pre> <br><p>  * En g√©n√©ral, dans ce cas, il s'agit d'un petit hack pour le param√©trage, en ciseau il y a une conception standard qui est pr√©f√©rable d'utiliser si, √©crivez quelque chose de plus simple. </p><br><pre> <code class="scala hljs">switch(x) { is(value1) { <span class="hljs-comment"><span class="hljs-comment">// ... } is(value2) { // ... } }</span></span></code> </pre> <br><p>  Eh bien, le record </p><br><pre> <code class="scala hljs"> when(io.wb.wbWrite) { data_4 := <span class="hljs-type"><span class="hljs-type">Mux</span></span>(io.wb.addr === <span class="hljs-type"><span class="hljs-type">ADDR_4</span></span>, io.wb.dat_master, data_4) }</code> </pre> <br><ul><li>  <code>Mux[T &lt;: Data](cond: Bool, con: T, alt: T): T</code> - multiplexeur r√©gulier </li></ul><br><p>  Nous int√©grons quelque chose de similaire √† notre compteur multicanal, raccrochons des registres pour la gestion des canaux et un chapeau.  Mais ici, c'est √† port√©e de main du contr√¥leur de bus universel WB vers lequel nous allons transf√©rer une carte m√©moire de ce type: </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  Pour une telle t√¢che, le <code>trait</code> nous aidera - quelque chose comme les mixins √† Sala.  La t√¢che principale sera de faire en sorte que <code>readMemMap: [Int, Data]</code> ressemble √† <code>Seq( -&gt; )</code> , et ce serait bien aussi si vous pouviez transf√©rer l'adresse de base et le tableau de donn√©es √† l'int√©rieur de la carte m√©moire </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  Ce qui sera d√©velopp√© avec quelque chose de similaire, o√π WB_DAT_WIDTH est la largeur des donn√©es en octets </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_0</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_2</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_3</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  Pour impl√©menter cela, nous √©crivons une fonction de conversion de <code>Map[Int, Any]</code> √† <code>Seq[(Bool, UInt)]</code> .  Vous devez utiliser le calcul du mod√®le scala. </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseMemMap</span></span></span></span>(memMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = memMap.flatMap { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(addr, data) =&gt; data <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a: <span class="hljs-type"><span class="hljs-type">UInt</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Seq</span></span>((io.wb.adr === addr.<span class="hljs-type"><span class="hljs-type">U</span></span>) -&gt; a) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] =&gt; a.map(x =&gt; (io.wb.adr === (addr + io.wb.dat_slave.getWidth / <span class="hljs-number"><span class="hljs-number">8</span></span>).<span class="hljs-type"><span class="hljs-type">U</span></span>) -&gt; x) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"WRONG MEM MAP!!!"</span></span>) } }.toSeq</code> </pre> <br><p>  Enfin, notre trait ressemblera √† ceci: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlaveDriver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io : wishboneSlave <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedReadMap: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = parseMemMap(readMemMap) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedWriteMap: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = parseMemMap(writeMemMap) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_ack = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_dat = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(io.wb.dat_slave.getWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) when(io.wb.wbTransaction) { wb_ack := <span class="hljs-literal"><span class="hljs-literal">true</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> }.otherwise { wb_ack := <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> } when(io.wb.wbRead) { wb_dat := <span class="hljs-type"><span class="hljs-type">MuxCase</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> = <span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>, parsedReadMap) } when(io.wb.wbWrite) { parsedWriteMap.foreach { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(addrMatched, data) =&gt; data := <span class="hljs-type"><span class="hljs-type">Mux</span></span>(addrMatched, io.wb.dat_master, data) } } wb_dat &lt;&gt; io.wb.dat_slave wb_ack &lt;&gt; io.wb.ack_slave <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseMemMap</span></span></span></span>(memMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = { <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>} }</code> </pre> <br><p>  Un peu sur la scala: </p><br><ul><li>  <code>io , readMemMap, writeMemMap</code> sont les champs abstraits de notre <code>trait</code> 'a, qui doivent √™tre d√©finis dans la classe dans laquelle nous le m√©langerons. </li></ul></div></div><br><h4 id="kak-im-polzovatsya">  Comment l'utiliser </h4><br><p>  Afin de m√©langer notre <code>trait</code> avec le module, plusieurs conditions doivent √™tre remplies: </p><br><ul><li>  <code>io</code> devrait h√©riter de la classe <code>wishboneSlave</code> </li><li>  besoin de d√©clarer deux cartes m√©moire <code>readMemMap</code> et <code>writeMemMap</code> </li></ul><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneMultiChannelCounter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BASE</span></span> = <span class="hljs-number"><span class="hljs-number">0x11A00000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">OUT</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">S_EN</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">H_EN</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000300</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbAddrWidth = <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbDataWidth = <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbTagWidth = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> width = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(wbAddrWidth, wbDataWidth, wbTagWidth) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hardwareEnable: <span class="hljs-type"><span class="hljs-type">Vec</span></span>[<span class="hljs-type"><span class="hljs-type">Bool</span></span>] = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Vec</span></span>(width.length, <span class="hljs-type"><span class="hljs-type">Bool</span></span>())) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counter = <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MultiChannelCounter</span></span>(width)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> softwareEnable = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(width.length.<span class="hljs-type"><span class="hljs-type">W</span></span>)) width.indices.foreach(i =&gt; counter.io.enable(i) := io.hardwareEnable(i) &amp;&amp; softwareEnable(i)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">OUT</span></span> -&gt; width.indices.map(counter.io.getOut), <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">S_EN</span></span> -&gt; softwareEnable, <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">H_EN</span></span> -&gt; io.hardwareEnable.asUInt ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">S_EN</span></span> -&gt; softwareEnable ) }</code> </pre> <br><p>  Nous cr√©ons le registre <code>softwareEnable</code> , il est ajout√© √† 'et' par le signal d'entr√©e <code>hardwareEnable</code> et va activer le <code>counter[MultiChannelCounter]</code> . </p><br><p>  Nous d√©clarons deux cartes m√©moire pour la lecture et l'√©criture: <code>readMemMap</code> <code>writeMemMap</code> , pour plus de d√©tails sur la structure, voir le chapitre ci-dessus. <br>  Dans la carte m√©moire de lecture, nous transf√©rons la valeur du compteur de chaque canal *, <code>softwareEnable</code> et <code>hardwareEnable</code> .  Et pour m√©moire, nous ne donnons que le registre <code>softwareEnable</code> . </p><br><p>  * <code>width.indices.map(counter.io.getOut)</code> - une conception √©trange, analyse fragmentaire. </p><br><ul><li>  <code>width.indices</code> - retournera un tableau avec des indices d'√©l√©ments, c'est-√†-dire  si <code>width.length == 4</code> alors <code>width.indices = {0, 1, 2, 3}</code> </li><li>  <code>{0, 1, 2, 3}.map(counter.io.getOut)</code> - donne quelque chose comme ceci: <br> <code>{ counter.io.getOut(0), counter.io.getOut(1), /*...*/ }</code> </li> </ul><br><p>  Maintenant, pour tout module sur burin avec, nous pouvons d√©clarer des cartes m√©moire pour la lecture et l'√©criture et connecter simplement notre contr√¥leur de bus universel lors de la g√©n√©ration, quelque chose comme ceci: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishbone_multicahnnel_counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneMultiChannelCounter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlaveDriver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">countersDriver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">Driver</span></span>.execute(<span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-string"><span class="hljs-string">"-td"</span></span>, <span class="hljs-string"><span class="hljs-string">"./src/generated"</span></span>), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishbone_multicahnnel_counter ) }</code> </pre> <br><p>  <code>wishboneSlaveDriver</code> - c'est exactement le m√©lange de traits que nous avons d√©crit sous le spoiler. </p><br><p>  Bien s√ªr, cette version du contr√¥leur universel est loin d'√™tre d√©finitive, mais plut√¥t grossi√®re au contraire.  Son objectif principal est de d√©montrer l'une des approches possibles pour d√©velopper rtl sur ciseau.  Avec toutes les capacit√©s de scala, de telles approches peuvent √™tre beaucoup plus vastes, donc chaque d√©veloppeur a son propre champ de cr√©ativit√©.  Certes, il n'y a nulle part o√π s'inspirer particuli√®rement, sauf: </p><br><ul><li>  la biblioth√®que native des burins, dont un peu plus loin, vous pouvez voir l'h√©ritage des modules et des interfaces </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/freechipsproject/rocket-chip</a> - risc-v tout le noyau est impl√©ment√© sur ciseau, √† condition que vous connaissiez tr√®s bien scala, pour les d√©butants sans un demi-litre, comme on dit, il vous faudra beaucoup de temps pour comprendre.  il n'y a pas de documentation officielle sur la structure interne du projet. </li></ul><br><h3 id="multiclockdomain">  MultiClockDomain </h3><br><p>  Et si nous voulons contr√¥ler manuellement l'horloge et r√©initialiser les signaux au ciseau.  Jusqu'√† r√©cemment, cela ne pouvait pas √™tre fait, mais avec l'une des derni√®res versions, le support <code>withClock {}</code> , <code>withReset {}</code> et <code>withClockAndReset {}</code> .  Regardons un exemple: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DoubleClockModule</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> in = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outB = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClock = <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) regClock &lt;&gt; io.out <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockB = withClock(io.clockB) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockB &lt;&gt; io.outB }</code> </pre> <br><ul><li>  <code>regClock</code> - un registre qui sera cadenc√© par le signal d' <code>clock</code> standard et r√©initialis√© par la <code>reset</code> standard </li><li>  <code>regClockB</code> - ce m√™me registre est cadenc√© comme vous l' aurez devin√© le signal <code>io.clockB</code> , mais remise √† z√©ro est utilis√© une norme. </li></ul><br><p>  Si nous voulons supprimer compl√®tement l' <code>clock</code> standard et <code>reset</code> signaux, nous pouvons utiliser la fonctionnalit√© exp√©rimentale - <code>RawModule</code> (module sans horloge standard et signaux de r√©initialisation, tout le monde devra √™tre contr√¥l√© manuellement).  Un exemple: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiClockModule</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockA = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resetA = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resetB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> in = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outA = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outB = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockA = withClockAndReset(io.clockA, io.resetA) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockA &lt;&gt; io.outA <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockB = withClockAndReset (io.clockB, io.resetB) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockB &lt;&gt; io.outB }</code> </pre> <br><h3 id="utils-biblioteka">  Biblioth√®que d'utils </h3><br><p>  Les bonus agr√©ables du ciseau ne s'arr√™tent pas l√†.  Ses cr√©ateurs ont travaill√© dur et ont √©crit une petite mais tr√®s utile biblioth√®que de petites interfaces, modules, fonctions.  Curieusement, il n'y a pas de description de la biblioth√®que sur le wiki, mais vous pouvez voir le lien de la feuille de triche vers lequel au tout d√©but (il y a deux derni√®res sections) </p><br><p>  Interfaces: </p><br><ul><li>  <code>DecoupledIO</code> est l'interface pr√™te / valide couramment utilis√©e. <br>  <code>DecoupledIO(UInt(32.W))</code> - contiendra des signaux: <br> <code>val ready = Input(Bool())</code> <br> <code>val valid = Output(Bool())</code> <br> <code>val data = Output(UInt(32.W))</code> </li> <li>  <code>ValidIO</code> - identique √† <code>DecoupledIO</code> uniquement sans <code>ready</code> </li></ul><br><p>  Modules: </p><br><ul><li>  <code>Queue</code> - le module FIFO synchrone est une chose tr√®s utile. L'interface ressemble √† <br>  <code>val enq: DecoupledIO[T]</code> - <code>DecoupledIO</code> invers√© <br>  <code>val deq: DecoupledIO[T]</code> - <code>DecoupledIO</code> r√©gulier <br>  <code>val count: UInt</code> - quantit√© de donn√©es dans la file d'attente </li><li>  <code>Pipe</code> - module de retard, ins√®re le ni√®me nombre de tranches de registre </li><li>  <code>Arbiter</code> - arbitre sur les interfaces <code>DecoupledIO</code> , a de nombreuses sous-esp√®ces diff√©rentes dans le type d'arbitrage <br>  <code>val in: Vec[DecoupledIO[T]]</code> - tableau d'interfaces d'entr√©e <br> <code>val out: DecoupledIO[T]</code> <br>  <code>val chosen: UInt</code> - affiche le canal s√©lectionn√© </li></ul><br><p>  Autant que vous puissiez comprendre de la discussion sur github - dans les plans globaux, il y a une extension significative de cette biblioth√®que de modules: tels que FIFO asynchrone, LSFSR, diviseurs de fr√©quence, mod√®les PLL pour FPGA;  diverses interfaces;  contr√¥leurs pour eux et bien plus encore. </p><br><h3 id="chisel-io-teseters">  Io-testeurs de burin </h3><br><p>  La possibilit√© de tester au burin doit √™tre mentionn√©e, pour le moment il y a deux fa√ßons de tester ceci: </p><br><ul><li>  <code>peekPokeTesters</code> - des tests de simulation purement qui testent la logique de votre conception </li><li><p>  <code>hardwareIOTeseters</code> est d√©j√† plus int√©ressant car  avec cette approche, vous obtiendrez un banc de test g√©n√©r√© avec des tests que vous avez √©crits sur un burin, et m√™me si vous avez un v√©rificateur, vous obtiendrez m√™me une chronologie. </p><br><p>  Mais jusqu'√† pr√©sent, l'approche du test n'a pas √©t√© finalis√©e et la discussion est toujours en cours.  √Ä l'avenir, un outil universel appara√Ætra probablement, pour les tests et les tests, il sera √©galement possible d'√©crire sur un burin.  Mais pour l'instant, vous pouvez regarder ce qui existe d√©j√† et comment l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utiliser ici</a> . </p><br></li></ul><br><h3 id="nedostatki-chisel">  Inconv√©nients du ciseau </h3><br><p>  Cela ne veut pas dire que le burin est un outil universel et que tout le monde devrait y passer.  Lui, comme peut-√™tre tous les projets en phase de d√©veloppement, a ses inconv√©nients, qui m√©ritent d'√™tre mentionn√©s par souci d'exhaustivit√©. </p><br><p>  Le premier inconv√©nient, et peut-√™tre le plus important, est le manque de vidages asynchrones.  Assez lourd, mais il peut √™tre r√©solu de plusieurs fa√ßons, et l'un d'eux est des scripts au-dessus de verilog, qui transforment la r√©initialisation synchrone en asynchrone.  C'est facile √† faire car  toutes les constructions dans le verilog g√©n√©r√© avec <code>always</code> assez uniformes. </p><br><p>  Le deuxi√®me inconv√©nient, selon beaucoup, est l'illisibilit√© du verilog g√©n√©r√© et, par cons√©quent, la complication du d√©bogage.  Mais regardons le code g√©n√©r√© √† partir de l'exemple avec un simple compteur </p><br><div class="spoiler">  <b class="spoiler_title">Verilog g√©n√©r√©</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">`ifdef RANDOMIZE_GARBAGE_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_INVALID_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_REG_INIT `define RANDOMIZE `endif `ifdef RANDOMIZE_MEM_INIT `define RANDOMIZE `endif module SimpleCounter( input clock, input reset, input io_enable, output [7:0] io_out ); reg [7:0] counter; reg [31:0] _RAND_0; wire [8:0] _T_7; wire [7:0] _T_8; wire [7:0] _GEN_0; assign _T_7 = counter + 8'h1; assign _T_8 = _T_7[7:0]; assign _GEN_0 = io_enable ? _T_8 : counter; assign io_out = counter; `ifdef RANDOMIZE integer initvar; initial begin `ifndef verilator #0.002 begin end `endif `ifdef RANDOMIZE_REG_INIT _RAND_0 = {1{$random}}; counter = _RAND_0[7:0]; `endif // RANDOMIZE_REG_INIT end `endif // RANDOMIZE always @(posedge clock) begin if (reset) begin counter &lt;= 8'h0; end else begin if (io_enable) begin counter &lt;= _T_8; end end end endmodule</code> </pre> </div></div><br><p>  √Ä premi√®re vue, le verilog g√©n√©r√© peut repousser, m√™me dans une conception de taille moyenne, mais jetons un coup d'≈ìil. </p><br><ul><li>  RANDOMIZE d√©finit - (peut √™tre utile lors de tests avec des burineurs) - sont g√©n√©ralement inutiles, mais ils n'interf√®rent pas particuli√®rement </li><li>  Comme nous voyons le nom de nos ports, et le registre est conserv√© </li><li>  _GEN_0 est une variable inutile pour nous, mais n√©cessaire pour que firrtl √† l'interpr√©teur g√©n√®re du verilog.  Nous n'y pr√™tons pas non plus attention. </li><li>  Il reste _T_7 et _T_8, toute la logique combinatoire du verilog g√©n√©r√© sera pr√©sent√©e pas √† pas sous forme de variables _T. </li></ul><br><p>  Plus important encore, tous les ports, registres et c√¢bles n√©cessaires au d√©bogage gardent leurs noms √† l'√©cart.  Et si vous regardez non seulement le verilog mais aussi le ciseau, le processus de d√©bogage sera bient√¥t aussi simple qu'avec le verilog pur. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Dans les r√©alit√©s modernes, le d√©veloppement de RTL, qu'il s'agisse d'asic ou de fpga en dehors de l'environnement acad√©mique, est depuis longtemps pass√© de l'utilisation de code verilog pur √† la main √† l'un ou l'autre type de script de g√©n√©ration, qu'il s'agisse d'un petit script tcl ou d'un IDE entier avec un tas de fonctionnalit√©s. </p><br><p>  Chisel, √† son tour, est le d√©veloppement logique des langages pour le d√©veloppement et le test de la logique num√©rique.  Supposons qu'√† ce stade, il soit loin d'√™tre parfait, mais d√©j√† en mesure de fournir des opportunit√©s pour lesquelles vous pouvez accepter ses lacunes.      ,                   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419413/">https://habr.com/ru/post/fr419413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419401/index.html">Interfaces de ligne de commande Java: picocli</a></li>
<li><a href="../fr419405/index.html">Comment vont les choses avec IPv6, ou ce qui entrave la transition vers une nouvelle version du protocole - discuter de la situation</a></li>
<li><a href="../fr419407/index.html">Une analyse d√©taill√©e de la correspondance Dota 2 entre OpenAI et les gens au format 5x5. Les gens ont perdu</a></li>
<li><a href="../fr419409/index.html">Nouveaux NUC Intel bas√©s sur les processeurs Coffee Lake</a></li>
<li><a href="../fr419411/index.html">√Ä propos du feu dans un gratte-ciel. Cin√©ma et r√©alit√©</a></li>
<li><a href="../fr419415/index.html">Mattermost et Powershell - une puissance √©norme ou une petite automatisation √† la maison</a></li>
<li><a href="../fr419417/index.html">RGPD: cartographie des donn√©es ou comment les clients trouvent des ordinateurs portables oubli√©s depuis longtemps</a></li>
<li><a href="../fr419419/index.html">Auto-tests de l'interface utilisateur: comment le faire ne vaut pas la peine</a></li>
<li><a href="../fr419423/index.html">On nous promet une vid√©o en temps r√©el sans frises ni secousses</a></li>
<li><a href="../fr419425/index.html">Semaine de la s√©curit√© 29. Hacking Reddit, un portefeuille pour les routeurs de crypto-monnaie et MikroTik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>