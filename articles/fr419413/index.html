<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏻 🛌🏻 🛑 Chisel - (pas tout à fait) une nouvelle approche du développement de la logique numérique 🙍🏼 🔆 👍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avec le développement de la microélectronique, les conceptions RTL sont devenues de plus en plus nombreuses. La réutilisation du code Verilog est très...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chisel - (pas tout à fait) une nouvelle approche du développement de la logique numérique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419413/"><p><img src="https://habrastorage.org/webt/ka/wc/b5/kawcb52amqtfs9chlivqku8sj-a.jpeg"></p><br><p>  Avec le développement de la microélectronique, les conceptions RTL sont devenues de plus en plus nombreuses.  La réutilisation du code Verilog est très gênante, même avec les puces Generate, Macros et System Verilog.  Chisel, cependant, permet d'appliquer toute la puissance de la programmation objet et fonctionnelle au développement rtl, qui est une étape attendue depuis longtemps qui peut remplir les poumons des développeurs ASIC et FPGA d'air frais. </p><br><p>  Cet article donnera un bref aperçu des fonctionnalités principales et considérera certains cas d'utilisation de l'utilisateur, nous parlerons également des lacunes de cette langue.  À l'avenir, si le sujet est intéressant, nous continuons l'article dans des tutoriels plus détaillés. </p><a name="habracut"></a><br><h3 id="sistemnye-trebovaniya">  Configuration requise </h3><br><ul><li>  niveau de base scala </li><li>  verilog et les principes de base de la conception numérique. </li><li>  garder la documentation de burin à portée de main </li></ul><br><p>  Je vais essayer de comprendre les bases du burin à l'aide d'exemples simples, mais si quelque chose n'est pas clair, vous pouvez jeter un œil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Quant à la scala, cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">feuille de triche</a> peut aider pour une plongée rapide. </p><br><p>  Il en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">existe un</a> similaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour le burin</a> . </p><br><p>  Le code d'article complet (sous la forme d'un projet scala sbt) peut être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouvé ici</a> . </p><br><h3 id="prostoy-schetchik">  Compteur simple </h3><br><p>  Comme son nom l'indique, le ciseau 'Constructing Hardware In a scala Embedded Language' est un langage de description du matériel construit sur scala. </p><br><p>  Brièvement sur la façon dont tout fonctionne, alors: un graphique matériel est construit à partir de la description rtl sur ciseau, qui, à son tour, se transforme en une description intermédiaire dans le langage firrtl, puis l'interpréteur backend intégré est généré à partir de firrtl verilog. </p><br><p>  Regardons deux implémentations d'un simple compteur. </p><br><p>  verilog: </p><br><pre><code class="plaintext hljs">module SimpleCounter #( parameter WIDTH = 8 )( input clk, input reset, input wire enable, output wire [WIDTH-1:0] out ); reg [WIDTH-1:0] counter; assign out = counter; always @(posedge clk) if (reset) begin counter &lt;= {(WIDTH){1'b0}}; end else if (enable) begin counter &lt;= counter + 1; end endmodule</code> </pre> <br><p>  ciseau: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleCounter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">width: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enable = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(width.<span class="hljs-type"><span class="hljs-type">W</span></span>)) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counter = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(width.<span class="hljs-type"><span class="hljs-type">W</span></span>)) io.out &lt;&gt; counter when(io.enable) { counter := counter + <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span> } }</code> </pre> <br><p>  Un peu de burin: </p><br><ul><li>  <code>Module</code> - conteneur pour la description du module rtl </li><li>  <code>Bundle</code> est une structure de données en ciseau, principalement utilisée pour définir des interfaces. </li><li>  <code>io</code> - variable pour déterminer les ports </li><li>  <code>Bool</code> - type de données, signal simple sur un seul bit </li><li>  <code>UInt(width: Width)</code> - entier non signé, le constructeur accepte la profondeur de bits du signal en entrée. </li><li>  <code>RegInit[T &lt;: Data](init: T)</code> est un constructeur de registre; il prend une valeur de réinitialisation à l'entrée et a le même type de données. </li><li>  <code>&lt;&gt;</code> - opérateur de connexion de signal universel </li><li>  <code>when(cond: =&gt; Bool) { /*...*/ }</code> - analogique <code>if</code> un Verilog </li></ul><br><p>  Nous parlerons de quel verilog génère un burin un peu plus tard.  Comparez maintenant ces deux modèles.  Comme vous pouvez le voir, il n'y a aucune mention des signaux <code>clk</code> et <code>reset</code> dans le burin.  Le fait est que le burin ajoute ces signaux au module par défaut.  La valeur de réinitialisation du registre de <code>counter</code> est <code>RegInit</code> constructeur de registre avec la réinitialisation <code>RegInit</code> .  Chisel prend en charge les modules avec de nombreux signaux d'horloge, mais à ce sujet un peu plus tard. </p><br><h3 id="schetchik-chut-poslozhnee">  Le compteur est un peu plus compliqué </h3><br><p>  Allons de l'avant et compliquons un peu la tâche, par exemple - nous allons créer un compteur multicanal avec un paramètre d'entrée sous la forme d'une séquence de bits pour chaque canal. </p><br><p>  Commençons maintenant avec la version burin </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiChannelCounter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">width: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">] = </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">(32, 16, 8, 4</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enable = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Vec</span></span>(width.length, <span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(width.sum.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOut</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">UInt</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> right = width.dropRight(width.length - i).sum <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.out(right + width(i) - <span class="hljs-number"><span class="hljs-number">1</span></span>, right) } }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counters: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">SimpleCounter</span></span>] = width.map(x =&gt; <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SimpleCounter</span></span>(x)) ) io.out &lt;&gt; util.<span class="hljs-type"><span class="hljs-type">Cat</span></span>(counters.map(_.io.out)) width.indices.foreach { i =&gt; counters(i).io.enable &lt;&gt; io.enable(i) } }</code> </pre> <br><p>  Un peu sur la scala: </p><br><ul><li>  <code>width: Seq[Int]</code> - paramètre d'entrée pour le constructeur de la classe <code>MultiChannelCounter</code> , a le type <code>Seq[Int]</code> - une séquence avec des éléments entiers. </li><li>  <code>Seq</code> est l'un des types de collections dans scala avec une séquence d'éléments bien définie. </li><li>  <code>.map</code> est une fonction familière pour les collections pour tout le monde, capable de convertir une collection en une autre en raison de la même opération sur chaque élément, dans notre cas, une séquence de valeurs entières se transforme en une séquence de <code>SimpleCounter</code> avec la profondeur de bits correspondante. </li></ul><br><p>  Un peu de burin: </p><br><ul><li>  <code>Vec[T &lt;: Data](gen: T, n: Int): Vec[T]</code> - type de données burin, est un analogue du tableau. </li><li>  <code>Module[T &lt;: BaseModule](bc: =&gt; T): T</code> est la méthode d'encapsulation requise pour les modules instanciables. </li><li>  <code>util.Cat[T &lt;: Bits](r: Seq[T]): UInt</code> - fonction de concaténation, analogique <code>{1'b1, 2'b01, 4'h0}</code> dans verilog </li></ul><br><p>  Faites attention aux ports: <br>  <code>enable</code> - déjà déployé dans <code>Vec[Bool]</code> *, en gros, dans un tableau de signaux à un bit, un pour chaque canal, il était possible de faire <code>UInt(width.length.W)</code> . <br>  <code>out</code> - il est étendu à une largeur totale de tous nos canaux. </p><br><p>  Les <code>counters</code> variables sont un tableau de nos compteurs.  Nous connectons le signal d' <code>enable</code> de chaque compteur au port d'entrée correspondant, et combinons tous <code>out</code> signaux de <code>out</code> en un à l'aide de la fonction <code>util.Cat</code> intégrée et le transmettons à la sortie. </p><br><p>  Nous notons également la fonction <code>getOut(i: Int)</code> - cette fonction calcule et retourne la plage de bits dans le signal de <code>out</code> pour le <code>i</code> canal.  Il sera très utile pour poursuivre les travaux avec un tel compteur.  L'implémentation de quelque chose comme ça dans verilog ne fonctionnera pas </p><br><p>  * <code>Vec</code> ne doit pas être confondu avec <code>Vector</code> , le premier est un tableau de données en ciseau, le second est une collection en scala. </p><br><p>  Essayons maintenant d'écrire ce module sur verilog, pour plus de commodité, même sur systemVerilog. </p><br><p>  Après avoir réfléchi, je suis arrivé à cette option (très probablement ce n'est pas la seule vraie et la plus optimale, mais vous pouvez toujours suggérer votre mise en œuvre dans les commentaires). </p><br><div class="spoiler">  <b class="spoiler_title">verilog</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module MultiChannelCounter #( parameter TOTAL = 4, parameter integer WIDTH_SEQ [TOTAL] = {32, 16, 8, 4} )(clk, reset, enable, out); localparam OUT_WIDTH = get_sum(TOTAL, WIDTH_SEQ); input clk; input reset; input wire [TOTAL - 1 : 0] enable; output wire [OUT_WIDTH - 1 :0] out; genvar j; generate for(j = 0; j &lt; TOTAL; j = j + 1) begin : counter_generation localparam OUT_INDEX = get_sum(j, WIDTH_SEQ); SimpleCounter #( WIDTH_SEQ[j] ) SimpleCounter_unit ( .clk(clk), .reset(reset), .enable(enable[j]), .out(out[OUT_INDEX + WIDTH_SEQ[j] - 1: OUT_INDEX]) ); end endgenerate function automatic integer get_sum; input integer array_width; input integer array [TOTAL]; integer counter = 0; integer i; begin for(i = 0; i &lt; array_width; i = i + 1) counter = counter + array[i]; get_sum = counter; end endfunction endmodule</code> </pre> </div></div><br><p>  Cela semble déjà beaucoup plus impressionnant.  Mais que se passe-t-il si, nous allons plus loin et vis sur l'interface populaire de wishbone avec accès au registre. </p><br><h3 id="bundle-interfeysy">  Interfaces groupées </h3><br><p>  Wishbone est un petit bus similaire à AMBA APB, principalement utilisé pour les cœurs IP open source. </p><br><p>  Plus de détails sur le wiki: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://ru.wikipedia.org/wiki/Wishbone</a> </p><br><p>  Parce que  ciseau nous donne un type de données de conteneur <code>Bundle</code> est logique pour envelopper le bus dans un tel récipient, qui peut ensuite être utilisé dans des projets sur le ciseau. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneMasterSignals</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, gotTag: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = false</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adr = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(addrWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dat_master = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(dataWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dat_slave = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(dataWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stb = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> we = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cyc = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sel = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>((dataWidth / <span class="hljs-number"><span class="hljs-number">8</span></span>).<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ack_master = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ack_slave = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag_master: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gotTag) <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag_slave: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gotTag) <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbTransaction</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = cyc &amp;&amp; stb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbWrite</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = wbTransaction &amp;&amp; we <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbRead</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = wbTransaction &amp;&amp; !we <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneMasterSignals.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth, dataWidth, gotTag).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  Un peu sur la scala: </p><br><ul><li>  <code>Option</code> - un wrapper de données facultatif dans scala qui peut être un élément ou <code>None</code> , <code>Option[UInt]</code> est <code>Some(UInt(/*...*/))</code> ou <code>None</code> , utile lors du paramétrage des signaux. </li></ul><br><p>  Cela ne semble rien d'inhabituel.  Juste une description de l'interface par l'assistant, à l'exception de quelques signaux et méthodes: </p><br><p>  <code>tag_master</code> et <code>tag_slave</code> sont des signaux universels facultatifs dans le protocole wishbone, nous les verrons si le paramètre <code>gotTag</code> est <code>true</code> . </p><br><p>  <code>wbTransaction</code> , <code>wbWrite</code> , <code>wbRead</code> - fonctions pour simplifier le travail avec le bus. </p><br><p>  <code>cloneType</code> - méthode de clonage de type requise pour toutes les classes <code>[T &lt;: Bundle]</code> paramétrées </p><br><p>  Mais nous avons également besoin d'une interface esclave, voyons comment elle peut être implémentée. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlave</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, tagWidht: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 0</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb = <span class="hljs-type"><span class="hljs-type">Flipped</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth , dataWidth, tagWidht)) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneSlave.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(addrWidth, dataWidth, tagWidht).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  La méthode <code>Flipped</code> , comme vous pouvez le deviner d'après le nom, retourne l'interface, et maintenant notre interface d'assistant est devenue un esclave, nous ajoutons la même classe pour l'assistant. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneMaster</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, tagWidht: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 0</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth , dataWidth, tagWidht) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneMaster.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMaster(addrWidth, dataWidth, tagWidht).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  Eh bien, c'est tout, l'interface est prête.  Mais avant d'écrire un gestionnaire, voyons comment nous pouvons utiliser ces interfaces au cas où nous aurions besoin de faire un changement ou quelque chose avec un grand ensemble d'interfaces de triangulation. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneCrossbarIo</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">n: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> slaves = <span class="hljs-type"><span class="hljs-type">Vec</span></span>(n, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(addrWidth, dataWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> master = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMaster(addrWidth, dataWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WBCrossBar</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">WishboneCrossbarIo</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>)) io.master &lt;&gt; io.slaves(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Ceci est un petit blanc pour le commutateur.  Il est pratique de déclarer une interface de type <code>Vec[wishboneSlave]</code> , et vous pouvez connecter les interfaces avec le même opérateur <code>&lt;&gt;</code> .  Puces de burin utiles pour gérer un large ensemble de signaux. </p><br><h3 id="universalnyy-kontroller-shiny">  Contrôleur de bus universel </h3><br><p>  Comme mentionné précédemment sur la puissance de la programmation fonctionnelle et objet, nous allons essayer de l'appliquer.  Plus loin, nous parlerons de la mise en œuvre du contrôleur de bus universel à triangulation sous forme de <code>trait</code> , il s'agira d'une sorte de mixin pour tout module avec le bus <code>wishboneSlave</code> , pour le module dont vous avez juste besoin de définir une carte mémoire et de lui mélanger le contrôleur de <code>trait</code> pendant la génération. </p><br><h4 id="realizaciya">  Implémentation </h4><br><div class="spoiler">  <b class="spoiler_title">Pour ceux qui sont toujours enthousiastes</b> <div class="spoiler_text"><p>  Passons à l'implémentation du gestionnaire.  Il sera simple et répondra immédiatement aux transactions uniques, en cas de chute hors du pool d'adresses, retournez zéro. </p><br><p>  Analysons en plusieurs parties: </p><br><ul><li><p>  chaque transaction doit recevoir une réponse avec accusé de réception </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io : wishboneSlave = <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_ack = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) when(io.wb.wbTransaction) { wb_ack := <span class="hljs-literal"><span class="hljs-literal">true</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> }.otherwise { wb_ack := <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> } wb_ack &lt;&gt; io.wb.ack_slave</code> </pre> <br></li><li>  Nous répondons à la lecture avec des données <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_dat = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(io.wb.dat_slave.getWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// getWidth   when(io.wb.wbRead) { wb_dat := MuxCase(default = 0.U, Seq( (io.wb.addr === ADDR_1) -&gt; data_1, (io.wb.addr === ADDR_3) -&gt; data_2, (io.wb.addr === ADDR_3) -&gt; data_2 )) } wb_dat &lt;&gt; io.wb.dat_slave</span></span></code> </pre> <br><ul><li>  <code>MuxCase[T &lt;: Data] (default: T, mapping: Seq[(Bool, T)]): T</code> est le schéma de coordination intégré du type de <code>case</code> dans verilog *. </li></ul></li></ul><br><p>  À quoi cela ressemblerait-il dans verilog: </p><br><pre> <code class="plaintext hljs"> always @(posedge clock) if(reset) wb_dat_o &lt;= 0; else if(wb_read) case (wb_adr_i) `ADDR_1 : wb_dat_o &lt;= data_1; `ADDR_2 : wb_dat_o &lt;= data_2; `ADDR_3 : wb_dat_o &lt;= data_3; default : wb_dat_o &lt;= 0; endcase }</code> </pre> <br><p>  * En général, dans ce cas, il s'agit d'un petit hack pour le paramétrage, en ciseau il y a une conception standard qui est préférable d'utiliser si, écrivez quelque chose de plus simple. </p><br><pre> <code class="scala hljs">switch(x) { is(value1) { <span class="hljs-comment"><span class="hljs-comment">// ... } is(value2) { // ... } }</span></span></code> </pre> <br><p>  Eh bien, le record </p><br><pre> <code class="scala hljs"> when(io.wb.wbWrite) { data_4 := <span class="hljs-type"><span class="hljs-type">Mux</span></span>(io.wb.addr === <span class="hljs-type"><span class="hljs-type">ADDR_4</span></span>, io.wb.dat_master, data_4) }</code> </pre> <br><ul><li>  <code>Mux[T &lt;: Data](cond: Bool, con: T, alt: T): T</code> - multiplexeur régulier </li></ul><br><p>  Nous intégrons quelque chose de similaire à notre compteur multicanal, raccrochons des registres pour la gestion des canaux et un chapeau.  Mais ici, c'est à portée de main du contrôleur de bus universel WB vers lequel nous allons transférer une carte mémoire de ce type: </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  Pour une telle tâche, le <code>trait</code> nous aidera - quelque chose comme les mixins à Sala.  La tâche principale sera de faire en sorte que <code>readMemMap: [Int, Data]</code> ressemble à <code>Seq( -&gt; )</code> , et ce serait bien aussi si vous pouviez transférer l'adresse de base et le tableau de données à l'intérieur de la carte mémoire </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  Ce qui sera développé avec quelque chose de similaire, où WB_DAT_WIDTH est la largeur des données en octets </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_0</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_2</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_3</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  Pour implémenter cela, nous écrivons une fonction de conversion de <code>Map[Int, Any]</code> à <code>Seq[(Bool, UInt)]</code> .  Vous devez utiliser le calcul du modèle scala. </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseMemMap</span></span></span></span>(memMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = memMap.flatMap { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(addr, data) =&gt; data <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a: <span class="hljs-type"><span class="hljs-type">UInt</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Seq</span></span>((io.wb.adr === addr.<span class="hljs-type"><span class="hljs-type">U</span></span>) -&gt; a) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] =&gt; a.map(x =&gt; (io.wb.adr === (addr + io.wb.dat_slave.getWidth / <span class="hljs-number"><span class="hljs-number">8</span></span>).<span class="hljs-type"><span class="hljs-type">U</span></span>) -&gt; x) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"WRONG MEM MAP!!!"</span></span>) } }.toSeq</code> </pre> <br><p>  Enfin, notre trait ressemblera à ceci: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlaveDriver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io : wishboneSlave <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedReadMap: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = parseMemMap(readMemMap) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedWriteMap: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = parseMemMap(writeMemMap) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_ack = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_dat = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(io.wb.dat_slave.getWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) when(io.wb.wbTransaction) { wb_ack := <span class="hljs-literal"><span class="hljs-literal">true</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> }.otherwise { wb_ack := <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> } when(io.wb.wbRead) { wb_dat := <span class="hljs-type"><span class="hljs-type">MuxCase</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> = <span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>, parsedReadMap) } when(io.wb.wbWrite) { parsedWriteMap.foreach { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(addrMatched, data) =&gt; data := <span class="hljs-type"><span class="hljs-type">Mux</span></span>(addrMatched, io.wb.dat_master, data) } } wb_dat &lt;&gt; io.wb.dat_slave wb_ack &lt;&gt; io.wb.ack_slave <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseMemMap</span></span></span></span>(memMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = { <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>} }</code> </pre> <br><p>  Un peu sur la scala: </p><br><ul><li>  <code>io , readMemMap, writeMemMap</code> sont les champs abstraits de notre <code>trait</code> 'a, qui doivent être définis dans la classe dans laquelle nous le mélangerons. </li></ul></div></div><br><h4 id="kak-im-polzovatsya">  Comment l'utiliser </h4><br><p>  Afin de mélanger notre <code>trait</code> avec le module, plusieurs conditions doivent être remplies: </p><br><ul><li>  <code>io</code> devrait hériter de la classe <code>wishboneSlave</code> </li><li>  besoin de déclarer deux cartes mémoire <code>readMemMap</code> et <code>writeMemMap</code> </li></ul><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneMultiChannelCounter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BASE</span></span> = <span class="hljs-number"><span class="hljs-number">0x11A00000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">OUT</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">S_EN</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">H_EN</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000300</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbAddrWidth = <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbDataWidth = <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbTagWidth = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> width = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(wbAddrWidth, wbDataWidth, wbTagWidth) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hardwareEnable: <span class="hljs-type"><span class="hljs-type">Vec</span></span>[<span class="hljs-type"><span class="hljs-type">Bool</span></span>] = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Vec</span></span>(width.length, <span class="hljs-type"><span class="hljs-type">Bool</span></span>())) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counter = <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MultiChannelCounter</span></span>(width)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> softwareEnable = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(width.length.<span class="hljs-type"><span class="hljs-type">W</span></span>)) width.indices.foreach(i =&gt; counter.io.enable(i) := io.hardwareEnable(i) &amp;&amp; softwareEnable(i)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">OUT</span></span> -&gt; width.indices.map(counter.io.getOut), <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">S_EN</span></span> -&gt; softwareEnable, <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">H_EN</span></span> -&gt; io.hardwareEnable.asUInt ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">S_EN</span></span> -&gt; softwareEnable ) }</code> </pre> <br><p>  Nous créons le registre <code>softwareEnable</code> , il est ajouté à 'et' par le signal d'entrée <code>hardwareEnable</code> et va activer le <code>counter[MultiChannelCounter]</code> . </p><br><p>  Nous déclarons deux cartes mémoire pour la lecture et l'écriture: <code>readMemMap</code> <code>writeMemMap</code> , pour plus de détails sur la structure, voir le chapitre ci-dessus. <br>  Dans la carte mémoire de lecture, nous transférons la valeur du compteur de chaque canal *, <code>softwareEnable</code> et <code>hardwareEnable</code> .  Et pour mémoire, nous ne donnons que le registre <code>softwareEnable</code> . </p><br><p>  * <code>width.indices.map(counter.io.getOut)</code> - une conception étrange, analyse fragmentaire. </p><br><ul><li>  <code>width.indices</code> - retournera un tableau avec des indices d'éléments, c'est-à-dire  si <code>width.length == 4</code> alors <code>width.indices = {0, 1, 2, 3}</code> </li><li>  <code>{0, 1, 2, 3}.map(counter.io.getOut)</code> - donne quelque chose comme ceci: <br> <code>{ counter.io.getOut(0), counter.io.getOut(1), /*...*/ }</code> </li> </ul><br><p>  Maintenant, pour tout module sur burin avec, nous pouvons déclarer des cartes mémoire pour la lecture et l'écriture et connecter simplement notre contrôleur de bus universel lors de la génération, quelque chose comme ceci: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishbone_multicahnnel_counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneMultiChannelCounter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlaveDriver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">countersDriver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">Driver</span></span>.execute(<span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-string"><span class="hljs-string">"-td"</span></span>, <span class="hljs-string"><span class="hljs-string">"./src/generated"</span></span>), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishbone_multicahnnel_counter ) }</code> </pre> <br><p>  <code>wishboneSlaveDriver</code> - c'est exactement le mélange de traits que nous avons décrit sous le spoiler. </p><br><p>  Bien sûr, cette version du contrôleur universel est loin d'être définitive, mais plutôt grossière au contraire.  Son objectif principal est de démontrer l'une des approches possibles pour développer rtl sur ciseau.  Avec toutes les capacités de scala, de telles approches peuvent être beaucoup plus vastes, donc chaque développeur a son propre champ de créativité.  Certes, il n'y a nulle part où s'inspirer particulièrement, sauf: </p><br><ul><li>  la bibliothèque native des burins, dont un peu plus loin, vous pouvez voir l'héritage des modules et des interfaces </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/freechipsproject/rocket-chip</a> - risc-v tout le noyau est implémenté sur ciseau, à condition que vous connaissiez très bien scala, pour les débutants sans un demi-litre, comme on dit, il vous faudra beaucoup de temps pour comprendre.  il n'y a pas de documentation officielle sur la structure interne du projet. </li></ul><br><h3 id="multiclockdomain">  MultiClockDomain </h3><br><p>  Et si nous voulons contrôler manuellement l'horloge et réinitialiser les signaux au ciseau.  Jusqu'à récemment, cela ne pouvait pas être fait, mais avec l'une des dernières versions, le support <code>withClock {}</code> , <code>withReset {}</code> et <code>withClockAndReset {}</code> .  Regardons un exemple: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DoubleClockModule</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> in = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outB = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClock = <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) regClock &lt;&gt; io.out <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockB = withClock(io.clockB) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockB &lt;&gt; io.outB }</code> </pre> <br><ul><li>  <code>regClock</code> - un registre qui sera cadencé par le signal d' <code>clock</code> standard et réinitialisé par la <code>reset</code> standard </li><li>  <code>regClockB</code> - ce même registre est cadencé comme vous l' aurez deviné le signal <code>io.clockB</code> , mais remise à zéro est utilisé une norme. </li></ul><br><p>  Si nous voulons supprimer complètement l' <code>clock</code> standard et <code>reset</code> signaux, nous pouvons utiliser la fonctionnalité expérimentale - <code>RawModule</code> (module sans horloge standard et signaux de réinitialisation, tout le monde devra être contrôlé manuellement).  Un exemple: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiClockModule</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockA = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resetA = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resetB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> in = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outA = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outB = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockA = withClockAndReset(io.clockA, io.resetA) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockA &lt;&gt; io.outA <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockB = withClockAndReset (io.clockB, io.resetB) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockB &lt;&gt; io.outB }</code> </pre> <br><h3 id="utils-biblioteka">  Bibliothèque d'utils </h3><br><p>  Les bonus agréables du ciseau ne s'arrêtent pas là.  Ses créateurs ont travaillé dur et ont écrit une petite mais très utile bibliothèque de petites interfaces, modules, fonctions.  Curieusement, il n'y a pas de description de la bibliothèque sur le wiki, mais vous pouvez voir le lien de la feuille de triche vers lequel au tout début (il y a deux dernières sections) </p><br><p>  Interfaces: </p><br><ul><li>  <code>DecoupledIO</code> est l'interface prête / valide couramment utilisée. <br>  <code>DecoupledIO(UInt(32.W))</code> - contiendra des signaux: <br> <code>val ready = Input(Bool())</code> <br> <code>val valid = Output(Bool())</code> <br> <code>val data = Output(UInt(32.W))</code> </li> <li>  <code>ValidIO</code> - identique à <code>DecoupledIO</code> uniquement sans <code>ready</code> </li></ul><br><p>  Modules: </p><br><ul><li>  <code>Queue</code> - le module FIFO synchrone est une chose très utile. L'interface ressemble à <br>  <code>val enq: DecoupledIO[T]</code> - <code>DecoupledIO</code> inversé <br>  <code>val deq: DecoupledIO[T]</code> - <code>DecoupledIO</code> régulier <br>  <code>val count: UInt</code> - quantité de données dans la file d'attente </li><li>  <code>Pipe</code> - module de retard, insère le nième nombre de tranches de registre </li><li>  <code>Arbiter</code> - arbitre sur les interfaces <code>DecoupledIO</code> , a de nombreuses sous-espèces différentes dans le type d'arbitrage <br>  <code>val in: Vec[DecoupledIO[T]]</code> - tableau d'interfaces d'entrée <br> <code>val out: DecoupledIO[T]</code> <br>  <code>val chosen: UInt</code> - affiche le canal sélectionné </li></ul><br><p>  Autant que vous puissiez comprendre de la discussion sur github - dans les plans globaux, il y a une extension significative de cette bibliothèque de modules: tels que FIFO asynchrone, LSFSR, diviseurs de fréquence, modèles PLL pour FPGA;  diverses interfaces;  contrôleurs pour eux et bien plus encore. </p><br><h3 id="chisel-io-teseters">  Io-testeurs de burin </h3><br><p>  La possibilité de tester au burin doit être mentionnée, pour le moment il y a deux façons de tester ceci: </p><br><ul><li>  <code>peekPokeTesters</code> - des tests de simulation purement qui testent la logique de votre conception </li><li><p>  <code>hardwareIOTeseters</code> est déjà plus intéressant car  avec cette approche, vous obtiendrez un banc de test généré avec des tests que vous avez écrits sur un burin, et même si vous avez un vérificateur, vous obtiendrez même une chronologie. </p><br><p>  Mais jusqu'à présent, l'approche du test n'a pas été finalisée et la discussion est toujours en cours.  À l'avenir, un outil universel apparaîtra probablement, pour les tests et les tests, il sera également possible d'écrire sur un burin.  Mais pour l'instant, vous pouvez regarder ce qui existe déjà et comment l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utiliser ici</a> . </p><br></li></ul><br><h3 id="nedostatki-chisel">  Inconvénients du ciseau </h3><br><p>  Cela ne veut pas dire que le burin est un outil universel et que tout le monde devrait y passer.  Lui, comme peut-être tous les projets en phase de développement, a ses inconvénients, qui méritent d'être mentionnés par souci d'exhaustivité. </p><br><p>  Le premier inconvénient, et peut-être le plus important, est le manque de vidages asynchrones.  Assez lourd, mais il peut être résolu de plusieurs façons, et l'un d'eux est des scripts au-dessus de verilog, qui transforment la réinitialisation synchrone en asynchrone.  C'est facile à faire car  toutes les constructions dans le verilog généré avec <code>always</code> assez uniformes. </p><br><p>  Le deuxième inconvénient, selon beaucoup, est l'illisibilité du verilog généré et, par conséquent, la complication du débogage.  Mais regardons le code généré à partir de l'exemple avec un simple compteur </p><br><div class="spoiler">  <b class="spoiler_title">Verilog généré</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">`ifdef RANDOMIZE_GARBAGE_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_INVALID_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_REG_INIT `define RANDOMIZE `endif `ifdef RANDOMIZE_MEM_INIT `define RANDOMIZE `endif module SimpleCounter( input clock, input reset, input io_enable, output [7:0] io_out ); reg [7:0] counter; reg [31:0] _RAND_0; wire [8:0] _T_7; wire [7:0] _T_8; wire [7:0] _GEN_0; assign _T_7 = counter + 8'h1; assign _T_8 = _T_7[7:0]; assign _GEN_0 = io_enable ? _T_8 : counter; assign io_out = counter; `ifdef RANDOMIZE integer initvar; initial begin `ifndef verilator #0.002 begin end `endif `ifdef RANDOMIZE_REG_INIT _RAND_0 = {1{$random}}; counter = _RAND_0[7:0]; `endif // RANDOMIZE_REG_INIT end `endif // RANDOMIZE always @(posedge clock) begin if (reset) begin counter &lt;= 8'h0; end else begin if (io_enable) begin counter &lt;= _T_8; end end end endmodule</code> </pre> </div></div><br><p>  À première vue, le verilog généré peut repousser, même dans une conception de taille moyenne, mais jetons un coup d'œil. </p><br><ul><li>  RANDOMIZE définit - (peut être utile lors de tests avec des burineurs) - sont généralement inutiles, mais ils n'interfèrent pas particulièrement </li><li>  Comme nous voyons le nom de nos ports, et le registre est conservé </li><li>  _GEN_0 est une variable inutile pour nous, mais nécessaire pour que firrtl à l'interpréteur génère du verilog.  Nous n'y prêtons pas non plus attention. </li><li>  Il reste _T_7 et _T_8, toute la logique combinatoire du verilog généré sera présentée pas à pas sous forme de variables _T. </li></ul><br><p>  Plus important encore, tous les ports, registres et câbles nécessaires au débogage gardent leurs noms à l'écart.  Et si vous regardez non seulement le verilog mais aussi le ciseau, le processus de débogage sera bientôt aussi simple qu'avec le verilog pur. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Dans les réalités modernes, le développement de RTL, qu'il s'agisse d'asic ou de fpga en dehors de l'environnement académique, est depuis longtemps passé de l'utilisation de code verilog pur à la main à l'un ou l'autre type de script de génération, qu'il s'agisse d'un petit script tcl ou d'un IDE entier avec un tas de fonctionnalités. </p><br><p>  Chisel, à son tour, est le développement logique des langages pour le développement et le test de la logique numérique.  Supposons qu'à ce stade, il soit loin d'être parfait, mais déjà en mesure de fournir des opportunités pour lesquelles vous pouvez accepter ses lacunes.      ,                   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419413/">https://habr.com/ru/post/fr419413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419401/index.html">Interfaces de ligne de commande Java: picocli</a></li>
<li><a href="../fr419405/index.html">Comment vont les choses avec IPv6, ou ce qui entrave la transition vers une nouvelle version du protocole - discuter de la situation</a></li>
<li><a href="../fr419407/index.html">Une analyse détaillée de la correspondance Dota 2 entre OpenAI et les gens au format 5x5. Les gens ont perdu</a></li>
<li><a href="../fr419409/index.html">Nouveaux NUC Intel basés sur les processeurs Coffee Lake</a></li>
<li><a href="../fr419411/index.html">À propos du feu dans un gratte-ciel. Cinéma et réalité</a></li>
<li><a href="../fr419415/index.html">Mattermost et Powershell - une puissance énorme ou une petite automatisation à la maison</a></li>
<li><a href="../fr419417/index.html">RGPD: cartographie des données ou comment les clients trouvent des ordinateurs portables oubliés depuis longtemps</a></li>
<li><a href="../fr419419/index.html">Auto-tests de l'interface utilisateur: comment le faire ne vaut pas la peine</a></li>
<li><a href="../fr419423/index.html">On nous promet une vidéo en temps réel sans frises ni secousses</a></li>
<li><a href="../fr419425/index.html">Semaine de la sécurité 29. Hacking Reddit, un portefeuille pour les routeurs de crypto-monnaie et MikroTik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>