<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏼 ✖️ ◾️ 90 fitur baru (dan API) di JDK 11 🧖 🍤 🧒🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya sajikan kepada Anda terjemahan artikel " 90 Fitur Baru (dan API) di JDK 11 " oleh Simon Ritter. 





 Bagi banyak orang, siklus rili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>90 fitur baru (dan API) di JDK 11</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424683/"><p>  Halo, Habr!  Saya sajikan kepada Anda terjemahan artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">90 Fitur Baru (dan API) di JDK 11</a> " oleh Simon Ritter. </p><br><p><img src="https://habrastorage.org/webt/nz/8c/f_/nz8cf_erkk_q0xqhz_kptdl772s.jpeg"></p><br><p>  Bagi banyak orang, siklus rilis JDK enam bulan yang baru berarti bahwa beberapa belum mengetahui apa fitur baru di JDK 10, dan JDK 11 berada di ambang. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dalam salah satu blog awal</a> , semua 109 fitur baru dan API terdaftar yang berhasil ditemukan di JDK 10. Oleh karena itu, untuk JDK 11 diputuskan untuk melakukan hal yang sama.  Namun, format yang berbeda dipilih.  Posting ini akan dibagi menjadi dua bagian: fitur baru yang tersedia untuk pengembang (API publik) dan yang lainnya.  Jadi, jika Anda hanya tertarik pada apa yang secara langsung mempengaruhi perkembangan Anda, Anda dapat melewati bagian kedua. </p><br><p>  Jumlah total perubahan yang dapat dihitung ternyata 90 (ini adalah JEP plus kelas dan metode baru, tidak termasuk metode terpisah untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://openjdk.java.net/groups/net/">klien HTTP</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perekam Penerbangan</a> ) ( <em>catatan penerjemah: Java Flight Recorder (JFR) adalah salah satu add-on bawaan Oracle di JDK, tetapi dimulai dengan Java 11, terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 328</a> , itu dipindahkan ke open source)</em> .  Meskipun JDK 11 berhasil menemukan sebelas perubahan kurang dari pada JDK 10, saya pikir itu adil untuk mengatakan bahwa lebih banyak fungsi telah ditambahkan ke JDK 11, pasti di tingkat JVM. </p><a name="habracut"></a><br><h3 id="novye-zametnye-dlya-razrabotchika-fichi">  Fitur baru yang terlihat oleh pengembang </h3><br><p>  JDK 11 memiliki beberapa perubahan yang dapat memengaruhi gaya pengembangan.  Ada sedikit perubahan sintaksis, banyak API baru dan kemampuan untuk menjalankan aplikasi dalam satu file tanpa menggunakan kompiler ( <em>note translator: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file shebang</a> disebut</em> ).  Selain itu, perubahan besar (dan putus) adalah penghapusan modul agregasi <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">java.se.ee</a></strong> , yang dapat mempengaruhi migrasi aplikasi yang ada ke JDK 11. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 323: Sintaks Variabel Lokal untuk Parameter Lambda</a></strong> </p><br><p>  Dalam JDK 10, inferensi variabel lokal (atau inferensi tipe) diperkenalkan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 286</a> ).  Ini menyederhanakan kode karena Anda tidak perlu lagi secara eksplisit menentukan jenis variabel lokal, Anda dapat menggunakan <strong>var</strong> sebagai gantinya.  JEP 323 memperluas penggunaan sintaks ini, yang sekarang juga berlaku untuk parameter ekspresi lambda.  Contoh sederhana: </p><br><pre><code class="java hljs">list.stream() .map((<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Seorang programmer Java yang penuh perhatian akan menunjukkan bahwa ekspresi lambda sudah memiliki tipe inferensi, jadi menggunakan var akan (dalam hal ini) berlebihan.  Kita bisa dengan mudah menulis kode yang sama dengan: </p><br><pre> <code class="java hljs"> list.stream() .map(s -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Mengapa menambahkan dukungan var?  Jawabannya adalah satu kasus khusus - ketika Anda ingin menambahkan anotasi ke parameter lambda.  Ini tidak dapat dilakukan tanpa jenis keterlibatan apa pun.  Untuk menghindari penggunaan tipe eksplisit, kita bisa menggunakan var untuk menyederhanakan banyak hal, dengan cara ini: </p><br><pre> <code class="java hljs"> list.stream() .map((<span class="hljs-meta"><span class="hljs-meta">@Notnull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s) -&gt; s.toLowerCase()) .collect(Collectors.toList());</code> </pre> <br><p>  Perubahan ini membutuhkan perubahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada Spesifikasi Bahasa Jawa (JLS)</a> , khususnya: </p><br><p>  Halaman 24: Deskripsi pengidentifikasi khusus var. <br>  Halaman 627-630: Parameter Lambda <br>  Halaman 636: Evaluasi Runtime dari ekspresi Lambda <br>  Halaman 746: Sintaks Lambda </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 330: Luncurkan Program Kode-Sumber File Tunggal</a></strong> </p><br><p>  Salah satu kritik terhadap Jawa adalah redundansi sintaksis, dan "upacara" yang terkait dengan peluncuran bahkan aplikasi sepele dapat secara serius meningkatkan ambang masuk bagi pemula.  Untuk menulis aplikasi yang hanya mencetak "Hello World!", Anda harus menulis kelas dengan metode utama public static void dan menggunakan metode System.out.println ().  Setelah melakukan ini, Anda harus mengkompilasi kode menggunakan javac.  Akhirnya, Anda dapat meluncurkan aplikasi yang akan menyambut dunia.  Menjalankan skrip yang sama dalam sebagian besar bahasa modern jauh lebih sederhana dan lebih cepat. </p><br><p>  JEP 330 menghilangkan kebutuhan untuk mengkompilasi aplikasi file tunggal.  Sekarang cukup masukkan: </p><br><pre> <code class="java hljs"> java HelloWorld.java</code> </pre> <br><p>  Peluncur Java mengidentifikasi bahwa file tersebut berisi kode sumber Java dan mengkompilasi kode tersebut ke file * .class sebelum menjalankannya. </p><br><p>  Argumen ditempatkan setelah nama file sumber diberikan sebagai argumen ketika aplikasi dimulai.  Argumen ditempatkan sebelum nama file sumber dilewatkan sebagai argumen ke peluncur java setelah kompilasi kode (ini memungkinkan Anda untuk mengatur hal-hal seperti classpath pada baris perintah).  Argumen yang terkait dengan kompiler (mis. Classpath) juga akan diteruskan ke javac untuk kompilasi. </p><br><p>  Contoh: </p><br><pre> <code class="java hljs"> java -classpath /home/foo/java Hello.java Bonjour</code> </pre> <br><p>  Itu akan setara dengan: </p><br><pre> <code class="java hljs"> javac -classpath /home/foo/java Hello.java java -classpath /home/foo/java Hello Bonjour</code> </pre> <br><p>  JEP ini juga menyediakan dukungan untuk file shebang.  Untuk mengurangi perlunya menyebutkan java launcher di baris perintah, Anda dapat memasukkannya di baris pertama file sumber.  Sebagai contoh: </p><br><pre> <code class="java hljs"> #!/usr/bin/java --source <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorld</span></span></span><span class="hljs-class"> </span></span>{ ...</code> </pre> <br><p>  Diperlukan flag -sumber dengan versi Java yang digunakan. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 321: Klien HTTP (Standar)</a></strong> </p><br><p>  JDK 9 memperkenalkan API baru untuk mendukung protokol HTTP Client ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 110</a> ).  Karena JDK 9 menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Platform Module System (JPMS)</a> , API ini dimasukkan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul inkubator</a> .  Modul inkubator dirancang untuk menyediakan API baru, tetapi tidak mengubahnya menjadi standar Java SE.  Pengembang dapat mencoba API dengan memberikan umpan balik.  Setelah melakukan perubahan yang diperlukan (API ini diperbarui di JDK 10), API dapat ditransfer ke modul utama untuk menjadi bagian dari standar. </p><br><p>  HTTP Client API sekarang merupakan bagian dari standar Java SE 11. Ini memperkenalkan modul dan paket baru untuk JDK, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://download.java.net/java/early_access/jdk11/docs/api/java.net.">java.net.http</a> .  Kelas utama: </p><br><ul><li>  Httpclient </li><li>  Httprequest </li><li>  HttpResponse </li><li>  Soket web </li></ul><br><p>  API dapat digunakan secara sinkron atau asinkron.  Dalam mode asinkron, CompletionFutures dan CompletionStages digunakan. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 320: Hapus Modul Java EE dan CORBA</a></strong> </p><br><p>  Dengan diperkenalkannya JPMS di JDK 9, dimungkinkan untuk membagi file rt.jar monolitik menjadi beberapa modul.  Manfaat tambahan dari JPMS adalah sekarang Anda dapat membuat lingkungan runtime Java yang hanya mencakup modul yang diperlukan untuk aplikasi Anda, sangat mengurangi ukuran keseluruhan.  Dengan batasan yang jelas, modul usang sekarang lebih mudah untuk dihapus dari Java API.  Inilah yang dilakukan JEP ini;  Modul meta java.se.ee mencakup enam modul yang tidak lagi menjadi bagian dari standar Java SE 11 dan tidak akan dimasukkan dalam JDK. </p><br><p>  Modul Jarak Jauh: </p><br><ul><li>  corba ( <em>catatan penerjemah:</em> <del>  <em>beristirahat dengan tenang</em> </del>  <em>, bakar di neraka</em> ) </li><li>  transaksi </li><li>  aktivasi </li><li>  xml.bind </li><li>  xml.ws </li><li>  xml.ws.annotation </li></ul><br><p>  Modul-modul ini telah ditandai usang (@Deprecated) sejak JDK 9 dan tidak disertakan secara default dalam kompilasi atau runtime.  Jika Anda mencoba mengompilasi atau menjalankan aplikasi menggunakan API dari modul-modul ini pada JDK 9 atau JDK 10, maka Anda akan gagal.  Jika Anda menggunakan API dari modul-modul ini dalam kode Anda, Anda harus menyediakannya sebagai modul atau pustaka yang terpisah.  Dilihat oleh ulasan, tampaknya bahwa modul java.xml yang merupakan bagian dari JAX-WS, dukungan layanan web SOAP adalah orang-orang yang akan menyebabkan sebagian besar masalah. </p><br><h3 id="novyy-publichnyy-api">  API publik baru </h3><br><p>  Banyak API baru di JDK 11 adalah hasil dari kenyataan bahwa modul klien HTTP sekarang menjadi bagian dari standar, serta dimasukkannya Perekam Penerbangan. </p><br><p>  Daftar skema lengkap perubahan API, termasuk perbandingan berbagai versi JDK, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat ditemukan di sini.</a> </p><br><p>  Tercantum di sini adalah semua metode baru selain yang terdapat dalam modul java.net.http dan jdk.jfr.  Juga tidak terdaftar adalah metode dan kelas baru dalam modul java.security, yang cukup spesifik untuk perubahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 324</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 329</a> (ada enam kelas baru dan delapan metode baru). </p><br><h4 id="javaiobytearrayoutputstream">  java.io.ByteArrayOutputStream </h4><br><ul><li>  <strong>membatalkan writeBytes (byte [])</strong> : menulis semua byte dari argumen ke OutputStream </li></ul><br><h4 id="javaiofilereader">  java.io.FileReader </h4><br><p>  Dua konstruktor baru yang memungkinkan Anda menentukan Charset. </p><br><h4 id="javaiofilewriter">  java.io.FileWriter </h4><br><p>  Empat konstruktor baru yang memungkinkan Anda menentukan Charset. </p><br><h4 id="javaioinputstream">  java.io.InputStream </h4><br><ul><li>  <strong>io.InputStream nullInputStream ()</strong> : mengembalikan InputStream yang tidak membaca byte.  Melihat metode ini (dan yang ada di OutputStream, Reader, dan Writer), muncul pertanyaan mengapa itu mungkin berguna.  Anda dapat menganggapnya sebagai <strong>/ dev / null</strong> - untuk membuang output yang tidak Anda butuhkan, atau memberikan input yang selalu mengembalikan byte nol. </li></ul><br><h4 id="javaiooutputstream">  java.io.OutputStream </h4><br><ul><li>  <strong>io.OutputStream nullOutputStream ()</strong> </li></ul><br><h4 id="javaioreader">  java.io.Reader </h4><br><ul><li>  <strong>io.Reader nullReader ()</strong> </li></ul><br><h4 id="javaiowriter">  java.io.Writer </h4><br><ul><li>  <strong>io.Writer nullWriter ()</strong> </li></ul><br><h4 id="javalangcharacter">  java.lang.Character </h4><br><ul><li>  <strong>String toString (int)</strong> : Ini adalah bentuk overload dari metode yang sudah ada, tetapi int digunakan sebagai ganti char.  Int adalah titik kode Unicode. </li></ul><br><h4 id="javalangcharsequence">  java.lang.CharSequence </h4><br><ul><li>  <strong>int bandingkan (CharSequence, CharSequence)</strong> : membandingkan dua contoh CharSequence secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">leksikografis</a> .  Mengembalikan nilai negatif, nol, atau nilai positif jika urutan pertama kurang leksikografis, sama dengan, atau lebih besar dari yang kedua. </li></ul><br><h4 id="javalangrefreference">  referensi java.lang.ref. </h4><br><ul><li>  <strong>lang.Object clone ()</strong> : Saya harus mengakui, perubahan ini menyebabkan kebingungan.  Kelas referensi tidak mengimplementasikan antarmuka Cloneable, dan metode ini melempar CloneNotSupportedException.  Pasti ada alasan untuk dimasukkan, mungkin untuk sesuatu di masa depan.  ( <em>Catatan Penerjemah: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada diskusi tentang StackOverflow</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiket di OpenJDK</a></em> ) </li></ul><br><h4 id="javalangruntime">  java.lang.Runtime </h4><br><h4 id="javalangsystem">  java.lang.System </h4><br><p>  Tidak ada metode baru di sini, tetapi perlu disebutkan bahwa metode <strong>runFinalizersOnExit ()</strong> sekarang dihapus dari kedua kelas (mungkin ada masalah ketika bermigrasi ke JDK 11). </p><br><h4 id="javalangstring">  java.lang.String </h4><br><p>  Saya pikir ini adalah salah satu highlights dari API baru di JDK 11. Ada beberapa metode baru yang berguna di sini. </p><br><ul><li>  <strong>boolean isBlank ()</strong> : mengembalikan true jika string kosong atau hanya berisi spasi, jika tidak palsu. </li><li>  <strong>Aliran garis ()</strong> : mengembalikan Aliran dari String, diekstraksi dari string ini, dipisahkan oleh pemisah garis. </li><li>  <strong>String repeat (int)</strong> : mengembalikan string yang nilainya merupakan gabungan dari string ini, diulang beberapa kali. </li><li>  <strong>String strip ()</strong> : Mengembalikan string yang nilainya string ini, ini menghapus semua spasi di awal dan akhir string. </li><li>  <strong>String stripLeading ()</strong> : mengembalikan string yang nilainya string ini, sambil menghapus semua spasi di awal baris. </li><li>  <strong>String stripTrailing ()</strong> : mengembalikan string yang nilainya string ini, ini menghapus semua spasi di akhir string. </li></ul><br><p>  Kemungkinan besar, Anda melihat <strong>strip ()</strong> dan bertanya: "Apa bedanya dengan metode <strong>trim ()</strong> yang ada?"  Jawabannya terletak pada perbedaan dalam mendefinisikan ruang.  ( <em>catatan penerjemah: singkatnya, <strong>strip ()</strong> memahami Unicode lebih baik, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis terperinci tentang StackOverflow</a></em> ) </p><br><h4 id="javalangstringbuffer">  java.lang.StringBuffer </h4><br><h4 id="javalangstringbuilder">  java.lang.StringBuilder </h4><br><p>  Kedua kelas ini memiliki metode <strong>compareTo () baru</strong> yang menggunakan StringBuffer / StringBuilder dan mengembalikan int.  Metode perbandingan leksikal mirip dengan metode <strong>compareTo () baru</strong> di CharSequence. </p><br><h4 id="javalangthread">  java.lang.Thread </h4><br><p>  Tidak ada metode baru.  Metode <strong>destroy ()</strong> dan <strong>stop (Throwable)</strong> telah dihapus.  Metode <strong>stop ()</strong> , yang tidak menggunakan argumen, masih ada.  Dapat menyebabkan masalah kompatibilitas. </p><br><h4 id="javaniobytebuffer">  java.nio.ByteBuffer </h4><br><h4 id="javaniocharbuffer">  java.nio.CharBuffer </h4><br><h4 id="javaniodoublebuffer">  java.nio.DoubleBuffer </h4><br><h4 id="javaniofloatbuffer">  java.nio.FloatBuffer </h4><br><h4 id="javaniolongbuffer">  java.nio.LongBuffer </h4><br><h4 id="javanioshortbuffer">  java.nio.ShortBuffer </h4><br><p>  Semua kelas ini sekarang memiliki metode <strong>mismatch ()</strong> , yang menemukan dan mengembalikan indeks relatif ketidakcocokan pertama antara buffer ini dan buffer yang diteruskan. </p><br><h4 id="javaniochannelsselectionkey">  java.nio.channels.SelectionKey </h4><br><ul><li>  <strong>int interestOpsAnd (int)</strong> : Secara teoritis menetapkan minat kunci ini (minat kunci) ke persimpangan bitwise ("dan") dari rangkaian minat yang ada dan nilai yang diteruskan. </li><li>  <strong>int interestOpsOr (int)</strong> : Secara teoritis menetapkan minat kunci ini (bunga kunci) dalam bitwise union ("atau") dari rangkaian minat yang ada dan nilai yang diteruskan. </li></ul><br><h4 id="javaniochannelsselector">  java.nio.channels.Selector </h4><br><ul><li>  <strong>int select (java.util.function.Consumer, long)</strong> : pilih dan lakukan tindakan pada tombol yang salurannya sesuai untuk operasi I / O.  argumen panjang adalah batas waktu. </li><li>  <strong>pilih int (java.util.function.Consumer)</strong> : sama seperti di atas, tetapi tanpa batas waktu. </li><li>  <strong>int selectNow (java.util.function.Consumer)</strong> : sama seperti di atas, hanya non-blocking. </li></ul><br><h4 id="javaniofilefiles">  java.nio.file.Files </h4><br><ul><li>  <strong>String readString (Path)</strong> : membaca semua konten dari file menjadi string, mendekode dari byte ke karakter menggunakan pengkodean UTF-8. </li><li>  <strong>String readString (Path, Charset)</strong> : seperti yang ditunjukkan di atas, dengan perbedaan bahwa decoding dari byte ke karakter terjadi menggunakan Charset yang ditentukan. </li><li>  <strong>Path writeString (Path, CharSequence, java.nio.file.OpenOption [])</strong> : Tulis CharSequence ke file.  Karakter dikodekan dalam byte menggunakan pengkodean UTF-8. </li><li>  <strong>Path writeString (Path, CharSequence, java.nio.file.Charset, OpenOption [])</strong> : sama seperti di atas, karakter dikodekan dalam byte menggunakan pengkodean yang ditentukan dalam Charset. </li></ul><br><h4 id="javaniofilepath">  java.nio.file.Path </h4><br><ul><li>  <strong>Path of (String, String [])</strong> : mengembalikan Path dari argumen string dari path atau urutan string yang, ketika digabungkan, membentuk string path. </li><li>  <strong>Path of (net.URI)</strong> : mengembalikan Path dari URI. </li></ul><br><h4 id="javautilcollection">  java.util.Collection </h4><br><ul><li>  <strong>Objek [] toArray (java.util.function.IntFunction)</strong> : mengembalikan array yang berisi semua elemen dalam koleksi ini, menggunakan fungsi generasi yang disediakan untuk mengalokasikan array yang dikembalikan. </li></ul><br><h4 id="javautilconcurrentpriorityblockingqueue">  java.util.concurrent.PriorityBlockingQueue </h4><br><h4 id="javautilpriorityqueue">  java.util.PriorityQueue </h4><br><ul><li>  <strong>void forEach (java.util.function.Consumer)</strong> : Melakukan aksi yang diteruskan untuk setiap elemen yang dapat diulangi hingga semua elemen diproses atau tindakan tersebut membuat pengecualian. </li><li>  <strong>boolean removeAll (java.util.Collection)</strong> : menghapus semua elemen koleksi ini yang juga terkandung dalam koleksi yang ditentukan (operasi opsional). </li><li>  <strong>boolean removeIf (java.util.function.Predicate)</strong> : Menghapus semua elemen dari koleksi ini yang memenuhi predikat yang diberikan. </li><li>  <strong>boolean retainAll (java.util.Collection)</strong> : Menyimpan hanya elemen-elemen dalam koleksi ini yang terkandung dalam koleksi yang ditransfer (operasi opsional). </li></ul><br><h4 id="javautilconcurrenttimeunit">  java.util.concurrent.TimeUnit </h4><br><ul><li>  <strong>long convert (java.time.Duration)</strong> : mengkonversi Durasi yang dilewati ke jenis ini. </li></ul><br><h4 id="javautilfunctionpredicate">  java.util.function.Predicate </h4><br><ul><li>  <strong>Predikat tidak (Predikat)</strong> : Mengembalikan predikat, yang merupakan negasi dari predikat yang ditransmisikan. </li></ul><br><p>  Ini adalah salah satu API baru favorit saya di JDK 11. Sebagai contoh, Anda dapat mengonversi kode ini: </p><br><pre> <code class="java hljs"> lines.stream() .filter(s -&gt; !s.isBlank())</code> </pre> <br><p>  masuk </p><br><pre> <code class="java hljs"> lines.stream() .filter(Predicate.not(String::isBlank))</code> </pre> <br><p>  atau jika kami menggunakan impor statis: </p><br><pre> <code class="java hljs"> lines.stream() .filter(not(String::isBlank))</code> </pre> <br><p>  Secara pribadi, saya percaya bahwa versi ini lebih mudah dipahami dan ringkas. </p><br><h4 id="javautiloptional">  java.util.Optional </h4><br><h4 id="javautiloptionalint">  java.util.OptionalInt </h4><br><h4 id="javautiloptionaldouble">  java.util.OptionalDouble </h4><br><h4 id="javautiloptionallong">  java.util.OptionalLong </h4><br><ul><li>  <strong>boolean isEmpty ()</strong> : Jika tidak ada nilai, mengembalikan true, jika tidak, false. </li></ul><br><h4 id="javautilregexpattern">  java.util.regex.Pattern </h4><br><ul><li>  <strong>Predikat asMatchPredicate ()</strong> : Saya pikir itu mungkin permata dari JDK 11. API baru. Membuat predikat yang memeriksa apakah templat ini cocok dengan string input yang diberikan. </li></ul><br><h4 id="javautilzipdeflater">  java.util.zip.Deflater </h4><br><ul><li><p>  <strong>int deflate (ByteBuffer)</strong> : kompres input dan isi buffer yang ditentukan dengannya. </p><br></li><li><p>  <strong>int deflate (ByteBuffer, int)</strong> : kompres input dan isi buffer yang ditentukan dengannya.  Mengembalikan jumlah aktual dari data yang dikompresi. </p><br></li><li><p>  <strong>void setDictionary (ByteBuffer)</strong> : Menetapkan kamus yang ditentukan untuk kompresi ke byte di buffer ini.  Ini adalah bentuk kelebihan dari metode yang sudah ada yang bisa diterima ByteBuffer, bukan array byte. </p><br></li><li><p>  <strong>void setInput (ByteBuffer)</strong> : Mengatur input yang akan dikompres.  Juga merupakan bentuk kelebihan dari metode yang ada. </p><br></li></ul><br><h4 id="javautilzipinflater">  java.util.zip.Inflater </h4><br><ul><li>  <strong>int inflate (ByteBuffer)</strong> : mendekompresi byte ke buffer yang ditentukan.  Mengembalikan jumlah byte aktual yang tidak di-zip. </li><li>  <strong>void setDictionary (ByteBuffer)</strong> : Mengatur kamus yang ditentukan ke byte di buffer ini.  Bentuk kelebihan dari metode yang ada. </li><li>  <strong>membatalkan setInput (ByteBuffer)</strong> : Mengatur input untuk dekompresi.  Bentuk kelebihan dari metode yang ada. </li></ul><br><h4 id="javaxprintattributestandarddialogowner">  javax.print.attribute.standard.DialogOwner </h4><br><p>  Ini adalah kelas baru di JDK 11. Digunakan untuk mendukung permintaan dialog cetak atau pengaturan halaman.  Harus ditampilkan di atas semua jendela atau jendela tertentu. </p><br><h4 id="javaxswingdefaultcomboboxmodel">  javax.swing.DefaultComboBoxModel </h4><br><h4 id="javaxswingdefaultlistmodel">  javax.swing.DefaultListModel </h4><br><ul><li>  <strong>membatalkan addAll (Koleksi)</strong> : menambahkan semua elemen yang ada dalam koleksi. </li><li>  <strong>membatalkan addAll (int, Collection)</strong> : menambahkan semua elemen yang ada dalam koleksi, mulai dari indeks yang ditentukan. </li></ul><br><h4 id="javaxswinglistselectionmodel">  javax.swing.ListSelectionModel </h4><br><ul><li>  <strong>int [] getSelectedIndices ()</strong> : Mengembalikan array semua indeks yang dipilih dalam model yang dipilih, dalam urutan menaik. </li><li>  <strong>int getSelectedItemsCount ()</strong> : Mengembalikan jumlah item yang dipilih. </li></ul><br><h4 id="jdkjshellevalexception">  jdk.jshell.EvalException </h4><br><ul><li>  <strong>jshell.JShellException getCause ()</strong> : mengembalikan pembungkus penyebab yang dapat dibuang di klien eksekusi yang diwakili oleh EvalException, atau nol jika penyebabnya tidak ada atau tidak diketahui. </li></ul><br><h3 id="novye-fichi-ne-publichnyy-api">  Fitur baru (bukan API publik) </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 181: Kontrol Akses Berbasis Sarang</a> </p><br><p>  Java (dan bahasa lainnya) mendukung kelas bersarang melalui kelas dalam.  Untuk operasi yang benar, kompiler harus melakukan beberapa trik.  Sebagai contoh: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outerInt); } } }</code> </pre> <br><p>  Kompiler memodifikasi ini untuk membuat sesuatu seperti ini sebelum melakukan kompilasi: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerInt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access$<span class="hljs-number"><span class="hljs-number">000</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outerInt; } }</code> </pre> <br><pre> <code class="java hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Outer outer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printOuterInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Outer int = "</span></span> + outer.access$<span class="hljs-number"><span class="hljs-number">000</span></span>()); } }</code> </pre> <br><p>  Meskipun, secara logis, kelas dalam adalah bagian dari kode yang sama dengan kelas luar, itu dikompilasi sebagai kelas terpisah.  Oleh karena itu, ini memerlukan metode sintetis ("jembatan"), yang harus dibuat oleh kompiler untuk memberikan akses ke bidang pribadi kelas eksternal. </p><br><p>  JEP ini mewakili konsep "soket", di mana dua anggota soket yang sama (Luar dan Dalam dari contoh kami) adalah tetangga.  Dua atribut baru ditambahkan dalam format file * .class: NestHost dan NestMembers.  Perubahan ini juga berguna untuk bahasa yang dikompilasi bytecode lain yang mendukung kelas bersarang. </p><br><p>  Fitur ini menyediakan tiga metode baru untuk java.lang.Class: </p><br><ul><li>  <strong>Kelas getNestHost ()</strong> </li><li>  <strong>Kelas [] getNestMembers ()</strong> </li><li>  <strong>boolean isNestmateOf (clazz)</strong> </li></ul><br><p>  Fitur ini juga memerlukan perubahan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi Mesin Virtual Java (JVMS)</a> , khususnya di bagian 5.4.4 Kontrol Akses. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 309: Konstanta File-Kelas Dinamis</a></strong> </p><br><p>  JEP ini menjelaskan ekstensi format file * .class untuk mendukung formulir baru dengan kumpulan konstan CONSTANT_Dynamic (sering disebut sebagai condy dalam presentasi).  Gagasan tentang konstanta dinamis tampaknya merupakan sebuah oxymoron, tetapi, pada kenyataannya, Anda dapat menganggapnya sebagai nilai akhir di Jawa.  Nilai pool konstan tidak diatur pada tahap kompilasi (tidak seperti konstanta lain), tetapi metode bootstrap digunakan untuk menentukan nilai pada saat run time.  Oleh karena itu, nilainya dinamis, tetapi karena nilainya hanya ditetapkan satu kali, nilainya juga konstan. </p><br><p>  Fitur ini terutama bermanfaat bagi mereka yang sedang mengembangkan bahasa dan kompiler baru.  Siapa yang akan menghasilkan bytecode dan * .class file untuk dijalankan di JVM.  Ini akan menyederhanakan beberapa tugas. </p><br><p>  Fitur ini menyediakan kelas java.lang.invoke.ConstantBootstraps baru dengan sembilan metode baru.  Saya tidak akan mencantumkan semuanya di sini;  ini adalah metode bootstrap untuk konstanta yang dihitung secara dinamis. </p><br><p>  Fitur ini memerlukan perubahan pada JVMS, khususnya, dalam cara menggunakan kode byte khusus dan bagian 4.4 dari Constant Pool. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 315: Tingkatkan Aarch64 Intrinsics</a></strong> </p><br><p>  Ini adalah JEP yang disumbangkan oleh Red Hat.  JVM sekarang dapat menggunakan instruksi khusus yang tersedia di set perintah Arm 64. Secara khusus, ini meningkatkan operasi metode sin (), cos (), dan log () dari kelas java.lang.Math. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 318: Pengumpul Sampah Epsilon</a></strong> </p><br><p>  Red Hat juga berkontribusi pada JEP ini.  Pengumpul sampah Epsilon agak tidak biasa karena tidak mengumpulkan sampah!  Ini akan mengalokasikan memori baru jika perlu saat membuat objek baru, tetapi tidak membebaskan ruang yang ditempati oleh objek tanpa tautan. </p><br><p>  Jadi, apa gunanya?  Setidaknya ada dua kegunaan: </p><br><ul><li>  Pertama-tama, kolektor ini dirancang untuk memastikan bahwa algoritma GC baru dievaluasi dalam hal dampaknya terhadap kinerja.  Idenya adalah menjalankan contoh aplikasi dengan Epsilon GC dan menghasilkan metrik.  Algoritma GC baru dimasukkan, tes yang sama dijalankan dan hasilnya dibandingkan. </li><li>  Untuk tugas yang sangat singkat atau berumur pendek (pikirkan fungsi serverless di cloud), di mana Anda dapat memastikan bahwa Anda tidak melebihi memori yang dialokasikan untuk menumpuk ruang.  Ini dapat meningkatkan kinerja dengan menghilangkan overhead (termasuk mengumpulkan statistik yang diperlukan untuk memutuskan apakah akan menjalankan collector) dalam kode aplikasi. </li></ul><br><p>  Jika ruang tumpukan habis, operasi JVM selanjutnya dapat dikonfigurasi dalam salah satu dari tiga cara: </p><br><ul><li>  OutOfMemoryError biasa disebut. </li><li>  Reset Heap </li><li>  Sulit menghentikan JVM dan mungkin melakukan tugas eksternal (misalnya, memulai debugger). </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>JEP 324: Perjanjian Utama dengan Curve25519 dan Curve448</strong></a> </p><br><p>  Standar kriptografi terus berubah dan membaik.  Dalam hal ini, skema Diffie-Hellman yang ada dengan kurva elips digantikan oleh Curve25519 dan Curve448.  Ini adalah skema perjanjian utama yang ditentukan dalam RFC-7748. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>JEP 327: Unicode 10</strong></a> </p><br><p>  Platform Java mendukung Unicode untuk memungkinkan pemrosesan semua set karakter.  Karena Unicode telah diperbarui ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi 10</a> , JDK juga telah diperbarui untuk mendukung versi standar ini. </p><br><p>  Saya selalu tertarik untuk melihat apa yang dimasukkan pengembang Unicode dalam versi baru.  Unicode 10 memiliki 8.518 karakter baru.  Ini termasuk simbol Bitcoin, rangkaian karakter Nüshu (digunakan oleh wanita Cina untuk menulis puisi), dan Soyombo dan Zanabazar Square (adalah karakter yang digunakan dalam teks historis Buddha untuk menulis bahasa Sanskerta, Tibet, dan Mongolia).  Banyak Emoji lain juga telah ditambahkan, termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Colbert Emoji yang</a> telah lama ditunggu-tunggu. </p><br><p>  Ingat, dimulai dengan JDK 9, Anda dapat menggunakan UTF-8 dalam file properti (.properties).  Ini berarti bahwa setiap karakter Unicode dapat digunakan dalam file tersebut.  Termasuk Emoji.  Atau Nüshu. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>JEP 328: Perekam Penerbangan</strong></a> </p><br><p> Flight Recorder —       JVM.  JDK 11        Oracle JDK. ,  Oracle     Oracle JDK  OpenJDK,      OpenJDK. </p><br><p> JEP    : </p><br><ul><li>  API        </li><li>        </li><li>      </li><li>    , JVM HotSpot   JDK </li></ul><br><p>      : jdk.jfr  jdk.management.jfr. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>JEP 329: ChaCha20 and Poly1305 Cryptographic Algorithms</strong></a> </p><br><p>  JEP 324,   ,  JDK.   ChaCha20  ChaCha20-Poly1305,    RFC 7539. ChaCha20 —     ,    ,    RC4. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>JEP 331: Low-overhead Heap Profiling</strong></a> </p><br><p>  ,   JEP,   Google.          Java  JVM. </p><br><p>  : </p><br><ul><li>    ,       </li><li>       </li><li>     </li><li>        ( ,     GC   VM) </li><li>         Java. </li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>JEP 332: Transport Layer Security (TLS) 1.3</strong></a> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TLS 1.3 (RFC 8446)</a>  " "  TLS            . JDK   ,      Datagram Transport Layer Security (DTLS). </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>JEP 333: ZGC A Scalable, Low Latency Garbage Collector</strong></a> </p><br><p>     ,     ,     ()    .      (  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Weak Generational Hypothesis</a> )    (  )  GC   .     ""  ,            .           . </p><br><p> ZGC — region-based (  G1), NUMA aware  compacting  .      . </p><br><p>     pauseless     ,      C4   Zing JVM. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>JEP 335: Deprecate the Nashorn Scripting Engine</strong></a> </p><br><p> Nashorn    JDK 8     Rhino Javascript .    ,   Nashorn   API  jjs     Java.   ,   .     Graal VM   ,     ,  . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>JEP 336: Deprecate the Pack200 Tools and APIs</strong></a> </p><br><p> Pack200 —     JAR-,     Java SE 5.0.   JPMS  JDK 9 Pack200       JDK.  pack200  unpack200  API Pack200  java.util.jar          JDK.   ,  . </p><br><h3 id="vyvody">  Kesimpulan </h3><br><p> JDK 11 —   LTS JDK (       ).   ,  ,   ,   ,  JVM   ,        . </p><br><p> Zulu  JDK 11  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>   ! </p><br><p>         JDK 11? </p><br><p> ( <em>. : ,         </em> ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424683/">https://habr.com/ru/post/id424683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424673/index.html">CLRium # 4: .NET Community Meeting</a></li>
<li><a href="../id424675/index.html">Apa yang terjadi di ritel</a></li>
<li><a href="../id424677/index.html">Sejarah singkat tombol angka</a></li>
<li><a href="../id424679/index.html">Memperbaiki esensi periferal komputer</a></li>
<li><a href="../id424681/index.html">Oktober Intisari Acara TI (Bagian Satu)</a></li>
<li><a href="../id424685/index.html">Komisi Sekuritas dan Bursa AS mengajukan gugatan terhadap kepala Tesla Elon Musk, termasuk karena penipuan</a></li>
<li><a href="../id424687/index.html">Ini adalah lebah yang tepat: adaptasi mekanis terhadap efek dinamis</a></li>
<li><a href="../id424689/index.html">Kontrol situasi membuat Anda bahagia.</a></li>
<li><a href="../id424691/index.html">Kami mengundang Anda ke konferensi Azov Developers Meetup 2018 - 13 Oktober di Taganrog</a></li>
<li><a href="../id424693/index.html">Menambahkan tanda air ke semua gambar situs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>