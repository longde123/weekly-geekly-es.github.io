<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌰 📊 ♣️ Siklus Pengujian Reaksi Penuh. Laporan Auto.ru 👻 😢 🥐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Keinginan untuk menjauh dari pengujian regresi manual adalah alasan bagus untuk memperkenalkan autotest. Pertanyaannya adalah yang mana? Pengembang an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Siklus Pengujian Reaksi Penuh. Laporan Auto.ru</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/459924/"> Keinginan untuk menjauh dari pengujian regresi manual adalah alasan bagus untuk memperkenalkan autotest.  Pertanyaannya adalah yang mana?  Pengembang antarmuka Natalya Stus dan Alexei Androsov mengingat bagaimana tim mereka melewati beberapa iterasi dan membangun pengujian frontend di Auto.ru berdasarkan Jest dan Puppeteer: tes unit, tes untuk masing-masing komponen Bereaksi, tes integrasi.  Yang paling menarik dari pengalaman ini adalah pengujian terisolasi komponen-React di browser tanpa Selenium Grid, Java, dan hal-hal lainnya. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/yr/np/zo/yrnpzon4-5momllzoy0bg1zz-ie.jpeg"></a> <br><br>  Alexey: <br>  - Pertama, Anda perlu memberi tahu sedikit apa itu Berita Otomotif.  Ini adalah situs yang menjual mobil.  Ada pencarian, akun pribadi, layanan mobil, suku cadang, ulasan, dealer dan banyak lagi.  Auto.ru adalah proyek yang sangat besar, banyak kode.  Kami menulis semua kode dalam monorepe besar, karena semuanya tercampur.  Orang yang sama melakukan tugas serupa, misalnya, untuk seluler dan desktop.  Ternyata banyak kode, dan monorepa sangat penting bagi kami.  Pertanyaannya adalah bagaimana cara mengujinya? <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/vn/qv/qf/vnqvqfbci0v-wlfceczgd5snhgi.jpeg"><br><br>  Kami memiliki Bereaksi dan Node.js, yang melakukan rendering sisi server dan meminta data dari backend.  Potongan-potongan yang tersisa dan kecil di BEM. <br><br><img src="https://habrastorage.org/webt/xb/1p/_b/xb1p_b-9j8huy-rle317mtp5sjc.jpeg"><br><br>  Natalya: <br>  - Kami mulai berpikir ke arah otomatisasi.  Siklus rilis aplikasi individual kami mencakup beberapa langkah.  Pertama, fitur ini dikembangkan oleh programmer di cabang terpisah.  Setelah itu, di cabang terpisah yang sama, fitur diuji oleh penguji manual.  Jika semuanya baik-baik saja, tugas jatuh ke kandidat pelepasan.  Jika tidak, maka kembali ke iterasi pengembangan lagi, tes lagi.  Sampai penguji mengatakan bahwa semuanya baik-baik saja dalam fitur ini, itu tidak akan jatuh ke kandidat rilis. <br><br>  Setelah mengumpulkan kandidat rilis, ada regresi manual - tidak hanya Auto.ru, tetapi hanya paket yang akan kami roll.  Misalnya, jika kita akan memutar web desktop, maka ada regresi manual dari web desktop.  Ini adalah banyak kasus uji manual.  Regresi seperti itu memakan waktu sekitar satu hari kerja dari satu penguji manual. <br><br>  Ketika regresi selesai, rilis terjadi.  Setelah itu, cabang rilis bergabung ke master.  Pada titik ini, kita bisa menyuntikkan kode master, yang kami uji hanya untuk web desktop, dan kode ini dapat merusak web seluler, misalnya.  Ini tidak diperiksa segera, tetapi hanya pada regresi manual berikutnya - web seluler. <br><br><img src="https://habrastorage.org/webt/uc/pp/f6/ucppf6mqcfn6rcjayzc7mzgzzwe.jpeg"><br><br>  Secara alami, tempat paling menyakitkan dalam proses ini adalah regresi manual, yang memakan waktu sangat lama.  Semua penguji manual, secara alami, lelah melakukan hal yang sama setiap hari.  Karena itu, kami memutuskan untuk mengotomatiskan semuanya.  Solusi pertama yang dieksekusi adalah tes mandiri Selenium dan Java, yang ditulis oleh tim terpisah.  Ini adalah tes ujung ke ujung, e2e, yang menguji seluruh aplikasi.  Mereka menulis sekitar 5 ribu tes semacam itu.  Apa yang akhirnya kita lakukan? <br><br>  Secara alami, kami mempercepat regresi.  Tes otomatis lulus jauh lebih cepat daripada penguji manual, sekitar 10 kali lebih cepat hasilnya.  Dengan demikian, tindakan rutin yang mereka lakukan setiap hari dihapus dari penguji manual.  Bug yang ditemukan dari autotest lebih mudah direproduksi.  Mulai ulang tes ini atau lihat langkah-langkahnya - tidak seperti penguji manual, yang akan berkata: "Saya mengklik sesuatu dan semuanya rusak." <br><br>  Memberikan stabilitas lapisan.  Kami selalu menjalankan uji coba yang sama - berbeda, sekali lagi, dari pengujian manual, ketika tester dapat mempertimbangkan bahwa kami tidak menyentuh tempat ini, dan saya tidak akan memeriksanya kali ini.  Kami menambahkan pengujian untuk membandingkan tangkapan layar, meningkatkan akurasi pengujian UI - sekarang kami memeriksa perbedaan dalam beberapa piksel yang tidak akan dilihat oleh penguji dengan matanya.  Semua berkat tes tangkapan layar. <br><br>  Tapi ada kontra.  Yang terbesar - untuk pengujian e2e kita membutuhkan lingkungan pengujian yang sepenuhnya konsisten dengan produk.  Itu harus selalu diperbarui dan operasional.  Ini membutuhkan kekuatan yang hampir sama banyaknya dengan dukungan stabilitas penjualan.  Secara alami, kita tidak selalu mampu membelinya.  Oleh karena itu, kami sering mengalami situasi di mana lingkungan pengujian terletak atau di suatu tempat ada sesuatu yang rusak, dan pengujian gagal, meskipun tidak ada masalah di paket paling depan. <br><br>  Tes-tes ini juga sedang dikembangkan oleh tim terpisah, yang memiliki tugasnya sendiri, gilirannya sendiri dalam pelacak tugas, dan fitur-fitur baru ditutupi dengan beberapa penundaan.  Mereka tidak dapat datang segera setelah rilis fitur baru dan segera menulis tanda kutip di atasnya.  Karena tes mahal dan sulit untuk menulis dan memelihara, kami tidak mencakup semua skenario dengan mereka, tetapi hanya yang paling kritis.  Pada saat yang sama, sebuah tim yang terpisah diperlukan, dan ia akan memiliki alat yang terpisah, infrastruktur yang terpisah, semua miliknya sendiri.  Dan analisis tes jatuh juga merupakan tugas yang tidak sepele untuk penguji manual atau untuk pengembang.  Saya akan menunjukkan beberapa contoh. <br><br><img src="https://habrastorage.org/webt/gn/ix/c6/gnixc6p8h1phrdhcjlosttb0ai8.jpeg"><br><br>  Kami telah menjalankan tes.  500 tes berlalu, beberapa jatuh.  Kita bisa melihat hal seperti itu di laporan.  Di sini tes tidak dimulai, dan tidak jelas apakah semuanya baik di sana atau tidak. <br><br><img src="https://habrastorage.org/webt/40/70/6p/40706pwn5i1vfzfpl4ekmfhpeom.jpeg"><br><br>  Contoh lain - tes dimulai, tetapi jatuh dengan kesalahan seperti itu.  Dia tidak dapat menemukan elemen di halaman, tetapi mengapa - kita tidak tahu.  Entah elemen ini tidak muncul, atau ternyata berada di halaman yang salah, atau pelacak berubah.  Yang Anda butuhkan untuk pergi dan debazh tangan. <br><br><img src="https://habrastorage.org/webt/vh/_f/xd/vh_fxdrktlr3llkbrcloced22ks.jpeg"><br><br>  Tes tangkapan layar juga tidak selalu memberi kita akurasi yang baik.  Di sini kita memuat beberapa jenis kartu, kartu itu sedikit bergerak, tes kami telah jatuh. <br><br><img src="https://habrastorage.org/webt/_r/1y/dm/_r1ydm4pdscdlxgdse5focstyje.jpeg"><br><br>  Kami mencoba memecahkan sejumlah masalah ini.  Kami mulai menjalankan bagian dari tes pada prod - tes yang tidak memengaruhi data pengguna tidak mengubah apa pun dalam database.  Artinya, kami di prod membuat mesin terpisah yang melihat ke lingkungan prod.  Kami baru saja menginstal paket frontend baru dan menjalankan tes di sana.  Produk setidaknya stabil. <br><br>  Kami mentransfer beberapa tes ke mokeys, tetapi kami memiliki banyak backend yang berbeda, API yang berbeda, dan mengunci semuanya adalah tugas yang sangat sulit, terutama untuk 5 ribu tes.  Untuk ini, layanan khusus yang disebut mockritsa ditulis, ini membantu membuat mokas yang diperlukan untuk frontend cukup mudah dan cukup mudah untuk mem-proxy-nya. <br><br>  Kami juga harus membeli seterika agar kisi-kisi Selenium kami yang darinya pengujian ini diluncurkan lebih besar sehingga tidak akan jatuh, karena mereka tidak dapat menaikkan peramban, dan karenanya, akan berjalan lebih cepat.  Bahkan setelah kami mencoba menyelesaikan masalah ini, kami masih sampai pada kesimpulan bahwa tes seperti itu tidak cocok untuk CI, mereka membutuhkan waktu yang sangat lama.  Kami tidak dapat menjalankannya pada setiap permintaan kumpulan.  Kami hanya tidak pernah dalam hidup kami nanti akan menganalisis laporan ini, yang akan dihasilkan untuk setiap permintaan kumpulan. <br><br><img src="https://habrastorage.org/webt/od/0z/rl/od0zrladzvsshl04e52vipgtcvo.jpeg"><br><br>  Oleh karena itu, untuk CI, kita memerlukan tes cepat dan stabil yang tidak akan gagal karena beberapa alasan acak.  Kami ingin menjalankan tes untuk permintaan kumpulan tanpa dudukan uji, backend, database, tanpa kasus pengguna yang rumit. <br><br>  Kami ingin tes-tes ini ditulis bersamaan dengan kode, dan bahwa hasil tes segera memperjelas jika ada masalah. <br><br>  Alexey: <br>  - Ya, dan kami memutuskan untuk mencoba semua yang kami inginkan, untuk meluruskan semuanya dari awal hingga akhir dalam infrastruktur Jest yang sama.  Mengapa kami memilih Jest?  Kami sudah menulis unit test pada Jest, kami menyukainya.  Ini adalah alat populer yang didukung, ia sudah memiliki banyak integrasi yang sudah jadi di sana: Bereaksi tes render, Enzyme.  Semuanya berfungsi di luar kotak, tidak ada yang perlu dibangun, semuanya sederhana. <br><br><img src="https://habrastorage.org/webt/js/bo/sa/jsbosapwtytq_x6a8zkvxl6gdv0.jpeg"><br><br>  Dan Jest secara pribadi menang untuk saya dalam hal itu, tidak seperti moka apa pun, sulit untuk menembakkan efek samping dari semacam tes pihak ketiga di kaki Anda jika saya lupa membersihkannya atau yang lainnya.  Dalam moka, ini dilakukan sekali atau dua kali, tetapi di Jest sulit untuk melakukannya: itu terus diluncurkan di utas terpisah.  Itu mungkin, tetapi sulit.  Dan untuk e2e yang dirilis Puppeteer, kami juga memutuskan untuk mencobanya.  Itu yang kita dapat. <br><br><img src="https://habrastorage.org/webt/ab/ph/oa/abphoap_rzksxw_spwh4t_0nfra.jpeg"><br><br>  Natalya: <br>  "Aku juga akan mulai dengan contoh unit test."  Ketika kami menulis tes hanya untuk beberapa fungsi, tidak ada masalah khusus.  Kami menyebut fungsi ini, memberikan beberapa argumen, membandingkan apa yang terjadi dengan apa yang seharusnya terjadi. <br><br>  Jika kita berbicara tentang komponen-React, maka semuanya menjadi sedikit lebih rumit.  Kita perlu membuat mereka entah bagaimana.  Ada penyaji uji Bereaksi, tetapi tidak terlalu nyaman untuk uji unit, karena tidak akan memungkinkan kami untuk menguji komponen secara terpisah.  Ini akan membuat komponen sepenuhnya ke ujung, ke tata letak. <br><br>  Dan saya ingin menunjukkan bagaimana dengan Enzim dimungkinkan untuk menulis unit test untuk komponen Bereaksi menggunakan contoh komponen seperti itu di mana kita memiliki MyComponent tertentu.  Dia mendapat semacam penyangga, dia punya semacam logika.  Lalu dia mengembalikan komponen Foo, yang, pada gilirannya, akan mengembalikan komponen bar, yang sudah di komponen bar kembali kepada kita, pada kenyataannya, tata letak. <br><br><img src="https://habrastorage.org/webt/h2/1e/e6/h21ee6qkeeucwkgnvye6ewsgxog.jpeg"><br><br>  Kita dapat menggunakan alat Enzyme seperti rendering dangkal.  Inilah yang kita butuhkan untuk menguji komponen MyComponent secara terpisah.  Dan tes-tes ini tidak akan tergantung pada komponen apa yang akan terkandung di dalamnya.  Kami hanya akan menguji logika komponen MyComponent. <br><br>  Jest memiliki sesuatu yang disebut Snapshot, dan mereka juga dapat membantu kita di sini.  “Expect something toMatchSnapshot” akan membuat struktur seperti itu bagi kami, hanya file teks yang menyimpan, pada kenyataannya, apa yang kami lewati untuk diharapkan, apa yang terjadi, dan ketika tes ini dijalankan untuk pertama kalinya, file ini ditulis.  Dengan menjalankan tes lebih lanjut, apa yang diperoleh akan dibandingkan dengan standar yang terkandung dalam file MyComponent.test.js.snap. <br><br>  Di sini kita melihat bahwa keseluruhan render, mengembalikan persis apa yang dirender metode dari MyComponent, dan apa foo, secara umum, tidak peduli.  Kita dapat menulis dua tes seperti itu untuk dua kasus kita, untuk dua kasus kita untuk komponen MyComponent. <br><br><img src="https://habrastorage.org/webt/wu/b3/iw/wub3iwlwsatz7ytgzpeim8vsbqs.jpeg"><br><br>  Pada prinsipnya, kita dapat menguji hal yang sama tanpa Snapshot, cukup memeriksa skrip yang kita butuhkan, misalnya, memeriksa prop mana yang diteruskan ke komponen foo.  Tetapi pendekatan ini memiliki satu minus.  Jika kami menambahkan beberapa elemen lain ke MyComponent, pengujian baru kami, ini tidak akan ditampilkan dengan cara apa pun. <br><br><img src="https://habrastorage.org/webt/pd/9e/vy/pd9evyrhuh7kfzrqcukvwpbudaq.jpeg"><br><br>  Karena itu, bagaimanapun juga, tes Snapshot adalah tes yang akan menunjukkan kepada kita hampir semua perubahan di dalam komponen.  Tetapi jika kita menulis kedua tes pada Snapshot, dan kemudian kita membuat perubahan yang sama pada komponen, maka kita akan melihat bahwa kedua tes akan jatuh.  Pada prinsipnya, hasil tes jatuh ini akan memberi tahu kita tentang hal yang sama, bahwa kita menambahkan semacam "halo" di sana. <br><br><img src="https://habrastorage.org/webt/gv/c1/dc/gvc1dcwq9aw2m3owq6c-esulpsg.jpeg"><br><br>  Dan ini juga berlebihan, oleh karena itu, saya percaya bahwa lebih baik menggunakan satu tes Snapshot untuk struktur yang sama.  Periksa sisa logikanya dengan cara yang berbeda, tanpa Snapshot, karena Snapshot, mereka tidak terlalu indikatif.  Ketika Anda melihat Snapshot, Anda baru saja melihat bahwa sesuatu telah dirender, tetapi tidak jelas logika mana yang Anda uji di sini.  Ini sama sekali tidak cocok untuk TDD jika Anda ingin menggunakannya.  Dan itu tidak akan berfungsi seperti dokumentasi.  Maka, ketika Anda melihat komponen ini, Anda akan melihat bahwa ya, Snapshot berhubungan dengan sesuatu, tetapi jenis logika apa yang ada di sana tidak begitu jelas. <br><br><img src="https://habrastorage.org/webt/wa/yc/ia/wayciagk2zoa51amkq8bb9xcqic.jpeg"><br><br><img src="https://habrastorage.org/webt/zk/mj/sa/zkmjsaoqa-34pqk2flku7_n7nsy.jpeg"><br><br>  Dengan cara yang sama, kami akan menulis unit test pada komponen foo, pada komponen bar, misalnya, Snapshot. <br><br><img src="https://habrastorage.org/webt/bg/eu/lk/bgeulklgkyqg-woog9tkqhkkpco.jpeg"><br><br>  Kami mendapatkan cakupan 100% untuk ketiga komponen ini.  Kami percaya bahwa kami telah memeriksa semuanya, kami selesai dengan baik. <br><br>  Tetapi katakanlah kita mengubah sesuatu di komponen bar, menambahkan beberapa prop baru ke dalamnya, dan kami memiliki tes untuk komponen bar, jelas.  Kami mengoreksi tes, dan ketiga tes lulus bersama kami. <br><br><img src="https://habrastorage.org/webt/4i/pe/xc/4ipexciijx7ss998ugl84hr6smi.jpeg"><br><br>  Tetapi pada kenyataannya, jika kita mengumpulkan seluruh cerita ini, maka tidak ada yang akan berhasil, karena MyComponent tidak akan menyatu dengan kesalahan seperti itu.  Kami tidak benar-benar melewati prop yang diharapkan ke komponen bar.  Oleh karena itu, kita berbicara tentang fakta bahwa dalam kasus ini kita juga memerlukan tes integrasi yang akan memeriksa, termasuk apakah kita memanggil komponen anaknya dengan benar dari komponen kita. <br><br><img src="https://habrastorage.org/webt/8e/aa/zk/8eaazkltwuurjeh7fhef39ovblq.jpeg"><br><br>  Memiliki komponen seperti itu dan mengubah salah satunya, Anda segera melihat perubahan apa yang terjadi pada komponen ini. <br><br>  Peluang apa yang kami miliki di Enzim untuk melakukan pengujian integrasi?  Render dangkal itu sendiri mengembalikan struktur seperti itu.  Ini memiliki metode menyelam di dalamnya, jika dipanggil pada beberapa komponen Bereaksi, itu akan gagal di dalamnya.  Dengan demikian, dengan menyebutnya pada komponen foo, kita mendapatkan apa yang dirender komponen foo, ini adalah bar, jika kita melakukan penyelaman lagi, kita akan mendapatkan, pada kenyataannya, tata letak yang dikembalikan komponen bar kepada kita.  Ini hanya akan menjadi tes integrasi. <br><br><img src="https://habrastorage.org/webt/oo/jm/af/oojmafj91rsbbpprnhyqf868qoy.jpeg"><br><br>  Atau Anda dapat merender semuanya sekaligus menggunakan metode mount, yang mengimplementasikan render DOM penuh.  Tapi saya tidak menyarankan melakukan ini, karena itu akan menjadi Snapshot yang sangat sulit.  Dan, sebagai aturan, Anda tidak perlu memeriksa seluruh struktur sepenuhnya.  Anda hanya perlu memeriksa integrasi antara komponen induk dan anak dalam setiap kasus. <br><br><img src="https://habrastorage.org/webt/q9/ud/i-/q9udi-03qar0hjqhxe6th8an6zc.jpeg"><br><br>  Dan untuk MyComponent kami menambahkan tes integrasi, jadi pada tes pertama saya menambahkan hanya menyelam, dan ternyata kami menguji tidak hanya logika komponen itu sendiri, tetapi juga integrasi dengan komponen foo.  Hal yang sama, kami menambahkan tes integrasi untuk komponen foo yang benar memanggil komponen bar, dan kemudian kami memeriksa seluruh rantai ini, dan kami yakin bahwa tidak ada perubahan yang akan menghancurkan kami, pada kenyataannya, rendering dari MyComponent <br><br><img src="https://habrastorage.org/webt/ff/zu/fq/ffzufq_vcw5lmuygnztd0lycvao.jpeg"><br><br>  Contoh lain, sudah dari proyek nyata.  Secara singkat tentang apa lagi yang bisa dilakukan Jest dan Enzim.  Jest bisa melakukan moki.  Anda dapat, jika Anda menggunakan beberapa fungsi eksternal dalam komponen Anda, Anda dapat menguncinya.  Misalnya, dalam contoh ini, kami memanggil beberapa jenis api, kami tentu saja tidak ingin masuk ke api apa pun di unit test, jadi kami hanya menghapus fungsi getResource dengan beberapa objek jest.fn.  Bahkan, fungsi tiruannya.  Kemudian kita dapat memeriksa apakah itu dipanggil atau tidak, berapa kali dipanggil, dengan argumen apa.  Semua ini memungkinkan Anda untuk melakukan Jest. <br><br><img src="https://habrastorage.org/webt/z8/lb/ap/z8lbapgq_qzer-1vz3yazx9wo-o.jpeg"><br><br>  Dalam rendering dangkal, Anda bisa meneruskan store ke komponen.  Jika Anda membutuhkan toko, Anda bisa memindahkannya ke sana, dan itu akan berhasil. <br><br><img src="https://habrastorage.org/webt/y2/tl/ih/y2tlihjjqqwogsbftvcirxe_njc.jpeg"><br><br>  Anda juga dapat mengubah Status dan penyangga dalam komponen yang sudah dirender. <br><br><img src="https://habrastorage.org/webt/ew/8g/hc/ew8ghcc6gtv3347yt8ik6o9v6s4.jpeg"><br><br>  Anda dapat memanggil metode simulasi pada beberapa komponen.  Itu hanya memanggil pawang.  Misalnya, jika Anda mensimulasikan klik, itu akan memanggil onClick untuk komponen tombol di sini.  Semua ini dapat dibaca, tentu saja, dalam dokumentasi tentang Enzim, banyak potongan berguna.  Ini hanya beberapa contoh dari proyek nyata. <br><br><img src="https://habrastorage.org/webt/tw/kn/9t/twkn9txihstmq5pdpc9yqgc1nnw.jpeg"><br><br>  Alexey: <br>  - Kami sampai pada pertanyaan yang paling menarik.  Kita dapat menguji Jest, kita dapat menulis unit test, memeriksa komponen, memeriksa elemen mana yang merespons klik dengan tidak benar.  Kami dapat memeriksa html mereka.  Sekarang kita perlu memeriksa tata letak komponen, css. <br><br><img src="https://habrastorage.org/webt/fw/dj/8p/fwdj8pbfn6ywa4he7ejwjnq6hs4.jpeg"><br><br>  Dan disarankan untuk melakukan ini sehingga prinsip pengujian tidak berbeda dengan yang saya jelaskan sebelumnya.  Jika saya memeriksa html, maka saya menelepon rendering dangkal, butuh dan memberikan html kepada saya.  Saya ingin memeriksa css, panggil saja semacam render dan periksa - tanpa mengangkat apa pun, tanpa menyiapkan alat apa pun. <br><br><img src="https://habrastorage.org/webt/mz/u-/p2/mzu-p2y3eiblryntol0eelzghtc.jpeg"><br><br>  Saya mulai mencarinya, dan hampir di mana-mana jawaban yang sama diberikan untuk semua yang disebut Puppeteer, atau grid Selenium.  Anda membuka beberapa tab, Anda pergi ke html halaman, mengambil screenshot dan membandingkannya dengan opsi sebelumnya.  Jika belum berubah, maka semuanya baik-baik saja. <br><br>  Pertanyaannya adalah, apa itu html halaman jika saya hanya ingin memeriksa satu komponen secara terpisah?  Diinginkan - dalam kondisi yang berbeda. <br><br><img src="https://habrastorage.org/webt/w2/t0/vn/w2t0vni_fdskrtopftgiigmxows.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sub></sup> </h5><br>  Saya tidak ingin menulis banyak html halaman ini untuk setiap komponen, untuk setiap negara.  Avito berjalan dengan baik.  Roma Dvornov menerbitkan sebuah artikel tentang Habré, dan dia, dengan cara, berpidato.  Apa yang mereka lakukan  Mereka mengambil komponen, merakit html melalui render standar.  Kemudian dengan bantuan plugin dan segala macam trik mereka mengumpulkan semua aset yang mereka miliki - gambar, css.  Masukkan semuanya ke dalam html, dan mereka hanya mendapatkan html yang tepat. <br><br><img src="https://habrastorage.org/webt/0j/yr/zk/0jyrzkzvwzebsx36hos2vvi1uvs.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sub></sup> </h5><br>  Dan kemudian mereka mengangkat server khusus, mengirim html di sana, menjadikannya, dan mengembalikan beberapa hasil.  Artikel yang sangat menarik, baca, namun, Anda dapat menarik banyak ide menarik dari sana. <br><br><img src="https://habrastorage.org/webt/z5/xp/gb/z5xpgbasgyr6gooqi_dt-p4_mxw.jpeg"><br><br>  Apa yang saya tidak suka di sana.  Merakit komponen berbeda dari cara kerjanya menuju produksi.  Sebagai contoh, kami memiliki webpack, dan di sana ia akan dikumpulkan oleh beberapa jenis aset babel, itu ditarik secara berbeda di sana.  Saya tidak dapat menjamin bahwa saya menguji apa yang akan saya unduh sekarang. <br><br>  Dan lagi, layanan terpisah untuk tangkapan layar.  Saya ingin melakukannya dengan lebih mudah.  Dan ternyata, ada ide bahwa, mari kita kumpulkan persis sama seperti yang akan kita kumpulkan.  Dan cobalah untuk menggunakan sesuatu seperti Docker, karena itu adalah hal seperti itu, dapat diletakkan di komputer, secara lokal, itu akan menjadi sederhana, terisolasi, tidak menyentuh apa pun, semuanya baik-baik saja. <br><br><img src="https://habrastorage.org/webt/9k/nz/hm/9knzhmk3-qivjt6peujxtmjnovw.jpeg"><br><br>  Tapi masalah ini adalah dengan html halaman, tetap sama seperti apa sebenarnya.  Dan sebuah ide lahir.  Anda memiliki webpack.conf yang disederhanakan, dan darinya ada beberapa EntryPoint untuk klien js.  Modul-modul tersebut dijelaskan, cara merakitnya, file output, semua plugin yang telah Anda jelaskan, semuanya sudah dikonfigurasi, semuanya baik-baik saja. <br><br><img src="https://habrastorage.org/webt/3f/km/ha/3fkmhal86lf6s38oq8rnnhchsdg.jpeg"><br><br>  Bagaimana jika saya suka ini?  Dia akan masuk ke komponen saya dan mengumpulkannya secara terpisah.  Dan akan ada tepat satu komponen.  Jika saya menambahkan html webpack di sana, itu juga akan memberi saya html, dan aset ini akan dikumpulkan di sana, dan hal ini, bagaimanapun, sudah dapat diuji secara otomatis. <br><br>  Dan saya akan menulis semua ini, tetapi kemudian saya menemukan ini. <br><br><img src="https://habrastorage.org/webt/hq/ju/0s/hqju0sbemjp1z3ryufas0pk0tfu.jpeg"><br><br>  Jest-puppeteer-React, sebuah plugin muda.  Dan saya mulai aktif berkontribusi untuk itu.  Jika Anda tiba-tiba ingin mencobanya, Anda dapat, misalnya, datang kepada saya, entah bagaimana saya dapat membantu.  Sebenarnya, proyek itu bukan milikku. <br><br>  Anda menulis file biasa sebagai test.js, dan file-file ini perlu ditulis sedikit secara terpisah untuk membantu menemukannya, agar tidak mengkompilasi seluruh proyek untuk Anda, tetapi untuk mengkompilasi hanya komponen yang diperlukan.  Bahkan, Anda mengambil konfigurasi webpack.  Dan titik input berubah ke file browser.js ini, yaitu, persis apa yang ingin kami uji akan dikemas dalam html, dan dengan bantuan Puppeteer itu akan membawa Anda tangkapan layar. <br><br><img src="https://habrastorage.org/webt/3e/jh/fr/3ejhfrfte3ucybs-vvl6ncw28vo.jpeg"><br><br>  Apa yang bisa dia lakukan?    ,         jest-image-snapshot.    .     ,     ,  js,   media-query, ,  . <br><br>    headless-,  ,    ,  ,   ,  headless-,     Chrome   .  web-,    , , ,   . <br><br>       Docker.          .  .  ,  Docker,  .   .  Docker     ,         , ,     Linux,   -   ,      -  .  Docker   ,            . <br><br><img src="https://habrastorage.org/webt/gt/26/zc/gt26zcwy-madcquchbm37l89lwo.jpeg"><br><br>      ?   ,       . ,  .    before-after,     ,  .   ,    .   ,         Chrome,       Firefox.    . <br><br>       .    pixelmatch.  ,   looksame,    «»,    .   ,         . <br><br><img src="https://habrastorage.org/webt/ep/zg/ov/epzgovfoqseh2bj5r7jcr8z0lr0.jpeg"><br><br>  —   .   ,  ,     .  ,    :    - ,             —    Enzyme.      Redux   store .  .    viewport,  ,      .   , ,     . <br><br><img src="https://habrastorage.org/webt/ln/wh/qu/lnwhqusfy-4mqef59zw0lmnoaus.jpeg"><br><br>      .  ,   .  ?     ,     . <br><br><img src="https://habrastorage.org/webt/ut/l6/xb/utl6xb7objmhjnhozdlamgwzjyk.jpeg"><br><br>   :       5-10        . Selenium    .    ,  , ,           .        . <br><br><img src="https://habrastorage.org/webt/md/qr/rf/mdqrrf6ueg73uu25m6wqfihyo3q.jpeg"><br><br>      Puppeteer,    e2e-.      ,          e2e- —   ,    Selenium. <br><br> : <br> — ,         Selenium Java ,    .     - JS   Puppeteer,    ,         . <br><br>     ,       .     ,           ,    . <br><br><img src="https://habrastorage.org/webt/0s/7u/ns/0s7uns7oaxi3dcwuejuhk5kwuoy.jpeg"><br><br>   —  Selenium  Java,   —  JS Puppeteer.   .   18  .          ,   ,    Java.  ,           ,       Java  Selenium. <br><br><img src="https://habrastorage.org/webt/kk/us/pj/kkuspjg5dwwz6h2tuhkwfkssth0.jpeg"><br><br> : <br> —     ?       .    , html-,    css   .   e2e. .  ,       . <br><br><img src="https://habrastorage.org/webt/sj/wg/58/sjwg58se3lov3vvrskvjjh2pw90.jpeg"><br><br>     ,    ,  .        . ,   , —  , .        ,     . -    , ,      :     ,     . <br><br>   ,         ,     .     git hook,  -,      .    green master —   ,   ,  ,      .  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459924/">https://habr.com/ru/post/id459924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459906/index.html">Tic Tac Toe, bagian 3: Undo / Redo dengan penyimpanan perintah</a></li>
<li><a href="../id459910/index.html">Situasi: perusahaan tidak terburu-buru untuk mengembangkan layanan untuk asisten suara - apa risikonya</a></li>
<li><a href="../id459914/index.html">SQL Index Manager - alat gratis untuk mendefrag dan mempertahankan indeks</a></li>
<li><a href="../id459918/index.html">Pemecahan masalah dengan pwnable.kr 03 - bof. Buffer overflow pada stack</a></li>
<li><a href="../id459922/index.html">Menghapus kebisingan frekuensi tinggi dari sinyal sensor getaran selama diagnostik getaran bantalan</a></li>
<li><a href="../id459928/index.html">Jalur siswa ke pengembangan aplikasi seluler</a></li>
<li><a href="../id459930/index.html">Otomasi impor Python</a></li>
<li><a href="../id459934/index.html">Intisari materi menarik untuk pengembang ponsel # 306 (pada 8-14 Juli)</a></li>
<li><a href="../id459936/index.html">9 trik lagi untuk bekerja dengan Visual Studio</a></li>
<li><a href="../id459948/index.html">Menerapkan awan volumetrik yang benar secara fisik seperti di Horizon Zero Dawn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>