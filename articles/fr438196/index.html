<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤°ğŸ¼ ğŸ¤¹ğŸ½ â— Si le projet est Â«ThÃ©Ã¢treÂ», utilisez des acteurs ... ğŸ’‡ ğŸ—ï¸ ğŸ”›</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article prÃ©sentera l'expÃ©rience de l'utilisation de l'approche acteur dans un projet intÃ©ressant de systÃ¨me de contrÃ´le automatisÃ© pour un thÃ©Ã¢tre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Si le projet est Â«ThÃ©Ã¢treÂ», utilisez des acteurs ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438196/"><p>  Cet article prÃ©sentera l'expÃ©rience de l'utilisation de l'approche acteur dans un projet intÃ©ressant de systÃ¨me de contrÃ´le automatisÃ© pour un thÃ©Ã¢tre.  C'est exactement l'impression d'utilisation, rien de plus. </p><a name="habracut"></a><br><p>  RÃ©cemment, j'ai pu participer Ã  une tÃ¢che trÃ¨s intÃ©ressante - la modernisation, mais en fait - le dÃ©veloppement d'un nouveau systÃ¨me de contrÃ´le automatisÃ© pour le levage de crÃ©maillÃ¨res pour l'un des thÃ©Ã¢tres. </p><br><p>  Un thÃ©Ã¢tre moderne (s'il est grand) est une organisation assez complexe.  Beaucoup de personnes, d'Ã©quipements et de systÃ¨mes divers y participent.  L'un de ces systÃ¨mes est le systÃ¨me de commande pour Â«monter et descendreÂ» le dÃ©cor sur la scÃ¨ne.  Les spectacles modernes, et plus d'opÃ©ras et de ballets, sont de plus en plus saturÃ©s de moyens techniques chaque annÃ©e.  Il utilise beaucoup de dÃ©cors complexes et leurs mouvements pendant l'action.  Le paysage est activement utilisÃ© dans les plans de mise en scÃ¨ne, Ã©largissant le sens de ce qui se passe et mÃªme Â«jouant votre propre rÃ´le de soutienÂ»).  En gÃ©nÃ©ral, il Ã©tait trÃ¨s intÃ©ressant de se familiariser avec la vie en coulisses du thÃ©Ã¢tre et de dÃ©couvrir ce qui s'y passe pendant les reprÃ©sentations.  AprÃ¨s tout, les spectateurs ordinaires ne voient que ce qui se passe sur scÃ¨ne. </p><br><p>  Mais cet article est encore technique et j'ai voulu y partager l'expÃ©rience de l'utilisation de l'approche acteur pour implÃ©menter la gestion.  Et partagez Ã©galement l'expÃ©rience de l'utilisation de l'un des rares frameworks d'acteurs C ++ - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sobjectizer</a> . </p><br><p>  Pourquoi exactement lui?  Nous le regardons depuis longtemps.  Il y a des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles</a> sur un habr, il a une excellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> dÃ©taillÃ©e avec des exemples.  Le projet est assez mature.  Un rapide coup d'Å“il aux exemples a montrÃ© que les dÃ©veloppeurs opÃ¨rent avec des concepts Â«familiersÂ» (Ã©tats, temporisations, Ã©vÃ©nements), c'est-Ã -dire  on ne s'attendait pas Ã  de gros problÃ¨mes de comprÃ©hension et de maÃ®trise, Ã  utiliser dans notre projet.  Et oui, surtout, les dÃ©veloppeurs sont adÃ©quats et sympathiques, prÃªts Ã  vous aider avec des conseils <del>  (en russe) </del>  .  Nous avons donc dÃ©cidÃ© d'essayer ... </p><br><h2 id="a-chto-delaem">  On fait quoi? </h2><br><p>  Alors, Ã  quoi ressemble notre Â«objet de contrÃ´leÂ»?  Le systÃ¨me d'ascenseurs shtanketovy - c'est 62 shankets (tuyaux mÃ©talliques) sur toute la largeur de la scÃ¨ne accrochÃ©e au-dessus de cette mÃªme scÃ¨ne, environ tous les 30 Ã  40 cm du bord de la scÃ¨ne en profondeur.  Les shankets eux-mÃªmes sont suspendus Ã  des cordes et peuvent monter ou descendre sur la scÃ¨ne (mouvement vertical).  Dans chaque reprÃ©sentation (ou opÃ©ra ou ballet), une partie des strophes est utilisÃ©e pour la dÃ©coration.  Le dÃ©cor y est accrochÃ© et dÃ©placÃ© (si le script l'exige) pendant l'action.  Le mouvement lui-mÃªme est effectuÃ© sur commande des opÃ©rateurs (ils ont des panneaux de commande spÃ©ciaux) en utilisant le systÃ¨me Â«moteur - cÃ¢ble - contrepoidsÂ» (Ã  peu prÃ¨s le mÃªme que les ascenseurs dans les maisons).  Les moteurs sont situÃ©s sur les bords de la scÃ¨ne (sur plusieurs niveaux), de sorte qu'ils ne sont pas visibles pour le spectateur.  Tous les moteurs sont divisÃ©s en 8 groupes et chaque groupe dispose de trois convertisseurs de frÃ©quence (IF).  Dans chaque groupe, trois moteurs peuvent Ãªtre activÃ©s simultanÃ©ment, chacun Ã©tant connectÃ© Ã  son propre onduleur.  Au total, nous avons un systÃ¨me de 62 moteurs et 24 onduleurs que nous devons contrÃ´ler. </p><br><p>  Notre tÃ¢che Ã©tait de dÃ©velopper une interface opÃ©rateur pour gÃ©rer cette Ã©conomie, ainsi que de mettre en Å“uvre des algorithmes de gestion.  Le systÃ¨me comprend trois postes de contrÃ´le.  Deux postes de commande sont situÃ©s directement au-dessus de la scÃ¨ne et un poste est situÃ© dans la salle des machines (oÃ¹ se trouvent les armoires de commande) et est conÃ§u pour surveiller les travaux d'un Ã©lectricien en service.  Dans les armoires de commande, il y a des contrÃ´leurs qui exÃ©cutent des commandes, contrÃ´lent le PWM, alimentent les moteurs, suivent la position des tiges.  Sur les deux tÃ©lÃ©commandes supÃ©rieures se trouvent des moniteurs, une unitÃ© centrale oÃ¹ les algorithmes de contrÃ´le et la boule de commande tournent comme une Â«sourisÂ».  Un rÃ©seau Ethernet est utilisÃ© entre les panneaux de contrÃ´le.  Chaque armoire de commande possÃ¨de un canal RS485 (soit 8 canaux) de chacun des deux panneaux de commande.  La gestion peut Ãªtre effectuÃ©e simultanÃ©ment Ã  partir des deux tÃ©lÃ©commandes (qui sont au-dessus de la scÃ¨ne), mais en mÃªme temps, une seule des tÃ©lÃ©commandes (dÃ©signÃ©e par l'opÃ©rateur comme opÃ©rateur principal) Ã©change avec les armoires, la deuxiÃ¨me console Ã  ce moment est considÃ©rÃ©e comme une sauvegarde et l'Ã©change est dÃ©sactivÃ© sur elle. </p><br><h2 id="prichyom-tut-aktory">  Et ici les acteurs </h2><br><p>  Du point de vue des algorithmes, l'ensemble du systÃ¨me est construit sur des Ã©vÃ©nements.  Soit ce sont des changements dans les capteurs, soit les actions de l'opÃ©rateur, soit le dÃ©but d'un certain temps (temporisateurs).  Et de tels algorithmes sont trÃ¨s bien placÃ©s par le systÃ¨me d'acteurs qui traitent les Ã©vÃ©nements entrants, forment une sorte de rÃ©ponse, et tout cela en fonction de leur Ã©tat.  Dans le sobjectizer, tous ces mÃ©canismes sortent de la boÃ®te.  Les principaux principes sur lesquels un tel systÃ¨me est basÃ© peuvent Ãªtre attribuÃ©s: l'interaction entre les acteurs se produit Ã  travers des messages, les acteurs peuvent avoir des Ã©tats et se dÃ©placer entre eux, dans chaque Ã©tat, l'acteur ne traite que les messages qui l'intÃ©ressent en ce moment.  Fait intÃ©ressant, dans un sobjectiseur, travailler avec des acteurs est conceptuellement distinct de travailler avec des flux de travail.  C'est-Ã -dire  Vous pouvez dÃ©crire les acteurs dont vous avez besoin, rÃ©aliser leur logique, rÃ©aliser leur interaction Ã  travers des messages.  Mais ensuite, rÃ©solvez sÃ©parÃ©ment le problÃ¨me de l'allocation de threads (ressources) pour leur travail.  Ceci est assurÃ© par les soi-disant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"rÃ©partiteurs"</a> qui sont responsables d'une politique particuliÃ¨re de travail avec les threads.  Par exemple, il y a un rÃ©partiteur qui alloue un thread sÃ©parÃ© pour chaque acteur avec lequel travailler, il y a un rÃ©partiteur qui fournit un pool de threads (c'est-Ã -dire qu'il peut y avoir plus d'acteurs que de threads) avec la possibilitÃ© de dÃ©finir le nombre maximum de threads, il y a un rÃ©partiteur qui alloue un thread pour tous.  La prÃ©sence de rÃ©partiteurs fournit un mÃ©canisme trÃ¨s flexible pour mettre en place un systÃ¨me d'acteurs adaptÃ© Ã  vos besoins.  Vous pouvez combiner des groupes d'acteurs pour travailler avec l'un des rÃ©partiteurs, tout en changeant un type de rÃ©partiteur en un autre, cela change essentiellement une ligne de code.  Selon les auteurs du framework, il n'est pas difficile non plus d'Ã©crire votre propre rÃ©partiteur unique.  Cela n'Ã©tait pas nÃ©cessaire dans notre projet, car tout ce dont nous avions besoin Ã©tait dÃ©jÃ  dans le sobjectizer. </p><br><p>  Une autre caractÃ©ristique intÃ©ressante est la prÃ©sence du concept de Â«coopÃ©rationÂ» des acteurs.  La coopÃ©ration est un groupe d'acteurs qui peuvent tous exister ou tous Ãªtre dÃ©truits (ou non lancÃ©s) si au moins un acteur de la coopÃ©ration n'a pas pu commencer Ã  travailler ou terminer.  Je n'ai mÃªme pas peur de donner une telle analogie ( <del>  mÃªme s'il s'agit d'un autre "opÃ©ra" </del>  ) que le concept de Â«coopÃ©rationÂ» est comme le concept de Â«foyersÂ» dans le Kubernetes dÃ©sormais Ã  la mode, il ne semble que dans le sobjectizer, il est apparu plus tÃ´t ... </p><br><p>  Au moment de la crÃ©ation, chaque acteur est inclus dans la coopÃ©ration (la coopÃ©ration peut consister en un acteur), s'attache Ã  l'un ou l'autre rÃ©partiteur et commence Ã  travailler.  Dans le mÃªme temps, les acteurs (et la coopÃ©ration) peuvent (facilement) Ãªtre crÃ©Ã©s dynamiquement en grand nombre, et comme les dÃ©veloppeurs le promettent, ce n'est pas cher.  Tous les acteurs Ã©changent entre eux via des " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boÃ®tes aux lettres</a> " (mbox).  C'est Ã©galement un concept assez intÃ©ressant et fort dans le sobjectizer.  Il fournit un mÃ©canisme trÃ¨s flexible pour le traitement des messages entrants.  PremiÃ¨rement, plusieurs destinataires peuvent se cacher derriÃ¨re une boÃ®te.  C'est vraiment trÃ¨s pratique.  Par exemple, une boÃ®te est crÃ©Ã©e dans laquelle les Ã©vÃ©nements provenant de capteurs externes sont reÃ§us et chaque acteur souscrit aux Ã©vÃ©nements qui l'intÃ©ressent.  Cela fournit un style de fonctionnement Â«publier / s'abonnerÂ».  DeuxiÃ¨mement, les dÃ©veloppeurs ont fourni la possibilitÃ© de crÃ©er relativement facilement leur propre implÃ©mentation de boÃ®tes aux lettres qui peuvent prÃ©traiter les messages entrants (par exemple, les filtrer ou les distribuer d'une maniÃ¨re spÃ©ciale entre les consommateurs).  De plus, chaque acteur a sa propre boÃ®te aux lettres et peut mÃªme lui envoyer un Â«lienÂ» dans des messages Ã  d'autres acteurs, par exemple, afin qu'ils puissent envoyer une sorte de notification comme rÃ©ponse de retour. </p><br><p>  Dans notre projet, afin d'assurer l'indÃ©pendance des groupes de moteurs entre eux, ainsi que d'assurer le fonctionnement Â«asynchroneÂ» des moteurs au sein du groupe, tous les objets de contrÃ´le ont Ã©tÃ© divisÃ©s en 8 groupes (selon le nombre d'armoires de commande), chacun comptant trois travailleurs (car pas plus de trois moteurs peuvent fonctionner en groupe Ã  la fois). <br>  Il faut Ã©galement dire que le sobjectizer (dans la version actuelle 5.5) ne contient pas de mÃ©canismes d'interprocessus et d'interaction rÃ©seau et laisse cette partie aux dÃ©veloppeurs.  Les auteurs l'ont fait trÃ¨s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dÃ©libÃ©rÃ©ment</a> , afin que le cadre soit plus Â«facileÂ».  De plus, les mÃ©canismes d'interaction rÃ©seau Â«une foisÂ» existaient dans les versions prÃ©cÃ©dentes, mais Ã©taient exclus.  Cependant, cela ne cause aucun inconvÃ©nient, car en effet l'interaction rÃ©seau est trÃ¨s dÃ©pendante des tÃ¢ches Ã  rÃ©soudre, des protocoles d'Ã©change utilisÃ©s, etc.  Ici, une implÃ©mentation universelle ne peut pas Ãªtre optimale dans tous les cas. </p><br><p>  Dans notre cas, pour la communication rÃ©seau et interprocessus, nous avons utilisÃ© l'un de nos dÃ©veloppements de longue date - la bibliothÃ¨que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libuniset2</a> .  Par consÃ©quent, l'architecture de notre systÃ¨me ressemble Ã  ceci: </p><br><ul><li>  libuniset fournit une communication rÃ©seau et interprocessus (basÃ©e sur des capteurs) </li><li>  sobjectizer fournit la crÃ©ation d'un systÃ¨me d'acteurs interagissant les uns avec les autres (dans le mÃªme espace d'adressage) mettant en Å“uvre des algorithmes de contrÃ´le. </li></ul><br><p>  Alors, je vous rappelle que nous avons 62 moteurs.  Chaque moteur peut Ãªtre connectÃ© Ã  l'onduleur, le support correspondant peut recevoir les coordonnÃ©es auxquelles vous devez arriver et la vitesse Ã  laquelle vous devez vous dÃ©placer.  De plus, le moteur prÃ©sente les conditions suivantes: </p><br><ul><li>  prÃªt Ã  partir </li><li>  connectÃ© </li><li>  courir (tourner) </li><li>  accident </li><li>  connexion (Ã©tat transitoire) </li><li>  arrÃªt (Ã©tat transitoire) </li></ul><br><p>  En consÃ©quence, chaque Â«moteurÂ» est reprÃ©sentÃ© dans le systÃ¨me par un acteur qui implÃ©mente la logique des transitions entre les Ã©tats, traite les Ã©vÃ©nements des capteurs et Ã©met des commandes de contrÃ´le.  Dans sobjectizer, les acteurs sont faciles Ã  crÃ©er, il suffit d'hÃ©riter votre classe de la classe de base so_5 :: agent_t.  En mÃªme temps, le constructeur doit prendre le soi-disant contexte :: so_5 :: context_t comme premier argument, les autres arguments Ã©tant dÃ©terminÃ©s par les besoins du dÃ©veloppeur. </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); ... }</code> </pre> <br><p>  Parce que  cet article n'est pas pÃ©dagogique, je ne fournirai donc pas ici les textes dÃ©taillÃ©s des descriptions de cours ou de mÃ©thodes.  L'article voulait juste montrer Ã  quel point il est facile (en quelques lignes) avec sobjectizer de faire tout cela.  Permettez-moi de vous rappeler que le projet a une excellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> dÃ©taillÃ©e, avec un tas d'exemples diffÃ©rents. </p><br><h2 id="a-chto-za-sostoyaniya-u-etih-aktorov-o-chyom-rech">  Et quels sont les Â«Ã©tatsÂ» de ces acteurs?  De quoi tu parles? </h2><br><p>  L'utilisation des Ã©tats et des transitions entre eux pour ACS est gÃ©nÃ©ralement un sujet natif.  Ce Â«conceptÂ» s'intÃ¨gre trÃ¨s bien dans la gestion d'Ã©vÃ©nements.  Dans sobjectizer, ce concept est pris en charge au niveau de l'API.  Dans une classe d'acteurs, les Ã©tats sont assez facilement dÃ©clarÃ©s </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Drive_A(); <span class="hljs-comment"><span class="hljs-comment">//  state_t st_base {this}; state_t st_disabled{ initial_substate_of{st_base}, "disabled" }; state_t st_preinit{ substate_of{st_base}, "preinit" }; state_t st_off{ substate_of{st_base}, "off" }; state_t st_connecting{ substate_of{st_base}, "connecting" }; state_t st_disconnecting{ substate_of{st_base}, "disconnecting" }; state_t st_connected{ substate_of{st_base}, "connected" }; ... }</span></span></code> </pre><br><p>  et en outre, pour chaque Ã©tat, le dÃ©veloppeur dÃ©termine les gestionnaires nÃ©cessaires.  Souvent, certaines actions sont requises lors de l'entrÃ©e dans un Ã©tat et lors de sa sortie.  Ceci est Ã©galement prÃ©vu dans le sobjectizer, vous dÃ©finissez tout aussi facilement vos gestionnaires pour ces Ã©vÃ©nements (Â«state entryÂ», Â«state exitÂ»). <del>  On estime que les dÃ©veloppeurs du passÃ© ont une vaste expÃ©rience ACS-shny </del>  ... </p><br><h3 id="obrabotchiki-sobytiy">  Gestionnaires d'Ã©vÃ©nements </h3><br><p>  Les gestionnaires d'Ã©vÃ©nements, c'est lÃ  que la logique de votre application est implÃ©mentÃ©e.  Comme mentionnÃ© ci-dessus, un abonnement est fait Ã  une boÃ®te aux lettres spÃ©cifique et pour un certain Ã©tat de l'acteur.  Si un acteur n'a pas d'Ã©tats explicitement dÃ©clarÃ©s dans le code, alors il est implicitement dans l'Ã©tat spÃ©cial "default_state".  Dans diffÃ©rents Ã©tats, vous pouvez dÃ©finir diffÃ©rents gestionnaires pour les mÃªmes Ã©vÃ©nements.  Si vous n'avez pas spÃ©cifiÃ© de gestionnaire d'Ã©vÃ©nements dans cette boÃ®te aux lettres, il sera simplement ignorÃ© (c'est-Ã -dire qu'il n'existera tout simplement pas pour l'acteur). </p><br><p>  La syntaxe de dÃ©finition des gestionnaires est trÃ¨s simple.  Il suffit d'indiquer votre fonction.  Aucun type ou argument de modÃ¨le n'est requis.  Tout est dÃ©duit automatiquement de la dÃ©finition de la fonction.  Par exemple: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_base) .event( &amp;Drive_A::on_get_info ) .event( &amp;Drive_A::on_control ) .event( &amp;Drive_A::off_control );</code> </pre> <br><p>  Voici un exemple d'abonnement Ã  des Ã©vÃ©nements dans une boÃ®te spÃ©cifique pour l'Ã©tat st_base.  Fait intÃ©ressant, dans cet exemple, st_base est l'Ã©tat de base pour les autres Ã©tats et, par consÃ©quent, cet abonnement sera valide pour tous les Ã©tats qui sont Â«hÃ©ritÃ©sÂ» de st_base.  Cette approche vous permet de vous dÃ©barrasser du "copier-coller" pour dÃ©terminer les mÃªmes gestionnaires pour diffÃ©rents Ã©tats.  Dans le mÃªme temps, dans un Ã©tat spÃ©cifique, vous pouvez soit remplacer le gestionnaire spÃ©cifiÃ©, soit le "dÃ©sactiver" (supprimer). </p><br><p>  Il existe une autre faÃ§on de dÃ©finir les gestionnaires.  Il s'agit d'une dÃ©finition directe des fonctions lambda.  C'est un moyen trÃ¨s pratique, car les gestionnaires sont souvent des fonctions courtes dans quelques actions, envoyer quelque chose Ã  quelqu'un ou changer d'Ã©tat. </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_disconnecting) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_disconnected_t</span></span>&amp; m) { ... st_off.activate(); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&amp; m ) { ... st_protection.activate(); });</code> </pre> <br><p>  Au dÃ©but, cette syntaxe semble compliquÃ©e.  Mais en seulement quelques jours de dÃ©veloppement actif, vous vous y habituez et commence mÃªme Ã  l'aimer.  Parce que toute la logique du travail de l'acteur dans un Ã©tat ou un autre peut tenir dans un code assez court et tout sera devant vos yeux.  Par exemple, dans l'exemple illustrÃ©, dans l'Ã©tat dÃ©connectÃ© (st_disconnecting), soit la transition vers l'Ã©tat dÃ©connectÃ© (st_off.) Ou l'Ã©tat de protection (st_protection) se produit si un message sur une sorte d'Ã©chec se produit.  Un tel code est assez facile Ã  lire. </p><br><p>  Soit dit en passant, pour les cas simples lorsqu'un Ã©vÃ©nement doit simplement entrer dans un Ã©tat, il existe une syntaxe encore plus courte: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mbox = drv-&gt;so_mbox(); st_off .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_connected_t</span></span>&gt;(mbox, st_connected) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_limit_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_t</span></span>&gt;(mbox, st_on);</code> </pre><br><h2 id="upravlenie">  La gestion </h2><br><p>  Comment fonctionne la gestion de toute cette Ã©conomie?  Comme mentionnÃ© ci-dessus, deux tÃ©lÃ©commandes sont fournies pour le contrÃ´le direct du mouvement des shtankets.  Sur chaque tÃ©lÃ©commande, il y a un moniteur, un manipulateur (trackball) et un cadran de vitesse (en plus de "l'ordinateur" cachÃ© dans la tÃ©lÃ©commande sur lequel tout tourne et des tas de convertisseurs de toutes sortes).  Le systÃ¨me a plusieurs modes de contrÃ´le du mouvement des shtankets.  Manuel et "mode script".  A propos du "mode scÃ©nario" sera discutÃ© plus loin, et maintenant un peu sur le "mode manuel".  Dans ce mode, l'opÃ©rateur sÃ©lectionne le segment souhaitÃ©, le prÃ©pare pour le mouvement (connecte le moteur Ã  l'onduleur), dÃ©finit la marque (position cible) du segment, et dÃ¨s qu'il dÃ©finit la vitesse supÃ©rieure Ã  zÃ©ro, les segments commencent Ã  se dÃ©placer.  Pour rÃ©gler la vitesse, un ajusteur physique spÃ©cial est utilisÃ©, sous la forme d'un Â«potentiomÃ¨tre avec boutonÂ», mais il existe Ã©galement un Â«Ã©cran de rÃ©glageÂ» de la vitesse.  Le plus "tournÃ©", le <del>  plus fort </del>  va plus vite.  La vitesse maximale est limitÃ©e Ã  1,5 m / s.  Bouton de vitesse - un pour tous.  C'est-Ã -dire  En mode manuel, tous les porte-outils connectÃ©s Ã  l'opÃ©rateur se dÃ©placent Ã  la mÃªme vitesse dÃ©finie.  Bien qu'ils puissent se dÃ©placer dans diffÃ©rentes directions (cela dÃ©pend de l'endroit oÃ¹ l'opÃ©rateur les a dirigÃ©s).  Bien sÃ»r, il est difficile pour une personne de garder une trace de plus de deux ou trois shtankets en mÃªme temps, donc gÃ©nÃ©ralement ils ne bougent pas beaucoup en mode manuel.  Depuis deux stations, les opÃ©rateurs peuvent gÃ©rer simultanÃ©ment chacun de leurs shtankets.  De plus, chaque console (opÃ©rateur) possÃ¨de son propre rÃ©gulateur de vitesse. </p><br><p>  Du point de vue de l'implÃ©mentation, le mode manuel ne contient pas de logique particuliÃ¨re.  La commande de connexion du moteur provient de l'interface graphique, est convertie en message Ã  l'acteur correspondant, qui y travaille.  En passant par les Ã©tats Â«offÂ» -&gt; Â«connectingÂ» -&gt; Â«connectedÂ».  La mÃªme chose avec le rÃ©glage de la position pour le mouvement du stunket et le rÃ©glage de la vitesse.  Tous ces Ã©vÃ©nements arrivent Ã  l'acteur sous forme de messages auxquels il rÃ©agit.  Sauf s'il peut Ãªtre notÃ© que l'interface graphique et le processus de contrÃ´le lui-mÃªme sont des processus diffÃ©rents et qu'entre eux il y a une interaction "interprocessus" Ã  travers les "capteurs" utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libuniset2</a> . </p><br><h2 id="rezhim-ispolneniya-scenariya-opyat-eti-aktory">  Mode d'exÃ©cution de script (encore une fois, ces acteurs?) </h2><br><p>  En fait, le mode de contrÃ´le manuel est principalement utilisÃ© uniquement pour sortir pendant les rÃ©pÃ©titions ou dans des cas simples.  Le mode principal dans lequel le contrÃ´le est en cours est le Â«mode d'exÃ©cution de scriptÂ» ou, briÃ¨vement, le Â«mode de scriptÂ».  Dans ce mode, chaque shtank se dÃ©place vers son point avec les paramÃ¨tres spÃ©cifiÃ©s dans le script (vitesse et marque cible).  Pour l'opÃ©rateur, le contrÃ´le dans ce mode consiste en deux commandes simples: </p><br><ul><li>  prÃ©parez-vous (le bon groupe de moteurs est connectÃ©) </li><li>  allons-y (le groupe commence Ã  se dÃ©placer vers les positions cibles dÃ©finies pour chacun). </li></ul><br><p>  L'ensemble du scÃ©nario est divisÃ© en soi-disant Â«agendasÂ».  Un agenda est un mouvement d'un groupe shtanket.  C'est-Ã -dire  chaque programme comprend un groupe de shtankets, avec la vitesse cible et la marque oÃ¹ vous devez venir.  En fait, le script est divisÃ© en actes, les actes sont divisÃ©s en peintures, les peintures sont divisÃ©es en citations Ã  comparaÃ®tre et les citations Ã  comparaÃ®tre sont dÃ©jÃ  constituÃ©es de Â«butsÂ» pour des shtankets spÃ©cifiques.  Mais du point de vue de la gestion, cette division n'est pas importante, car  c'est Ã  l'ordre du jour que des paramÃ¨tres spÃ©cifiques de mouvement sont finalement indiquÃ©s. </p><br><p>  Pour mettre en Å“uvre ce rÃ©gime, le systÃ¨me d'acteurs est remontÃ© au mieux.  Un Â«lecteur de scriptÂ» a Ã©tÃ© dÃ©veloppÃ© qui crÃ©e un groupe d'acteurs spÃ©ciaux et les lance.  Nous avons dÃ©veloppÃ© deux types d'acteurs: les acteurs-acteurs, conÃ§us pour effectuer des tÃ¢ches pour un shtanket spÃ©cifique, et un acteur-coordinateur, qui rÃ©partit les tÃ¢ches entre les interprÃ¨tes.  De plus, des acteurs performants sont crÃ©Ã©s selon les besoins, si au moment de la prochaine Ã©quipe n'est pas libre.  L'acteur coordinateur est responsable de la crÃ©ation et du maintien du pool d'acteurs performants.  Par consÃ©quent, la direction ressemble Ã  ceci: </p><br><ul><li>  instruction charge le script </li><li>  "Retourne" Ã  l'ordre du jour souhaitÃ© (va gÃ©nÃ©ralement juste dans une rangÃ©e). </li><li>  au bon moment, appuie sur le bouton Â«prÃ©parerÂ», par lequel une commande (message) est envoyÃ©e Ã  l'acteur coordinateur pour chaque formulaire inclus dans l'agenda actuel avec les paramÃ¨tres de mouvement. </li><li>  L'acteur-coordinateur examine son bassin d'acteurs libres, en prend un gratuit (s'il n'en crÃ©e pas un nouveau) et lui donne une tÃ¢che (nombre de shankets et paramÃ¨tres de mouvement). </li><li>  Chaque acteur-acteur ayant reÃ§u la tÃ¢che commence Ã  exÃ©cuter la commande Â«se prÃ©parerÂ».  C'est-Ã -dire  il connecte le moteur et entre en mode veille de la commande Â«goÂ». </li><li>  le moment venu, l'opÃ©rateur donne la commande "allons-y" </li><li>  l'Ã©quipe "go" vient au coordinateur.  Il l'envoie Ã  tous ses interprÃ¨tes actuellement actifs et ils commencent Â«l'exÃ©cutionÂ». </li></ul><br><p>  Il convient de noter que l'agenda contient des paramÃ¨tres supplÃ©mentaires.  Par exemple, commencez le mouvement avec un retard de N secondes ou commencez le mouvement uniquement aprÃ¨s une commande d'opÃ©rateur spÃ©ciale distincte.  Par consÃ©quent, la liste des Ã©tats pour chaque acteur performant est assez longue: "prÃªt Ã  exÃ©cuter la commande suivante", "prÃªt Ã  bouger", "mouvement retardÃ©", "en attente de la commande de l'opÃ©rateur", "mouvement", "exÃ©cution terminÃ©e", "dysfonctionnement" . </p><br><p>  Une fois que le shanket a atteint (ou non) la marque spÃ©cifiÃ©e, l'acteur-interprÃ¨te informe le coordinateur de la tÃ¢che terminÃ©e.  Le coordinateur donne l'ordre de dÃ©sactiver ce moteur (s'il ne participe plus Ã  l'agenda actuel) ou Ã©met de nouveaux paramÃ¨tres de mouvement.  Ã€ son tour, l'acteur-interprÃ¨te a reÃ§u une commande pour Ã©teindre le moteur, l'Ã©teint et passe dans un Ã©tat d'attente pour de nouvelles commandes, ou commence Ã  exÃ©cuter une nouvelle commande. </p><br><p>  En raison du fait que le sobjectizer dispose d'une API bien pensÃ©e et pratique pour travailler avec les Ã©tats, le code d'implÃ©mentation est assez concis.  Par exemple, le retard sur le mouvement est dÃ©crit sur une seule ligne: </p><br><pre> <code class="cpp hljs">st_delay.time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{target-&gt;delay()}, st_moving ); st_delay.activate(); ...</code> </pre><br><p>  La fonction time_limit dÃ©finit une limite de temps sur combien peut Ãªtre dÃ©pensÃ© dans un Ã©tat donnÃ© et quel Ã©tat doit Ãªtre passÃ© aprÃ¨s un temps spÃ©cifiÃ© (st_moving). </p><br><h2 id="aktory-zaschity">  Acteurs de la protection </h2><br><p>  Bien sÃ»r, pendant le fonctionnement, des dysfonctionnements peuvent survenir.  Le systÃ¨me est requis pour gÃ©rer ces situations.  Il y avait aussi une place pour l'utilisation des acteurs.  ConsidÃ©rez plusieurs de ces protections: </p><br><ul><li>  protection contre les surintensitÃ©s </li><li>  protection contre les dÃ©faillances de mesure </li><li>  protection contre les mouvements dans la direction opposÃ©e (et cela peut Ãªtre le cas si quelque chose ne va pas avec le capteur ou le compteur) </li><li>  protection contre les mouvements sans commande </li><li>  contrÃ´le de l'exÃ©cution de l'Ã©quipe (contrÃ´le que le shtanket a commencÃ© Ã  bouger) </li></ul><br><p>  Vous pouvez voir que toutes ces protections sont indÃ©pendantes (autosuffisantes) du point de vue de la mise en Å“uvre, et devraient fonctionner "en parallÃ¨le".  C'est-Ã -dire  n'importe quelle condition peut fonctionner.  Dans le mÃªme temps, la logique de vÃ©rification des conditions de dÃ©clenchement pour chacune des protections est propre, parfois un retard (temporisateur) est nÃ©cessaire pour le dÃ©clenchement, parfois un traitement prÃ©alable de plusieurs mesures prÃ©cÃ©dentes est nÃ©cessaire, etc.  Par consÃ©quent, la mise en Å“uvre de chaque type de protection en tant que petit acteur distinct s'est avÃ©rÃ©e trÃ¨s pratique.  Tous ces acteurs sont lancÃ©s en plus (en coopÃ©ration) de l'acteur principal qui met en Å“uvre la logique de contrÃ´le.  Cette approche facilite l'ajout de types de dÃ©fenses supplÃ©mentaires simplement en ajoutant un autre acteur au groupe.  Dans le mÃªme temps, la mise en place d'un tel acteur reste assez simple et comprÃ©hensible, car  Il implÃ©mente une seule fonction. </p><br><p>  Les acteurs de la protection ont Ã©galement plusieurs Ã‰tats.  Fondamentalement, ils ne s'allument (passent Ã  l'Ã©tat Â«marcheÂ») que lorsque le moteur est connectÃ© ou que la tige est en mouvement.  Lorsque les conditions de protection sont dÃ©clenchÃ©es, ils publient une notification de la protection (avec un code de sÃ©curitÃ© et quelques dÃ©tails pour la journalisation), l'acteur principal rÃ©pond dÃ©jÃ  Ã  cette notification qui, si nÃ©cessaire, Ã©teint le moteur et passe en mode protection. </p><br><h2 id="v-kachestve-vyvoda">  En conclusion .. </h2><br><p>  ... bien sÃ»r, cet article n'est pas une sorte de "dÃ©couverte".  L'approche acteur a longtemps Ã©tÃ© utilisÃ©e avec succÃ¨s dans de nombreux systÃ¨mes.  Mais pour moi, c'Ã©tait la premiÃ¨re expÃ©rience de l'utilisation consciente de l'approche acteur pour construire des algorithmes de systÃ¨mes de contrÃ´le dans un projet relativement petit.  Et l'expÃ©rience a Ã©tÃ© assez rÃ©ussie.  J'espÃ¨re avoir pu montrer que les acteurs sont trÃ¨s bien superposÃ©s aux algorithmes de contrÃ´le, ils ont trouvÃ© une place littÃ©ralement partout. </p><br><p>  D'aprÃ¨s l'expÃ©rience des projets prÃ©cÃ©dents, il Ã©tait clair que d'une maniÃ¨re ou d'une autre, nous mettions en Å“uvre Â«quelque chose comme Ã§aÂ» (Ã©tats, messagerie, contrÃ´le de flux, etc.), mais ce n'Ã©tait pas une approche unifiÃ©e.  En utilisant le sobjectizer, nous avons obtenu un outil de dÃ©veloppement concis et lÃ©ger qui prend une tonne de problÃ¨mes.  Il n'est plus nÃ©cessaire (explicite) d'utiliser des outils de synchronisation (mutex, etc.), il n'y a pas de travail explicite avec les streams, pas de rÃ©alisations de la machine Ã  Ã©tats.  Tout cela dans le cadre, logiquement interconnectÃ© et prÃ©sentÃ© comme une API pratique, en plus, sans perdre le contrÃ´le des dÃ©tails.  L'expÃ©rience a donc Ã©tÃ© intÃ©ressante.  Pour ceux qui doutent encore, je recommande de prÃªter attention Ã  l'approche acteur et au framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sobjectizer</a> en particulier.  Il laisse des Ã©motions positives. </p><br><p>  Et l'approche acteur fonctionne vraiment!  Surtout au thÃ©Ã¢tre. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438196/">https://habr.com/ru/post/fr438196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438178/index.html">CrÃ©ation de votre premiÃ¨re application ARCore</a></li>
<li><a href="../fr438180/index.html">Enregistrer une transaction immobiliÃ¨re en ligne</a></li>
<li><a href="../fr438182/index.html">L'Ã©tude a rÃ©vÃ©lÃ© les avantages du piratage modÃ©rÃ© pour les producteurs et les distributeurs de contenu</a></li>
<li><a href="../fr438184/index.html">Rapport de la Bank of America: 700 quintillions de dollars depuis l'espace</a></li>
<li><a href="../fr438192/index.html">Dell Inspiron 14 (5482): 2-en-1 Ã©conomique avec de bonnes options de mise Ã  niveau</a></li>
<li><a href="../fr438198/index.html">Entrons dans l'histoire: oÃ¹ poussent les jambes des quadrocoptÃ¨res</a></li>
<li><a href="../fr438202/index.html">JavaScript: champs de classes publics et privÃ©s</a></li>
<li><a href="../fr438204/index.html">Dispositif de compilateur Swift. Partie 1</a></li>
<li><a href="../fr438206/index.html">26 recommandations pour l'utilisation du type var en Java</a></li>
<li><a href="../fr438210/index.html">Civilisation des ressorts, 2/5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>