<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☘️ 💆🏽 🙌 Que TestMace es mejor que Postman 👩🏾‍🔬 🙃 🧕🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos, en contacto TestMace ! Quizás mucha gente sabe de nosotros por nuestros artículos anteriores . Para aquellos que acaban de conectarse: e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Que TestMace es mejor que Postman</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480734/"><p><img src="https://habrastorage.org/webt/iy/_5/c3/iy_5c3q9lbspu40fmjpvixnwkre.jpeg"></p><br><p> Hola a todos, en contacto <a href="https://testmace.com/" rel="nofollow">TestMace</a> !  Quizás mucha gente sabe de nosotros por <a href="https://habr.com/ru/post/458372/">nuestros</a> <a href="https://habr.com/ru/post/458964/">artículos</a> <a href="https://habr.com/ru/post/462585/">anteriores</a> .  Para aquellos que acaban de conectarse: estamos desarrollando un IDE para trabajar con la API TestMace.  La pregunta más frecuente al comparar TestMace con productos de la competencia es "¿En qué se diferencia de Postman?"  Decidimos que era hora de dar una respuesta detallada a esta pregunta.  A continuación detallamos nuestras ventajas sobre <a href="https://www.getpostman.com/" rel="nofollow">Cartero</a> . </p><a name="habracut"></a><br><h2 id="razdelenie-na-uzly">  Subdivisión </h2><br><p>  Si trabaja con Postman, sabrá que la interfaz de solicitud contiene todas las funciones necesarias.  Hay scripts, pruebas y, de hecho, las solicitudes mismas.  Esto simplifica el trabajo para principiantes, pero para escenarios grandes este enfoque no es flexible.  ¿Qué sucede si desea crear varias consultas y agregarlas?  ¿Qué sucede si desea ejecutar una secuencia de comandos sin una solicitud o varias secuencias de comandos separadas lógicamente en una fila?  Al final, sería bueno separar las pruebas de los scripts utilitarios ordinarios.  Además, el enfoque de "agregar toda la funcionalidad a un nodo" no es escalable: la interfaz se sobrecarga rápidamente. </p><br><p>  TestMace inicialmente divide toda la funcionalidad en diferentes tipos de nodos.  ¿Quieres hacer una solicitud?  Aquí hay un nodo de <a href="https://docs-ru.testmace.com/node-types/requeststep" rel="nofollow">paso de solicitud</a> .  ¿Quieres escribir un guión?  Aquí hay un nodo de <a href="https://docs-ru.testmace.com/node-types/script" rel="nofollow">script</a> para usted.  ¿Necesitas pruebas?  Por favor - nodo de <a href="https://docs-ru.testmace.com/node-types/assertion" rel="nofollow">afirmación</a> .  Ah, sí, todavía puedes envolver todo esto en un nodo de <a href="https://docs-ru.testmace.com/node-types/folder" rel="nofollow">carpeta</a> .  Y todo esto se combina fácilmente entre sí.  Este enfoque no solo es muy flexible, sino que, de acuerdo con el principio de unicidad de responsabilidad, le permite usar solo lo que realmente necesita en este momento.  ¿Por qué necesito scripts y pruebas si solo quiero hacer una solicitud? </p><br><h2 id="chelovekochitaemyy-format-proekta">  Formato de proyecto legible por humanos </h2><br><p>  Hay una diferencia conceptual en la forma en que el almacenamiento es entre TestMace y Postman.  En Postman, todas las solicitudes se almacenan en algún lugar del almacenamiento local.  Si es necesario compartir solicitudes entre varios usuarios, entonces debe usar la sincronización incorporada.  De hecho, este es un enfoque generalmente aceptado, no sin fallas.  ¿Qué hay de la seguridad de los datos?  De hecho, la política de algunas empresas puede no permitir el almacenamiento de datos de terceros.  Sin embargo, ¡creemos que TestMace tiene algo mejor que ofrecer!  Y el nombre de esta mejora es "formato de proyecto legible por humanos". </p><br><p>  Para empezar, TestMace básicamente tiene una entidad de proyecto.  Y la aplicación se desarrolló originalmente con el objetivo de almacenar proyectos en sistemas de control de versiones: el árbol del proyecto se proyecta casi uno a uno en la estructura del archivo, yaml se usa como formato de almacenamiento (sin corchetes ni comas adicionales), y la representación del archivo de cada nodo se describe en detalle en la documentación con comentarios .  Pero en la mayoría de los casos no mirará allí: todos los nombres de campo tienen nombres lógicos. </p><br><p>  ¿Qué le da esto al usuario?  Esto le permite cambiar de manera muy flexible el equipo de flujo de trabajo, utilizando los enfoques habituales.  Por ejemplo, los desarrolladores pueden almacenar un proyecto en el mismo repositorio que el backend.  En las sucursales, además de cambiar la base de código directamente, el desarrollador puede reparar los scripts de consulta y las pruebas existentes.  Después de confirmar los cambios en el repositorio (git, svn, mercurial, que le gusta más) CI (su favorito, no impuesto a nadie) lanza nuestra utilidad de consola <a href="https://www.npmjs.com/package/%40testmace/cli" rel="nofollow">testmace-cli</a> , y el informe recibido después de la ejecución (por ejemplo, en formato junit, que también es compatible con testmace-cli) se envía al sistema apropiado.  Y el problema de seguridad antes mencionado ya no es un problema. </p><br><p>  Como puede ver, TestMace no impone su ecosistema y paradigma.  En cambio, se integra fácilmente en procesos ya establecidos. </p><br><h2 id="dinamicheskie-peremennye">  Variables dinámicas </h2><br><p>  TestMace sigue el concepto de no código: si el problema puede resolverse sin usar código, intentamos dar esta oportunidad.  Trabajar con variables es solo esa funcionalidad, que en la mayoría de los casos se puede hacer sin programación. </p><br><p>  Ejemplo: recibimos una respuesta del servidor y queremos guardar parte de la respuesta en una variable.  En Postman, escribiríamos algo así en un script de prueba (lo cual es extraño en sí mismo): </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonData = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(responseBody); postman.setEnvironmentVariable(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, jsonData.data);</code> </pre> <br><p>  Pero en nuestra opinión, escribir un guión para un guión tan simple y de uso frecuente parece redundante.  Por lo tanto, en TestMace es posible asignar una respuesta a una variable usando una interfaz gráfica.  Eche un vistazo a lo simple que es: </p><br><p><img src="https://habrastorage.org/webt/3z/w8/qm/3zw8qmh_a7cnwz2wqkozfw4bv8s.gif"></p><br><p>  Y ahora, con cada solicitud, esta variable dinámica se actualizará.  Pero puede argumentar, argumentando que el enfoque de cartero es más flexible y le permite no solo hacer una tarea, sino también realizar un preprocesamiento.  Aquí se explica cómo modificar el ejemplo anterior: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonData = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(responseBody); postman.setEnvironmentVariable(<span class="hljs-string"><span class="hljs-string">"data"</span></span>, CryptoJS.MD5(jsonData.data));</code> </pre> <br><p>  Bueno, para esto, TestMace tiene un nodo de <a href="https://docs-ru.testmace.com/node-types/script" rel="nofollow">script</a> que cubre este script.  Para reproducir el caso anterior, pero ya en la ejecución de TestMace, es necesario crear un nodo de secuencia de comandos después de la solicitud y utilizar el siguiente código como secuencia de comandos: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = tm.currentNode.prev.response.body.data; tm.currentNode.parent.setDynamicVar(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, crypto.MD5(data));</code> </pre> <br><p>  Como puede ver, la composición de los nodos también sirvió un buen servicio aquí.  ¡Y para un caso tan simple como el descrito anteriormente, simplemente puede asignar la expresión <code>${crypto.MD5($response.data)}</code> variable creada a través de la interfaz gráfica! </p><br><h2 id="sozdanie-testov-cherez-gui">  Crear pruebas a través de la GUI </h2><br><p>  Postman le permite crear pruebas escribiendo scripts (en el caso de Postman, esto es JavaScript).  Este enfoque tiene ventajas sólidas: flexibilidad casi ilimitada, disponibilidad de soluciones preparadas, etc. </p><br><p>  Sin embargo, las realidades son a menudo tales (no lo somos, la vida es tal) que el probador no tiene habilidades de programación, y me gustaría aportar beneficios al equipo ahora.  Para tales casos, siguiendo el concepto sin código, TestMace le permite crear pruebas simples a través de una interfaz gráfica sin recurrir a escribir scripts.  Aquí, por ejemplo, se ve como el proceso de crear una prueba que compara los valores de igualdad: </p><br><p><img src="https://habrastorage.org/webt/fv/i-/k6/fvi-k6da_gymia7jfvt0kmx1aps.gif"></p><br><p>  Sin embargo, la creación de pruebas en un editor gráfico no excluye la capacidad de <a href="https://docs-ru.testmace.com/node-types/assertion/script" rel="nofollow">escribir pruebas en código</a> .  Aquí las mismas bibliotecas que en el nodo de script, y <a href="https://www.chaijs.com/" rel="nofollow">chai</a> para escribir pruebas. </p><br><h2 id="vozmozhnost-zapustit-uzhe-suschestvuyuschiy-scenariy-po-ssylke-link-uzel">  Capacidad para ejecutar un script existente por referencia (nodo de enlace) </h2><br><p>  Tales situaciones a menudo surgen cuando una determinada solicitud o incluso un script completo necesita ejecutarse varias veces en diferentes partes de un proyecto.  Un ejemplo de tales solicitudes es la autorización personalizada en varias etapas, que lleva el entorno al estado deseado, etc.  En general, hablando en términos de lenguajes de programación, me gustaría tener funciones que puedan reutilizarse en diferentes partes de la aplicación.  En TestMace, esta función la realiza el nodo de <a href="https://docs-ru.testmace.com/node-types/link" rel="nofollow">enlace</a> .  Usarlo es muy simple: <br>  1) crear una consulta o script <br>  2) crear un nodo de tipo Enlace <br>  3) en los parámetros especifique el enlace al script creado en el primer paso </p><br><p>  En una versión más avanzada, puede especificar qué variables dinámicas del script se lanzan a un nivel superior en relación con el enlace.  ¿Suena confuso?  Supongamos que creamos una carpeta llamada <strong>create-post</strong> , dentro de la cual se asigna una variable dinámica <code>postId</code> a este nodo.  Ahora en el enlace del nodo <strong>create-post-link</strong> , puede especificar explícitamente que la variable <code>postId</code> asigne al ancestro <strong>create-post-link</strong> .  Este mecanismo (nuevamente, expresado en lenguaje de programador) puede usarse para devolver el resultado de la "función".  En general, genial, SECO en pleno crecimiento y de nuevo no se dañó ni una sola línea de código. </p><br><p><img src="https://habrastorage.org/webt/yo/8s/nj/yo8snjixc2ozh3vdrhprnstmess.gif"></p><br><p>  En cuanto a Postman, la solicitud de función para reutilizar solicitudes ha estado <a href="https://github.com/postmanlabs/postman-app-support/issues/1535" rel="nofollow">suspendida desde 2015</a> , y parece haber <a href="https://github.com/postmanlabs/postman-app-support/issues/1535" rel="nofollow">algunos indicios de</a> que están trabajando en este problema.  En su forma actual, Postman, por supuesto, tiene la capacidad de cambiar el flujo de ejecución, lo que en teoría probablemente le permite implementar este comportamiento, pero esto es más un truco sucio que un enfoque realmente funcional. </p><br><h2 id="prochie-otlichiya">  Otras diferencias </h2><br><ul><li>  Mayor control sobre el alcance de las variables.  El ámbito más pequeño dentro del cual puede definir una variable en Postman es la colección.  TestMace le permite definir variables para cualquier consulta o carpeta.  En Postman, la colección Compartir le permite exportar solo colecciones, mientras que en TestMace compartir funciona para cualquier nodo. </li><li>  TestMace admite <a href="http-headers" rel="nofollow">encabezados heredados</a> , que por defecto se pueden sustituir en consultas secundarias.  En Postman, hay una <a href="https://github.com/postmanlabs/postman-app-support/issues/1947" rel="nofollow">tarea</a> a este respecto, e incluso está cerrada, pero como solución se propone ... <a href="https://github.com/postmanlabs/postman-app-support/issues/1947" rel="nofollow">usar scripts</a> .  En TestMace, todo esto se configura a través de la GUI y existe la opción de deshabilitar opcionalmente los encabezados heredados en descendientes específicos </li><li>  Deshacer / Rehacer.  Funciona no solo al editar nodos, sino también al mover, eliminar, renombrar y otras operaciones que cambian la estructura del proyecto </li><li>  Los archivos adjuntos a las solicitudes se convierten en parte del proyecto y se almacenan con él, mientras se sincronizan perfectamente, a diferencia de Postman.  (Sí, ya no necesita seleccionar archivos manualmente cada vez que inicia y transferirlos a sus colegas en los archivos) </li></ul><br><h2 id="fichi-kotorye-uzhe-na-podhode">  Características que están en camino </h2><br><p>  No pudimos resistir la tentación de abrir el velo del secreto en los próximos lanzamientos, especialmente cuando la funcionalidad es muy sabrosa y ya está en proceso de prelanzamiento.  Entonces, nos encontramos. </p><br><h3 id="funkcii">  Las funciones </h3><br><p>  Como saben, Postman utiliza las llamadas variables dinámicas para generar valores.  <a href="https://learning.getpostman.com/docs/postman/variables-and-environments/variables-list/" rel="nofollow">La lista de ellos es impresionante</a> y la gran mayoría de las funciones sirven para generar valores falsos.  Por ejemplo, para generar un correo electrónico aleatorio, debe escribir: </p><br><pre> <code class="plaintext hljs">{{$randomEmail}}</code> </pre> <br><p>  Sin embargo, dado que estas son variables (aunque dinámicas), no pueden usarse como funciones: no son parametrizables, por lo tanto, no funcionará tomar un hash de una cadena. </p><br><p>  En TestMace, planeamos agregar funciones honestas.  Justo dentro de $ {} no solo puede acceder a la variable, sino también llamar a la función.  Es decir  si necesita generar el notorio correo electrónico falso, simplemente escribimos </p><br><pre> <code class="plaintext hljs">${faker.internet.email()}</code> </pre> <br><p>  Además del hecho de que esta es una función, puede notar que existe la posibilidad de llamar a un método de objeto.  Y en lugar de una gran lista plana de variables dinámicas, tenemos un conjunto de objetos agrupados lógicamente. </p><br><p>  Pero, ¿qué pasa si queremos calcular el hash de la cadena?  Fácil! </p><br><pre> <code class="plaintext hljs">${crypto.MD5($dynamicVar.data)}</code> </pre> <br><p>  ¡Puede notar que incluso puede pasar variables como parámetros!  En este lugar, un lector curioso puede sospechar que algo anda mal ... </p><br><h3 id="ispolzovanie-javascript-v-vyrazheniyah">  Usando JavaScript en expresiones </h3><br><p>  ... Y no en vano!  Cuando se formaron los requisitos para las funciones, de repente llegamos a la conclusión de que en las expresiones debe dejar que se escriba JavaScript válido.  Así que ahora eres libre de escribir expresiones en el espíritu: </p><br><pre> <code class="javascript hljs">${<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">''</span></span> + crypto.MD5(<span class="hljs-string"><span class="hljs-string">'asdf'</span></span>)}</code> </pre> <br><p>  ¡Y todo esto sin scripts directamente en los campos de entrada! </p><br><p>  En cuanto a Postman, solo se pueden usar variables, y al intentar escribir una pequeña expresión, el validador jura y se niega a calcularla. </p><br><p><img src="https://habrastorage.org/webt/a_/ul/53/a_ul5311im7wyvy-b1_vlqqlifw.png"></p><br><h3 id="prodvinutoe-avtodopolnenie">  Autocompletado avanzado </h3><br><p>  Por el momento, TestMace tiene autocompletado estándar, que se ve así: </p><br><p><img src="https://habrastorage.org/webt/kl/2b/ub/kl2bubsefwlskk59_qtdijhdnn0.png"></p><br><p>  Aquí, además de la línea de autocompletar, se indica a qué pertenece esta línea.  Este mecanismo solo funciona en expresiones enmarcadas entre paréntesis $ {}. </p><br><p>  Como puede ver, se han agregado marcadores visuales que indican el tipo de la variable (por ejemplo, cadena, número, matriz, etc.).  También puede cambiar los modos de finalización automática (por ejemplo, puede elegir la finalización automática con variables o encabezados).  ¡Pero incluso esto no es lo más importante! </p><br><p>  Primero, la finalización automática funciona incluso en expresiones (cuando sea posible).  Así es como se ve: </p><br><p><img src="https://habrastorage.org/webt/vk/vg/f5/vkvgf5vtk4sjh7r1tzamrdpojcm.png"></p><br><p>  Y en segundo lugar, ahora el autocompletado también está disponible en scripts.  ¡Mira cómo funciona! </p><br><p><img src="https://habrastorage.org/webt/ea/rd/2l/eard2lfj7wmtu4189xn-wy2tjjk.gif"></p><br><p>  No tiene sentido comparar esta funcionalidad con Postman: la autocompletación está limitada solo a listas estáticas de variables, encabezados y sus valores (corríjame si lo olvidé).  Las secuencias de comandos no se completan automáticamente :( </p><br><h1 id="zaklyuchenie">  Conclusión </h1><br><p>  En octubre, ha pasado un año desde el comienzo del desarrollo de nuestro producto.  Durante este tiempo, logramos hacer muchas cosas y de alguna manera nos pusimos al día con nuestros competidores.  Pero sea como sea, nuestro objetivo es hacer una herramienta realmente conveniente para trabajar con la API.  Todavía tenemos mucho trabajo por hacer, aquí hay un plan de desarrollo aproximado para nuestro proyecto para el próximo año: <a href="https://testmace.com/roadmap/" rel="nofollow">https://testmace.com/roadmap</a> . </p><br><p>  Sus comentarios nos permitirán navegar mejor por la abundancia de características, y su apoyo nos dará la fuerza y ​​la confianza de que estamos haciendo lo correcto.  Dio la casualidad de que hoy es un día importante para nuestro proyecto: el día de la publicación de TestMace en <a href="https://www.producthunt.com/posts/testmace" rel="nofollow">ProductHunt</a> .  Apoye nuestro proyecto, es muy importante para nosotros.  Además, en nuestra página de PH hoy hay una oferta tentadora y limitada. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480734/">https://habr.com/ru/post/480734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480712/index.html">El vuelo con un dosímetro en el bolsillo</a></li>
<li><a href="../480714/index.html">Cómo agregar códec a FFmpeg</a></li>
<li><a href="../480716/index.html">Matlab vs. Julia vs. Pitón</a></li>
<li><a href="../480718/index.html">6 consejos para una revisión exitosa del código</a></li>
<li><a href="../480724/index.html">Idiomas transcompilados: proyectos de conversión de código a código</a></li>
<li><a href="../480736/index.html">¿Por qué no todos los errores deben corregirse para mejorar un producto de TI?</a></li>
<li><a href="../480738/index.html">Experiencia en la creación de un producto en Rusia o Cómo crear una aspiradora inalámbrica "popular" PRO-EXPERT</a></li>
<li><a href="../480740/index.html">4 características geniales de Numpy que uso constantemente</a></li>
<li><a href="../480744/index.html">¿Cómo puede un programador proteger su proyecto favorito?</a></li>
<li><a href="../480746/index.html">Precarga en php 7.4: Compositor y selección de archivos para precarga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>