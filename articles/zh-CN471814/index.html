<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾 👨🏼‍💻 👨🏾 WolframClientForPython | 适用于Python的新Wolfram语言客户端库 🧜🏽 ⛳️ 🧔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我博客中的原始翻译 

 从Python获得对Wolfram语言的完全访问权限 
 Wolfram语言（ Wolfram语言 ）为程序员提供了一种独特的语言，其中包含多种复杂算法以及关于世界的内置知识。 多年来，人们一直在问我们如何从其他软件环境和编程语言访问我们技术的所有功能。 多年过去了，我们创...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WolframClientForPython | 适用于Python的新Wolfram语言客户端库</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wolfram/blog/471814/"><img src="https://habrastorage.org/webt/ob/gy/js/obgyjseqnmvhwnhq5nzso3_sxcq.png"><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我博客中的原始翻译</a></b> <br><br><h2> 从Python获得对Wolfram语言的完全访问权限 </h2><br>  Wolfram语言（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram语言</a> ）为程序员提供了一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">独特的语言，</a>其中包含多种复杂算法以及关于世界的内置知识。 多年来，人们一直在问我们如何从其他软件环境和编程语言访问我们技术的所有功能。 多年过去了，我们创建了许多此类解决方案， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">例如用于Excel的Wolfram CloudConnector，</a>用于C / C ++程序的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WSTP</a> （Wolfram符号传输协议），以及当然是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">J / Link</a> ，它可以直接从Java访问Wolfram语言。 <br><br> 因此，今天我们很高兴正式向您介绍期待已久的新的语言组合解决方案，它<b>将使</b>您<b>能够直接有效地从Python语言调用Wolfram语言</b> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram Client Library for Python</a> 。 最重要的是，此客户端库具有完全开放源代码， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该</a>代码在MIT许可证下托管在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WolframClientForPython git存储库中</a> ，因此您可以随意复制并随意使用它。 <br><br><h2> 很简单。 </h2><br>  Wolfram客户端库可轻松将大量Wolfram语言<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">算法</a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram知识库</a>直接集成到任何现有的Python代码中，从而大大节省了开发新代码的时间和精力。 在本文中，我们首先向您展示如何在Python和Wolfram语言之间建立连接，查看几种可用于Wolfram语言进行计算的方法和示例，然后从Python调用它。 有关更<b>完整的参考信息，</b>请访问： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram Python客户端库文档主页</a> 。 <br><a name="habracut"></a><br><h2> 当场欣赏... </h2><br> 让我们从一个简单的示例开始，该示例计算从正态分布获取的一百万个数字的平均和标准偏差。 本示例说明如何从Python调用Wolfram函数，并将Python的结果与相同的Wolfram语言计算结果进行比较，以表明它们具有高度收敛性。 <br><br><h3> 统计数据分析 </h3><br> 首先，要连接到Wolfram语言，您需要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram引擎</a> （免费的Wolfram语言引擎）创建一个新会话： <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wolframclient.evaluation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WolframLanguageSession session=WolframLanguageSession()</code> </pre> <br> 要调用Wolfram语言函数，您需要导入`wl`引擎： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wolframclient.language <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wl</code> </pre> <br> 现在，您可以执行任何Wolfram语言代码。 将来自Python的<i>样本</i>变量分配给从正态分布中提取的一百万个随机数的列表值，平均值为0，标准差为1： <br><br><pre> <code class="python hljs">sample = session.evaluate(wl.RandomVariate(wl.NormalDistribution(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1e6</span></span>))</code> </pre> <br> 考虑其中的前五个： <br><br><pre> <code class="python hljs">sample[:<span class="hljs-number"><span class="hljs-number">5</span></span>] [<span class="hljs-number"><span class="hljs-number">0.44767075774581</span></span>, <span class="hljs-number"><span class="hljs-number">0.9662810005828261</span></span>, <span class="hljs-number"><span class="hljs-number">-1.327910570542906</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2383857558557122</span></span>, <span class="hljs-number"><span class="hljs-number">1.1826399551062043</span></span>]</code> </pre> <br> 您可以使用Wolfram语言计算此<i>样本</i>的平均值。 如预期的那样，它将接近零： <br><br><pre> <code class="python hljs">session.evaluate(wl.Mean(sample)) <span class="hljs-number"><span class="hljs-number">0.0013371607703851515</span></span></code> </pre> <br> 您也可以在Python中直接计算出相同的值，以确保获得相似的结果： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> statistics <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mean mean(sample) <span class="hljs-number"><span class="hljs-number">0.0013371607703851474</span></span></code> </pre> <br> 同样，您可以使用Wolfram语言计算<i>样本</i>的标准偏差： <br><br><pre> <code class="python hljs">session.evaluate(wl.StandardDeviation(sample)) <span class="hljs-number"><span class="hljs-number">1.0014296230797068</span></span></code> </pre> <br> 然后在Python中运行以下代码，以确保获得类似的结果： <br><br><pre> <code class="python hljs">stdev(sample) <span class="hljs-number"><span class="hljs-number">1.0014296230797068</span></span></code> </pre> <br> 不得不为结果收敛而感到高兴。 现在您知道了如何从Python调用简单的Wolfram语言函数。 让我们继续一个更有趣的示例。 <br><br><h3> 使用Wolfram知识库 </h3><br> 让我们看一下Wolfram语言内置函数，该函数在Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WolframAlpha中</a>不可用： <br><br><pre> <code class="python hljs">moons = session.evaluate(wl.WolframAlpha(<span class="hljs-string"><span class="hljs-string">'moons of Saturn'</span></span>, <span class="hljs-string"><span class="hljs-string">'Result'</span></span>))</code> </pre> <br>  WolframAlpha函数是Wolfram语言中的高级功能之一，可通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web API</a>与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram | Alpha</a>服务器进行通信。 您可以直接从Python使用此API，当您直接从Wolfram语言访问所有数据处理功能时，调用WolframAlpha函数将更加强大和便捷。 让我们看一下Python中的<i>moon</i>变量包含什么： <br><br><pre> <code class="python hljs">moons EntityClass[<span class="hljs-string"><span class="hljs-string">'PlanetaryMoon'</span></span>, <span class="hljs-string"><span class="hljs-string">'SaturnMoon'</span></span>]</code> </pre> <br> 此处的输出是Wolfram语言的表达式在Python中的表示形式，可用于任何后续计算中。 例如，如果要为此获取土星的前四颗卫星的列表（按它们与土星的接近程度），则需要运行以下代码： <br><br><pre> <code class="python hljs">session.evaluate(wl.EntityList(moons))[:<span class="hljs-number"><span class="hljs-number">4</span></span>] [Entity[<span class="hljs-string"><span class="hljs-string">'PlanetaryMoon'</span></span>, <span class="hljs-string"><span class="hljs-string">'S2009S1'</span></span>], Entity[<span class="hljs-string"><span class="hljs-string">'PlanetaryMoon'</span></span>, <span class="hljs-string"><span class="hljs-string">'Pan'</span></span>], Entity[<span class="hljs-string"><span class="hljs-string">'PlanetaryMoon'</span></span>, <span class="hljs-string"><span class="hljs-string">'Daphnis'</span></span>], Entity[<span class="hljs-string"><span class="hljs-string">'PlanetaryMoon'</span></span>, <span class="hljs-string"><span class="hljs-string">'Atlas'</span></span>]]</code> </pre> <br> 或者，您可以使用以下代码显示土星的四颗最大质量的卫星： <br><br><pre> <code class="python hljs">bigmoons = session.evaluate(wl.EntityList(wl.SortedEntityClass(moons, wl.Rule(<span class="hljs-string"><span class="hljs-string">"Mass"</span></span>,<span class="hljs-string"><span class="hljs-string">"Descending"</span></span>),<span class="hljs-number"><span class="hljs-number">4</span></span>))) bigmoons [Entity[<span class="hljs-string"><span class="hljs-string">'PlanetaryMoon'</span></span>, <span class="hljs-string"><span class="hljs-string">'Titan'</span></span>], Entity[<span class="hljs-string"><span class="hljs-string">'PlanetaryMoon'</span></span>, <span class="hljs-string"><span class="hljs-string">'Rhea'</span></span>], Entity[<span class="hljs-string"><span class="hljs-string">'PlanetaryMoon'</span></span>, <span class="hljs-string"><span class="hljs-string">'Iapetus'</span></span>], Entity[<span class="hljs-string"><span class="hljs-string">'PlanetaryMoon'</span></span>, <span class="hljs-string"><span class="hljs-string">'Dione'</span></span>]]</code> </pre> <br> 或者，您可以获取带有这些卫星名称的字符串数组，例如： <br><br><pre> <code class="python hljs">session.evaluate(wl.Map(wl.Function( wl.Slot()(<span class="hljs-string"><span class="hljs-string">"Name"</span></span>)), bigmoons)) [<span class="hljs-string"><span class="hljs-string">'Titan'</span></span>, <span class="hljs-string"><span class="hljs-string">'Rhea'</span></span>, <span class="hljs-string"><span class="hljs-string">'Iapetus'</span></span>, <span class="hljs-string"><span class="hljs-string">'Dione'</span></span>]</code> </pre> <br> 这一切都令人印象深刻。 让我们看看使用Wolfram语言中内置的图像处理和机器学习功能的另一个示例。 <br><br><h3> 图像处理与机器学习 </h3><br> 首先，让我们切换到另一种模式，以Wolfram语言直接执行评估。 到目前为止，您已经使用`wl`引擎在Python中创建Wolfram语言表达式，但是您还可以执行用Python编写的包含Wolfram语言代码的代码行，有时甚至更容易理解： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wolframclient.language <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wlexpr</code> </pre> <br><br> 例如，使用Wolfram语言计算1 +1，然后将其作为字符串发送： <br><br><pre> <code class="python hljs">session.evaluate(<span class="hljs-string"><span class="hljs-string">'1+1'</span></span>) <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><br> 使用此方法，您可以用Wolfram语言编写一小段代码，该代码在输入处接收图像，并使用内置的人<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">脸检测算法</a>在图像中查找人脸的位置。 在这里，我们使用的图像是荷兰艺术家<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">约翰内斯·维米尔</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Johannes Vermeer</a> ）的著名画作“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>戴珍珠耳环的女孩</i></a> ”（应该指出的是，这种算法自然也适用于几乎任何可识别面部的物体图像）。 由于Python终端界面不支持图像输出，因此我们需要使用<b>Jupyter Notebook</b>和<b>Python图像库</b> （PIL）包才能输出结果： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io</code> </pre> <br><pre> <code class="python hljs">session.evaluate(wlexpr(<span class="hljs-string"><span class="hljs-string">''' image = ImageResize[ Import["Girl_with_a_Pearl_Earring.jpg"], 300]; boxes = FindFaces[image]; face = ImageAssemble[{{image,HighlightImage[image, boxes, "Blur"]}}]; '''</span></span>) )</code> </pre> <br><pre> <code class="python hljs">data = session.evaluate( wlexpr(<span class="hljs-string"><span class="hljs-string">'ExportByteArray[ face, "PNG" ]'</span></span>) )</code> </pre> <br><pre> <code class="python hljs">Image.open(io.BytesIO)</code> </pre> <br><img src="https://habrastorage.org/webt/vq/ef/ra/vqefra2fawf4rxnyqyu3h7fq-6u.png"><br><br> 结果，所有东西同时变得非常容易和强大。 但是，如果您没有在计算机上本地安装Wolfram引擎，并且想将Wolfram客户端库用于Python，该怎么办？ 在这种情况下，始终可以通过从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram Cloud</a> （云）中调用Wolfram语言来直接使用它。 <br><br><h2> 所以，去云端 </h2><br>  Wolfram Cloud提供了对Wolfram语言的轻松访问，而无需在本地进行预安装。  Wolfram Cloud提供了多种服务，包括Wolfram语言Web编程界面以及部署自定义Wolfram语言Web API的功能。 <br><br> 在以下示例中，我们将通过部署Wolfram语言Web-API来完成此任务。 例如，API在输入中接受两个国家（country1和country2）的名称，找到每个国家的首都，然后计算它们之间的距离（以公里为单位）： <br><br><pre> <code class="plaintext hljs">CloudDeploy[ APIFunction[{"country1"-&gt;"String","country2"-&gt;"String"}, QuantityMagnitude[ GeoDistance[ EntityValue[Entity["Country", #country1], "CapitalCity"], EntityValue[Entity["Country", #country2], "CapitalCity"] ], "Kilometers" ]&amp;, "WXF" ], CloudObject["api/public/capital_distance"], Permissions-&gt;"Public"]</code> </pre> <br><img src="https://habrastorage.org/webt/n_/k6/17/n_k617rum5_crn4lmveruhtbdkg.png"><br><br> 部署此API之后，您可以启动新的Wolfram语言会话，但是这次您要连接到Wolfram Cloud而不是本地引擎： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wolframclient.evaluation WolframCloudSession cloud = WolframCloudSession()</code> </pre> <br> 要调用API，您必须指定用户名（user1）和API端点（api / public / capital_distance）。 使用此数据，您可以连接到云... <br><br><pre> <code class="python hljs">api = (<span class="hljs-string"><span class="hljs-string">'user1'</span></span>, <span class="hljs-string"><span class="hljs-string">'api/public/capital_distance'</span></span>) result = cloud.call(api, {<span class="hljs-string"><span class="hljs-string">'country1'</span></span>: <span class="hljs-string"><span class="hljs-string">'Netherlands'</span></span>, <span class="hljs-string"><span class="hljs-string">'country2'</span></span>: <span class="hljs-string"><span class="hljs-string">'Spain'</span></span>})</code> </pre> <br>  ...然后获得所需的结果： <br><pre> <code class="python hljs">result.get() <span class="hljs-number"><span class="hljs-number">1481.4538329484521</span></span></code> </pre> <br> 再次评估它是多么容易和简单。 <br><br> 如果要保存已部署的Wolfram语言API，以便只有您可以使用它，则可以使用<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">权限</a> →“私有”</b>命令来部署该API。 为此，可以在私有API中生成（使用Wolfram语言）身份验证安全密钥： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/256/6e9/7f6/2566e97f66daed66b68aa77c5086fd8f.png" alt="图片"><br><pre> <code class="plaintext hljs">key = GenerateSecuredAuthenticationKey["myapp"]</code> </pre> <br> 从以下两行输入中复制答案： <br><br><pre> <code class="plaintext hljs">key["ConsumerKey"] key["ConsumerSecret"]</code> </pre> <br> 然后将它们粘贴到您的Python会话中： <br><br><pre> <code class="python hljs">SecuredAuthenticationKey(<span class="hljs-string"><span class="hljs-string">'&lt;&lt;paste-consumer-key-here&gt;&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;&lt;paste-consumer-secret-here&gt;&gt;'</span></span>)</code> </pre> <br> 然后使用身份验证启动新的云会话： <br><br><pre> <code class="python hljs">cloud = WolframCloudSession(credentials=sak) cloud.start() cloud.authorized() <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br> 现在，您（而且只有您）可以使用已部署为私有使用的任何Wolfram语言API。 <br><br><h2> 让我们谈谈序列化的基本概念 </h2><br> 为了快速高效地完成所有工作，用于Python的Wolfram客户端库使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开放的WXF格式</a>在Python和Wolfram之间交换表达式。  WXF是一种二进制格式，用于以适合与外部程序共享的形式准确地序列化Wolfram语言表达式。 库函数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Export</a>可以将Python对象序列化为字符串输入形式和WXF，并且还支持一组Python内置类，例如dict，list和string： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wolframclient.serializers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> export export({ <span class="hljs-string"><span class="hljs-string">'list'</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-string"><span class="hljs-string">'string'</span></span>: <span class="hljs-string"><span class="hljs-string">u'abc'</span></span>, <span class="hljs-string"><span class="hljs-string">'etc'</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">-1.2</span></span>] }) <span class="hljs-string"><span class="hljs-string">b'&lt;|"list" -&gt; {1, 2, 3}, "string" -&gt; "abc", "etc" -&gt; {0, None, -1.2}|&gt;'</span></span></code> </pre> <br>  WXF是带有打包数据的数字数组，可让您有效地支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NumPy</a>数组。 <br><br> 例如，创建一个由255个8位正整数组成的数组： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy array=numpy.arange(<span class="hljs-number"><span class="hljs-number">255</span></span>, dtype=<span class="hljs-string"><span class="hljs-string">'uint8'</span></span>)</code> </pre> <br> 将其序列化为WXF字节并计算字节数： <br><br><pre> <code class="python hljs">wxf=export(array, target_format=<span class="hljs-string"><span class="hljs-string">'wxf'</span></span>) len(wxf) <span class="hljs-number"><span class="hljs-number">262</span></span></code> </pre> <br>  NumPy允许您访问许多Python库。 因此，这种高效而紧凑的序列化有助于将Python系统连接到Wolfram语言，其直接结果是NumPy支持序列化PIL图像通常非常有效。 大多数像素数据模式显示为指定为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NumericArrayType</a>的数字数组类型之一。 <br><br> 还值得注意的是，此处最初支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pandas</a> Series和DataFrame。 该库还提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一种</a>用于序列化任意类的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可扩展机制</a> 。 <br><br><h2> 现在有什么？ </h2><br> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pip</a>命令为Python安装最新的Wolfram客户端库： <br><br><pre> <code class="python hljs">$ pip install wolframclient</code> </pre> <br> 为此，您需要Python 3.5.3（或更高版本）和Wolfram语言11.3（或更高版本）。 查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram客户端库</a>文档。 所有源代码都托管在Wolfram Research <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WolframClientForPython</a>存储库中。 <br><br> 如果您有改进的建议，可以并希望帮助我们做到这一点，可以通过向我们发送更新该存储库中数据的请求来做到这一点。 <br> 我们很高兴此版本终于发布，希望对您有用。 请在评论部分或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wolfram社区中</a>告诉我们您的意见，我们将尽力与您联系。 <br><br><div class="spoiler">  <b class="spoiler_title">关于翻译</b> <div class="spoiler_text"> 我非常感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Peter Tenishev</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Galina Nikitina</a>在翻译和准备出版物方面的帮助。 </div></div><br><blockquote> 想学习如何用Wolfram语言编程吗？ <br> 观看每周的<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络研讨会</a></b> 。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新课程<b>注册</b></a> 。 准备<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>在线课程</b></a> 。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>订购</b></a> Wolfram语言的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">解决方案</a> 。 </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471814/">https://habr.com/ru/post/zh-CN471814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471802/index.html">简而言之，Linux特权（功能）</a></li>
<li><a href="../zh-CN471806/index.html">光照如何影响游戏设计和游戏体验</a></li>
<li><a href="../zh-CN471808/index.html">带预制组件的独立GSM继电器和逆变器</a></li>
<li><a href="../zh-CN471810/index.html">比较用于审核Active Directory中的更改的工具：Quest Change Auditor和Netwrix Auditor</a></li>
<li><a href="../zh-CN471812/index.html">适用于软件开发人员的免费Wolfram引擎库</a></li>
<li><a href="../zh-CN471816/index.html">如何为macOS Catalina 10.15签署应用程序</a></li>
<li><a href="../zh-CN471820/index.html">电话骗子。 第三步，在其中获取有关我的银行单元已创建的文档</a></li>
<li><a href="../zh-CN471822/index.html">第一次认识家庭助理</a></li>
<li><a href="../zh-CN471824/index.html">软盘相机：关于Sony Mavica MVC-FD85的8个有趣事实（许多图片）</a></li>
<li><a href="../zh-CN471836/index.html">自动化的python代码可视化。 第四部分：文档支持</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>