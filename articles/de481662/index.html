<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüç≥ ü§πüèø üíå Erprobung neuer Tools zum Erstellen und Automatisieren der Bereitstellung in Kubernetes üë©üèª‚Äç‚öñÔ∏è ü•å üëèüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! In letzter Zeit wurden viele coole Automatisierungstools zum Erstellen von Docker-Images und f√ºr die Bereitstellung auf Kubernetes ver√∂ffentlic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erprobung neuer Tools zum Erstellen und Automatisieren der Bereitstellung in Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481662/"><p><img src="https://habrastorage.org/webt/fu/wy/ia/fuwyia7huxrflvry8lzz2dbl2tw.png"></p><br><p>  Hallo!  In letzter Zeit wurden viele coole Automatisierungstools zum Erstellen von Docker-Images und f√ºr die Bereitstellung auf Kubernetes ver√∂ffentlicht.  In diesem Zusammenhang habe ich mich entschlossen, mit dem Gitlab zu spielen, seine F√§higkeiten zu untersuchen und nat√ºrlich die Pipeline zu konfigurieren. </p><br><p>  Die Inspiration f√ºr diese Arbeit war die Site <a href="https://kubernetes.io/" rel="nofollow">kubernetes.io</a> , die automatisch aus <a href="http://github.com/kubernetes/website" rel="nofollow">Quellcodes</a> generiert wird. F√ºr jeden gesendeten Pool generiert der Roboter automatisch eine Vorschau-Version der Site mit Ihren √Ñnderungen und bietet einen Link zum Anzeigen. </p><br><p>  Ich habe versucht, einen √§hnlichen Prozess von Grund auf neu zu erstellen, der jedoch vollst√§ndig auf Gitlab CI und kostenlosen Tools basiert, mit denen ich Anwendungen in Kubernetes bereitgestellt habe.  Heute werde ich Ihnen endlich mehr dar√ºber erz√§hlen. </p><br><p>  In dem Artikel werden Tools wie die folgenden behandelt: <br>  <strong>Hugo</strong> , <strong>qbec</strong> , <strong>kaniko</strong> , <strong>git-crypt</strong> und <strong>GitLab CI</strong> bei der Erstellung dynamischer Umgebungen. </p><a name="habracut"></a><br><hr><br><h1 id="coderzhanie">  Inhalt </h1><br><ol><li>  <a href="https://habr.com/ru/post/481662/"><strong>Wir stellen Hugo vor</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Dockerfile vorbereiten</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Bekanntschaft mit Kaniko</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Wir stellen vor: qbec</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Versucht Gitlab-Runner mit Kubernetes-Executor</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Einsatz von Helmkarten mit qbec</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Einf√ºhrung in die Git-Krypta</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Erstellen Sie ein Toolbox-Image</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Unsere erste Pipeline und Assemblierung von Bildern nach Tags</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Bereitstellungsautomatisierung</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Artefakte und Push-Build-in-Master</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Dynamische Umgebungen</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Apps √ºberpr√ºfen</strong></a> </li></ol><br><hr><br><h1 id="1-znakomstvo-s-hugoanchorhugoanchor">  1. Hugo vorstellen <a name="hugo"></a></h1><br><p>  Als Beispiel f√ºr unser Projekt werden wir versuchen, eine Website f√ºr die Ver√∂ffentlichung von Dokumentationen zu erstellen, die auf Hugo basieren.  Hugo ist ein statischer Inhaltsgenerator. </p><br><p>  F√ºr diejenigen, die mit statischen Generatoren nicht vertraut sind, werde ich Ihnen etwas mehr √ºber sie erz√§hlen.  Im Gegensatz zu regul√§ren Datenbank-Site-Engines und einigen PHP-Engines, die nach Aufforderung durch einen Benutzer Seiten im laufenden Betrieb generieren, sind statische Generatoren etwas anders angeordnet.  Sie erm√∂glichen es Ihnen, die Quelle, in der Regel eine Reihe von Dateien in den Markup- und Designvorlagen von Markdown, zu nehmen und sie dann zu einer vollst√§ndig fertigen Site zu kompilieren. </p><br><p>  Das hei√üt, am Ausgang erhalten Sie eine Verzeichnisstruktur und eine Reihe von generierten HTML-Dateien, die einfach auf jedes billige Hosting hochgeladen werden k√∂nnen und eine funktionierende Site erhalten. </p><br><p>  Hugo kann lokal installiert und ausprobiert werden: </p><br><p>  Wir initialisieren die neue Site: </p><br><pre><code class="bash hljs">hugo new site docs.example.org</code> </pre> <br><p>  Und zur gleichen Zeit das Git-Repository: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> docs.example.org git init</code> </pre> <br><p>  Bisher ist unsere Website makellos und damit etwas darauf erscheint, m√ºssen wir zuerst ein Thema, ein Thema, verkn√ºpfen. Es handelt sich lediglich um eine Reihe von Vorlagen und voreingestellten Regeln, mit denen unsere Website generiert wird. </p><br><p>  Als Thema verwenden wir <a href="https://themes.gohugo.io/hugo-theme-learn/" rel="nofollow"><strong>Learn</strong></a> , das meiner Meinung nach am besten f√ºr eine Site mit Dokumentation geeignet ist. </p><br><p>  Ich m√∂chte besonders darauf achten, dass wir keine Themendateien im Repository unseres Projekts speichern m√ºssen, sondern sie einfach mit dem <strong>Git-Submodul verbinden k√∂nnen</strong> : </p><br><pre> <code class="bash hljs">git submodule add https://github.com/matcornic/hugo-theme-learn themes/learn</code> </pre> <br><p>  Daher befinden sich in unserem Repository nur Dateien, die in direktem Zusammenhang mit unserem Projekt stehen, und das verkn√ºpfte Thema bleibt in Form eines Links zu einem bestimmten Repository und wird darin festgeschrieben. Das hei√üt, es kann immer aus der Originalquelle abgerufen werden und hat keine Angst vor inkompatiblen √Ñnderungen. </p><br><p>  Fix <strong>config.toml</strong> config: </p><br><pre> <code class="plaintext hljs">baseURL = "http://docs.example.org/" languageCode = "en-us" title = "My Docs Site" theme = "learn"</code> </pre> <br><p>  Bereits in dieser Phase k√∂nnen Sie Folgendes ausf√ºhren: </p><br><pre> <code class="bash hljs">hugo server</code> </pre> <br><p>  Und unter <a href="http://localhost:1313/" rel="nofollow">http: // localhost: 1313 /</a> √ºberpr√ºfen Sie unsere neu erstellte Site. Alle am Verzeichnis vorgenommenen √Ñnderungen werden automatisch aktualisiert, und die ge√∂ffnete Seite im Browser ist sehr praktisch. </p><br><p>  Versuchen wir, ein Deckblatt in <strong>content / _index.md</strong> zu erstellen: </p><br><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section"># My docs site ## Welcome to the docs! You will be very smart :-)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Screenshot der neu erstellten Seite</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/gb/yx/nv/gbyxnvagfs6bks4iqbwcrrovumu.png"></p></div></div><br><p>  Um eine Site zu generieren, f√ºhren Sie einfach Folgendes aus: </p><br><pre> <code class="bash hljs">hugo</code> </pre> <br><p>  Der Inhalt des <strong>public /</strong> -Verzeichnisses ist Ihre Site. <br>  Ja, √ºbrigens, f√ºgen wir es sofort zu <strong>.gitignore hinzu</strong> : </p><br><pre> <code class="plaintext hljs">echo /public &gt; .gitignore</code> </pre> <br><p>  Vergessen Sie nicht, unsere √Ñnderungen zu √ºbernehmen: </p><br><pre> <code class="plaintext hljs">git add . git commit -m "New site created"</code> </pre> <br><hr><br><h1 id="2-podgotovka-dockerfileanchordockerfileanchor">  2. Vorbereiten der Docker-Datei <a name="dockerfile"></a></h1><br><p>  Es ist Zeit, die Struktur unseres Repository zu bestimmen.  Normalerweise benutze ich etwas wie: </p><br><pre> <code class="plaintext hljs">. ‚îú‚îÄ‚îÄ deploy ‚îÇ ‚îú‚îÄ‚îÄ app1 ‚îÇ ‚îî‚îÄ‚îÄ app2 ‚îî‚îÄ‚îÄ dockerfiles ‚îú‚îÄ‚îÄ image1 ‚îî‚îÄ‚îÄ image2</code> </pre> <br><ul><li>  <strong>dockerfiles /</strong> - enth√§lt Verzeichnisse mit Dockerfiles und allem, was Sie zum Erstellen unserer Docker-Images ben√∂tigen. </li><li>  <strong>deploy /</strong> - enth√§lt Verzeichnisse f√ºr die Bereitstellung unserer Anwendungen auf Kubernetes </li></ul><br><p>  Daher erstellen wir unser erstes Dockerfile unter dem Pfad <strong>dockerfiles / website / Dockerfile</strong> </p><br><pre> <code class="bash hljs">FROM alpine:3.11 as builder ARG HUGO_VERSION=0.62.0 RUN wget -O- https://github.com/gohugoio/hugo/releases/download/v<span class="hljs-variable"><span class="hljs-variable">${HUGO_VERSION}</span></span>/hugo_<span class="hljs-variable"><span class="hljs-variable">${HUGO_VERSION}</span></span>_linux-64bit.tar.gz | tar -xz -C /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin ADD . /src RUN hugo -s /src FROM alpine:3.11 RUN apk add --no-cache darkhttpd COPY --from=builder /src/public /var/www ENTRYPOINT [ <span class="hljs-string"><span class="hljs-string">"/usr/bin/darkhttpd"</span></span> ] CMD [ <span class="hljs-string"><span class="hljs-string">"/var/www"</span></span> ]</code> </pre> <br><p>  Wie Sie sehen, enth√§lt die Docker-Datei zwei FROMs. Diese Funktion wird als <a href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="nofollow"><strong>mehrstufige Erstellung bezeichnet</strong></a> und erm√∂glicht es Ihnen, alles Unn√∂tige vom endg√ºltigen Docker-Image auszuschlie√üen. <br>  Daher enth√§lt das endg√ºltige Image nur <strong>darkhttpd</strong> (einen <strong>einfachen</strong> HTTP-Server) und <strong>public /</strong> - den Inhalt unserer statisch generierten Site. </p><br><p>  Vergessen Sie nicht, unsere √Ñnderungen zu √ºbernehmen: </p><br><pre> <code class="plaintext hljs">git add dockerfiles/website git commit -m "Add Dockerfile for website"</code> </pre> <br><hr><br><h1 id="3-znakomstvo-s-kanikoanchorkanikoanchor">  3. Bekanntschaft mit Kaniko <a name="kaniko"></a></h1><br><p>  Als Sammler von Docker-Images habe ich mich f√ºr <strong><a href="https://github.com/GoogleContainerTools/kaniko" rel="nofollow">Kaniko entschieden</a></strong> , da f√ºr die Arbeit kein Docker-Daemon erforderlich ist. Die Assembly selbst kann auf jedem Computer ausgef√ºhrt und der Cache direkt in der Registrierung gespeichert werden, sodass kein dauerhafter Speicher mehr erforderlich ist . </p><br><p>  Um das Image zu erstellen, starten Sie einfach den Container mit <strong>Kaniko Executor</strong> und √ºbergeben Sie den aktuellen Build-Kontext an ihn. Dies k√∂nnen Sie lokal √ºber Docker tun: </p><br><pre> <code class="bash hljs">docker run -ti --rm \ -v <span class="hljs-variable"><span class="hljs-variable">$PWD</span></span>:/workspace \ -v ~/.docker/config.json:/kaniko/.docker/config.json:ro \ gcr.io/kaniko-project/executor:v0.15.0 \ --cache \ --dockerfile=dockerfiles/website/Dockerfile \ --destination=registry.gitlab.com/kvaps/docs.example.org/website:v0.0.1</code> </pre> <br><p>  Dabei ist <strong>registry.gitlab.com/kvaps/docs.example.org/website</strong> der Name Ihres Docker-Image. Nach dem Zusammenbau wird es automatisch in das Docker-Register verschoben. </p><br><p>  Mit <strong>dem</strong> Parameter <strong>--cache</strong> k√∂nnen Sie Layer in der Docker-Registrierung zwischenspeichern. F√ºr das angegebene Beispiel werden sie in <strong>registry.gitlab.com/kvaps/docs.example.org/website/cache</strong> gespeichert. Mit dem Parameter <strong>--cache</strong> k√∂nnen Sie jedoch einen anderen Pfad <strong>angeben repo</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Screenshot Docker-Registry</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/0-/31/qx/0-31qxfta2gk7-colutf2l_qtmm.png"></p></div></div><br><hr><br><h1 id="4-znakomstvo-s-qbecanchorqbecanchor">  4. Bekanntschaft mit qbec <a name="qbec"></a></h1><br><p>  <a href="https://qbec.io/" rel="nofollow">Qbec</a> ist ein Bereitstellungstool, mit dem Sie das Manifest Ihrer Anwendung deklarativ beschreiben und f√ºr Kubernetes bereitstellen k√∂nnen.  Durch die Verwendung von Jsonnet als Hauptsyntax k√∂nnen Sie die Beschreibung von Unterschieden f√ºr mehrere Umgebungen erheblich vereinfachen und die Code-Wiederholbarkeit nahezu vollst√§ndig eliminieren. </p><br><p>  Dies kann insbesondere dann der Fall sein, wenn Sie eine Anwendung in mehreren Clustern mit unterschiedlichen Parametern bereitstellen m√ºssen und diese deklarativ in Git beschreiben m√∂chten. </p><br><p>  Mit Qbec k√∂nnen Sie Helm-Diagramme auch rendern, indem Sie ihnen die erforderlichen Parameter √ºbergeben und sie anschlie√üend ausf√ºhren. Au√üerdem k√∂nnen Sie regul√§re Manifeste mit verschiedenen Mutationen erstellen, die auf sie angewendet werden k√∂nnen. Auf diese Weise muss das ChartMuseum nicht mehr verwendet werden.  Das hei√üt, Sie k√∂nnen Diagramme direkt in git speichern und rendern, wo sie sich befinden. </p><br><p>  Wie ich bereits sagte, speichern wir alle Bereitstellungen im Verzeichnis <strong>deploy /</strong> : </p><br><pre> <code class="bash hljs">mkdir deploy <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy</code> </pre> <br><p>  Initialisieren wir unsere erste Anwendung: </p><br><pre> <code class="bash hljs">qbec init website <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> website</code> </pre> <br><p>  Nun sieht die Struktur unserer Anwendung so aus: </p><br><pre> <code class="plaintext hljs">. ‚îú‚îÄ‚îÄ components ‚îú‚îÄ‚îÄ environments ‚îÇ  ‚îú‚îÄ‚îÄ base.libsonnet ‚îÇ  ‚îî‚îÄ‚îÄ default.libsonnet ‚îú‚îÄ‚îÄ params.libsonnet ‚îî‚îÄ‚îÄ qbec.yaml</code> </pre> <br><p>  Schauen Sie sich die Datei <strong>qbec.yaml an</strong> : </p><br><pre> <code class="plaintext hljs">apiVersion: qbec.io/v1alpha1 kind: App metadata: name: website spec: environments: default: defaultNamespace: docs server: https://kubernetes.example.org:8443 vars: {}</code> </pre> <br><p>  Hier interessieren uns vor allem <strong>spec.environments</strong> , qbec hat bereits eine Standardumgebung f√ºr uns angelegt und die Serveradresse sowie den Namespace aus unserer aktuellen kubeconfig √ºbernommen. <br>  Jetzt wird qbec bei der Bereitstellung in der <strong>Standardumgebung</strong> immer nur im angegebenen Kubernetes-Cluster und im angegebenen Namespace bereitgestellt. Sie m√ºssen also nicht mehr zwischen Kontexten und Namespaces wechseln, um eine Bereitstellung durchzuf√ºhren. <br>  Bei Bedarf k√∂nnen Sie die Einstellungen in dieser Datei jederzeit aktualisieren. </p><br><p>  Alle Ihre Umgebungen sind in <strong>qbec.yaml</strong> und in der Datei <strong>params.libsonnet beschrieben</strong> , in der <strong>angegeben</strong> ist, wo Sie die Parameter f√ºr diese Umgebungen <strong>festlegen</strong> m√ºssen. </p><br><p>  Als n√§chstes sehen wir zwei Verzeichnisse: </p><br><ul><li>  <strong>komponenten /</strong> - alle manifeste f√ºr unsere anwendung werden hier gespeichert, sie k√∂nnen sowohl in jsonnet als auch in normalen yaml-dateien beschrieben werden </li><li>  <strong>Umgebungen /</strong> - Hier werden alle Variablen (Parameter) f√ºr unsere Umgebungen beschrieben. </li></ul><br><p>  Standardm√§√üig haben wir zwei Dateien: </p><br><ul><li>  <strong>environ / base.libsonnet</strong> - enth√§lt allgemeine Parameter f√ºr alle Umgebungen </li><li>  <strong>environ / default.libsonnet</strong> - Enth√§lt Parameter, die f√ºr die <strong>Standardumgebung</strong> √ºberschrieben werden </li></ul><br><p>  √ñffnen wir die <strong>Datei surroundings / base.libsonnet</strong> und f√ºgen dort die Parameter f√ºr unsere erste Komponente hinzu: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">website</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'example-docs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/website:v0.0.1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">ingressClass</span></span>: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span>, <span class="hljs-attr"><span class="hljs-attr">domain</span></span>: <span class="hljs-string"><span class="hljs-string">'docs.example.org'</span></span>, }, }, }</code> </pre> <br><p>  Wir werden auch unsere erste Komponente <strong>components / website.jsonnet</strong> erstellen: </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.website; [ { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'apps/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Deployment'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: params.replicas, <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: { <span class="hljs-attr"><span class="hljs-attr">matchLabels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, }, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: { <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">containers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'darkhttpd'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: params.image, <span class="hljs-attr"><span class="hljs-attr">ports</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: params.containerPort, }, ], }, ], <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: params.nodeSelector, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: params.tolerations, <span class="hljs-attr"><span class="hljs-attr">imagePullSecrets</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'regsecret'</span></span> }], }, }, }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Service'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">ports</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: params.servicePort, <span class="hljs-attr"><span class="hljs-attr">targetPort</span></span>: params.containerPort, }, ], }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'extensions/v1beta1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Ingress'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">annotations</span></span>: { <span class="hljs-string"><span class="hljs-string">'kubernetes.io/ingress.class'</span></span>: params.ingressClass, }, <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: params.domain, <span class="hljs-attr"><span class="hljs-attr">http</span></span>: { <span class="hljs-attr"><span class="hljs-attr">paths</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">backend</span></span>: { <span class="hljs-attr"><span class="hljs-attr">serviceName</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: params.servicePort, }, }, ], }, }, ], }, }, ]</code> </pre> <br><p>  In dieser Datei wurden sofort drei Kubernetes-Entit√§ten beschrieben: <strong>Deployment</strong> , <strong>Service</strong> und <strong>Ingress</strong> .  Auf Wunsch k√∂nnen wir sie in verschiedene Komponenten aufteilen, aber in diesem Stadium reicht uns eine. </p><br><p>  Die Syntax von <strong>jsonnet ist der</strong> von regul√§rem json sehr √§hnlich, im Prinzip ist regul√§res jsonnet bereits g√ºltig. Daher ist es m√∂glicherweise zun√§chst einfacher, Onlinedienste wie <strong>yaml2json</strong> zu verwenden, um Ihr √ºbliches yaml nach json zu konvertieren, oder wenn Ihre Komponenten keine Variablen enthalten Sie k√∂nnen in Form von gew√∂hnlichem Yam beschrieben werden. </p><br><blockquote>  Wenn Sie mit <strong>jsonnet arbeiten,</strong> empfehle <strong>ich</strong> dringend, ein Plugin f√ºr Ihren Editor zu installieren <br><br>  F√ºr vim gibt es beispielsweise ein <strong>vim-jsonnet-Plug-in</strong> , das die Syntaxhervorhebung <strong>aktiviert und bei</strong> jedem <strong>Speichern</strong> automatisch <strong>jsonnet fmt</strong> ausf√ºhrt (dazu muss jsonnet installiert sein). </blockquote><p>  Alles ist fertig, jetzt k√∂nnen wir mit dem Deployment beginnen: </p><br><p>  Um zu sehen, was passiert ist, machen wir Folgendes: </p><br><pre> <code class="bash hljs">qbec show default</code> </pre> <br><p>  Am Ausgang sehen Sie gerenderte Yaml-Manifeste, die auf den Standardcluster angewendet werden. </p><br><p>  Ok, jetzt bewerben: </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><p>  Am Ausgang sehen Sie immer, was in Ihrem Cluster getan wird. Qbec fordert Sie auf, die √Ñnderungen zu akzeptieren. Durch Eingabe von <strong>y k√∂nnen</strong> Sie Ihre Absichten best√§tigen. </p><br><p>  Fertig, jetzt ist unsere Anwendung angedockt! </p><br><p>  Wenn Sie √Ñnderungen vornehmen, k√∂nnen Sie immer Folgendes tun: </p><br><pre> <code class="bash hljs">qbec diff default</code> </pre> <br><p>  um zu sehen, wie sich diese √Ñnderungen auf die aktuelle Bereitstellung auswirken </p><br><p>  Vergessen Sie nicht, unsere √Ñnderungen zu √ºbernehmen: </p><br><pre> <code class="plaintext hljs">cd ../.. git add deploy/website git commit -m "Add deploy for website"</code> </pre> <br><hr><br><h1 id="5-probuem-gitlab-runner-s-kubernetes-executoranchorgitlab-runneranchor">  5. Probieren Sie Gitlab-runner mit Kubernetes-executor aus <a name="gitlab-runner"></a></h1><br><p>  Bis vor kurzem habe ich auf einer vorbereiteten Maschine (LXC-Container) mit Shell oder Docker-Executor nur den √ºblichen <strong>Gitlab-Runner verwendet</strong> .  Anfangs hatten wir mehrere dieser L√§ufer global in unserem Hitlab definiert.  Sie sammelten Docker-Bilder f√ºr alle Projekte. </p><br><p>  Aber wie die Praxis gezeigt hat, ist diese Option sowohl in Bezug auf die Praktikabilit√§t als auch in Bezug auf die Sicherheit nicht optimal.  Es ist viel besser und ideologisch korrekter, f√ºr jedes Projekt und sogar f√ºr jede Umgebung separate L√§ufer einzusetzen. </p><br><p>  Gl√ºcklicherweise ist dies √ºberhaupt kein Problem, da wir <strong>gitlab-runner</strong> jetzt als Teil unseres Projekts direkt auf Kubernetes bereitstellen werden. </p><br><p>  Gitlab bietet ein fertiges Steuerdiagramm f√ºr die Bereitstellung von gitlab-runner in Kubernetes.  Alles was Sie tun m√ºssen, ist das <strong>Registrierungs-Token</strong> f√ºr unser Projekt unter <strong>Einstellungen -&gt; CI / CD -&gt; L√§ufer</strong> herauszufinden und es zu √ºbergeben. </p><br><pre> <code class="bash hljs">helm repo add gitlab https://charts.gitlab.io helm install gitlab-runner \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> gitlabUrl=https://gitlab.com \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> runnerRegistrationToken=yga8y-jdCusVDn_t4Wxc \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> rbac.create=<span class="hljs-literal"><span class="hljs-literal">true</span></span> \ gitlab/gitlab-runner</code> </pre> <br><p>  Wo: </p><br><ul><li>  <strong><a href="https://gitlab.com/" rel="nofollow">https://gitlab.com</a></strong> ist die Adresse Ihres Gitlab-Servers. </li><li>  <strong>yga8y-jdCusVDn_t4Wxc</strong> - Registrierungs-Token f√ºr Ihr Projekt. </li><li>  <strong>rbac.create = true</strong> - Gibt dem L√§ufer die erforderliche Anzahl von Berechtigungen, um Pods f√ºr die Ausf√ºhrung unserer Aufgaben mit dem kubernetes-executor erstellen zu k√∂nnen. </li></ul><br><p>  Wenn alles richtig gemacht ist, sollten Sie den registrierten L√§ufer im Abschnitt <strong>L√§ufer</strong> in den Einstellungen Ihres Projekts sehen. </p><br><div class="spoiler">  <b class="spoiler_title">Screenshot des hinzugef√ºgten L√§ufers</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/at/lx/g_/atlxg_u6rjn4n0pkcpn8--2gare.png"></p></div></div><br><p>  Ist es so einfach  - ja so einfach!  Kein √Ñrger mehr mit der manuellen Registrierung von L√§ufern, von nun an werden L√§ufer automatisch erstellt und zerst√∂rt. </p><br><hr><br><h1 id="6-deploy-helm-chartov-s-qbecanchorqbec-helmanchor">  6. Bereitstellung von Helmkarten mit QBEC <a name="qbec-helm"></a></h1><br><p>  Da wir beschlossen haben, <strong>gitlab-runner als</strong> Teil unseres Projekts zu betrachten, ist es an der Zeit, es in unserem Git-Repository zu beschreiben. </p><br><p>  Wir k√∂nnten es als separate Komponente der <strong>Website bezeichnen</strong> , aber wir planen, in Zukunft sehr oft unterschiedliche Kopien der <strong>Website</strong> <strong>bereitzustellen</strong> , im Gegensatz zu <strong>gitlab-runner</strong> , das f√ºr jeden Kubernetes-Cluster nur einmal bereitgestellt wird.  Also lasst uns eine separate Anwendung daf√ºr initialisieren: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy qbec init gitlab-runner <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> gitlab-runner</code> </pre> <br><p>  Dieses Mal werden wir Kubernetes Entit√§ten nicht manuell beschreiben, sondern ein fertiges Helm-Diagramm erstellen.  Einer der Vorteile von qbec ist die M√∂glichkeit, Helm-Diagramme direkt aus dem Git-Repository zu rendern. </p><br><p>  Lassen Sie es uns mit Git-Submodul einstecken: </p><br><pre> <code class="bash hljs">git submodule add https://gitlab.com/gitlab-org/charts/gitlab-runner vendor/gitlab-runner</code> </pre> <br><p>  Jetzt enth√§lt das Verzeichnis <strong>vendor / gitlab-runner</strong> unser Repository mit einem Diagramm f√ºr gitlab-runner. </p><br><blockquote>  Ebenso k√∂nnen Sie andere Repositorys, beispielsweise das gesamte Repository, mit den offiziellen Charts <strong><a href="https://github.com/helm/charts" rel="nofollow">https://github.com/helm/charts verbinden</a></strong> </blockquote><p>  Beschreiben wir die <strong>Komponente components / gitlab-runner.jsonnet</strong> : </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.gitlabRunner; std.native(<span class="hljs-string"><span class="hljs-string">'expandHelmTemplate'</span></span>)( <span class="hljs-string"><span class="hljs-string">'../vendor/gitlab-runner'</span></span>, params.values, { <span class="hljs-attr"><span class="hljs-attr">nameTemplate</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: env.namespace, <span class="hljs-attr"><span class="hljs-attr">thisFile</span></span>: std.thisFile, <span class="hljs-attr"><span class="hljs-attr">verbose</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, } )</code> </pre> <br><p>  Als erstes Argument f√ºr <strong>expandHelmTemplate √ºbergeben</strong> wir den Pfad zum Diagramm, dann <strong>params.values</strong> , die wir aus den Umgebungsparametern <strong>entnehmen</strong> , und dann ein Objekt mit </p><br><ul><li>  <strong>nameTemplate</strong> - <strong>Versionsname</strong> </li><li>  <strong>Namespace</strong> - Der Namespace wurde an helm √ºbergeben </li><li>  <strong>thisFile</strong> - Erforderlicher Parameter, der den Pfad zur aktuellen Datei √ºbergibt </li><li>  <strong>verbose</strong> - Zeigt den Befehl <strong>helm template</strong> mit allen Argumenten beim Rendern des Diagramms an </li></ul><br><p>  Nun werden wir die Parameter f√ºr unsere Komponente in <strong>environ / base.libsonnet beschreiben</strong> : </p><br><pre> <code class="javascript hljs">local secrets = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../secrets/base.libsonnet'</span></span>; { <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabRunner</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner'</span></span>, <span class="hljs-attr"><span class="hljs-attr">values</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'https://gitlab.com/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">create</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: secrets.runnerRegistrationToken, }, }, }, }</code> </pre> <br><p>  <strong>Beachten Sie</strong> das <strong>runnerRegistrationToken, das</strong> wir aus der <strong>Datei</strong> external <strong>secrets / base.libsonnet</strong> entnehmen. <strong>Erstellen</strong> wir es: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: <span class="hljs-string"><span class="hljs-string">'yga8y-jdCusVDn_t4Wxc'</span></span>, }</code> </pre> <br><p>  √úberpr√ºfen Sie, ob alles funktioniert: </p><br><pre> <code class="bash hljs">qbec show default</code> </pre> <br><p>  Wenn alles in Ordnung ist, k√∂nnen wir unsere fr√ºhere Version √ºber die Helm-Version entfernen: </p><br><pre> <code class="bash hljs">helm uninstall gitlab-runner</code> </pre> <br><p>  und bereitstellen, aber schon √ºber qbec: </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><hr><br><h1 id="7-znakomstvo-s-git-cryptanchorgit-cryptanchor">  7. Einf√ºhrung in Git-Crypt <a name="git-crypt"></a></h1><br><p>  <strong><a href="https://github.com/AGWA/git-crypt" rel="nofollow">Git-Crypt</a></strong> ist ein Tool, mit dem Sie eine transparente Verschl√ºsselung f√ºr Ihr Repository einrichten k√∂nnen. </p><br><p>  Im Moment sieht die Struktur unseres Verzeichnisses f√ºr gitlab-runner so aus: </p><br><pre> <code class="plaintext hljs">. ‚îú‚îÄ‚îÄ components ‚îÇ  ‚îú‚îÄ‚îÄ gitlab-runner.jsonnet ‚îú‚îÄ‚îÄ environments ‚îÇ  ‚îú‚îÄ‚îÄ base.libsonnet ‚îÇ  ‚îî‚îÄ‚îÄ default.libsonnet ‚îú‚îÄ‚îÄ params.libsonnet ‚îú‚îÄ‚îÄ qbec.yaml ‚îú‚îÄ‚îÄ secrets ‚îÇ  ‚îî‚îÄ‚îÄ base.libsonnet ‚îî‚îÄ‚îÄ vendor ‚îî‚îÄ‚îÄ gitlab-runner (submodule)</code> </pre> <br><p>  Geheimnisse in Git aufzubewahren ist aber nicht sicher, oder?  Also m√ºssen wir sie richtig verschl√ºsseln. </p><br><blockquote>  Normalerweise ist dies aus Gr√ºnden einer einzelnen Variablen nicht immer sinnvoll.  Sie k√∂nnen Geheimnisse an <strong>qbec</strong> und √ºber die Umgebungsvariablen Ihres CI-Systems weitergeben. <br>  Es ist jedoch anzumerken, dass es komplexere Projekte gibt, die viel mehr Geheimnisse enthalten k√∂nnen, und es √§u√üerst schwierig sein wird, sie alle durch Umgebungsvariablen zu √ºbertragen. <br><br>  Au√üerdem w√ºrde ich Ihnen in diesem Fall kein so wunderbares Tool wie <strong>Git-Crypt vorstellen k√∂nnen</strong> . <br><br>  <strong>git-crypt ist</strong> auch deshalb praktisch, weil Sie damit den gesamten Verlauf von Geheimnissen speichern sowie Konflikte auf die gleiche Weise vergleichen, zusammenf√ºhren und l√∂sen k√∂nnen, wie wir dies bei Git getan haben. </blockquote><p>  Zun√§chst m√ºssen wir nach der Installation von <strong>git-crypt</strong> Schl√ºssel f√ºr unser Repository generieren: </p><br><pre> <code class="plaintext hljs">git crypt init</code> </pre> <br><p>  Wenn Sie einen PGP-Schl√ºssel haben, k√∂nnen Sie sich sofort als Mitbearbeiter f√ºr dieses Projekt hinzuf√ºgen: </p><br><pre> <code class="plaintext hljs">git-crypt add-gpg-user kvapss@gmail.com</code> </pre> <br><p>  So k√∂nnen Sie dieses Repository jederzeit mit Ihrem privaten Schl√ºssel entschl√ºsseln. </p><br><p>  Wenn Sie keinen PGP-Schl√ºssel haben und dieser nicht erwartet wird, k√∂nnen Sie den Projektschl√ºssel auch in die andere Richtung exportieren: </p><br><pre> <code class="plaintext hljs">git crypt export-key /path/to/keyfile</code> </pre> <br><p>  Auf diese Weise kann jeder mit einer exportierten <strong>Schl√ºsseldatei</strong> Ihr Repository entschl√ºsseln. </p><br><p>  Es ist Zeit, unser erstes Geheimnis aufzubauen. <br>  Ich <strong>m√∂chte</strong> Sie daran erinnern, dass wir uns noch im Verzeichnis <strong>deploy / gitlab-runner /</strong> befinden, in dem sich <strong>das</strong> Verzeichnis <strong>secrets /</strong> befindet. Verschl√ºsseln wir alle darin enthaltenen Dateien. Dazu erstellen wir die <strong>Datei secrets / .gitattributes</strong> mit dem folgenden Inhalt: </p><br><pre> <code class="plaintext hljs">* filter=git-crypt diff=git-crypt .gitattributes !filter !diff</code> </pre> <br><p>  Wie Sie dem Inhalt <strong>entnehmen</strong> k√∂nnen, werden alle Dateien von mask <strong>*</strong> mit Ausnahme von <strong>.gitattributes</strong> selbst √ºber <strong>git-crypt</strong> <strong>ausgef√ºhrt</strong> </p><br><p>  Wir k√∂nnen dies √ºberpr√ºfen, indem wir Folgendes ausf√ºhren: </p><br><pre> <code class="bash hljs">git crypt status -e</code> </pre> <br><p>  Am Ausgang erhalten wir eine Liste aller Dateien im Repository, f√ºr die die Verschl√ºsselung aktiviert ist </p><br><p>  Das ist alles, jetzt k√∂nnen wir unsere √Ñnderungen sicher √ºbernehmen: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../.. git add . git commit -m <span class="hljs-string"><span class="hljs-string">"Add deploy for gitlab-runner"</span></span></code> </pre> <br><p>  Um das Repository zu blockieren, gehen Sie wie folgt vor: </p><br><pre> <code class="bash hljs">git crypt lock</code> </pre> <br><p>  und dann verwandeln sich alle verschl√ºsselten Dateien in etwas Bin√§res, es wird unm√∂glich sein, sie zu lesen. <br>  So entschl√ºsseln Sie ein Repository: </p><br><pre> <code class="bash hljs">git crypt unlock</code> </pre> <br><hr><br><h1 id="8-sozdayom-toolbox-obrazanchortoolboxanchor">  8. Erstellen Sie ein Toolbox-Image <a name="toolbox"></a></h1><br><p>  Ein Toolbox-Image ist ein solches Image mit allen Tools, die wir zum Bereitstellen unseres Projekts verwenden.  Es wird vom gitlab-L√§ufer verwendet, um typische Bereitstellungsaufgaben auszuf√ºhren. </p><br><p>  Alles ist hier einfach, wir erstellen eine neue <strong>Docker-Datei / Toolbox / Dockerfile</strong> mit folgendem Inhalt: </p><br><pre> <code class="bash hljs">FROM alpine:3.11 RUN apk add --no-cache git git-crypt RUN QBEC_VER=0.10.3 \ &amp;&amp; wget -O- https://github.com/splunk/qbec/releases/download/v<span class="hljs-variable"><span class="hljs-variable">${QBEC_VER}</span></span>/qbec-linux-amd64.tar.gz \ | tar -C /tmp -xzf - \ &amp;&amp; mv /tmp/qbec /tmp/jsonnet-qbec /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/ RUN KUBECTL_VER=1.17.0 \ &amp;&amp; wget -O /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/kubectl \ https://storage.googleapis.com/kubernetes-release/release/v<span class="hljs-variable"><span class="hljs-variable">${KUBECTL_VER}</span></span>/bin/linux/amd64/kubectl \ &amp;&amp; chmod +x /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/kubectl RUN HELM_VER=3.0.2 \ &amp;&amp; wget -O- https://get.helm.sh/helm-v<span class="hljs-variable"><span class="hljs-variable">${HELM_VER}</span></span>-linux-amd64.tar.gz \ | tar -C /tmp -zxf - \ &amp;&amp; mv /tmp/linux-amd64/helm /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/helm</code> </pre> <br><p>  Wie Sie sehen, installieren wir in diesem Image alle Dienstprogramme, die wir zum Bereitstellen unserer Anwendung verwendet haben.  Wir brauchen <strong>hier</strong> kein <strong>Kubectl</strong> , aber Sie m√∂chten vielleicht schon beim Einrichten der Pipeline damit spielen. </p><br><p>  Au√üerdem m√ºssen wir die Rolle f√ºr die von gitlab-runner generierten Pods konfigurieren, um mit Kubernetes kommunizieren und ein Deployment durchf√ºhren zu k√∂nnen. </p><br><p>  Gehen Sie dazu mit gitlab-runner in das Verzeichnis: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy/gitlab-runner</code> </pre> <br><p>  und f√ºge eine neue Komponente <strong>components / rbac.jsonnet hinzu</strong> : </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.rbac; [ { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'ServiceAccount'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Role'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">apiGroups</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">resources</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">verbs</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], }, ], }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'RoleBinding'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">roleRef</span></span>: { <span class="hljs-attr"><span class="hljs-attr">apiGroup</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Role'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">subjects</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'ServiceAccount'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: env.namespace, }, ], }, ]</code> </pre> <br><p>  Wir werden auch die neuen Parameter in <strong>environ / base.libsonnet beschreiben</strong> , die jetzt so aussehen: </p><br><pre> <code class="javascript hljs">local secrets = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../secrets/base.libsonnet'</span></span>; { <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabRunner</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner'</span></span>, <span class="hljs-attr"><span class="hljs-attr">values</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'https://gitlab.com/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">create</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: secrets.runnerRegistrationToken, <span class="hljs-attr"><span class="hljs-attr">runners</span></span>: { <span class="hljs-attr"><span class="hljs-attr">serviceAccountName</span></span>: $.components.rbac.name, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/toolbox:v0.0.1'</span></span>, }, }, }, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner-deploy'</span></span>, }, }, }</code> </pre> <br><p>  Hinweis <strong>$ .components.rbac.name</strong> bezieht sich auf den <strong>Namen</strong> der Komponente <strong>rbac</strong> </p><br><p>  Lassen Sie uns √ºberpr√ºfen, was sich ge√§ndert hat: </p><br><pre> <code class="bash hljs">qbec diff default</code> </pre> <br><p>  und wende unsere √Ñnderungen auf Kubernetes an: </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><p>  Vergessen Sie auch nicht, unsere √Ñnderungen an git vorzunehmen: </p><br><pre> <code class="plaintext hljs">cd ../.. git add dockerfiles/toolbox git commit -m "Add Dockerfile for toolbox" git add deploy/gitlab-runner git commit -m "Configure gitlab-runner to use toolbox"</code> </pre> <br><hr><br><h1 id="9-nash-pervyy-payplayn-i-sborka-obrazov-po-tegamanchorpipeline-buildanchor">  9. Unsere erste Pipeline und Assemblierung von Bildern nach Tags <a name="pipeline-build"></a></h1><br><p>  Im Stammverzeichnis des Projekts erstellen wir die <strong>Datei .gitlab-ci.yml</strong> mit folgendem Inhalt: </p><br><pre> <code class="plaintext hljs">.build_docker_image: stage: build image: name: gcr.io/kaniko-project/executor:debug-v0.15.0 entrypoint: [""] before_script: - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" &gt; /kaniko/.docker/config.json build_toolbox: extends: .build_docker_image script: - /kaniko/executor --cache --context $CI_PROJECT_DIR/dockerfiles/toolbox --dockerfile $CI_PROJECT_DIR/dockerfiles/toolbox/Dockerfile --destination $CI_REGISTRY_IMAGE/toolbox:$CI_COMMIT_TAG only: refs: - tags build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_TAG only: refs: - tags</code> </pre> <br><p>  Bitte beachten Sie, dass wir <strong>GIT_SUBMODULE_STRATEGY verwenden: Normal</strong> f√ºr Jobs, bei denen Sie Submodule vor der Ausf√ºhrung explizit initialisieren m√ºssen. </p><br><p>  Vergessen Sie nicht, unsere √Ñnderungen zu √ºbernehmen: </p><br><pre> <code class="plaintext hljs">git add .gitlab-ci.yml git commit -m "Automate docker build"</code> </pre> <br><p>  Ich denke, Sie k√∂nnen es sicher Version <strong>v0.0.1 nennen</strong> und ein Tag h√§ngen: </p><br><pre> <code class="bash hljs">git tag v0.0.1</code> </pre> <br><p>  Wir werden Tags h√§ngen, wenn wir eine neue Version ver√∂ffentlichen m√ºssen.  Tags in Docker-Bildern werden an Git-Tags gebunden.  Jeder Push mit einem neuen Tag initialisiert die Assemblierung von Bildern mit diesem Tag. </p><br><p>  F√ºhren Sie <strong>git push - tags aus</strong> und sehen Sie sich unsere erste Pipeline an: </p><br><div class="spoiler">  <b class="spoiler_title">Screenshot der ersten Pipeline</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5u/ce/fg/5ucefgejcfjz7jpwvou206mwufy.png"></p></div></div><br><blockquote>  Es ist zu beachten, dass das Assemblieren nach Tags zum Assemblieren von Docker-Images geeignet ist, jedoch nicht zum Bereitstellen einer Anwendung in Kubernetes.  Da auch alten Commits neue Tags zugewiesen werden k√∂nnen, f√ºhrt in diesem Fall die Initialisierung der Pipeline f√ºr diese zum Deployment der alten Version. <br><br>  Um dieses Problem zu l√∂sen, werden in der Regel Docker-Images an Tags angeh√§ngt und die Anwendung im <strong>Master-</strong> Zweig bereitgestellt, in dem Versionen der gesammelten Images fest codiert sind.  In diesem Fall k√∂nnen Sie das Rollback mit einem einfachen <strong>Master-</strong> Tag "Zur√ºcksetzen" initialisieren. </blockquote><br><hr><br><h1 id="10-avtomatizaciya-deployaanchorpipeline-deployanchor">  10. Automatisierung der Bereitstellung <a name="pipeline-deploy"></a></h1><br><p>  Damit Gitlab-runner unsere Geheimnisse entschl√ºsseln kann, m√ºssen wir den Repository-Schl√ºssel exportieren und zu den Umgebungsvariablen unseres CIs hinzuf√ºgen: </p><br><pre> <code class="plaintext hljs">git crypt export-key /tmp/docs-repo.key base64 -w0 /tmp/docs-repo.key; echo</code> </pre> <br><p>  Speichern Sie den resultierenden String in Gitlab. Gehen Sie dazu zu den Einstellungen unseres Projekts: <br>  <strong>Einstellungen -&gt; CI / CD -&gt; Variablen</strong> </p><br><p>  Und erstelle eine neue Variable: </p><br><div class="scrollable-table"><table><thead><tr><th>  Typ </th><th>  Schl√ºssel </th><th>  Wert </th><th>  Gesch√ºtzt </th><th>  Maskiert </th><th> Scope </th></tr></thead><tbody><tr><td> <code>File</code> </td> <td> <code>GITCRYPT_KEY</code> </td> <td> <code>&lt;your string&gt;</code> </td> <td> <code>true</code> <em>(     <code>false</code> )</em> </td><td> <code>true</code> </td> <td> <code>All environments</code> </td> </tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/vj/li/ea/vjliealfwwsmiy4-nvjfvcf89ig.png"></p></div></div><br><p>    <strong>.gitlab-ci.yml</strong>   : </p><br><pre> <code class="plaintext hljs">.deploy_qbec_app: stage: deploy only: refs: - master deploy_gitlab_runner: extends: .deploy_qbec_app variables: GIT_SUBMODULE_STRATEGY: normal before_script: - base64 -d "$GITCRYPT_KEY" | git-crypt unlock - script: - qbec apply default --root deploy/gitlab-runner --force:k8s-context __incluster__ --wait --yes deploy_website: extends: .deploy_qbec_app script: - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes</code> </pre> <br><p>        qbec: </p><br><ul><li> <strong>--root some/app</strong> ‚Äî      </li><li> <strong>--force:k8s-context __incluster__</strong> ‚Äî   ,             gtilab-runner.   ,      qbec     Kubernetes-   kubeconfig </li><li> <strong>--wait</strong> ‚Äî  qbec ,        Ready       exit-code. </li><li> <strong>--yes</strong> ‚Äî     <strong>Are you sure?</strong>  . </li></ul><br><p>     : </p><br><pre> <code class="plaintext hljs">git add .gitlab-ci.yml git commit -m "Automate deploy"</code> </pre> <br><p>   <strong>git push</strong>       : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/0p/aj/vs/0pajvs-a-lrxvfuw8zylnj6lleg.png"></p></div></div><br><hr><br><h1 id="11-artefakty-i-sborka-pri-push-v-masteranchorartifactsanchor"> 11.     push  master <a name="artifacts"></a></h1><br><p>            ,             .           digest  master-. </p><br><p>  :    <strong>website</strong>      push  <strong>master</strong> ,       Kubernetes. </p><br><p>        <strong>.gitlab-ci.yml</strong> : </p><br><pre> <code class="plaintext hljs">build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - mkdir -p $CI_PROJECT_DIR/artifacts - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_REF_NAME --digest-file $CI_PROJECT_DIR/artifacts/website.digest artifacts: paths: - artifacts/ only: refs: - master - tags deploy_website: extends: .deploy_qbec_app script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST"</code> </pre> <br><p>  ,    <strong>master</strong>  <strong>refs</strong>   <strong>build_website</strong>     <strong>$CI_COMMIT_REF_NAME</strong>  <strong>$CI_COMMIT_TAG</strong> ,        Git           .  ,        ,           docker-registry. </p><br><p>   docker-       ,        Kubernetes,           ,         . </p><br><p>  <strong>--vm:ext-str digest="$DIGEST"</strong>  qbec ‚Äî      jsonnet.            .   ,     ,     ,               . </p><br><p>     Kaniko  digest    ( <strong>--digest-file</strong> ) <br>          . </p><br><p>     <strong>deploy/website/environments/base.libsonnet</strong>     : </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">website</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'example-docs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/website@'</span></span> + std.extVar(<span class="hljs-string"><span class="hljs-string">'digest'</span></span>), <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">ingressClass</span></span>: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span>, <span class="hljs-attr"><span class="hljs-attr">domain</span></span>: <span class="hljs-string"><span class="hljs-string">'docs.example.org'</span></span>, }, }, }</code> </pre> <br><p> ,     <strong>master</strong>   docker-  <strong>website</strong> ,      Kubernetes. </p><br><p>     : </p><br><pre> <code class="bash hljs">git add . git commit -m <span class="hljs-string"><span class="hljs-string">"Configure dynamic build"</span></span></code> </pre> <br><p> ,  <strong>git push</strong>    - : </p><br><div class="spoiler"> <b class="spoiler_title">   master</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7_/ry/nh/7_rynh5lgu_8hqnnl_gasx73zwq.png"></p></div></div><br><p>       gitlab-runner   push, , ,      ,     <strong>.gitlab-ci.yml</strong> : </p><br><pre> <code class="plaintext hljs">deploy_gitlab_runner: extends: .deploy_qbec_app variables: GIT_SUBMODULE_STRATEGY: normal before_script: - base64 -d "$GITCRYPT_KEY" | git-crypt unlock - script: - qbec apply default --root deploy/gitlab-runner --force:k8s-context __incluster__ --wait --yes only: changes: - deploy/gitlab-runner/**/*</code> </pre> <br><p> <strong>changes</strong>      <strong>deploy/gitlab-runner/</strong>          </p><br><p>     : </p><br><pre> <code class="bash hljs">git add .gitlab-ci.yml git commit -m <span class="hljs-string"><span class="hljs-string">"Reduce gitlab-runner deploy"</span></span></code> </pre> <br><p> <strong>git push</strong> , - : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/-t/9b/3m/-t9b3mtofbunu7xfogpmb0pacsm.png"></p></div></div><br><hr><br><h1 id="12-dynamic-environmentsanchordynamic-environmentsanchor"> 12. Dynamic environments <a name="dynamic-environments"></a></h1><br><p>       . </p><br><p>     <strong>build_website</strong>   <strong>.gitlab-ci.yml</strong> ,     <strong>only</strong> ,   Gitlab        : </p><br><pre> <code class="plaintext hljs">build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - mkdir -p $CI_PROJECT_DIR/artifacts - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_REF_NAME --digest-file $CI_PROJECT_DIR/artifacts/website.digest artifacts: paths: - artifacts/</code> </pre> <br><p>    <strong>deploy_website</strong> ,    <strong>environment</strong> : </p><br><pre> <code class="plaintext hljs">deploy_website: extends: .deploy_qbec_app environment: name: prod url: https://docs.example.org script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST"</code> </pre> <br><p>   Gitlab    <strong>prod</strong>       . </p><br><p>     : </p><br><pre> <code class="plaintext hljs">deploy_website: extends: .deploy_qbec_app environment: name: prod url: https://docs.example.org script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST" deploy_review: extends: .deploy_qbec_app environment: name: review/$CI_COMMIT_REF_NAME url: http://$CI_ENVIRONMENT_SLUG.docs.example.org on_stop: stop_review script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply review --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST" --vm:ext-str subdomain="$CI_ENVIRONMENT_SLUG" --app-tag "$CI_ENVIRONMENT_SLUG" only: refs: - branches except: refs: - master stop_review: extends: .deploy_qbec_app environment: name: review/$CI_COMMIT_REF_NAME action: stop stage: deploy before_script: - git clone "$CI_REPOSITORY_URL" master - cd master script: - qbec delete review --root deploy/website --force:k8s-context __incluster__ --yes --vm:ext-str digest="$DIGEST" --vm:ext-str subdomain="$CI_ENVIRONMENT_SLUG" --app-tag "$CI_ENVIRONMENT_SLUG" variables: GIT_STRATEGY: none only: refs: - branches except: refs: - master when: manual</code> </pre> <br><p>     push     master    preview  . </p><br><p>      qbec: <strong>--app-tag</strong> ‚Äî             ,       Kubernetes qbec    . <br>           review,       . </p><br><p>      <strong>qbec apply review</strong> ,  <strong>qbec apply default</strong> ‚Äî               (review  default): </p><br><p>  <strong>review</strong>   <strong>deploy/website/qbec.yaml</strong> </p><br><pre> <code class="plaintext hljs">spec: environments: review: defaultNamespace: docs server: https://kubernetes.example.org:8443</code> </pre> <br><p>     <strong>deploy/website/params.libsonnet</strong> : </p><br><pre> <code class="javascript hljs">local env = std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>); local paramsMap = { <span class="hljs-attr"><span class="hljs-attr">_</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/base.libsonnet'</span></span>, <span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/default.libsonnet'</span></span>, <span class="hljs-attr"><span class="hljs-attr">review</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/review.libsonnet'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> std.objectHas(paramsMap, env) then paramsMap[env] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> error <span class="hljs-string"><span class="hljs-string">'environment '</span></span> + env + <span class="hljs-string"><span class="hljs-string">' not defined in '</span></span> + std.thisFile</code> </pre> <br><p>        <strong>deploy/website/environments/review.libsonnet</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// this file has the param overrides for the default environment local base = import './base.libsonnet'; local slug = std.extVar('qbec.io/tag'); local subdomain = std.extVar('subdomain'); base { components+: { website+: { name: 'example-docs-' + slug, domain: subdomain + '.docs.example.org', }, }, }</span></span></code> </pre> <br><p>       <strong>stop_review</strong> ,         gitlab    checkout    <strong>GIT_STRATEGY: none</strong> ,    <strong>master</strong> -   review  . <br>  ,        . <br>       review   ,     . </p><br><p>     : </p><br><pre> <code class="plaintext hljs">git add . git commit -m "Enable automatic review"</code> </pre> <br><p> <strong>git push</strong> , <strong>git checkout -b test</strong> , <strong>git push origin test</strong> , : </p><br><div class="spoiler"> <b class="spoiler_title">  environments  Gitlab</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/wc/pz/ce/wcpzcedcwgfqvr0h_thgcw4ylqk.png"></p></div></div><br><p>  ? ‚Äî ,    : <strong>git checkout master</strong> , <strong>git push origin :test</strong> ,      environment   . </p><br><blockquote>    ,        ,     <strong>.gitlab-ci.yml</strong>       . <br>          protected-,   <strong>master</strong> ,        . </blockquote><br><hr><br><h1 id="13-review-appsanchorreview-appsanchor"> 13. Review Apps <a name="review-apps"></a></h1><br><p> <strong><a href="https://docs.gitlab.com/ee/ci/review_apps/" rel="nofollow">Review Apps</a></strong>    ,                . </p><br><p>      ,    <strong>.gitlab/route-map.yml</strong>       ,       : </p><br><pre> <code class="plaintext hljs"># Indices - source: /content\/(.+?)_index\.(md|html)/ public: '\1' # Pages - source: /content\/(.+?)\.(md|html)/ public: '\1/'</code> </pre> <br><p>     : </p><br><pre> <code class="plaintext hljs">git add .gitlab/ git commit -m "Enable review apps"</code> </pre> <br><p> <strong>git push</strong> ,  : </p><br><div class="spoiler"> <b class="spoiler_title">  Review App</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ns/wi/za/nswizajvjjozyoluazo21pzq7t8.png"></p></div></div><br><h1 id="job-is-done"> Job is done! </h1><br><p> <strong> :</strong> </p><br><ul><li>  Gitlab: <a href="" rel="nofollow">https://gitlab.com/kvaps/docs.example.org</a> </li><li>  GitHub: <a href="" rel="nofollow">https://github.com/kvaps/docs.example.org</a> </li></ul><br><p>   ,    <img src="https://habrastorage.org/getpro/habr/post_images/cd7/2c7/9c3/cd72c79c3eeb7355e20bba58e9088654.gif" alt="Bild"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481662/">https://habr.com/ru/post/de481662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481644/index.html">So √ºberleben Sie eine SQL-Datenbank im 21. Jahrhundert: Clouds, Kubernetes und PostgreSQL Multimaster</a></li>
<li><a href="../de481648/index.html">Junos PyEZ am Beispiel der Aufgabe, freie ipv4-Subnetze zu finden</a></li>
<li><a href="../de481652/index.html">Backdoor (?) Auf BlackBerry Android-Smartphones</a></li>
<li><a href="../de481654/index.html">Die Geschichte, wie Ihnen QA Engineer mithilfe von Test IT mithilfe des Bot Frameworks das Leben erleichtert hat</a></li>
<li><a href="../de481656/index.html">PagerDuty oder warum die Operationsabteilung nachts m√∂glicherweise nicht schl√§ft</a></li>
<li><a href="../de481664/index.html">Serverlose Preise und Kosten: AWS Lambda</a></li>
<li><a href="../de481666/index.html">Benutzerdefinierte SwiftLint-Regeln</a></li>
<li><a href="../de481668/index.html">Das erste Problem mit dem Viewer oder die Schwierigkeiten beim Konvertieren von WebRTC-Videostreams in HLS</a></li>
<li><a href="../de481670/index.html">Erstellen Sie einen Aktionsplan mit dem AWS Cloud Adoption Framework</a></li>
<li><a href="../de481672/index.html">Mobilfunkautomaten im Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>