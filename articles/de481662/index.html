<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🍳 🤹🏿 💌 Erprobung neuer Tools zum Erstellen und Automatisieren der Bereitstellung in Kubernetes 👩🏻‍⚖️ 🥌 👏🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! In letzter Zeit wurden viele coole Automatisierungstools zum Erstellen von Docker-Images und für die Bereitstellung auf Kubernetes veröffentlic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erprobung neuer Tools zum Erstellen und Automatisieren der Bereitstellung in Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481662/"><p><img src="https://habrastorage.org/webt/fu/wy/ia/fuwyia7huxrflvry8lzz2dbl2tw.png"></p><br><p>  Hallo!  In letzter Zeit wurden viele coole Automatisierungstools zum Erstellen von Docker-Images und für die Bereitstellung auf Kubernetes veröffentlicht.  In diesem Zusammenhang habe ich mich entschlossen, mit dem Gitlab zu spielen, seine Fähigkeiten zu untersuchen und natürlich die Pipeline zu konfigurieren. </p><br><p>  Die Inspiration für diese Arbeit war die Site <a href="https://kubernetes.io/" rel="nofollow">kubernetes.io</a> , die automatisch aus <a href="http://github.com/kubernetes/website" rel="nofollow">Quellcodes</a> generiert wird. Für jeden gesendeten Pool generiert der Roboter automatisch eine Vorschau-Version der Site mit Ihren Änderungen und bietet einen Link zum Anzeigen. </p><br><p>  Ich habe versucht, einen ähnlichen Prozess von Grund auf neu zu erstellen, der jedoch vollständig auf Gitlab CI und kostenlosen Tools basiert, mit denen ich Anwendungen in Kubernetes bereitgestellt habe.  Heute werde ich Ihnen endlich mehr darüber erzählen. </p><br><p>  In dem Artikel werden Tools wie die folgenden behandelt: <br>  <strong>Hugo</strong> , <strong>qbec</strong> , <strong>kaniko</strong> , <strong>git-crypt</strong> und <strong>GitLab CI</strong> bei der Erstellung dynamischer Umgebungen. </p><a name="habracut"></a><br><hr><br><h1 id="coderzhanie">  Inhalt </h1><br><ol><li>  <a href="https://habr.com/ru/post/481662/"><strong>Wir stellen Hugo vor</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Dockerfile vorbereiten</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Bekanntschaft mit Kaniko</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Wir stellen vor: qbec</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Versucht Gitlab-Runner mit Kubernetes-Executor</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Einsatz von Helmkarten mit qbec</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Einführung in die Git-Krypta</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Erstellen Sie ein Toolbox-Image</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Unsere erste Pipeline und Assemblierung von Bildern nach Tags</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Bereitstellungsautomatisierung</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Artefakte und Push-Build-in-Master</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Dynamische Umgebungen</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>Apps überprüfen</strong></a> </li></ol><br><hr><br><h1 id="1-znakomstvo-s-hugoanchorhugoanchor">  1. Hugo vorstellen <a name="hugo"></a></h1><br><p>  Als Beispiel für unser Projekt werden wir versuchen, eine Website für die Veröffentlichung von Dokumentationen zu erstellen, die auf Hugo basieren.  Hugo ist ein statischer Inhaltsgenerator. </p><br><p>  Für diejenigen, die mit statischen Generatoren nicht vertraut sind, werde ich Ihnen etwas mehr über sie erzählen.  Im Gegensatz zu regulären Datenbank-Site-Engines und einigen PHP-Engines, die nach Aufforderung durch einen Benutzer Seiten im laufenden Betrieb generieren, sind statische Generatoren etwas anders angeordnet.  Sie ermöglichen es Ihnen, die Quelle, in der Regel eine Reihe von Dateien in den Markup- und Designvorlagen von Markdown, zu nehmen und sie dann zu einer vollständig fertigen Site zu kompilieren. </p><br><p>  Das heißt, am Ausgang erhalten Sie eine Verzeichnisstruktur und eine Reihe von generierten HTML-Dateien, die einfach auf jedes billige Hosting hochgeladen werden können und eine funktionierende Site erhalten. </p><br><p>  Hugo kann lokal installiert und ausprobiert werden: </p><br><p>  Wir initialisieren die neue Site: </p><br><pre><code class="bash hljs">hugo new site docs.example.org</code> </pre> <br><p>  Und zur gleichen Zeit das Git-Repository: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> docs.example.org git init</code> </pre> <br><p>  Bisher ist unsere Website makellos und damit etwas darauf erscheint, müssen wir zuerst ein Thema, ein Thema, verknüpfen. Es handelt sich lediglich um eine Reihe von Vorlagen und voreingestellten Regeln, mit denen unsere Website generiert wird. </p><br><p>  Als Thema verwenden wir <a href="https://themes.gohugo.io/hugo-theme-learn/" rel="nofollow"><strong>Learn</strong></a> , das meiner Meinung nach am besten für eine Site mit Dokumentation geeignet ist. </p><br><p>  Ich möchte besonders darauf achten, dass wir keine Themendateien im Repository unseres Projekts speichern müssen, sondern sie einfach mit dem <strong>Git-Submodul verbinden können</strong> : </p><br><pre> <code class="bash hljs">git submodule add https://github.com/matcornic/hugo-theme-learn themes/learn</code> </pre> <br><p>  Daher befinden sich in unserem Repository nur Dateien, die in direktem Zusammenhang mit unserem Projekt stehen, und das verknüpfte Thema bleibt in Form eines Links zu einem bestimmten Repository und wird darin festgeschrieben. Das heißt, es kann immer aus der Originalquelle abgerufen werden und hat keine Angst vor inkompatiblen Änderungen. </p><br><p>  Fix <strong>config.toml</strong> config: </p><br><pre> <code class="plaintext hljs">baseURL = "http://docs.example.org/" languageCode = "en-us" title = "My Docs Site" theme = "learn"</code> </pre> <br><p>  Bereits in dieser Phase können Sie Folgendes ausführen: </p><br><pre> <code class="bash hljs">hugo server</code> </pre> <br><p>  Und unter <a href="http://localhost:1313/" rel="nofollow">http: // localhost: 1313 /</a> überprüfen Sie unsere neu erstellte Site. Alle am Verzeichnis vorgenommenen Änderungen werden automatisch aktualisiert, und die geöffnete Seite im Browser ist sehr praktisch. </p><br><p>  Versuchen wir, ein Deckblatt in <strong>content / _index.md</strong> zu erstellen: </p><br><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section"># My docs site ## Welcome to the docs! You will be very smart :-)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Screenshot der neu erstellten Seite</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/gb/yx/nv/gbyxnvagfs6bks4iqbwcrrovumu.png"></p></div></div><br><p>  Um eine Site zu generieren, führen Sie einfach Folgendes aus: </p><br><pre> <code class="bash hljs">hugo</code> </pre> <br><p>  Der Inhalt des <strong>public /</strong> -Verzeichnisses ist Ihre Site. <br>  Ja, übrigens, fügen wir es sofort zu <strong>.gitignore hinzu</strong> : </p><br><pre> <code class="plaintext hljs">echo /public &gt; .gitignore</code> </pre> <br><p>  Vergessen Sie nicht, unsere Änderungen zu übernehmen: </p><br><pre> <code class="plaintext hljs">git add . git commit -m "New site created"</code> </pre> <br><hr><br><h1 id="2-podgotovka-dockerfileanchordockerfileanchor">  2. Vorbereiten der Docker-Datei <a name="dockerfile"></a></h1><br><p>  Es ist Zeit, die Struktur unseres Repository zu bestimmen.  Normalerweise benutze ich etwas wie: </p><br><pre> <code class="plaintext hljs">. ├── deploy │ ├── app1 │ └── app2 └── dockerfiles ├── image1 └── image2</code> </pre> <br><ul><li>  <strong>dockerfiles /</strong> - enthält Verzeichnisse mit Dockerfiles und allem, was Sie zum Erstellen unserer Docker-Images benötigen. </li><li>  <strong>deploy /</strong> - enthält Verzeichnisse für die Bereitstellung unserer Anwendungen auf Kubernetes </li></ul><br><p>  Daher erstellen wir unser erstes Dockerfile unter dem Pfad <strong>dockerfiles / website / Dockerfile</strong> </p><br><pre> <code class="bash hljs">FROM alpine:3.11 as builder ARG HUGO_VERSION=0.62.0 RUN wget -O- https://github.com/gohugoio/hugo/releases/download/v<span class="hljs-variable"><span class="hljs-variable">${HUGO_VERSION}</span></span>/hugo_<span class="hljs-variable"><span class="hljs-variable">${HUGO_VERSION}</span></span>_linux-64bit.tar.gz | tar -xz -C /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin ADD . /src RUN hugo -s /src FROM alpine:3.11 RUN apk add --no-cache darkhttpd COPY --from=builder /src/public /var/www ENTRYPOINT [ <span class="hljs-string"><span class="hljs-string">"/usr/bin/darkhttpd"</span></span> ] CMD [ <span class="hljs-string"><span class="hljs-string">"/var/www"</span></span> ]</code> </pre> <br><p>  Wie Sie sehen, enthält die Docker-Datei zwei FROMs. Diese Funktion wird als <a href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="nofollow"><strong>mehrstufige Erstellung bezeichnet</strong></a> und ermöglicht es Ihnen, alles Unnötige vom endgültigen Docker-Image auszuschließen. <br>  Daher enthält das endgültige Image nur <strong>darkhttpd</strong> (einen <strong>einfachen</strong> HTTP-Server) und <strong>public /</strong> - den Inhalt unserer statisch generierten Site. </p><br><p>  Vergessen Sie nicht, unsere Änderungen zu übernehmen: </p><br><pre> <code class="plaintext hljs">git add dockerfiles/website git commit -m "Add Dockerfile for website"</code> </pre> <br><hr><br><h1 id="3-znakomstvo-s-kanikoanchorkanikoanchor">  3. Bekanntschaft mit Kaniko <a name="kaniko"></a></h1><br><p>  Als Sammler von Docker-Images habe ich mich für <strong><a href="https://github.com/GoogleContainerTools/kaniko" rel="nofollow">Kaniko entschieden</a></strong> , da für die Arbeit kein Docker-Daemon erforderlich ist. Die Assembly selbst kann auf jedem Computer ausgeführt und der Cache direkt in der Registrierung gespeichert werden, sodass kein dauerhafter Speicher mehr erforderlich ist . </p><br><p>  Um das Image zu erstellen, starten Sie einfach den Container mit <strong>Kaniko Executor</strong> und übergeben Sie den aktuellen Build-Kontext an ihn. Dies können Sie lokal über Docker tun: </p><br><pre> <code class="bash hljs">docker run -ti --rm \ -v <span class="hljs-variable"><span class="hljs-variable">$PWD</span></span>:/workspace \ -v ~/.docker/config.json:/kaniko/.docker/config.json:ro \ gcr.io/kaniko-project/executor:v0.15.0 \ --cache \ --dockerfile=dockerfiles/website/Dockerfile \ --destination=registry.gitlab.com/kvaps/docs.example.org/website:v0.0.1</code> </pre> <br><p>  Dabei ist <strong>registry.gitlab.com/kvaps/docs.example.org/website</strong> der Name Ihres Docker-Image. Nach dem Zusammenbau wird es automatisch in das Docker-Register verschoben. </p><br><p>  Mit <strong>dem</strong> Parameter <strong>--cache</strong> können Sie Layer in der Docker-Registrierung zwischenspeichern. Für das angegebene Beispiel werden sie in <strong>registry.gitlab.com/kvaps/docs.example.org/website/cache</strong> gespeichert. Mit dem Parameter <strong>--cache</strong> können Sie jedoch einen anderen Pfad <strong>angeben repo</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Screenshot Docker-Registry</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/0-/31/qx/0-31qxfta2gk7-colutf2l_qtmm.png"></p></div></div><br><hr><br><h1 id="4-znakomstvo-s-qbecanchorqbecanchor">  4. Bekanntschaft mit qbec <a name="qbec"></a></h1><br><p>  <a href="https://qbec.io/" rel="nofollow">Qbec</a> ist ein Bereitstellungstool, mit dem Sie das Manifest Ihrer Anwendung deklarativ beschreiben und für Kubernetes bereitstellen können.  Durch die Verwendung von Jsonnet als Hauptsyntax können Sie die Beschreibung von Unterschieden für mehrere Umgebungen erheblich vereinfachen und die Code-Wiederholbarkeit nahezu vollständig eliminieren. </p><br><p>  Dies kann insbesondere dann der Fall sein, wenn Sie eine Anwendung in mehreren Clustern mit unterschiedlichen Parametern bereitstellen müssen und diese deklarativ in Git beschreiben möchten. </p><br><p>  Mit Qbec können Sie Helm-Diagramme auch rendern, indem Sie ihnen die erforderlichen Parameter übergeben und sie anschließend ausführen. Außerdem können Sie reguläre Manifeste mit verschiedenen Mutationen erstellen, die auf sie angewendet werden können. Auf diese Weise muss das ChartMuseum nicht mehr verwendet werden.  Das heißt, Sie können Diagramme direkt in git speichern und rendern, wo sie sich befinden. </p><br><p>  Wie ich bereits sagte, speichern wir alle Bereitstellungen im Verzeichnis <strong>deploy /</strong> : </p><br><pre> <code class="bash hljs">mkdir deploy <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy</code> </pre> <br><p>  Initialisieren wir unsere erste Anwendung: </p><br><pre> <code class="bash hljs">qbec init website <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> website</code> </pre> <br><p>  Nun sieht die Struktur unserer Anwendung so aus: </p><br><pre> <code class="plaintext hljs">. ├── components ├── environments │  ├── base.libsonnet │  └── default.libsonnet ├── params.libsonnet └── qbec.yaml</code> </pre> <br><p>  Schauen Sie sich die Datei <strong>qbec.yaml an</strong> : </p><br><pre> <code class="plaintext hljs">apiVersion: qbec.io/v1alpha1 kind: App metadata: name: website spec: environments: default: defaultNamespace: docs server: https://kubernetes.example.org:8443 vars: {}</code> </pre> <br><p>  Hier interessieren uns vor allem <strong>spec.environments</strong> , qbec hat bereits eine Standardumgebung für uns angelegt und die Serveradresse sowie den Namespace aus unserer aktuellen kubeconfig übernommen. <br>  Jetzt wird qbec bei der Bereitstellung in der <strong>Standardumgebung</strong> immer nur im angegebenen Kubernetes-Cluster und im angegebenen Namespace bereitgestellt. Sie müssen also nicht mehr zwischen Kontexten und Namespaces wechseln, um eine Bereitstellung durchzuführen. <br>  Bei Bedarf können Sie die Einstellungen in dieser Datei jederzeit aktualisieren. </p><br><p>  Alle Ihre Umgebungen sind in <strong>qbec.yaml</strong> und in der Datei <strong>params.libsonnet beschrieben</strong> , in der <strong>angegeben</strong> ist, wo Sie die Parameter für diese Umgebungen <strong>festlegen</strong> müssen. </p><br><p>  Als nächstes sehen wir zwei Verzeichnisse: </p><br><ul><li>  <strong>komponenten /</strong> - alle manifeste für unsere anwendung werden hier gespeichert, sie können sowohl in jsonnet als auch in normalen yaml-dateien beschrieben werden </li><li>  <strong>Umgebungen /</strong> - Hier werden alle Variablen (Parameter) für unsere Umgebungen beschrieben. </li></ul><br><p>  Standardmäßig haben wir zwei Dateien: </p><br><ul><li>  <strong>environ / base.libsonnet</strong> - enthält allgemeine Parameter für alle Umgebungen </li><li>  <strong>environ / default.libsonnet</strong> - Enthält Parameter, die für die <strong>Standardumgebung</strong> überschrieben werden </li></ul><br><p>  Öffnen wir die <strong>Datei surroundings / base.libsonnet</strong> und fügen dort die Parameter für unsere erste Komponente hinzu: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">website</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'example-docs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/website:v0.0.1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">ingressClass</span></span>: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span>, <span class="hljs-attr"><span class="hljs-attr">domain</span></span>: <span class="hljs-string"><span class="hljs-string">'docs.example.org'</span></span>, }, }, }</code> </pre> <br><p>  Wir werden auch unsere erste Komponente <strong>components / website.jsonnet</strong> erstellen: </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.website; [ { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'apps/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Deployment'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: params.replicas, <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: { <span class="hljs-attr"><span class="hljs-attr">matchLabels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, }, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: { <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">containers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'darkhttpd'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: params.image, <span class="hljs-attr"><span class="hljs-attr">ports</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: params.containerPort, }, ], }, ], <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: params.nodeSelector, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: params.tolerations, <span class="hljs-attr"><span class="hljs-attr">imagePullSecrets</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'regsecret'</span></span> }], }, }, }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Service'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">ports</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: params.servicePort, <span class="hljs-attr"><span class="hljs-attr">targetPort</span></span>: params.containerPort, }, ], }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'extensions/v1beta1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Ingress'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">annotations</span></span>: { <span class="hljs-string"><span class="hljs-string">'kubernetes.io/ingress.class'</span></span>: params.ingressClass, }, <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: params.domain, <span class="hljs-attr"><span class="hljs-attr">http</span></span>: { <span class="hljs-attr"><span class="hljs-attr">paths</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">backend</span></span>: { <span class="hljs-attr"><span class="hljs-attr">serviceName</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: params.servicePort, }, }, ], }, }, ], }, }, ]</code> </pre> <br><p>  In dieser Datei wurden sofort drei Kubernetes-Entitäten beschrieben: <strong>Deployment</strong> , <strong>Service</strong> und <strong>Ingress</strong> .  Auf Wunsch können wir sie in verschiedene Komponenten aufteilen, aber in diesem Stadium reicht uns eine. </p><br><p>  Die Syntax von <strong>jsonnet ist der</strong> von regulärem json sehr ähnlich, im Prinzip ist reguläres jsonnet bereits gültig. Daher ist es möglicherweise zunächst einfacher, Onlinedienste wie <strong>yaml2json</strong> zu verwenden, um Ihr übliches yaml nach json zu konvertieren, oder wenn Ihre Komponenten keine Variablen enthalten Sie können in Form von gewöhnlichem Yam beschrieben werden. </p><br><blockquote>  Wenn Sie mit <strong>jsonnet arbeiten,</strong> empfehle <strong>ich</strong> dringend, ein Plugin für Ihren Editor zu installieren <br><br>  Für vim gibt es beispielsweise ein <strong>vim-jsonnet-Plug-in</strong> , das die Syntaxhervorhebung <strong>aktiviert und bei</strong> jedem <strong>Speichern</strong> automatisch <strong>jsonnet fmt</strong> ausführt (dazu muss jsonnet installiert sein). </blockquote><p>  Alles ist fertig, jetzt können wir mit dem Deployment beginnen: </p><br><p>  Um zu sehen, was passiert ist, machen wir Folgendes: </p><br><pre> <code class="bash hljs">qbec show default</code> </pre> <br><p>  Am Ausgang sehen Sie gerenderte Yaml-Manifeste, die auf den Standardcluster angewendet werden. </p><br><p>  Ok, jetzt bewerben: </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><p>  Am Ausgang sehen Sie immer, was in Ihrem Cluster getan wird. Qbec fordert Sie auf, die Änderungen zu akzeptieren. Durch Eingabe von <strong>y können</strong> Sie Ihre Absichten bestätigen. </p><br><p>  Fertig, jetzt ist unsere Anwendung angedockt! </p><br><p>  Wenn Sie Änderungen vornehmen, können Sie immer Folgendes tun: </p><br><pre> <code class="bash hljs">qbec diff default</code> </pre> <br><p>  um zu sehen, wie sich diese Änderungen auf die aktuelle Bereitstellung auswirken </p><br><p>  Vergessen Sie nicht, unsere Änderungen zu übernehmen: </p><br><pre> <code class="plaintext hljs">cd ../.. git add deploy/website git commit -m "Add deploy for website"</code> </pre> <br><hr><br><h1 id="5-probuem-gitlab-runner-s-kubernetes-executoranchorgitlab-runneranchor">  5. Probieren Sie Gitlab-runner mit Kubernetes-executor aus <a name="gitlab-runner"></a></h1><br><p>  Bis vor kurzem habe ich auf einer vorbereiteten Maschine (LXC-Container) mit Shell oder Docker-Executor nur den üblichen <strong>Gitlab-Runner verwendet</strong> .  Anfangs hatten wir mehrere dieser Läufer global in unserem Hitlab definiert.  Sie sammelten Docker-Bilder für alle Projekte. </p><br><p>  Aber wie die Praxis gezeigt hat, ist diese Option sowohl in Bezug auf die Praktikabilität als auch in Bezug auf die Sicherheit nicht optimal.  Es ist viel besser und ideologisch korrekter, für jedes Projekt und sogar für jede Umgebung separate Läufer einzusetzen. </p><br><p>  Glücklicherweise ist dies überhaupt kein Problem, da wir <strong>gitlab-runner</strong> jetzt als Teil unseres Projekts direkt auf Kubernetes bereitstellen werden. </p><br><p>  Gitlab bietet ein fertiges Steuerdiagramm für die Bereitstellung von gitlab-runner in Kubernetes.  Alles was Sie tun müssen, ist das <strong>Registrierungs-Token</strong> für unser Projekt unter <strong>Einstellungen -&gt; CI / CD -&gt; Läufer</strong> herauszufinden und es zu übergeben. </p><br><pre> <code class="bash hljs">helm repo add gitlab https://charts.gitlab.io helm install gitlab-runner \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> gitlabUrl=https://gitlab.com \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> runnerRegistrationToken=yga8y-jdCusVDn_t4Wxc \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> rbac.create=<span class="hljs-literal"><span class="hljs-literal">true</span></span> \ gitlab/gitlab-runner</code> </pre> <br><p>  Wo: </p><br><ul><li>  <strong><a href="https://gitlab.com/" rel="nofollow">https://gitlab.com</a></strong> ist die Adresse Ihres Gitlab-Servers. </li><li>  <strong>yga8y-jdCusVDn_t4Wxc</strong> - Registrierungs-Token für Ihr Projekt. </li><li>  <strong>rbac.create = true</strong> - Gibt dem Läufer die erforderliche Anzahl von Berechtigungen, um Pods für die Ausführung unserer Aufgaben mit dem kubernetes-executor erstellen zu können. </li></ul><br><p>  Wenn alles richtig gemacht ist, sollten Sie den registrierten Läufer im Abschnitt <strong>Läufer</strong> in den Einstellungen Ihres Projekts sehen. </p><br><div class="spoiler">  <b class="spoiler_title">Screenshot des hinzugefügten Läufers</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/at/lx/g_/atlxg_u6rjn4n0pkcpn8--2gare.png"></p></div></div><br><p>  Ist es so einfach  - ja so einfach!  Kein Ärger mehr mit der manuellen Registrierung von Läufern, von nun an werden Läufer automatisch erstellt und zerstört. </p><br><hr><br><h1 id="6-deploy-helm-chartov-s-qbecanchorqbec-helmanchor">  6. Bereitstellung von Helmkarten mit QBEC <a name="qbec-helm"></a></h1><br><p>  Da wir beschlossen haben, <strong>gitlab-runner als</strong> Teil unseres Projekts zu betrachten, ist es an der Zeit, es in unserem Git-Repository zu beschreiben. </p><br><p>  Wir könnten es als separate Komponente der <strong>Website bezeichnen</strong> , aber wir planen, in Zukunft sehr oft unterschiedliche Kopien der <strong>Website</strong> <strong>bereitzustellen</strong> , im Gegensatz zu <strong>gitlab-runner</strong> , das für jeden Kubernetes-Cluster nur einmal bereitgestellt wird.  Also lasst uns eine separate Anwendung dafür initialisieren: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy qbec init gitlab-runner <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> gitlab-runner</code> </pre> <br><p>  Dieses Mal werden wir Kubernetes Entitäten nicht manuell beschreiben, sondern ein fertiges Helm-Diagramm erstellen.  Einer der Vorteile von qbec ist die Möglichkeit, Helm-Diagramme direkt aus dem Git-Repository zu rendern. </p><br><p>  Lassen Sie es uns mit Git-Submodul einstecken: </p><br><pre> <code class="bash hljs">git submodule add https://gitlab.com/gitlab-org/charts/gitlab-runner vendor/gitlab-runner</code> </pre> <br><p>  Jetzt enthält das Verzeichnis <strong>vendor / gitlab-runner</strong> unser Repository mit einem Diagramm für gitlab-runner. </p><br><blockquote>  Ebenso können Sie andere Repositorys, beispielsweise das gesamte Repository, mit den offiziellen Charts <strong><a href="https://github.com/helm/charts" rel="nofollow">https://github.com/helm/charts verbinden</a></strong> </blockquote><p>  Beschreiben wir die <strong>Komponente components / gitlab-runner.jsonnet</strong> : </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.gitlabRunner; std.native(<span class="hljs-string"><span class="hljs-string">'expandHelmTemplate'</span></span>)( <span class="hljs-string"><span class="hljs-string">'../vendor/gitlab-runner'</span></span>, params.values, { <span class="hljs-attr"><span class="hljs-attr">nameTemplate</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: env.namespace, <span class="hljs-attr"><span class="hljs-attr">thisFile</span></span>: std.thisFile, <span class="hljs-attr"><span class="hljs-attr">verbose</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, } )</code> </pre> <br><p>  Als erstes Argument für <strong>expandHelmTemplate übergeben</strong> wir den Pfad zum Diagramm, dann <strong>params.values</strong> , die wir aus den Umgebungsparametern <strong>entnehmen</strong> , und dann ein Objekt mit </p><br><ul><li>  <strong>nameTemplate</strong> - <strong>Versionsname</strong> </li><li>  <strong>Namespace</strong> - Der Namespace wurde an helm übergeben </li><li>  <strong>thisFile</strong> - Erforderlicher Parameter, der den Pfad zur aktuellen Datei übergibt </li><li>  <strong>verbose</strong> - Zeigt den Befehl <strong>helm template</strong> mit allen Argumenten beim Rendern des Diagramms an </li></ul><br><p>  Nun werden wir die Parameter für unsere Komponente in <strong>environ / base.libsonnet beschreiben</strong> : </p><br><pre> <code class="javascript hljs">local secrets = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../secrets/base.libsonnet'</span></span>; { <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabRunner</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner'</span></span>, <span class="hljs-attr"><span class="hljs-attr">values</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'https://gitlab.com/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">create</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: secrets.runnerRegistrationToken, }, }, }, }</code> </pre> <br><p>  <strong>Beachten Sie</strong> das <strong>runnerRegistrationToken, das</strong> wir aus der <strong>Datei</strong> external <strong>secrets / base.libsonnet</strong> entnehmen. <strong>Erstellen</strong> wir es: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: <span class="hljs-string"><span class="hljs-string">'yga8y-jdCusVDn_t4Wxc'</span></span>, }</code> </pre> <br><p>  Überprüfen Sie, ob alles funktioniert: </p><br><pre> <code class="bash hljs">qbec show default</code> </pre> <br><p>  Wenn alles in Ordnung ist, können wir unsere frühere Version über die Helm-Version entfernen: </p><br><pre> <code class="bash hljs">helm uninstall gitlab-runner</code> </pre> <br><p>  und bereitstellen, aber schon über qbec: </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><hr><br><h1 id="7-znakomstvo-s-git-cryptanchorgit-cryptanchor">  7. Einführung in Git-Crypt <a name="git-crypt"></a></h1><br><p>  <strong><a href="https://github.com/AGWA/git-crypt" rel="nofollow">Git-Crypt</a></strong> ist ein Tool, mit dem Sie eine transparente Verschlüsselung für Ihr Repository einrichten können. </p><br><p>  Im Moment sieht die Struktur unseres Verzeichnisses für gitlab-runner so aus: </p><br><pre> <code class="plaintext hljs">. ├── components │  ├── gitlab-runner.jsonnet ├── environments │  ├── base.libsonnet │  └── default.libsonnet ├── params.libsonnet ├── qbec.yaml ├── secrets │  └── base.libsonnet └── vendor └── gitlab-runner (submodule)</code> </pre> <br><p>  Geheimnisse in Git aufzubewahren ist aber nicht sicher, oder?  Also müssen wir sie richtig verschlüsseln. </p><br><blockquote>  Normalerweise ist dies aus Gründen einer einzelnen Variablen nicht immer sinnvoll.  Sie können Geheimnisse an <strong>qbec</strong> und über die Umgebungsvariablen Ihres CI-Systems weitergeben. <br>  Es ist jedoch anzumerken, dass es komplexere Projekte gibt, die viel mehr Geheimnisse enthalten können, und es äußerst schwierig sein wird, sie alle durch Umgebungsvariablen zu übertragen. <br><br>  Außerdem würde ich Ihnen in diesem Fall kein so wunderbares Tool wie <strong>Git-Crypt vorstellen können</strong> . <br><br>  <strong>git-crypt ist</strong> auch deshalb praktisch, weil Sie damit den gesamten Verlauf von Geheimnissen speichern sowie Konflikte auf die gleiche Weise vergleichen, zusammenführen und lösen können, wie wir dies bei Git getan haben. </blockquote><p>  Zunächst müssen wir nach der Installation von <strong>git-crypt</strong> Schlüssel für unser Repository generieren: </p><br><pre> <code class="plaintext hljs">git crypt init</code> </pre> <br><p>  Wenn Sie einen PGP-Schlüssel haben, können Sie sich sofort als Mitbearbeiter für dieses Projekt hinzufügen: </p><br><pre> <code class="plaintext hljs">git-crypt add-gpg-user kvapss@gmail.com</code> </pre> <br><p>  So können Sie dieses Repository jederzeit mit Ihrem privaten Schlüssel entschlüsseln. </p><br><p>  Wenn Sie keinen PGP-Schlüssel haben und dieser nicht erwartet wird, können Sie den Projektschlüssel auch in die andere Richtung exportieren: </p><br><pre> <code class="plaintext hljs">git crypt export-key /path/to/keyfile</code> </pre> <br><p>  Auf diese Weise kann jeder mit einer exportierten <strong>Schlüsseldatei</strong> Ihr Repository entschlüsseln. </p><br><p>  Es ist Zeit, unser erstes Geheimnis aufzubauen. <br>  Ich <strong>möchte</strong> Sie daran erinnern, dass wir uns noch im Verzeichnis <strong>deploy / gitlab-runner /</strong> befinden, in dem sich <strong>das</strong> Verzeichnis <strong>secrets /</strong> befindet. Verschlüsseln wir alle darin enthaltenen Dateien. Dazu erstellen wir die <strong>Datei secrets / .gitattributes</strong> mit dem folgenden Inhalt: </p><br><pre> <code class="plaintext hljs">* filter=git-crypt diff=git-crypt .gitattributes !filter !diff</code> </pre> <br><p>  Wie Sie dem Inhalt <strong>entnehmen</strong> können, werden alle Dateien von mask <strong>*</strong> mit Ausnahme von <strong>.gitattributes</strong> selbst über <strong>git-crypt</strong> <strong>ausgeführt</strong> </p><br><p>  Wir können dies überprüfen, indem wir Folgendes ausführen: </p><br><pre> <code class="bash hljs">git crypt status -e</code> </pre> <br><p>  Am Ausgang erhalten wir eine Liste aller Dateien im Repository, für die die Verschlüsselung aktiviert ist </p><br><p>  Das ist alles, jetzt können wir unsere Änderungen sicher übernehmen: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../.. git add . git commit -m <span class="hljs-string"><span class="hljs-string">"Add deploy for gitlab-runner"</span></span></code> </pre> <br><p>  Um das Repository zu blockieren, gehen Sie wie folgt vor: </p><br><pre> <code class="bash hljs">git crypt lock</code> </pre> <br><p>  und dann verwandeln sich alle verschlüsselten Dateien in etwas Binäres, es wird unmöglich sein, sie zu lesen. <br>  So entschlüsseln Sie ein Repository: </p><br><pre> <code class="bash hljs">git crypt unlock</code> </pre> <br><hr><br><h1 id="8-sozdayom-toolbox-obrazanchortoolboxanchor">  8. Erstellen Sie ein Toolbox-Image <a name="toolbox"></a></h1><br><p>  Ein Toolbox-Image ist ein solches Image mit allen Tools, die wir zum Bereitstellen unseres Projekts verwenden.  Es wird vom gitlab-Läufer verwendet, um typische Bereitstellungsaufgaben auszuführen. </p><br><p>  Alles ist hier einfach, wir erstellen eine neue <strong>Docker-Datei / Toolbox / Dockerfile</strong> mit folgendem Inhalt: </p><br><pre> <code class="bash hljs">FROM alpine:3.11 RUN apk add --no-cache git git-crypt RUN QBEC_VER=0.10.3 \ &amp;&amp; wget -O- https://github.com/splunk/qbec/releases/download/v<span class="hljs-variable"><span class="hljs-variable">${QBEC_VER}</span></span>/qbec-linux-amd64.tar.gz \ | tar -C /tmp -xzf - \ &amp;&amp; mv /tmp/qbec /tmp/jsonnet-qbec /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/ RUN KUBECTL_VER=1.17.0 \ &amp;&amp; wget -O /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/kubectl \ https://storage.googleapis.com/kubernetes-release/release/v<span class="hljs-variable"><span class="hljs-variable">${KUBECTL_VER}</span></span>/bin/linux/amd64/kubectl \ &amp;&amp; chmod +x /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/kubectl RUN HELM_VER=3.0.2 \ &amp;&amp; wget -O- https://get.helm.sh/helm-v<span class="hljs-variable"><span class="hljs-variable">${HELM_VER}</span></span>-linux-amd64.tar.gz \ | tar -C /tmp -zxf - \ &amp;&amp; mv /tmp/linux-amd64/helm /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/helm</code> </pre> <br><p>  Wie Sie sehen, installieren wir in diesem Image alle Dienstprogramme, die wir zum Bereitstellen unserer Anwendung verwendet haben.  Wir brauchen <strong>hier</strong> kein <strong>Kubectl</strong> , aber Sie möchten vielleicht schon beim Einrichten der Pipeline damit spielen. </p><br><p>  Außerdem müssen wir die Rolle für die von gitlab-runner generierten Pods konfigurieren, um mit Kubernetes kommunizieren und ein Deployment durchführen zu können. </p><br><p>  Gehen Sie dazu mit gitlab-runner in das Verzeichnis: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy/gitlab-runner</code> </pre> <br><p>  und füge eine neue Komponente <strong>components / rbac.jsonnet hinzu</strong> : </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.rbac; [ { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'ServiceAccount'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Role'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">apiGroups</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">resources</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">verbs</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], }, ], }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'RoleBinding'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">roleRef</span></span>: { <span class="hljs-attr"><span class="hljs-attr">apiGroup</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Role'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">subjects</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'ServiceAccount'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: env.namespace, }, ], }, ]</code> </pre> <br><p>  Wir werden auch die neuen Parameter in <strong>environ / base.libsonnet beschreiben</strong> , die jetzt so aussehen: </p><br><pre> <code class="javascript hljs">local secrets = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../secrets/base.libsonnet'</span></span>; { <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabRunner</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner'</span></span>, <span class="hljs-attr"><span class="hljs-attr">values</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'https://gitlab.com/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">create</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: secrets.runnerRegistrationToken, <span class="hljs-attr"><span class="hljs-attr">runners</span></span>: { <span class="hljs-attr"><span class="hljs-attr">serviceAccountName</span></span>: $.components.rbac.name, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/toolbox:v0.0.1'</span></span>, }, }, }, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner-deploy'</span></span>, }, }, }</code> </pre> <br><p>  Hinweis <strong>$ .components.rbac.name</strong> bezieht sich auf den <strong>Namen</strong> der Komponente <strong>rbac</strong> </p><br><p>  Lassen Sie uns überprüfen, was sich geändert hat: </p><br><pre> <code class="bash hljs">qbec diff default</code> </pre> <br><p>  und wende unsere Änderungen auf Kubernetes an: </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><p>  Vergessen Sie auch nicht, unsere Änderungen an git vorzunehmen: </p><br><pre> <code class="plaintext hljs">cd ../.. git add dockerfiles/toolbox git commit -m "Add Dockerfile for toolbox" git add deploy/gitlab-runner git commit -m "Configure gitlab-runner to use toolbox"</code> </pre> <br><hr><br><h1 id="9-nash-pervyy-payplayn-i-sborka-obrazov-po-tegamanchorpipeline-buildanchor">  9. Unsere erste Pipeline und Assemblierung von Bildern nach Tags <a name="pipeline-build"></a></h1><br><p>  Im Stammverzeichnis des Projekts erstellen wir die <strong>Datei .gitlab-ci.yml</strong> mit folgendem Inhalt: </p><br><pre> <code class="plaintext hljs">.build_docker_image: stage: build image: name: gcr.io/kaniko-project/executor:debug-v0.15.0 entrypoint: [""] before_script: - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" &gt; /kaniko/.docker/config.json build_toolbox: extends: .build_docker_image script: - /kaniko/executor --cache --context $CI_PROJECT_DIR/dockerfiles/toolbox --dockerfile $CI_PROJECT_DIR/dockerfiles/toolbox/Dockerfile --destination $CI_REGISTRY_IMAGE/toolbox:$CI_COMMIT_TAG only: refs: - tags build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_TAG only: refs: - tags</code> </pre> <br><p>  Bitte beachten Sie, dass wir <strong>GIT_SUBMODULE_STRATEGY verwenden: Normal</strong> für Jobs, bei denen Sie Submodule vor der Ausführung explizit initialisieren müssen. </p><br><p>  Vergessen Sie nicht, unsere Änderungen zu übernehmen: </p><br><pre> <code class="plaintext hljs">git add .gitlab-ci.yml git commit -m "Automate docker build"</code> </pre> <br><p>  Ich denke, Sie können es sicher Version <strong>v0.0.1 nennen</strong> und ein Tag hängen: </p><br><pre> <code class="bash hljs">git tag v0.0.1</code> </pre> <br><p>  Wir werden Tags hängen, wenn wir eine neue Version veröffentlichen müssen.  Tags in Docker-Bildern werden an Git-Tags gebunden.  Jeder Push mit einem neuen Tag initialisiert die Assemblierung von Bildern mit diesem Tag. </p><br><p>  Führen Sie <strong>git push - tags aus</strong> und sehen Sie sich unsere erste Pipeline an: </p><br><div class="spoiler">  <b class="spoiler_title">Screenshot der ersten Pipeline</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5u/ce/fg/5ucefgejcfjz7jpwvou206mwufy.png"></p></div></div><br><blockquote>  Es ist zu beachten, dass das Assemblieren nach Tags zum Assemblieren von Docker-Images geeignet ist, jedoch nicht zum Bereitstellen einer Anwendung in Kubernetes.  Da auch alten Commits neue Tags zugewiesen werden können, führt in diesem Fall die Initialisierung der Pipeline für diese zum Deployment der alten Version. <br><br>  Um dieses Problem zu lösen, werden in der Regel Docker-Images an Tags angehängt und die Anwendung im <strong>Master-</strong> Zweig bereitgestellt, in dem Versionen der gesammelten Images fest codiert sind.  In diesem Fall können Sie das Rollback mit einem einfachen <strong>Master-</strong> Tag "Zurücksetzen" initialisieren. </blockquote><br><hr><br><h1 id="10-avtomatizaciya-deployaanchorpipeline-deployanchor">  10. Automatisierung der Bereitstellung <a name="pipeline-deploy"></a></h1><br><p>  Damit Gitlab-runner unsere Geheimnisse entschlüsseln kann, müssen wir den Repository-Schlüssel exportieren und zu den Umgebungsvariablen unseres CIs hinzufügen: </p><br><pre> <code class="plaintext hljs">git crypt export-key /tmp/docs-repo.key base64 -w0 /tmp/docs-repo.key; echo</code> </pre> <br><p>  Speichern Sie den resultierenden String in Gitlab. Gehen Sie dazu zu den Einstellungen unseres Projekts: <br>  <strong>Einstellungen -&gt; CI / CD -&gt; Variablen</strong> </p><br><p>  Und erstelle eine neue Variable: </p><br><div class="scrollable-table"><table><thead><tr><th>  Typ </th><th>  Schlüssel </th><th>  Wert </th><th>  Geschützt </th><th>  Maskiert </th><th> Scope </th></tr></thead><tbody><tr><td> <code>File</code> </td> <td> <code>GITCRYPT_KEY</code> </td> <td> <code>&lt;your string&gt;</code> </td> <td> <code>true</code> <em>(     <code>false</code> )</em> </td><td> <code>true</code> </td> <td> <code>All environments</code> </td> </tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/vj/li/ea/vjliealfwwsmiy4-nvjfvcf89ig.png"></p></div></div><br><p>    <strong>.gitlab-ci.yml</strong>   : </p><br><pre> <code class="plaintext hljs">.deploy_qbec_app: stage: deploy only: refs: - master deploy_gitlab_runner: extends: .deploy_qbec_app variables: GIT_SUBMODULE_STRATEGY: normal before_script: - base64 -d "$GITCRYPT_KEY" | git-crypt unlock - script: - qbec apply default --root deploy/gitlab-runner --force:k8s-context __incluster__ --wait --yes deploy_website: extends: .deploy_qbec_app script: - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes</code> </pre> <br><p>        qbec: </p><br><ul><li> <strong>--root some/app</strong> —      </li><li> <strong>--force:k8s-context __incluster__</strong> —   ,             gtilab-runner.   ,      qbec     Kubernetes-   kubeconfig </li><li> <strong>--wait</strong> —  qbec ,        Ready       exit-code. </li><li> <strong>--yes</strong> —     <strong>Are you sure?</strong>  . </li></ul><br><p>     : </p><br><pre> <code class="plaintext hljs">git add .gitlab-ci.yml git commit -m "Automate deploy"</code> </pre> <br><p>   <strong>git push</strong>       : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/0p/aj/vs/0pajvs-a-lrxvfuw8zylnj6lleg.png"></p></div></div><br><hr><br><h1 id="11-artefakty-i-sborka-pri-push-v-masteranchorartifactsanchor"> 11.     push  master <a name="artifacts"></a></h1><br><p>            ,             .           digest  master-. </p><br><p>  :    <strong>website</strong>      push  <strong>master</strong> ,       Kubernetes. </p><br><p>        <strong>.gitlab-ci.yml</strong> : </p><br><pre> <code class="plaintext hljs">build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - mkdir -p $CI_PROJECT_DIR/artifacts - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_REF_NAME --digest-file $CI_PROJECT_DIR/artifacts/website.digest artifacts: paths: - artifacts/ only: refs: - master - tags deploy_website: extends: .deploy_qbec_app script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST"</code> </pre> <br><p>  ,    <strong>master</strong>  <strong>refs</strong>   <strong>build_website</strong>     <strong>$CI_COMMIT_REF_NAME</strong>  <strong>$CI_COMMIT_TAG</strong> ,        Git           .  ,        ,           docker-registry. </p><br><p>   docker-       ,        Kubernetes,           ,         . </p><br><p>  <strong>--vm:ext-str digest="$DIGEST"</strong>  qbec —      jsonnet.            .   ,     ,     ,               . </p><br><p>     Kaniko  digest    ( <strong>--digest-file</strong> ) <br>          . </p><br><p>     <strong>deploy/website/environments/base.libsonnet</strong>     : </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">website</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'example-docs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/website@'</span></span> + std.extVar(<span class="hljs-string"><span class="hljs-string">'digest'</span></span>), <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">ingressClass</span></span>: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span>, <span class="hljs-attr"><span class="hljs-attr">domain</span></span>: <span class="hljs-string"><span class="hljs-string">'docs.example.org'</span></span>, }, }, }</code> </pre> <br><p> ,     <strong>master</strong>   docker-  <strong>website</strong> ,      Kubernetes. </p><br><p>     : </p><br><pre> <code class="bash hljs">git add . git commit -m <span class="hljs-string"><span class="hljs-string">"Configure dynamic build"</span></span></code> </pre> <br><p> ,  <strong>git push</strong>    - : </p><br><div class="spoiler"> <b class="spoiler_title">   master</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7_/ry/nh/7_rynh5lgu_8hqnnl_gasx73zwq.png"></p></div></div><br><p>       gitlab-runner   push, , ,      ,     <strong>.gitlab-ci.yml</strong> : </p><br><pre> <code class="plaintext hljs">deploy_gitlab_runner: extends: .deploy_qbec_app variables: GIT_SUBMODULE_STRATEGY: normal before_script: - base64 -d "$GITCRYPT_KEY" | git-crypt unlock - script: - qbec apply default --root deploy/gitlab-runner --force:k8s-context __incluster__ --wait --yes only: changes: - deploy/gitlab-runner/**/*</code> </pre> <br><p> <strong>changes</strong>      <strong>deploy/gitlab-runner/</strong>          </p><br><p>     : </p><br><pre> <code class="bash hljs">git add .gitlab-ci.yml git commit -m <span class="hljs-string"><span class="hljs-string">"Reduce gitlab-runner deploy"</span></span></code> </pre> <br><p> <strong>git push</strong> , - : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/-t/9b/3m/-t9b3mtofbunu7xfogpmb0pacsm.png"></p></div></div><br><hr><br><h1 id="12-dynamic-environmentsanchordynamic-environmentsanchor"> 12. Dynamic environments <a name="dynamic-environments"></a></h1><br><p>       . </p><br><p>     <strong>build_website</strong>   <strong>.gitlab-ci.yml</strong> ,     <strong>only</strong> ,   Gitlab        : </p><br><pre> <code class="plaintext hljs">build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - mkdir -p $CI_PROJECT_DIR/artifacts - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_REF_NAME --digest-file $CI_PROJECT_DIR/artifacts/website.digest artifacts: paths: - artifacts/</code> </pre> <br><p>    <strong>deploy_website</strong> ,    <strong>environment</strong> : </p><br><pre> <code class="plaintext hljs">deploy_website: extends: .deploy_qbec_app environment: name: prod url: https://docs.example.org script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST"</code> </pre> <br><p>   Gitlab    <strong>prod</strong>       . </p><br><p>     : </p><br><pre> <code class="plaintext hljs">deploy_website: extends: .deploy_qbec_app environment: name: prod url: https://docs.example.org script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST" deploy_review: extends: .deploy_qbec_app environment: name: review/$CI_COMMIT_REF_NAME url: http://$CI_ENVIRONMENT_SLUG.docs.example.org on_stop: stop_review script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply review --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST" --vm:ext-str subdomain="$CI_ENVIRONMENT_SLUG" --app-tag "$CI_ENVIRONMENT_SLUG" only: refs: - branches except: refs: - master stop_review: extends: .deploy_qbec_app environment: name: review/$CI_COMMIT_REF_NAME action: stop stage: deploy before_script: - git clone "$CI_REPOSITORY_URL" master - cd master script: - qbec delete review --root deploy/website --force:k8s-context __incluster__ --yes --vm:ext-str digest="$DIGEST" --vm:ext-str subdomain="$CI_ENVIRONMENT_SLUG" --app-tag "$CI_ENVIRONMENT_SLUG" variables: GIT_STRATEGY: none only: refs: - branches except: refs: - master when: manual</code> </pre> <br><p>     push     master    preview  . </p><br><p>      qbec: <strong>--app-tag</strong> —             ,       Kubernetes qbec    . <br>           review,       . </p><br><p>      <strong>qbec apply review</strong> ,  <strong>qbec apply default</strong> —               (review  default): </p><br><p>  <strong>review</strong>   <strong>deploy/website/qbec.yaml</strong> </p><br><pre> <code class="plaintext hljs">spec: environments: review: defaultNamespace: docs server: https://kubernetes.example.org:8443</code> </pre> <br><p>     <strong>deploy/website/params.libsonnet</strong> : </p><br><pre> <code class="javascript hljs">local env = std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>); local paramsMap = { <span class="hljs-attr"><span class="hljs-attr">_</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/base.libsonnet'</span></span>, <span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/default.libsonnet'</span></span>, <span class="hljs-attr"><span class="hljs-attr">review</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/review.libsonnet'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> std.objectHas(paramsMap, env) then paramsMap[env] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> error <span class="hljs-string"><span class="hljs-string">'environment '</span></span> + env + <span class="hljs-string"><span class="hljs-string">' not defined in '</span></span> + std.thisFile</code> </pre> <br><p>        <strong>deploy/website/environments/review.libsonnet</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// this file has the param overrides for the default environment local base = import './base.libsonnet'; local slug = std.extVar('qbec.io/tag'); local subdomain = std.extVar('subdomain'); base { components+: { website+: { name: 'example-docs-' + slug, domain: subdomain + '.docs.example.org', }, }, }</span></span></code> </pre> <br><p>       <strong>stop_review</strong> ,         gitlab    checkout    <strong>GIT_STRATEGY: none</strong> ,    <strong>master</strong> -   review  . <br>  ,        . <br>       review   ,     . </p><br><p>     : </p><br><pre> <code class="plaintext hljs">git add . git commit -m "Enable automatic review"</code> </pre> <br><p> <strong>git push</strong> , <strong>git checkout -b test</strong> , <strong>git push origin test</strong> , : </p><br><div class="spoiler"> <b class="spoiler_title">  environments  Gitlab</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/wc/pz/ce/wcpzcedcwgfqvr0h_thgcw4ylqk.png"></p></div></div><br><p>  ? — ,    : <strong>git checkout master</strong> , <strong>git push origin :test</strong> ,      environment   . </p><br><blockquote>    ,        ,     <strong>.gitlab-ci.yml</strong>       . <br>          protected-,   <strong>master</strong> ,        . </blockquote><br><hr><br><h1 id="13-review-appsanchorreview-appsanchor"> 13. Review Apps <a name="review-apps"></a></h1><br><p> <strong><a href="https://docs.gitlab.com/ee/ci/review_apps/" rel="nofollow">Review Apps</a></strong>    ,                . </p><br><p>      ,    <strong>.gitlab/route-map.yml</strong>       ,       : </p><br><pre> <code class="plaintext hljs"># Indices - source: /content\/(.+?)_index\.(md|html)/ public: '\1' # Pages - source: /content\/(.+?)\.(md|html)/ public: '\1/'</code> </pre> <br><p>     : </p><br><pre> <code class="plaintext hljs">git add .gitlab/ git commit -m "Enable review apps"</code> </pre> <br><p> <strong>git push</strong> ,  : </p><br><div class="spoiler"> <b class="spoiler_title">  Review App</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ns/wi/za/nswizajvjjozyoluazo21pzq7t8.png"></p></div></div><br><h1 id="job-is-done"> Job is done! </h1><br><p> <strong> :</strong> </p><br><ul><li>  Gitlab: <a href="" rel="nofollow">https://gitlab.com/kvaps/docs.example.org</a> </li><li>  GitHub: <a href="" rel="nofollow">https://github.com/kvaps/docs.example.org</a> </li></ul><br><p>   ,    <img src="https://habrastorage.org/getpro/habr/post_images/cd7/2c7/9c3/cd72c79c3eeb7355e20bba58e9088654.gif" alt="Bild"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481662/">https://habr.com/ru/post/de481662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481644/index.html">So überleben Sie eine SQL-Datenbank im 21. Jahrhundert: Clouds, Kubernetes und PostgreSQL Multimaster</a></li>
<li><a href="../de481648/index.html">Junos PyEZ am Beispiel der Aufgabe, freie ipv4-Subnetze zu finden</a></li>
<li><a href="../de481652/index.html">Backdoor (?) Auf BlackBerry Android-Smartphones</a></li>
<li><a href="../de481654/index.html">Die Geschichte, wie Ihnen QA Engineer mithilfe von Test IT mithilfe des Bot Frameworks das Leben erleichtert hat</a></li>
<li><a href="../de481656/index.html">PagerDuty oder warum die Operationsabteilung nachts möglicherweise nicht schläft</a></li>
<li><a href="../de481664/index.html">Serverlose Preise und Kosten: AWS Lambda</a></li>
<li><a href="../de481666/index.html">Benutzerdefinierte SwiftLint-Regeln</a></li>
<li><a href="../de481668/index.html">Das erste Problem mit dem Viewer oder die Schwierigkeiten beim Konvertieren von WebRTC-Videostreams in HLS</a></li>
<li><a href="../de481670/index.html">Erstellen Sie einen Aktionsplan mit dem AWS Cloud Adoption Framework</a></li>
<li><a href="../de481672/index.html">Mobilfunkautomaten im Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>