<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÄ üë®üèø‚Äç‚úàÔ∏è ü§µüèΩ No√ß√µes b√°sicas sobre ponteiros para iniciantes üßëüèø‚Äçü§ù‚Äçüßëüèø üíê üë®üèΩ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Hoje, devido ao aprimoramento e baixo custo da tecnologia, a quantidade de mem√≥ria e o poder de processamento est√£o aumentando constan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>No√ß√µes b√°sicas sobre ponteiros para iniciantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456318/"><h2>  1. Introdu√ß√£o </h2><br>  Hoje, devido ao aprimoramento e baixo custo da tecnologia, a quantidade de mem√≥ria e o poder de processamento est√£o aumentando constantemente. <br><br>  De acordo com a Lei de Moore: <br><blockquote>  O n√∫mero de transistores colocados em um chip de circuito integrado dobra a cada 24 meses. </blockquote>  Note-se que dois par√¢metros foram alterados: <br><br><ul><li>  N√∫mero de transistores </li><li>  Dimens√µes do m√≥dulo </li></ul><br>  Os mesmos princ√≠pios s√£o projetados na quantidade de RAM (DRAM). <br><br>  Agora, a quest√£o da mem√≥ria n√£o √© aguda, pois a quantidade de mem√≥ria nos √∫ltimos 10 anos aumentou 16 vezes por dado. <br><a name="habracut"></a><br>  A maioria das linguagens de programa√ß√£o de alto n√≠vel (PL) j√° est√° "pronta para uso", ocultando o trabalho com a mem√≥ria do programador.  E, como essa pergunta estava adormecida, aparece uma nova casta de programadores que n√£o entendem <s>ou n√£o querem entender</s> como funciona o trabalho com mem√≥ria. <br><br>  Neste t√≥pico, consideraremos os principais pontos de trabalho com mem√≥ria usando o exemplo da linguagem C ++, porque √© uma das poucas linguagens imperativas que suporta o trabalho direto com mem√≥ria e suporta OOP. <br><br><h2>  Para que serve a TI? </h2><br><blockquote>  Vale ressaltar aqui, este artigo foi desenvolvido para pessoas que est√£o iniciando seu caminho em C ++ ou que desejam ter uma id√©ia sobre mem√≥ria din√¢mica. </blockquote><br>  Em tempo de execu√ß√£o, qualquer programa reserva um peda√ßo de mem√≥ria para si pr√≥prio na DRAM.  Todo o outro espa√ßo livre de DRAM √© chamado de <u>"Heap"</u> (ingl√™s "Heap").  A aloca√ß√£o de mem√≥ria durante a execu√ß√£o para as necessidades do programa ocorre precisamente a partir da pilha e √© chamada aloca√ß√£o de mem√≥ria din√¢mica. <br><br>  O problema √© que, se voc√™ n√£o limpar a mem√≥ria alocada quando ela n√£o for mais necess√°ria, poder√° ocorrer um vazamento de mem√≥ria, no qual o sistema <u>(programa)</u> simplesmente trava.  Parecido com um carro que parou no meio da estrada porque algu√©m se esqueceu de reabastecer a tempo. <br><br><div class="spoiler">  <b class="spoiler_title">O que voc√™ j√° deve saber</b> <div class="spoiler_text">  Os PLs mais modernos s√£o equipados com coletores de lixo e limpam sua mem√≥ria por conta pr√≥pria. <br>  No entanto, o C ++ se estabeleceu como uma das APIs de desempenho mais r√°pido, em parte porque todo o trabalho com mem√≥ria √© feito manualmente. <br></div></div><br><br><h2>  novo e excluir </h2><br>  A aloca√ß√£o de mem√≥ria pode ser est√°tica e din√¢mica.  A aloca√ß√£o est√°tica da mem√≥ria √© chamada de aloca√ß√£o √∫nica de mem√≥ria durante a compila√ß√£o do programa, e a quantidade de mem√≥ria est√°tica n√£o muda no tempo de execu√ß√£o.  Um exemplo cl√°ssico √© a declara√ß√£o de uma vari√°vel inteira ou matriz.  Mas e se o programador n√£o souber antecipadamente quantos elementos s√£o necess√°rios no cont√™iner? <br>  O uso da mem√≥ria din√¢mica √© aconselh√°vel quando for necess√°rio organizar a aloca√ß√£o de mem√≥ria para as necessidades do programa, conforme necess√°rio. <br>  O <i>novo</i> operador √© respons√°vel por alocar mem√≥ria din√¢mica em C ++ e a <i>exclus√£o</i> √© respons√°vel por limp√°-la. <br>  O <i>novo</i> operador retorna o resultado de sua opera√ß√£o como um ponteiro para uma nova inst√¢ncia da classe. <br>  A sintaxe √© esta: <br><br>  |  <b>ponteiro de tipo de dados (T1)</b> |  *  <b>nome do ponteiro</b> | = <i>novo</i> |  <b>tipo T1</b> |; <br><br>  Ap√≥s o <i>novo</i> operador, voc√™ pode usar o construtor, por exemplo, para inicializar os campos da classe. <br>  Vale ressaltar que o mesmo vazamento de mem√≥ria ocorre exatamente quando o programador perde o controle sobre sua aloca√ß√£o. <br><blockquote>  √â importante lembrar: <br>  Se voc√™ se esqueceu de limpar a mem√≥ria din√¢mica dos elementos desnecess√°rios "gastos", mais cedo ou mais tarde chegar√° um momento cr√≠tico em que simplesmente n√£o haver√° lugar para tirar a mem√≥ria. </blockquote><br>  Um exemplo de aloca√ß√£o de mem√≥ria e sua limpeza: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main{ <span class="hljs-comment"><span class="hljs-comment">// ,       new int *ptr = new int(); //   cout&lt;&lt;*ptr&lt;&lt;endl; // ,     delete ptr; //  delete     ,         return 0; }</span></span></code> </pre> <br><br>  Este artigo n√£o discutir√° os chamados ponteiros "inteligentes", pois o t√≥pico √© muito extenso, mas, resumindo: "Os ponteiros inteligentes automatizam parcialmente o processo de limpeza de mem√≥ria para o programador". <br><br><h2>  Ponteiros </h2><br>  Os ponteiros s√£o respons√°veis ‚Äã‚Äãpor trabalhar com mem√≥ria din√¢mica em C ++.  Este √© um t√≥pico do qual o apetite estraga os iniciantes. <br><br>  Voc√™ pode declarar um ponteiro usando o operador <b>*</b> .  Por padr√£o, ele apontar√° para alguma regi√£o aleat√≥ria da mem√≥ria.  Para que possamos acessar a √°rea de mem√≥ria de que precisamos, precisamos passar um link (operador <b>&amp;</b> ) para a vari√°vel desejada. <br><br>  O ponteiro em si √© simplesmente o endere√ßo de uma c√©lula de mem√≥ria e, para acessar os dados armazenados nessa c√©lula, deve ser desreferenciado. <br><h3>  Retiro importante </h3><br><blockquote>  Se voc√™ tentar exibir o ponteiro sem referenciar, em vez do valor da √°rea de mem√≥ria para a qual aponta, o endere√ßo dessa √°rea de mem√≥ria ser√° exibido. <br>  Para remover a refer√™ncia de um ponteiro, basta colocar o operador <b>*</b> na frente do nome. </blockquote><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,          int* pNum= new int(1) ; cout&lt;&lt;*pNum&lt;&lt;endl; //    ,        ,       (   int   ) pNum++; cout&lt;&lt;*pNum&lt;&lt;endl; // ,         return 0; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/ka/bg/0k/kabg0kkojm0kefvksto7cye60ps.png"><br><br>  Olhando para esses exemplos, eu gostaria de perguntar: "Por que isso √© necess√°rio se voc√™ pode derivar imediatamente uma vari√°vel?" <br><br>  Outro exemplo: <br><br>  Temos uma classe de programadores que descreve os membros de uma equipe de programadores que <s>n√£o sabem sobre ponteiros.</s> <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Programmers</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Programmers(){} Programmers(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iWeight, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iAge){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;weight = iWeight; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;age = iAge; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> weight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     Programmers int size = 9; Programmers *prog [size]; //  Programmers Programmers *ptr = nullptr; //     Programmers       //          for (int i =0;i&lt;size;i++) { ptr=new Programmers(i+100,i); prog[i]=ptr; } return 0; }</span></span></code> </pre> <br>  Dessa maneira, a mem√≥ria pode ser manipulada como quisermos.  E √© por isso que, ao trabalhar com mem√≥ria, voc√™ pode "dar um tiro no pr√≥prio p√©".  Deve-se observar que trabalhar com o ponteiro √© muito mais r√°pido, pois o valor em si n√£o √© copiado, mas apenas um link para um endere√ßo espec√≠fico √© atribu√≠do a ele. <br><br>  A prop√≥sito, uma palavra-chave t√£o popular fornece um ponteiro para o objeto de classe atual.  <s>Esses ponteiros est√£o por toda parte.</s> <br><br>  <b>Um exemplo de ponteiro na vida cotidiana:</b> <br><br>  Imagine uma situa√ß√£o quando voc√™ pede um prato em um restaurante.  Para fazer um pedido, basta apontar para o prato no menu e voc√™ estar√° preparado.  Da mesma forma, outros visitantes do restaurante indicam o item desejado no menu.  Assim, cada linha do menu √© um ponteiro para a fun√ß√£o de cozimento de um prato, e esse ponteiro foi criado no est√°gio de design deste pr√≥prio menu. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de ponteiro de fun√ß√£o</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      void Chicken(){ cout&lt;&lt;"Wait 5 min...Chicken is cooking"&lt;&lt;endl; } void JustWater(){ cout&lt;&lt;"Take your water"&lt;&lt;endl; } int main() { //    void   void (*ptr)(); ptr = Chicken; ptr(); ptr=JustWater; ptr(); return 0; }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ja/kn/0p/jakn0pthuo6au9wx9w_uqlfbd00.png"><br></div></div><br>  De volta aos nossos programadores.  Suponha que agora precisamos levar os campos de classe para a se√ß√£o <b>privada</b> , conforme conv√©m ao princ√≠pio de encapsulamento do OOP, ent√£o precisamos do <b>getter</b> para obter acesso de leitura a esses campos.  Mas imagine que n√£o temos 2 campos, mas 100, e para isso precisamos escrever nosso pr√≥prio acessador para cada um? <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  Bem, claro que n√£o, eu nem entendo por que voc√™ abriu esse spoiler. <br></div></div><br>  Para fazer isso, tornaremos um "acessador" do tipo nulo e passaremos argumentos a ele por refer√™ncia.  O significado de passar um argumento por refer√™ncia √© que o valor do argumento n√£o √© copiado, mas apenas o endere√ßo do argumento real √© transmitido.  Assim, ao alterar o valor desse argumento, os dados na c√©lula de mem√≥ria do argumento atual tamb√©m ser√£o alterados. <br>  Isso tamb√©m afeta o desempenho geral, j√° que passar um argumento por refer√™ncia √© mais r√°pido que passar por valor.  E isso sem mencionar as grandes cole√ß√µes de elementos. <br><br>  Por exemplo, o m√©todo <i>getParams</i> interno alterar√° os argumentos recebidos e os valores, inclusive no escopo, de onde foi chamado. <br>  Um ponteiro nos ajudar√° a navegar na matriz.  A partir da teoria das estruturas de dados, sabemos que uma matriz √© uma regi√£o cont√≠nua da mem√≥ria cujos elementos s√£o organizados um ap√≥s o outro. <br>  Isso significa que, se voc√™ alterar o valor do ponteiro para o n√∫mero de bytes que o elemento ocupa na matriz, poder√° alcan√ßar cada elemento at√© que o ponteiro ultrapasse os limites da matriz. <br>  Crie outro ponteiro que aponte para o primeiro elemento da matriz dos <u>programadores</u> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Programmers</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Programmers(){} Programmers(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iWeight, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iAge){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;weight = iWeight; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;age = iAge; } <span class="hljs-comment"><span class="hljs-comment">//    ,   main     void getParams(int &amp;w, int &amp;a){ w=weight; a=age; } private: int weight; int age; }; int main() { int size = 9; Programmers *prog [size]; Programmers *ptr=nullptr; for (int i =0;i&lt;size;i++) { ptr=new Programmers(i+100,i); prog[i]=ptr; } int w,a; int count = 9; //    //        Programmers **iter = prog; for (int i=0;i&lt;count;i++) { ptr = *iter++; ptr-&gt;getParams(w,a); if(*(iter-1) != nullptr){ delete *(iter-1); ptr = nullptr; } cout&lt;&lt;w&lt;&lt;"\t"&lt;&lt;a&lt;&lt;endl; } return 0; }</span></span></code> </pre><br><img src="https://habrastorage.org/webt/6q/9v/pi/6q9vpiibfo8zddb4znzbfkqcvuu.png"><br><br>  Neste exemplo, quero transmitir a voc√™ a ess√™ncia do fato de que, quando voc√™ altera o valor do endere√ßo do ponteiro, pode acessar outra √°rea da mem√≥ria. <br><br>  Estruturas de dados, como listas, vetores, etc.  com base em ponteiros e, portanto, denominadas estruturas de dados din√¢micas.  E para iterar sobre eles, √© mais correto usar iteradores.  Um iterador √© um ponteiro para um elemento da estrutura de dados e fornece acesso ao elemento do cont√™iner. <br><br><h3>  Em conclus√£o </h3><br>  Tendo entendido o t√≥pico dos ponteiros, trabalhar com mem√≥ria torna-se uma parte agrad√°vel da programa√ß√£o e, como um todo, um entendimento detalhado de como a m√°quina trabalha com a mem√≥ria e como gerenci√°-la.  Em certo sentido, h√° uma filosofia por tr√°s do pr√≥prio conceito de "Trabalhar com a mem√≥ria".  Na ponta dos dedos, voc√™ altera a carga nas placas de capacitores muito pequenos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456318/">https://habr.com/ru/post/pt456318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456304/index.html">Como publicar o utilit√°rio do console no PyPI em 1 minuto</a></li>
<li><a href="../pt456306/index.html">Tecnologias de microeletr√¥nica nos dedos: Lei de Moore, o marketing se move e por que os nan√¥metros n√£o s√£o os mesmos agora. Parte 3</a></li>
<li><a href="../pt456310/index.html">Log√≠stica da a√ß√£o para coleta seletiva de materiais recicl√°veis</a></li>
<li><a href="../pt456314/index.html">Eu tenho raz√£o</a></li>
<li><a href="../pt456316/index.html">Frontend Weekly Digest (10-16 junho 2019)</a></li>
<li><a href="../pt456320/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 369 (10-16 de junho de 2019)</a></li>
<li><a href="../pt456322/index.html">Como tirar o m√°ximo proveito da confer√™ncia. Instru√ß√£o para o menor</a></li>
<li><a href="../pt456332/index.html">PHP Digest No. 158 (3-17 de junho de 2019)</a></li>
<li><a href="../pt456334/index.html">Imortalidade merecida: jogos que n√£o deixavam voc√™ ficar entediado</a></li>
<li><a href="../pt456336/index.html">11 dicas para usar o Redux ao desenvolver aplicativos React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>