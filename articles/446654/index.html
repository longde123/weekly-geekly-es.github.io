<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😶 💣 🍫 Cómo guardamos la revisión del código 👧🏽 🐲 🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Soy un desarrollador líder de Java en Yandex.Money. 


 Cada mañana de trabajo en 2018, recibí unas 30 solicitudes de extracción esperando una revisió...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo guardamos la revisión del código</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/446654/"><p><img src="https://habrastorage.org/webt/6x/su/21/6xsu21mfqcq5d7qqvafxwbmkdgq.png"></p><br><p>  Soy un desarrollador líder de Java en Yandex.Money. </p><br><p>  Cada mañana de trabajo en 2018, recibí unas 30 solicitudes de extracción esperando una revisión, y no tuve tiempo suficiente para ordenarlas todas en un día.  Al final del verano, me fui de vacaciones, y cuando regresé, encontré una fila de 50 relaciones públicas que me asignaron.  No había ganas de rastrillarlos, pero de hecho solo era la punta del iceberg, lo que vi con mis propios ojos.  Ese día decidí que era hora de cambiar algo. </p><br><p>  Esta es la historia de cómo aceleramos la revisión del código, descargamos a los principales desarrolladores y mejoramos las herramientas que usamos todos los días. </p><a name="habracut"></a><br><h2 id="kod-revyu-10-kak-bylo-ranshe">  Revisión de código 1.0.  ¿Cómo estuvo antes? </h2><br><p>  En Yandex.Money, una revisión de código ha sido durante mucho tiempo un paso de desarrollo obligatorio, y todos han estado acostumbrados a ella.  Algunos se dieron cuenta de que esto era tan importante como las pruebas;  otros consideraron esto como un mal necesario, y alguien encontró una revisión de código solo como el autor de las solicitudes de extracción, pero evitó la revisión de código de otra persona.  Creo que muchos han viajado sucesivamente del último al primero, y esto es normal. </p><br><p>  Para la revisión del código, utilizamos Bitbucket desde el principio.  Para cada repositorio de componentes, se agregó una lista de 3-4 revisores predeterminados, que se agregaron a todos los RP.  Por lo general, esta lista fue compilada y editada por el jefe del departamento, y a veces se agregaron allí voluntarios que ellos mismos querían revisar un componente en particular.  En los repositorios de la biblioteca fue un poco más fácil: la lista de revisores fue la misma para todas las bibliotecas, y los desarrolladores senior se incluyeron allí. </p><br><p>  Como resultado, casi toda la carga recayó en los revisores de los desarrolladores senior, que gradualmente dejaron de ser suficientes, teniendo en cuenta el crecimiento del departamento a 60 personas, un aumento en el número de repositorios (más de 60 componentes, más de 100 bibliotecas) y la aceleración de nuestro CI / CD. </p><br><p>  Además de la gran carga de trabajo y la falta de recursos de los revisores, hubo otros problemas: </p><br><ul><li>  en algunos componentes, uno podría esperar una reacción de los revisores por más de un día, </li><li>  alta carga de trabajo de los nombrados como revisores en varios componentes, </li><li>  es difícil atraer nuevos revisores, incluso debido al párrafo anterior, </li><li>  si el revisor principal se enfermó o estuvo de vacaciones, la revisión del código de tiempo de los componentes comenzó a aumentar notablemente, </li><li>  los revisores designados no siempre tenían experiencia real en el componente, debido a esto la calidad de la revisión del código sufrió. </li></ul><br><p>  Antes de resolver estos problemas, debe decidir qué esperamos generalmente de una revisión de código. </p><br><h2 id="pravilnoe-kod-revyu--eto-kak">  La revisión correcta del código es ¿cómo? </h2><br><p>  Hemos identificado cuatro puntos que deberían estar en la revisión de código actualizada: </p><br><ol><li>  <strong>Validar la arquitectura de la solución</strong> .  Cosa bastante obvia.  Esperamos esto de los desarrolladores senior con experiencia en este componente. </li><li>  <strong>Verificación de la implementación técnica</strong> , que también esperamos de especialistas superiores y medios con experiencia en este componente. </li><li>  <strong>La transferencia de conocimiento</strong> , que consiste en el estudio de la lógica empresarial y la base del código por parte de principiantes y junio a través de revisiones de código. </li><li> <strong>Capacidad para evaluar las habilidades difíciles de los desarrolladores</strong> .  Quiero que a cada desarrollador se le asigne un mentor que evalúe el crecimiento, determine el vector de desarrollo, note algunas deficiencias, haga comentarios, etc.  Por lo tanto, el mentor también debería ver el código de sus pupilos. </li></ol><br><p>  Quizás alguien vea otras metas o no esté de acuerdo con la nuestra: comparta en los comentarios.  Mientras tanto, pasaré de la formulación de objetivos a la búsqueda de medios para alcanzarlos; decidimos que queremos alcanzarlos todos y (casi) de inmediato. </p><br><h2 id="kod-revyu-20-kak-stalo">  Revisión de código 2.0.  Como es </h2><br><p>  ¿Qué se nos ocurrió?  Comenzamos a razonar paso a paso. </p><br><p>  En Yandex.Money, los desarrolladores trabajan en equipos en áreas de negocios, generalmente de 2 a 4 desarrolladores en un equipo. </p><br><p>  Digamos que voy a abrir una solicitud de extracción, es decir, soy su <strong>autor</strong> .  Tengo <strong>mi equipo</strong> , cuyos desarrolladores son conscientes de la lógica empresarial de lo que estoy haciendo, porque todos participamos en proyectos comunes, a menudo sincronizamos y generalmente interactuamos activamente.  Por lo tanto, primero quiero agregarlos a mis solicitudes de extracción, para que al menos estén al día con lo que estoy haciendo. </p><br><p>  Cada componente en Yandex.Money tiene un equipo que es responsable y lo acompaña en la producción. </p><br><p>  Si modifico un componente del que es responsable otro equipo, entonces parece lógico agregar desarrolladores de este equipo a los revisores: son responsables de este componente y deben monitorear la calidad de su código.  Pero para no sobrecargar a los revisores, solo tomamos una persona aleatoria de este equipo; creemos que esto es suficiente. </p><br><p>  Puede suceder que el <strong>equipo responsable del componente</strong> no tenga suficiente experiencia en él.  Esto sucede cuando los recién llegados aparecen en el equipo o se les ha confiado este componente solo recientemente.  Sin embargo, sé que tenemos expertos reales en esta compañía en este repositorio, ¡y sería genial si uno de ellos mirara mi código!  Por supuesto, mi conocimiento es difícil de formalizar, pero puede tomar el historial del repositorio y calcular la revisión del código en función del número de RP y estadísticas, que trabajaron mucho en este código y / o lo revisaron mucho.  Calculamos la métrica de experiencia en el repositorio, seleccionamos los mejores desarrolladores para esta métrica, los llamamos <strong>expertos</strong> y agregamos un experto aleatorio a los revisores. </p><br><p>  En 2018, presentamos el instituto de mentoría en la empresa, por lo que ahora un mentor entre los desarrolladores senior está observando a cada equipo.  Además, cada recién llegado a la empresa al principio tiene un mentor personal. </p><br><p>  ¡Deje que mi mentor mire mi código!  Podrá ayudar en caso de problemas en la revisión del código, y también tendrá una idea de mis fortalezas y debilidades en las habilidades técnicas. </p><br><p><img src="https://habrastorage.org/webt/li/vz/hm/livzhmai-uj6ykbxn3g2jpgqqbm.png"></p><br><p>  En total, se pueden agregar de cinco a seis personas a los revisores de cada solicitud de extracción.  Pero, de hecho, generalmente son un poco más pequeños, porque se pueden combinar diferentes roles en una sola persona.  Mi mentor puede ser un experto al mismo tiempo, y mi equipo puede ser responsable del componente.  Subjetivamente, 3-4 revisores serían óptimos para las solicitudes de extracción. </p><br><h2 id="kod-revyu-20-chto-pod-kapotom">  Revisión de código 2.0.  ¿Qué hay debajo del capó? </h2><br><p>  El punto es pequeño: haz que todo funcione.  Aquí ayudó que todas nuestras alineaciones ya estuvieran configuradas en un sistema separado que proporciona la API REST para recibirlas.  Por lo tanto, después de un par de semanas de desarrollo pausado en mi tiempo libre, nació la primera versión del complemento para Bitbucket, que se desarrolló gradualmente y adquirió todo el conjunto de funcionalidades necesarias durante el otoño. </p><br><h4 id="kak-rabotaet-plagin">  Cómo funciona el complemento </h4><br><p>  Normalmente, al crear un PR, Bitbucket rellena previamente los visores que se especifican en la configuración del proyecto o repositorio.  Desde el punto de vista del usuario, nada ha cambiado aquí: todos los revisores también se rellenan previamente cuando se abre esta página, excepto que se ha agregado un campo con una descripción de qué revisor en qué rol se agregó.  Y los roles de los revisores han aparecido de la siguiente manera: </p><br><ul><li>  teammate es miembro del equipo del autor de relaciones públicas, se agrega fácilmente gracias a la API REST con composiciones de equipo, </li><li>  propietario del repositorio: un miembro aleatorio del equipo responsable del componente;  en la configuración del repositorio era necesario dar la oportunidad de elegir el equipo responsable, </li><li>  experto en repositorios - experto en repositorios aleatorio;  Te contaré más sobre esto más tarde </li><li>  mentor: un mentor para un equipo o un principiante, también está disponible a través de la API REST de un servicio con composiciones de equipo. </li></ul><br><h4 id="eksperty-po-repozitoriyam">  Expertos en repositorios </h4><br><p>  Te contaré un poco más sobre cómo consideramos expertos.  Todos los días, el complemento pasa por todos los repositorios, analiza todas las solicitudes de extracción del último año y considera dos métricas simples: </p><br><ul><li>  la cantidad de solicitudes de extracción creadas por el desarrollador, </li><li>  el número de RP que revisó y estableció aprobar, necesita trabajo o rechazar. </li></ul><br><p>  Agregamos ponderaciones a estas métricas basadas en el hecho de que desde el punto de vista de la experiencia en el código, el refinamiento de este código es más importante que la revisión.  Primero, estimamos el número de solicitudes de extracción creadas una vez y media más importante que una revisión, y luego aumentamos la proporción de tres a uno.  Resumimos las métricas multiplicadas por sus pesos y obtenemos la calificación de desarrollador. </p><br><p>  A continuación, clasificamos a todos estos desarrolladores por calificación, seleccionamos los 5 mejores, en el camino, cortamos a aquellos cuya calificación está por debajo del umbral para cortar a los transeúntes ocasionales.  Y generalmente tenemos de tres a cinco expertos para cada repositorio. </p><br><p>  Arriba, le describí el enfoque para la selección de revisores, que elegimos e implementamos, pero a lo largo del camino implementamos varias pequeñas mejoras a la vez, lo que hizo que el proceso de revisión del código sea aún más rápido, más conveniente y más agradable. </p><br><h4 id="zapret-merge-pull-rekvesta-poka-ne-proverena-zadacha-v-jira">  Prohibir solicitud de extracción de fusión hasta que la tarea se haya registrado en Jira </h4><br><p>  Una cosa tan obvia y necesaria que, desafortunadamente, no sale de la caja.  Solo obtenemos código estable en dev, que no solo pasó las comprobaciones estáticas y las pruebas de desarrollador, sino también las pruebas de integración junto con otros servicios.  El estado de tales pruebas para nosotros se refleja solo en la tarea de Jira y, por lo tanto, antes, los desarrolladores tenían que ver manualmente si la tarea estaba marcada para ralentizar la solicitud de extracción. </p><br><h4 id="avtomaticheskiy-merge-pull-rekvestov">  Solicitud de extracción automática de fusión </h4><br><p>  La solicitud de extracción puede pasar una parte considerable de su vida en un estado en el que nada le impide tomarse el tiempo, pero una persona se olvida de hacerlo o no lo hace de inmediato.  Un ejemplo sorprendente es la expectativa de probar una tarea, sin la cual no la mantenemos en desarrollo.  Aquí es donde resulta útil una fusión automática, que funciona de acuerdo con un principio simple: si las relaciones públicas pueden congelarse, entonces lo hacemos. </p><br><p>  Todas las condiciones necesarias para la fusión están cubiertas por cheques.  Verificamos el éxito del ensamblaje, el nivel de cobertura de la prueba, la ausencia de dependencias de instantáneas de las bibliotecas, el estado de la tarea en Jira y la presencia de todas las actualizaciones necesarias.  Es decir, tenemos todo para usar dicha funcionalidad y olvidarnos de las relaciones públicas desde el momento de pasar la revisión del código y enviar la tarea a la prueba (a menos que, por supuesto, el control de calidad encuentre problemas en ella). </p><br><p>  E implementamos esto de una manera bastante conveniente: introdujimos un bot especial AutoMergeBot, que solo necesitamos agregar a los revisores, para que pueda comenzar a monitorear esta solicitud de extracción y congelarla cuando llegue el momento. </p><br><h4 id="uchet-otsutstviy-revyuerov">  Contabilización de la ausencia de revisores. </h4><br><p>  Si el propietario o experto del componente está de vacaciones o de baja por enfermedad, el revisor no lo agregará, y su lugar lo ocupará el que esté en el lugar de trabajo.  Como beneficio adicional, una montaña de solicitudes de atracción de otras personas no caerá en este crítico al salir de las vacaciones.  Darse cuenta de esto no fue difícil debido al hecho de que toda la falta de empleados con nosotros se presentó con solicitudes en Jira. </p><br><h4 id="uchet-zanyatosti-revyuerov">  Contabilidad para el empleo de revisores </h4><br><p>  Alguien revisa diez relaciones públicas al día, y unos cinco.  Alguien ya ha acumulado 20 relaciones públicas no vistas, mientras que alguien casi no tiene ninguno.  Tomamos todo esto en cuenta para distribuir la carga de manera más uniforme en los revisores.  Cuanta más carga, menos se agrega a los nuevos RP, todo es simple. </p><br><h4 id="markirovka-razmerov-pr-pri-sozdanii">  Marcar tamaños de relaciones públicas al crear </h4><br><p>  En la página de creación de solicitud de extracción, el autor puede elegir su tamaño aproximado: S, M o L. Esto ayuda a los revisores a estimar el tiempo aproximado que pasarán en la revisión del código.  Por ejemplo, tengo 5 minutos libres, y entiendo que puedo lograr ver la solicitud de extracción de tamaño S. No tiene sentido abrir M o L, porque no tengo tiempo para verlos y la próxima vez tendré que empezar desde cero. </p><br><p>  En el futuro, queremos tener en cuenta estos atributos al calcular las estadísticas de relaciones públicas. </p><br><h4 id="markirovka-srochnyh-pr">  Etiquetado Urgente PR </h4><br><p>  Además, al crear un PR, el autor puede indicar que la tarea es muy urgente al agregar dicho símbolo al nombre PR.  Los revisores lo verán de inmediato e intentarán verlo primero.  Parece ser un poco, pero muy útil y conveniente. </p><br><h4 id="treking-nachala-i-okonchaniya-kod-revyu">  Seguimiento de revisión de código de inicio y finalización </h4><br><p>  Si al mejorar el proceso es imposible entender cuánto ha mejorado, entonces no tiene sentido comenzar. </p><br><p>  Lo mismo ocurre con la revisión del código: podemos intentar mejorarlo tanto como queramos, pero ¿cómo nos aseguraremos de una dinámica positiva sin métricas y estadísticas?  En nuestro caso, esta no es la tarea más fácil: fuera de la caja, Bitbucket y Jira no dieron la oportunidad de rastrear el tiempo de revisión del código.  Solo teníamos la métrica de vida útil de relaciones públicas en servicio, lo que no nos convenía del todo, porque solo retiramos la solicitud después de que se completa la prueba de la tarea, por lo tanto, los indicadores extraños se mezclaron en esta métrica. </p><br><p>  Jira almacena y le permite cargar todos los puntos de control del ciclo de vida de la tarea, por lo que pensamos que es correcto enriquecer estos datos con dos etiquetas adicionales: la hora de inicio y finalización de la revisión del código.  Solo era necesario enseñarle al plugin para que Bitbucket pusiera estas etiquetas en Jira.  Por lo tanto, Jira fue, y sigue siendo, un único punto de verdad para la tarea, y con este conjunto de datos podemos separar el tiempo de la revisión del código del momento de probar la tarea. </p><br><p>  El punto más delgado aquí es cómo determinar cuándo finalizar una revisión de código.  ¿Tal vez este es el momento de obtener la primera aplicación, tal vez la última, o tal vez este es el momento de los últimos cambios realizados por el autor de PR?  No tengo una respuesta a esta pregunta, aquí solo necesito estar de acuerdo entre nosotros y elegir una cosa o cubrir los tres eventos con métricas y seguir las desviaciones. </p><br><h4 id="treking-zagruzki-revyuerov">  Seguimiento de descargas de revisores </h4><br><p>  Otra métrica útil es la carga de trabajo de los revisores.  Como escribí anteriormente, lo tenemos en cuenta al asignar revisores a nuevos RP, pero también publicamos esta información para monitorear la dinámica de los equipos, departamentos o empresas.  A veces, esto ayuda a detectar anomalías y posibles problemas: si está claro que una o más personas en un equipo cuelgan 10 o más RP no vistos todos los días, entonces hay una razón para averiguar si todo está en orden. </p><br><h4 id="prosmotr-metrik-v-grafana">  Ver métricas en Grafana </h4><br><p>  La creación de informes sobre datos de Jira es útil, pero no muy conveniente, por lo que también agregamos el envío de métricas para los principales eventos en StatsD con el fin de crear gráficos sobre datos operativos en Grafana.  Monitoreamos el tiempo promedio hasta la primera prueba, el tiempo de vida promedio del RP, y también observamos los valores anómalos de estas métricas para encontrar y resolver problemas rápidamente. </p><br><p>  Al momento de escribir, nuestro tablero se ve así: </p><br><p><img src="https://habrastorage.org/webt/7t/ci/q0/7tciq07igrzqnejdy0cir6smqks.png"></p><br><h1 id="chto-poluchili-v-itoge">  ¿Qué obtuviste al final? </h1><br><p>  Desafortunadamente, todos somos fuertes en retrospectiva, por lo que no presentamos las métricas de revisión de código mencionadas anteriormente antes de que el proceso en sí comenzara a cambiar (septiembre-octubre de 2018), pero ya en el camino, por lo que solo podemos rastrear de manera confiable las mejoras o deterioros desde principios de diciembre de 2018 ¿Qué logramos notar? </p><br><p>  Lo primero que llama la atención es la reducción de la carga en los revisores superiores, y sentí esto con mi propio ejemplo.  Como ya mencioné, era normal para mí ver unos 30 RP en línea por la mañana, pero ahora este número fluctúa entre 10 y 15. Las estadísticas del departamento lo confirman: desde diciembre de 2018, nadie ha aumentado el número máximo de RP que esperan una revisión. arriba 15. En promedio, observamos una imagen que sugiere que, en promedio, cada desarrollador espera de 4 a 5 relaciones públicas no vistas por la mañana, lo que parece ser un número bastante adecuado. </p><br><p><img src="https://habrastorage.org/webt/g9/a6/aj/g9a6ajl7hnnuaizyigu7rcjkoqo.png"></p><br><p>  En cuanto a la relevancia de la selección de revisores y la calidad de la revisión del código, aquí solo podemos confiar en indicadores subjetivos.  De acuerdo con las encuestas de colegas, realmente comenzamos a obtener una excelente selección de revisores, ahora nadie tiene que agregar manualmente y no se dejan abandonados ni olvidados los RP. </p><br><p><img src="https://habrastorage.org/webt/mc/jw/7q/mcjw7qch8z_30nfwtc3c5i3at68.png"></p><br><p>  Si hablamos sobre el tiempo que lleva pasar la revisión del código, entonces es demasiado pronto para calcular estadísticas sobre este indicador, porque comenzamos a recopilarlo recientemente.  A nuestra disposición solo existe el tiempo de vida de las solicitudes de extracción, que en realidad no aumentó ni disminuyó.  Esta métrica incluye el tiempo de prueba de la tarea, por lo que es difícil sacar conclusiones claras al respecto, además, al cambiar el código de revisión, no lo hicimos más largo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446654/">https://habr.com/ru/post/446654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446638/index.html">Cisco HyperFlex vs. competidores: pruebas de rendimiento</a></li>
<li><a href="../446640/index.html">20 proyectos, 20 idiomas, fecha límite ayer. Parte 2</a></li>
<li><a href="../446642/index.html">Lista de verificación para crear y publicar aplicaciones web</a></li>
<li><a href="../446644/index.html">Cómo ejecutar SMM en 2019: 17 diagramas de Neil Patel</a></li>
<li><a href="../446648/index.html">Desarrollo de operadores de Kubernetes con Operator Framework</a></li>
<li><a href="../446656/index.html">Codificación de voz de 1600 bits / s con codificador de voz neural LPCNet</a></li>
<li><a href="../446658/index.html">Entrevista con Andrei Stankevich sobre programación deportiva.</a></li>
<li><a href="../446660/index.html">IA, estudiante y gran premio: cómo hacer aprendizaje automático en octavo grado</a></li>
<li><a href="../446662/index.html">Transacciones y mecanismos para su control.</a></li>
<li><a href="../446664/index.html">¡SAP Forum 2019 está a solo 2 semanas! ¿Qué habrá allí?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>