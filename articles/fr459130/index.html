<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏻 👩🏽‍🔬 ✍🏻 Traitement des erreurs en douceur dans les microservices 👩🏿‍🍳 👨🏻‍🎓 💃🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article montre comment implémenter la gestion des erreurs et la journalisation sur la base du principe "Made and Forgot" dans Go. La méthode est con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Traitement des erreurs en douceur dans les microservices</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459130/"><p>  L'article montre comment implémenter la gestion des erreurs et la journalisation sur la base du principe "Made and Forgot" dans Go.  La méthode est conçue pour les microservices sur Go, fonctionnant dans un conteneur Docker et construite conformément aux principes de l'architecture propre. </p><a name="habracut"></a><br><p>  Cet article est une version détaillée d'un rapport de la récente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réunion de Go à Kazan</a> .  Si vous êtes intéressé par Go et que vous vivez à Kazan, Innopolis, la belle Yoshkar-Ola ou dans une autre ville à proximité, vous devriez visiter la page de la communauté: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">golangkazan.github.io</a> . </p><br><p>  Lors de la réunion, notre équipe dans deux rapports a montré comment nous développons des microservices sur Go - quels principes nous suivons et comment nous simplifions nos vies.  Cet article se concentre sur notre concept de gestion des erreurs, que nous étendons maintenant à tous nos nouveaux microservices. </p><br>
<h2 id="soglasheniya-o-strukture-mikroservisa">  Accords de structure de microservices </h2><br><p>  Avant d'aborder les règles de gestion des erreurs, il convient de décider quelles restrictions nous observons lors de la conception et du codage.  Pour ce faire, il convient de dire à quoi ressemblent nos microservices. </p><br><p>  Tout d'abord, nous respectons une architecture propre.  Nous divisons le code en trois niveaux et observons la règle de dépendance: les packages à un niveau plus profond sont indépendants des packages externes et il n'y a pas de dépendances cycliques.  Heureusement, les dépendances directes de tourniquet des packages sont interdites dans Go.  Des dépendances indirectes via la terminologie d'emprunt, des hypothèses sur le comportement ou la conversion en un type peuvent toujours apparaître, elles doivent être évitées. </p><br><p>  Voici à quoi ressemblent nos niveaux: </p><br><ol><li>  Le niveau de domaine contient des règles de logique métier dictées par le domaine. <br><ul><li>  parfois on se passe de domaine si la tâche est simple </li><li>  <em>règle: le</em> code au niveau du domaine dépend uniquement des capacités de Go, de la bibliothèque Go standard et des bibliothèques sélectionnées qui étendent la langue Go </li></ul></li><li>  La couche d'application contient des règles de logique métier dictées par les tâches de l'application. <br><ul><li>  <em>règle: le</em> code au niveau de l'application peut dépendre du domaine </li></ul></li><li>  Le niveau d'infrastructure contient le code d'infrastructure qui connecte l'application à diverses technologies de stockage (MySQL, Redis), de transport (GRPC, HTTP), d'interaction avec l'environnement externe et avec d'autres services <br><ul><li>  <em>règle: le</em> code au niveau de l'infrastructure peut dépendre du domaine et de l'application </li><li>  <em>règle:</em> une seule technologie par package Go </li></ul></li><li>  Le paquet principal crée tous les objets - "singleton à vie", les connecte ensemble et lance des coroutines à longue durée de vie - par exemple, il commence à traiter les requêtes HTTP à partir du port 8081 </li></ol><br><p>  Voici à quoi ressemble l'arborescence de répertoires du microservice (la partie où se trouve le code Go): </p><br><p><img src="https://habrastorage.org/webt/dk/ft/id/dkftidhxmqh30yy9zbdaeajfbgy.png" alt="Image: Aller à l'arborescence du projet"></p><br><p>  Pour chacun des contextes d'application (modules), la structure du package ressemble à ceci: </p><br><ul><li> le package d'application déclare une interface de service qui contient toutes les actions possibles à un niveau donné qui implémente l'interface de structure de service et la fonction <code>func NewService(...) Service</code> </li><li>  l'isolation du travail avec la base de données est obtenue du fait que le domaine ou le package d'application déclare l'interface Repository, qui est implémentée au niveau de l'infrastructure dans le package avec le nom visuel "mysql" </li><li>  le code de transport se trouve dans le paquet <code>infrastructure/transport</code> <br><ul><li>  nous utilisons GRPC, donc les talons de serveur sont générés à partir du fichier proto (c'est-à-dire l'interface du serveur, les structures de réponse / demande et tout le code d'interaction client) </li></ul></li></ul><br><p>  Tout cela est illustré dans le diagramme: </p><br><p><img src="https://habrastorage.org/webt/-p/gm/hi/-pgmhid0ohkvijl2zmghnlokz7y.png" alt="Image: Diagramme du package Go Project"></p><br><h2 id="principy-obrabotki-oshibok">  Principes de gestion des erreurs </h2><br><p>  Ici, tout est simple: </p><br><ol><li>  Nous pensons que des erreurs et des paniques se produisent lors du traitement des demandes à l'API - ce qui signifie qu'une erreur ou une panique ne devrait affecter qu'une seule demande </li><li>  Nous pensons que les journaux ne sont nécessaires que pour l'analyse des incidents (et il existe un débogueur pour le débogage), par conséquent, les informations sur les demandes sont reçues dans le journal et, tout d'abord, les erreurs inattendues lors du traitement des demandes </li><li>  Nous pensons qu'une infrastructure entière est construite pour le traitement des journaux (par exemple, basée sur ELK) - et le microservice y joue un rôle passif, écrivant des journaux sur stderr </li></ol><br><p>  Nous ne nous concentrerons pas sur les paniques: n'oubliez pas de gérer la panique dans chaque goroutine et lors du traitement de chaque requête, de chaque message, de chaque tâche asynchrone lancée par la requête.  Presque toujours, la panique peut être transformée en une erreur pour empêcher l'application complète de se terminer. </p><br><h2 id="idioma-sentinel-errors">  Erreurs Idiom Sentinel </h2><br><p>  Au niveau de la logique métier, seules les erreurs attendues définies par les règles métier sont traitées.  Les erreurs sentinelles vous aideront à identifier de telles erreurs - nous utilisons cet idiome au lieu d'écrire nos propres types de données pour les erreurs.  Un exemple: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNoCake = errors.New(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><p>  Une variable globale est déclarée ici, ce que, par notre accord de gentleman, nous ne devrions changer nulle part.  Si vous n'aimez pas les variables globales et utilisez le linter pour les détecter, vous pouvez vous en tirer avec certaines constantes, comme le suggère Dave Cheney dans le message <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Erreurs constantes</a> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(e) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrNoCake = Error(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><blockquote>  Si vous aimez cette approche, vous souhaiterez peut-être ajouter le type <code>ConstError</code> à votre bibliothèque de langues Go d'entreprise. </blockquote><br><h2 id="kompoziciya-oshibok">  Composition des erreurs </h2><br><p>  Le principal avantage des erreurs Sentinel est la possibilité de composer facilement des erreurs.  En particulier, lors de la création d'une erreur ou de la réception d'une erreur de l'extérieur, il serait bon de lui ajouter stacktrace.  À ces fins, il existe deux solutions populaires. </p><br><ul><li>  Paquet xerrors, qui dans Go 1.13 sera inclus dans la bibliothèque standard comme expérience </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Package github.com/pkg/errors</a> par Dave Cheney <br><ul><li>  le paquet est gelé et ne se dilate pas, mais il est néanmoins bon </li></ul></li></ul><br><p>  Notre équipe utilise toujours <code>github.com/pkg/errors</code> et les <code>errors.WithStack</code> fonctions avec <code>errors.WithStack</code> (quand nous n'avons rien à ajouter, sauf stacktrace) ou les <code>errors.Wrap</code> . <code>errors.Wrap</code> (quand nous avons quelque chose à dire sur cette erreur).  Les deux fonctions acceptent une erreur à l'entrée et renvoient une nouvelle erreur, mais avec stacktrace.  Exemple de la couche infrastructure: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> mysql <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/pkg/errors"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { row := r.client.QueryRow(sql, params...) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err := row.Scan(...) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sql.ErrNoRows: <span class="hljs-comment"><span class="hljs-comment">//     stacktrace return nil, errors.WithStack(app.ErrNoCake) } }</span></span></code> </pre> <br><p>  Nous recommandons que chaque erreur soit enveloppée une seule fois.  C'est facile à faire si vous suivez les règles: </p><br><ul><li>  toutes les erreurs externes sont enveloppées une fois dans l'un des packages d'infrastructure </li><li>  toutes les erreurs générées par les règles de logique métier sont complétées par stacktrace au moment de la création </li></ul><br><h2 id="pervoprichina-oshibki">  Cause racine de l'erreur </h2><br><p>  On s'attend à ce que toutes les erreurs soient divisées en prévu et inattendu.  Pour gérer l'erreur attendue, vous devez vous débarrasser des effets de la composition.  Les packages xerrors et <code>github.com/pkg/errors</code> ont tout ce dont vous avez besoin: en particulier, le package errors a la fonction <code>errors.Cause</code> , qui renvoie la cause première de l'erreur.  Cette fonction dans une boucle, l'une après l'autre, récupère les erreurs antérieures tandis que l'erreur extraite suivante a la méthode d' <code>Cause() error</code> . </p><br><p>  Un exemple auquel nous extrayons la cause racine et la comparons directement avec l'erreur sentinelle: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { state, err := s.repo.FindOne(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Cause(err) == ErrNoCake { err = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">// No cake is OK, create a new one // ... } else if err != nil { // ... } }</span></span></code> </pre> <br><h2 id="obrabotka-oshibok-v-defer">  Gestion des erreurs en différé </h2><br><p>  Vous utilisez peut-être linter, ce qui vous permet de vérifier manuellement toutes les erreurs.  Dans ce cas, vous êtes probablement furieux lorsque linter vous demande de vérifier les erreurs avec les méthodes <code>.Close()</code> et d'autres méthodes que vous <code>defer</code> uniquement <code>defer</code> .  Avez-vous déjà essayé de gérer correctement l'erreur en différé, surtout s'il y avait une autre erreur avant cela?  Et nous avons essayé et sommes pressés de partager la recette. </p><br><p>  Imaginez que tout le travail avec la base de données se fasse uniquement par le biais de transactions.  Selon la règle de dépendance, les niveaux d'application et de domaine ne doivent pas dépendre directement ou indirectement de l'infrastructure et de la technologie SQL.  Cela signifie qu'au <strong>niveau de l'application et du domaine, il n'y a pas de mot "transaction"</strong> . </p><br><p>  La solution la plus simple consiste à remplacer le mot «transaction» par quelque chose d'abstrait;  ainsi le modèle d'unité de travail est né.  Dans notre implémentation, le service dans le package d'application reçoit la fabrique via l'interface UnitOfWorkFactory, et pendant chaque opération crée un objet UnitOfWork qui masque la transaction.  L'objet UnitOfWork vous permet d'obtenir un référentiel. </p><br><div class="spoiler">  <b class="spoiler_title">Plus sur UnitOfWork</b> <div class="spoiler_text"><p>  Pour mieux comprendre l'utilisation de l'unité de travail, jetez un œil au schéma: </p><br><p><img src="https://habrastorage.org/webt/08/hi/iy/08hiiyavd51o3_aof9ys_s9noue.png" alt="Unité de travail Image Go"></p><br><ul><li>  Le référentiel représente une collection abstraite persistante d'objets (par exemple, des agrégats au niveau du domaine) d'un type défini </li><li>  UnitOfWork masque la transaction et crée des objets de référentiel </li><li>  UnitOfWorkFactory permet simplement au service de créer de nouvelles transactions sans rien savoir des transactions. </li></ul><br><p>  N'est-il pas excessif de créer une transaction pour chaque opération, même initialement atomique?  Cela dépend de vous;  Nous pensons qu'il est plus important de maintenir l'indépendance de la logique métier que d'économiser sur la création d'une transaction. </p><br><p>  Est-il possible de combiner UnitOfWork et Repository?  C'est possible, mais nous pensons que cela viole le principe de la responsabilité unique. </p></div></div><br><p>  Voici à quoi ressemble l'interface: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UnitOfWork <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Repository() Repository Complete(err *error) }</code> </pre> <br><p>  L'interface UnitOfWork fournit la méthode Complete, qui prend un paramètre d'entrée-sortie: un pointeur vers l'interface d'erreur.  Oui, c'est le pointeur et c'est le paramètre in-out - dans tous les autres cas, le code du côté appelant sera beaucoup plus compliqué. </p><br><p>  Exemple d'opération avec unitOfWork: </p><br><blockquote>  Attention: l'erreur <strong>doit</strong> être déclarée comme valeur de retour nommée.  Si au lieu de la valeur de retour nommée err vous utilisez la variable locale err, vous ne pouvez pas l'utiliser en différé!  Et pas un seul linter ne le détectera encore - voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">go-critique # 801</a> </blockquote><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { unitOfWork, err := s.unitOfWorkFactory.New() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> unitOfWork.Complete(&amp;err) repo := unitOfWork.Repository() } <span class="hljs-comment"><span class="hljs-comment">// ...  </span></span></code> </pre> <br><p>  Donc l'achèvement est réalisé <del>  transactions </del>  UnitOfWork: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *unitOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     -  commit txErr := u.tx.Commit() *err = errors.Wrap(txErr, "cannot complete transaction") } else { //    -  rollback txErr := return u.tx.Rollback() //  rollback   ,    *err = mergeErrors(*err, errors.Wrap(txErr, "cannot rollback transaction")) } }</span></span></code> </pre> <br><p>  La fonction <code>mergeErrors</code> fusionne deux erreurs, mais elle traite nil sans problème au lieu d'une ou des deux erreurs.  Dans le même temps, nous pensons que les deux erreurs se sont produites lors de l'exécution d'une opération à différentes étapes, et la première erreur est plus importante - par conséquent, lorsque les deux erreurs ne sont pas nulles, nous enregistrons la première, et seul le message est enregistré à partir de la deuxième erreur: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> errors <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error, nextErr error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = nextErr } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nextErr != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = errors.Wrap(err, nextErr.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><blockquote>  Vous devriez peut-être ajouter la fonction <code>mergeErrors</code> à votre bibliothèque d'entreprise pour Go. </blockquote><br><h2 id="podsistema-logirovaniya">  Sous-système de journalisation </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liste de contrôle des</a> articles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">: ce que vous aviez à faire avant de démarrer les microservices dans prod</a> conseille: </p><br><ul><li>  les journaux sont écrits dans stderr </li><li>  les journaux doivent être en JSON, un objet JSON compact par ligne </li><li>  Il devrait y avoir un ensemble standard de champs: <br><ul><li>  horodatage - heure de l'événement en <strong>millisecondes</strong> , de préférence au format RFC 3339 (exemple: "1985-04-12T23: 20: 50.52Z") </li><li>  niveau - niveau d'importance, par exemple, "info" ou "erreur" </li><li>  app_name - nom de l'application </li><li>  et d'autres domaines </li></ul></li></ul><br><p>  Nous préférons ajouter deux champs supplémentaires aux messages d'erreur: <code>"error"</code> et <code>"stacktrace"</code> . </p><br><p>  Il existe de nombreuses bibliothèques de journalisation de qualité pour le langage Golang, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sirupsen / logrus</a> , que nous utilisons.  Mais nous n'utilisons pas directement la bibliothèque.  Tout d'abord, dans notre package de <code>log</code> , nous réduisons l'interface de bibliothèque trop étendue à une seule interface Logger: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { WithField(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Logger WithFields(Fields) Logger Debug(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Info(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Error(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><p>  Si le programmeur veut écrire des journaux, il doit obtenir l'interface de l'enregistreur de l'extérieur, et cela doit être fait au niveau de l'infrastructure, pas de l'application ou du domaine.  L'interface de l'enregistreur est concise: </p><br><ul><li>  il réduit le nombre de niveaux de gravité pour le débogage, les informations et les erreurs, comme le conseille l'article. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parlons de la journalisation.</a> </li><li>  il introduit des règles spéciales pour la méthode Error: la méthode accepte toujours un objet error </li></ul><br><p>  Une telle rigueur permet d'orienter les programmeurs dans la bonne direction: si quelqu'un veut améliorer le système de journalisation lui-même, il doit le faire en tenant compte de l'ensemble de l'infrastructure de leur collecte et de leur traitement, qui ne commence que dans le microservice (et se termine généralement quelque part à Kibana et Zabbix). </p><br><p>  Cependant, dans le package de journaux, il existe une autre interface qui vous permet d'interrompre le programme lorsqu'une erreur fatale se produit et ne peut donc être utilisée que dans le package principal: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MainLogger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Logger FatalError(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><h2 id="paket-jsonlog">  Paquet Jsonlog </h2><br><p>  Implémente l'interface Logger notre package <code>jsonlog</code> , qui configure la bibliothèque logrus et résume le travail avec.  Ressemble schématiquement à ceci: </p><br><p><img src="https://habrastorage.org/webt/g4/we/6m/g4we6m81oxxtd1nlvwklblru6eq.png" alt="Diagramme du package de l'enregistreur d'images"></p><br><p>  Un package propriétaire vous permet de connecter les besoins d'un microservice (exprimés par l'interface <code>log.Logger</code> ), les capacités de la bibliothèque logrus et les fonctionnalités de votre infrastructure, la journalisation. </p><br><p>  Par exemple, nous utilisons ELK (Elastic Search, Logstash, Kibana), et donc dans le package jsonlog nous: </p><br><ul><li>  définir le format <code>logrus.JSONFormatter</code> pour <code>logrus.JSONFormatter</code> <br><ul><li>  en même temps, nous définissons l'option FieldMap, avec laquelle nous transformons le champ <code>"time"</code> en <code>"@timestamp"</code> , et le champ <code>"msg"</code> en <code>"message"</code> </li></ul></li><li>  sélectionner le niveau de journal </li><li>  ajouter un hook qui extrait stacktrace de l'objet <code>Error(error, ...interface{})</code> passé à la méthode <code>Error(error, ...interface{})</code> </li></ul><br><p>  Le microservice initialise l'enregistreur dans la fonction principale: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(log.MainLogger, error)</span></span></span></span> { logLevel, err := jsonlog.ParseLevel(config.LogLevel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to parse log level"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonlog.NewLogger(&amp;jsonlog.Config{ Level: logLevel, AppName: <span class="hljs-string"><span class="hljs-string">"cookingservice"</span></span> }), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><h2 id="obrabotka-oshibok-i-logirovanie-s-pomoschyu-middleware">  Gestion des erreurs et journalisation avec le middleware </h2><br><p>  Nous passons à GRPC dans nos microservices sur Go.  Mais même si vous utilisez l'API HTTP, les principes généraux sont pour vous. </p><br><p>  Tout d'abord, la gestion des erreurs et la journalisation doivent se produire au niveau de l' <code>infrastructure</code> dans le package responsable du transport, car c'est lui qui combine la connaissance des règles du protocole de transport et la connaissance des <code>app.Service</code> interface <code>app.Service</code> .  Rappelez-vous à quoi ressemble la relation de package: </p><br><p><img src="https://habrastorage.org/webt/fw/zn/hz/fwznhzsxd35ydgajmotnvprqbum.png" alt="Image Diagramme du package GRPC"></p><br><p>  Il est pratique de traiter les erreurs et de maintenir les journaux en utilisant le modèle Middleware (Middleware est le nom du modèle Decorator dans le monde de Golang et Node.js): </p><br><p>  Où ajouter un middleware?  Combien devrait-il y en avoir? </p><br><p>  Il existe différentes options pour ajouter un middleware, vous choisissez: </p><br><ul><li>  Vous pouvez décorer l'interface <code>app.Service</code> , mais nous vous déconseillons de le faire car cette interface ne reçoit pas d'informations sur la couche de transport, telles que l'adresse IP du client </li><li>  Avec GRPC, vous pouvez accrocher un gestionnaire à toutes les demandes (plus précisément, deux - unaire et steam), mais toutes les méthodes API seront enregistrées dans le même style avec le même ensemble de champs </li><li>  Avec GRPC, le générateur de code crée pour nous une interface serveur dans laquelle nous appelons la méthode <code>app.Service</code> - nous décorons cette interface car elle contient des informations au niveau du transport et la possibilité de consigner différentes méthodes API de différentes manières </li></ul><br><p>  Ressemble schématiquement à ceci: </p><br><p><img src="https://habrastorage.org/webt/vn/dl/eh/vndlehx5hogpu09hj3zekrzmyie.png" alt="Image Diagramme du package du middleware GRPC"></p><br><p>  Vous pouvez créer différents middlewares pour la gestion des erreurs (et la panique) et pour la journalisation.  Vous pouvez tout croiser en un seul.  Nous allons considérer un exemple dans lequel tout est croisé en un middleware, qui est créé comme ceci: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next api.BackendService, logger log.Logger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BackendService</span></span></span></span> { server := &amp;errorHandlingMiddleware{ next: next, logger: logger, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server }</code> </pre> <br><p>  Nous obtenons l'interface <code>api.BackendService</code> en <code>api.BackendService</code> et la décorons, renvoyant notre implémentation de l'interface <code>api.BackendService</code> en <code>api.BackendService</code> . </p><br><p>  Une méthode API arbitraire dans Middleware est implémentée comme suit: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ctx context.Context, req *api.ListCakesRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*api.ListCakesResponse, error)</span></span></span></span> { start := time.Now() res, err := m.next.ListCakes(ctx, req) m.logCall(start, err, <span class="hljs-string"><span class="hljs-string">"ListCakes"</span></span>, log.Fields{ <span class="hljs-string"><span class="hljs-string">"cookIDs"</span></span>: req.CookIDs, }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res, translateError(err) }</code> </pre> <br><p>  Ici, nous effectuons trois tâches: </p><br><ol><li>  Appelez la méthode ListCakes de l'objet décoré </li><li>  Nous <code>logCall</code> méthode <code>logCall</code> , en lui transmettant toutes les informations importantes, y compris un ensemble de champs sélectionnés individuellement qui tombent dans le journal </li><li>  À la fin, nous remplaçons l'erreur en appelant translateError. </li></ol><br><p>  La traduction des erreurs sera discutée plus tard.  Et la <code>logCall</code> est effectuée par la méthode <code>logCall</code> , qui appelle simplement la bonne méthode d'interface Logger: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start time.Time, err error, method </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fields log.Fields)</span></span></span></span> { fields[<span class="hljs-string"><span class="hljs-string">"duration"</span></span>] = fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%v"</span></span>, time.Since(start)) fields[<span class="hljs-string"><span class="hljs-string">"method"</span></span>] = method logger := m.logger.WithFields(fields) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { logger.Error(err, <span class="hljs-string"><span class="hljs-string">"call failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.Info(<span class="hljs-string"><span class="hljs-string">"call finished"</span></span>) } }</code> </pre> <br><h2 id="translyaciya-oshibok">  Traduction d'erreur </h2><br><p>  Nous devons obtenir la cause première de l'erreur et la transformer en une erreur compréhensible au niveau du transport et documentée dans l'API de votre service. </p><br><p>  Dans GRPC, c'est simple - utilisez la fonction <code>status.Errorf</code> pour créer une erreur avec un code d'état.  Si vous disposez d'une API HTTP (API REST), vous pouvez créer votre propre type d'erreur que les <strong>niveaux d'application et de domaine ne devraient pas connaître.</strong> </p><br><p>  Dans une première approximation, la traduction d'erreur ressemble à ceci: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ! ! -   err  status.Error func translateError(err error) error { switch errors.Cause(err) { case app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) default: err = status.Errorf(codes.Internal, err.Error()) } return err }</span></span></code> </pre> <br><p>  Lors de la validation des arguments d'entrée, l'interface décorée peut renvoyer une erreur du type <code>status.Status</code> avec un code d'état, et la première version de translateError perdra ce code d'état. </p><br><p>  Faisons une version améliorée en lançant un type d'interface (longue vie de frappe de canard!): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> statusError <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GRPCStatus() *status.Status } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isGrpcStatusError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(er error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { _, ok := err.(statusError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translateError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isGrpcStatusError(err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: err = status.Errorf(codes.Internal, err.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  La fonction <code>translateError</code> est créée individuellement pour chaque contexte (module indépendant) dans votre microservice et traduit les erreurs de logique métier en erreurs au niveau du transport. </p><br><h2 id="podvedyom-itogi">  Pour résumer </h2><br><p>  Nous vous proposons plusieurs règles pour gérer les erreurs et travailler avec les journaux.  À vous de décider de les suivre ou non. </p><br><ol><li>  Suivez les principes de l'architecture propre, ne violez pas directement ou indirectement la règle des dépendances.  La logique métier ne devrait dépendre que d'un langage de programmation et non de technologies externes. </li><li>  Utilisez un package qui propose la composition des erreurs et la création de traces de pile.  Par exemple, "github.com/pkg/errors" ou le package xerrors, qui fera bientôt partie de la bibliothèque standard Go. </li><li>  N'utilisez pas de bibliothèques de journalisation tierces dans le microservice - créez votre propre bibliothèque avec les packages log et jsonlog, qui masqueront les détails de l'implémentation de la journalisation </li><li>  Utilisez le modèle Middleware pour gérer les erreurs et écrire des journaux sur la direction de transport du niveau d'infrastructure du programme </li></ol><br><p>  Ici, nous n'avons rien dit sur les technologies de suivi des requêtes (par exemple, OpenTracing), la surveillance des métriques (par exemple, les performances des requêtes de base de données) et d'autres choses comme la journalisation.  Vous allez vous en occuper, nous croyons en vous. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459130/">https://habr.com/ru/post/fr459130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459118/index.html">Comment nous avons conçu et mis en œuvre le nouveau réseau sur Huawei dans le bureau de Moscou, partie 2</a></li>
<li><a href="../fr459120/index.html">Ordinateurs intégrés modulaires série UNO-1000/2000</a></li>
<li><a href="../fr459122/index.html">Aleksey Savvateev: Prix Nobel de Jean Tyrol pour l'analyse des marchés imparfaits (2014) et de la réputation collective</a></li>
<li><a href="../fr459126/index.html">Réservoir de robot Raspberry Pi avec Intel Neural Computer Stick 2</a></li>
<li><a href="../fr459128/index.html">Interfaces japonaises dans le monde réel</a></li>
<li><a href="../fr459134/index.html">Expérience avec BDD</a></li>
<li><a href="../fr459136/index.html">Fausse pilule bleue</a></li>
<li><a href="../fr459138/index.html">Comment la clé secrète Huawei est entrée dans le firmware des routeurs Cisco</a></li>
<li><a href="../fr459140/index.html">Pose d'implants: comment cela se fait-il?</a></li>
<li><a href="../fr459142/index.html">Création d'un graphique linéaire moyen animé animé dans R. Récupération de données via l'API NBA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>