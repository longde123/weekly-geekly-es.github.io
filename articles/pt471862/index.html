<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéç üë®üèº‚Äç‚öïÔ∏è üë®üèø‚Äçüé§ Implementa√ß√£o do Analisador PEG üëêüèª üï¥üèª üò¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inspirado apenas por uma compreens√£o parcial do PEG, decidi tentar implement√°-lo. O resultado pode n√£o ser o melhor entre os analisadores de PEG de us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementa√ß√£o do Analisador PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471862/"><p>  Inspirado apenas por uma compreens√£o parcial do PEG, decidi tentar implement√°-lo.  O resultado pode n√£o ser o melhor entre os analisadores de PEG de uso geral - j√° existem muitos deles (por exemplo, o TatSu √© escrito em Python e gera c√≥digo Python) - mas essa √© uma boa maneira de entender o PEG.  No futuro, quero substitu√≠-lo pela implementa√ß√£o atual do analisador no CPython. </p><br><div class="spoiler">  <b class="spoiler_title">Conte√∫do da s√©rie Ps Parser Python</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Analisadores de Peg</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementa√ß√£o do Analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gera√ß√£o de analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visualiza√ß√£o do analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gram√°tica PEG recursiva esquerda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Adicionando a√ß√µes √† gram√°tica PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meta gram√°tica para analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementando os recursos restantes do PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PEG no Core Developer Sprint</a> </li></ul></div></div><br><p>  Nesta se√ß√£o, lancei as bases para entender o trabalho do analisador, usando um exemplo de uma implementa√ß√£o auto-escrita simples da gram√°tica de brinquedos de um artigo anterior. </p><a name="habracut"></a><br><p>  (A prop√≥sito, como experimento, n√£o coloco links no meu texto. Se voc√™ n√£o entende alguma coisa, basta pesquisar no Google. :-) </p><br><p> Normalmente, um PEG usa um analisador de descida recursiva com um buffer ilimitado para retornar.  Aqui est√° uma gram√°tica de brinquedo de um artigo anterior: </p><br><pre><code class="plaintext hljs">statement: assignment | expr | if_statement expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: NAME | NUMBER | '(' expr ')' assignment: target '=' expr target: NAME if_statement: 'if' expr ':' statement</code> </pre> <br><p>  O analisador super-abstrato da descida recursiva para esse idioma definir√° sua fun√ß√£o para cada regra na qual as alternativas ser√£o entendidas.  Por exemplo, para <code>statement</code> , ter√≠amos esta fun√ß√£o: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assignment(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> if_statement(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Obviamente, este √© um exemplo simplista demais: omite detalhes importantes, por exemplo, o que √© fornecido √† entrada dessa fun√ß√£o e qual ser√° o resultado de sua execu√ß√£o. </p><br><p>  Vamos come√ßar com os argumentos.  Os analisadores cl√°ssicos usam um tokenizador separado, que divide a entrada (arquivo ou linha de texto) em uma s√©rie de tokens, como palavras-chave, identificadores (nomes), n√∫meros e operadores.  Os analisadores PEG (como outros analisadores modernos como o ANTLR) geralmente combinam tokeniza√ß√£o e an√°lise, mas, para o meu projeto, decidi deixar um tokenizador separado. </p><br><p>  A tokeniza√ß√£o de Python √© bastante complicada, por isso n√£o quero implement√°-la nas regras do PEG.  Por exemplo, voc√™ deve acompanhar o recuo (isso requer uma pilha dentro do tokenizer);  O processamento de novas linhas em Python tamb√©m √© interessante (elas s√£o significativas, exceto aquelas inclu√≠das entre colchetes).  Muitos tipos de cadeias tamb√©m causam alguma complexidade.  Em resumo, n√£o tenho queixas sobre o tokenizer Python existente, ent√£o quero deix√°-lo como est√°.  A prop√≥sito, o CPython possui dois tokenizadores: o interno, que √© usado pelo analisador, √© escrito em C, e a biblioteca padr√£o, que √© uma c√≥pia exata implementada em Python puro.  Isso ser√° √∫til no meu projeto. </p><br><p>  Um tokenizer cl√°ssico geralmente possui uma interface simples que consiste em uma √∫nica fun√ß√£o <code>get_token()</code> .  Cada vez, ele retorna o pr√≥ximo token na sequ√™ncia de entrada, analisando um grupo de caracteres.  O m√≥dulo de <code>tokenize</code> do CPython n√£o √© exce√ß√£o: sua API principal √© um gerador que emite um token de cada vez.  Cada token √© um objeto do tipo <code>TypeInfo</code> , que possui v√°rios campos, o mais importante dos quais √© o tipo de token (por exemplo, <code>NAME</code> , <code>NUMBER</code> , <code>STRING</code> ) e seu valor de string √© o conjunto de caracteres em que consiste (por exemplo, <code>abc</code> , <code>42</code> ou <code>"Hello, world"</code> ).  Existem tamb√©m campos adicionais.  Por exemplo, para o √≠ndice de token no fluxo de entrada, que √© √∫til em mensagens de erro. </p><br><p>  Um tipo especial de token √© <code>ENDMARKER</code> , que indica que o final do arquivo de entrada foi atingido.  O gerador cair√° se voc√™ o ignorar e tentar obter o pr√≥ximo token. </p><br><p>  Mas eu estava distra√≠do.  Como realizamos retornos ilimitados?  A revers√£o da lista de tokens exige que voc√™ se lembre da posi√ß√£o no c√≥digo-fonte e reanalise a partir desse ponto.  A API do tokenizer n√£o nos permite mover o ponteiro, mas voc√™ pode capturar o fluxo de tokens em uma matriz e reproduzi-lo a partir da√≠, o que faremos.  Voc√™ tamb√©m pode repetir isso com <code>itertools.tee()</code> , mas isso provavelmente √© menos eficaz em nosso caso, se voc√™ observar os avisos na documenta√ß√£o. </p><br><p>  Suponho que voc√™ possa simplesmente tokenizar todas as entradas da lista primeiro e depois us√°-las como entradas para o analisador.  Mas se houver um token inv√°lido no final do arquivo (por exemplo, uma linha com uma cota√ß√£o de fechamento ausente) e tamb√©m houver um erro de sintaxe no arquivo, voc√™ receber√° uma mensagem de erro do tokenizer.  Acredito que isso seja ruim para o usu√°rio, pois um erro de sintaxe pode ser a principal causa de uma linha inv√°lida.  Portanto, tenho requisitos ligeiramente diferentes para o tokenizer, em particular, ele deve ser implementado como uma lista lenta. </p><br><p>  A API principal √© muito simples.  O objeto <code>Tokenizer</code> encapsula uma matriz de tokens e posi√ß√£o nessa matriz.  Ele tem tr√™s m√©todos principais: </p><br><ul><li>  <code>get_token()</code> retorna o pr√≥ximo token, movendo o ponteiro (ou l√™ o pr√≥ximo token da fonte, se estivermos no final do buffer do token); </li><li>  <code>mark()</code> retorna a posi√ß√£o atual no buffer; </li><li>  <code>reset(pos)</code> define a posi√ß√£o no buffer (o argumento deve ser obtido da <code>mark()</code> ). </li></ul><br><p>  Adicionamos uma fun√ß√£o auxiliar <code>peek_token()</code> , que retorna o pr√≥ximo token sem alterar a posi√ß√£o no buffer. </p><br><p>  √â assim que a base da classe <code>Tokenizer</code> parece: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tokenizer</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokengen)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Call with tokenize.generate_tokens(...)."""</span></span> self.tokengen = tokengen self.tokens = [] self.pos = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.pos <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> self.pos = pos <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> token = self.peek_token() self.pos += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> token <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">peek_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.pos == len(self.tokens): self.tokens.append(next(self.tokengen)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokens[self.pos]</code> </pre> <br><p>  Aqui, algo √© omitido por simplicidade (por exemplo, os nomes dos m√©todos e vari√°veis ‚Äã‚Äãda inst√¢ncia devem come√ßar com um sublinhado), mas esse √© apenas um prot√≥tipo da API do <code>Tokenizer</code> . </p><br><p>  O analisador tamb√©m deve se tornar uma classe para que <code>statement()</code> , <code>expr()</code> etc.  poderia ser implementado como m√©todos.  O tokenizer se tornar√° uma vari√°vel de inst√¢ncia, mas n√£o quero que os m√©todos do analisador chame diretamente <code>get_token()</code> . Em vez disso, implementamos o m√©todo <code>wait()</code> na classe <code>Parser</code> , que pode ser bem-sucedido ou falhar, assim como o m√©todo do analisador.  O argumento para a fun√ß√£o <code>wait()</code> √© o token esperado: uma sequ√™ncia de caracteres (por exemplo, <code>+</code> ) ou um tipo de token (por exemplo, <code>NAME</code> ).  O tipo do valor de retorno ainda n√£o √© importante, voltarei a ele depois de discutir o resultado do trabalho do analisador. </p><br><p>  Deixe que as fun√ß√µes da regra gramatical retornem apenas <code>True</code> ou <code>False</code> .  Isso √© bom para a ci√™ncia da computa√ß√£o te√≥rica (a√≠ o analisador responde √† pergunta " <em>Essa</em> √© <em>uma</em> string v√°lida na linguagem?"), Mas n√£o para n√≥s.  Nossa tarefa √© criar um AST.  Ent√£o, vamos reescrever esse c√≥digo para que cada m√©todo de an√°lise retorne um objeto <code>Node</code> em caso de sucesso ou <code>None</code> em caso de falha. </p><br><p>  A classe <code>Node</code> pode ser muito simples: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, type, children)</span></span></span><span class="hljs-function">:</span></span> self.type = type self.children = children</code> </pre> <br><p>  Aqui, <code>type</code> determina o tipo do n√≥ AST (por exemplo, <code>add</code> ou <code>if</code> ) e os descendentes s√£o uma lista de n√≥s e tokens (inst√¢ncias <code>TokenInfo</code> ).  Isso √© suficiente para o compilador gerar c√≥digo ou executar outras an√°lises, como verifica√ß√£o de tipo est√°tico ou fiapos.  Embora, no futuro, eu gostaria de mudar a forma como a AST √© apresentada. </p><br><p>  Para se encaixar nesse esquema, o m√©todo <code>expect()</code> deve retornar um objeto <code>TokenInfo</code> em caso de sucesso e <code>None</code> em caso de falha.  Para poder reverter para tokens anteriores, envolvo as chamadas para os m√©todos <code>mark()</code> e <code>reset()</code> do tokenizer (aqui a API n√£o muda).  Aqui est√° o que aconteceu: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, tokenizer)</span></span></span><span class="hljs-function">:</span></span> self.tokenizer = tokenizer <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokenizer.mark() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> self.tokenizer.reset(pos) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, arg)</span></span></span><span class="hljs-function">:</span></span> token = self.tokenizer.peek_token() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> token.type == arg <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> token.string == arg: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.tokenizer.get_token() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Mais uma vez: omiti alguns detalhes, mas isso j√° est√° funcionando. </p><br><p>  Agora, preciso introduzir um requisito importante para os m√©todos do analisador.  Todos devem retornar o <code>Node</code> , colocando o tokenizer ap√≥s o √∫ltimo token da regra gramatical que reconheceram;  <code>None</code> e deixe a posi√ß√£o do tokenizer inalterada.  Se o m√©todo do analisador ler v√°rios tokens e depois cair, dever√° restaurar a posi√ß√£o do tokenizer.  Para isso, <code>mark()</code> e <code>reset()</code> s√£o destinados.  Observe que <code>expect()</code> tamb√©m obedece a esta regra. </p><br><p>  Ent√£o, aqui est√° um esbo√ßo do analisador real.  Aqui eu uso o operador morsa do Python 3.8 ( <code>:=</code> ): </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToyParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a := self.assignment(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i := self.if_statement(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t := self.term(): pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op := self.expect(<span class="hljs-string"><span class="hljs-string">"+"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">"add"</span></span>, [t, e]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op := self.expect(<span class="hljs-string"><span class="hljs-string">"-"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e := self.expr(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">"sub"</span></span>, [t, e]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">term</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Very similar... def atom(self): if token := self.expect(NAME): return token if token := self.expect(NUMBER): return token pos = self.mark() if self.expect("("): if e := self.expr(): if self.expect(")"): return e self.reset(pos) return None</span></span></code> </pre> <br><p>  Omiti a implementa√ß√£o de alguns m√©todos para que o leitor tivesse a oportunidade de praticar a si pr√≥prio.  Isso √© realmente melhor do que apenas ler sobre como esse analisador √© implementado.  No final, geraremos esse c√≥digo automaticamente a partir da gram√°tica.  Constantes como <code>NAME</code> e <code>NUMBER</code> s√£o importadas do m√≥dulo de <code>token</code> da biblioteca padr√£o.  Isso nos vincula ainda mais √† implementa√ß√£o atual do tokenizer Python.  Se queremos criar um analisador PEG generalizado, precisamos encontrar maneiras de evitar isso. </p><br><p>  Observe tamb√©m que estou um pouco enganado.  O m√©todo <code>expr</code> deve ser recursivo √† esquerda, mas tornei o analisador recursivo √† direita, porque o analisador de descida recursiva n√£o funciona com regras gramaticais recursivas √† esquerda.  Isso pode ser corrigido, mas ainda √© o tema de algumas pesquisas cient√≠ficas, e eu gostaria de falar sobre isso separadamente.  Lembre-se de que essa implementa√ß√£o n√£o √© 100% consistente com nossa gram√°tica simplificada. </p><br><p>  As principais coisas que eu quero que voc√™ entenda at√© agora: </p><br><ul><li>  As regras gramaticais correspondem aos m√©todos do analisador e, quando uma regra gramatical se refere a outra, chama um m√©todo de outra regra. </li><li>  Quando uma sequ√™ncia de tokens pode ser interpretada de maneira diferente, os m√©todos correspondentes do analisador s√£o chamados um ap√≥s o outro. </li><li>  Quando uma regra gramatical se refere a um token, o m√©todo chama a fun√ß√£o <code>expect()</code> . </li><li>  Se o analisador reconhecer com √™xito sua regra gramatical na posi√ß√£o atual, ele retornar√° o n√≥ AST correspondente;  se ele n√£o conseguir reconhecer sua regra gramatical, ele retornar√° <code>None</code> . </li><li>  Os m√©todos do analisador devem redefinir explicitamente a posi√ß√£o do tokenizer quando parar de analisar depois de usar um ou mais tokens (direta ou indiretamente, invocar outro m√©todo de an√°lise bem-sucedido).  Isso √© aplic√°vel n√£o apenas quando uma das op√ß√µes √© rejeitada para prosseguir para a pr√≥xima, mas tamb√©m quando a an√°lise √© rejeitada como um todo. </li></ul><br><p>  Se todos os m√©todos de an√°lise obedecerem a essas regras, n√£o ser√° necess√°rio agrupar cada uma nas chamadas <code>mark()</code> e <code>reset()</code> .  Isso pode ser provado por indu√ß√£o. </p><br><p>  Al√©m disso, √© tentador tentar se livrar de chamadas expl√≠citas para <code>mark()</code> e <code>reset()</code> usando o gerenciador de contexto e a instru√ß√£o <code>with</code> , mas n√£o funcionar√°: voc√™ n√£o deve chamar <code>reset()</code> se tiver √™xito!  Como uma corre√ß√£o adicional, voc√™ pode tentar usar exce√ß√µes para o fluxo de controle para que o gerenciador de contexto saiba se o tokenizer deve ser redefinido (acho que o TatSu est√° fazendo algo semelhante).  Por exemplo, algo como isto: </p><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.assignment() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.expr() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.if_statement() <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ParsingFailure</code> </pre> <br><p>  Em particular, uma pequena escada de <code>if</code> em <code>atom()</code> para reconhecer uma express√£o entre colchetes pode ser escrita como: </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.alt(): self.expect(<span class="hljs-string"><span class="hljs-string">"("</span></span>) e = self.expr() self.expect(<span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e</code> </pre> <br><p>  Mas me parece muito "m√°gico" - ao ler esse c√≥digo, voc√™ deve se lembrar de que cada m√©todo de an√°lise (incluindo <code>wait()</code> ) pode gerar uma exce√ß√£o.  E que essa exce√ß√£o √© capturada e ignorada pelo gerenciador de contexto na instru√ß√£o <code>with</code> .  Isso √© bastante incomum, embora realiz√°vel (retornando <code>True</code> de <code>__exit__</code> ).  No entanto, meu objetivo final √© gerar c√≥digo em C, n√£o em Python, e em C n√£o h√° nenhuma instru√ß√£o <code>with</code> para alterar o fluxo de controle. </p><br><p>  De qualquer forma, aqui est√£o alguns t√≥picos para as seguintes partes: </p><br><ul><li>  gera√ß√£o de m√©todos analisadores a partir da gram√°tica; </li><li>  an√°lise de pacotes (memoriza√ß√£o); </li><li>  Recursos de EBNF como <code>(x | y)</code> , <code>[xy ...]</code> , <code>x*</code> , <code>x+</code> ; </li><li>  rastreamento (para depurar um analisador ou gram√°tica); </li><li>  Recursos de PEG como lookahead e cut; </li><li>  como lidar com regras recursivas √† esquerda; </li><li>  Gera√ß√£o de c√≥digo C </li></ul><br><p>  Licen√ßa para este artigo e c√≥digo citado: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471862/">https://habr.com/ru/post/pt471862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471852/index.html">Not√≠cias do mundo do OpenStreetMap n¬∫ 481 (01/10/2019 - 07/10/2019)</a></li>
<li><a href="../pt471854/index.html">Calor Morte 5G</a></li>
<li><a href="../pt471856/index.html">Resolvemos todas as 42 vers√µes do quebra-cabe√ßa de po√ß√µes de Harry Potter</a></li>
<li><a href="../pt471858/index.html">RabbitMQ vs. Kafka: Failover e alta disponibilidade em clusters</a></li>
<li><a href="../pt471860/index.html">Analisadores de Peg</a></li>
<li><a href="../pt471864/index.html">Gera√ß√£o de analisador PEG</a></li>
<li><a href="../pt471870/index.html">Uso efetivo do libdispatch</a></li>
<li><a href="../pt471872/index.html">Interfaces no C # 8: suposi√ß√µes perigosas na implementa√ß√£o padr√£o</a></li>
<li><a href="../pt471876/index.html">PDU e Tudo-Tudo-Tudo: Distribui√ß√£o de Energia em Rack</a></li>
<li><a href="../pt471878/index.html">Como escrever um contrato inteligente para o WebAssembly em uma rede Ontology? Parte 1: Ferrugem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>