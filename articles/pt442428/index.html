<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜñ üè¥‚Äç‚ò†Ô∏è üö• A linha de comando mais simples no NASM e QEMU üö¶ üé∞ ü¶ì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ent√£o, direto ao ponto. Escreveremos no Linux, no NASM e usando o QEMU. Como √© f√°cil de instalar, pule esta etapa. 


 Entende-se que o leitor est√° fa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A linha de comando mais simples no NASM e QEMU</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442428/"><p><img src="https://habrastorage.org/webt/-m/3u/a3/-m3ua33_7vl-xeb4pg1o8qacclg.png" alt="imagem"></p><br><p>  Ent√£o, direto ao ponto.  Escreveremos no Linux, no NASM e usando o QEMU.  Como √© f√°cil de instalar, pule esta etapa. </p><br><p>  Entende-se que o leitor est√° familiarizado com a sintaxe do NASM pelo menos no n√≠vel b√°sico (no entanto, n√£o haver√° nada particularmente complicado aqui) e entende o que s√£o registros. </p><a name="habracut"></a><br><h2 id="bazovaya-teoriya">  Teoria b√°sica </h2><br><p>  A primeira coisa que inicia o processador quando o computador √© ligado √© o c√≥digo do BIOS (ou UEFI, mas aqui vou falar apenas sobre o BIOS), que √© "conectado" na mem√≥ria da placa-m√£e (especificamente, em 0xFFFFFFF0). </p><br><p>  Imediatamente ap√≥s ligar o BIOS, o POST (Power-On Self-Test) √© iniciado - autoteste ap√≥s a ativa√ß√£o.  O BIOS verifica a integridade da mem√≥ria, detecta e inicializa os dispositivos conectados, verifica os registros, determina o tamanho da mem√≥ria e assim por diante. </p><br><p>  O pr√≥ximo passo √© identificar o disco de inicializa√ß√£o a partir do qual voc√™ pode inicializar o sistema operacional.  Um disco de inicializa√ß√£o √© um disco (ou qualquer outra unidade) que possui os √∫ltimos 2 bytes do primeiro setor (o primeiro setor significa os primeiros 512 bytes da unidade, porque 1 setor = 512 bytes) √© 55 e AA (no formato hexadecimal).  Assim que um disco de inicializa√ß√£o for encontrado, o BIOS carregar√° seus primeiros 512 bytes na RAM no endere√ßo 0x7c00 e transferir√° o controle para o processador nesse endere√ßo. </p><br><p>  Obviamente, nesses 512 bytes, n√£o funcionar√° para se ajustar a um sistema operacional completo.  Portanto, geralmente nesse setor, coloque o carregador prim√°rio, que carrega o c√≥digo principal do sistema operacional na RAM e transfere o controle para ele. </p><br><p>  Desde o in√≠cio, o processador estava sendo executado no modo Real (= modo de 16 bits).  Isso significa que ele s√≥ pode funcionar com dados de 16 bits e usa endere√ßamento de mem√≥ria segmentada e tamb√©m pode endere√ßar apenas 1 MB de mem√≥ria.  Mas n√£o usaremos o segundo aqui.  A imagem abaixo mostra o estado da RAM ao transferir o controle para o nosso c√≥digo (a foto √© tirada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui</a> ). </p><br><p><img src="https://habrastorage.org/webt/qs/xb/jr/qsxbjr6em-78cr7d6xj7_nh86bg.png" alt="imagem"></p><br><p>  A √∫ltima coisa a dizer antes da parte pr√°tica s√£o as interrup√ß√µes.  Uma interrup√ß√£o √© um sinal especial (por exemplo, de um dispositivo de entrada, como um teclado ou mouse) para um processador que diz que √© necess√°rio interromper imediatamente a execu√ß√£o do c√≥digo atual e executar o c√≥digo do manipulador de interrup√ß√µes.  Todos os endere√ßos dos manipuladores de interrup√ß√£o est√£o localizados na Tabela de descritores de interrup√ß√£o (IDT) na mem√≥ria principal.  Cada interrup√ß√£o possui seu pr√≥prio manipulador de interrup√ß√µes.  Por exemplo, quando uma tecla do teclado √© pressionada, uma interrup√ß√£o √© chamada, o processador para, lembra o endere√ßo da instru√ß√£o interrompida, salva todos os valores de seus registros (na pilha) e prossegue para executar o manipulador de interrup√ß√µes.  Assim que sua execu√ß√£o termina, o processador restaura os valores dos registradores e retorna √† instru√ß√£o interrompida e continua a execu√ß√£o. </p><br><p>  Por exemplo, para exibir algo na tela, o BIOS usa a interrup√ß√£o 0x10 (formato hexadecimal) e a interrup√ß√£o 0x16 √© usada para aguardar que uma tecla seja pressionada.  De fato, todas essas interrup√ß√µes s√£o necess√°rias aqui. </p><br><p>  Al√©m disso, cada interrup√ß√£o tem sua pr√≥pria subfun√ß√£o que determina a peculiaridade de seu comportamento.  Para exibir algo no formato de texto (!), √â necess√°rio inserir o valor 0x0e no registro AH.  Al√©m disso, as interrup√ß√µes t√™m seus pr√≥prios par√¢metros.  0x10 recebe valores de ah (define uma subfun√ß√£o espec√≠fica) e al (o caractere a ser impresso).  Desta maneira </p><br><pre><code class="plaintext hljs">mov ah, 0x0e mov al, 'x' int 0x10</code> </pre> <br><p>  exibe o caractere 'x'.  0x16 pega o valor de ah (subfun√ß√£o espec√≠fica) e carrega o valor da chave inserida no registro al.  Usaremos a fun√ß√£o 0x0. </p><br><h2 id="prakticheskaya-chast">  Parte pr√°tica </h2><br><p>  Vamos come√ßar com o c√≥digo auxiliar.  Vamos precisar da fun√ß√£o de comparar duas linhas e da fun√ß√£o de exibir uma linha na tela.  Tentei descrever o funcionamento dessas fun√ß√µes nos coment√°rios o mais claramente poss√≠vel. </p><br><p>  str_compare.asm: </p><br><pre> <code class="plaintext hljs">compare_strs_si_bx: push si ;         push bx push ax comp: mov ah, [bx] ;     , cmp [si], ah ;      ah jne not_equal ;    ,     cmp byte [si], 0 ;    ,    je first_zero ;    inc si ;     bx  si inc bx jmp comp ;   first_zero: cmp byte [bx], 0 ;    bx != 0,  ,   jne not_equal ;  ,    not_equal mov cx, 1 ;     ,  cx = 1 pop si ;     pop bx pop ax ret ;     not_equal: mov cx, 0 ;  ,  cx = 0 pop si ;    pop bx pop ax ret ;    </code> </pre> <br><p>  A fun√ß√£o aceita os registros SI e BX como par√¢metros.  Se as linhas forem iguais, CX ser√° definido como 1, caso contr√°rio, 0. </p><br><p>  Tamb√©m √© importante notar que os registradores AX, BX, CX e DX s√£o divididos em duas partes de byte √∫nico: AH, BH, CH e DH para o byte alto e AL, BL, CL e DL para o byte baixo. </p><br><p>  Inicialmente, entende-se que em bx e si existem ponteiros (!) (Ou seja, armazena o endere√ßo na mem√≥ria) para algum endere√ßo na mem√≥ria em que o in√≠cio da linha est√° localizado.  A opera√ß√£o [bx] pegar√° um ponteiro de bx, ir√° para esse endere√ßo e ter√° algum valor a partir da√≠.  inc bx significa que agora o ponteiro far√° refer√™ncia ao endere√ßo imediatamente ap√≥s o endere√ßo original. </p><br><p>  print_string.asm: </p><br><pre> <code class="plaintext hljs">print_string_si: push ax ;  ax   mov ah, 0x0e ;  ah  0x0e,    call print_next_char ;  pop ax ;  ax ret ;   print_next_char: mov al, [si] ;    cmp al, 0 ;  si  jz if_zero ;     int 0x10 ;     al inc si ;    jmp print_next_char ;   ... if_zero: ret</code> </pre> <br><p>  Como par√¢metro, a fun√ß√£o pega o registro SI e byte byte imprime uma string. </p><br><p>  Agora vamos para o c√≥digo principal.  Primeiro, vamos definir todas as vari√°veis ‚Äã‚Äã(esse c√≥digo estar√° no final do arquivo): </p><br><pre> <code class="plaintext hljs">; 0x0d -   , 0xa -    wrong_command: db "Wrong command!", 0x0d, 0xa, 0 greetings: db "The OS is on. Type 'help' for commands", 0x0d, 0xa, 0xa, 0 help_desc: db "Here's nothing to show yet. But soon...", 0x0d, 0xa, 0 goodbye: db 0x0d, 0xa, "Goodbye!", 0x0d, 0xa, 0 prompt: db "&gt;", 0 new_line: db 0x0d, 0xa, 0 help_command: db "help", 0 input: times 64 db 0 ;   - 64  times 510 - ($-$$) db 0 dw 0xaa55</code> </pre> <br><p>  O caractere de retorno de carro move o carro para a borda esquerda da tela, ou seja, para o in√≠cio da linha. </p><br><pre> <code class="plaintext hljs">input: times 64 db 0</code> </pre> <br><p>  significa que alocamos 64 bytes sob o buffer para entrada e os preenchemos com zeros. </p><br><p>  O restante das vari√°veis ‚Äã‚Äã√© necess√°rio para exibir algumas informa√ß√µes; mais abaixo no c√≥digo, voc√™ entender√° por que todas elas s√£o necess√°rias. </p><br><pre> <code class="plaintext hljs">times 510 - ($-$$) db 0 dw 0xaa55</code> </pre> <br><p>  significa que definimos explicitamente o tamanho do arquivo de sa√≠da (com a extens√£o .bin) para 512 bytes, preenchemos os primeiros 510 bytes com zeros (√© claro, eles s√£o preenchidos antes da execu√ß√£o do c√≥digo inteiro) e os √∫ltimos dois bytes com os mesmos bytes "m√°gicos" 55 e AA .  $ significa o endere√ßo da instru√ß√£o atual e $$ √© o endere√ßo da primeira instru√ß√£o do nosso c√≥digo. </p><br><p>  Vamos para o c√≥digo atual: </p><br><pre> <code class="plaintext hljs">org 0x7c00 ; (1) bits 16 ; (2) jmp start ;    start %include "print_string.asm" ;     %include "str_compare.asm" ; ==================================================== start: mov ah, 0x00 ;   (3) mov al, 0x03 int 0x10 mov sp, 0x7c00 ;   (4) mov si, greetings ;    call print_string_si ;      mainloop</code> </pre> <br><p>  (1)  Este comando deixa claro para o NASM que estamos executando o c√≥digo come√ßando em 0x7c00.  Isso permite polarizar automaticamente todos os endere√ßos relativos a esse endere√ßo, para que n√£o fa√ßamos isso explicitamente. <br>  (2)  Este comando instrui o NASM que estamos operando no modo de 16 bits. <br>  (3)  Quando lan√ßado, o QEMU imprime muitas informa√ß√µes que n√£o precisamos.  Para fazer isso, defina ah 0x00, al 0x03 e chame 0x10 para limpar a tela de tudo. <br>  (4)  Para salvar registros na pilha, voc√™ deve especificar em qual endere√ßo seu v√©rtice ser√° localizado usando o ponteiro da pilha SP.  SP indicar√° a √°rea na mem√≥ria na qual o pr√≥ximo valor ser√° gravado.  Adicione o valor √† pilha - o SP diminui a mem√≥ria em 2 bytes (j√° que estamos no Modo Real, onde todos os operandos de registro s√£o de 16 bits, ou seja, valores de byte duplo).  Como especificamos 0x7c00, os valores na pilha ser√£o armazenados ao lado do c√≥digo na mem√≥ria.  Mais uma vez - a pilha cresce (!).  Isso significa que quanto mais valores houver na pilha, menos mem√≥ria o ponteiro da pilha SP indicar√°. </p><br><pre> <code class="plaintext hljs">mainloop: mov si, prompt ;   call print_string_si call get_input ;     jmp mainloop ;  mainloop...</code> </pre> <br><p>  La√ßo principal.  Aqui, com cada itera√ß√£o, imprimimos o caractere "&gt;", ap√≥s o qual chamamos a fun√ß√£o get_input, que implementa o trabalho com interrup√ß√£o do teclado. </p><br><pre> <code class="plaintext hljs">get_input: mov bx, 0 ;  bx      input_processing: mov ah, 0x0 ;    0x16 int 0x16 ;  ASCII  cmp al, 0x0d ;   enter je check_the_input ;   ,   ,  ;    cmp al, 0x8 ;   backspace je backspace_pressed cmp al, 0x3 ;   ctrl+c je stop_cpu mov ah, 0x0e ;     -   ;     int 0x10 mov [input+bx], al ;       inc bx ;   cmp bx, 64 ;  input  je check_the_input ;    ,    enter jmp input_processing ;   </code> </pre> <br><p>  (1) [input + bx] significa que pegamos o endere√ßo do in√≠cio da entrada do buffer de entrada e adicionamos bx a ele, ou seja, chegamos ao bx + o 1¬∫ elemento do buffer. </p><br><pre> <code class="plaintext hljs">stop_cpu: mov si, goodbye ;   call print_string_si jmp $ ;    ; $    </code> </pre> <br><p>  Tudo √© simples aqui - se voc√™ pressionou Ctrl + C, o computador executa a fun√ß√£o jmp $ sem parar. </p><br><pre> <code class="plaintext hljs">backspace_pressed: cmp bx, 0 ;  backspace ,  input ,  je input_processing ;    mov ah, 0x0e ;  backspace.  ,   int 0x10 ;   ,      mov al, ' ' ;      ,  int 0x10 ;   mov al, 0x8 ;       int 0x10 ;     backspace dec bx mov byte [input+bx], 0 ;    input   jmp input_processing ;   </code> </pre> <br><p>  Para n√£o apagar o caractere '&gt;' ao pressionar backspace, verificamos se a entrada est√° vazia.  Caso contr√°rio, n√£o fa√ßa nada. </p><br><pre> <code class="plaintext hljs">check_the_input: inc bx mov byte [input+bx], 0 ;     ,   ;  (  '\0'  ) mov si, new_line ;     call print_string_si mov si, help_command ;  si     help mov bx, input ;   bx -   call compare_strs_si_bx ;  si  bx (  help) cmp cx, 1 ; compare_strs_si_bx   cx 1,  ;     je equal_help ;  =&gt;    ;  help jmp equal_to_nothing ;   ,   "Wrong command!"</code> </pre> <br><p>  Aqui, acho que tudo fica claro com os coment√°rios. </p><br><pre> <code class="plaintext hljs">equal_help: mov si, help_desc call print_string_si jmp done equal_to_nothing: mov si, wrong_command call print_string_si jmp done</code> </pre> <br><p>  Dependendo do que foi inserido, exibimos o texto da vari√°vel help_desc ou o texto da vari√°vel de comando errado. </p><br><pre> <code class="plaintext hljs">; done    input done: cmp bx, 0 ;     input   je exit ;   ,    mainloop dec bx ;  ,      mov byte [input+bx], 0 jmp done ;       exit: ret</code> </pre> <br><p>  Na verdade, todo o c√≥digo √©: </p><br><p>  prompt.asm: </p><br><pre> <code class="plaintext hljs">org 0x7c00 bits 16 jmp start ;    start %include "print_string.asm" %include "str_compare.asm" ; ==================================================== start: cli ;  ,    ;     mov ah, 0x00 ;   mov al, 0x03 int 0x10 mov sp, 0x7c00 ;   mov si, greetings ;    call print_string_si ;      mainloop mainloop: mov si, prompt ;   call print_string_si call get_input ;     jmp mainloop ;  mainloop... get_input: mov bx, 0 ;  bx      input_processing: mov ah, 0x0 ;    0x16 int 0x16 ;  ASCII  cmp al, 0x0d ;   enter je check_the_input ;   ,   ,  ;    cmp al, 0x8 ;   backspace je backspace_pressed cmp al, 0x3 ;   ctrl+c je stop_cpu mov ah, 0x0e ;     -   ;     int 0x10 mov [input+bx], al ;       inc bx ;   cmp bx, 64 ;  input  je check_the_input ;    ,    enter jmp input_processing ;    stop_cpu: mov si, goodbye ;   call print_string_si jmp $ ;    ; $     backspace_pressed: cmp bx, 0 ;  backspace ,  input ,  je input_processing ;    mov ah, 0x0e ;  backspace.  ,   int 0x10 ;   ,      mov al, ' ' ;      ,  int 0x10 ;   mov al, 0x8 ;       int 0x10 ;     backspace dec bx mov byte [input+bx], 0 ;    input   jmp input_processing ;    check_the_input: inc bx mov byte [input+bx], 0 ;     ,   ;  (  '\0'  ) mov si, new_line ;     call print_string_si mov si, help_command ;  si     help mov bx, input ;   bx -   call compare_strs_si_bx ;  si  bx (  help) cmp cx, 1 ; compare_strs_si_bx   cx 1,  ;     je equal_help ;  =&gt;    ;  help jmp equal_to_nothing ;   ,   "Wrong command!" equal_help: mov si, help_desc call print_string_si jmp done equal_to_nothing: mov si, wrong_command call print_string_si jmp done ; done    input done: cmp bx, 0 ;     input   je exit ;   ,    mainloop dec bx ;  ,      mov byte [input+bx], 0 jmp done ;       exit: ret ; 0x0d -   , 0xa -    wrong_command: db "Wrong command!", 0x0d, 0xa, 0 greetings: db "The OS is on. Type 'help' for commands", 0x0d, 0xa, 0xa, 0 help_desc: db "Here's nothing to show yet. But soon...", 0x0d, 0xa, 0 goodbye: db 0x0d, 0xa, "Goodbye!", 0x0d, 0xa, 0 prompt: db "&gt;", 0 new_line: db 0x0d, 0xa, 0 help_command: db "help", 0 input: times 64 db 0 ;   - 64  times 510 - ($-$$) db 0 dw 0xaa55</code> </pre><br><p>  Para compilar tudo isso, digite o comando: </p><br><pre> <code class="plaintext hljs">nasm -f bin prompt.asm -o bootloader.bin</code> </pre> <br><p>  E n√≥s obtemos o bin√°rio com nosso c√≥digo na sa√≠da.  Agora execute o emulador QEMU com este arquivo (-monitor stdio permite exibir o valor do registro a qualquer momento, usando o comando print $ reg): </p><br><pre> <code class="plaintext hljs">qemu-system-i386 bootloader.bin -monitor stdio</code> </pre> <br><p>  E obtemos a sa√≠da: </p><br><p><img src="https://habrastorage.org/webt/fq/h2/_7/fqh2_7m_r8mnne4pfo7x4sqvc4k.png" alt="imagem"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442428/">https://habr.com/ru/post/pt442428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442406/index.html">Resumo da Fintech: transfer√™ncias gratuitas no sistema SBP, vulnerabilidade dos bancos a ataques e outras not√≠cias</a></li>
<li><a href="../pt442408/index.html">A m√°quina universal para a realiza√ß√£o de testes de bricolage, parte 1</a></li>
<li><a href="../pt442414/index.html">Estudar em uma universidade estrangeira na primeira pessoa</a></li>
<li><a href="../pt442416/index.html">Resumo da Pesquisa e Desenvolvimento da Universidade ITMO: discutindo tend√™ncias e novas conquistas dos cientistas</a></li>
<li><a href="../pt442422/index.html">Entusiasta recriou a placa de som Sound Blaster 1.0 - conte-nos o qu√£o not√°vel √© o projeto</a></li>
<li><a href="../pt442430/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel # 288 (24 de fevereiro a 3 de mar√ßo)</a></li>
<li><a href="../pt442432/index.html">[Pelas docas] Flutter. Parte 1. Para desenvolvedores do Android</a></li>
<li><a href="../pt442434/index.html">7 recomenda√ß√µes para analisar os 70 principais par√¢metros de crescimento do site em 2019 no Yandex</a></li>
<li><a href="../pt442438/index.html">Uma primeira olhada no JavaScript atrav√©s dos olhos de um desenvolvedor Java</a></li>
<li><a href="../pt442440/index.html">Criando um aplicativo Android usando o Anko Layouts e o Anko Coroutines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>