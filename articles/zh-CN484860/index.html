<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐕 👍🏾 🧝 实施名称和结果名称 🌰 👨🏻‍🏭 👶🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我想在7月份写这篇文章，但是， 讽刺的是 ，我无法决定该怎么称呼。 只有在凯特·格雷格里 （ Kate Gregory）在CppCon上发表讲话之后，我才想到好术语，现在我终于可以告诉您如何调用函数了。 


当然，有些名称根本不携带任何信息，例如int f(int x) 。 它们也不需要使用，但这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>实施名称和结果名称</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484860/"><p><img src="https://habrastorage.org/webt/sw/9a/fb/sw9afbxo38dofpspvffb0c_jrq4.jpeg"></p><br><p> 我想在7月份写这篇文章，但是， <em>讽刺的是</em> ，我无法决定该怎么称呼。 只有在<a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">凯特·格雷格里</a> （ <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">Kate Gregory）在CppCon上发表讲话</a>之后，我才想到好术语，现在我终于可以告诉您如何调用函数了。 </p><br><p>当然，有些名称根本不携带任何信息，例如<code>int f(int x)</code> 。 它们也不需要使用，但这与它们无关。 有时，似乎标题中的信息已满，但绝对没有好处。 </p><a name="habracut"></a><br><h2 id="primer-1-stdlog2p1"> 示例1：std :: log2p1（） </h2><br><p> 在C ++ 20中，在标头中添加了几个用于位操作的新功能，其中包括<code>std::log2p1</code> 。 看起来像这样： <br><br><br></p><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log2p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::log2(x)); }</code> </pre><br><p> 也就是说，对于任何自然数，该函数将返回其二进制对数加1，对于0，它将返回0。对于if / else运算符而言，这不是学校问题，这确实是有用的事情-该值适合的最小位数。 仅通过函数名称猜测它几乎是不可能的。 </p><br><h2 id="primer-2-stdbless"> 示例2：std :: bless（） </h2><br><p>  <em>现在不再是名字</em> </p><br><p> 题外话：在C ++中，指针算法仅适用于指向数组元素的指针。 从原则上讲，这是合乎逻辑的：在通常情况下，相邻对象的集合是未知的，并且“在变量<code>i</code>右边的十个字节中可能发生任何事情”。 这无疑是模糊的行为。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> obj = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = &amp;obj; ++ptr; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><p> 但是这样的限制声明了大量现有代码的不确定行为。 例如，这是<code>std::vector&lt;T&gt;::reserve()</code>的简化实现： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      auto new_memory = (T*) ::operator new(n * sizeof(T)); //    … //   auto size = this-&gt;size(); begin_ = new_memory; //   end_ = new_memory + size; //     end_capacity_ = new_memory + n; //    }</span></span></code> </pre> <br><p> 我们已经分配了内存，移动了所有对象，现在尝试确保指针指示去向。 这只是最后三行未定义，因为它们包含对数组外部指针的算术运算！ </p><br><p> 当然，应该怪的不是程序员。 问题出在C ++标准本身，该标准将这段显然合理的代码声明为未定义行为。 因此， <a href="https://wg21.link/p0593">P0593</a>建议通过添加一些函数（如<code>::operator new</code>和<code>std::malloc</code> ）来根据需要创建数组的能力，以纠正标准。 它们创建的所有指针都将神奇地成为数组的指针，并且可以使用它们执行算术运算。 </p><br><p>  <em>仍然没有名字，请稍等。</em> </p><br><p> 但是有时，当使用这些功能之一未分配的内存时，需要对指针进行操作。 例如， <code>deallocate()</code>函数本质上适用于死存储器，在死存储器中根本没有对象，但是仍然必须加总指针和区域的大小。 在这种情况下，P0593提供了<code>std::bless(void* ptr, std::size_t n)</code>函数<code>std::bless(void* ptr, std::size_t n)</code> （那里还有另一个函数，也称为<code>bless</code> ，但这与它无关）。 它对现实生活中的物理计算机没有影响，但是它为抽象机创建对象，从而允许使用指针算术。 </p><br><p> 名称<code>std::bless</code>是暂时的。 </p><br><p>  <em>所以，名字。</em> </p><br><p> 在科隆，LEWG的任务是为此功能命名。 提出了“ <code>implicitly_create_objects()</code>和“ <code>implicitly_create_objects_as_needed()</code> ”选项，因为这是函数的作用。 </p><br><p> 我不喜欢这些选项。 </p><br><h2 id="primer-3-stdpartial_sort_copy"> 示例3：std :: partial_sort_copy（） </h2><br><p>  <em><a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">凯特演讲中的</a>例子</em> </p><br><p> 有一个功能<code>std::sort</code> ，它对容器的元素进行排序： </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(vec.begin(), vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, 4, 5}</span></span></code> </pre> <br><p> 还有<code>std::partial_sort</code> ，它仅对部分元素进行排序： </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort(vec.begin(), vec.begin() + <span class="hljs-number"><span class="hljs-number">3</span></span>, vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, ?, ?} ( ...4,5,  ...5,4)</span></span></code> </pre> <br><p> 仍然有<code>std::partial_sort_copy</code> ，它也对部分元素进行排序，但是同时旧容器不会更改，而是将值转移到新容器中： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; out; out.resize(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort_copy(vec.begin(), vec.end(), out.begin(), out.end()); <span class="hljs-comment"><span class="hljs-comment">// out == {1, 2, 3}</span></span></code> </pre> <br><p> 凯特（Kate）声称<code>std::partial_sort_copy</code>是一个普通的名字，我同意她的看法。 </p><br><h2 id="nazvanie-implementacii-i-nazvanie-rezultata"> 实施名称和结果名称 </h2><br><p> 严格来说，列出的名称中没有一个是<em>错误的</em> ：它们都完美地描述了该功能的作用。  <code>std::log2p1()</code>真正计算二进制对数并加一个；  <code>implicitly_create_objects()</code>隐式创建对象， <code>std::partial_sort_copy()</code>对容器进行部分排序并复制结果。 但是，我不喜欢所有这些名称，因为它们<em>没有用</em> 。 </p><br><p> 没有程序员坐下来思考：“我希望我可以取二进制对数并加一个”。 他需要知道给定值适合多少位，并且他在<code>bit_width</code>搜索诸如<code>bit_width</code>类的内容<code>bit_width</code> 。 当他到达库用户时，二进制对数与它有什么关系，他已经编写了实现（很可能错过了对零的检查）。 即使<code>std::log2p1</code>在代码中被证明是一个奇迹，下一个看到此代码的人也应该再次理解它的含义以及为什么需要它。  <code>bit_width(max_value)</code>不会有这样的问题。 </p><br><p> 同样，没有人需要“隐式创建对象”或“对向量的副本进行部分排序”-他们需要重用内存或以降序获得5个最大值。 像<code>recycle_storage()</code> （也被建议为名称<code>std::bless</code> ）和<code>top_n_sorted()</code>会更加清晰。 </p><br><p> 凯特（Kate）将术语<em>实现名称</em>用于<code>std::partial_sort_copy()</code> ，但它也适合其他两个函数。 确实很好地描述了其名称的实现。 只是用户需要结果的名称-他通过调用函数得到的结果。 对于她的内部结构，他不在乎，他只想找出位的大小或重用内存。 </p><br><p>  <strong>根据功能的规范来命名功能意味着要在库开发人员及其用户之间产生误解。</strong>  <strong>您必须始终记住何时以及如何使用该功能。</strong> </p><br><p> 听起来很老套，是的。 但是从<code>std::log2p1()</code>来看，这对每个人来说都不是显而易见的。 而且，有时候不是那么简单。 </p><br><h2 id="primer-4-stdpopcount"> 示例4：std :: popcount（） </h2><br><p>  <code>std::popcount()</code>类似， <code>std::log2p1()</code>在C ++ 20中，建议添加到<code>&lt;bit&gt;</code> 。 当然，这是一个非常糟糕的名字。 如果您不知道此功能的作用，则无法猜测。 缩写不仅令人困惑（名称中包含pop，但pop / push与之无关）-解密人口计数（计算人口？人口数量？）也无济于事。 </p><br><p> 另一方面， <code>std::popcount()</code>此函数的理想选择，因为它调用汇编指令popcount。 这不仅是实现的<em>名称</em> -它是完整的描述。 </p><br><p> 但是，在这种情况下，语言开发人员和程序员之间的差距并不大。 从六十年代开始，对二进制字中的单位数进行计数的一条指令称为弹出计数。 对于一个对位操作一无所知的人来说，这样的名字绝对是显而易见的。 </p><br><p>  <em>顺便说一句，一个好问题：您认为对于初学者来说方便的名称，还是让他们对oldfags熟悉？</em> </p><br><h2 id="heppi-end"> 幸福的结局？ </h2><br><p>  <a href="https://wg21.link/P1956">P1956</a>建议将<code>std::log2p1()</code>重命名为<code>std::bit_width()</code> 。 该提议可能会在C ++ 20中被接受。  <code>std::ceil2</code>和<code>std::ceil2</code>也将分别重命名为std :: bit_ceil（）和std :: bit_floor（）。 他们的旧名字也不太好，但是出于其他原因。 </p><br><p> 科隆的LEWG既没有<code>implicitly_create_objects[_as_needed]</code>选择<code>implicitly_create_objects[_as_needed]</code>也没有选择<code>recycle_storage</code>作为<code>std::bless</code>的名称。 他们决定完全不在标准中包含此功能。 通过显式创建字节数组可以达到相同的效果，因此，他们说不需要该功能。 我不喜欢这样，因为调用<code>std::recycle_storage()</code>更具可读性。 另一个<code>std::bless()</code>仍然存在，但现在称为<code>start_lifetime_as</code> 。 我喜欢那样 它应该进入C ++ 23。 </p><br><p> 当然， <code>std::partial_sort_copy()</code>不再重命名-以此名称在1998年进入标准。但是至少<code>std::log2p1</code>固定的，这还不错。 </p><br><p> 在提出函数名称时，您需要考虑谁将使用它们以及他从函数中想要什么。 正如凯特（Kate）所说， <strong>命名需要同理心</strong> 。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484860/">https://habr.com/ru/post/zh-CN484860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484836/index.html">根据乌克兰2020年的绿色关税计算获利能力</a></li>
<li><a href="../zh-CN484838/index.html">在Google Ads中设置规则的13个示例[说明]</a></li>
<li><a href="../zh-CN484840/index.html">返回</a></li>
<li><a href="../zh-CN484846/index.html">我与开源的关系</a></li>
<li><a href="../zh-CN484854/index.html">在MS-DOS上的C＃中运行游戏</a></li>
<li><a href="../zh-CN484862/index.html">通过混合应用程序从AngularJS迁移到Angular7</a></li>
<li><a href="../zh-CN484866/index.html">在ARM嵌入式计算机上使用Astra Linux</a></li>
<li><a href="../zh-CN484868/index.html">如何衡量团队的进步？ 第二部分</a></li>
<li><a href="../zh-CN484870/index.html">英语如何改变了伊洛娜面具20年</a></li>
<li><a href="../zh-CN484874/index.html">“您的IT专家已被打破，带来了新的人才”：如何在IT领域建立事业而不是发疯</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>