<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😓 👩🏽‍🤝‍👩🏻 🐬 Experiência usando BDD 👩🏿‍🤝‍👨🏾 🦁 👩🏽‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Há cerca de sete anos, Dan North, em seu artigo, descreveu a aplicação prática da abordagem BDD, que permite tornar o processo de desenvolvimento mais...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Experiência usando BDD</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/459134/"><p><img src="https://habrastorage.org/webt/oo/ze/t3/oozet3hyz1ptfa9q11me-mgcgh4.jpeg"></p><br><p>  Há cerca de sete anos, Dan North, em seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo,</a> descreveu a aplicação prática da abordagem BDD, que permite tornar o processo de desenvolvimento mais compreensível e gerenciável, estabelecendo comunicações internas.  O setor mostra cada vez mais interesse nessa metodologia todos os dias, visando a interação produtiva de equipes padrão, como “analytics-development-testing”. </p><br><p>  No entanto, agora apenas uma pequena parte das empresas decide usar o BDD.  Porque </p><a name="habracut"></a><br><p>  Então, vamos descobrir.  O BDD (Behavior Driven Development) é uma metodologia flexível intimamente relacionada ao TDD (Test Driven Development - “Desenvolvimento através de testes”).  Por experiência, mesmo testadores experientes geralmente não vêem a diferença entre essas metodologias.  De fato, à primeira vista, é difícil isolar: ambas as abordagens envolvem escrever documentação e testes antes do início da fase de desenvolvimento.  E a diferença é esta: no BDD, para descrever os testes, você precisa usar uma linguagem natural que seja compreensível para cada participante do projeto, a fim de, de fato, combinar a declaração do problema, os testes e a documentação.  Em outras palavras, é definida a DSL (linguagem específica para o assunto) e, em seguida, é criado um conjunto limitado de frases padrão que descreve o comportamento dos elementos necessários.  Então, com a ajuda deles, um cenário é desenvolvido usando a nova funcionalidade, que ficará clara para todos. </p><br><p>  Vamos ver a diferença uma vez, e ela ficará aparente: </p><br><p><img src="https://habrastorage.org/webt/fg/s3/_e/fgs3_e71mp3t_ynlkbvbh-d6olw.png"></p><br><p>  Vamos tocar neste exemplo, mas primeiro, vamos olhar para toda a variedade de metodologias que atualmente são de relevância diferente de zero. </p><br><h2 id="sravnim-neskolko-metodologiy">  Compare várias metodologias </h2><br><p>  O diagrama abaixo mostra uma comparação de três abordagens: TDD, TLD (Test Last Development) e BDD: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/xz/st/lvxzstichnozebdmzcfl7wncxt8.png"></div><br><ul><li> Quando trabalhamos de acordo com a metodologia do BDD, as especificações de autoteste e desenho acompanham cada estágio do ciclo de desenvolvimento de software, o que garante a relevância constante dos autotestes e da documentação. </li><li>  As metodologias TDD e ATDD (Teste de aceitação) são combinadas em um diagrama em um bloco, porque  escrito na fase de análise.  Como mencionado acima, o TDD é baseado em testes de gravação antes de desenvolver a funcionalidade.  O desenvolvedor deve escrever testes para escrever a funcionalidade do teste. </li><li>  O TLD (Test Last Development) inclui testes após a implementação da funcionalidade. </li><li>  O BDD é universal e pode ser incluído em qualquer estágio do desenvolvimento. </li></ul><br><p>  O segundo diagrama mostra o envolvimento dos participantes no processo de desenvolvimento na escrita de scripts. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/b_/ao/uqb_aoyi3-7jdr651-sdk6nmmzc.png"></div><br><ul><li>  No BDD, qualquer membro da equipe pode se conectar aos testes em qualquer estágio, por exemplo, analista, usuário comercial, desenvolvedor e testador, pois os testes são claros para todos os participantes do processo. </li><li>  O BDD também é útil, pois você não precisa gastar muito tempo escrevendo vários tipos de documentação.  O esquema de desenvolvimento clássico requer, no mínimo, especificações e scripts de teste que geralmente são escritos por pessoas diferentes.  No BDD, uma especificação é um caso de teste, enquanto também é um autoteste.  Os testadores não precisam escrever documentação de teste separada - para eles, o analista já fez isso, escrevendo uma especificação a partir de construções de linguagem natural (que é legível e compreensível por qualquer membro da equipe). </li></ul><br><p>  Sem dúvida, o BDD é uma boa ferramenta para alcançar a qualidade do produto.  Testes e documentação são gravados mais rapidamente.  Para uma empresa, um projeto se torna mais transparente, graças a construções de linguagem natural que são compreensíveis para qualquer pessoa longe da programação. </p><br><p>  Isso é sobre os profissionais.  No entanto, como já foi dito, apesar de um grande número de vantagens, poucos implementam essa metodologia. </p><br><h2 id="bdd-vsem-horosh-no-pochemu-ego-ne-ispolzuyut">  O BDD é bom para todos, mas por que não usá-lo? </h2><br><p>  A resposta é simples: é longa e cara.  A maioria das empresas de TI concorda com esta declaração.  E a princípio não fomos exceção.  O BDD é inconveniente, mesmo que exija o envolvimento de especialistas em testes já no estágio de elaboração de requisitos. </p><br><p>  O BDD vira a diretriz clássica de desenvolvimento (TLD) de cabeça para baixo.  É mal implementado porque é difícil.  O ciclo de desenvolvimento está se prolongando. </p><br><p>  O BDD é, sem dúvida, uma maneira de obter qualidade.  Mas nem todos estão dispostos a pagar tempo e especialistas por essa qualidade. </p><br><p>  No entanto, o que devo fazer se ainda quiser implementar o BDD? </p><br><p>  Você pode tentar usar estruturas prontas.  Por exemplo Pepino, Squish, Yulup. </p><br><p>  O principal problema da complexidade do BDD não está no processo, mas na implementação e nas ferramentas existentes.  Tome a WEB como um exemplo de desenvolvimento de um sistema de informações corporativas.  Tendo uma implementação na Web, encontramos um WebDriver, atualmente o padrão para automatizar aplicativos em execução em um navegador da Web.  Ele tem muitas oportunidades.  Para levar em consideração várias personalizações dos elementos da página, é necessário criar opções para acessá-los.  E aqui, para facilitar o desenvolvimento do teste, várias bibliotecas vêm em socorro (Selenide, etc.), que cria seu próprio ecossistema que você precisa conhecer.  Para trabalhar com o WebDriver, você precisa de um programador ou de automação de testadores, porque  tudo é implementado usando códigos e designs astutos. </p><br><h2 id="nachalo-raboty-s-bdd-freymvorkom---slozhno-i-dolgo">  Começar com a estrutura do BDD é difícil e demorado. </h2><br><p>  Nosso foco está em um instrumento chamado Gauge.  Essa é uma estrutura flexível e leve, distribuída sob uma licença gratuita.  Francamente, nós realmente não estudamos as alternativas, porque  O uso do Gauge foi ditado agressivamente pelo nosso cliente. </p><br><p>  No Gauge, os testes são gravados em arquivos de especificação (arquivos com extensão .spec).  A especificação contém etapas de teste escritas em linguagem natural.  Essas etapas são implementadas em uma linguagem de programação (usamos a linguagem de programação Java).  Ao implementar as etapas, é importante cumprir a Convenção de Nomenclatura, tanto nos nomes do script quanto nos arquivos de implementação, e nos nomes dos métodos e etapas de implementação do script, eles devem ser completamente idênticos.  Uma flexibilidade adicional para esta ferramenta é que as etapas podem ter parâmetros. </p><br><p>  O Gauge nos permitiu usar os benefícios do BDD.  No entanto, ainda encontramos problemas que são a complexidade da implementação: os problemas das ferramentas e a implementação do processo. </p><br><p>  Descobriu-se que o envolvimento dos testadores em um estágio inicial tem um efeito ruim no resultado final.  Maior tempo para desenvolver testes.  O uso de qualquer estrutura requer grandes esforços do testador, que, sem dúvida, deve ter um bom domínio de programação.  No início, o processo de trabalhar com o script era o seguinte: o analista contou o teste ao testador e o escritor técnico anotou.  Enquanto o testador lidava com a implementação do software, o significado da funcionalidade testada mudou.  Isso afeta a separação do ponto de entrada, e deve ser um, pois o processo é dividido e se transforma em um processo "normal", do qual eu apenas queria sair.  I.e.  o ponto de entrada foi dividido, as comunicações se espalharam, o testador entrou de cabeça na implementação do teste, o escritor técnico entendeu à sua maneira e o analista reescreveu suas docas e mudou de idéia, o desenvolvedor entrou em "seu mundo"). </p><br><p>  O testador passou muito tempo no código.  Mas o mesmo testador ainda teve que pensar na busca por elementos na página.  A situação lembrava um famoso jogo infantil: "Telefone mimado".  Ocorreu um colapso.  E decidimos: o BDD funcionará apenas se os analistas puderem escrever testes.  É necessário reduzir a complexidade dos testes de escrita, simplificá-los.  Mas para isso, você precisa simplificar significativamente as interfaces de teste.  Ferramentas de teste, a implementação do processo em conjunto com todas as abordagens e bibliotecas deve ser mais simples. </p><br><p>  O trabalho do testador a princípio ficou assim: </p><br><ol><li>  <em>Exame da documentação, se houver;</em> </li><li>  Elaborando uma lista de verificação; </li><li>  Teste ad-hoc </li><li>  Elaborar um plano de teste; </li><li>  <em>Refinamento da visão de mundo do analista;</em> </li><li>  <em>Refinamento da imagem do mundo pelo desenvolvedor;</em> </li><li>  <em>Se tudo crescer junto, escrevendo a documentação do teste, em paralelo com o teste;</em> </li><li>  Esperando por bugs, testando bugs; </li><li>  <em>Descrição das páginas, controles, procure elementos na página usando o Web-Driver.</em>  <em>Pesquise o que já foi implementado no sistema de teste;</em> </li><li>  Escrevendo lógica de teste; </li><li>  Lançamento </li><li>  Suporte bug / Regress bug; </li><li>  <em>Atualização de especificação;</em> </li><li>  Fix bug </li><li>  <em>Atualização de autoteste, atualizando um grande número de controles alterados;</em> </li><li>  Lançamento </li><li>  ... <br>  Os itens <em>em itálico</em> (1, 5, 6, 7, 9, 13, 15) levam a custos de tempo.  Eles podem e devem ser otimizados. </li></ol><br><p>  Esta lista é brevemente ilustrada no diagrama do processo de desenvolvimento: </p><br><img src="https://habrastorage.org/webt/si/7y/m8/si7ym8xktulzmpgsvtsogu-5bfe.png"><br><p>  Nossa empresa é especializada em projetos com implementação na web de interfaces.  Com base nisso, usamos a ferramenta Driver da Web para interagir com o navegador. </p><br><p>  De fato, o Selenium Web Driver é o padrão e é usado para descrever objetos da Web em qualquer estrutura, incluindo as bibliotecas Gauge, jUnit, Masquerade e outras.  Ele tem muita flexibilidade para tarefas diferentes, o que cria muita trabalho em problemas do tipo local.  Precisamos encontrar uma solução para reduzir a complexidade. </p><br><p>  Por exemplo, vamos mostrar no diagrama como o Selenium Web Driver, a estrutura Gauge, a biblioteca Masquerade e a linguagem de programação Java estão relacionadas. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ki/md/ib/kimdibdn1wmo8au4ubirnrbwsta.png"></div><br><p>  Nesse esquema, em vez da estrutura do BDD, você pode colocar jUnit, TestNG ou qualquer outro, qualquer pacote funcionará, dependendo das necessidades.  O Selenium e o Masquerade permanecerão, a linguagem de programação pode ser alterada. </p><br><h2 id="uskorenie-processa-napisaniya-koda--podklyuchenie-masquerade">  Acelerando a Escrita de Código - Conectando Mascarada </h2><br><p>  Nossa empresa está desenvolvendo na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plataforma CUBA</a> .  E especificamente para esta plataforma, foi desenvolvida uma ferramenta para autoteste: O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Masquerade</a> é uma biblioteca que fornece uma API concisa e conveniente para trabalhar com código na implementação de testes usando o WebDriver.  Esta biblioteca funciona no Selenium Web Driver, é amiga do selenide e de qualquer estrutura. </p><br><p>  Nos projetos CUBA, cada elemento da página da web contém cuba-id, que não muda.  O CUBA usa uma abordagem de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">componentes</a> , e a biblioteca Masquerade simplifica a interação com os elementos da página da web.  A biblioteca pode executar ações com elementos da página da web implementados usando o CUBA de uma maneira mais simples.  Portanto, ao procurar elementos na página, você não precisa usar construções volumosas com o XPath, como era antes: </p><br><pre><code class="plaintext hljs">$(new By.ByXPath("//*/div/div[2]/div/div[2]/div/div/div[3]/div/div/div[3).click();</code> </pre> <br><p>  Ou construções mais concisas em Java, que, no entanto, ainda são complicadas: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String cssClass, String caption)</span></span></span><span class="hljs-function"> </span></span>{ $(By.cssSelector(cssClass) .$(byText(caption)) .closest(<span class="hljs-string"><span class="hljs-string">".v-button"</span></span>) .click(); }</code> </pre> <br><p>  Após conectar a biblioteca Masquerade, a descrição do controle incorporado parece simples e fácil de acessar.  Você nem precisa procurar controles na página, porque  ele já tem isso no projeto.  Aqui está um exemplo de uma descrição do botão para o formulário de autorização no aplicativo: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7m/up/og/7mupog9cgkybpr5of9kctzreplg.png"></div><br><p>  No código da página, vemos um elemento claramente reconhecível <code>cuba-id=”loginButton”</code> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/8e/v-/ey8ev-vzpxdicfy1uohlen2eahg.png"></div><br><p>  Vamos descrever o botão usando a biblioteca Masquerade: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"WebHBoxLayout"</span></span>, <span class="hljs-string"><span class="hljs-string">"loginButton"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button loginButton;</code> </pre> <br><p>  Uma implementação de teste simples na estrutura do jUnit é um bloco de autorização executado antes de cada teste: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginAdm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Tests loginTest = _$(Tests.class); loginTest.login(); }</code> </pre> <br><p>  E no corpo do método de login, o seguinte código: </p><br><pre> <code class="java hljs">LoginWindow loginWindow = _$(LoginWindow.class); assertNotNull(loginWindow.getLoginField()); loginWindow.getLoginField() .shouldBe(EDITABLE) .shouldBe(ENABLED); loginWindow.loginField.setValue(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>); loginWindow.passwordField.setValue(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>); loginWindow.rememberMeCheckBox.setChecked(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); loginWindow.loginButton().click();</code> </pre> <br><p>  O mais importante é como descrevemos a página, como nos referimos a elementos.  Descrição da página LoginWindow: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginWindow</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Composite</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginWindow</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"loginField"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TextField loginField; <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"passwordField"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PasswordField passwordField; <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"rememberMeCheckBox"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CheckBox rememberMeCheckBox; <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"loginFormLayout"</span></span>, <span class="hljs-string"><span class="hljs-string">"loginButton"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button loginButton; }</code> </pre> <br><p>  Encontrar itens é apenas parte da biblioteca Masquerade.  O acesso aos elementos de uma página da web permite executar várias ações com esses elementos.  Por exemplo, você pode selecionar um item na lista suspensa: </p><br><pre> <code class="java hljs">getMaxResultsLayout().openOptionsPopup().select(<span class="hljs-string"><span class="hljs-string">"5000"</span></span>)</code> </pre> <br><p>  Ou ordene a tabela: </p><br><pre> <code class="java hljs">Table tb1 = client.getPaymentsTable(); tb1.sort(<span class="hljs-string"><span class="hljs-string">"column_year"</span></span>, Table.SortDirection.ASCENDING);</code> </pre> <br><p>  Veja as capturas de tela abaixo para obter uma lista de algumas ações da tabela: </p><br><p><img src="https://habrastorage.org/webt/a_/yb/xi/a_ybxiqn6tnamitezd8ytoeu5tq.png"></p><br><p><img src="https://habrastorage.org/webt/zj/n8/0l/zjn80lwr-gurcycna9onk9bhgxk.png"></p><br><p><img src="https://habrastorage.org/webt/ui/gz/6i/uigz6imouut0epktbr8vsmunlj4.png"></p><br><p>  O uso do Masquerade simplificou bastante a gravação de testes. Agora, para escrever um teste para novas funcionalidades, você precisa: </p><br><ol><li>  Usar o Masquerade para descrever uma página é fácil e não requer habilidades especiais de programação. </li><li>  Colete em uma classe todas as páginas usadas ao verificar a funcionalidade. </li><li>  Nas construções prontas da linguagem natural, colete um script de teste (substituindo os nomes dos elementos necessários), ou seja, escreva uma especificação do Gauge. </li></ol><br><h2 id="integriruem-masquerade-i-gauge">  Integrando Masquerade e Gauge </h2><br><p>  Antes de usar o BDD, a abordagem de DPN era usada e, para trabalhar com ela, também otimizamos o processo de escrever o código do teste.  Pacotes jUnit / TestNG + WebDriver + Selenide + Masquerade usados. </p><br><p>  Agora, para trabalhar com o Gauge, adicionamos o plug-in correspondente ao intellij IDEA.  Depois disso, será possível criar um novo tipo de teste - Especificação. </p><br><p>  Agora criamos a especificação (script) e implementamos as etapas usando os recursos do WebDriver, Masquerade e Java. </p><br><p><img src="https://habrastorage.org/webt/en/7c/sk/en7cskb3yo2k5cbwcnp_alqlfyq.png"></p><br><p>  Clicamos na etapa do script e vamos para a implementação: </p><br><p><img src="https://habrastorage.org/webt/lh/rx/zq/lhrxzqa-9gsnfzbson9w4hqndce.png"></p><br><p>  Na implementação, você pode usar o método login () existente. </p><br><h2 id="kak-zhe-vyglyadit-eto-sovershenstvo">  Como é essa perfeição? </h2><br><p>  Lembre-se do exemplo que examinamos no início do artigo: </p><br><p><img src="https://habrastorage.org/webt/fg/s3/_e/fgs3_e71mp3t_ynlkbvbh-d6olw.png"></p><br><p>  <code>"Navigation.openMenu(menu)”</code> contém a implementação da abertura de um menu usando a biblioteca Masquerade. </p><br><p>  A biblioteca foi posteriormente expandida e surgiram etapas universais que poderiam ser usadas para qualquer aplicativo CUBA.  Estas são as etapas que permitem trabalhar com elementos do programa: botões, campos, tabelas.  Essas etapas universais se tornaram o conjunto de frases padrão que usamos no BDD para escrever scripts. </p><br><p>  Graças ao Masquerade + Gauge, reduzimos significativamente a complexidade da criação de testes.  Agora os testes podem ser escritos por pessoas que não possuem habilidades especiais de programação.  Um teste pode ser escrito por uma pessoa (antes, um script era inventado por uma, mas implementado por outra, o que gerava confusão).  Portanto, atingimos nosso objetivo - as interfaces são simplificadas e não será difícil para os analistas escrever scripts de teste. </p><br><p>  As alterações do processo são mostradas abaixo: </p><br><h6 id="bylo">  Foi: </h6><br><p><img src="https://habrastorage.org/webt/si/7y/m8/si7ym8xktulzmpgsvtsogu-5bfe.png" alt="Was"></p><br><h6 id="stalo">  Tornou-se: </h6><br><p><img src="https://habrastorage.org/webt/7d/vv/-a/7dvv-awtowdnlwwhifgz7_njoac.png" alt="Tornou-se"></p><br><p>  Em comparação, observa-se que os requisitos, a especificação e a documentação do teste são combinados em um parágrafo.  A documentação de teste também é um autoteste, com exceção da implementação de etapas de teste específicas. </p><br><h2 id="itogi">  Sumário </h2><br><p>  No momento, estamos desenvolvendo com sucesso de acordo com o esquema indicado acima.  E conseguimos nos livrar do principal problema do BDD - um aumento sério em termos devido à complexidade da implementação, adicionando e finalizando o kit de ferramentas.  No entanto, a qualidade da entrega do produto melhorou. </p><br><p>  O tempo necessário para manter a documentação é reduzido proporcionalmente ao número de especificações alteradas, porque  uma alteração na especificação (lógica do sistema) leva automaticamente a uma alteração no autoteste em uma iteração.  I.e.  o testador não precisa entrar no sistema de documentação (como Confluence etc.) para obter uma atualização, e isso também é válido para outros membros da equipe. </p><br><p>  O tempo para implementar e dar suporte a testes na presença de uma biblioteca que simplifica o trabalho com objetos de página foi reduzido pela metade em comparação ao trabalho com o driver da web limpo usual e o custo de refazer os links do XP. </p><br><p>  No desenvolvimento de qualquer solução comercial e no gerenciamento da qualidade - o custo de eliminar erros na coleta de requisitos e análises está crescendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exponencialmente</a> .  Assim, a probabilidade de problemas associados ao retrabalho do produto, de acordo com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos</a> e cronogramas existentes no desenvolvimento iterativo, com a detecção precoce de um problema, que é um bom estudo dos requisitos, reduz significativamente o custo de desenvolvimento, dependendo do projeto.  Pode ser 0% e ~ 40%.  É essa melhoria que é alcançada através da introdução do BDD.  Isso pode ser implementado sem chamar a palavra BDD, mas existe no BDD.  Ser capaz de contornar problemas é uma parte importante da garantia da qualidade. </p><br><p>  Concluindo, gostaria de observar que esse esquema de desenvolvimento também está integrado à Integração Contínua e ao sistema de gerenciamento de teste de QA Lens desenvolvido em nossa empresa.  No QA Lens, você pode escrever os mesmos scripts que no IDEA usando uma linguagem orientada ao assunto.  Esse idioma consiste em um glossário compilado anteriormente de ações disponíveis que foram implementadas anteriormente.  Ao executar um autoteste no Gauge a partir da máquina de um desenvolvedor ou IC, o QA Lens anota automaticamente quais etapas do script foram concluídas e quais não.  Assim, após executar um autoteste de um script escrito por um analista, o departamento de testes recebe imediatamente informações completas e atualizadas sobre o estado do produto. </p><br><p>  Autores: Sunagatov Ildar e Yushkova Julia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Yushkova</a> ) <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459134/">https://habr.com/ru/post/pt459134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459120/index.html">Computadores modulares incorporados da série UNO-1000/2000</a></li>
<li><a href="../pt459122/index.html">Aleksey Savvateev: Prêmio Nobel de Jean Tyrol por analisar mercados imperfeitos (2014) e reputação coletiva</a></li>
<li><a href="../pt459126/index.html">Tanque de robô Raspberry Pi com bastão de computador Intel Neural 2</a></li>
<li><a href="../pt459128/index.html">Interfaces japonesas no mundo real</a></li>
<li><a href="../pt459130/index.html">Manipulação suave de erros em microsserviços</a></li>
<li><a href="../pt459136/index.html">Pílula azul falsa</a></li>
<li><a href="../pt459138/index.html">Como a chave secreta da Huawei entrou no firmware dos roteadores Cisco</a></li>
<li><a href="../pt459140/index.html">Colocação do implante: como isso é feito?</a></li>
<li><a href="../pt459142/index.html">Construindo um gráfico de linha de média móvel animado em R. Recuperando dados através da API da NBA</a></li>
<li><a href="../pt459144/index.html">Frontend Weekly Digest (1 a 7 de julho de 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>