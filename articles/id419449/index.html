<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📊 👇🏼 🙄 API Redux vs. Bereaksi Konteks 🎆 ⛏️ 🖐🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di Bereaksi 16.3, API Konteks baru telah ditambahkan. Baru dalam arti bahwa API Konteks lama ada di belakang layar, kebanyakan orang entah tidak tahu ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API Redux vs. Bereaksi Konteks</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419449/"><img src="https://habrastorage.org/webt/fg/fp/ik/fgfpikxzusi8yqxz5vioyhdjgxm.png"><br><br>  Di Bereaksi 16.3, API Konteks baru telah ditambahkan.  <i>Baru</i> dalam arti bahwa API Konteks <i>lama</i> ada di belakang layar, kebanyakan orang entah tidak tahu tentang keberadaannya atau tidak menggunakannya, karena dokumentasi menyarankan untuk tidak menggunakannya. <br><br>  Namun, sekarang Context API adalah bagian penuh dari Bereaksi, terbuka untuk digunakan (tidak seperti sebelumnya, secara resmi). <br><a name="habracut"></a><br>  Segera setelah rilis Bereaksi 16.3, artikel muncul yang memproklamirkan kematian Redux karena API Konteks baru.  Jika Anda bertanya kepada Redux tentang ini, saya pikir dia akan menjawab - "laporan kematian saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sangat dilebih-lebihkan</a> ." <br><br>  Dalam posting ini saya ingin berbicara tentang bagaimana API Konteks baru berfungsi, bagaimana tampilannya seperti Redux, ketika Anda dapat menggunakan Konteks daripada Redux, dan mengapa Konteks tidak menggantikan Redux dalam setiap kasus. <br><br>  <b>Jika Anda hanya ingin ikhtisar API Konteks, Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengikuti tautan</a> .</b> <br><br><h3>  Bereaksi Contoh Aplikasi </h3><br>  Saya akan menyarankan agar Anda memiliki pemahaman tentang prinsip-prinsip bekerja dengan negara bagian dalam React (properti &amp; negara bagian), tetapi jika tidak, saya memiliki kursus 5 hari gratis untuk membantu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda mempelajarinya</a> . <br><br>  Mari kita lihat contoh yang membawa kita pada konsep yang digunakan di Redux.  Kita akan mulai dengan React versi sederhana, dan kemudian melihat tampilannya di Redux dan akhirnya dengan Context. <br><br><img src="https://habrastorage.org/webt/tq/8q/ze/tq8qzesfpe66d4kveo0p6y10cv0.png"><br><br>  Dalam aplikasi ini, informasi pengguna ditampilkan di dua tempat: di bilah navigasi di sudut kanan atas dan di panel samping di sebelah konten utama. <br><br>  (Anda mungkin memperhatikan bahwa ada banyak kesamaan dengan Twitter. Bukan kebetulan! Salah satu cara terbaik untuk mengasah keterampilan Bereaksi Anda adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyalin (membuat replika situs / aplikasi yang ada)</a> . <br><br>  Struktur komponen terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/ld/x0/3j/ldx03joils7rg-6cszxkur0dm_u.png"><br><br>  Menggunakan pure React (hanya alat peraga), kita perlu menyimpan informasi pengguna cukup tinggi di pohon sehingga dapat diteruskan ke komponen yang membutuhkannya.  Dalam hal ini, informasi pengguna harus di Aplikasi. <br><br>  Kemudian, untuk mentransfer informasi tentang pengguna ke komponen-komponen yang membutuhkannya, aplikasi harus meneruskannya ke Nav dan Body.  Mereka, pada gilirannya, akan meneruskannya ke UserAvatar (hore!) Dan Sidebar.  Akhirnya, Sidebar harus meneruskannya ke UserStats. <br><br>  Mari kita lihat bagaimana ini bekerja dalam kode (saya meletakkan semuanya dalam satu file untuk membuatnya lebih mudah dibaca, tetapi sebenarnya mungkin akan dipecah menjadi file yang terpisah, mengikuti beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">struktur standar</a> ). <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./styles.css"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserAvatar = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ user, size }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( &lt;img className={`user-avatar ${size || ""}`} alt="user avatar" src={user.avatar} /&gt; ); const UserStats = ({ user }) =&gt; ( &lt;div className="user-stats"&gt; &lt;div&gt; &lt;UserAvatar user={user} /&gt; {user.name} &lt;/div&gt; &lt;div className="stats"&gt; &lt;div&gt;{user.followers} Followers&lt;/div&gt; &lt;div&gt;Following {user.following}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); const Nav = ({ user }) =&gt; ( &lt;div className="nav"&gt; &lt;UserAvatar user={user} size="small" /&gt; &lt;/div&gt; ); const Content = () =&gt; &lt;div className="content"&gt;main content here&lt;/div&gt;; const Sidebar = ({ user }) =&gt; ( &lt;div className="sidebar"&gt; &lt;UserStats user={user} /&gt; &lt;/div&gt; ); const Body = ({ user }) =&gt; ( &lt;div className="body"&gt; &lt;Sidebar user={user} /&gt; &lt;Content user={user} /&gt; &lt;/div&gt; ); class App extends React.Component { state = { user: { avatar: "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b", name: "Dave", followers: 1234, following: 123 } }; render() { const { user } = this.state; return ( &lt;div className="app"&gt; &lt;Nav user={user} /&gt; &lt;Body user={user} /&gt; &lt;/div&gt; ); } } ReactDOM.render(&lt;App /&gt;, document.querySelector("#root"));</code> </pre> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sampel CodeSandbox</a> <br><br>  Di sini Aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menginisialisasi keadaan yang</a> mengandung objek pengguna.  Dalam aplikasi nyata, Anda kemungkinan besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengekstraksi data ini dari server</a> dan menyimpannya dalam keadaan untuk dirender. <br><br>  Mengenai alat peraga ("pengeboran prop"), <i>ini bukan masalah besar</i> .  Ini bekerja dengan baik.  Melemparkan alat peraga, ini adalah contoh ideal Bereaksi.  Tetapi melemparkan jauh ke dalam pohon negara bisa sedikit mengganggu saat menulis.  Dan semakin menjengkelkan jika Anda harus mengirimkan banyak props'ov (dan bukan satu). <br><br>  Namun, ada minus besar dalam strategi ini: ini menciptakan koneksi antara komponen yang tidak boleh dihubungkan.  Dalam contoh di atas, Nav harus menerima prop "pengguna" dan meneruskannya ke UserAvatar, bahkan jika Nav tidak membutuhkannya. <br><br>  Komponen yang digabungkan dengan erat (seperti yang memberikan alat peraga kepada anak-anak mereka) lebih sulit untuk digunakan kembali, karena Anda harus mengikatnya kepada orang tua baru setiap kali Anda menggunakannya di tempat baru. <br><br>  Mari kita lihat bagaimana kita dapat meningkatkan ini. <br><br><h3>  Sebelum menggunakan Konteks atau Redux ... </h3><br>  Jika Anda dapat menemukan cara untuk <i>menggabungkan</i> struktur aplikasi Anda dan mengambil keuntungan dari memberikan props kepada keturunan, ini dapat membuat kode Anda lebih bersih tanpa harus beralih ke props, <i>Context</i> , atau <i>Redux</i> . <br><br>  Dalam contoh ini, alat peraga anak-anak adalah solusi hebat untuk komponen yang perlu universal, seperti Nav, Sidebar, dan Body.  Perlu diketahui juga bahwa Anda dapat meneruskan JSX ke properti <i>apa pun</i> , tidak hanya untuk anak-anak - karena itu, jika Anda memerlukan lebih dari satu "slot" untuk menghubungkan komponen, ingat ini. <br><br>  Berikut adalah contoh aplikasi Bereaksi di mana Nav, Body, dan Sidebar mengambil anak-anak dan menampilkannya apa adanya.  Dengan demikian, orang yang menggunakan komponen tidak perlu khawatir tentang mentransfer data tertentu yang diperlukan oleh komponen.  Dia hanya dapat menampilkan apa yang dia butuhkan di tempat, menggunakan data yang sudah dia miliki dalam ruang lingkup.  Contoh ini juga menunjukkan cara menggunakan alat peraga apa pun untuk mengirimkan anak-anak. <br><br>  (Terima kasih kepada Dan Abramov untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penawaran ini</a> !) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./styles.css"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserAvatar = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ user, size }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( &lt;img className={`user-avatar ${size || ""}`} alt="user avatar" src={user.avatar} /&gt; ); const UserStats = ({ user }) =&gt; ( &lt;div className="user-stats"&gt; &lt;div&gt; &lt;UserAvatar user={user} /&gt; {user.name} &lt;/div&gt; &lt;div className="stats"&gt; &lt;div&gt;{user.followers} Followers&lt;/div&gt; &lt;div&gt;Following {user.following}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); //  children   . const Nav = ({ children }) =&gt; ( &lt;div className="nav"&gt; {children} &lt;/div&gt; ); const Content = () =&gt; ( &lt;div className="content"&gt;main content here&lt;/div&gt; ); const Sidebar = ({ children }) =&gt; ( &lt;div className="sidebar"&gt; {children} &lt;/div&gt; ); // Body   sidebar  content,    , //    . const Body = ({ sidebar, content }) =&gt; ( &lt;div className="body"&gt; &lt;Sidebar&gt;{sidebar}&lt;/Sidebar&gt; {content} &lt;/div&gt; ); class App extends React.Component { state = { user: { avatar: "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b", name: "Dave", followers: 1234, following: 123 } }; render() { const { user } = this.state; return ( &lt;div className="app"&gt; &lt;Nav&gt; &lt;UserAvatar user={user} size="small" /&gt; &lt;/Nav&gt; &lt;Body sidebar={&lt;UserStats user={user} /&gt;} content={&lt;Content /&gt;} /&gt; &lt;/div&gt; ); } } ReactDOM.render(&lt;App /&gt;, document.querySelector("#root"));</code> </pre> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sampel CodeSandbox</a> <br><br>  Jika aplikasi Anda terlalu rumit (lebih rumit dari contoh ini!), Mungkin sulit untuk memahami bagaimana menyesuaikan templat dengan anak-anak.  Mari kita lihat bagaimana Anda bisa mengganti penerusan alat peraga dengan Redux. <br><br><h3>  Contoh redux </h3><br>  Saya akan melihat sekilas contoh Redux sehingga kita bisa mendapatkan pemahaman yang lebih dalam tentang bagaimana Context bekerja, jadi jika Anda tidak memiliki pemahaman yang jelas tentang Redux, pertama-tama baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengantar saya untuk Redux</a> (atau tonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">videonya</a> ). <br><br>  Berikut adalah aplikasi Bereaksi kami yang dirancang ulang untuk menggunakan Redux.  Informasi pengguna telah dipindahkan ke toko Redux, yang berarti bahwa kita dapat menggunakan fungsi connect-redux connect untuk secara langsung meneruskan prop pengguna ke komponen yang membutuhkannya. <br><br>  Ini adalah kemenangan besar dalam hal menyingkirkan keterhubungan.  Lihatlah Nav, Body, dan Sidebar, dan Anda akan melihat bahwa mereka tidak lagi menerima atau mengirimkan prop pengguna.  Mereka tidak lagi bermain kentang panas dengan alat peraga.  Tidak ada lagi koneksi yang tidak berguna. <br><br>  Peredam tidak banyak berpengaruh di sini;  ini cukup sederhana.  Saya memiliki satu hal lagi tentang cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerja redux Redux</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara menulis kode</a> yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak dapat diubah</a> yang mereka gunakan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    createStore, connect, and Provider: import { createStore } from "redux"; import { connect, Provider } from "react-redux"; //  reducer       . const initialState = {}; function reducer(state = initialState, action) { switch (action.type) { //    action SET_USER  state. case "SET_USER": return { ...state, user: action.user }; default: return state; } } //  store  reducer'   . const store = createStore(reducer); // Dispatch' action     user. store.dispatch({ type: "SET_USER", user: { avatar: "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b", name: "Dave", followers: 1234, following: 123 } }); //   mapStateToProps,      state (user) //     `user` prop. const mapStateToProps = state =&gt; ({ user: state.user }); //  UserAvatar    connect(),    //`user` ,      . //     2 : // const UserAvatarAtom = ({ user, size }) =&gt; ( ... ) // const UserAvatar = connect(mapStateToProps)(UserAvatarAtom); const UserAvatar = connect(mapStateToProps)(({ user, size }) =&gt; ( &lt;img className={`user-avatar ${size || ""}`} alt="user avatar" src={user.avatar} /&gt; )); //   UserStats    connect(),    // `user` . const UserStats = connect(mapStateToProps)(({ user }) =&gt; ( &lt;div className="user-stats"&gt; &lt;div&gt; &lt;UserAvatar /&gt; {user.name} &lt;/div&gt; &lt;div className="stats"&gt; &lt;div&gt;{user.followers} Followers&lt;/div&gt; &lt;div&gt;Following {user.following}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )); //    Nav      `user`. const Nav = () =&gt; ( &lt;div className="nav"&gt; &lt;UserAvatar size="small" /&gt; &lt;/div&gt; ); const Content = () =&gt; ( &lt;div className="content"&gt;main content here&lt;/div&gt; ); //   Sidebar. const Sidebar = () =&gt; ( &lt;div className="sidebar"&gt; &lt;UserStats /&gt; &lt;/div&gt; ); //   Body. const Body = () =&gt; ( &lt;div className="body"&gt; &lt;Sidebar /&gt; &lt;Content /&gt; &lt;/div&gt; ); //  App    ,     . const App = () =&gt; ( &lt;div className="app"&gt; &lt;Nav /&gt; &lt;Body /&gt; &lt;/div&gt; ); //     Provider, //   connect()    store. ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.querySelector("#root") );</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sampel CodeSandbox</a> <br><br>  Sekarang Anda mungkin bertanya-tanya bagaimana Redux mencapai keajaiban ini.  Luar biasa  Bagaimana React tidak mendukung kelulusan alat peraga ke beberapa level, dan bisakah Redux melakukan ini? <br><br>  Jawabannya adalah bahwa Redux menggunakan fungsi <i>konteks</i> Bereaksi (fitur konteks).  Bukan API Konteks modern (belum), tetapi yang lama.  Salah satu yang menurut dokumentasi Bereaksi tidak digunakan kecuali Anda menulis perpustakaan sendiri atau mengetahui apa yang Anda lakukan. <br><br>  Konteksnya mirip dengan bus komputer yang mengikuti setiap komponen: untuk mendapatkan daya (data) melewatinya, Anda hanya perlu terhubung.  Dan reaksi-redux connect tidak hanya itu. <br><br>  Namun, fitur Redux ini hanyalah puncak gunung es.  Mentransfer data ke tempat yang tepat adalah fitur Redux yang paling <i>jelas</i> .  Berikut adalah beberapa manfaat lain yang Anda dapatkan di luar kotak: <br><br>  <b>menghubungkan adalah fungsi murni</b> <br><br>  terhubung secara otomatis membuat komponen yang terhubung menjadi "bersih", artinya, komponen tersebut hanya akan dirender ulang ketika propsnya berubah - yaitu, ketika irisan status Redux berubah.  Ini mencegah rendering ulang yang tidak perlu dan mempercepat aplikasi. <br><br>  <b>Mudah debugging dengan Redux</b> <br><br>  Upacara tindakan menulis dan reduksi diimbangi oleh kemudahan debugging yang Redux berikan kepada Anda. <br><br>  Dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi Redux DevTools,</a> Anda mendapatkan log otomatis semua tindakan yang dilakukan oleh aplikasi Anda.  Kapan saja, Anda dapat membukanya dan melihat tindakan apa yang diluncurkan, berapa payloadnya, dan nyatakan sebelum dan sesudah tindakan. <br><br><img src="https://habrastorage.org/webt/go/km/oi/gokmoivlzezzfb-wjkhujjyxep8.gif"><br><br>  Fitur hebat lainnya yang disediakan Redux DevTools adalah debugging menggunakan <i>"perjalanan waktu"</i> , yaitu, Anda dapat mengeklik tindakan apa pun sebelumnya dan pergi ke titik waktu ini, langsung ke saat ini.  Alasannya adalah karena setiap tindakan memperbarui toko dengan <i>cara yang sama</i> , sehingga Anda dapat mengambil daftar pembaruan status yang direkam dan memutarnya tanpa efek samping, dan berakhir di tempat yang Anda inginkan. <br><br>  Ada juga alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LogRocket</a> , yang pada dasarnya memberi Anda Redux DevTools permanen dalam <i>produksi</i> untuk setiap pengguna Anda.  Punya laporan bug?  Tidak masalah  Lihatlah sesi pengguna ini di LogRocket, dan Anda dapat melihat pengulangan dari apa yang dia lakukan dan tindakan apa yang diluncurkan.  Semua ini berfungsi menggunakan aliran aksi Redux. <br><br>  <b>Memperluas Redux dengan Middleware</b> <br><br>  Redux mendukung konsep middleware (kata mewah untuk "fungsi yang berjalan setiap kali tindakan dikirim").  Menulis middleware Anda sendiri tidak sesulit kelihatannya, dan memungkinkan Anda menggunakan beberapa alat canggih. <br><br>  Misalnya ... <br><br><ul><li>  Ingin mengirim permintaan API setiap kali nama tindakan dimulai dengan FETCH_?  Anda dapat melakukan ini dengan middleware. </li><li>  Ingin tempat tersentralisasi untuk mencatat peristiwa dalam perangkat lunak analisis Anda?  Middleware adalah tempat yang baik untuk melakukan ini. </li><li>  Ingin mencegah tindakan memulai pada titik waktu tertentu?  Anda dapat melakukan ini dengan middleware, tidak terlihat oleh aplikasi Anda yang lain. </li><li>  Ingin mencegat tindakan yang memiliki token JWT dan secara otomatis menyimpannya ke localStorage?  Ya, middleware. </li></ul><br>  Berikut ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> bagus dengan contoh cara menulis Redux middleware. <br><br><h4>  Cara menggunakan React Context API </h4><br>  Tapi mungkin Anda tidak membutuhkan semua keanehan Redux ini.  Anda mungkin tidak perlu debugging sederhana, tuning, atau peningkatan kinerja otomatis - semua yang ingin Anda lakukan adalah mentransfer data dengan mudah.  Mungkin aplikasi Anda kecil, atau Anda hanya perlu dengan cepat melakukan sesuatu dan menangani seluk-beluk nanti. <br><br>  API Konteks baru mungkin tepat untuk Anda.  Mari kita lihat cara kerjanya. <br><br>  Saya memposting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial</a> API Konteks cepat di Egghead jika Anda lebih suka menonton daripada membaca (3:43). <br><br>  Berikut adalah 3 komponen penting dari API Konteks: <br><br><ul><li>  Fungsi React.createContext yang menciptakan konteks </li><li>  Penyedia (mengembalikan createContext), yang mengatur "bus", <br>  melewati pohon komponen </li><li>  Konsumen (juga membuat Konteks dikembalikan) yang masuk ke dalam <br>  "Bus listrik" untuk ekstraksi data </li></ul><br>  Penyedia sangat mirip dengan Penyedia di React-Redux.  Itu mengambil nilai yang bisa menjadi apa pun yang Anda inginkan (bahkan bisa menjadi toko Redux ... tapi itu bodoh).  Kemungkinan besar, ini adalah objek yang berisi data Anda dan tindakan apa pun yang ingin Anda lakukan dengan data tersebut. <br><br>  Konsumen bekerja sedikit seperti fungsi koneksi di React-Redux, menghubungkan ke data dan membuatnya tersedia untuk komponen yang menggunakannya. <br><br>  Berikut adalah hal-hal menariknya: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     context //    2 : { Provider, Consumer } // ,   ,  UpperCase,  camelCase //  ,          , //        . const UserContext = React.createContext(); // ,     context, //   Consumer. // Consumer   "render props". const UserAvatar = ({ size }) =&gt; ( &lt;UserContext.Consumer&gt; {user =&gt; ( &lt;img className={`user-avatar ${size || ""}`} alt="user avatar" src={user.avatar} /&gt; )} &lt;/UserContext.Consumer&gt; ); // ,      "user prop", //   Consumer    context. const UserStats = () =&gt; ( &lt;UserContext.Consumer&gt; {user =&gt; ( &lt;div className="user-stats"&gt; &lt;div&gt; &lt;UserAvatar user={user} /&gt; {user.name} &lt;/div&gt; &lt;div className="stats"&gt; &lt;div&gt;{user.followers} Followers&lt;/div&gt; &lt;div&gt;Following {user.following}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )} &lt;/UserContext.Consumer&gt; ); // ...    ... // ... (      `user`). //  App   context ,  Provider. class App extends React.Component { state = { user: { avatar: "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b", name: "Dave", followers: 1234, following: 123 } }; render() { return ( &lt;div className="app"&gt; &lt;UserContext.Provider value={this.state.user}&gt; &lt;Nav /&gt; &lt;Body /&gt; &lt;/UserContext.Provider&gt; &lt;/div&gt; ); } }</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sampel CodeSandbox</a> <br><br>  Mari kita lihat cara kerjanya. <br><br>  Ingat, kami memiliki 3 bagian: konteks itu sendiri (dibuat menggunakan React.createContext) dan dua komponen yang berinteraksi dengannya (Penyedia dan Konsumen). <br><br>  <b>Penyedia dan Konsumen bekerja bersama</b> <br><br>  Penyedia dan Konsumen terkait dan tidak dapat dipisahkan.  Mereka hanya tahu bagaimana berinteraksi satu sama lain.  Jika Anda membuat dua konteks yang terpisah, katakan, "Context1" dan "Context2", maka Provider dan Consumer Context1 tidak akan dapat berkomunikasi dengan Provider dan Consumer Context2. <br><br>  <b>Konteks tidak mengandung status</b> <br><br>  Perhatikan bahwa konteks <i>tidak memiliki keadaannya sendiri</i> .  Ini hanya saluran untuk data Anda.  Anda harus memberikan nilainya kepada Penyedia, dan nilai itu akan diteruskan ke Konsumen mana pun yang tahu cara mencarinya (Penyedia terikat pada konteks yang sama dengan Konsumen). <br><br>  Saat Anda membuat konteks, Anda dapat melewati "default" sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ctx = React.createContext(yourDefaultValue);</code> </pre><br><br>  Nilai default adalah apa yang akan diterima Konsumen ketika ditempatkan di pohon tanpa Penyedia di atasnya.  Jika Anda tidak lulus, nilainya akan tidak ditentukan.  Perhatikan bahwa ini <i>adalah nilai default</i> , bukan nilai <i>awal</i> .  Konteks tidak menyimpan apa pun;  itu hanya menyebarkan data yang Anda masukkan ke dalamnya. <br><br>  <b>Konsumen Menggunakan Pola Alat Peraga Render</b> <br><br>  Fungsi hubungkan Redux adalah komponen dengan urutan lebih tinggi (disingkat HoC).  Itu membungkus komponen lain dan melewati alat peraga ke dalamnya. <br><br>  Konsumen, sebaliknya, mengharapkan komponen anak menjadi suatu fungsi.  Kemudian ia memanggil fungsi ini selama rendering, meneruskan nilai yang diterimanya dari Penyedia di suatu tempat di atasnya (baik nilai default dari konteks, atau tidak terdefinisi jika Anda tidak melewati nilai default). <br><br>  <b>Penyedia mengambil satu nilai.</b> <br><br>  Hanya satu nilai, seperti prop.  Tapi ingat, nilainya bisa apa saja.  Dalam praktiknya, jika Anda ingin meneruskan beberapa nilai, Anda harus membuat objek dengan semua nilai dan meneruskan objek ini. <br><br><h3>  API konteks fleksibel </h3><br>  Karena menciptakan konteks memberi kita dua komponen untuk dikerjakan (Penyedia dan Konsumen), kita dapat menggunakannya sesuai keinginan.  Berikut ini beberapa ide. <br><br>  <b>Bungkus Konsumen dalam HOC</b> <br><br>  Tidak suka gagasan menambahkan UserContext.Consumer di setiap tempat yang membutuhkannya?  Ini kodemu!  Anda memiliki hak untuk memutuskan apa yang akan menjadi pilihan terbaik Anda. <br><br>  Jika Anda lebih suka mendapatkan nilai sebagai prop, Anda dapat menulis pembungkus kecil di sekitar Konsumen sebagai berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Component</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConnectedComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;UserContext.Consumer&gt; {user =&gt; &lt;Component {...props} user={user}/&gt;} &lt;/UserContext.Consumer&gt; ); } }</code> </pre><br>  Setelah itu, Anda dapat menulis ulang, misalnya, UserAvatar menggunakan fungsi withUser: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserAvatar = withUser(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ size, user }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">`</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">user-avatar</span></span></span></span><span class="xml"><span class="hljs-tag"> ${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span></span><span class="xml"><span class="hljs-tag"> || ""}`} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"user avatar"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{user.avatar}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> ));</span></span></code> </pre><br>  Dan voila, konteks bisa berfungsi seperti menghubungkan Redux.  Minus kebersihan otomatis. <br><br>  Berikut adalah contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CodeSandbox</a> dengan HOC ini. <br><br>  <b>Simpan Status di Penyedia</b> <br><br>  Ingat bahwa Penyedia hanyalah saluran.  Itu tidak menyimpan data apa pun.  Tapi ini tidak menghentikan Anda dari membuat pembungkus Anda <i>sendiri</i> untuk menyimpan data. <br><br>  Pada contoh di atas, data disimpan di App, jadi satu-satunya hal yang perlu Anda pahami adalah komponen Provider + Consumer.  Tapi mungkin Anda ingin membuat toko sendiri.  Anda dapat membuat komponen untuk menyimpan status dan meneruskannya melalui konteks: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserStore</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: { <span class="hljs-attr"><span class="hljs-attr">avatar</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Dave"</span></span>, <span class="hljs-attr"><span class="hljs-attr">followers</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">following</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span> } }; render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;UserContext.Provider value={</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.user}&gt; {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.props.children} &lt;</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/UserContext.Provider&gt; ); } } /</span></span></span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/ ...    ... const App = () =&gt; ( &lt;div className="app"&gt; &lt;Nav /</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &lt;Body </span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/&gt; &lt;/</span></span></span></span><span class="hljs-function"><span class="hljs-params">div&gt; </span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReactDOM</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;UserStore&gt; &lt;App </span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/&gt; &lt;/</span></span></span></span><span class="hljs-function"><span class="hljs-params">UserStore&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">document</span></span></span></span><span class="hljs-function"><span class="hljs-params">.querySelector(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"#root"</span></span></span></span></span><span class="hljs-function">) );</span></span></code> </pre><br>  Sekarang data pengguna terkandung dalam komponennya <i>sendiri</i> , yang tugas utamanya adalah data ini.  Keren  Aplikasi dapat kembali menjadi stateless.  Saya pikir itu terlihat sedikit lebih bersih. <br><br>  Berikut adalah contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CodeSandbox</a> dengan UserStore ini. <br><br>  <b>Lemparkan tindakan ke bawah melalui konteks</b> <br><br>  Ingatlah bahwa objek yang melewati Penyedia dapat berisi semua yang Anda inginkan.  Ini berarti bahwa itu mungkin mengandung fungsi.  Anda bahkan dapat menyebutkan tindakan mereka. <br><br>  Inilah contoh baru: ruangan sederhana dengan sakelar untuk mengganti warna latar belakang - oh, maksudku cahaya. <br><br><img src="https://habrastorage.org/webt/di/s4/r1/dis4r10ujowkvv5pn9mgx9b6jbs.gif"><br><br>  Keadaan disimpan di toko, yang juga memiliki fungsi beralih cahaya.  Baik negara dan fungsi dilewatkan melalui konteks. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./styles.css"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  context. const RoomContext = React.createContext(); // ,     //   . class RoomStore extends React.Component { state = { isLit: false }; toggleLight = () =&gt; { this.setState(state =&gt; ({ isLit: !state.isLit })); }; render() { //  state  onToggleLight action return ( &lt;RoomContext.Provider value={{ isLit: this.state.isLit, onToggleLight: this.toggleLight }} &gt; {this.props.children} &lt;/RoomContext.Provider&gt; ); } } //    ,    , //       RoomContext. const Room = () =&gt; ( &lt;RoomContext.Consumer&gt; {({ isLit, onToggleLight }) =&gt; ( &lt;div className={`room ${isLit ? "lit" : "dark"}`}&gt; The room is {isLit ? "lit" : "dark"}. &lt;br /&gt; &lt;button onClick={onToggleLight}&gt;Flip&lt;/button&gt; &lt;/div&gt; )} &lt;/RoomContext.Consumer&gt; ); const App = () =&gt; ( &lt;div className="app"&gt; &lt;Room /&gt; &lt;/div&gt; ); //     RoomStore, //           . ReactDOM.render( &lt;RoomStore&gt; &lt;App /&gt; &lt;/RoomStore&gt;, document.querySelector("#root") );</span></span></code> </pre><br>  Berikut adalah contoh kerja lengkap di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CodeSandbox</a> . <br><br>  <b>Jadi, apa yang harus digunakan, Konteks atau Redux?</b> <br><br>  Sekarang Anda telah melihat kedua jalur, yang mana yang layak digunakan?  Saya tahu Anda hanya ingin mendengar jawaban untuk pertanyaan ini, tetapi saya harus menjawab - "itu tergantung pada Anda." <br><br>  Itu tergantung pada seberapa besar aplikasi Anda sekarang atau seberapa cepat itu akan tumbuh.  Berapa banyak orang yang akan mengerjakannya - hanya Anda atau tim besar?  Seberapa berpengalaman Anda atau tim Anda dalam bekerja dengan konsep-konsep fungsional yang diandalkan Redux (seperti kekekalan dan fitur murni). <br><br>  Kesalahan fatal yang merembes ke seluruh ekosistem JavaScript adalah gagasan <i>kompetisi</i> .  Ada gagasan bahwa setiap pilihan adalah permainan zero-sum: jika Anda menggunakan <i>perpustakaan</i> A, Anda tidak boleh menggunakan <i>perpustakaan</i> pesaingnya B. Bahwa ketika perpustakaan baru keluar yang lebih baik dari yang sebelumnya, ia harus menyingkirkan yang sudah ada.  Bahwa semuanya harus / atau bahwa Anda harus memilih yang terbaru dan yang terbaik, atau diturunkan ke latar belakang dengan pengembang dari masa lalu. <br><br>  Pendekatan terbaik adalah dengan melihat pilihan yang luar biasa ini dengan contoh, seperangkat alat.  Itu seperti memilih antara menggunakan obeng atau obeng yang kuat.  Untuk 80% kasus, obeng akan melakukan pekerjaan lebih mudah dan lebih cepat daripada obeng.  Tetapi untuk 20% lainnya, obeng akan menjadi pilihan terbaik (tidak cukup ruang, atau item tipis).  Ketika saya membeli obeng, saya tidak langsung membuang obeng, dia tidak menggantinya, tetapi hanya memberi saya pilihan lain.  Cara lain untuk memecahkan masalah. <br><br>  Konteks tidak "mengganti" Redux, tidak lebih dari Bereaksi "ganti" Angular atau jQuery.  Sial, saya masih menggunakan jQuery ketika saya harus melakukan sesuatu dengan cepat.  Saya terkadang masih menggunakan templat EJS sisi-server alih-alih menggunakan aplikasi Bereaksi.  Kadang-kadang Bereaksi lebih dari yang Anda butuhkan untuk menyelesaikan tugas.  Hal yang sama berlaku untuk Redux. <br><br>  Hari ini, jika Redux lebih dari yang Anda butuhkan, Anda dapat menggunakan konteks. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Belajar Bereaksi bisa jadi sulit - ada begitu banyak perpustakaan dan alat! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saran saya </font><font style="vertical-align: inherit;">Abaikan semuanya :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk tutorial langkah demi langkah, baca buku saya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Pure React</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419449/">https://habr.com/ru/post/id419449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419429/index.html">Saya berusia 57 dan saya seorang ahli scrum</a></li>
<li><a href="../id419433/index.html">Laporan DSW - Pembuat Laporan DeepSeeWeb</a></li>
<li><a href="../id419437/index.html">AR - Augmented Reality (artikel plus video)</a></li>
<li><a href="../id419439/index.html">Bagaimana e-commerce bertahan dalam promosi skala besar. Bersiap untuk beban puncak di web [Bagian 2]</a></li>
<li><a href="../id419441/index.html">SpaceX pertama menggunakan kembali roket Falcon 9 Block 5 hari ini</a></li>
<li><a href="../id419451/index.html">Buat bundel untuk Symfony 4 langkah demi langkah</a></li>
<li><a href="../id419453/index.html">Metode numerik untuk memecahkan sistem persamaan nonlinier</a></li>
<li><a href="../id419457/index.html">RabbitMQ - SQL Server</a></li>
<li><a href="../id419459/index.html">Baterai timbal-asam: alfabet pengisian daya pulsa</a></li>
<li><a href="../id419461/index.html">Ventilasi kamar kecil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>