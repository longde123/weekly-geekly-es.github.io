<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôé üÜö ‚ôàÔ∏è Aceleramos el procesamiento distribuido de gr√°ficos grandes utilizando estructuras de datos probabil√≠sticas y no solo üè° üßñüèæ ü§∏üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uno de los recursos m√°s valiosos de cualquier red social es el "gr√°fico de las amistades": la informaci√≥n se difunde a trav√©s de las conexiones en est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aceleramos el procesamiento distribuido de gr√°ficos grandes utilizando estructuras de datos probabil√≠sticas y no solo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/465985/"><p><img src="https://habrastorage.org/webt/u1/y0/hk/u1y0hkslkriigc-z1_wkrilk2bm.jpeg"></p><br><p>  Uno de los recursos m√°s valiosos de cualquier red social es el "gr√°fico de las amistades": la informaci√≥n se difunde a trav√©s de las conexiones en esta columna, se env√≠a contenido interesante a los usuarios y se env√≠an comentarios constructivos a los autores del contenido.  Adem√°s, el gr√°fico tambi√©n es una fuente importante de informaci√≥n que le permite comprender mejor al usuario y mejorar continuamente el servicio.  Sin embargo, en los casos en que el gr√°fico crece, t√©cnicamente es cada vez m√°s dif√≠cil extraer informaci√≥n del mismo.  En este art√≠culo hablaremos sobre algunos trucos utilizados para procesar gr√°ficos grandes en OK.ru. </p><a name="habracut"></a><br><p>  Para comenzar, considere una tarea simple del mundo real: determinar la edad del usuario.  Conocer la edad permite a la red social seleccionar contenido m√°s relevante y adaptarse mejor a la persona.  Parece que la edad ya est√° indicada al crear una p√°gina en las redes sociales, pero de hecho, con bastante frecuencia, los usuarios son astutos e indican una edad diferente de la real.  Un gr√°fico social puede ayudar a rectificar la situaci√≥n :). </p><br><p> Tomemos, por ejemplo, Bob (todos los personajes del art√≠culo son ficticios, cualquier coincidencia con la realidad es el resultado de la creatividad de una casa al azar): </p><br><p><img src="https://habrastorage.org/webt/wq/ht/tp/wqhttpoxzxunnad14b4csy9owhe.png"></p><br><p>  Por un lado, la mitad de los amigos de Bob son adolescentes, lo que sugiere que Bob tambi√©n es un adolescente.  Pero tambi√©n tiene amigos mayores, por lo que la confianza en la respuesta es baja.  La informaci√≥n adicional del gr√°fico social puede ayudar a aclarar la respuesta: </p><br><p><img src="https://habrastorage.org/webt/w5/ef/ku/w5efku89o5lqu0hrv0kbrl9nte8.png"></p><br><p>  Al tener en cuenta no solo los arcos en los que Bob est√° directamente involucrado, sino tambi√©n los arcos entre sus amigos, podemos ver que Bob es parte de una densa comunidad de adolescentes, lo que nos permite llegar a una conclusi√≥n sobre su edad con un mayor grado de confianza. </p><br><p>  Dicha estructura de datos se conoce como una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">red del ego</a> o subgrafo del ego; durante mucho tiempo se ha utilizado con √©xito para resolver muchos problemas: b√∫squeda de comunidades, identificaci√≥n de bots y spam, recomendaciones de amigos y contenido, etc.  Sin embargo, el c√°lculo del ego de una subgraf√≠a para <strong>todos los</strong> usuarios en un gr√°fico con cientos de millones de nodos y decenas de miles de millones de arcos est√° plagado de una serie de "peque√±as dificultades t√©cnicas" :). </p><br><p>  El principal problema es que al considerar la informaci√≥n sobre el "segundo paso" en el gr√°fico, se produce una explosi√≥n cuadr√°tica del n√∫mero de conexiones.  Por ejemplo, para un usuario con 150 enlaces directos del ego, una subgraf√≠a puede incluir hasta <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2">150</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-4">150</span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0.267em; margin-right: 0.267em;">‚àó</span><span class="MJXp-mn" id="MJXp-Span-6">149</span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-9">2</span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-11"><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-13">11</span><span class="MJXp-mo" id="MJXp-Span-14" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-15">32</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> 150 + 150 * 149/2 = $ 11,32</script>  enlaces, y para un usuario activo con 5,000 amigos, el subgrafo del ego puede crecer a m√°s de 12,000,000 enlaces. </p><br><p>  Una complicaci√≥n adicional es el hecho de que el gr√°fico se almacena en un entorno distribuido y ning√∫n nodo tiene una imagen completa del gr√°fico en la memoria.  El trabajo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la partici√≥n equilibrada de gr√°ficos se</a> lleva a cabo tanto en la academia como en la industria, pero incluso los mejores resultados al recopilar el subgrafo del ego conducen a la comunicaci√≥n "todos con todos": para obtener informaci√≥n sobre los amigos de los amigos del usuario, tendr√° que ir a todas las "particiones" en la mayor√≠a de los casos </p><br><p>  Una de las alternativas de trabajo en este caso ser√° la duplicaci√≥n forzada de datos (por ejemplo, el algoritmo 3 en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo de Google</a> ), pero esta duplicaci√≥n tampoco es gratuita.  Tratemos de descubrir qu√© se puede mejorar en este proceso. </p><br><h3 id="naivnyy-algoritm">  Algoritmo ingenuo </h3><br><p>  Para comenzar, considere el algoritmo "ingenuo" para generar un subgr√°fico del ego: </p><br><p><img src="https://habrastorage.org/webt/1o/zn/qz/1oznqzgjwr2iadbhoko7vgvp7hm.png"></p><br><p>  El algoritmo supone que el gr√°fico original se almacena como una lista de adyacencia, es decir.  La informaci√≥n sobre todos los amigos del usuario se almacena en un solo registro con la ID de usuario en la clave y la lista de ID de amigos en el valor.  Para dar el segundo paso y obtener informaci√≥n sobre amigos que necesita: </p><br><ol><li>  Convierta un gr√°fico en la lista de aristas, donde cada arista es una entrada separada. </li><li>  Haga que la lista de aristas se una sobre s√≠ misma, lo que dar√° todas las rutas en un gr√°fico de longitud 2. </li><li>  Agrupar por inicio de ruta. </li></ol><br><p>  En la salida para cada usuario, obtenemos listas de rutas de longitud 2 para cada usuario.  Cabe se√±alar aqu√≠ que la estructura resultante es en realidad una <strong>vecindad de dos pasos del usuario</strong> , mientras que la subgraf√≠a del ego es su subconjunto.  Por lo tanto, para completar el proceso, debemos filtrar todos los arcos que salen de los amigos inmediatos. </p><br><p>  Este algoritmo es bueno porque se implementa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos l√≠neas en Scala</a> bajo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apache Spark</a> .  Pero las ventajas terminan ah√≠: para un gr√°fico de tama√±o industrial, el volumen de comunicaci√≥n de la red est√° m√°s all√° del l√≠mite y el tiempo de operaci√≥n se mide en d√≠as.  La principal dificultad es creada por dos operaciones de barajado que ocurren cuando unimos y agrupamos.  ¬øEs posible reducir la cantidad de datos enviados? </p><br><h3 id="ego-podgraf-v-odin-shuffle">  Subgrafo del ego en una barajadura </h3><br><p>  Dado que nuestro gr√°fico de amistades es sim√©trico, puede usar las optimizaciones propuestas por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tomas Schank</a> : </p><br><ol><li>  Puede obtener todos los caminos de longitud 2 sin unirse: si Bob tiene amigos Alice y Harry, entonces hay caminos Alice-Bob-Harry y Harry-Bob-Alice. </li><li>  Al agrupar, dos caminos en la entrada corresponden al mismo borde nuevo.  La ruta Bob-Alice-Dave y Bob-Dave-Alice contiene la misma informaci√≥n para Bob, lo que significa que puede enviar solo cada segunda ruta, clasificando a los usuarios por su ID. </li></ol><br><p>  Despu√©s de aplicar las optimizaciones, el esquema de trabajo se ver√° as√≠: </p><br><p><img src="https://habrastorage.org/webt/zp/jx/da/zpjxdat-xtd9tqukfqt9tta8n0i.png"></p><br><ol><li>  En la primera etapa de generaci√≥n, obtenemos una lista de rutas de longitud 2 con un filtro de ID de pedido. </li><li>  En el segundo, nos agrupamos por el primer usuario en el camino. </li></ol><br><p>  En esta configuraci√≥n, el algoritmo cumple una operaci√≥n aleatoria y el tama√±o de los datos transmitidos por la red se reduce a la mitad.  :) </p><br><h3 id="raskladyvaem-ego-podgraf-v-pamyati">  Coloca el subgrafo del ego en la memoria </h3><br><p>  Una cuesti√≥n importante que a√∫n no hemos considerado es c√≥mo descomponer los datos en el ego de un subgr√°fico en la memoria.  Para almacenar el gr√°fico como un todo, utilizamos una lista de adyacencia.  Esta estructura es conveniente para tareas en las que es necesario pasar por el gr√°fico terminado en su conjunto, pero es costoso si queremos construir un gr√°fico a partir de piezas y hacer an√°lisis m√°s sutiles.  La estructura ideal para nuestra tarea debe realizar efectivamente las siguientes operaciones: </p><br><ol><li>  La uni√≥n de dos gr√°ficos obtenidos de diferentes particiones. </li><li>  Conseguir todos los amigos humanos. </li><li>  Comprobando si dos personas est√°n conectadas. </li><li>  Almacenamiento en memoria sin gastos generales de boxeo. </li></ol><br><p>  Uno de los formatos m√°s adecuados para estos requisitos es el an√°logo de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">matriz de CSR dispersa</a> : </p><br><p><img src="https://habrastorage.org/webt/nm/rl/ch/nmrlchko5kxd5cslkvu2kh37vkq.png"></p><br><p>  El gr√°fico en este caso se almacena en forma de tres matrices: </p><br><ol><li>  usuarios: una matriz ordenada con la ID de todos los usuarios que participan en el gr√°fico. </li><li>  index: una matriz del mismo tama√±o que los usuarios, donde para cada usuario se almacena un puntero de √≠ndice al comienzo de la informaci√≥n sobre las relaciones de los usuarios en la tercera matriz. </li><li>  amigos: una matriz de tama√±o igual al n√∫mero de bordes en el gr√°fico, donde los ID de los usuarios relacionados se muestran secuencialmente para los ID correspondientes de los usuarios.  La matriz se ordena por velocidad de procesamiento dentro de la informaci√≥n sobre los enlaces de un solo usuario. </li></ol><br><p>  En este formato, la operaci√≥n de fusionar dos gr√°ficos se realiza en tiempo lineal, y la operaci√≥n de obtener informaci√≥n sobre un usuario espec√≠fico o sobre un par de usuarios por logaritmo del n√∫mero de v√©rtices.  En este caso, la sobrecarga en la memoria no depende del tama√±o del gr√°fico, ya que se utiliza un n√∫mero fijo de matrices.  Al agregar una cuarta matriz de datos de tama√±o igual al tama√±o de los amigos, puede guardar informaci√≥n adicional asociada con las relaciones en el gr√°fico. </p><br><p>  Usando la propiedad de simetr√≠a de gr√°fico, puede almacenar solo la mitad de los arcos "triangulares superiores" (cuando los arcos se almacenan solo de una ID m√°s peque√±a a una m√°s grande), pero en este caso, la reconstrucci√≥n de todas las conexiones de un solo usuario llevar√° tiempo lineal.  Un buen compromiso en este caso puede ser un enfoque que utiliza la codificaci√≥n "triangular superior" para el almacenamiento y la transferencia entre nodos, y la codificaci√≥n sim√©trica al cargar el ego del subgrafo en la memoria para su an√°lisis. </p><br><h3 id="umenshaem-shuffle">  Reducir barajar </h3><br><p>  Sin embargo, incluso despu√©s de implementar toda la optimizaci√≥n mencionada anteriormente, la tarea de construir todas las subgraf√≠as del ego todav√≠a funciona demasiado tiempo.  En nuestro caso, aproximadamente 6 horas con una alta utilizaci√≥n del cl√∫ster.  Una mirada m√°s cercana muestra que la principal fuente de complejidad sigue siendo la operaci√≥n de barajar, mientras que una parte importante de los datos involucrados en la baraja se descarta en las siguientes etapas.  El hecho es que el enfoque descrito construye una vecindad completa de dos pasos para cada usuario, mientras que el subgrafo del ego es solo un subconjunto relativamente peque√±o de esta vecindad que contiene solo arcos <em>internos</em> . </p><br><p>  Por ejemplo, si al procesar a los vecinos directos de Bob, Harry y Frank, supi√©ramos que no eran amigos, entonces, en el primer paso, podr√≠amos filtrar esos caminos externos.  Pero para saber si Gary y Frenkov son amigos, tendr√° que arrastrar el gr√°fico de amistad a la memoria en todos los nodos inform√°ticos o realizar llamadas remotas mientras procesa cada registro, lo que, seg√∫n las condiciones de la tarea, es imposible. </p><br><p>  Sin embargo, existe una soluci√≥n si nos permitimos, en un peque√±o porcentaje de casos, cometer errores cuando encontramos amistad donde realmente no existe.  Hay toda una familia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estructuras de datos probabil√≠sticas</a> que permiten reducir el consumo de memoria durante el almacenamiento de datos en √≥rdenes de magnitud, al tiempo que permiten una cierta cantidad de error.  La estructura m√°s famosa de este tipo es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el filtro Bloom</a> , que durante muchos a√±os se ha utilizado con √©xito en bases de datos industriales para compensar las fallas en el cach√© de "cola larga". </p><br><p>  La tarea principal del filtro Bloom es responder la pregunta "¬øest√° incluido este elemento en los muchos elementos vistos anteriormente?"  Adem√°s, si el filtro responde "no", entonces el elemento probablemente no est√© incluido en el conjunto, pero si responde "s√≠", existe una peque√±a probabilidad de que el elemento todav√≠a no est√© all√≠. </p><br><p>  En nuestro caso, el "elemento" ser√° un par de usuarios, y el "conjunto" ser√° todos los bordes del gr√°fico.  Luego, el filtro Bloom se puede aplicar con √©xito para reducir el tama√±o de la mezcla aleatoria: </p><br><p><img src="https://habrastorage.org/webt/eo/_e/ua/eo_eua9cf1wxdkxttwevejawbje.png"></p><br><p>  Una vez preparado el filtro Bloom con informaci√≥n sobre el gr√°fico, podemos mirar a trav√©s de los amigos de Harry para descubrir que Bob e Ilona no son amigos, lo que significa que no necesitamos enviarle informaci√≥n sobre la conexi√≥n entre Gary e Ilona.  Sin embargo, la informaci√≥n de que Harry y Bob son amigos por s√≠ solos a√∫n tendr√° que enviarse para que Bob pueda restaurar completamente su gr√°fica de amistad despu√©s de la agrupaci√≥n. </p><br><h3 id="ubiraem-shuffle">  Eliminar barajar </h3><br><p>  Despu√©s de aplicar el filtro, la cantidad de datos enviados se reduce en aproximadamente un 80%, y la tarea se completa en 1 hora con una carga de cl√∫ster moderada, lo que le permite realizar libremente otras tareas en paralelo.  En este modo, ya se puede "poner en funcionamiento" y poner a diario, pero todav√≠a hay potencial para la optimizaci√≥n. </p><br><p>  Por parad√≥jico que pueda parecer, el problema puede resolverse sin recurrir a la combinaci√≥n aleatoria, si se permite un cierto porcentaje de errores.  Y el filtro Bloom puede ayudarnos con esto: </p><br><p><img src="https://habrastorage.org/webt/el/zv/ya/elzvyazgijeu9ew7yt8te-xvmm8.png"></p><br><p>  Si miramos la lista de amigos de Bob usando un filtro, descubrimos que Alice y Charlie son <em>casi seguramente</em> amigos, podemos agregar inmediatamente el arco correspondiente al subgrafo del ego de Bob.  Todo el proceso en este caso tomar√° menos de 15 minutos y no requerir√° la transferencia de datos a trav√©s de la red, sin embargo, un cierto porcentaje de arcos, dependiendo de la configuraci√≥n del filtro, puede estar ausente en la realidad. </p><br><p>  Los arcos adicionales agregados por el filtro no introducen distorsiones significativas para algunas tareas: por ejemplo, al contar tri√°ngulos, podemos corregir f√°cilmente el resultado, y al preparar atributos para algoritmos de aprendizaje autom√°tico, la correcci√≥n ML en s√≠ misma se puede aprender en el siguiente paso. </p><br><p>  Pero en algunas tareas, los arcos adicionales conducen a un deterioro fatal en la calidad del resultado: por ejemplo, cuando se buscan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">componentes conectados</a> en el subgrafo del ego con un ego remoto (sin la parte superior del usuario), la probabilidad de un "puente fantasma" entre los componentes aumenta cuadr√°ticamente en relaci√≥n con su tama√±o, lo que conduce a que en casi todas partes tenemos un gran componente. </p><br><p>  Hay un √°rea intermedia donde el efecto negativo de los arcos adicionales debe evaluarse experimentalmente: por ejemplo, algunos algoritmos de b√∫squeda de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad</a> pueden hacer frente con bastante √©xito a un poco de ruido, devolviendo una estructura comunitaria casi id√©ntica. </p><br><h3 id="vmesto-zaklyucheniya">  En lugar de una conclusi√≥n </h3><br><p>  Las subgraf√≠as de usuarios del ego son una fuente importante de informaci√≥n que se utiliza activamente en OK para mejorar la calidad de las recomendaciones, refinar la demograf√≠a y combatir el correo no deseado, pero su c√°lculo est√° plagado de una serie de dificultades. </p><br><p>  En el art√≠culo, examinamos la evoluci√≥n del enfoque de la tarea de construir subgrafos del ego para todos los usuarios de una red social y pudimos mejorar el tiempo de trabajo desde las 20 horas iniciales hasta 1 hora, y en el caso de un peque√±o porcentaje de errores, hasta 10-15 minutos. </p><br><p>  Los tres "pilares" en los que se basa la decisi√≥n final son: </p><br><ol><li>  Usando la propiedad de simetr√≠a gr√°fica y los algoritmos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tomas Schank</a> . </li><li>  Almacene eficientemente las subgraf√≠as del ego utilizando una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">matriz de CSR dispersa</a> . </li><li>  Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un filtro Bloom</a> para reducir la transferencia de datos a trav√©s de la red. </li></ol><br><p>  Se pueden encontrar ejemplos de c√≥mo ha evolucionado el c√≥digo del algoritmo en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuaderno Zeppelin</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465985/">https://habr.com/ru/post/465985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465975/index.html">Gu√≠a SQL: C√≥mo escribir mejor las consultas (Parte 2)</a></li>
<li><a href="../465977/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D√≠a 31. CDP, Syslog y NTP</a></li>
<li><a href="../465979/index.html">Recuerde que todo ^ W es justo lo que necesita. Experiencia con Anki. Parte 1 (introductoria, pen√∫ltima)</a></li>
<li><a href="../465981/index.html">Mi experiencia de administraci√≥n de IBM DB2 Express-C cuando se usa con 1C: Enterprise</a></li>
<li><a href="../465983/index.html">Intel Comet Lake: un poco de 14 nm en la d√©cima generaci√≥n</a></li>
<li><a href="../465987/index.html">El loro ha aterrizado. El anuncio del libro "Aprendizaje profundo generativo"</a></li>
<li><a href="../465989/index.html">Estrategia de producto y estrategia de organizaci√≥n en t√©rminos de ingenier√≠a de sistemas.</a></li>
<li><a href="../465991/index.html">Trabajadores de la arquitectura Clean Swift</a></li>
<li><a href="../465993/index.html">No es necesario ahorrar en seguridad digital</a></li>
<li><a href="../465995/index.html">LDC - Excursi√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>