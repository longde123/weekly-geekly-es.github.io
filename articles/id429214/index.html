<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ· ğŸ“° Fitur Middleware dan Pipeline di Laravel ğŸ° ğŸ¥‹ ğŸŠ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Laravel adalah sistem yang benar-benar besar dan kompleks yang mencoba menyelesaikan sebagian besar tugas sehari-hari seorang pengembang web dengan ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur Middleware dan Pipeline di Laravel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429214/"><img src="https://habrastorage.org/webt/gq/9y/lj/gq9yljr_yvia5supmq_lo1ify0a.jpeg"><br><br>  <b>Laravel</b> adalah sistem yang benar-benar besar dan kompleks yang mencoba menyelesaikan sebagian besar tugas sehari-hari seorang pengembang web dengan cara yang paling elegan dan mengumpulkan sebanyak mungkin alat dan, yang sangat penting, dengan sebanyak mungkin antarmuka manusia. <br><br>  Dan hari ini kita akan fokus pada salah satu alat ini, atau lebih tepatnya pada penggunaan dan implementasinya oleh programmer.  Kurangnya dokumentasi lengkap, serta kurangnya artikel berbahasa Rusia dan sangat sedikit artikel asing, mendorong saya untuk memutuskan untuk mengungkapkan tabir kerahasiaan tertentu tentang fitur menarik kerangka kerja ini dan memilih topik ini sebagai artikel pertama saya tentang HabrÃ©. <br><a name="habracut"></a><br><h4>  Middleware </h4><br><blockquote>  Artikel ini mengasumsikan bahwa pembaca sudah terbiasa dengan penggunaan dasar fungsi kerangka ini, jadi saya tidak akan membahas hal ini untuk waktu yang lama. </blockquote><br>  Di luar kotak, Laravel memberi kami fungsionalitas yang cukup kuat untuk memfilter permintaan HTTP yang masuk ke aplikasi kami.  Kita berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Middleware yang</a> dicintai semua orang (atau tidak) - pengembang menjumpai kelas-kelas ini dengan cepat dalam penguasaan Laravel, sambil membaca bagian â€œDasar-Dasarâ€ dari dokumentasi resmi, dan ini tidak mengejutkan - Middleware adalah salah satu yang utama dan paling penting batu bata atas dasar di mana seluruh sistem dibangun. <br><br>  Contoh kasus standar pengguna komponen ini di Laravel adalah: <i>EncryptCookies / RedirectIfAuthenticated / VerifyCsrfToken</i> , dan sebagai contoh implementasi kustom, Anda dapat mengutip lokalisasi aplikasi middleware (mengatur lokalisasi yang diperlukan berdasarkan pada data permintaan tertentu) sebelum mentransfer permintaan lebih lanjut. <br><br><h2>  Lebih dalam ke jurang </h2><br><h4>  Putuskan harapan semua orang yang datang ke sini </h4><br>  Nah, sekarang setelah poin utama selesai - kita bisa menyelidiki tempat yang mengerikan bagi banyak orang - dalam alfa dan omega, awal dan akhir - dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber Laravel</a> .  Mereka yang berusaha segera menutup artikel - luangkan waktu Anda.  Bahkan, dalam kode sumber kerangka kerja ini hampir tidak ada yang benar-benar rumit dari sisi konseptual - pencipta jelas berusaha tidak hanya untuk membuat antarmuka yang jelas dan nyaman untuk bekerja dengan gagasan mereka, tetapi mereka juga sangat berusaha melakukan hal yang sama secara langsung pada tingkat kode sumber, yang tidak dapat tidak untuk menyenangkan. <br><br>  Saya akan mencoba menjelaskan konsep tentang bagaimana <i>Middleware</i> dan <i>Pipeline bekerja</i> pada tingkat kode dan logika sesederhana dan dapat diakses mungkin, dan saya akan mencoba untuk tidak masuk ke dalamnya - di mana itu tidak perlu dalam kerangka artikel.  Jadi, jika di komentar ada orang yang tahu semua baris kode sumber dengan hati - saya meminta Anda untuk tidak mengkritik narasi dangkal saya.  Tetapi setiap rekomendasi dan koreksi ketidakakuratan hanya diterima. <br><br><h4>  Middleware - melintasi barikade </h4><br>  Saya percaya bahwa belajar apa pun selalu lebih mudah ketika diberikan contoh yang baik.  Karena itu, saya mengundang Anda dan saya untuk mempelajari binatang misterius ini dengan nama <i>Pipeline</i> .  Jika para pemberani seperti itu benar-benar ada, maka sebelum membaca lebih lanjut kita perlu menginstal proyek Laravel kosong versi 5.7 - versi ini hanya disebabkan oleh fakta bahwa itu adalah yang terakhir pada saat penulisan, semua hal di atas harus identik setidaknya untuk versi 5.4.  Mereka yang hanya ingin mengetahui esensi dan kesimpulan artikel dapat dengan aman melewati bagian ini. <br><br>  Apa yang bisa lebih baik daripada mempelajari perilaku komponen, kecuali mempelajari perilaku yang sudah ada di dalam sistem?  Mungkin sesuatu dapat, tetapi kami akan melakukannya tanpa komplikasi yang tidak perlu dan memulai analisis kami dengan standar Middleware - yaitu, dengan yang paling sederhana dan paling dapat dipahami dari seluruh geng - <b>RedirectIfAuthenticated</b> : <br><br><div class="spoiler">  <b class="spoiler_title">RedirectIfAuthenticated.php</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedirectIfAuthenticated</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/**      * Handle an incoming request. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> \Illuminate\Http\Request $request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> \Closure $next * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string|null $guard * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> mixed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request, Closure $next, $guard = null)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Auth::guard($guard)-&gt;check()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> redirect(<span class="hljs-string"><span class="hljs-string">'/'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $next($request); } }</code> </pre> <br></div></div><br>  Di kelas middleware klasik mana pun, ada metode utama yang harus secara langsung memproses permintaan dan meneruskan pemrosesan ke yang berikutnya dalam rantai - dalam kasus kami, ini adalah metode <i>pegangan</i> .  Di kelas khusus ini, pemrosesan permintaan cukup sederhana - "jika pengguna diotorisasi, kemudian arahkan dia ke halaman utama dan, dengan demikian, mengakhiri rantai." <br><br>  Jika kita melihat pendaftaran Middleware ini di <i>app / Http / Kernel.php</i> , kita akan melihat bahwa itu terdaftar di 'route middleware'.  Agar kami dapat mengetahui cara kerja sistem dengan middleware ini, mari kita pergi ke kelas dari mana <i>aplikasi / Http / Kernel kita</i> mewarisi - dan itu mewarisi dari kelas <i>Illuminate \ Foundation \ Http \ Kernel</i> .  Pada tahap ini, kita akan langsung membuka gerbang ke <s>neraka</s> kode sumber kerangka kerja kita, atau lebih tepatnya, ke bagian paling penting dan utama darinya - ke inti bekerja dengan HTTP.  Ngomong-ngomong, siapa yang peduli - Laravel didasarkan pada banyak komponen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Symfony</a> , khususnya di bagian ini - pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/symfony/">HttpFoundation</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/symfony/">HttpKernel</a> . <br><br>  Definisi dan implementasi middleware kami di konstruktor kernel adalah sebagai berikut: <br><br><div class="spoiler">  <b class="spoiler_title">Illuminate \ Foundation \ Http \ Kernel (Aplikasi $ app, Router $ router)</b> <div class="spoiler_text"><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/**    HTTP Kernel . * Create a new HTTP kernel instance. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> \Illuminate\Contracts\Foundation\Application $app * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> \Illuminate\Routing\Router $router * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> void */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Application $app, Router $router)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;app = $app; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;router = $router; $router-&gt;middlewarePriority = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;middlewarePriority; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;middlewareGroups <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $middleware) { $router-&gt;middlewareGroup($key, $middleware); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;routeMiddleware <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $middleware) { $router-&gt;aliasMiddleware($key, $middleware); } }</code> </pre><br></div></div><br>  Kode ini cukup sederhana dan mudah - untuk setiap middleware dalam array kami mendaftarkannya dengan alias / indeks di router kami.  Metode aliasMiddleware dan middlewareGroups dari kelas Route kami hanya menambahkan middleware ke salah satu array dari objek router.  Tetapi ini tidak termasuk dalam konteks artikel, jadi kami akan melewatkan momen ini dan melanjutkan. <br><br>  Yang benar-benar kami minati adalah metode <b>sendRequestThroughRoute</b> , yang secara harfiah menerjemahkan cara <b>mengirim</b> <b>Permintaan melalui Rute</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Illuminate \ Foundation \ Http \ Kernel :: sendRequestThroughRouter ($ request)</b> <div class="spoiler_text"><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/**     middleware / router. * Send the given request through the middleware / router. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> \Illuminate\Http\Request $request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> \Illuminate\Http\Response */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequestThroughRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// *    * return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter()); }</span></span></code> </pre><br></div></div><br>  Sebagai parameter, metode ini menerima permintaan.  Pada titik ini, kita harus melihat kembali kode <b>RedirectIfAuthenticated</b> kami.  Kami juga mendapatkan permintaan dalam metode <i>pegangan</i> middleware kami, kami akan membutuhkan catatan ini nanti. <br><br>  Kode di atas memiliki antarmuka yang sangat jelas dan mudah dibaca - <i>"Pipeline", yang mengirimkan permintaan melalui masing-masing middleware terdaftar, dan kemudian "mentransfer" ke router</i> .  Menawan dan indah.  Saya pikir pada tahap ini kami tidak akan mencoba untuk menguraikan bagian kode ini lebih lanjut, saya hanya akan menjelaskan secara singkat peran bagian ini dalam keseluruhan sistem: <br><br>  Sebelum permintaan masuk ke pengontrol Anda, banyak tindakan dilakukan, mulai dari hanya mengurai url itu sendiri, dan diakhiri dengan inisialisasi kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Permintaan</a> .  Middleware juga terlibat dalam <b>rantai</b> aksi ini.  Kelas middleware sendiri menerapkan (hampir) pola perancangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chain of Responsibility</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">atau Chain of Responsibility</a> , sehingga setiap kelas midleware konkret hanyalah tautan dalam rantai. <br><br>  Di atas, kami tidak hanya kembali ke kelas <b>RedirectIfAuthenticated</b> kami yang semula dianggap.  Permintaan "beredar" di sepanjang rantai, termasuk yang melewati semua yang diperlukan untuk rute middleware.  Momen ini akan membantu kita bekerja dengan tautan kita sendiri dalam rantai kita sendiri, lebih lanjut tentang itu nanti. <br><br><h3>  Pipeline - menyalurkan aplikasi kita </h3><br>  Salah satu contoh implementasi <i>Pipeline yang</i> kami lihat di atas.  Tetapi tujuan artikel ini bukan hanya untuk menjelaskan operasi komponen ini pada tingkat integrasi dengan Laravel, tetapi juga untuk menjelaskan prinsip dasar bekerja dengan kelas ini dalam kode kita sendiri. <br><br>  Kelas itu sendiri dapat ditemukan dengan definisi lengkapnya dengan namespace: <blockquote>  Menerangi \ Pipeline \ Pipeline </blockquote><br>  Mungkin ada cukup banyak aplikasi untuk komponen ini, tergantung pada tugas khusus yang harus Anda selesaikan, tetapi salah satu motivasi yang paling jelas adalah persyaratan untuk membuat rantai penangan permintaan Anda sendiri, yang tidak mengganggu proses seluruh sistem dan ditentukan secara eksklusif pada tingkat logika bisnis Anda.  Juga, antarmuka kelas memiliki tingkat abstraksi yang cukup dan memiliki fungsi yang cukup untuk mengimplementasikan berbagai jenis antrian. <br><br><h4>  Contoh implementasi di Laravel </h4><br>  Kami menerapkan rantai kueri yang paling sederhana dan jauh dari kenyataan.  Kami akan menggunakan string "HELLO WORLD" sebagai data, dan dengan bantuan dua penangan, kami akan membentuk string "Halo Pengguna" darinya.  Kode ini sengaja disederhanakan. <br><br>  Sebelum implementasi "Pipa" kita sendiri, kita perlu mengidentifikasi elemen-elemen dari pipa ini.  Elemen ditulis dengan analogi dengan middleware: <br><br><div class="spoiler">  <b class="spoiler_title">Menentukan Penangan</b> <div class="spoiler_text">  StrToLowerAction.php: <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Closure</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrToLowerAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Handle an incoming request. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $content * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> Closure $next * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> mixed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $content, Closure $next)</span></span></span><span class="hljs-function"> </span></span>{ $content = strtolower($content); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $next($content); } }</code> </pre><br>  SetUserAction.php: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Closure</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetUserAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Handle an incoming request. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $content * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> Closure $next * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> mixed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $content, Closure $next)</span></span></span><span class="hljs-function"> </span></span>{ $content = ucwords(str_replace(<span class="hljs-string"><span class="hljs-string">'world'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, $content)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $next($content); } }</code> </pre><br></div></div><br>  Lalu kami membuat "jalur pipa", menentukan jenis data apa yang ingin kami kirimkan, menentukan melalui kumpulan prosesor mana kami ingin mengirim data ini, dan juga menentukan panggilan balik, yang menerima sebagai argumen data kami melewati seluruh rantai.  Jika data di seluruh rantai tetap tidak berubah, bagian dengan panggilan balik dapat dihilangkan: <br><br><pre> <code class="php hljs">$pipes = [ StrToLowerAction::class, SetUserNameAction::class ]; $data = <span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>; $finalData = app(Pipeline::class) -&gt;send($data) <span class="hljs-comment"><span class="hljs-comment">// ,       -&gt;through($pipes) //   -&gt;then(function ($changedData) { return $changedData; //  ,    }); var_dump($finalData); //      $finalData</span></span></code> </pre><br>  Juga, jika Anda memiliki keinginan atau kebutuhan untuk mendefinisikan metode Anda sendiri dalam penangan, antarmuka Pipeline menyediakan metode khusus <i>via ('method_name')</i> , maka pemrosesan rantai dapat ditulis dengan cara ini: <br><br><pre> <code class="php hljs">$finalData = app(Pipeline::class) -&gt;send($data) -&gt;through($pipes) -&gt;via(<span class="hljs-string"><span class="hljs-string">'handle'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      ,         -&gt;then(function ($changedData) { return $changedData; });</span></span></code> </pre><br>  Secara langsung, data yang kami lewati prosesor dapat berupa apa saja, serta interaksi dengan mereka.  Mengetik petunjuk dan mengatur tipe objek yang dikembalikan dalam rantai akan membantu menghindari kesalahan integritas data. <br><br><h2>  Kesimpulan </h2><br>  Laravel menyediakan sejumlah besar kelas bawaan, dan fleksibilitas banyak dari mereka memungkinkan kami untuk mengembangkan sesuatu yang kompleks dengan kesederhanaan yang cukup.  Artikel ini membahas kemungkinan membuat antrian sederhana untuk permintaan berdasarkan kelas Pipeline yang dibangun ke Laravel.  Implementasi kelas ini dalam kode final bisa sangat berbeda, dan fleksibilitas alat ini memungkinkan Anda untuk menyingkirkan banyak tindakan yang tidak perlu saat membangun algoritma tertentu. <br><br>  Cara khusus menggunakan fitur kerangka kerja ini tergantung pada tugas yang diberikan kepada Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429214/">https://habr.com/ru/post/id429214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429198/index.html">Kerangka Kernel-Bridge: Jembatan di Ring0</a></li>
<li><a href="../id429202/index.html">Kursus mahal: apakah itu layak?</a></li>
<li><a href="../id429204/index.html">Kesalahpahaman paling penting tentang pengembangan game</a></li>
<li><a href="../id429210/index.html">Kenyataan pahit: pemangku kepentingan Anda tidak menginginkan analisis bisnis</a></li>
<li><a href="../id429212/index.html">Microsoft mengonfirmasi keberadaan (massa) masalah dengan aktivasi Windows 10</a></li>
<li><a href="../id429216/index.html">Periksa penjualan di Google Play - apakah perlu khawatir?</a></li>
<li><a href="../id429218/index.html">Julia dan persamaan diferensial parsial</a></li>
<li><a href="../id429220/index.html">FSIN versus hukum fisika atau lebah versus madu</a></li>
<li><a href="../id429222/index.html">Duma Negara akan mengembalikan tagihan pada data pengguna besar untuk direvisi</a></li>
<li><a href="../id429224/index.html">Pola formulir web gelap atau apa yang akan menjadi bentuk konversi terbanyak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>