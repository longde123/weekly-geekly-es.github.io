<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏽 🧛🏼 🦒 Servicios de Amazon Cloud y análisis de cartera de inversiones 🏥 🕒 🍌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, ha habido una alta volatilidad en los mercados bursátiles, cuando, por ejemplo, un documento estable de una empresa conocida puede perd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Servicios de Amazon Cloud y análisis de cartera de inversiones</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426027/">  Recientemente, ha habido una alta volatilidad en los mercados bursátiles, cuando, por ejemplo, un documento estable de una empresa conocida puede perder varios por ciento a la vez por las noticias de sanciones contra su administración o viceversa, volar a ciegas en un informe positivo y las expectativas de los inversores sobre dividendos súper rentables. <br><br>  ¿Cómo determinar si la propiedad de un valor dado ha generado ingresos o solo pérdidas y decepciones? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q3/2q/zs/q32qzs8fmzzpilpnbmfcek6l57a.png"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(Fuente)</a> <br><br>  En este artículo, le diré cómo identificar y visualizar el resultado financiero ajustado para valores. <br><br>  Utilizando el ejemplo de informes de clientes de Opening Broker, consideraremos el análisis y la consolidación de informes de corretaje para el mercado de valores, construyendo la arquitectura de un sistema de informes en la nube con el posterior análisis simple y conveniente en AWS Quicksight. <br><a name="habracut"></a><br><h2>  Descripción de la tarea </h2><br>  Muchas capacitaciones y lecciones educativas nos informan sobre la necesidad de un diario del operador, donde todos los parámetros de transacción se registran para un análisis posterior y para resumir la estrategia comercial.  Estoy de acuerdo en que este enfoque para trabajar en el intercambio le permite disciplinar a un comerciante, aumentar su conciencia, pero también puede cansarlo de un proceso tedioso. <br><br>  Admito que al principio intenté seguir cuidadosamente los consejos del diario, escribí meticulosamente cada transacción con sus parámetros en una tabla de Excel, construí algunos informes, cuadros resumen, planifiqué transacciones futuras, pero ... rápidamente me cansé de todo. <br><br><div class="spoiler">  <b class="spoiler_title">¿Por qué es inconveniente mantener el diario de un comerciante manualmente?</b> <div class="spoiler_text"><ul><li>  el llenado manual del diario (incluso usando automatización parcial, en la forma de descargar transacciones diarias desde la terminal de negociación) se cansa rápidamente; </li><li>  existe un alto riesgo de error o error tipográfico con la entrada manual; </li><li>  Puede suceder que un comerciante activo se convierta en un inversor pasivo y regrese cada vez menos a esta revista, y luego se olvide por completo (mi caso);  bien y finalmente </li><li>  podemos programar, ¿por qué no aprovechar esto y automatizar todo el proceso?  ¡Entonces vamos! </li></ul></div></div><br>  A menudo, las compañías de corretaje son organizaciones de alta tecnología que brindan a sus clientes análisis de bastante alta calidad sobre casi todos los temas de interés.  Es justo decir que este informe está mejorando cada vez más con cada actualización, pero incluso los más avanzados pueden no tener la personalización y consolidación que los clientes exigentes y curiosos quieren ver. <br><br>  Por ejemplo, Opening Broker le permite recibir informes de corretaje en formato XML en su cuenta personal, pero si tiene un IIA y una cuenta de corretaje regular en la Bolsa de Moscú (MOEX), estos serán dos informes diferentes, y si tiene otra cuenta en St. Petersburg Stock Exchange (SPB), luego los dos primeros agregarán uno más. <br><br>  En total, para obtener un diario consolidado del inversor, será necesario procesar tres archivos en formato XML. <br><br>  Los informes antes mencionados sobre MOEX y SPB difieren ligeramente en sus formatos, que deberán tenerse en cuenta en el proceso de implementación del mapeo de datos. <br><br><h2>  Arquitectura del sistema en desarrollo. </h2><br>  El siguiente diagrama muestra el modelo de arquitectura del sistema en desarrollo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/uq/ed/vvuqedfvl-l8tnghx3v6vtujabc.jpeg"></div><br><h2>  Implementación del analizador </h2><br>  Recibiremos informes de las tres cuentas de la Cuenta personal durante el período máximo posible (se puede dividir en varios informes por año), los guardaremos en formato XML y los pondremos en una carpeta.  Como datos de prueba para el estudio, utilizaremos una cartera de clientes ficticia, pero con parámetros lo más cercanos posible a las realidades del mercado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/og/ig/xw/ogigxw4yganahuuzbdqecsbqmry.png"></div><br>  Suponga que el inversionista Sr. X bajo consideración tiene una pequeña cartera de cinco valores: <br><br><ol><li>  El informe sobre el intercambio SPB tendrá dos documentos: Apple y Microsoft; </li><li>  El informe sobre el intercambio MOEX (corretaje) contiene un documento: FGC UES; </li><li>  El informe sobre el MOEX Exchange (IIS) contiene dos valores: MMK y OFZ 24019; </li></ol><br>  Según nuestros cinco valores, puede haber transacciones en la compra / venta, pago de dividendos y un cupón, el precio puede cambiar, etc.  Queremos ver la situación en el momento actual, a saber: el resultado financiero, teniendo en cuenta todos los pagos, transacciones y el valor de mercado actual. <br><br>  Y aquí entra en juego Python, leemos la información de todos los informes en una matriz: <br><br><pre><code class="python hljs">my_files_list = [join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> listdir(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isfile(join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f))] my_xml_data = [] <span class="hljs-comment"><span class="hljs-comment">#     for f in my_files_list: tree = ET.parse(f) root = tree.getroot() my_xml_data.append(root)</span></span></code> </pre> <br><blockquote>  Para el análisis, de los informes necesitamos varias entidades, a saber: <br><br><ul><li>  Posiciones de valores en una cartera; </li><li>  Acuerdos concluidos; </li><li>  Operaciones no comerciales y otros movimientos de cuenta; </li><li>  Precios promedio de las posiciones abiertas </li></ul></blockquote>  Para preparar la muestra, utilizaremos cuatro diccionarios para describir los conjuntos anteriores. <br><br><pre> <code class="python hljs">dict_stocks = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost_rub'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'saldo'</span></span> : []} dict_deals = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'quantity'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'price'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'brokerage'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: []} dict_flows = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: []} dict_avg_price = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'avg_open_price'</span></span> : []}</code> </pre> <br>  Algunas palabras sobre de qué se tratan estos diccionarios. <br><br><div class="spoiler">  <b class="spoiler_title">Diccionario Dict_stocks</b> <div class="spoiler_text">  El diccionario dict_stocks es necesario para almacenar información general sobre la cartera: <br><br><ul><li>  Nombre del papel (stock_name); </li><li>  Nombre de la cuenta (SPB, MOEX BROK, MOEX IIS) (cuenta); </li><li>  Moneda utilizada para liquidaciones en este papel (moneda); </li><li>  Valor actual (en el momento de generar el informe en el Agente de apertura de cuenta personal) (current_cost).  Aquí quiero señalar que para clientes demasiado exigentes, es posible realizar mejoras adicionales en el futuro y utilizar el recibo dinámico de una cotización de seguridad de un terminal comercial o del sitio web del intercambio correspondiente; </li><li>  El valor actual de la posición de seguridad en el momento en que se generó el informe (current_cost_rub) <br>  De manera similar al artículo anterior, aquí también puede obtener la tasa del Banco Central en el momento actual o la tasa de cambio, como lo desee. </li><li>  Saldo actual de valores (saldo) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Diccionario dict_deals</b> <div class="spoiler_text">  Se requiere el diccionario dict_deals para almacenar la siguiente información sobre transacciones completadas: <br><br><ul><li>  Nombre del papel (stock_name); </li><li>  Nombre de la cuenta (SPB, MOEX BROK, MOEX IIS) (cuenta); </li><li>  Fecha de transacción, es decir  T0 (date_oper); </li><li>  Tipo de operación (type_oper); </li><li>  El volumen de valores que participan en la transacción (cantidad); </li><li>  El precio al que se ejecutó la transacción (precio); </li><li>  Moneda en la que se realizó la transacción (moneda); </li><li>  Comisión de corretaje para una transacción (corretaje); </li><li>  El resultado financiero de la transacción (resultado) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Diccionario Dict_flows</b> <div class="spoiler_text">  El diccionario dict_flows refleja el movimiento de fondos en la cuenta del cliente y se utiliza para almacenar la siguiente información: <br><br><ul><li>  Nombre del papel (stock_name); </li><li>  Nombre de la cuenta (SPB, MOEX BROK, MOEX IIS) (cuenta); </li><li>  Fecha de transacción, es decir  T0 (date_oper); </li><li>  Tipo de operación (type_oper).  Puede tomar varios valores: div, NKD, tax; </li><li>  Moneda en la que se realizó la transacción (moneda); </li><li>  El resultado financiero de la operación (resultado) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Diccionario dict_avg_price</b> <div class="spoiler_text">  El diccionario dict_avg_price es necesario para la información contable al precio promedio de compra de cada artículo: <br><br><ul><li>  Nombre del papel (stock_name); </li><li>  Nombre de la cuenta (SPB, MOEX BROK, MOEX IIS) (cuenta); </li><li>  Precio promedio de una posición abierta (avg_open_price) </li></ul></div></div><br>  Procesamos una variedad de documentos XML y completamos estos diccionarios con los datos apropiados: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       for XMLdata in my_xml_data: #      exchange_name = 'SPB' if XMLdata.get('board_list') == ' ' else 'MOEX' client_code = XMLdata.get('client_code') account_name = get_account_name(exchange_name, client_code) #   current_position, deals, flows, stock_name, \ saldo, ticketdate, price, brokerage, \ operationdate, currency, \ current_cost, current_cost_rub, \ stock_name_deal, payment_currency, currency_flows = get_allias(exchange_name) #      get_briefcase(XMLdata) df_stocks = pd.DataFrame(dict_stocks) df_stocks.set_index("stock_name", drop = False, inplace = True) #    get_deals(XMLdata) df_deals = pd.DataFrame(dict_deals) df_avg = pd.DataFrame(dict_avg_price) #       get_nontrade_operation(XMLdata) df_flows = pd.DataFrame(dict_flows)</span></span></code> </pre> <br>  Todo el procesamiento pasa por el ciclo sobre todos los datos XML de los informes.  La información sobre la plataforma de negociación, el código del cliente es el mismo en todos los informes, por lo que puede extraerlo de manera segura de las mismas etiquetas sin utilizar el mapeo. <br><br>  Pero luego tenemos que usar un diseño especial que proporcionará el alias necesario para la etiqueta basada en el informe (SPB o MOEX), porque  Los datos de naturaleza idéntica en estos informes se denominan de manera diferente. <br><br><div class="spoiler">  <b class="spoiler_title">Discrepancias de etiquetas</b> <div class="spoiler_text"><ul><li>  La comisión del agente de transacciones en el informe SBP se encuentra en la etiqueta de <b>corretaje</b> y en el informe <b>MOEX</b> : <b>broker_commission</b> ; </li><li>  La fecha de transacción de la cuenta no comercial en el informe SPB es fecha de <b>operación</b> , y en MOEX, es fecha de <b>operación</b> , etc. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de mapeo de etiquetas</b> <div class="spoiler_text"><pre> <code class="python hljs">tags_mapping = { <span class="hljs-string"><span class="hljs-string">'SPB'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'briefcase_position'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'closed_deal'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'nontrade_money_operation'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'issuername'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currencycode'</span></span> }, <span class="hljs-string"><span class="hljs-string">'MOEX'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_assets'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_main_deals_conclusion'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_non_trade_money_operations'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'security_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'price_currency_code'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currency_code'</span></span> } }</code> </pre></div></div><br>  La función get_allias devuelve el nombre de la etiqueta necesaria para el procesamiento, tomando el nombre de la plataforma de negociación como entrada: <br><br><div class="spoiler">  <b class="spoiler_title">Función Get_allias</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_allias</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exchange_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'current_position'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'deals'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'flows'</span></span>], ... tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>] )</code> </pre></div></div><br>  La función get_briefcase es responsable de procesar la información sobre el estado de la cartera de clientes: <br><br><div class="spoiler">  <b class="spoiler_title">Función Get_briefcase</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#         briefcase_position briefcase_position = XMLdata.find(current_position) if not briefcase_position: return try: for child in briefcase_position: stock_name_reduce = child.get(stock_name).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_stocks['stock_name'].append(stock_name_reduce) dict_stocks['account'].append(account_name) dict_stocks['currency'].append(child.get(currency)) dict_stocks['current_cost'].append(float(child.get(current_cost))) dict_stocks['current_cost_rub'].append(float(child.get(current_cost_rub))) dict_stocks['saldo'].append(float(child.get(saldo))) except Exception as e: print('get_briefcase --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  A continuación, la función get_deals recupera información sobre transacciones: <br><br><div class="spoiler">  <b class="spoiler_title">Función Get_deals</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_deals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> stock_name_proc = <span class="hljs-string"><span class="hljs-string">''</span></span> closed_deal = XMLdata.find(deals) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> closed_deal: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">#   SPB    -    , #    MOEX:  ,      #    : if exchange_name == 'SPB': sortchildrenby(closed_deal, stock_name_deal) for child in closed_deal: sortchildrenby(child, stock_name_deal) try: for child in closed_deal: stock_name_reduce = child.get(stock_name_deal).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_deals['stock_name'].append(stock_name_reduce) dict_deals['account'].append(account_name) dict_deals['date_oper'].append(to_dt(child.get(ticketdate)).strftime('%Y-%m-%d')) current_cost = get_current_cost(stock_name_reduce) #    SPB     - quantity, #   MOEX  : buy_qnty  sell_qnty if exchange_name == 'MOEX': if child.get('buy_qnty'): quantity = float(child.get('buy_qnty')) else: quantity = - float(child.get('sell_qnty')) else: quantity = float(child.get('quantity')) dict_deals['quantity'].append(quantity) dict_deals['price'].append(float(child.get('price'))) dict_deals['type_oper'].append('deal') dict_deals['currency'].append(child.get(payment_currency)) brok_comm = child.get(brokerage) if brok_comm is None: brok_comm = 0 else: brok_comm = float(brok_comm) dict_deals['brokerage'].append(float(brok_comm)) #         if stock_name_proc != stock_name_reduce: if stock_name_proc != '': put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] stock_name_proc = stock_name_reduce pnl = PnlSnapshot(stock_name_proc, float(child.get('price')), quantity) dict_deals['result'].append(-1 * brok_comm) else: pnl.update_by_tradefeed(float(child.get('price')), quantity) #  ,   if quantity &lt; 0: if pnl.m_realized_pnl &gt; 0 and exchange_name != 'SPB': pnl_sum = pnl.m_realized_pnl * 0.87 - brok_comm else: pnl_sum = pnl.m_realized_pnl - brok_comm dict_deals['result'].append(float(pnl_sum)) else: pnl.update_by_marketdata(current_cost) dict_deals['result'].append(-1 * brok_comm) put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] except Exception as e: print('get_deals --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  Además de procesar una matriz con información sobre los parámetros de la transacción, el precio promedio de una posición abierta y realizado por PNL utilizando el método FIFO también se calcula aquí.  La clase PnlSnapshot es responsable de este cálculo, cuya creación con las pequeñas modificaciones se tomó como base el código presentado aquí: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cálculo de</a> pérdidas y ganancias <br><br>  Y, por último, lo más difícil de implementar es la función de obtener información sobre operaciones no comerciales: <b>get_nontrade_operation</b> .  Su complejidad radica en el hecho de que en el bloque de informe utilizado para operaciones no comerciales, no hay información clara sobre el tipo de transacción y la seguridad a la que está vinculada esta operación. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de destinos de pago para operaciones no comerciales</b> <div class="spoiler_text">  El pago de dividendos o ingresos por cupones acumulados puede indicarse de la siguiente manera: <br><br><ol><li>  Pago de ingresos del cliente &lt;777777&gt; <font color="#cc0000">dividendos</font> &lt; <font color="#cc0000">APPLE</font> INC-ao&gt; -&gt; pago de dividendos del informe SPB; </li><li>  Pago de ingresos del cliente &lt;777777&gt; <font color="#cc0000">dividendos</font> &lt; <font color="#cc0000">MICROSOFT</font> COM-&gt; </li><li>  Pago de rentas del cliente 777777i (NKD 2 <font color="#cc0000">OFZ 24019</font> ) retención de impuestos 0,00 rublos -&gt; pago de cupón del informe MOEX; </li><li>  Pago de ingresos al cliente 777777 <font color="#cc0000">dividendos de FGC UES</font> -ao retención de impuestos XX.XX rublos -&gt; pago de dividendos del informe MOEX.  etc. </li></ol></div></div><br>  En consecuencia, será difícil prescindir de expresiones regulares, por lo que las utilizaremos al máximo.  El otro lado del problema es que el nombre de la empresa no siempre coincide con el nombre en la cartera o en las transacciones en el propósito del pago.  Por lo tanto, el nombre recibido del emisor del propósito del pago debe correlacionarse adicionalmente con el diccionario.  Como diccionario usaremos una variedad de ofertas, porque  Existe la lista más completa de empresas. <br><br>  La función <b>get_company_from_str</b> recupera el nombre del emisor del comentario: <br><br><div class="spoiler">  <b class="spoiler_title">Función Get_company_from_str</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comment)</span></span></span><span class="hljs-function">:</span></span> company_name = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-comment"><span class="hljs-comment">#    / flows_pattern = [ '^.+\s&lt;(\w+)?.+-&gt;$', '^.+\s(.+)-.+$', '^.+\(\s\d?\s(.+)\).+$', '^.+\s(.+)-.+$' ] for pattern in flows_pattern: match = re.search(pattern, comment) if match: return match.group(1).upper() return company_name</span></span></code> </pre> </div></div><br>  La función <b>get_company_from_briefcase</b> lleva el nombre de la compañía al diccionario si encuentra una coincidencia entre las compañías que participaron en las transacciones: <br><br><div class="spoiler">  <b class="spoiler_title">Función Get_company_from_briefcase</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(company_name)</span></span></span><span class="hljs-function">:</span></span> company_name_full = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> value_from_dic = df_deals[df_deals[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].str.contains(company_name)] company_arr = value_from_dic[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].unique() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(company_arr) == <span class="hljs-number"><span class="hljs-number">1</span></span>: company_name_full = company_arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> company_name_full</code> </pre> <br></div></div><br>  Y finalmente, la función final de recopilar datos sobre operaciones no comerciales es <b>get_nontrade_operation</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Función Get_nontrade_operation</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nontrade_operation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> nontrade_money_operation = XMLdata.find(flows) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> nontrade_money_operation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nontrade_money_operation: comment = child.get(<span class="hljs-string"><span class="hljs-string">'comment'</span></span>) type_oper_match = re.search(<span class="hljs-string"><span class="hljs-string">'||^.+.+.+$'</span></span>, comment) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type_oper_match: company_name = get_company_from_str(comment) type_oper = get_type_oper(comment) dict_flows[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].append(company_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'account'</span></span>].append(account_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>].append(to_dt(child.get(operationdate)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>)) dict_flows[<span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>].append(type_oper) dict_flows[<span class="hljs-string"><span class="hljs-string">'result'</span></span>].append(float(child.get(<span class="hljs-string"><span class="hljs-string">'amount'</span></span>))) dict_flows[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>].append(child.get(currency_flows)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'get_nontrade_operation --&gt; Oops! It seems we have a BUG!'</span></span>, e)</code> </pre> </div></div><br>  El resultado de la recopilación de datos de los informes serán tres marcos de datos, que son aproximadamente los siguientes: <br><br><ol><li>  DataFrame con información sobre los precios promedio de las posiciones abiertas: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1o/c-/qs/1oc-qs_akl5cvraaq7sg7pvfwfu.png"></div></li><li>  Deal DataFrame: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/lp/xb/gqlpxby2utfl0ahr-fm8l_fqywc.png"></div></li><li>  DataFrame con información sobre operaciones no comerciales: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hx/-7/su/hx-7suk1zgheyiyr6ov6o0z5yd0.png"></div><br></li></ol><br>  Entonces, todo lo que nos queda por hacer es realizar una unión externa de la tabla de transacciones con la tabla de información de cartera: <br><br><pre> <code class="python hljs">df_result = pd.merge(df_deals, df_stocks_avg, how=<span class="hljs-string"><span class="hljs-string">'outer'</span></span>, on=[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'account'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency'</span></span>]).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/wj/nz/jowjnzmldhgscs30ynz5lrdcueu.png"></div><br>  Y finalmente, la parte final del procesamiento de la matriz de datos es la fusión de la matriz de datos obtenida en el paso anterior con el DataFrame para transacciones no comerciales. <br>  El resultado del trabajo realizado es una gran mesa plana con toda la información necesaria para el análisis: <br><br><pre> <code class="python hljs">df_result_full = df_result.append(df_flows, ignore_index=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result_full.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>).head()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jc/rh/ccjcrh4dq5auyrg3jba6csb_s0g.png"></div><br>  El conjunto de datos resultante (Informe final) del DataFrame se carga fácilmente en el CSV y luego se puede utilizar para un análisis detallado en cualquier sistema de BI. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exists(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>): makedirs(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>) report_name = <span class="hljs-string"><span class="hljs-string">'OUTPUT\my_trader_diary.csv'</span></span> df_result_full.to_csv(report_name, index = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, encoding=<span class="hljs-string"><span class="hljs-string">'utf-8-sig'</span></span>)</code> </pre> <br><br><h2>  Cargar y procesar datos en AWS </h2><br>  El progreso no se detiene y ahora los servicios en la nube y los modelos informáticos sin servidor están ganando gran popularidad en el procesamiento y almacenamiento de datos.  Esto se debe en gran parte a la simplicidad y al bajo costo de este enfoque, cuando no necesita comprar equipos costosos para construir una arquitectura de sistema para computación compleja o procesar grandes datos, sino que simplemente alquila la energía en la nube por el tiempo que necesita e implementa los recursos necesarios lo suficientemente rápido por una tarifa relativamente pequeña . <br><br>  Uno de los proveedores de nube más grandes y conocidos del mercado es Amazon.  Veamos el ejemplo del entorno de Amazon Web Services (AWS) para crear un sistema analítico para procesar datos en nuestra cartera de inversiones. <br><br>  AWS tiene una amplia selección de herramientas, pero utilizaremos lo siguiente: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Amazon S3</a> : almacenamiento de objetos, que le permite almacenar cantidades casi ilimitadas de información; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AWS Glue</a> : el servicio ETL en la nube más potente que puede determinar la estructura y generar el código ETL a partir de los datos de origen dados; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Amazon Athena</a> , un servicio de consulta SQL en línea sin servidor, le permite analizar rápidamente los datos de S3 sin mucha preparación.  También tiene acceso a los metadatos que prepara AWS Glue, que le permite acceder a los datos inmediatamente después de pasar el ETL; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Amazon QuickSight</a> : servicio de BI sin servidor, puede crear cualquier visualización, informes analíticos "sobre la marcha", etc. </li></ul><br>  La documentación de Amazon está bien, en particular, hay un buen artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mejores prácticas al usar Athena con AWS Glue</a> , que describe cómo crear y usar tablas y datos usando AWS Glue.  Aprovechemos las ideas principales de este artículo y aplíquelas para crear nuestra propia arquitectura de un sistema de informes analíticos. <br><br>  Los archivos CSV preparados por nuestro analizador de informes se agregarán al depósito S3.  Está previsto que la carpeta correspondiente en S3 se reponga todos los sábados, al final de la semana de negociación, por lo que no puede prescindir de la partición de datos en la fecha de formación y procesamiento del informe. <br>  Además de optimizar el funcionamiento de las consultas SQL a dichos datos, este enfoque nos permitirá realizar análisis adicionales, por ejemplo, para obtener la dinámica de los cambios en el resultado financiero de cada artículo, etc. <br><br><div class="spoiler">  <b class="spoiler_title">Trabaja con Amazon S3</b> <div class="spoiler_text"><ul><li>  Cree un depósito en S3, llámelo "informe-analizador"; </li><li>  En este bucket "report-parser" crea una carpeta llamada "my_trader_diary"; </li><li>  En el directorio "my_trader_diary", cree un directorio con la fecha del informe actual, por ejemplo, "date_report = 2018-10-01" y coloque el archivo CSV en él; </li><li>  Solo en aras del experimento y una mejor comprensión de la partición, crearemos dos directorios más: “date_report = 2018-09-27” y “date_report = 2018-10-08”.  Ponemos el mismo archivo CSV en ellos; </li><li>  El último "informe-analizador" del cubo S3 debería parecerse al que se muestra en las imágenes a continuación: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n1/4z/c9/n14zc9odchiv6l-_dpc_qbs3s_o.png"></div></li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Trabajar con AWS Glue</b> <div class="spoiler_text">  En general, solo puede hacer Amazon Athena para crear una tabla externa a partir de los datos que se encuentran en S3, pero AWS Glue es una herramienta más flexible y conveniente para esto. <br><br><ul><li>  Entramos en AWS Glue y creamos un nuevo Crawler, que recopilará una tabla de archivos CSV separados informando las fechas: <br><ul><li>  Establecer el nombre del nuevo rastreador; </li><li>  Indicamos el repositorio de dónde obtener los datos (s3: // report-parser / my_trader_diary /) </li><li>  Seleccionamos o creamos un nuevo rol de IAM que tendrá acceso para iniciar Crawler y acceder al recurso especificado en S3; </li><li>  A continuación, debe establecer la frecuencia de inicio.  Lo ponemos a la demanda por ahora, pero en el futuro, creo que esto cambiará y el lanzamiento será semanal; </li><li>  Guarde y espere a que se cree el rastreador. </li></ul></li><li>  Cuando el Crawler entre en el estado Listo, ¡inícielo! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/xx/z9/edxxz9kurfrebky5-fuaqwzt-0e.png"></div></li><li>  Una vez que funcione, aparecerá una nueva tabla my_trader_diary en AWS Glue: Base de datos -&gt; pestaña Tablas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u6/2n/rt/u62nrttephj6m-hxxguky4il6os.png"></div></li></ul></div></div><br>  Considere la tabla generada con más detalle. <br>  Si hace clic en el nombre de la tabla creada, iremos a la página con la descripción de los metadatos.  En la parte inferior hay un diseño de tabla y el más reciente es una columna que no estaba en el archivo CSV de origen: date_report.  Esta columna AWS Glue se crea automáticamente en función de la definición de secciones de los datos de origen (en el Bucket S3, nombramos especialmente las carpetas date_report = AAAA-MM-DD, lo que nos permitió usarlas como secciones separadas por fecha). <br><br><div class="spoiler">  <b class="spoiler_title">Particionamiento de tabla</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/30/2v/5o302vb08y_zmylnfyaiign5us0.png"></div><br>  En la misma página en la esquina superior derecha hay un botón Ver particiones, al hacer clic en el que podemos ver en qué secciones se compone nuestra tabla generada: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/82/0l/kk/820lkk4mytj34kzh0tt__ieb6me.png"></div></div></div><br><h2>  Análisis de datos </h2><br>  Teniendo a nuestra disposición datos procesados ​​cargados, podemos comenzar a analizarlos fácilmente.  Para comenzar, considere las capacidades de Amazon Athena como la forma más fácil y rápida de realizar consultas analíticas.  Para hacer esto, vaya al servicio Amazon Athena, seleccione la base de datos que necesitamos (financiera) y escriba el siguiente código SQL: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d.date_report, d.account, d.stock_name, d.currency, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.quantity) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> quantity, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.result), <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_trader_diary d <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.date_report, d.account, d.stock_name, d.currency <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.account, d.stock_name, d.date_report;</code> </pre> <br>  Esta solicitud nos mostrará un resultado financiero neto para cada valor para todas las fechas de informes.  Porque  descargamos el mismo informe tres veces para diferentes fechas, el resultado no cambiará, lo que, por supuesto, en un mercado real será diferente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9o/fg/dl/9ofgdloafbrxbvctdyprolilvna.png"></div><br>  Pero, ¿qué sucede si queremos visualizar los datos recibidos en forma de tablas o diagramas flexibles?  Aquí Amazon QuickSight viene al rescate, con la ayuda de la cual puede configurar análisis flexibles casi tan rápido como escribir una consulta SQL.  Iremos al servicio Amazon QuickSight (si no se ha registrado allí, entonces es necesario registrarse). <br><br>  Haga clic en el botón Nuevos análisis -&gt; Nuevo conjunto de datos y en la ventana que aparece seleccionar las fuentes para el conjunto de datos, haga clic en Athena: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kr/bv/yqkrbv144qas16af4jolsj3rnci.png"></div><br><br>  Vamos a encontrar un nombre para nuestra fuente de datos, por ejemplo, "PNL_analysis" y hacer clic en el botón "Crear fuente de datos". <br><br>  A continuación, se abre la ventana Elija su tabla, donde debe seleccionar la base de datos y la tabla de origen de datos.  Seleccionamos la base de datos financiera y la tabla que contiene: my_traider_diary.  De manera predeterminada, se utiliza toda la tabla, pero si selecciona "Usar SQL personalizado", puede personalizar y ajustar la muestra de datos que necesita.  Por ejemplo, usamos toda la tabla y hacemos clic en el botón Editar / Vista previa de datos. <br><br>  Se abrirá una nueva página donde puede realizar configuraciones adicionales y procesar datos existentes. <br><br>  Ahora necesitamos agregar campos calculados adicionales a nuestro conjunto de datos: trimestre y año de operación.  Un lector atento puede notar que tales manipulaciones fueron más fáciles de realizar en el analizador antes de guardar el Informe Final en CSV.  Sin lugar a dudas, mi objetivo ahora es demostrar las capacidades y la flexibilidad de la configuración del sistema de BI sobre la marcha.  Continuamos creando campos calculados haciendo clic en el botón "Nuevo campo". <br><br><div class="spoiler">  <b class="spoiler_title">Crea un nuevo campo</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ax/1z/ag/ax1zagyy7nnryd62t5najdntcio.png"></div></div></div><br>  Para resaltar el año de la operación y el trimestre, se utilizan fórmulas simples: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/yc/bi/pmycbiybxqtus62nkaa_5v2fu4s.png"></div><br><div class="spoiler">  <b class="spoiler_title">Completar fórmulas para un nuevo campo</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uo/e1/u1/uoe1u1uco3ygn7cljsr6qcnhwbk.png"></div></div></div><br>  Cuando los campos calculados se hayan creado y agregado correctamente a la selección, asigne un nombre a nuestro conjunto de datos, por ejemplo, "my_pnl_analyze" y haga clic en el botón "Guardar y visualizar". <br><br>  Después de eso, nos transferimos a la placa principal de Amazon QuickSight y lo primero que debemos hacer es configurar un filtro para la fecha del informe (teniendo en cuenta que se recopilaron los mismos datos de tres secciones).  Seleccione la fecha del informe 2018-10-01 y haga clic en el botón Aplicar y vaya a la pestaña Visualizar. <br><br><div class="spoiler">  <b class="spoiler_title">Ajuste del filtro</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/an/jo/et/anjoet5xt_divhygnebb5v9ys8k.png"></div></div></div><br>          , ,       ,        (..      )   .      BI –  .      ,       (   MS Excel) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/90/3e/it/903eitay8v9j1psyz05d8qaqh_k.png"></div><blockquote>     ,          ,      , ..     1 509.91 .     (1 763.36 . –     174 . –   ).         . </blockquote><br>   –  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/up/a7/qj/upa7qjdqjiqyo-j6tx0bnrth67m.png"></div><br>    ,   ,      ,               .       : sum_investment  count_days. <br><br><div class="spoiler"> <b class="spoiler_title"> sum_investment</b> <div class="spoiler_text">   sum_investment ( )   : <br><br> ifelse({stock_name} = ' 24019',{avg_open_price} * quantity * 10,{avg_open_price} * quantity) <br><br>           ,       –     (    – 1000). <br></div></div><br><div class="spoiler"> <b class="spoiler_title"> count_days</b> <div class="spoiler_text">   count_day (   )                : <br><br> dateDiff(parseDate({date_oper}),parseDate({date_report})) <br></div></div><br>      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ws/dk/utwsdkbzhksrjh3wunw_w6stqr0.png"></div><br><br><h2>    </h2><br>              « »    Amazon.          , ..            , ,          ,  . <br><br>              ,     (  )     .   ,        ,     ,       –     . <br><br> ,           . ,      PNL        (,    ),       .…     Quicksight     ,    ,        Python      . <br><br>     -  ,      :          XML-! ,    ,  API               .       Amazon:   ETL-job  AWS Glue           Amazon QuickSight    . <br><br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426027/">https://habr.com/ru/post/es426027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426017/index.html">Cómo reducir el número de experimentos con animales.</a></li>
<li><a href="../es426019/index.html">Estación meteorológica en Arduino de la A a la Z. Parte 5</a></li>
<li><a href="../es426021/index.html">libgdx y sentimientos</a></li>
<li><a href="../es426023/index.html">Lección abierta "Laboratorio virtual en Vagrant"</a></li>
<li><a href="../es426025/index.html">Usar métodos ofensivos para enriquecer la Inteligencia de amenazas</a></li>
<li><a href="../es426029/index.html">¿Te rindes y quieres abandonar la tarea? Así es como se ve la capacitación efectiva para desarrolladores</a></li>
<li><a href="../es426031/index.html">Preocuparse por capturar el mundo con inteligencia artificial puede basarse en suposiciones no científicas</a></li>
<li><a href="../es426033/index.html">Choque de titanes matemáticos sobre prueba épica de hipótesis ABC</a></li>
<li><a href="../es426039/index.html">Lanzamiento de emergencia "Soyuz MS-10" (equipo rescatado, transmitido)</a></li>
<li><a href="../es426041/index.html">Solución simbólica de ecuaciones diferenciales lineales y sistemas mediante el método de transformación de Laplace utilizando SymPy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>