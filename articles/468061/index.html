<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😡 🙍 🆒 Cron en Linux: historia, uso y dispositivo ✌️ 👑 🎌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El clásico escribió que las horas felices no se observan. En esos tiempos salvajes, no había programadores ni Unix, pero hoy en día los programadores ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cron en Linux: historia, uso y dispositivo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468061/"><img src="https://habrastorage.org/webt/tm/ya/6j/tmya6jd_1sbhnfncczo1nf2g7_y.jpeg"><br><p>  El clásico escribió que las horas felices no se observan.  En esos tiempos salvajes, no había programadores ni Unix, pero hoy en día los programadores lo saben muy bien: en lugar de ellos, cron seguirá el tiempo. </p><br><p>  Las utilidades de línea de comando para mí son tanto debilidad como de rutina.  sed, awk, wc, cut y otros programas antiguos se ejecutan diariamente mediante scripts en nuestros servidores.  Muchos de ellos están diseñados como tareas para cron, un planificador de los años 70. </p><br><p>  Durante mucho tiempo usé cron superficialmente, sin entrar en detalles, pero una vez, al encontrar un error al ejecutar el script, decidí resolverlo a fondo.  Así que este artículo apareció, al escribir el que conocí con POSIX crontab, las principales variantes cron en las distribuciones populares de Linux y el dispositivo de algunas de ellas. </p><br><p>  ¿Usando Linux y ejecutando tareas en cron?  ¿Interesado en la arquitectura de aplicaciones del sistema Unix?  Entonces estamos en camino! </p><a name="habracut"></a><br><h1 id="soderzhanie">  Contenido </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Origen de las especies</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Posix crontab</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bestseller - Vixie cron 3.0pl1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cron en Debian y Ubuntu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compinche en Red Hat, Fedora y CentOS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compinche en SLES y openSUSE</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dispositivo cron Vixie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Epílogo</a> </li></ul><br><h1 id="proishozhdenie-vidov">  Origen de las especies </h1><br><p>  La ejecución periódica de programas de usuario o sistema es una necesidad obvia para todos los sistemas operativos.  Por lo tanto, la necesidad de servicios que permitan la planificación centralizada y la ejecución de tareas, los programadores se han dado cuenta desde hace mucho tiempo. </p><br><p> Los sistemas operativos tipo Unix derivan su pedigrí de la Versión 7 Unix, desarrollada en la década de 1970 por Bell Labs, incluido el famoso Ken Thompson.  Junto con la Versión 7 de Unix, también se suministró cron, un servicio para la ejecución regular de tareas de superusuario. </p><br><p>  Un cron moderno típico es un programa simple, pero el algoritmo de la versión original era aún más simple: el servicio se despertaba una vez por minuto, leía la placa de tareas de un solo archivo (/ etc / lib / crontab) y realizaba para el superusuario las tareas que deberían realizarse en el minuto actual . </p><br><p>  Posteriormente, las opciones avanzadas para un servicio simple y útil llegaron con todos los sistemas operativos tipo Unix. </p><br><p>  Las descripciones generalizadas del formato crontab y los principios básicos de la utilidad en 1992 se incluyeron en el estándar principal de los sistemas operativos tipo Unix, POSIX, y, por lo tanto, cron del estándar de facto se convirtió en el estándar de jure. </p><br><p>  En 1987, Paul Vixie, después de entrevistar a los usuarios de Unix para obtener sugerencias para cron, lanzó otra versión del demonio que soluciona algunos de los problemas del cron tradicional y extiende la sintaxis de los archivos de tabla. </p><br><p>  En la tercera versión, Vixie cron comenzó a cumplir con los requisitos de POSIX, además, el programa tenía una licencia liberal, o mejor dicho, no había ninguna licencia, excepto por los deseos en README: el autor no da garantías, no puede eliminar el nombre del autor y solo puede vender el programa con código fuente  Estos requisitos resultaron ser compatibles con los principios del software libre, que estaba ganando popularidad en esos años, por lo que algunas de las distribuciones clave de Linux que aparecieron a principios de los 90 tomaron Vixie cron como una distribución del sistema y todavía lo están desarrollando. </p><br><p>  En particular, Red Hat y SUSE están desarrollando Vixie cron - cronie fork, mientras que Debian y Ubuntu están usando el cron original de Vixie con muchos parches. </p><br><p>  Primero, conozcamos la utilidad crontab definida por el usuario descrita en POSIX, después de lo cual analizaremos las extensiones de sintaxis introducidas en Vixie cron y el uso de variaciones de Vixie cron en distribuciones populares de Linux.  Y finalmente, la guinda del pastel es un análisis del dispositivo cron daemon. </p><br><h1 id="posix-crontab">  Posix crontab </h1><br><p>  Si el cron original siempre funcionó para el superusuario, los programadores modernos a menudo se ocupan de las tareas de los usuarios comunes, lo que es más seguro y conveniente. </p><br><p>  Los Cron se envían con un conjunto de dos programas: el demonio cron que se ejecuta constantemente y la utilidad crontab disponible para los usuarios.  Este último le permite editar tablas de tareas específicas para cada usuario en el sistema, mientras que el demonio inicia tareas desde las tablas de usuario y del sistema. </p><br><p>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estándar POSIX</a> no describe el comportamiento del demonio, y solo se formaliza el programa de usuario <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">crontab</a> .  La existencia de mecanismos para iniciar las tareas del usuario, por supuesto, está implícita, pero no se describe en detalle. </p><br><p>  Hay cuatro cosas que puede hacer con la utilidad crontab: editar la tabla de tareas del usuario en el editor, cargar la tabla desde el archivo, mostrar la tabla de tareas actual y borrar la tabla de tareas.  Ejemplos de la utilidad crontab: </p><br><pre><code class="plaintext hljs">crontab -e #    crontab -l #    crontab -r #    crontab path/to/file.crontab #     </code> </pre> <br><p>  Al llamar a <code>crontab -e</code> , se utilizará el editor especificado en la <code>EDITOR</code> entorno <code>EDITOR</code> estándar. </p><br><p>  Las tareas mismas se describen en el siguiente formato: </p><br><pre> <code class="plaintext hljs"># -  # # ,   * * * * * /path/to/exec -a -b -c # ,   10-    10 * * * * /path/to/exec -a -b -c # ,   10-            10 2 * * * /path/to/exec -a -b -c &gt; /tmp/cron-job-output.log</code> </pre> <br><p>  Los primeros cinco campos de registro: minutos [1..60], horas [0..23], días del mes [1..31], meses [1..12], días de la semana [0..6], donde 0 - domingo  El último, sexto campo, es una cadena que será ejecutada por el intérprete de comandos estándar. </p><br><p>  En los primeros cinco campos, los valores se pueden enumerar con una coma: </p><br><pre> <code class="plaintext hljs"># ,         1,10 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  O a través de un guión: </p><br><pre> <code class="plaintext hljs"># ,          0-9 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  El acceso de los usuarios a la programación de tareas está regulado en los archivos POSIX cron.allow y cron.deny que enumeran, respectivamente, los usuarios con acceso a crontab y los usuarios sin acceso al programa.  El estándar no regula la ubicación de estos archivos. </p><br><p>  Los programas en ejecución, de acuerdo con el estándar, deben pasar al menos cuatro variables de entorno: </p><br><ol><li>  HOME es el directorio de inicio del usuario. </li><li>  LOGNAME: inicio de sesión del usuario. </li><li>  RUTA es el camino por el cual encontrar las utilidades del sistema estándar. </li><li>  SHELL es el camino hacia el shell utilizado. </li></ol><br><p>  Es de destacar que POSIX no dice nada acerca de dónde provienen los valores para estas variables. </p><br><h1 id="hit-prodazh--vixie-cron-30pl1">  Bestseller - Vixie cron 3.0pl1 </h1><br><p>  El antecesor común de las variantes cron populares es Vixie cron 3.0pl1, presentado en la lista de correo comp.sources.unix de 1992.  Las características principales de esta versión las consideraremos con más detalle. </p><br><p>  Vixie cron viene en dos programas (cron y crontab).  Como de costumbre, el daemon es responsable de leer e iniciar tareas desde la tabla de tareas del sistema y las tablas de tareas de usuarios individuales, y la utilidad crontab es responsable de editar las tablas de usuarios. </p><br><h3 id="tablica-zadach-i-fayly-konfiguracii">  Tabla de tareas y archivos de configuración </h3><br><p>  La tabla de tareas del superusuario se encuentra en / etc / crontab.  La sintaxis de la tabla del sistema corresponde a la sintaxis de Vixie cron, ajustada por el hecho de que la sexta columna indica el nombre del usuario en nombre de quién se inicia la tarea: </p><br><pre> <code class="plaintext hljs">#     vlad * * * * * vlad /path/to/exec</code> </pre> <br><p>  Las tablas de tareas de usuario comunes se encuentran en / var / cron / tabs / username y usan una sintaxis común.  Cuando se inicia la utilidad crontab, estos archivos se editan en nombre del usuario. </p><br><p>  Las listas de usuarios con acceso a crontab se administran en los archivos / var / cron / allow y / var / cron / deny, donde es suficiente agregar el nombre de usuario como una línea separada. </p><br><h3 id="rasshirennyy-sintaksis">  Sintaxis Extendida </h3><br><p>  En comparación con el crontab POSIX, la solución de Paul Vixie contiene varias modificaciones muy útiles a la sintaxis de la tabla de tareas de la utilidad. </p><br><p>  Se ha puesto a disposición una nueva sintaxis de tabla: por ejemplo, puede especificar los días de la semana o los meses por nombre (lunes, martes, etc.): </p><br><pre> <code class="plaintext hljs">#         * * * Jan Mon,Tue /path/to/exec</code> </pre> <br><p>  Puede especificar el paso a través del cual se inician las tareas: </p><br><pre> <code class="plaintext hljs">#       */2 * * * Mon,Tue /path/to/exec</code> </pre> <br><p>  Los pasos e intervalos se pueden mezclar: </p><br><pre> <code class="plaintext hljs">#             0-10/2 * * * * /path/to/exec</code> </pre> <br><p>  Se admiten alternativas intuitivas a la sintaxis regular (reinicio, anual, anual, mensual, semanal, diario, medianoche, por hora): </p><br><pre> <code class="plaintext hljs">#     @reboot /exec/on/reboot #     @daily /exec/daily #     @hourly /exec/daily</code> </pre> <br><h3 id="sreda-vypolneniya-zadach">  Entorno de ejecución de tareas </h3><br><p>  Vixie cron le permite cambiar el entorno de las aplicaciones en ejecución. </p><br><p>  Las variables de entorno USER, LOGNAME y HOME no solo las proporciona el daemon, sino que se toman del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivo passwd</a> .  La variable PATH obtiene el valor "/ usr / bin: / bin", y SHELL obtiene el valor "/ bin / sh".  Los valores de todas las variables excepto LOGNAME se pueden cambiar en las tablas de usuario. </p><br><p>  El mismo cron utiliza algunas variables de entorno (principalmente SHELL y HOME) para ejecutar la tarea.  Así es como se vería usar bash en lugar de sh estándar para ejecutar tareas personalizadas: </p><br><pre> <code class="plaintext hljs">SHELL=/bin/bash HOME=/tmp/ # exec   bash-  /tmp/ * * * * * /path/to/exec</code> </pre> <br><p>  En última instancia, todas las variables de entorno definidas en la tabla (utilizadas por cron o necesarias para el proceso) se transferirán a la tarea en ejecución. </p><br><p>  La utilidad crontab utiliza el editor especificado en la variable de entorno VISUAL o EDITOR para editar archivos.  Si estas variables no están definidas en el entorno donde se lanzó crontab, entonces se usa "/ usr / ucb / vi" (ucb es probablemente la Universidad de California, Berkeley). </p><br><h1 id="cron-v-debian-i-ubuntu">  cron en Debian y Ubuntu </h1><br><p>  Los desarrolladores de Debian y derivados han lanzado una versión <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">altamente modificada</a> de Vixie cron versión 3.0pl1.  No hay diferencias en la sintaxis de los archivos de tabla; para los usuarios, este es el mismo cron de Vixie.  Nuevas características más importantes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">syslog</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SELinux</a> y soporte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PAM</a> . </p><br><p>  De los cambios menos notables, pero tangibles: la ubicación de los archivos de configuración y las tablas de tareas. </p><br><p>  Las tablas de usuarios en Debian se encuentran en el directorio / var / spool / cron / crontabs, la tabla del sistema todavía está en / etc / crontab.  Las tablas de tareas específicas de Debian se colocan en /etc/cron.d, desde donde el cron daemon las lee automáticamente.  El control de acceso del usuario está regulado por los archivos /etc/cron.allow y /etc/cron.deny. </p><br><p>  El shell / bin / sh predeterminado todavía se usa como el shell predeterminado. Debian reproduce un pequeño shell de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tablero</a> compatible con POSIX que se ejecuta sin leer ninguna configuración (en modo no interactivo). </p><br><p>  Cron en las últimas versiones de Debian se inicia a través de systemd, y la configuración de inicio se puede ver en /lib/systemd/system/cron.service.  No hay nada especial en la configuración del servicio; cualquier gestión de tareas más fina se puede hacer a través de variables de entorno declaradas directamente en el crontab de cada usuario. </p><br><h1 id="cronie-v-redhat-fedora-i-centos">  cronie en RedHat, Fedora y CentOS </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cronie</a> - fork de Vixie cron versión 4.1.  Al igual que en Debian, la sintaxis no cambió, pero se agregó soporte para PAM y SELinux, trabajando en un clúster, rastreando archivos usando inotify y otras características. </p><br><p>  La configuración predeterminada está en los lugares habituales: la tabla del sistema está en / etc / crontab, los paquetes colocan sus tablas en /etc/cron.d, las tablas de usuario se encuentran en / var / spool / cron / crontabs. </p><br><p>  El daemon se ejecuta en systemd, la configuración del servicio es /lib/systemd/system/crond.service. </p><br><p>  En el inicio, las distribuciones similares a Red Hat usan / bin / sh de manera predeterminada, cuya función es bash estándar.  Cabe señalar que cuando se ejecutan tareas cron a través de / bin / sh, el shell bash se inicia en modo compatible con POSIX y no lee ninguna configuración adicional cuando se opera en modo no interactivo. </p><br><h1 id="cronie-v-sles-i-opensuse">  compinche en SLES y openSUSE </h1><br><p>  La distribución alemana SLES y su derivada openSUSE usan el mismo compinche.  El demonio aquí también se ejecuta en systemd, la configuración del servicio está en /usr/lib/systemd/system/cron.service.  Configuración: / etc / crontab, /etc/cron.d, / var / spool / cron / tabs.  Como / bin / sh actúa el mismo bash, lanzado en modo no interactivo compatible con POSIX. </p><br><h1 id="ustroystvo-vixie-cron">  Dispositivo cron Vixie </h1><br><p>  Los descendientes modernos de cron no han cambiado radicalmente en comparación con Vixie cron, pero sin embargo, han adquirido nuevas capacidades que no se requieren para comprender los principios del programa.  Muchas de estas extensiones son desordenadas y confunden el código.  Es un placer leer el código fuente original de cron de Paul Vixie. </p><br><p>  Por lo tanto, decidí analizar el dispositivo cron utilizando el ejemplo de un programa común para ambas ramas del desarrollo cron: Vixie cron 3.0pl1.  Simplificaré los ejemplos eliminando ifdefs que complican la lectura y omitiendo los detalles secundarios. </p><br><p>  El trabajo del demonio se puede dividir en varias etapas: </p><br><ol><li>  Inicialización del programa. </li><li>  Recopile y actualice la lista de tareas para ejecutar. </li><li>  La operación principal del ciclo cron. </li><li>  Lanzamiento de tarea. </li></ol><br><p>  Vamos a ordenarlos en orden. </p><br><h3 id="inicializaciya">  Inicialización </h3><br><p>  Cuando se inicia, después de verificar los argumentos del proceso, cron instala los manejadores de señal SIGCHLD y SIGHUP.  El primero registra la finalización del proceso secundario, el segundo cierra el descriptor de archivo del archivo de registro: </p><br><pre> <code class="cpp hljs">signal(SIGCHLD, sigchld_handler); signal(SIGHUP, sighup_handler);</code> </pre> <br><p>  El demonio cron en el sistema siempre funciona solo, solo como superusuario y desde el directorio principal cron.  Las siguientes llamadas crean un bloqueo de archivo con el PID del proceso del daemon, asegúrese de que el usuario sea correcto y cambie el directorio actual al directorio principal: </p><br><pre> <code class="cpp hljs">acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); set_cron_uid(); set_cron_cwd();</code> </pre> <br><p>  Se establece la ruta predeterminada, que se utilizará al iniciar los procesos: </p><br><pre> <code class="cpp hljs">setenv(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, _PATH_DEFPATH, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Luego, el proceso se "demoniza": crea una copia secundaria del proceso llamando a fork y una nueva sesión en el proceso secundario (llamando a setsid).  Ya no hay necesidad del proceso padre, y completa el trabajo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> _exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><p>  La finalización del proceso principal libera el bloqueo en el archivo de bloqueo.  Además, debe actualizar el PID en el archivo para el niño.  Después de eso, se llena la base de datos de tareas: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> database.head = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.tail = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.mtime = (<span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; load_database(&amp;database);</code> </pre> <br><p>  Más cron procede al ciclo de trabajo principal.  Pero antes de eso, eche un vistazo a cargar la lista de tareas. </p><br><h3 id="sbor-i-obnovlenie-spiska-zadach">  Recopilar y actualizar la lista de tareas </h3><br><p>  La función load_database es responsable de cargar la lista de tareas.  Comprueba el crontab del sistema principal y el directorio con archivos de usuario.  Si los archivos y el directorio no han cambiado, la lista de tareas no se vuelve a leer.  De lo contrario, comienza a formarse una nueva lista de tareas. </p><br><p>  Descargar un archivo del sistema con nombres especiales de archivos y tablas: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syscron_stat.st_mtime) { process_crontab(<span class="hljs-string"><span class="hljs-string">"root"</span></span>, <span class="hljs-string"><span class="hljs-string">"*system*"</span></span>, SYSCRONTAB, &amp;syscron_stat, &amp;new_db, old_db); }</code> </pre> <br><p>  Carga de tablas de usuario en un bucle: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != (dp = readdir(dir))) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>], tabname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dp-&gt;d_name[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(fname, dp-&gt;d_name); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(tabname, CRON_TAB(fname)); process_crontab(fname, fname, tabname, &amp;statbuf, &amp;new_db, old_db); }</code> </pre><br><p>  Luego, la base de datos anterior se reemplaza por una nueva. </p><br><p>  En los ejemplos anteriores, llamar a la función process_crontab asegura que exista el usuario que coincida con el nombre del archivo de la tabla (a menos que sea el superusuario) y luego llama a load_user.  Este último ya lee el archivo en sí línea por línea: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((status = load_env(envstr, file)) &gt;= OK) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ERR: free_user(u); u = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> done; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: e = load_entry(file, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, pw, envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e) { e-&gt;next = u-&gt;crontab; u-&gt;crontab = e; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: envp = env_set(envp, envstr); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><p>  Aquí, las funciones load_env / env_set establecen la variable de entorno (líneas de la forma VAR = valor), o la función load_entry lee la descripción de la tarea (* * * * * / path / to / exec). </p><br><p>  La entidad de entrada devuelta por load_entry es nuestra tarea ubicada en la lista general de tareas.  En la función en sí, se realiza un largo análisis del formato de tiempo, pero estamos más interesados ​​en la formación de variables de entorno y parámetros de inicio de tareas: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*         passwd*/</span></span> e-&gt;uid = pw-&gt;pw_uid; e-&gt;gid = pw-&gt;pw_gid; <span class="hljs-comment"><span class="hljs-comment">/*    (/bin/sh),      */</span></span> e-&gt;envp = env_copy(envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"SHELL=%s"</span></span>, _PATH_BSHELL); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"HOME=%s"</span></span>, pw-&gt;pw_dir); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"PATH=%s"</span></span>, _PATH_DEFPATH); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     passwd */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"%s=%s"</span></span>, <span class="hljs-string"><span class="hljs-string">"LOGNAME"</span></span>, pw-&gt;pw_name); e-&gt;envp = env_set(e-&gt;envp, envstr);</code> </pre> <br><p>  El ciclo principal también funciona con la lista actual de tareas. </p><br><h3 id="glavnyy-cikl">  Ciclo principal </h3><br><p>  El cron original de la versión 7 de Unix funcionó de manera bastante simple: en un ciclo volví a leer la configuración, ejecuté las tareas del minuto actual como superusuario y dormí hasta el comienzo del siguiente minuto.  Este enfoque simple en máquinas antiguas requería demasiados recursos. </p><br><p>  Se propuso una versión alternativa en SysV, en la que el demonio se durmió hasta el siguiente minuto, para el cual se definió la tarea, o durante 30 minutos.  Los recursos para releer la configuración y verificar las tareas en este modo se consumieron menos, pero se volvió inconveniente actualizar rápidamente la lista de tareas. </p><br><p>  Vixie cron volvió a revisar las listas de tareas una vez por minuto, ya que a fines de los años 80 los recursos en máquinas Unix estándar se habían vuelto mucho más grandes: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  ,       */</span></span> run_reboot_jobs(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime    */</span></span> cron_sync(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (TRUE) { <span class="hljs-comment"><span class="hljs-comment">/*  ,     TargetTime    ,    */</span></span> cron_sleep(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> cron_tick(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime     */</span></span> TargetTime += <span class="hljs-number"><span class="hljs-number">60</span></span>; }</code> </pre><br><p>  La función cron_sleep, que llama a las funciones job_runqueue (enumeración e inicio de tareas) y do_command (inicio de cada tarea individual), participa directamente en la realización de tareas.  La última función debe considerarse con más detalle. </p><br><h3 id="zapusk-zadachi">  Lanzamiento de tarea </h3><br><p>  La función do_command se ejecuta en un buen estilo Unix, es decir, se bifurca para la ejecución asincrónica de tareas.  El proceso padre continúa lanzando tareas, el proceso hijo está preparando el proceso de la tarea: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   fork */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*  :          */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> child_process(e, u); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> _exit(OK_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  Hay mucha lógica en child_process: toma la salida estándar y el error fluye sobre sí mismo, para que luego se pueda enviar por correo (si la variable de entorno MAILTO se especifica en la tabla de tareas) y, finalmente, espera a que se complete el proceso de la tarea principal. </p><br><p>  El proceso de la tarea está formado por otra bifurcación: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (vfork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(ERROR_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* -   ,   .. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-comment"><span class="hljs-comment">/* *     ,    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  ,    , *       */</span></span> setgid(e-&gt;gid); setuid(e-&gt;uid); chdir(env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*   SHELL      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *shell = env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*       , *    ,       */</span></span> execle(shell, shell, <span class="hljs-string"><span class="hljs-string">"-c"</span></span>, e-&gt;cmd, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*  —    ?   */</span></span> perror(<span class="hljs-string"><span class="hljs-string">"execl"</span></span>); _exit(ERROR_EXIT); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    :      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  Aquí, en general, y todo el cron.  Omití algunos detalles interesantes, por ejemplo, la contabilidad de usuarios remotos, pero describí lo principal. </p><br><h1 id="posleslovie">  Epílogo </h1><br><p>  Cron es un programa sorprendentemente simple y útil, hecho en las mejores tradiciones del mundo Unix.  Ella no hace nada superfluo, pero ha estado haciendo su trabajo notablemente durante las últimas décadas.  Conocer el código de la versión que viene con Ubuntu no tardó más de una hora, ¡y me divertí mucho!  Espero poder compartirlo contigo. </p><br><p>  No sé sobre ti, pero es un poco triste para mí darme cuenta de que la programación moderna, con su tendencia a complicarse y abstraerse, ha dejado de tener tanta simplicidad. </p><br><p>  Hay muchas alternativas modernas para cron: systemd-timers le permite organizar sistemas complejos con dependencias, en fcron puede controlar de manera más flexible el consumo de recursos por tareas.  Pero personalmente, siempre he tenido el crontab más simple. </p><br><p>  En una palabra, ¡ama Unix, usa programas simples y no te olvides de leer maná para tu plataforma! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468061/">https://habr.com/ru/post/468061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468049/index.html">Uso de werf para desplegar gráficos complejos de Helm</a></li>
<li><a href="../468051/index.html">VDS con Windows Server con licencia por 100 rublos: ¿mito o realidad?</a></li>
<li><a href="../468053/index.html">Aprendizaje automático para su caza plana. Parte 1</a></li>
<li><a href="../468057/index.html">Desarrollo de sistema operativo tipo Unix: multitarea y llamadas al sistema (7)</a></li>
<li><a href="../468059/index.html">Mi segunda semana con Haiku: muchos diamantes escondidos y sorpresas agradables, así como algunos problemas</a></li>
<li><a href="../468063/index.html">Angulareact</a></li>
<li><a href="../468065/index.html">Modelos de gestión mental de productos para todos</a></li>
<li><a href="../468067/index.html">Cómo funciona la composición alfa</a></li>
<li><a href="../468071/index.html">Eduard Medvedev, CTO de Tungsten Labs: "Hemos crecido hasta el punto en que la tecnología puede causar daños masivos"</a></li>
<li><a href="../468073/index.html">Andrei Terekhov: "Puedes decir todo lo que quieras que el estadounidense es mejor, pero nuestro auto nunca se descompone"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>