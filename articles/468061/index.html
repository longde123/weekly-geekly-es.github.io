<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò° üôç üÜí Cron en Linux: historia, uso y dispositivo ‚úåÔ∏è üëë üéå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El cl√°sico escribi√≥ que las horas felices no se observan. En esos tiempos salvajes, no hab√≠a programadores ni Unix, pero hoy en d√≠a los programadores ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cron en Linux: historia, uso y dispositivo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468061/"><img src="https://habrastorage.org/webt/tm/ya/6j/tmya6jd_1sbhnfncczo1nf2g7_y.jpeg"><br><p>  El cl√°sico escribi√≥ que las horas felices no se observan.  En esos tiempos salvajes, no hab√≠a programadores ni Unix, pero hoy en d√≠a los programadores lo saben muy bien: en lugar de ellos, cron seguir√° el tiempo. </p><br><p>  Las utilidades de l√≠nea de comando para m√≠ son tanto debilidad como de rutina.  sed, awk, wc, cut y otros programas antiguos se ejecutan diariamente mediante scripts en nuestros servidores.  Muchos de ellos est√°n dise√±ados como tareas para cron, un planificador de los a√±os 70. </p><br><p>  Durante mucho tiempo us√© cron superficialmente, sin entrar en detalles, pero una vez, al encontrar un error al ejecutar el script, decid√≠ resolverlo a fondo.  As√≠ que este art√≠culo apareci√≥, al escribir el que conoc√≠ con POSIX crontab, las principales variantes cron en las distribuciones populares de Linux y el dispositivo de algunas de ellas. </p><br><p>  ¬øUsando Linux y ejecutando tareas en cron?  ¬øInteresado en la arquitectura de aplicaciones del sistema Unix?  Entonces estamos en camino! </p><a name="habracut"></a><br><h1 id="soderzhanie">  Contenido </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Origen de las especies</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Posix crontab</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bestseller - Vixie cron 3.0pl1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cron en Debian y Ubuntu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compinche en Red Hat, Fedora y CentOS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compinche en SLES y openSUSE</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dispositivo cron Vixie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ep√≠logo</a> </li></ul><br><h1 id="proishozhdenie-vidov">  Origen de las especies </h1><br><p>  La ejecuci√≥n peri√≥dica de programas de usuario o sistema es una necesidad obvia para todos los sistemas operativos.  Por lo tanto, la necesidad de servicios que permitan la planificaci√≥n centralizada y la ejecuci√≥n de tareas, los programadores se han dado cuenta desde hace mucho tiempo. </p><br><p> Los sistemas operativos tipo Unix derivan su pedigr√≠ de la Versi√≥n 7 Unix, desarrollada en la d√©cada de 1970 por Bell Labs, incluido el famoso Ken Thompson.  Junto con la Versi√≥n 7 de Unix, tambi√©n se suministr√≥ cron, un servicio para la ejecuci√≥n regular de tareas de superusuario. </p><br><p>  Un cron moderno t√≠pico es un programa simple, pero el algoritmo de la versi√≥n original era a√∫n m√°s simple: el servicio se despertaba una vez por minuto, le√≠a la placa de tareas de un solo archivo (/ etc / lib / crontab) y realizaba para el superusuario las tareas que deber√≠an realizarse en el minuto actual . </p><br><p>  Posteriormente, las opciones avanzadas para un servicio simple y √∫til llegaron con todos los sistemas operativos tipo Unix. </p><br><p>  Las descripciones generalizadas del formato crontab y los principios b√°sicos de la utilidad en 1992 se incluyeron en el est√°ndar principal de los sistemas operativos tipo Unix, POSIX, y, por lo tanto, cron del est√°ndar de facto se convirti√≥ en el est√°ndar de jure. </p><br><p>  En 1987, Paul Vixie, despu√©s de entrevistar a los usuarios de Unix para obtener sugerencias para cron, lanz√≥ otra versi√≥n del demonio que soluciona algunos de los problemas del cron tradicional y extiende la sintaxis de los archivos de tabla. </p><br><p>  En la tercera versi√≥n, Vixie cron comenz√≥ a cumplir con los requisitos de POSIX, adem√°s, el programa ten√≠a una licencia liberal, o mejor dicho, no hab√≠a ninguna licencia, excepto por los deseos en README: el autor no da garant√≠as, no puede eliminar el nombre del autor y solo puede vender el programa con c√≥digo fuente  Estos requisitos resultaron ser compatibles con los principios del software libre, que estaba ganando popularidad en esos a√±os, por lo que algunas de las distribuciones clave de Linux que aparecieron a principios de los 90 tomaron Vixie cron como una distribuci√≥n del sistema y todav√≠a lo est√°n desarrollando. </p><br><p>  En particular, Red Hat y SUSE est√°n desarrollando Vixie cron - cronie fork, mientras que Debian y Ubuntu est√°n usando el cron original de Vixie con muchos parches. </p><br><p>  Primero, conozcamos la utilidad crontab definida por el usuario descrita en POSIX, despu√©s de lo cual analizaremos las extensiones de sintaxis introducidas en Vixie cron y el uso de variaciones de Vixie cron en distribuciones populares de Linux.  Y finalmente, la guinda del pastel es un an√°lisis del dispositivo cron daemon. </p><br><h1 id="posix-crontab">  Posix crontab </h1><br><p>  Si el cron original siempre funcion√≥ para el superusuario, los programadores modernos a menudo se ocupan de las tareas de los usuarios comunes, lo que es m√°s seguro y conveniente. </p><br><p>  Los Cron se env√≠an con un conjunto de dos programas: el demonio cron que se ejecuta constantemente y la utilidad crontab disponible para los usuarios.  Este √∫ltimo le permite editar tablas de tareas espec√≠ficas para cada usuario en el sistema, mientras que el demonio inicia tareas desde las tablas de usuario y del sistema. </p><br><p>  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√°ndar POSIX</a> no describe el comportamiento del demonio, y solo se formaliza el programa de usuario <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">crontab</a> .  La existencia de mecanismos para iniciar las tareas del usuario, por supuesto, est√° impl√≠cita, pero no se describe en detalle. </p><br><p>  Hay cuatro cosas que puede hacer con la utilidad crontab: editar la tabla de tareas del usuario en el editor, cargar la tabla desde el archivo, mostrar la tabla de tareas actual y borrar la tabla de tareas.  Ejemplos de la utilidad crontab: </p><br><pre><code class="plaintext hljs">crontab -e #    crontab -l #    crontab -r #    crontab path/to/file.crontab #     </code> </pre> <br><p>  Al llamar a <code>crontab -e</code> , se utilizar√° el editor especificado en la <code>EDITOR</code> entorno <code>EDITOR</code> est√°ndar. </p><br><p>  Las tareas mismas se describen en el siguiente formato: </p><br><pre> <code class="plaintext hljs"># -  # # ,   * * * * * /path/to/exec -a -b -c # ,   10-    10 * * * * /path/to/exec -a -b -c # ,   10-            10 2 * * * /path/to/exec -a -b -c &gt; /tmp/cron-job-output.log</code> </pre> <br><p>  Los primeros cinco campos de registro: minutos [1..60], horas [0..23], d√≠as del mes [1..31], meses [1..12], d√≠as de la semana [0..6], donde 0 - domingo  El √∫ltimo, sexto campo, es una cadena que ser√° ejecutada por el int√©rprete de comandos est√°ndar. </p><br><p>  En los primeros cinco campos, los valores se pueden enumerar con una coma: </p><br><pre> <code class="plaintext hljs"># ,         1,10 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  O a trav√©s de un gui√≥n: </p><br><pre> <code class="plaintext hljs"># ,          0-9 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  El acceso de los usuarios a la programaci√≥n de tareas est√° regulado en los archivos POSIX cron.allow y cron.deny que enumeran, respectivamente, los usuarios con acceso a crontab y los usuarios sin acceso al programa.  El est√°ndar no regula la ubicaci√≥n de estos archivos. </p><br><p>  Los programas en ejecuci√≥n, de acuerdo con el est√°ndar, deben pasar al menos cuatro variables de entorno: </p><br><ol><li>  HOME es el directorio de inicio del usuario. </li><li>  LOGNAME: inicio de sesi√≥n del usuario. </li><li>  RUTA es el camino por el cual encontrar las utilidades del sistema est√°ndar. </li><li>  SHELL es el camino hacia el shell utilizado. </li></ol><br><p>  Es de destacar que POSIX no dice nada acerca de d√≥nde provienen los valores para estas variables. </p><br><h1 id="hit-prodazh--vixie-cron-30pl1">  Bestseller - Vixie cron 3.0pl1 </h1><br><p>  El antecesor com√∫n de las variantes cron populares es Vixie cron 3.0pl1, presentado en la lista de correo comp.sources.unix de 1992.  Las caracter√≠sticas principales de esta versi√≥n las consideraremos con m√°s detalle. </p><br><p>  Vixie cron viene en dos programas (cron y crontab).  Como de costumbre, el daemon es responsable de leer e iniciar tareas desde la tabla de tareas del sistema y las tablas de tareas de usuarios individuales, y la utilidad crontab es responsable de editar las tablas de usuarios. </p><br><h3 id="tablica-zadach-i-fayly-konfiguracii">  Tabla de tareas y archivos de configuraci√≥n </h3><br><p>  La tabla de tareas del superusuario se encuentra en / etc / crontab.  La sintaxis de la tabla del sistema corresponde a la sintaxis de Vixie cron, ajustada por el hecho de que la sexta columna indica el nombre del usuario en nombre de qui√©n se inicia la tarea: </p><br><pre> <code class="plaintext hljs">#     vlad * * * * * vlad /path/to/exec</code> </pre> <br><p>  Las tablas de tareas de usuario comunes se encuentran en / var / cron / tabs / username y usan una sintaxis com√∫n.  Cuando se inicia la utilidad crontab, estos archivos se editan en nombre del usuario. </p><br><p>  Las listas de usuarios con acceso a crontab se administran en los archivos / var / cron / allow y / var / cron / deny, donde es suficiente agregar el nombre de usuario como una l√≠nea separada. </p><br><h3 id="rasshirennyy-sintaksis">  Sintaxis Extendida </h3><br><p>  En comparaci√≥n con el crontab POSIX, la soluci√≥n de Paul Vixie contiene varias modificaciones muy √∫tiles a la sintaxis de la tabla de tareas de la utilidad. </p><br><p>  Se ha puesto a disposici√≥n una nueva sintaxis de tabla: por ejemplo, puede especificar los d√≠as de la semana o los meses por nombre (lunes, martes, etc.): </p><br><pre> <code class="plaintext hljs">#         * * * Jan Mon,Tue /path/to/exec</code> </pre> <br><p>  Puede especificar el paso a trav√©s del cual se inician las tareas: </p><br><pre> <code class="plaintext hljs">#       */2 * * * Mon,Tue /path/to/exec</code> </pre> <br><p>  Los pasos e intervalos se pueden mezclar: </p><br><pre> <code class="plaintext hljs">#             0-10/2 * * * * /path/to/exec</code> </pre> <br><p>  Se admiten alternativas intuitivas a la sintaxis regular (reinicio, anual, anual, mensual, semanal, diario, medianoche, por hora): </p><br><pre> <code class="plaintext hljs">#     @reboot /exec/on/reboot #     @daily /exec/daily #     @hourly /exec/daily</code> </pre> <br><h3 id="sreda-vypolneniya-zadach">  Entorno de ejecuci√≥n de tareas </h3><br><p>  Vixie cron le permite cambiar el entorno de las aplicaciones en ejecuci√≥n. </p><br><p>  Las variables de entorno USER, LOGNAME y HOME no solo las proporciona el daemon, sino que se toman del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivo passwd</a> .  La variable PATH obtiene el valor "/ usr / bin: / bin", y SHELL obtiene el valor "/ bin / sh".  Los valores de todas las variables excepto LOGNAME se pueden cambiar en las tablas de usuario. </p><br><p>  El mismo cron utiliza algunas variables de entorno (principalmente SHELL y HOME) para ejecutar la tarea.  As√≠ es como se ver√≠a usar bash en lugar de sh est√°ndar para ejecutar tareas personalizadas: </p><br><pre> <code class="plaintext hljs">SHELL=/bin/bash HOME=/tmp/ # exec   bash-  /tmp/ * * * * * /path/to/exec</code> </pre> <br><p>  En √∫ltima instancia, todas las variables de entorno definidas en la tabla (utilizadas por cron o necesarias para el proceso) se transferir√°n a la tarea en ejecuci√≥n. </p><br><p>  La utilidad crontab utiliza el editor especificado en la variable de entorno VISUAL o EDITOR para editar archivos.  Si estas variables no est√°n definidas en el entorno donde se lanz√≥ crontab, entonces se usa "/ usr / ucb / vi" (ucb es probablemente la Universidad de California, Berkeley). </p><br><h1 id="cron-v-debian-i-ubuntu">  cron en Debian y Ubuntu </h1><br><p>  Los desarrolladores de Debian y derivados han lanzado una versi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">altamente modificada</a> de Vixie cron versi√≥n 3.0pl1.  No hay diferencias en la sintaxis de los archivos de tabla; para los usuarios, este es el mismo cron de Vixie.  Nuevas caracter√≠sticas m√°s importantes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">syslog</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SELinux</a> y soporte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PAM</a> . </p><br><p>  De los cambios menos notables, pero tangibles: la ubicaci√≥n de los archivos de configuraci√≥n y las tablas de tareas. </p><br><p>  Las tablas de usuarios en Debian se encuentran en el directorio / var / spool / cron / crontabs, la tabla del sistema todav√≠a est√° en / etc / crontab.  Las tablas de tareas espec√≠ficas de Debian se colocan en /etc/cron.d, desde donde el cron daemon las lee autom√°ticamente.  El control de acceso del usuario est√° regulado por los archivos /etc/cron.allow y /etc/cron.deny. </p><br><p>  El shell / bin / sh predeterminado todav√≠a se usa como el shell predeterminado. Debian reproduce un peque√±o shell de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tablero</a> compatible con POSIX que se ejecuta sin leer ninguna configuraci√≥n (en modo no interactivo). </p><br><p>  Cron en las √∫ltimas versiones de Debian se inicia a trav√©s de systemd, y la configuraci√≥n de inicio se puede ver en /lib/systemd/system/cron.service.  No hay nada especial en la configuraci√≥n del servicio; cualquier gesti√≥n de tareas m√°s fina se puede hacer a trav√©s de variables de entorno declaradas directamente en el crontab de cada usuario. </p><br><h1 id="cronie-v-redhat-fedora-i-centos">  cronie en RedHat, Fedora y CentOS </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cronie</a> - fork de Vixie cron versi√≥n 4.1.  Al igual que en Debian, la sintaxis no cambi√≥, pero se agreg√≥ soporte para PAM y SELinux, trabajando en un cl√∫ster, rastreando archivos usando inotify y otras caracter√≠sticas. </p><br><p>  La configuraci√≥n predeterminada est√° en los lugares habituales: la tabla del sistema est√° en / etc / crontab, los paquetes colocan sus tablas en /etc/cron.d, las tablas de usuario se encuentran en / var / spool / cron / crontabs. </p><br><p>  El daemon se ejecuta en systemd, la configuraci√≥n del servicio es /lib/systemd/system/crond.service. </p><br><p>  En el inicio, las distribuciones similares a Red Hat usan / bin / sh de manera predeterminada, cuya funci√≥n es bash est√°ndar.  Cabe se√±alar que cuando se ejecutan tareas cron a trav√©s de / bin / sh, el shell bash se inicia en modo compatible con POSIX y no lee ninguna configuraci√≥n adicional cuando se opera en modo no interactivo. </p><br><h1 id="cronie-v-sles-i-opensuse">  compinche en SLES y openSUSE </h1><br><p>  La distribuci√≥n alemana SLES y su derivada openSUSE usan el mismo compinche.  El demonio aqu√≠ tambi√©n se ejecuta en systemd, la configuraci√≥n del servicio est√° en /usr/lib/systemd/system/cron.service.  Configuraci√≥n: / etc / crontab, /etc/cron.d, / var / spool / cron / tabs.  Como / bin / sh act√∫a el mismo bash, lanzado en modo no interactivo compatible con POSIX. </p><br><h1 id="ustroystvo-vixie-cron">  Dispositivo cron Vixie </h1><br><p>  Los descendientes modernos de cron no han cambiado radicalmente en comparaci√≥n con Vixie cron, pero sin embargo, han adquirido nuevas capacidades que no se requieren para comprender los principios del programa.  Muchas de estas extensiones son desordenadas y confunden el c√≥digo.  Es un placer leer el c√≥digo fuente original de cron de Paul Vixie. </p><br><p>  Por lo tanto, decid√≠ analizar el dispositivo cron utilizando el ejemplo de un programa com√∫n para ambas ramas del desarrollo cron: Vixie cron 3.0pl1.  Simplificar√© los ejemplos eliminando ifdefs que complican la lectura y omitiendo los detalles secundarios. </p><br><p>  El trabajo del demonio se puede dividir en varias etapas: </p><br><ol><li>  Inicializaci√≥n del programa. </li><li>  Recopile y actualice la lista de tareas para ejecutar. </li><li>  La operaci√≥n principal del ciclo cron. </li><li>  Lanzamiento de tarea. </li></ol><br><p>  Vamos a ordenarlos en orden. </p><br><h3 id="inicializaciya">  Inicializaci√≥n </h3><br><p>  Cuando se inicia, despu√©s de verificar los argumentos del proceso, cron instala los manejadores de se√±al SIGCHLD y SIGHUP.  El primero registra la finalizaci√≥n del proceso secundario, el segundo cierra el descriptor de archivo del archivo de registro: </p><br><pre> <code class="cpp hljs">signal(SIGCHLD, sigchld_handler); signal(SIGHUP, sighup_handler);</code> </pre> <br><p>  El demonio cron en el sistema siempre funciona solo, solo como superusuario y desde el directorio principal cron.  Las siguientes llamadas crean un bloqueo de archivo con el PID del proceso del daemon, aseg√∫rese de que el usuario sea correcto y cambie el directorio actual al directorio principal: </p><br><pre> <code class="cpp hljs">acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); set_cron_uid(); set_cron_cwd();</code> </pre> <br><p>  Se establece la ruta predeterminada, que se utilizar√° al iniciar los procesos: </p><br><pre> <code class="cpp hljs">setenv(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, _PATH_DEFPATH, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Luego, el proceso se "demoniza": crea una copia secundaria del proceso llamando a fork y una nueva sesi√≥n en el proceso secundario (llamando a setsid).  Ya no hay necesidad del proceso padre, y completa el trabajo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> _exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><p>  La finalizaci√≥n del proceso principal libera el bloqueo en el archivo de bloqueo.  Adem√°s, debe actualizar el PID en el archivo para el ni√±o.  Despu√©s de eso, se llena la base de datos de tareas: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> database.head = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.tail = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.mtime = (<span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; load_database(&amp;database);</code> </pre> <br><p>  M√°s cron procede al ciclo de trabajo principal.  Pero antes de eso, eche un vistazo a cargar la lista de tareas. </p><br><h3 id="sbor-i-obnovlenie-spiska-zadach">  Recopilar y actualizar la lista de tareas </h3><br><p>  La funci√≥n load_database es responsable de cargar la lista de tareas.  Comprueba el crontab del sistema principal y el directorio con archivos de usuario.  Si los archivos y el directorio no han cambiado, la lista de tareas no se vuelve a leer.  De lo contrario, comienza a formarse una nueva lista de tareas. </p><br><p>  Descargar un archivo del sistema con nombres especiales de archivos y tablas: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syscron_stat.st_mtime) { process_crontab(<span class="hljs-string"><span class="hljs-string">"root"</span></span>, <span class="hljs-string"><span class="hljs-string">"*system*"</span></span>, SYSCRONTAB, &amp;syscron_stat, &amp;new_db, old_db); }</code> </pre> <br><p>  Carga de tablas de usuario en un bucle: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != (dp = readdir(dir))) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>], tabname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dp-&gt;d_name[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(fname, dp-&gt;d_name); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(tabname, CRON_TAB(fname)); process_crontab(fname, fname, tabname, &amp;statbuf, &amp;new_db, old_db); }</code> </pre><br><p>  Luego, la base de datos anterior se reemplaza por una nueva. </p><br><p>  En los ejemplos anteriores, llamar a la funci√≥n process_crontab asegura que exista el usuario que coincida con el nombre del archivo de la tabla (a menos que sea el superusuario) y luego llama a load_user.  Este √∫ltimo ya lee el archivo en s√≠ l√≠nea por l√≠nea: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((status = load_env(envstr, file)) &gt;= OK) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ERR: free_user(u); u = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> done; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: e = load_entry(file, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, pw, envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e) { e-&gt;next = u-&gt;crontab; u-&gt;crontab = e; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: envp = env_set(envp, envstr); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><p>  Aqu√≠, las funciones load_env / env_set establecen la variable de entorno (l√≠neas de la forma VAR = valor), o la funci√≥n load_entry lee la descripci√≥n de la tarea (* * * * * / path / to / exec). </p><br><p>  La entidad de entrada devuelta por load_entry es nuestra tarea ubicada en la lista general de tareas.  En la funci√≥n en s√≠, se realiza un largo an√°lisis del formato de tiempo, pero estamos m√°s interesados ‚Äã‚Äãen la formaci√≥n de variables de entorno y par√°metros de inicio de tareas: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*         passwd*/</span></span> e-&gt;uid = pw-&gt;pw_uid; e-&gt;gid = pw-&gt;pw_gid; <span class="hljs-comment"><span class="hljs-comment">/*    (/bin/sh),      */</span></span> e-&gt;envp = env_copy(envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"SHELL=%s"</span></span>, _PATH_BSHELL); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"HOME=%s"</span></span>, pw-&gt;pw_dir); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"PATH=%s"</span></span>, _PATH_DEFPATH); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     passwd */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"%s=%s"</span></span>, <span class="hljs-string"><span class="hljs-string">"LOGNAME"</span></span>, pw-&gt;pw_name); e-&gt;envp = env_set(e-&gt;envp, envstr);</code> </pre> <br><p>  El ciclo principal tambi√©n funciona con la lista actual de tareas. </p><br><h3 id="glavnyy-cikl">  Ciclo principal </h3><br><p>  El cron original de la versi√≥n 7 de Unix funcion√≥ de manera bastante simple: en un ciclo volv√≠ a leer la configuraci√≥n, ejecut√© las tareas del minuto actual como superusuario y dorm√≠ hasta el comienzo del siguiente minuto.  Este enfoque simple en m√°quinas antiguas requer√≠a demasiados recursos. </p><br><p>  Se propuso una versi√≥n alternativa en SysV, en la que el demonio se durmi√≥ hasta el siguiente minuto, para el cual se defini√≥ la tarea, o durante 30 minutos.  Los recursos para releer la configuraci√≥n y verificar las tareas en este modo se consumieron menos, pero se volvi√≥ inconveniente actualizar r√°pidamente la lista de tareas. </p><br><p>  Vixie cron volvi√≥ a revisar las listas de tareas una vez por minuto, ya que a fines de los a√±os 80 los recursos en m√°quinas Unix est√°ndar se hab√≠an vuelto mucho m√°s grandes: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  ,       */</span></span> run_reboot_jobs(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime    */</span></span> cron_sync(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (TRUE) { <span class="hljs-comment"><span class="hljs-comment">/*  ,     TargetTime    ,    */</span></span> cron_sleep(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> cron_tick(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime     */</span></span> TargetTime += <span class="hljs-number"><span class="hljs-number">60</span></span>; }</code> </pre><br><p>  La funci√≥n cron_sleep, que llama a las funciones job_runqueue (enumeraci√≥n e inicio de tareas) y do_command (inicio de cada tarea individual), participa directamente en la realizaci√≥n de tareas.  La √∫ltima funci√≥n debe considerarse con m√°s detalle. </p><br><h3 id="zapusk-zadachi">  Lanzamiento de tarea </h3><br><p>  La funci√≥n do_command se ejecuta en un buen estilo Unix, es decir, se bifurca para la ejecuci√≥n asincr√≥nica de tareas.  El proceso padre contin√∫a lanzando tareas, el proceso hijo est√° preparando el proceso de la tarea: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   fork */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*  :          */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> child_process(e, u); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> _exit(OK_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  Hay mucha l√≥gica en child_process: toma la salida est√°ndar y el error fluye sobre s√≠ mismo, para que luego se pueda enviar por correo (si la variable de entorno MAILTO se especifica en la tabla de tareas) y, finalmente, espera a que se complete el proceso de la tarea principal. </p><br><p>  El proceso de la tarea est√° formado por otra bifurcaci√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (vfork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(ERROR_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* -   ,   .. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-comment"><span class="hljs-comment">/* *     ,    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  ,    , *       */</span></span> setgid(e-&gt;gid); setuid(e-&gt;uid); chdir(env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*   SHELL      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *shell = env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*       , *    ,       */</span></span> execle(shell, shell, <span class="hljs-string"><span class="hljs-string">"-c"</span></span>, e-&gt;cmd, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*  ‚Äî    ?   */</span></span> perror(<span class="hljs-string"><span class="hljs-string">"execl"</span></span>); _exit(ERROR_EXIT); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    :      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  Aqu√≠, en general, y todo el cron.  Omit√≠ algunos detalles interesantes, por ejemplo, la contabilidad de usuarios remotos, pero describ√≠ lo principal. </p><br><h1 id="posleslovie">  Ep√≠logo </h1><br><p>  Cron es un programa sorprendentemente simple y √∫til, hecho en las mejores tradiciones del mundo Unix.  Ella no hace nada superfluo, pero ha estado haciendo su trabajo notablemente durante las √∫ltimas d√©cadas.  Conocer el c√≥digo de la versi√≥n que viene con Ubuntu no tard√≥ m√°s de una hora, ¬°y me divert√≠ mucho!  Espero poder compartirlo contigo. </p><br><p>  No s√© sobre ti, pero es un poco triste para m√≠ darme cuenta de que la programaci√≥n moderna, con su tendencia a complicarse y abstraerse, ha dejado de tener tanta simplicidad. </p><br><p>  Hay muchas alternativas modernas para cron: systemd-timers le permite organizar sistemas complejos con dependencias, en fcron puede controlar de manera m√°s flexible el consumo de recursos por tareas.  Pero personalmente, siempre he tenido el crontab m√°s simple. </p><br><p>  En una palabra, ¬°ama Unix, usa programas simples y no te olvides de leer man√° para tu plataforma! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468061/">https://habr.com/ru/post/468061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468049/index.html">Uso de werf para desplegar gr√°ficos complejos de Helm</a></li>
<li><a href="../468051/index.html">VDS con Windows Server con licencia por 100 rublos: ¬ømito o realidad?</a></li>
<li><a href="../468053/index.html">Aprendizaje autom√°tico para su caza plana. Parte 1</a></li>
<li><a href="../468057/index.html">Desarrollo de sistema operativo tipo Unix: multitarea y llamadas al sistema (7)</a></li>
<li><a href="../468059/index.html">Mi segunda semana con Haiku: muchos diamantes escondidos y sorpresas agradables, as√≠ como algunos problemas</a></li>
<li><a href="../468063/index.html">Angulareact</a></li>
<li><a href="../468065/index.html">Modelos de gesti√≥n mental de productos para todos</a></li>
<li><a href="../468067/index.html">C√≥mo funciona la composici√≥n alfa</a></li>
<li><a href="../468071/index.html">Eduard Medvedev, CTO de Tungsten Labs: "Hemos crecido hasta el punto en que la tecnolog√≠a puede causar da√±os masivos"</a></li>
<li><a href="../468073/index.html">Andrei Terekhov: "Puedes decir todo lo que quieras que el estadounidense es mejor, pero nuestro auto nunca se descompone"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>