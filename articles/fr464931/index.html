<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöó ü§≥üèº üë©üèæ‚Äçüé§ Assembleur ins√®re ... en C #? üïô üéí ü§∂üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Donc, cette histoire a commenc√© avec une co√Øncidence de trois facteurs. Je: 



1. √©crit principalement en C #; 
2. seulement imagin√© grossi√®rement co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assembleur ins√®re ... en C #?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464931/">  Donc, cette histoire a commenc√© avec une co√Øncidence de trois facteurs.  Je: <br><br><ol><li>  √©crit principalement en C #; </li><li>  seulement imagin√© grossi√®rement comment il est organis√© et fonctionne; </li><li>  s'est int√©ress√© √† l'assembleur. </li></ol><br>  Ce m√©lange apparemment innocent a donn√© lieu √† une id√©e √©trange: est-il possible de combiner d'une mani√®re ou d'une autre ces langues?  Ajoutez en C # la possibilit√© de faire des insertions d'assembleur, un peu comme en C ++. <br><br>  Si vous √™tes int√©ress√© par les cons√©quences que cela a entra√Æn√©, bienvenue chez cat. <br><br> <a href=""><img src="https://habrastorage.org/webt/u-/sg/dk/u-sgdkb-3zwyqg682kuh2vvv1vq.png"></a> <br><a name="habracut"></a><br><h2>  Premi√®res difficult√©s </h2><br>  M√™me √† ce moment-l√†, j'ai r√©alis√© qu'il est tr√®s peu probable qu'il existe des outils standard pour appeler du code assembleur √† partir de code C # - cela contredit trop l'un des concepts importants du langage: la s√©curit√© de la m√©moire.  Apr√®s une √©tude superficielle de la question (qui, entre autres, a confirm√© le pressentiment initial - ¬´hors de la bo√Æte¬ª, il n'y a pas une telle possibilit√©), il est devenu clair qu'en plus du probl√®me id√©ologique, il y a un probl√®me purement technique: C #, comme vous le savez, est compil√© dans un bytecode interm√©diaire, qui interpr√©t√© par la machine virtuelle CLR.  Et c'est pr√©cis√©ment ici que nous sommes confront√©s au probl√®me m√™me: d'une part, le compilateur (ci-apr√®s je parlerai de Roslyn de Microsoft, car il est de facto la norme dans le domaine des compilateurs C #), √©videmment, ne peut pas reconna√Ætre et traduire les commandes assembleur d'une vue texte en une repr√©sentation binaire, ce qui signifie que nous devons utiliser les instructions de la machine directement sous leur forme binaire en tant qu'insert, et d'autre part, la machine virtuelle a son propre bytecode et ne peut pas reconna√Ætre et ex√©cuter cela  commandes group√©es que nous lui offrir. <br><br>  La solution th√©orique √† ce probl√®me est √©vidente - vous devez vous assurer que le code d'insertion binaire est ex√©cut√© par le processeur, en contournant l'interpr√©tation de la machine virtuelle.  La chose la plus simple qui me vient √† l'esprit est de stocker le code binaire sous la forme d'un tableau d'octets, vers lequel le contr√¥le sera en quelque sorte transf√©r√© au bon moment.  De l√† se profile la premi√®re t√¢che: vous devez trouver un moyen de transf√©rer le contr√¥le √† ce qui est contenu dans une zone de m√©moire arbitraire. <br><br><h2>  Premier prototype: ¬´appeler¬ª un tableau </h2><br>  Cette t√¢che est peut-√™tre l'obstacle le plus s√©rieux aux encarts.  En utilisant les outils de langage, il est facile d'obtenir un pointeur vers notre tableau, mais dans le monde C #, les pointeurs n'existent que sur les donn√©es et il est impossible de le transformer en un pointeur vers, disons, une fonction pour qu'elle puisse √™tre appel√©e plus tard (enfin, ou du moins je ne pouvais pas comprendre comment √† faire). <br><br>  Heureusement (ou malheureusement), rien n'est nouveau sous la lune et une recherche rapide dans Yandex pour les mots "C #" et "assembleur inserts" m'a conduit √† un article dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">num√©ro de d√©cembre 2007 du magazine]] [Aker]</a> .  Ayant honn√™tement copi√© la fonction √† partir de l√† et l‚Äôayant adapt√©e √† mes besoins, j‚Äôai <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualProtect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flNewProtect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpflOldProtect</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* InvokeAsm(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* firstAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* secondAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] code) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;i; p += <span class="hljs-number"><span class="hljs-number">0x14</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; i = *p; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* b = code) { *p = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)b; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> prev; VirtualProtect((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)b, (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)code.Length, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, &amp;prev); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)i; }</code> </pre> <br>  L'id√©e principale de ce code est de remplacer l'adresse de retour de la fonction <code>InvokeAsm()</code> sur la pile par l'adresse du tableau d'octets vers lequel vous souhaitez transf√©rer le contr√¥le.  Ensuite, apr√®s avoir quitt√© la fonction, au lieu de continuer l'ex√©cution du programme, l'ex√©cution de notre code binaire commencera. <br><br>  Nous traiterons plus en d√©tail de la magie qui <code>InvokeAsm()</code> dans <code>InvokeAsm()</code> .  Tout d'abord, nous d√©clarons une variable locale, qui, bien s√ªr, appara√Æt sur la pile, puis nous obtenons son adresse (obtenant ainsi l'adresse du haut de la pile).  Ensuite, nous y ajoutons une certaine constante magique obtenue en calculant minutieusement dans le d√©bogueur le d√©calage de l'adresse de retour par rapport au haut de la pile, sauvegardons l'adresse de retour et √©crivez plut√¥t l'adresse de notre tableau d'octets.  La signification sacr√©e de l'enregistrement de l'adresse de retour est √©vidente - nous devons continuer √† ex√©cuter le programme apr√®s notre insertion, ce qui signifie que nous devons savoir o√π transf√©rer le contr√¥le apr√®s.  Vient ensuite l'appel √† la fonction WinAPI √† partir de la biblioth√®que kernel32.dll - <code>VirtualProtect()</code> .  Il est n√©cessaire pour changer les attributs de la page m√©moire sur laquelle se trouve le code d'insertion.  Bien s√ªr, lors de la compilation du programme, il appara√Æt dans la section des donn√©es et la page m√©moire correspondante a un acc√®s en lecture et en √©criture.  Nous devons √©galement ajouter la permission d'ex√©cuter son contenu.  Enfin, nous renvoyons l'adresse de retour r√©elle stock√©e.  Bien s√ªr, cette adresse ne sera pas retourn√©e au code qui a appel√© <code>InvokeAsm()</code> , car  ex√©cution imm√©diatement apr√®s le <code>return (void*)i;</code>  "√âchec" dans l'encart.  Cependant, les conventions d'appel utilis√©es par la machine virtuelle (stdcall avec optimisation d√©sactiv√©e et fastcall avec activ√©) signifient renvoyer la valeur via le registre EAX, c'est-√†-dire  pour revenir de l'insert, nous devons suivre deux instructions: <code>push eax</code> (code 0x50) et <code>ret</code> (code 0xC3). <br><br><div class="spoiler">  <b class="spoiler_title">Clarification</b> <div class="spoiler_text">  √Ä l'avenir, nous parlerons de l'architecture de x86 (ou plut√¥t de IA-32) - ringard du fait qu'√† cette √©poque, je le connaissais au moins d'une mani√®re ou d'une autre, contrairement, disons, √† x86-64.  Cependant, la m√©thode de transfert de contr√¥le d√©crite ci-dessus devrait fonctionner pour le code 64 bits. <br></div></div><br>  Enfin, vous devez faire attention √† deux arguments inutilis√©s: <code>void* firstAsmArg</code> et <code>void* secondAsmArg</code> .  Ils sont n√©cessaires pour transf√©rer des donn√©es utilisateur arbitraires vers l'insert d'assembleur.  Ces arguments seront situ√©s soit √† un endroit connu de la pile (stdcall), soit, l√† encore, dans des registres bien connus (fastcall). <br><br><div class="spoiler">  <b class="spoiler_title">Un peu d'optimisation</b> <div class="spoiler_text">  Puisque, du point de vue du compilateur, ce qui se passe dans le code, ne comprend pas quoi, il peut par inadvertance lancer un appel fondamentalement important / ajouter quelque chose en ligne / ne pas sauvegarder un argument "inutilis√©" / interf√©rer d'une mani√®re ou d'une autre avec la mise en ≈ìuvre de notre plan.  Ceci est partiellement r√©solu par l' <code>[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]</code> , cependant, m√™me de telles pr√©cautions ne donnent pas l'effet souhait√©: par exemple, la variable locale <code>i</code> , qui est la cl√© de toute la fonction, se r√©v√®le soudainement √™tre un registre, ce qui g√¢che √©videmment tout .  Par cons√©quent, afin d'√©liminer compl√®tement la probabilit√© que quelque chose se passe mal, vous devez cr√©er une biblioth√®que avec l'optimisation d√©sactiv√©e (d√©sactivez-la dans les propri√©t√©s du projet ou utilisez la configuration de d√©bogage).  Par cons√©quent, stdcall sera utilis√©, donc √† l'avenir je proc√©derai de cette convention d'appel. <br></div></div><br><h2>  Am√©liorations </h2><br><h3>  La s√©curit√© vaut mieux que l'ins√©curit√© </h3><br>  Bien s√ªr, il n'est pas question de s√©curit√© (au sens o√π ce mot est utilis√© en C #).  Cependant, la m√©thode <code>InvokeAsm()</code> d√©crite ci-dessus fonctionne sur des pointeurs, ce qui signifie qu'elle ne peut √™tre appel√©e qu'√† partir du bloc marqu√© avec le mot-cl√© <code>unsafe</code> , ce qui n'est pas toujours pratique - au moins elle n√©cessite une compilation avec le commutateur / unsafe (ou la coche correspondante dans les propri√©t√©s du projet dans VS).  Par cons√©quent, il semble logique de fournir un shell qui fonctionne au moins IntPtr (au pire), et id√©alement, il permet √† l'utilisateur de sp√©cifier les types √† transmettre et √† renvoyer.  Eh bien, √ßa sonne comme g√©n√©rique, on √©crit g√©n√©rique, qu'est-ce qu'il y a d'autre, on demande, de parler?  En fait - il y a quelque chose. <br><br>  Le plus √©vident: comment obtenir un pointeur sur un argument dont le type est inconnu?  Les constructions de type <code>T* ptr = &amp;arg</code> ne <code>T* ptr = &amp;arg</code> pas autoris√©es en C # et, en g√©n√©ral, il n'est pas difficile de comprendre la raison: l'utilisateur peut bien utiliser l'un des types g√©r√©s comme param√®tre de type, un pointeur vers lequel ne peut pas √™tre obtenu.  La solution pourrait √™tre de limiter un param√®tre de type <code>unmanaged</code> , mais, premi√®rement, il n'appara√Æt qu'en C # 7.3, et deuxi√®mement, il ne permet pas de passer des cha√Ænes et des tableaux comme arguments, bien que l'op√©rateur <code>fixed</code> permette de les utiliser (nous obtenons le pointeur vers le premier caract√®re ou √©l√©ment de tableau, respectivement).  Eh bien, en plus, je voudrais donner √† l'utilisateur la possibilit√© d'op√©rer, y compris les types contr√¥l√©s - puisque nous avons commenc√© √† violer les r√®gles de la langue, nous les violerons jusqu'√† la fin! <br><br><h3>  Obtention d'un pointeur vers un objet g√©r√© et un objet par pointeur </h3><br>  Et encore une fois, apr√®s des d√©lib√©rations peu fructueuses, j'ai commenc√© √† chercher les solutions finales.  Cette fois, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur Habr√©</a> m'a aid√©.  En bref, l'une des m√©thodes propos√©es consiste √† √©crire une biblioth√®que auxiliaire, et non pas en C #, mais directement en IL.  Sa t√¢che consiste √† pousser un objet (en fait une r√©f√©rence √† l'objet) sur la pile de la machine virtuelle, pass√© en argument, puis √† r√©cup√©rer quelque chose d'autre dans la pile - par exemple, un nombre ou <code>IntPtr</code> .  En effectuant les m√™mes √©tapes dans l'ordre inverse, vous pouvez convertir le pointeur (par exemple, renvoy√© par l'insert d'assembleur) en objet.  Cette m√©thode est bonne car tout ce qui se passe est clair et transparent.  Mais il y a un inconv√©nient: je voulais m'en sortir avec le moins de fichiers possible, donc au lieu d'√©crire une biblioth√®que s√©par√©e, j'ai d√©cid√© d'incorporer le code IL dans la principale.  La seule fa√ßon que j'ai trouv√©e est d'√©crire des m√©thodes de stub en C #, de construire le projet, de d√©sassembler le binaire en utilisant ildasm, de r√©√©crire le code des m√©thodes de stub et de tout remettre ensemble avec ilasm.  Ce sont quelques actions suppl√©mentaires, et √©tant donn√© que vous devez les faire √† chaque fois que vous les construisez apr√®s avoir apport√© des modifications au code ... En g√©n√©ral, je m'en suis lass√© assez rapidement et j'ai commenc√© √† chercher des alternatives. <br><br>  √Ä ce moment-l√†, un merveilleux livre est tomb√© entre mes mains, gr√¢ce auquel j'ai beaucoup appris par moi-m√™me - ¬´CLR via C #¬ª de Jeffrey Richter.  Dans ce document, quelque part autour du vingti√®me chapitre, nous avons parl√© de la structure <code>GCHandle</code> , qui a une m√©thode <code>Alloc()</code> qui prend un objet et l'un des <code>GCHandleType</code> √©num√©ration <code>GCHandleType</code> .  Donc, si vous appelez cette m√©thode en lui passant l'objet souhait√© et <code>GCHandle.Pinned</code> , vous pouvez obtenir l'adresse de cet objet en m√©moire.  De plus, avant d'appeler <code>GCHandle.Free()</code> objet est fixe, c'est-√†-dire  enti√®rement prot√©g√© contre les effets du ramasse-miettes.  Cependant, il y a certains probl√®mes.  Tout d'abord, <code>GCHandle</code> n'aide en aucune fa√ßon √† terminer la conversion ¬´pointeur ‚Üí objet¬ª, seulement ¬´objet ‚Üí pointeur¬ª.  Plus important encore, pour utiliser <code>GCHandleType.Pinned</code> classe ou la structure de l'objet dont nous voulons obtenir l'adresse doit avoir l' <code>[StructLayout(LayoutKind.Sequential)]</code> , tandis que <code>LayoutKind.Auto</code> utilis√© par <code>LayoutKind.Auto</code> .  Cette m√©thode ne convient donc que pour certains types standard et pour les types personnalis√©s qui ont √©t√© initialement con√ßus dans cet esprit.  Pas exactement la m√©thode universelle que nous aimerions trouver, non? <br><br>  Eh bien, essayez encore.  <code>__makeref()</code> maintenant attention √† deux fonctions non document√©es, qui sont n√©anmoins prises en charge par Roslyn: <code>__makeref()</code> et <code>__refvalue()</code> .  Le premier prend un objet et retourne une instance de la structure <code>TypedReference</code> qui stocke une r√©f√©rence √† l'objet et √† son type, tandis que le second extrait l'objet de l'instance <code>typedReference</code> transmise.  Pourquoi ces fonctionnalit√©s sont-elles importantes pour nous?  Parce que <code>TypedReference</code> est une structure!  Dans le contexte de la discussion, cela signifie que nous pouvons obtenir un pointeur vers celui-ci, qui, en combinaison, sera un pointeur vers le premier champ de cette structure.  √Ä savoir, il stocke le lien m√™me avec l'objet qui nous int√©resse.  Ensuite, pour obtenir un pointeur sur un objet g√©r√©, nous devons lire la valeur par un pointeur sur ce que <code>__makeref()</code> renverra et le convertir en pointeur.  Pour obtenir un objet par pointeur, vous devez appeler <code>__makeref()</code> partir d'un objet conditionnellement vide du type requis, obtenir un pointeur sur l'instance <code>TypedReference</code> retourn√©e, √©crire un pointeur sur l'objet dessus, puis appeler <code>__refvalue()</code> .  Le r√©sultat est quelque chose comme ce code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Tout ToInstance&lt;Tout&gt;(IntPtr ptr) { Tout temp = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; TypedReference tr = __makeref(temp); Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr); Tout instance = __refvalue(tr, Tout); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ToPointer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).IsValueType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;tr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> **(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>***)&amp;tr; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  Revenant √† la t√¢che d'√©crire un wrapper s√ªr pour <code>InvokeAsm()</code> , il convient de noter que la m√©thode d'obtention de pointeurs √† l'aide de <code>__makeref()</code> et <code>__refvalue()</code> , contrairement √† l'utilisation de <code>GCHandle.Alloc(GCHandleType.Pinned)</code> , ne garantit pas que notre garbage collector est nulle part l'objet ne bougera pas.  Par cons√©quent, l'encapsuleur doit commencer par d√©sactiver le garbage collector et se terminer par la restauration de ses fonctionnalit√©s.  La solution est plut√¥t grossi√®re, mais efficace. <br></div></div><br><h2>  Pour ceux qui ne se souviennent pas des opcodes </h2><br>  Nous avons donc appris √† appeler du code binaire, appris √† transmettre non seulement des valeurs imm√©diates, mais aussi des pointeurs vers n'importe quoi comme arguments ... Il n'y a qu'un seul probl√®me.  O√π obtenir le m√™me code binaire?  Vous pouvez vous armer d'un crayon, d'un bloc-notes et d'une table d'opcode (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">celui-ci</a> ) ou prendre un √©diteur hexad√©cimal avec le support de l'assembleur x86 ou m√™me un traducteur √† part enti√®re, mais toutes ces options signifient que l'utilisateur devra utiliser autre chose que la biblioth√®que.  Ce n'√©tait pas tout √† fait ce que je voulais, j'ai donc d√©cid√© d'inclure mon traducteur dans la biblioth√®que, qui √©tait traditionnellement appel√©e SASM (abr√©viation de Stack Assembler; cela n'a rien √† voir avec l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IDE</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">Clause de non-responsabilit√©</b> <div class="spoiler_text">  Je ne suis pas bon pour analyser les cha√Ænes, donc le code du traducteur ... enfin, imparfait, c'est le moins qu'on puisse dire.  De plus, je ne suis pas fort dans les expressions r√©guli√®res, donc elles ne sont pas l√†.  Et en g√©n√©ral - un analyseur it√©ratif. <br></div></div><br>  Je ne vais probablement pas parler du processus de cr√©ation de ce "miracle" - il n'y a rien d'int√©ressant dans cette histoire, mais je vais d√©crire bri√®vement les principales caract√©ristiques.  La plupart des instructions x86 sont actuellement prises en charge.  Les instructions math√©matiques du coprocesseur pour travailler avec des nombres √† virgule flottante et √† partir d'extensions (MMX, SSE, AVX) ne sont pas encore prises en charge.  Il est possible de d√©clarer des constantes, des proc√©dures, des variables de pile locales, des variables globales, dont la m√©moire est allou√©e lors de la traduction directement dans un tableau avec du code binaire (si ces variables sont nomm√©es √† l'aide d'√©tiquettes, leur valeur peut √©galement √™tre obtenue √† partir de C # apr√®s avoir effectu√© l'insertion en appelant des m√©thodes <code>GetBYTEVariable()</code> , <code>GetWORDVariable()</code> , <code>GetDWORDVariable()</code> , <code>GetAStringVariable()</code> et <code>GetWStringVariable()</code> de l'objet <code>SASMCode</code> ), des macros <code>addr</code> et <code>invoke</code> sont pr√©sentes.  L'une des fonctionnalit√©s importantes est la prise en charge de l'importation de fonctions √† partir de biblioth√®ques externes √† l'aide de la construction <code>extern &lt; &gt; lib &lt; &gt;</code> . <br><br>  <code>asmret</code> macro <code>asmret</code> m√©rite un paragraphe s√©par√©.  En cours de traduction, il se d√©roule en 11 instructions formant l'√©pilogue.  Le prologue est ajout√© par d√©faut au d√©but du code traduit.  Leur t√¢che consiste √† sauvegarder / restaurer l'√©tat du processeur.  De plus, le prologue ajoute quatre constantes - <code>$first</code> , <code>$second</code> , <code>$this</code> et <code>$return</code> .  Lors de la traduction, ces constantes sont remplac√©es par des adresses sur la pile, auxquelles correspondent respectivement les premier et deuxi√®me arguments pass√©s √† l'insert d'assembleur, l'adresse de la premi√®re commande d'insertion et l'adresse de retour. <br><br><h2>  R√©sum√© </h2><br>  Le code en dira beaucoup plus que des mots, et il serait √©trange de ne pas partager le r√©sultat d'un travail assez long, donc j'invite tous ceux qui m'int√©ressent √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br>  Si, n√©anmoins, j'essaie de g√©n√©raliser d'une mani√®re ou d'une autre tout ce qui a √©t√© fait, alors, √† mon avis, un projet int√©ressant et m√™me, dans une certaine mesure, pas inutile s'est av√©r√©.  Par exemple, des algorithmes identiques pour trier les insertions en C # et utiliser les insertions d'assembleur diff√®rent en vitesse plus de deux fois (bien s√ªr, en faveur de l'assembleur).  Dans les projets s√©rieux, bien s√ªr, il n'est pas recommand√© d'utiliser la biblioth√®que r√©sultante (des effets secondaires impr√©visibles sont possibles, mais peu probables), mais c'est tout √† fait possible pour vous-m√™me. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464931/">https://habr.com/ru/post/fr464931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464919/index.html">Contr√¥le int√©gr√© des ressources de la RAM utilis√©e dans l'application</a></li>
<li><a href="../fr464921/index.html">System.IO.Pipelines - un outil peu connu pour les amateurs de hautes performances</a></li>
<li><a href="../fr464925/index.html">Guide vocal UX: situations, mod√®les, outils (et un peu de soutien moral)</a></li>
<li><a href="../fr464927/index.html">Mineur ASIC d'occasion: risques, v√©rification et hashrate rec√¢bl√©</a></li>
<li><a href="../fr464929/index.html">Chargement d'image de navigateur paresseux (attribut de chargement)</a></li>
<li><a href="../fr464933/index.html">Applications pour les livres √©lectroniques sur le syst√®me d'exploitation Android. Partie 4. Jeux</a></li>
<li><a href="../fr464935/index.html">DevOpsSec confortable: Nemesida WAF gratuit pour NGINX avec API et compte personnel</a></li>
<li><a href="../fr464937/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 312 (du 19 au 25 ao√ªt)</a></li>
<li><a href="../fr464939/index.html">Test des annotations @ NonNull / @ Nullable</a></li>
<li><a href="../fr464947/index.html">√âv√©nements num√©riques √† Moscou du 25 ao√ªt au 1er septembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>