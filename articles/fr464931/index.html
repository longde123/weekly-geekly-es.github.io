<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚗 🤳🏼 👩🏾‍🎤 Assembleur insère ... en C #? 🕙 🎒 🤶🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Donc, cette histoire a commencé avec une coïncidence de trois facteurs. Je: 



1. écrit principalement en C #; 
2. seulement imaginé grossièrement co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assembleur insère ... en C #?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464931/">  Donc, cette histoire a commencé avec une coïncidence de trois facteurs.  Je: <br><br><ol><li>  écrit principalement en C #; </li><li>  seulement imaginé grossièrement comment il est organisé et fonctionne; </li><li>  s'est intéressé à l'assembleur. </li></ol><br>  Ce mélange apparemment innocent a donné lieu à une idée étrange: est-il possible de combiner d'une manière ou d'une autre ces langues?  Ajoutez en C # la possibilité de faire des insertions d'assembleur, un peu comme en C ++. <br><br>  Si vous êtes intéressé par les conséquences que cela a entraîné, bienvenue chez cat. <br><br> <a href=""><img src="https://habrastorage.org/webt/u-/sg/dk/u-sgdkb-3zwyqg682kuh2vvv1vq.png"></a> <br><a name="habracut"></a><br><h2>  Premières difficultés </h2><br>  Même à ce moment-là, j'ai réalisé qu'il est très peu probable qu'il existe des outils standard pour appeler du code assembleur à partir de code C # - cela contredit trop l'un des concepts importants du langage: la sécurité de la mémoire.  Après une étude superficielle de la question (qui, entre autres, a confirmé le pressentiment initial - «hors de la boîte», il n'y a pas une telle possibilité), il est devenu clair qu'en plus du problème idéologique, il y a un problème purement technique: C #, comme vous le savez, est compilé dans un bytecode intermédiaire, qui interprété par la machine virtuelle CLR.  Et c'est précisément ici que nous sommes confrontés au problème même: d'une part, le compilateur (ci-après je parlerai de Roslyn de Microsoft, car il est de facto la norme dans le domaine des compilateurs C #), évidemment, ne peut pas reconnaître et traduire les commandes assembleur d'une vue texte en une représentation binaire, ce qui signifie que nous devons utiliser les instructions de la machine directement sous leur forme binaire en tant qu'insert, et d'autre part, la machine virtuelle a son propre bytecode et ne peut pas reconnaître et exécuter cela  commandes groupées que nous lui offrir. <br><br>  La solution théorique à ce problème est évidente - vous devez vous assurer que le code d'insertion binaire est exécuté par le processeur, en contournant l'interprétation de la machine virtuelle.  La chose la plus simple qui me vient à l'esprit est de stocker le code binaire sous la forme d'un tableau d'octets, vers lequel le contrôle sera en quelque sorte transféré au bon moment.  De là se profile la première tâche: vous devez trouver un moyen de transférer le contrôle à ce qui est contenu dans une zone de mémoire arbitraire. <br><br><h2>  Premier prototype: «appeler» un tableau </h2><br>  Cette tâche est peut-être l'obstacle le plus sérieux aux encarts.  En utilisant les outils de langage, il est facile d'obtenir un pointeur vers notre tableau, mais dans le monde C #, les pointeurs n'existent que sur les données et il est impossible de le transformer en un pointeur vers, disons, une fonction pour qu'elle puisse être appelée plus tard (enfin, ou du moins je ne pouvais pas comprendre comment à faire). <br><br>  Heureusement (ou malheureusement), rien n'est nouveau sous la lune et une recherche rapide dans Yandex pour les mots "C #" et "assembleur inserts" m'a conduit à un article dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">numéro de décembre 2007 du magazine]] [Aker]</a> .  Ayant honnêtement copié la fonction à partir de là et l’ayant adaptée à mes besoins, j’ai <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualProtect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpAddress, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flNewProtect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">* lpflOldProtect</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* InvokeAsm(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* firstAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* secondAsmArg, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] code) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;i; p += <span class="hljs-number"><span class="hljs-number">0x14</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; i = *p; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* b = code) { *p = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)b; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> prev; VirtualProtect((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)b, (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)code.Length, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, &amp;prev); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)i; }</code> </pre> <br>  L'idée principale de ce code est de remplacer l'adresse de retour de la fonction <code>InvokeAsm()</code> sur la pile par l'adresse du tableau d'octets vers lequel vous souhaitez transférer le contrôle.  Ensuite, après avoir quitté la fonction, au lieu de continuer l'exécution du programme, l'exécution de notre code binaire commencera. <br><br>  Nous traiterons plus en détail de la magie qui <code>InvokeAsm()</code> dans <code>InvokeAsm()</code> .  Tout d'abord, nous déclarons une variable locale, qui, bien sûr, apparaît sur la pile, puis nous obtenons son adresse (obtenant ainsi l'adresse du haut de la pile).  Ensuite, nous y ajoutons une certaine constante magique obtenue en calculant minutieusement dans le débogueur le décalage de l'adresse de retour par rapport au haut de la pile, sauvegardons l'adresse de retour et écrivez plutôt l'adresse de notre tableau d'octets.  La signification sacrée de l'enregistrement de l'adresse de retour est évidente - nous devons continuer à exécuter le programme après notre insertion, ce qui signifie que nous devons savoir où transférer le contrôle après.  Vient ensuite l'appel à la fonction WinAPI à partir de la bibliothèque kernel32.dll - <code>VirtualProtect()</code> .  Il est nécessaire pour changer les attributs de la page mémoire sur laquelle se trouve le code d'insertion.  Bien sûr, lors de la compilation du programme, il apparaît dans la section des données et la page mémoire correspondante a un accès en lecture et en écriture.  Nous devons également ajouter la permission d'exécuter son contenu.  Enfin, nous renvoyons l'adresse de retour réelle stockée.  Bien sûr, cette adresse ne sera pas retournée au code qui a appelé <code>InvokeAsm()</code> , car  exécution immédiatement après le <code>return (void*)i;</code>  "Échec" dans l'encart.  Cependant, les conventions d'appel utilisées par la machine virtuelle (stdcall avec optimisation désactivée et fastcall avec activé) signifient renvoyer la valeur via le registre EAX, c'est-à-dire  pour revenir de l'insert, nous devons suivre deux instructions: <code>push eax</code> (code 0x50) et <code>ret</code> (code 0xC3). <br><br><div class="spoiler">  <b class="spoiler_title">Clarification</b> <div class="spoiler_text">  À l'avenir, nous parlerons de l'architecture de x86 (ou plutôt de IA-32) - ringard du fait qu'à cette époque, je le connaissais au moins d'une manière ou d'une autre, contrairement, disons, à x86-64.  Cependant, la méthode de transfert de contrôle décrite ci-dessus devrait fonctionner pour le code 64 bits. <br></div></div><br>  Enfin, vous devez faire attention à deux arguments inutilisés: <code>void* firstAsmArg</code> et <code>void* secondAsmArg</code> .  Ils sont nécessaires pour transférer des données utilisateur arbitraires vers l'insert d'assembleur.  Ces arguments seront situés soit à un endroit connu de la pile (stdcall), soit, là encore, dans des registres bien connus (fastcall). <br><br><div class="spoiler">  <b class="spoiler_title">Un peu d'optimisation</b> <div class="spoiler_text">  Puisque, du point de vue du compilateur, ce qui se passe dans le code, ne comprend pas quoi, il peut par inadvertance lancer un appel fondamentalement important / ajouter quelque chose en ligne / ne pas sauvegarder un argument "inutilisé" / interférer d'une manière ou d'une autre avec la mise en œuvre de notre plan.  Ceci est partiellement résolu par l' <code>[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]</code> , cependant, même de telles précautions ne donnent pas l'effet souhaité: par exemple, la variable locale <code>i</code> , qui est la clé de toute la fonction, se révèle soudainement être un registre, ce qui gâche évidemment tout .  Par conséquent, afin d'éliminer complètement la probabilité que quelque chose se passe mal, vous devez créer une bibliothèque avec l'optimisation désactivée (désactivez-la dans les propriétés du projet ou utilisez la configuration de débogage).  Par conséquent, stdcall sera utilisé, donc à l'avenir je procéderai de cette convention d'appel. <br></div></div><br><h2>  Améliorations </h2><br><h3>  La sécurité vaut mieux que l'insécurité </h3><br>  Bien sûr, il n'est pas question de sécurité (au sens où ce mot est utilisé en C #).  Cependant, la méthode <code>InvokeAsm()</code> décrite ci-dessus fonctionne sur des pointeurs, ce qui signifie qu'elle ne peut être appelée qu'à partir du bloc marqué avec le mot-clé <code>unsafe</code> , ce qui n'est pas toujours pratique - au moins elle nécessite une compilation avec le commutateur / unsafe (ou la coche correspondante dans les propriétés du projet dans VS).  Par conséquent, il semble logique de fournir un shell qui fonctionne au moins IntPtr (au pire), et idéalement, il permet à l'utilisateur de spécifier les types à transmettre et à renvoyer.  Eh bien, ça sonne comme générique, on écrit générique, qu'est-ce qu'il y a d'autre, on demande, de parler?  En fait - il y a quelque chose. <br><br>  Le plus évident: comment obtenir un pointeur sur un argument dont le type est inconnu?  Les constructions de type <code>T* ptr = &amp;arg</code> ne <code>T* ptr = &amp;arg</code> pas autorisées en C # et, en général, il n'est pas difficile de comprendre la raison: l'utilisateur peut bien utiliser l'un des types gérés comme paramètre de type, un pointeur vers lequel ne peut pas être obtenu.  La solution pourrait être de limiter un paramètre de type <code>unmanaged</code> , mais, premièrement, il n'apparaît qu'en C # 7.3, et deuxièmement, il ne permet pas de passer des chaînes et des tableaux comme arguments, bien que l'opérateur <code>fixed</code> permette de les utiliser (nous obtenons le pointeur vers le premier caractère ou élément de tableau, respectivement).  Eh bien, en plus, je voudrais donner à l'utilisateur la possibilité d'opérer, y compris les types contrôlés - puisque nous avons commencé à violer les règles de la langue, nous les violerons jusqu'à la fin! <br><br><h3>  Obtention d'un pointeur vers un objet géré et un objet par pointeur </h3><br>  Et encore une fois, après des délibérations peu fructueuses, j'ai commencé à chercher les solutions finales.  Cette fois, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur Habré</a> m'a aidé.  En bref, l'une des méthodes proposées consiste à écrire une bibliothèque auxiliaire, et non pas en C #, mais directement en IL.  Sa tâche consiste à pousser un objet (en fait une référence à l'objet) sur la pile de la machine virtuelle, passé en argument, puis à récupérer quelque chose d'autre dans la pile - par exemple, un nombre ou <code>IntPtr</code> .  En effectuant les mêmes étapes dans l'ordre inverse, vous pouvez convertir le pointeur (par exemple, renvoyé par l'insert d'assembleur) en objet.  Cette méthode est bonne car tout ce qui se passe est clair et transparent.  Mais il y a un inconvénient: je voulais m'en sortir avec le moins de fichiers possible, donc au lieu d'écrire une bibliothèque séparée, j'ai décidé d'incorporer le code IL dans la principale.  La seule façon que j'ai trouvée est d'écrire des méthodes de stub en C #, de construire le projet, de désassembler le binaire en utilisant ildasm, de réécrire le code des méthodes de stub et de tout remettre ensemble avec ilasm.  Ce sont quelques actions supplémentaires, et étant donné que vous devez les faire à chaque fois que vous les construisez après avoir apporté des modifications au code ... En général, je m'en suis lassé assez rapidement et j'ai commencé à chercher des alternatives. <br><br>  À ce moment-là, un merveilleux livre est tombé entre mes mains, grâce auquel j'ai beaucoup appris par moi-même - «CLR via C #» de Jeffrey Richter.  Dans ce document, quelque part autour du vingtième chapitre, nous avons parlé de la structure <code>GCHandle</code> , qui a une méthode <code>Alloc()</code> qui prend un objet et l'un des <code>GCHandleType</code> énumération <code>GCHandleType</code> .  Donc, si vous appelez cette méthode en lui passant l'objet souhaité et <code>GCHandle.Pinned</code> , vous pouvez obtenir l'adresse de cet objet en mémoire.  De plus, avant d'appeler <code>GCHandle.Free()</code> objet est fixe, c'est-à-dire  entièrement protégé contre les effets du ramasse-miettes.  Cependant, il y a certains problèmes.  Tout d'abord, <code>GCHandle</code> n'aide en aucune façon à terminer la conversion «pointeur → objet», seulement «objet → pointeur».  Plus important encore, pour utiliser <code>GCHandleType.Pinned</code> classe ou la structure de l'objet dont nous voulons obtenir l'adresse doit avoir l' <code>[StructLayout(LayoutKind.Sequential)]</code> , tandis que <code>LayoutKind.Auto</code> utilisé par <code>LayoutKind.Auto</code> .  Cette méthode ne convient donc que pour certains types standard et pour les types personnalisés qui ont été initialement conçus dans cet esprit.  Pas exactement la méthode universelle que nous aimerions trouver, non? <br><br>  Eh bien, essayez encore.  <code>__makeref()</code> maintenant attention à deux fonctions non documentées, qui sont néanmoins prises en charge par Roslyn: <code>__makeref()</code> et <code>__refvalue()</code> .  Le premier prend un objet et retourne une instance de la structure <code>TypedReference</code> qui stocke une référence à l'objet et à son type, tandis que le second extrait l'objet de l'instance <code>typedReference</code> transmise.  Pourquoi ces fonctionnalités sont-elles importantes pour nous?  Parce que <code>TypedReference</code> est une structure!  Dans le contexte de la discussion, cela signifie que nous pouvons obtenir un pointeur vers celui-ci, qui, en combinaison, sera un pointeur vers le premier champ de cette structure.  À savoir, il stocke le lien même avec l'objet qui nous intéresse.  Ensuite, pour obtenir un pointeur sur un objet géré, nous devons lire la valeur par un pointeur sur ce que <code>__makeref()</code> renverra et le convertir en pointeur.  Pour obtenir un objet par pointeur, vous devez appeler <code>__makeref()</code> partir d'un objet conditionnellement vide du type requis, obtenir un pointeur sur l'instance <code>TypedReference</code> retournée, écrire un pointeur sur l'objet dessus, puis appeler <code>__refvalue()</code> .  Le résultat est quelque chose comme ce code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Tout ToInstance&lt;Tout&gt;(IntPtr ptr) { Tout temp = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; TypedReference tr = __makeref(temp); Marshal.WriteIntPtr(*(IntPtr*)(&amp;tr), ptr); Tout instance = __refvalue(tr, Tout); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ToPointer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> T obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).IsValueType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;tr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> **(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>***)&amp;tr; } }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  Revenant à la tâche d'écrire un wrapper sûr pour <code>InvokeAsm()</code> , il convient de noter que la méthode d'obtention de pointeurs à l'aide de <code>__makeref()</code> et <code>__refvalue()</code> , contrairement à l'utilisation de <code>GCHandle.Alloc(GCHandleType.Pinned)</code> , ne garantit pas que notre garbage collector est nulle part l'objet ne bougera pas.  Par conséquent, l'encapsuleur doit commencer par désactiver le garbage collector et se terminer par la restauration de ses fonctionnalités.  La solution est plutôt grossière, mais efficace. <br></div></div><br><h2>  Pour ceux qui ne se souviennent pas des opcodes </h2><br>  Nous avons donc appris à appeler du code binaire, appris à transmettre non seulement des valeurs immédiates, mais aussi des pointeurs vers n'importe quoi comme arguments ... Il n'y a qu'un seul problème.  Où obtenir le même code binaire?  Vous pouvez vous armer d'un crayon, d'un bloc-notes et d'une table d'opcode (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">celui-ci</a> ) ou prendre un éditeur hexadécimal avec le support de l'assembleur x86 ou même un traducteur à part entière, mais toutes ces options signifient que l'utilisateur devra utiliser autre chose que la bibliothèque.  Ce n'était pas tout à fait ce que je voulais, j'ai donc décidé d'inclure mon traducteur dans la bibliothèque, qui était traditionnellement appelée SASM (abréviation de Stack Assembler; cela n'a rien à voir avec l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IDE</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">Clause de non-responsabilité</b> <div class="spoiler_text">  Je ne suis pas bon pour analyser les chaînes, donc le code du traducteur ... enfin, imparfait, c'est le moins qu'on puisse dire.  De plus, je ne suis pas fort dans les expressions régulières, donc elles ne sont pas là.  Et en général - un analyseur itératif. <br></div></div><br>  Je ne vais probablement pas parler du processus de création de ce "miracle" - il n'y a rien d'intéressant dans cette histoire, mais je vais décrire brièvement les principales caractéristiques.  La plupart des instructions x86 sont actuellement prises en charge.  Les instructions mathématiques du coprocesseur pour travailler avec des nombres à virgule flottante et à partir d'extensions (MMX, SSE, AVX) ne sont pas encore prises en charge.  Il est possible de déclarer des constantes, des procédures, des variables de pile locales, des variables globales, dont la mémoire est allouée lors de la traduction directement dans un tableau avec du code binaire (si ces variables sont nommées à l'aide d'étiquettes, leur valeur peut également être obtenue à partir de C # après avoir effectué l'insertion en appelant des méthodes <code>GetBYTEVariable()</code> , <code>GetWORDVariable()</code> , <code>GetDWORDVariable()</code> , <code>GetAStringVariable()</code> et <code>GetWStringVariable()</code> de l'objet <code>SASMCode</code> ), des macros <code>addr</code> et <code>invoke</code> sont présentes.  L'une des fonctionnalités importantes est la prise en charge de l'importation de fonctions à partir de bibliothèques externes à l'aide de la construction <code>extern &lt; &gt; lib &lt; &gt;</code> . <br><br>  <code>asmret</code> macro <code>asmret</code> mérite un paragraphe séparé.  En cours de traduction, il se déroule en 11 instructions formant l'épilogue.  Le prologue est ajouté par défaut au début du code traduit.  Leur tâche consiste à sauvegarder / restaurer l'état du processeur.  De plus, le prologue ajoute quatre constantes - <code>$first</code> , <code>$second</code> , <code>$this</code> et <code>$return</code> .  Lors de la traduction, ces constantes sont remplacées par des adresses sur la pile, auxquelles correspondent respectivement les premier et deuxième arguments passés à l'insert d'assembleur, l'adresse de la première commande d'insertion et l'adresse de retour. <br><br><h2>  Résumé </h2><br>  Le code en dira beaucoup plus que des mots, et il serait étrange de ne pas partager le résultat d'un travail assez long, donc j'invite tous ceux qui m'intéressent à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br>  Si, néanmoins, j'essaie de généraliser d'une manière ou d'une autre tout ce qui a été fait, alors, à mon avis, un projet intéressant et même, dans une certaine mesure, pas inutile s'est avéré.  Par exemple, des algorithmes identiques pour trier les insertions en C # et utiliser les insertions d'assembleur diffèrent en vitesse plus de deux fois (bien sûr, en faveur de l'assembleur).  Dans les projets sérieux, bien sûr, il n'est pas recommandé d'utiliser la bibliothèque résultante (des effets secondaires imprévisibles sont possibles, mais peu probables), mais c'est tout à fait possible pour vous-même. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464931/">https://habr.com/ru/post/fr464931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464919/index.html">Contrôle intégré des ressources de la RAM utilisée dans l'application</a></li>
<li><a href="../fr464921/index.html">System.IO.Pipelines - un outil peu connu pour les amateurs de hautes performances</a></li>
<li><a href="../fr464925/index.html">Guide vocal UX: situations, modèles, outils (et un peu de soutien moral)</a></li>
<li><a href="../fr464927/index.html">Mineur ASIC d'occasion: risques, vérification et hashrate recâblé</a></li>
<li><a href="../fr464929/index.html">Chargement d'image de navigateur paresseux (attribut de chargement)</a></li>
<li><a href="../fr464933/index.html">Applications pour les livres électroniques sur le système d'exploitation Android. Partie 4. Jeux</a></li>
<li><a href="../fr464935/index.html">DevOpsSec confortable: Nemesida WAF gratuit pour NGINX avec API et compte personnel</a></li>
<li><a href="../fr464937/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 312 (du 19 au 25 août)</a></li>
<li><a href="../fr464939/index.html">Test des annotations @ NonNull / @ Nullable</a></li>
<li><a href="../fr464947/index.html">Événements numériques à Moscou du 25 août au 1er septembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>