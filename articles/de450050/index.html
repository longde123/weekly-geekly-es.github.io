<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß üà∑Ô∏è üà∫ Die Grundlagen der reaktiven Programmierung mit RxJS. Teil 3. Observable h√∂herer Ordnung üçÑ üç® üÜé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir untersuchen, wie es m√∂glich ist, einen anderen in einem Thread zu verarbeiten, warum er ben√∂tigt wird und wie Operatoren ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Grundlagen der reaktiven Programmierung mit RxJS. Teil 3. Observable h√∂herer Ordnung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450050/"><img src="https://habrastorage.org/webt/kk/rj/yw/kkrjywqpfptl1uta2ou9bltd-je.png"><br><br>  In diesem Artikel werden wir untersuchen, wie es m√∂glich ist, einen anderen in einem Thread zu verarbeiten, warum er ben√∂tigt wird und wie Operatoren h√∂herer Ordnung (im Folgenden als HOO bezeichnet) uns dabei helfen. <br><br>  Artikelserie "Grundlagen der reaktiven Programmierung mit RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1. Reaktivit√§t und Fl√ºsse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Bediener und Rohre</a> </li></ul><br><br>  Bei der Arbeit mit Threads tritt h√§ufig die Situation auf, dass die Ergebnisse eines anderen als Wert auf einen Thread √ºbertragen werden m√ºssen.  Beispielsweise m√∂chten wir eine Ajax-Anforderung ausf√ºhren und ihre Antwort im aktuellen Thread verarbeiten oder mehrere parallele Anforderungen ausf√ºhren und Pooling implementieren.  Ich denke, viele Menschen sind es gewohnt, solche Probleme mit einem Mechanismus wie Versprechen zu l√∂sen.  Aber ist es m√∂glich, sie mit RxJS zu l√∂sen?  Nat√ºrlich und alles ist viel einfacher als Sie denken! <br><a name="habracut"></a><br>  <b>Hinweis</b> : Um den theoretischen Teil des Artikels zu verstehen, m√ºssen Sie nicht die vorherigen Artikel lesen, sondern nur wissen, was beobachtbar ist, Bediener und Rohre.  Im praktischen Teil werden wir das Beispiel aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Artikel</a> verfeinern, den Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier</a> finden. <br><br><h4>  Das Problem </h4><br>  Stellen wir uns folgende Aufgabe vor: Wir m√ºssen jede Sekunde herausfinden, ob auf den Server zugegriffen werden kann.  Wie k√∂nnen wir es l√∂sen? <br><br>  Erstellen Sie zun√§chst einen Stream mit der Timer-Methode: <br><br><pre><code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre> <br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Timer-</a> Methode ist im Prinzip dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Intervall</a> sehr √§hnlich.  Im Gegensatz dazu k√∂nnen Sie das Thread-Start-Timeout festlegen, das vom ersten Parameter √ºbertragen wird.  Der zweite Parameter gibt das Intervall an, in dem ein neuer Wert generiert wird.  Wenn der zweite Parameter nicht angegeben wird, generiert der Timer nur einen Wert und beendet den Stream. <br><br>  Da Sie und ich keinen Server haben, empfehle ich, nur eine Funktion zu schreiben, die eine Anforderung an den Server emuliert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> makeRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timer(<span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mapTo(<span class="hljs-string"><span class="hljs-string">'success'</span></span>) ) }</code> </pre><br>  Was macht diese Methode?  Es gibt einen Stream zur√ºck, der mit der Timer-Methode erstellt wurde. Nach Ablauf einer Sekunde wird ein Wert ausgegeben und beendet.  Da die Timer-Methode nur eine Zahl generiert, verwenden wir den mapTo-Operator, um sie durch die Zeichenfolge "success" zu ersetzen. <br><br>  So sieht der von der makeRequest-Methode erstellte Stream aus: <br><br><img src="https://habrastorage.org/webt/5t/0a/pf/5t0apfljjo-5lc9buhsd9455mrk.png"><br><br>  Jetzt haben wir die Wahl: die makeRequest-Methode innerhalb des Streams aufzurufen oder diese Verantwortung dem Beobachter zuzuweisen? <br><br>  Der erste Ansatz ist vorzuziehen, da wir in diesem Fall das volle Potenzial von RxJS mit seinen Betreibern nutzen und unseren Beobachter von unn√∂tigen Pflichten entlasten k√∂nnen.  Wir verwenden die Timer-Methode, um Anforderungen nach Intervallen auszuf√ºhren: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Wenn wir solchen Code ausf√ºhren, werden wir sehen, dass wir in console.log keine Nachricht mit dem Text "Erfolg" erhalten, sondern ein Objekt vom Typ Observable: <br><br><img src="https://habrastorage.org/webt/ld/bd/ue/ldbduelhulehfiqmbm80sm3zgu8.png"><br><br>  Die Antwort wird durchaus erwartet, da wir in der Karte den Stream zur√ºckgeben.  Damit ein Stream funktioniert, m√ºssen Sie ihn abonnieren.  Mal sehen, wie man es <b>nicht macht</b> : <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observable</span></span></span><span class="hljs-function"> =&gt;</span></span> observable.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); });</code> </pre><br>  Das Problem mit dem obigen Beispiel ist, dass wir ein Abonnement in einem Abonnement erhalten.  Aber was ist, wenn wir mehr als eine Anfrage in einer Kette stellen m√∂chten?  Oder was ist, wenn wir uns irgendwann vom Fluss im Inneren abmelden m√ºssen?  In diesem Fall √§hnelt unser Code immer mehr ‚ÄûNudeln‚Äú.  Um dieses Problem zu l√∂sen, verf√ºgt RxJS √ºber spezielle Operatoren namens HOO. <br><br><h4>  Hoo </h4><br>  HOO ist eine spezielle Art von Anweisungen, die Streams als Werte akzeptieren.  Ein solcher Operator ist die mergeAll-Methode. <br><br>  Wenn ein Stream bei mergeAll ankommt, abonniert er ihn.  Der Stream, den der Bediener abonniert hat, wird als intern bezeichnet.  Der Stream, von dem der Bediener andere Flows als Werte empf√§ngt, wird als extern bezeichnet. <br><br>  Wenn ein interner Thread einen Wert generiert, √ºbertr√§gt mergeAll diesen Wert in den externen Thread.  Auf diese Weise m√ºssen wir nicht mehr manuell abonnieren.  Wenn wir uns vom externen Flow abmelden, wird mergeAll den internen automatisch abbestellen. <br><br>  Mal sehen, wie wir unser Beispiel mit mergeAll umschreiben k√∂nnen: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Im obigen Beispiel wurde der externe Stream von der Timer-Anweisung erstellt.  Die im Kartenoperator erstellten Flows sind intern.  Jeder erstellte Thread f√§llt in die Anweisung mergeAll. <br><br><img src="https://habrastorage.org/webt/la/va/m1/lavam1n0lygvuyfolgwfd6yfyd0.png"><br><br>  Die Kombination map + mergeAll wird sehr h√§ufig verwendet, daher gibt es in RxJS eine mergeMap-Methode: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Wenn ein externer Thread einen Wert generiert, ruft der mergeMap-Operator die an ihn √ºbergebene R√ºckruffunktion auf, die einen neuen Thread generiert.  Dann abonniert mergeMap den generierten Stream. <br><br><img src="https://habrastorage.org/webt/n1/rh/ks/n1rhksa9atkguhglj7by5p45bew.png"><br><br>  Die Besonderheit des Operators mergeAll / mergeMap besteht darin, dass ein anderer Stream ihn abonniert, wenn er darauf herunterkommt.  Somit k√∂nnen wir in einem externen Stream Werte von mehreren internen gleichzeitig abrufen.  Sehen wir uns das folgende Beispiel an: <br><br><pre> <code class="javascript hljs"> timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br>  So sieht der externe Stream ohne den Operator mergeMap aus: <br><br><img src="https://habrastorage.org/webt/ie/ww/8j/ieww8j7-t1lnixucckiwzzqrmxc.png"><br><br>  Und so mit mergeMap: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) )</code> </pre><br><img src="https://habrastorage.org/webt/lw/0p/_o/lw0p_ownbroitrzyxksva1lhexe.png"><br><br>  Jede Sekunde erstellen wir einen neuen internen Thread und mergeMap abonniert ihn.  Wir haben also viele interne Threads, die gleichzeitig arbeiten und deren Werte in die externen fallen: <br><br><img src="https://habrastorage.org/webt/ar/il/_v/aril_vrkhr-jrn1jkllqj6io-ec.png"><br><br><img src="https://habrastorage.org/webt/jv/wh/um/jvwhumoobhmtyejohzsxkc26oae.png"><br><br>  <b>Hinweis</b> : Seien <b>Sie</b> vorsichtig mit mergeMap. Jeder neue interne Thread funktioniert so lange, bis Sie sich vom externen Thread abmelden.  Im obigen Beispiel w√§chst die Anzahl der internen Threads von Sekunde zu Sekunde. Am Ende kann es so viele Threads geben, dass der Computer die Last nicht bew√§ltigen kann. <br><br><h4>  concatAll / concatMap </h4><br>  Die mergeMap-Methode eignet sich hervorragend, wenn Sie sich nicht f√ºr die Ausf√ºhrungsreihenfolge interner Threads interessieren. Was ist, wenn Sie sie ben√∂tigen?  Angenommen, wir m√∂chten, dass die n√§chste Serveranforderung erst ausgef√ºhrt wird, nachdem eine Antwort von der vorherigen empfangen wurde. <br><br>  F√ºr solche Zwecke ist der HOO-Operator concatAll / concatMap geeignet.  Dieser Operator, der den internen Thread abonniert hat, wartet, bis er beendet ist, und abonniert erst dann den n√§chsten. <br><br>  Wenn w√§hrend der Ausf√ºhrung eines Threads ein neuer Thread zu diesem absteigt, wird er in die Warteschlange gestellt, bis der vorherige abgeschlossen ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  1     const firstInnerObservable = timer(1000).pipe( mapTo(1) ); // ,  2     const secondInnerObservable = timer(500).pipe( mapTo(2) ); of( firstInnerObservable, secondInnerObservable ).pipe( concatAll() ).subscribe({ next: console.log });</span></span></code> </pre><br>  Im obigen Beispiel erstellen wir zwei Threads mit der Timer-Methode.  Aus Gr√ºnden der √úbersichtlichkeit habe ich den mapTo-Operator verwendet, um verschiedene Werte anzuzeigen.  Der erste Thread generiert 1, der zweite - 2. Ein externer Thread wird mit der of-Methode erstellt, bei der zwei der oben genannten Werte als Eingabe verwendet werden. <br><br>  Die concatAll-Anweisung empf√§ngt zuerst firstInnerObservable, abonniert sie und wartet auf ihren Abschluss. Erst nach Abschluss der ersten abonniert sie secondInnerObservable.  So sieht der externe Stream aus: <br><br><img src="https://habrastorage.org/webt/dz/cd/mi/dzcdmibwf773qa025bqlqfd9oe4.png"><br><br>  Wenn wir concatAll durch mergeAll ersetzen, sieht der Stream folgenderma√üen aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ax/o3/tw/axo3tw1onffl5zq956-ewdjdf8q.png"><br><br><h4>  switchAll / switchMap </h4><br>  Dieser Operator unterscheidet sich von den vorherigen darin, dass er beim Empfang eines neuen Streams den vorherigen sofort abmeldet und den neuen abonniert. <br><br>  Nehmen Sie das obige Beispiel und ersetzen Sie concatAll durch switchAll. Sehen Sie, wie sich der externe Fluss verh√§lt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( switchAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ec/ra/sm/ecrasmknkfvubsngt7c_dcrtu1w.png"><br><br>  Nur der Wert aus dem zweiten internen Stream wurde in den externen Stream √ºbertragen.  Dies liegt daran, dass switchMap vom ersten abgemeldet wurde, als es den zweiten Thread erhielt. <br><br>  Wann wird das ben√∂tigt?  Zum Beispiel bei der Implementierung einer Datensuche.  Wenn die Antwort vom Server noch nicht eingetroffen ist und wir bereits eine neue Anfrage gesendet haben, ist es nicht sinnvoll, auf die vorherige zu warten. <br><br><h4>  Auspuff / AuspuffMap </h4><br>  Abgas ist das genaue Gegenteil der switchAll-Anweisung, und sein Verhalten √§hnelt dem von concatAll.  Diese Methode, die den Stream abonniert, wartet auf den Abschluss.  Wenn ein neuer Stream darauf ankommt, wird er einfach verworfen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( exhaust() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/2m/x7/ur/2mx7urryxakugfc8srx3lffn92c.png"><br><br>  Im obigen Beispiel haben wir keine Zwei erhalten, da der Bediener in diesem Moment auf die Fertigstellung des ersten Threads wartete und einfach den zweiten Thread fallen lie√ü. <br><br>  Ich denke, viele haben eine Frage, wann ein solches Verhalten erforderlich sein kann.  Ein gutes Beispiel ist das Anmeldeformular.  Es ist nicht sinnvoll, mehrere Anforderungen an den Server zu senden, bis die aktuelle abgeschlossen ist. <br><br><h4>  Wir schlie√üen den Antrag ab </h4><br>  Wir erinnern uns an das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Beispiel</a> aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Artikel</a> .  Darin haben wir eine Suche auf GitHub implementiert und den mergeMap-Operator verwendet, um Anforderungen an den Server zu senden.  Jetzt kennen wir die Funktionen dieses Operators. Ist er in unserem Fall wirklich geeignet? <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Nehmen wir an, dass der GitHub-Server stark √ºberlastet ist und die Verarbeitung unserer Antwort viel Zeit in Anspruch nimmt.  Was k√∂nnte in diesem Fall m√∂glicherweise schief gehen? <br><br>  Angenommen, ein Benutzer hat einige Daten eingegeben, nicht auf eine Antwort gewartet und neue eingegeben.  In diesem Fall senden wir die zweite Anfrage an den Server.  Niemand garantiert jedoch, dass die Antwort auf die erste Anfrage fr√ºher kommt. <br><br>  Da es dem mergeMap-Operator egal ist, in welcher Reihenfolge die internen Threads verarbeitet werden sollen, werden die tats√§chlichen Daten gel√∂scht, wenn die erste Anforderung sp√§ter als die zweite ausgef√ºhrt wird.  Daher schlage ich vor, die mergeMap-Methode durch switchMap zu ersetzen: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Wenn der Benutzer neue Daten eingibt, wird switchMap den vorherigen Stream abbestellen und den neuen abonnieren. <br><br>  Es ist erw√§hnenswert, dass unsere http-Anfrage so lange h√§ngen bleibt, bis der Server eine Antwort darauf gibt.  Da wir uns jedoch vom internen Stream abgemeldet haben, f√§llt die Antwort nicht in den externen Stream. <br><br>  <b>Hinweis</b> : Wenn Sie mit Angular arbeiten und HttpClient f√ºr die Arbeit mit http verwenden, k√∂nnen Sie sich keine Sorgen machen, die Anforderung selbst abzubrechen.  HttpClient kann dies f√ºr Sie tun, wenn Sie sich abmelden. <br><br><h4>  Abbrechen http </h4><br>  Die Abruf-API kann die http-Anforderung mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">AbortController abbrechen</a> .  In Kombination mit dem switchMap-Operator spart diese Funktionalit√§t Benutzerverkehr. <br><br>  Lassen Sie uns unser Beispiel ein wenig umschreiben.  Und erstellen Sie eine Methode, die den Abruf in Observable umschlie√üt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createCancellableRequest = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      const controller = new AbortController(); const signal = controller.signal; return new Observable(observer =&gt; { fetch(url, { signal }) .then(response =&gt; { if (response.ok) { return response.json(); } throw new Error(''); }) //     .then(result =&gt; observer.next(result)) //   .then(() =&gt; observer.complete()) //   ,     .catch(error =&gt; observer.error(error)); // ,    return () =&gt; { //   controller.abort(); }; }); };</span></span></code> </pre><br>  √Ñndern Sie auch die Methode getUsersRepsFromApi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createCancellableRequest(url); }</code> </pre><br>  Jetzt gibt die Methode nicht vielversprechend zur√ºck, sondern beobachtbar.  Daher entfernen wir den Wrapper in switchMap: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getUsersRepsFromAPI(value).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([]) ) )</code> </pre><br>  <b>Hinweis</b> : In RxJS Version 6.5 wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">fromFetch-Anweisung</a> hinzugef√ºgt, die selbst die Abbruchmethode unter der Haube aufruft, sodass Sie kein eigenes ‚ÄûFahrrad‚Äú mehr schreiben m√ºssen. <br><br>  Das ist alles!  Den gesamten Beispielcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier</a> . <br><br><h4>  Fazit </h4><br>  Heute haben wir uns angesehen, was HOO ist und einige sehr n√ºtzliche Operatoren aus dieser Kategorie.  Nat√ºrlich waren diese weit von allen entfernt.  F√ºr detailliertere und detailliertere Informationen empfehle ich den Besuch der RxJS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Dokumentation</a> . <br><br>  Im n√§chsten Artikel m√∂chte ich untersuchen, was der Unterschied zwischen hei√üen und kalten Observablen ist. <br><br>  Schlie√ülich: Verwenden Sie das Abonnement nicht im Abonnement, da es HOO gibt! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450050/">https://habr.com/ru/post/de450050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450036/index.html">Summ3r 0f h4ck: Praktikum Digital Security 2019</a></li>
<li><a href="../de450040/index.html">Neues Unternehmen wird OpenJDK 8 und 11 unterst√ºtzen - wir verstehen die Situation</a></li>
<li><a href="../de450042/index.html">Russisches erweitertes Tastaturlayout</a></li>
<li><a href="../de450044/index.html">Auf der Suche nach einem Problem am falschen Ort</a></li>
<li><a href="../de450048/index.html">Anmerkungen zu √Ñnderungen des Bundesgesetzes Nr. 149-–§–ó ‚Äû√úber Information, Informationstechnologien und Informationsschutz‚Äú</a></li>
<li><a href="../de450054/index.html">Hacke den JWT-Token</a></li>
<li><a href="../de450056/index.html">Achten Sie auf Nummer 2: Zusammenfassung der Artikel zu Produktdenken, Verhaltenspsychologie und pers√∂nlicher Produktivit√§t</a></li>
<li><a href="../de450058/index.html">Der Lebenslauf dieses Typen</a></li>
<li><a href="../de450060/index.html">Wie ich herausfand, dass mein Visum noch nicht fertig ist, eine Nachricht in Slack</a></li>
<li><a href="../de450062/index.html">Wiederherstellung des Kreislaufs im Gehirn wenige Stunden nach dem Tod</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>