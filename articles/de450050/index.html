<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧 🈷️ 🈺 Die Grundlagen der reaktiven Programmierung mit RxJS. Teil 3. Observable höherer Ordnung 🍄 🍨 🆎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir untersuchen, wie es möglich ist, einen anderen in einem Thread zu verarbeiten, warum er benötigt wird und wie Operatoren ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Grundlagen der reaktiven Programmierung mit RxJS. Teil 3. Observable höherer Ordnung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450050/"><img src="https://habrastorage.org/webt/kk/rj/yw/kkrjywqpfptl1uta2ou9bltd-je.png"><br><br>  In diesem Artikel werden wir untersuchen, wie es möglich ist, einen anderen in einem Thread zu verarbeiten, warum er benötigt wird und wie Operatoren höherer Ordnung (im Folgenden als HOO bezeichnet) uns dabei helfen. <br><br>  Artikelserie "Grundlagen der reaktiven Programmierung mit RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1. Reaktivität und Flüsse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Bediener und Rohre</a> </li></ul><br><br>  Bei der Arbeit mit Threads tritt häufig die Situation auf, dass die Ergebnisse eines anderen als Wert auf einen Thread übertragen werden müssen.  Beispielsweise möchten wir eine Ajax-Anforderung ausführen und ihre Antwort im aktuellen Thread verarbeiten oder mehrere parallele Anforderungen ausführen und Pooling implementieren.  Ich denke, viele Menschen sind es gewohnt, solche Probleme mit einem Mechanismus wie Versprechen zu lösen.  Aber ist es möglich, sie mit RxJS zu lösen?  Natürlich und alles ist viel einfacher als Sie denken! <br><a name="habracut"></a><br>  <b>Hinweis</b> : Um den theoretischen Teil des Artikels zu verstehen, müssen Sie nicht die vorherigen Artikel lesen, sondern nur wissen, was beobachtbar ist, Bediener und Rohre.  Im praktischen Teil werden wir das Beispiel aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Artikel</a> verfeinern, den Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier</a> finden. <br><br><h4>  Das Problem </h4><br>  Stellen wir uns folgende Aufgabe vor: Wir müssen jede Sekunde herausfinden, ob auf den Server zugegriffen werden kann.  Wie können wir es lösen? <br><br>  Erstellen Sie zunächst einen Stream mit der Timer-Methode: <br><br><pre><code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre> <br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Timer-</a> Methode ist im Prinzip dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Intervall</a> sehr ähnlich.  Im Gegensatz dazu können Sie das Thread-Start-Timeout festlegen, das vom ersten Parameter übertragen wird.  Der zweite Parameter gibt das Intervall an, in dem ein neuer Wert generiert wird.  Wenn der zweite Parameter nicht angegeben wird, generiert der Timer nur einen Wert und beendet den Stream. <br><br>  Da Sie und ich keinen Server haben, empfehle ich, nur eine Funktion zu schreiben, die eine Anforderung an den Server emuliert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> makeRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timer(<span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mapTo(<span class="hljs-string"><span class="hljs-string">'success'</span></span>) ) }</code> </pre><br>  Was macht diese Methode?  Es gibt einen Stream zurück, der mit der Timer-Methode erstellt wurde. Nach Ablauf einer Sekunde wird ein Wert ausgegeben und beendet.  Da die Timer-Methode nur eine Zahl generiert, verwenden wir den mapTo-Operator, um sie durch die Zeichenfolge "success" zu ersetzen. <br><br>  So sieht der von der makeRequest-Methode erstellte Stream aus: <br><br><img src="https://habrastorage.org/webt/5t/0a/pf/5t0apfljjo-5lc9buhsd9455mrk.png"><br><br>  Jetzt haben wir die Wahl: die makeRequest-Methode innerhalb des Streams aufzurufen oder diese Verantwortung dem Beobachter zuzuweisen? <br><br>  Der erste Ansatz ist vorzuziehen, da wir in diesem Fall das volle Potenzial von RxJS mit seinen Betreibern nutzen und unseren Beobachter von unnötigen Pflichten entlasten können.  Wir verwenden die Timer-Methode, um Anforderungen nach Intervallen auszuführen: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Wenn wir solchen Code ausführen, werden wir sehen, dass wir in console.log keine Nachricht mit dem Text "Erfolg" erhalten, sondern ein Objekt vom Typ Observable: <br><br><img src="https://habrastorage.org/webt/ld/bd/ue/ldbduelhulehfiqmbm80sm3zgu8.png"><br><br>  Die Antwort wird durchaus erwartet, da wir in der Karte den Stream zurückgeben.  Damit ein Stream funktioniert, müssen Sie ihn abonnieren.  Mal sehen, wie man es <b>nicht macht</b> : <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observable</span></span></span><span class="hljs-function"> =&gt;</span></span> observable.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); });</code> </pre><br>  Das Problem mit dem obigen Beispiel ist, dass wir ein Abonnement in einem Abonnement erhalten.  Aber was ist, wenn wir mehr als eine Anfrage in einer Kette stellen möchten?  Oder was ist, wenn wir uns irgendwann vom Fluss im Inneren abmelden müssen?  In diesem Fall ähnelt unser Code immer mehr „Nudeln“.  Um dieses Problem zu lösen, verfügt RxJS über spezielle Operatoren namens HOO. <br><br><h4>  Hoo </h4><br>  HOO ist eine spezielle Art von Anweisungen, die Streams als Werte akzeptieren.  Ein solcher Operator ist die mergeAll-Methode. <br><br>  Wenn ein Stream bei mergeAll ankommt, abonniert er ihn.  Der Stream, den der Bediener abonniert hat, wird als intern bezeichnet.  Der Stream, von dem der Bediener andere Flows als Werte empfängt, wird als extern bezeichnet. <br><br>  Wenn ein interner Thread einen Wert generiert, überträgt mergeAll diesen Wert in den externen Thread.  Auf diese Weise müssen wir nicht mehr manuell abonnieren.  Wenn wir uns vom externen Flow abmelden, wird mergeAll den internen automatisch abbestellen. <br><br>  Mal sehen, wie wir unser Beispiel mit mergeAll umschreiben können: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Im obigen Beispiel wurde der externe Stream von der Timer-Anweisung erstellt.  Die im Kartenoperator erstellten Flows sind intern.  Jeder erstellte Thread fällt in die Anweisung mergeAll. <br><br><img src="https://habrastorage.org/webt/la/va/m1/lavam1n0lygvuyfolgwfd6yfyd0.png"><br><br>  Die Kombination map + mergeAll wird sehr häufig verwendet, daher gibt es in RxJS eine mergeMap-Methode: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Wenn ein externer Thread einen Wert generiert, ruft der mergeMap-Operator die an ihn übergebene Rückruffunktion auf, die einen neuen Thread generiert.  Dann abonniert mergeMap den generierten Stream. <br><br><img src="https://habrastorage.org/webt/n1/rh/ks/n1rhksa9atkguhglj7by5p45bew.png"><br><br>  Die Besonderheit des Operators mergeAll / mergeMap besteht darin, dass ein anderer Stream ihn abonniert, wenn er darauf herunterkommt.  Somit können wir in einem externen Stream Werte von mehreren internen gleichzeitig abrufen.  Sehen wir uns das folgende Beispiel an: <br><br><pre> <code class="javascript hljs"> timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br>  So sieht der externe Stream ohne den Operator mergeMap aus: <br><br><img src="https://habrastorage.org/webt/ie/ww/8j/ieww8j7-t1lnixucckiwzzqrmxc.png"><br><br>  Und so mit mergeMap: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) )</code> </pre><br><img src="https://habrastorage.org/webt/lw/0p/_o/lw0p_ownbroitrzyxksva1lhexe.png"><br><br>  Jede Sekunde erstellen wir einen neuen internen Thread und mergeMap abonniert ihn.  Wir haben also viele interne Threads, die gleichzeitig arbeiten und deren Werte in die externen fallen: <br><br><img src="https://habrastorage.org/webt/ar/il/_v/aril_vrkhr-jrn1jkllqj6io-ec.png"><br><br><img src="https://habrastorage.org/webt/jv/wh/um/jvwhumoobhmtyejohzsxkc26oae.png"><br><br>  <b>Hinweis</b> : Seien <b>Sie</b> vorsichtig mit mergeMap. Jeder neue interne Thread funktioniert so lange, bis Sie sich vom externen Thread abmelden.  Im obigen Beispiel wächst die Anzahl der internen Threads von Sekunde zu Sekunde. Am Ende kann es so viele Threads geben, dass der Computer die Last nicht bewältigen kann. <br><br><h4>  concatAll / concatMap </h4><br>  Die mergeMap-Methode eignet sich hervorragend, wenn Sie sich nicht für die Ausführungsreihenfolge interner Threads interessieren. Was ist, wenn Sie sie benötigen?  Angenommen, wir möchten, dass die nächste Serveranforderung erst ausgeführt wird, nachdem eine Antwort von der vorherigen empfangen wurde. <br><br>  Für solche Zwecke ist der HOO-Operator concatAll / concatMap geeignet.  Dieser Operator, der den internen Thread abonniert hat, wartet, bis er beendet ist, und abonniert erst dann den nächsten. <br><br>  Wenn während der Ausführung eines Threads ein neuer Thread zu diesem absteigt, wird er in die Warteschlange gestellt, bis der vorherige abgeschlossen ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  1     const firstInnerObservable = timer(1000).pipe( mapTo(1) ); // ,  2     const secondInnerObservable = timer(500).pipe( mapTo(2) ); of( firstInnerObservable, secondInnerObservable ).pipe( concatAll() ).subscribe({ next: console.log });</span></span></code> </pre><br>  Im obigen Beispiel erstellen wir zwei Threads mit der Timer-Methode.  Aus Gründen der Übersichtlichkeit habe ich den mapTo-Operator verwendet, um verschiedene Werte anzuzeigen.  Der erste Thread generiert 1, der zweite - 2. Ein externer Thread wird mit der of-Methode erstellt, bei der zwei der oben genannten Werte als Eingabe verwendet werden. <br><br>  Die concatAll-Anweisung empfängt zuerst firstInnerObservable, abonniert sie und wartet auf ihren Abschluss. Erst nach Abschluss der ersten abonniert sie secondInnerObservable.  So sieht der externe Stream aus: <br><br><img src="https://habrastorage.org/webt/dz/cd/mi/dzcdmibwf773qa025bqlqfd9oe4.png"><br><br>  Wenn wir concatAll durch mergeAll ersetzen, sieht der Stream folgendermaßen aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ax/o3/tw/axo3tw1onffl5zq956-ewdjdf8q.png"><br><br><h4>  switchAll / switchMap </h4><br>  Dieser Operator unterscheidet sich von den vorherigen darin, dass er beim Empfang eines neuen Streams den vorherigen sofort abmeldet und den neuen abonniert. <br><br>  Nehmen Sie das obige Beispiel und ersetzen Sie concatAll durch switchAll. Sehen Sie, wie sich der externe Fluss verhält: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( switchAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ec/ra/sm/ecrasmknkfvubsngt7c_dcrtu1w.png"><br><br>  Nur der Wert aus dem zweiten internen Stream wurde in den externen Stream übertragen.  Dies liegt daran, dass switchMap vom ersten abgemeldet wurde, als es den zweiten Thread erhielt. <br><br>  Wann wird das benötigt?  Zum Beispiel bei der Implementierung einer Datensuche.  Wenn die Antwort vom Server noch nicht eingetroffen ist und wir bereits eine neue Anfrage gesendet haben, ist es nicht sinnvoll, auf die vorherige zu warten. <br><br><h4>  Auspuff / AuspuffMap </h4><br>  Abgas ist das genaue Gegenteil der switchAll-Anweisung, und sein Verhalten ähnelt dem von concatAll.  Diese Methode, die den Stream abonniert, wartet auf den Abschluss.  Wenn ein neuer Stream darauf ankommt, wird er einfach verworfen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( exhaust() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/2m/x7/ur/2mx7urryxakugfc8srx3lffn92c.png"><br><br>  Im obigen Beispiel haben wir keine Zwei erhalten, da der Bediener in diesem Moment auf die Fertigstellung des ersten Threads wartete und einfach den zweiten Thread fallen ließ. <br><br>  Ich denke, viele haben eine Frage, wann ein solches Verhalten erforderlich sein kann.  Ein gutes Beispiel ist das Anmeldeformular.  Es ist nicht sinnvoll, mehrere Anforderungen an den Server zu senden, bis die aktuelle abgeschlossen ist. <br><br><h4>  Wir schließen den Antrag ab </h4><br>  Wir erinnern uns an das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Beispiel</a> aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Artikel</a> .  Darin haben wir eine Suche auf GitHub implementiert und den mergeMap-Operator verwendet, um Anforderungen an den Server zu senden.  Jetzt kennen wir die Funktionen dieses Operators. Ist er in unserem Fall wirklich geeignet? <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Nehmen wir an, dass der GitHub-Server stark überlastet ist und die Verarbeitung unserer Antwort viel Zeit in Anspruch nimmt.  Was könnte in diesem Fall möglicherweise schief gehen? <br><br>  Angenommen, ein Benutzer hat einige Daten eingegeben, nicht auf eine Antwort gewartet und neue eingegeben.  In diesem Fall senden wir die zweite Anfrage an den Server.  Niemand garantiert jedoch, dass die Antwort auf die erste Anfrage früher kommt. <br><br>  Da es dem mergeMap-Operator egal ist, in welcher Reihenfolge die internen Threads verarbeitet werden sollen, werden die tatsächlichen Daten gelöscht, wenn die erste Anforderung später als die zweite ausgeführt wird.  Daher schlage ich vor, die mergeMap-Methode durch switchMap zu ersetzen: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Wenn der Benutzer neue Daten eingibt, wird switchMap den vorherigen Stream abbestellen und den neuen abonnieren. <br><br>  Es ist erwähnenswert, dass unsere http-Anfrage so lange hängen bleibt, bis der Server eine Antwort darauf gibt.  Da wir uns jedoch vom internen Stream abgemeldet haben, fällt die Antwort nicht in den externen Stream. <br><br>  <b>Hinweis</b> : Wenn Sie mit Angular arbeiten und HttpClient für die Arbeit mit http verwenden, können Sie sich keine Sorgen machen, die Anforderung selbst abzubrechen.  HttpClient kann dies für Sie tun, wenn Sie sich abmelden. <br><br><h4>  Abbrechen http </h4><br>  Die Abruf-API kann die http-Anforderung mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">AbortController abbrechen</a> .  In Kombination mit dem switchMap-Operator spart diese Funktionalität Benutzerverkehr. <br><br>  Lassen Sie uns unser Beispiel ein wenig umschreiben.  Und erstellen Sie eine Methode, die den Abruf in Observable umschließt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createCancellableRequest = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      const controller = new AbortController(); const signal = controller.signal; return new Observable(observer =&gt; { fetch(url, { signal }) .then(response =&gt; { if (response.ok) { return response.json(); } throw new Error(''); }) //     .then(result =&gt; observer.next(result)) //   .then(() =&gt; observer.complete()) //   ,     .catch(error =&gt; observer.error(error)); // ,    return () =&gt; { //   controller.abort(); }; }); };</span></span></code> </pre><br>  Ändern Sie auch die Methode getUsersRepsFromApi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createCancellableRequest(url); }</code> </pre><br>  Jetzt gibt die Methode nicht vielversprechend zurück, sondern beobachtbar.  Daher entfernen wir den Wrapper in switchMap: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getUsersRepsFromAPI(value).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([]) ) )</code> </pre><br>  <b>Hinweis</b> : In RxJS Version 6.5 wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">fromFetch-Anweisung</a> hinzugefügt, die selbst die Abbruchmethode unter der Haube aufruft, sodass Sie kein eigenes „Fahrrad“ mehr schreiben müssen. <br><br>  Das ist alles!  Den gesamten Beispielcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier</a> . <br><br><h4>  Fazit </h4><br>  Heute haben wir uns angesehen, was HOO ist und einige sehr nützliche Operatoren aus dieser Kategorie.  Natürlich waren diese weit von allen entfernt.  Für detailliertere und detailliertere Informationen empfehle ich den Besuch der RxJS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Dokumentation</a> . <br><br>  Im nächsten Artikel möchte ich untersuchen, was der Unterschied zwischen heißen und kalten Observablen ist. <br><br>  Schließlich: Verwenden Sie das Abonnement nicht im Abonnement, da es HOO gibt! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450050/">https://habr.com/ru/post/de450050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450036/index.html">Summ3r 0f h4ck: Praktikum Digital Security 2019</a></li>
<li><a href="../de450040/index.html">Neues Unternehmen wird OpenJDK 8 und 11 unterstützen - wir verstehen die Situation</a></li>
<li><a href="../de450042/index.html">Russisches erweitertes Tastaturlayout</a></li>
<li><a href="../de450044/index.html">Auf der Suche nach einem Problem am falschen Ort</a></li>
<li><a href="../de450048/index.html">Anmerkungen zu Änderungen des Bundesgesetzes Nr. 149-ФЗ „Über Information, Informationstechnologien und Informationsschutz“</a></li>
<li><a href="../de450054/index.html">Hacke den JWT-Token</a></li>
<li><a href="../de450056/index.html">Achten Sie auf Nummer 2: Zusammenfassung der Artikel zu Produktdenken, Verhaltenspsychologie und persönlicher Produktivität</a></li>
<li><a href="../de450058/index.html">Der Lebenslauf dieses Typen</a></li>
<li><a href="../de450060/index.html">Wie ich herausfand, dass mein Visum noch nicht fertig ist, eine Nachricht in Slack</a></li>
<li><a href="../de450062/index.html">Wiederherstellung des Kreislaufs im Gehirn wenige Stunden nach dem Tod</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>