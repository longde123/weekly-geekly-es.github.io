<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüöí üë©üèø‚Äçü§ù‚Äçüë©üèª ü§∞ Lesen Sie Scaladoc f√ºr ‚Äûoffensichtliche‚Äú Erfassungsmethoden? Oder warum Faulheit nicht immer gut ist üôÜüèª üòÅ üßñüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie nicht wissen, wie sie sich unterscheiden 


someMap.map{ case (k, v) => k -> foo(v)}  


 und 


 someMap.mapValues(foo)  


 Mit Ausnahme de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lesen Sie Scaladoc f√ºr ‚Äûoffensichtliche‚Äú Erfassungsmethoden? Oder warum Faulheit nicht immer gut ist</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/430538/"><p>  Wenn Sie nicht wissen, wie sie sich unterscheiden </p><br><pre><code class="scala hljs">someMap.map{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (k, v) =&gt; k -&gt; foo(v)}</code> </pre> <br><p>  und </p><br><pre> <code class="scala hljs">someMap.mapValues(foo)</code> </pre> <br><p>  Mit Ausnahme der Syntax oder wenn Sie bezweifeln / nicht wissen, zu welchen schlimmen Konsequenzen dieser Unterschied f√ºhren kann und wo die <code>identity</code> , ist dieser Artikel f√ºr Sie. </p><br><p>  Nehmen Sie andernfalls an der Umfrage am Ende des Artikels teil. </p><a name="habracut"></a><br><h2 id="nachnem-s-prostogo">  Beginnen wir mit einem einfachen </h2><br><p>  Versuchen wir dumm, ein Beispiel vor dem Kat zu nehmen und zu sehen, was passiert: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"key1"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"value1"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"value2"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(value: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = value + <span class="hljs-string"><span class="hljs-string">"_changed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMap = someMap.map{<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (k,v) =&gt; k -&gt; foo(v)} <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMapValues = someMap.mapValues(foo) println(<span class="hljs-string"><span class="hljs-string">s"resultMap: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMap</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"equality: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${resultMap == resultMapValues}</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Dieser Code wird voraussichtlich gedruckt </p><br><pre> <code class="plaintext hljs">resultMap: Map(key1 -&gt; value1_changed, key2 -&gt; value2_changed) resultMapValues: Map(key1 -&gt; value1_changed, key2 -&gt; value2_changed) equality: true</code> </pre> <br><p>  Ungef√§hr auf dieser Ebene <code>mapValues</code> das Verst√§ndnis der <code>mapValues</code> Methode in den fr√ºhen Phasen des Lernens von Scala: Ja, es gibt eine solche Methode. Es ist praktisch, Werte in <code>Map</code> zu √§ndern, wenn sich die Schl√ºssel nicht √§ndern.  Und wirklich, was gibt es sonst noch zu denken?  Beim Namen der Methode ist alles offensichtlich, das Verhalten ist klar. </p><br><h2 id="primery-poslozhnee">  Kompliziertere Beispiele </h2><br><p>  Lassen Sie uns unser Beispiel ein wenig modifizieren (ich werde explizit Typen schreiben, damit Sie nicht glauben, dass es eine Art Muggel mit Implikationen gibt): </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueHolder</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">someMap</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"key1"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"value1"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"value2"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(value: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span> = <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span>(value) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span>] = someMap.map{<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (k,v) =&gt; k -&gt; foo(v)} <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMapValues: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span>] = someMap.mapValues(foo) println(<span class="hljs-string"><span class="hljs-string">s"resultMap: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMap</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"equality: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${resultMap == resultMapValues}</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Und solcher Code wird nach dem Start erzeugt </p><br><pre> <code class="plaintext hljs">resultMap: Map(key1 -&gt; ValueHolder(value1), key2 -&gt; ValueHolder(value2)) resultMapValues: Map(key1 -&gt; ValueHolder(value1), key2 -&gt; ValueHolder(value2)) equality: true</code> </pre> <br><p>  Es ist ziemlich logisch und offensichtlich.  "Alter, es ist Zeit, dem Artikel auf den Grund zu gehen!"  - Der Leser wird sagen.  Lassen Sie uns die Schaffung unserer Klasse von √§u√üeren Bedingungen abh√§ngig machen und ein paar einfache √úberpr√ºfungen auf Idiotie hinzuf√ºgen: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueHolder</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, seed: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span> = <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span>(value, <span class="hljs-type"><span class="hljs-type">Random</span></span>.nextInt()) ... println(<span class="hljs-string"><span class="hljs-string">s"simple assert for resultMap: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${resultMap.head == resultMap.head}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"simple assert for resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${resultMapValues.head == resultMapValues.head}</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Am Ausgang erhalten wir: </p><br><pre> <code class="plaintext hljs">resultMap: Map(key1 -&gt; ValueHolder(value1,1189482436), key2 -&gt; ValueHolder(value2,-702760039)) resultMapValues: Map(key1 -&gt; ValueHolder(value1,-1354493526), key2 -&gt; ValueHolder(value2,-379389312)) equality: false simple assert for resultMap: true simple assert for resultMapValues: false</code> </pre> <br><p>  Es ist logisch, dass die Ergebnisse jetzt nicht gleich, sondern zuf√§llig sind.  Aber warte, warum hat die zweite Behauptung <code>false</code> ?  Die Werte in <code>resultMapValues</code> haben sich wirklich ge√§ndert, aber wir haben nichts damit gemacht?  Lassen Sie uns √ºberpr√ºfen, ob alles im Inneren so ist wie es war: </p><br><pre> <code class="scala hljs">println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Und am Ausgang bekommen wir: </p><br><pre> <code class="plaintext hljs">resultMapValues: Map(key1 -&gt; ValueHolder(value1,1771067356), key2 -&gt; ValueHolder(value2,2034115276)) resultMapValues: Map(key1 -&gt; ValueHolder(value1,-625731649), key2 -&gt; ValueHolder(value2,-1815306407))</code> </pre> <br><p><img src="https://habrastorage.org/webt/q8/mu/fq/q8mufqtncnwg0ttpmvrcl6p4zxo.jpeg" alt="Bild"></p><br><h2 id="pochemu-eto-proizoshlo">  Warum ist das passiert? </h2><br><p>  Warum <code>println</code> den Wert von <code>Map</code> ? <br>  Es ist Zeit, sich bereits mit der Dokumentation der <code>mapValues</code> Methode zu <code>mapValues</code> : </p><br><pre> <code class="scala hljs"> <span class="hljs-comment"><span class="hljs-comment">/** Transforms this map by applying a function to every retrieved value. * @param f the function used to transform values of this map. * @return a map view which maps every key of this map * to `f(this(key))`. The resulting map wraps the original map without copying any elements. */</span></span></code> </pre> <br><p>  Die erste Zeile sagt uns, was wir gedacht haben - sie √§ndert <code>Map</code> und wendet die in den Argumenten √ºbergebene Funktion auf jeden Wert an.  Wenn Sie es jedoch sehr sorgf√§ltig und bis zum Ende lesen, stellt sich heraus, dass nicht die <code>Map</code> zur√ºckgegeben wird, sondern die "Kartenansicht" (Ansicht).  Und dies ist keine normale Ansicht ( <code>View</code> ), die Sie mit der <code>view</code> Methode erhalten k√∂nnen und die eine <code>force</code> Methode zur expliziten Berechnung hat.  Eine spezielle Klasse (der Code stammt aus Scala Version 2.12.7, aber f√ºr 2.11 gibt es fast dasselbe): </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MappedValues</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">f: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">V</span></span></span></span><span class="hljs-class"><span class="hljs-params"> =&gt; </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">W</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractMap</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultMap</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">U</span></span>](g: ((<span class="hljs-type"><span class="hljs-type">K</span></span>, <span class="hljs-type"><span class="hljs-type">W</span></span>)) =&gt; <span class="hljs-type"><span class="hljs-type">U</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((k, v) &lt;- self) g((k, f(v))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterator</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((k, v) &lt;- self.iterator) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (k, f(v)) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-function"> </span></span>= self.size <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span></span>(key: <span class="hljs-type"><span class="hljs-type">K</span></span>) = self.contains(key) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>(key: <span class="hljs-type"><span class="hljs-type">K</span></span>) = self.get(key).map(f) }</code> </pre> <br><p>  Wenn Sie diesen Code lesen, sehen Sie, dass nichts zwischengespeichert wird, und jedes Mal, wenn Sie auf die Werte zugreifen, werden sie neu berechnet.  Was wir in unserem Beispiel beobachten. </p><br><p>  Wenn Sie mit reinen Funktionen arbeiten und alles unver√§nderlich ist, werden Sie keinen Unterschied bemerken.  Nun, vielleicht wird die Leistung nachlassen.  Leider ist nicht alles in unserer Welt sauber und perfekt, und mit diesen Methoden k√∂nnen Sie auf den Rechen treten (was in einem unserer Projekte passiert ist, sonst w√§re dieser Artikel nicht gewesen). </p><br><p>  Nat√ºrlich sind wir nicht die Ersten, die darauf sto√üen.  Bereits 2011 wurde bei dieser Gelegenheit ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schwerwiegender Fehler</a> behoben (und zum Zeitpunkt des Schreibens ist er als offen markiert).  Es wird auch die <code>filterKeys</code> Methode erw√§hnt, die genau dieselben Probleme aufweist, da sie nach demselben Prinzip implementiert ist. </p><br><p>  Dar√ºber hinaus h√§ngt seit 2015 ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ticket</a> , um Inspektionen zu IntelliJ Idea hinzuzuf√ºgen. </p><br><h2 id="chto-delat">  Was zu tun ist? </h2><br><p>  Die einfachste L√∂sung ist, diese Methoden dumm nicht anzuwenden, weil  namentlich ist ihr Verhalten meiner Meinung nach sehr offensichtlich. </p><br><p>  Eine etwas bessere Option ist das Aufrufen der <code>map(identity)</code> . <br>  <code>identity</code> , wenn jemand nicht wei√ü, ist dies eine Funktion aus der Standardbibliothek, die einfach ihr Eingabeargument zur√ºckgibt.  In diesem Fall wird die Hauptarbeit von der <code>map</code> erledigt, die explizit eine normale <code>Map</code> .  Lassen Sie uns nur f√ºr den Fall √ºberpr√ºfen: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMapValues: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">ValueHolder</span></span>] = someMap.mapValues(foo).map(identity) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"simple assert for resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${resultMapValues.head == resultMapValues.head}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Am Ausgang bekommen wir </p><br><pre> <code class="plaintext hljs">resultMapValues: Map(key1 -&gt; ValueHolder(value1,333546604), key2 -&gt; ValueHolder(value2,228749608)) simple assert for resultMapValues: true resultMapValues: Map(key1 -&gt; ValueHolder(value1,333546604), key2 -&gt; ValueHolder(value2,228749608)) resultMapValues: Map(key1 -&gt; ValueHolder(value1,333546604), key2 -&gt; ValueHolder(value2,228749608))</code> </pre> <br><p>  Alles ist gut :) </p><br><p>  Wenn Sie immer noch Faulheit hinterlassen m√∂chten, ist es besser, den Code so zu √§ndern, dass er offensichtlich ist.  Sie k√∂nnen eine implizite Klasse mit einer Wrapper-Methode f√ºr <code>mapValues</code> und <code>filterKeys</code> , die einen neuen Namen <code>filterKeys</code> , der f√ºr sie verst√§ndlich ist.  Oder verwenden Sie explizit <code>.view</code> und arbeiten Sie mit einem Iterator von Paaren. </p><br><p>  Dar√ºber hinaus lohnt es sich, die Entwicklungsumgebung / -regel in einem statischen Analyseger√§t / an einer anderen Stelle zu √ºberpr√ºfen, um vor der Verwendung dieser Methoden zu warnen.  Weil es besser ist, jetzt ein wenig Zeit damit zu verbringen, als auf den Rechen zu treten und die Konsequenzen f√ºr eine lange Zeit sp√§ter zu harken. </p><br><h2 id="kak-vy-esche-mozhete-nastupit-na-grabli-i-kak-nastupili-na-nih-my">  Wie sonst k√∂nnen Sie auf den Rechen treten und wie sind wir auf sie getreten? </h2><br><p>  Neben dem Fall mit der Abh√§ngigkeit von √§u√üeren Bedingungen, den wir in den obigen Beispielen beobachtet haben, gibt es andere Optionen. </p><br><p>  Zum Beispiel ein ver√§nderlicher Wert (beachten Sie, hier ist auf einen oberfl√§chlichen Blick alles "unver√§nderlich"): </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someMap1 = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"key1"</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AtomicInteger</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-string"><span class="hljs-string">"key2"</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AtomicInteger</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someMap2 = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"key1"</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AtomicInteger</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-string"><span class="hljs-string">"key2"</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AtomicInteger</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span></span>(value: <span class="hljs-type"><span class="hljs-type">AtomicInteger</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = value.incrementAndGet() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>] = someMap1.map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (k, v) =&gt; k -&gt; increment(v) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultMapValues: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>] = someMap2.mapValues(increment) println(<span class="hljs-string"><span class="hljs-string">s"resultMap (1): </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMap</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues (1): </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMap (2): </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMap</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">s"resultMapValues (2): </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$resultMapValues</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p>  Dieser Code erzeugt dieses Ergebnis: </p><br><pre> <code class="plaintext hljs">resultMap (1): Map(key1 -&gt; 1, key2 -&gt; 1) resultMapValues (1): Map(key1 -&gt; 1, key2 -&gt; 1) resultMap (2): Map(key1 -&gt; 1, key2 -&gt; 1) resultMapValues (2): Map(key1 -&gt; 2, key2 -&gt; 2)</code> </pre> <br><p>  Als ich wieder auf <code>someMap2</code> zugegriffen <code>someMap2</code> , haben <code>someMap2</code> ein lustiges Ergebnis <code>someMap2</code> . </p><br><p>  Die Probleme, die auftreten k√∂nnen, wenn <code>mapValues</code> und <code>filterKeys</code> <code>mapValues</code> verwendet werden, k√∂nnen zu Leistungseinbu√üen, erh√∂htem Speicherverbrauch und / oder erh√∂hter Belastung des GC hinzugef√ºgt werden. Dies h√§ngt jedoch st√§rker von bestimmten F√§llen ab und ist m√∂glicherweise nicht so kritisch. </p><br><p>  Sie sollten auch die <code>toSeq</code> Methode des Iterators zum Sparschwein √§hnlicher Rechen hinzuf√ºgen, wodurch ein fauler <code>Stream</code> . </p><br><p>  Wir <code>mapValues</code> versehentlich auf <code>mapValues</code> .  Es wurde in einer Methode verwendet, die mithilfe von Reflection eine Reihe von Handlern aus der Konfiguration erstellte: Die Schl√ºssel waren die Bezeichner der Handler, und der Wert waren ihre Einstellungen, die dann in die Handler selbst konvertiert wurden (Klasseninstanz wurde erstellt).  Da die Handler nur aus reinen Funktionen bestanden, funktionierte alles problemlos, hatte aber auch keinen merklichen Einfluss auf die Leistung (nach dem Rechen nahmen wir Messungen vor). </p><br><p>  Aber einmal musste ich in einem der Handler ein Semaphor erstellen, damit nur ein Handler eine schwere Funktion ausf√ºhrt, deren Ergebnis zwischengespeichert und von anderen Handlern verwendet wird.  Und dann begannen Probleme in der Testumgebung - g√ºltiger Code, der lokal gut funktionierte, st√ºrzte aufgrund von Problemen mit dem Semaphor ab.  Der erste Gedanke bei der Inoperabilit√§t der neuen Funktionalit√§t ist nat√ºrlich, dass die Probleme damit verbunden sind.  Wir haben uns lange damit besch√§ftigt, bis wir zu dem Schluss kamen, dass "ein Spiel, warum werden verschiedene Instanzen von Handlern verwendet?"  und nur auf der Stapelspur fanden sie, dass wir <code>mapValues</code> . </p><br><p>  Wenn Sie mit Apache Spark arbeiten, k√∂nnen Sie auf ein √§hnliches Problem <code>.mapValues</code> wenn Sie pl√∂tzlich feststellen, dass Sie einen elementaren Code mit <code>.mapValues</code> abfangen k√∂nnen </p><br><pre> <code class="plaintext hljs">java.io.NotSerializableException: scala.collection.immutable.MapLike$$anon$2</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackoverflow.com/questions/32900862/map-can-not-be-serializable-in-scala</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://issues.scala-lang.org/browse/SI-7005</a> <br>  Aber <code>map(identity)</code> l√∂st das Problem, und normalerweise gibt es keine Motivation / Zeit, tiefer zu graben. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Fehler k√∂nnen an den unerwartetsten Stellen lauern - selbst bei Methoden, die zu 100% offensichtlich erscheinen.  Insbesondere ist dieses Problem meiner Meinung nach mit einem schlechten Methodennamen und einem unzureichend strengen R√ºckgabetyp verbunden. </p><br><p>  Nat√ºrlich ist es wichtig, die Dokumentation f√ºr alle in der Standardbibliothek verwendeten Methoden zu studieren, aber es ist nicht immer offensichtlich und ehrlich gesagt gibt es nicht immer genug Motivation, um √ºber die "offensichtlichen Dinge" zu lesen. </p><br><p>  Lazy Computing allein ist ein cooler Witz, und der Artikel ermutigt sie in keiner Weise, aufzugeben.  Wenn jedoch Faulheit nicht offensichtlich ist, kann dies zu Problemen f√ºhren. </p><br><p>  <code>mapValues</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erschien</a> das Problem mit <code>mapValues</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits bei Habr√©</a> in der √úbersetzung, aber pers√∂nlich war dieser Artikel, den ich sehr schlecht in meinen Kopf gesetzt hatte, weil  Es gab viele bereits bekannte / grundlegende Dinge und es war nicht ganz klar, wie gef√§hrlich die Verwendung dieser Funktionen sein k√∂nnte: </p><br><blockquote>  Die filterKeys-Methode umschlie√üt die Quelltabelle, ohne Elemente zu kopieren.  Daran ist nichts auszusetzen, aber Sie erwarten dieses Verhalten kaum von filterKeys </blockquote><p>  Das hei√üt, es gibt eine Bemerkung √ºber unerwartetes Verhalten, und gleichzeitig k√∂nnen Sie auch ein wenig auf den Rechen treten, anscheinend wird dies als unwahrscheinlich angesehen. </p><br><p>  ‚Üí Der gesamte Code aus dem Artikel befindet sich in dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430538/">https://habr.com/ru/post/de430538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430528/index.html">Programmieren mit PyUSB 1.0</a></li>
<li><a href="../de430530/index.html">Mock-Server f√ºr die mobile Testautomatisierung</a></li>
<li><a href="../de430532/index.html">Sicherheit in iOS-Apps</a></li>
<li><a href="../de430534/index.html">Erstellen einer Vorlage f√ºr Zabbix am Beispiel des DVR Trassir SDK</a></li>
<li><a href="../de430536/index.html">Entwerfen von Fensterfunktionen, die zu einer Einheit mit einem bestimmten √úberlappungsgrad zusammengefasst werden</a></li>
<li><a href="../de430542/index.html">Offenes Webinar ‚ÄûInfrastruktur als Code‚Äú</a></li>
<li><a href="../de430546/index.html">"Es wurde angenommen, dass der Code durch UML-Diagramme ersetzt wird, aber es besteht keine Notwendigkeit zum Testen": ein Interview mit Alexei Barantsev</a></li>
<li><a href="../de430548/index.html">Interrupts von externen Ger√§ten in einem x86-System. Teil 1. Die Entwicklung der Interrupt-Controller</a></li>
<li><a href="../de430550/index.html">Aufbau eines reaktiven Komponentensystems mit Kotlin</a></li>
<li><a href="../de430552/index.html">Start des Tages (September-Oktober 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>