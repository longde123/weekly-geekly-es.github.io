<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßõüèø üëèüèº üë®üèª‚Äçüé§ Programaci√≥n e intercambio de datos con ARDUINO a trav√©s de WIFI a trav√©s de ESP8266 Parte uno ‚úîÔ∏è üë®üèº‚Äçüé§ üë®üèª‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al igual que muchos otros productos caseros, utilizo regularmente microcontroladores AVR para todo tipo de manualidades de aficionados. Y gracias al c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programaci√≥n e intercambio de datos con ARDUINO a trav√©s de WIFI a trav√©s de ESP8266 Parte uno</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/406559/">  Al igual que muchos otros productos caseros, utilizo regularmente microcontroladores AVR para todo tipo de manualidades de aficionados.  Y gracias al concepto Arduino, estas artesan√≠as ahora tambi√©n adquieren un aspecto elegante.  De hecho, por unos 300-400 rublos, obtenemos una placa multicapa en miniatura con una m√°scara, serigraf√≠a y con los perif√©ricos para el microcontrolador completamente reproducidos (¬°adem√°s, en la versi√≥n SMD!).  No estoy hablando de todo tipo de complementos de la misma serie "Arduino": sensores, controladores, pantallas y conjuntos completos, los perif√©ricos adicionales que tanto necesitamos.  Y de nuevo, todo tambi√©n es econ√≥mico y tiene un excelente rendimiento.  Pr√°cticamente ya no es necesario criar algo y soldar en la "rodilla". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/dcc/5a0/51d/dcc5a051d0554a7a86eaf37d51702ce6.jpg"></div><br>  Pero todas estas diversas manualidades de aficionados, naturalmente, requieren <b>una programaci√≥n preliminar.</b>  Y m√°s adelante, con varias mejoras, constantemente tengo que actualizar estas manualidades.  Est√° claro que es m√°s conveniente hacer esto de forma remota que arrastrarlos constantemente a un programador regular.  En general, gracias a la misma plataforma Arduino, hay muchas opciones aqu√≠: Bluetooth, ZigBee, un canal de radio con su protocolo personal, IR e incluso Wi-Fi.  Todos ellos le permiten establecer contacto inal√°mbrico con su microcontrolador.  Pero nos detendremos en la √∫ltima opci√≥n.  Hay cuatro razones principales: <br><br>  1: moderno, el Internet de las cosas! <br><br>  2: hay un enrutador inal√°mbrico en cada apartamento, registre sus dispositivos en la red dom√©stica y ¬°listo! <br><br>  3: tus artesan√≠as dan un salto revolucionario en su desarrollo;  no solo se pueden programar a distancia, sino que tambi√©n se pueden comunicar con el mundo que los rodea: el reloj electr√≥nico toma independientemente la hora exacta de los relojes del servidor NTP, los dispositivos ejecutivos se controlan desde el otro extremo de la ciudad o el pa√≠s, los dispositivos de registro almacenan los datos acumulados en nube, etc.  etc. <br><br>  4: hay una maravillosa serie de chips ESP8266 en los que <s>no es muy</s> f√°cil implementar todo esto. <br><a name="habracut"></a><br>  Adem√°s, en este art√≠culo, se desmontar√° y demostrar√° el uso de un brazo mec√°nico en servos, programaci√≥n remota e intercambio de datos con una PC (o lo que sea) con dispositivos basados ‚Äã‚Äãen microcontroladores AVR.  Quiero se√±alar de inmediato que todos los programas enumerados a continuaci√≥n son puramente demostrativos y no tienen valor comercial.  Por lo tanto, no se aceptan reclamos, como por qu√© el programador est√° tan castrado y mal funcional o por qu√© no hay servicios adicionales en todas partes.  Como los c√≥digos est√°n abiertos, cualquiera puede terminarlos a su discreci√≥n, pero todav√≠a tengo suficiente para trabajar. <br><br>  Se supone que el lector ya est√° familiarizado con los m√≥dulos Arduino (escudos) y la conexi√≥n y el firmware del ESP8266.  De hecho, se ha publicado una gran cantidad de material en la Web que explica los conceptos b√°sicos del trabajo con estos dispositivos y no quisiera repetir aqu√≠.  Para los principiantes, al final del art√≠culo hay una lista de enlaces √∫tiles sobre estos temas, donde puedes encontrar mucha informaci√≥n <s>, por qu√© no funciona todo para ti</s> .  Desde mi experiencia como ex ingeniero electr√≥nico, puedo declarar responsablemente que el 99% de los problemas son los siguientes: <br><br>  1. Malos contactos.  Dado que los escudos "Arduino" implican cambiar entre s√≠ a trav√©s de cables del tipo "padre-madre", y no a trav√©s de la soldadura, muy a menudo algo, en alg√∫n lugar, desaparece.  Compru√©balo  Y de hecho, como dicen, la electr√≥nica es la ciencia de los contactos. <br><br>  2. Problemas de energ√≠a.  No suministre 5 voltios de potencia donde se requiere 3.3.  A veces, el humo proviene del ESP8266.  Aunque, por otro lado, digiere se√±ales l√≥gicas de dispositivos de cinco voltios sin problemas. <br><br>  3. Problemas con suficiente potencia.  ESP8266 tiene una naturaleza vil y a veces puede consumir casi trescientos miliamperios, aunque antes de eso podr√≠a satisfacerse con treinta.  En consecuencia, el estabilizador fr√°gil de 3,3 voltios de la placa "Arduino", al que no puede sumar nada, est√° conectado, inmediatamente se hunde a valores microsc√≥picos.  Y no puedes entender por qu√© est√° funcionando, entonces no. <br><br>  4. Confusi√≥n con conclusiones.  Siempre verifique qu√© se√±ales van a d√≥nde.  El receptor RXD debe conectarse al transmisor TXD, as√≠ como el TXD a RXD, pero MOSI debe conectarse a MOSI y MISO a MISO, y as√≠ sucesivamente. <br><br>  5. No conf√≠e en las resistencias pull-up en circuito en el ESP8266, siempre lleve los cables a cero o potencia, a trav√©s de resistencias externas de 5-10 kilo-ohmios, y no solo un puente.  De lo contrario, puede, en el mejor de los casos, obtener un consumo de corriente sin precedentes y luego oler el desagradable olor a pl√°stico quemado. <br><br>  6. Baj√≠os de software.  Dado que el software para usuarios individuales est√° escrito por los mismos entusiastas, las fallas del firmware en s√≠ y los errores aparecen peri√≥dicamente al actualizar las versiones del mismo firmware.  Se trata arrastr√°ndose en los foros relevantes, a veces incluso en ingl√©s.  Algunos compa√±eros incluso afirmaron que el chip ESP en s√≠ estaba h√∫medo como el clima en San Petersburgo, pero por otro lado tambi√©n exist√≠a la opini√≥n de que desde 2014 (el a√±o en que se lanz√≥ por primera vez), la situaci√≥n con esto ha mejorado dram√°ticamente (a diferencia del clima). <br><br>  7. Fallas misteriosas.  Este es un fen√≥meno raro, pero que consume nervios.  Por ejemplo, no ten√≠a un dispositivo remoto "Arduino".  M√°s bien, sucedi√≥ pero con errores.  Pero funcion√≥ sin errores si un cable del programador colgaba de √©l (pero sin el programador mismo).  "AHA", me dije, y solde un condensador de 15 pF entre el pin de transferencia de datos y el pin de sincronizaci√≥n.  Todo funcion√≥.  Pero el d√≠a mat√≥. <br><br>  Entonces, comencemos con el m√°s simple.  Tenemos un brazo mec√°nico MechArm (pero no el que Howard Volovits ensambl√≥) fabricado en China y una computadora personal con Windows.  La tarea es flashear remotamente el programa y administrarlo desde la computadora. <br><img src="https://habrastorage.org/web/296/4e6/530/2964e653055742f1a6641f06f2d767b1.jpg"><br>  Para el controlador de control, tomamos una linda bufanda en miniatura Arduino Nano con una piedra ATmega328P.  Esta placa est√° perfectamente insertada en el brazo mec√°nico. <br><img src="https://habrastorage.org/web/45f/320/2e5/45f3202e545d485faa6d1b5fb71bc574.jpg"><br>  Ahora decidimos c√≥mo lo programaremos.  Hay tres m√©todos principales que son m√°s adecuados para el firmware remoto: a trav√©s de la interfaz SPI, a trav√©s del cargador de arranque incorporado, a trav√©s del puerto JTAG. <br><br>  La opci√≥n m√°s f√°cil es, por supuesto, el gestor de arranque incorporado (gestor de arranque).  Esta es una memoria prerregistrada en FLASH, un programa que recibe un c√≥digo de acuerdo con cierto protocolo (por ejemplo, usando el UART m√°s simple) y lo escribe en la ubicaci√≥n del programa cargado con comandos especiales.  Esto funciona, por ejemplo, el gestor de arranque ARDUINO IDE.  Despu√©s de un reinicio o inicio, el gestor de arranque espera un tiempo para recibir datos y, si no espera, comienza la ejecuci√≥n del programa desde la direcci√≥n cero.  Si llegan los datos, los escribe en la secci√≥n del programa.  Despu√©s del siguiente reinicio, el programa descargado comienza a ejecutarse.  En detalle, tal vez lo describ√≠ incorrectamente, pero la esencia es solo eso.  Como resultado, solo necesitamos tres salidas para la programaci√≥n: receptor RTD, reinicio RESET y tierra GND.  En general, el transmisor TRD tambi√©n se usa para verificar el programa grabado, pero para aplicaciones de demostraci√≥n simples (no para una planta de energ√≠a nuclear), se puede omitir la verificaci√≥n. <br><br>  El cargador en s√≠ est√° escrito en lenguaje ensamblador, hay ejemplos de cargadores simples en hojas de datos en AVR.  Puede excavar un gestor de arranque existente si est√° en el dominio p√∫blico y simplemente usarlo de forma preparada si se conoce el protocolo por el cual funciona.  La √∫nica advertencia es que debe configurar el AVR en un modo especial mediante el parpadeo de los bits de fusibles especiales, que es realizado por un programador normal, y luego tambi√©n puede coser el cargador de arranque en la memoria del microcontrolador (es decir, no puede hacerlo sin un programador una vez). <br><br>  La segunda opci√≥n es programar a trav√©s de la interfaz serial SPI.  Aqu√≠ no hay un gestor de arranque interno, pero programamos enviando comandos especiales y luego datos a trav√©s de la interfaz mencionada anteriormente.  Aqu√≠ tenemos un gestor de arranque externo, pero a√∫n necesita escribirlo.  Adem√°s de RESET y GND, se utilizan cuatro salidas MOSI adicionales para la transmisi√≥n, datos MISO, sincronizaci√≥n SLK, selecci√≥n de chips CS.  Pero en general, tambi√©n puede eliminar MISO y CS.  Solo se aceptar√°n datos (entonces no habr√° verificaci√≥n del programa), y solo tenemos un cristal. <br><br>  Cada enfoque tiene sus pros y sus contras (y no consider√© JTAG en absoluto, ya que la vida humana es corta).  Pero al final, me inclin√© hacia SPI porque era demasiado flojo para escribir en ensamblador, pero no encontr√© cargadores de arranque listos para usar (simplemente no me ve√≠a bien). <br><br>  Para construir un canal inal√°mbrico, yo, como ya se mencion√≥, eleg√≠ el chip ESP8266 actualmente ampliamente conocido: un microcontrolador, o m√°s bien, un SoC (System-on-Chip) completo del fabricante chino Espressif con una interfaz Wi-Fi.  Adem√°s de Wi-Fi, se distingue por la capacidad de ejecutar programas desde una memoria flash externa.  Y espec√≠ficamente para mi proyecto, tom√© el ESP8266-07 con 512 KB de memoria a bordo. <br><br><img src="https://habrastorage.org/web/e50/03b/ab1/e5003bab173c4deca207971fd82261f0.jpg"><br>  En general, cualquier ESP8266 es adecuado cuando hay patas adicionales para implementar SPI.  Por lo tanto, el ESP8266-01 m√°s simple no nos conviene, ya que tiene muy pocas patas para puertos de entrada / salida.  Pero, por otro lado, la diferencia de precio es inferior a cien rublos, y est√°n disponibles por igual.  Bueno, las grandes placas de depuraci√≥n con ESP, donde un mont√≥n de perif√©ricos son convenientes, tampoco son adecuados para nosotros, ya que no entran donde queremos empujarlos en nuestro brazo mec√°nico. <br><br>  La esencia global de la idea en general fue la siguiente.  El cuerpo del programa cargado en el microcontrolador se transfiere de la computadora al ESP de forma inal√°mbrica a trav√©s de WI-FI (dentro de su red dom√©stica).  Y ESP ya por cable utilizando la interfaz SPI escribe este programa directamente en la memoria FLASH del microcontrolador.  Luego, naturalmente, lo restablece y permite que se ejecute el programa cargado.  Adem√°s, el ESP debe tener una unidad independiente, que tambi√©n gestiona el intercambio de datos con el microcontrolador, ya que queremos no solo programar, sino tambi√©n intercambiar datos con √©l.  En particular, para un proyecto con MechArm, despu√©s de grabar el programa, todav√≠a transmitimos se√±ales de servocontrol para poner esta mano en movimiento.  Por lo tanto, en el ESP en s√≠, es aconsejable que creemos un servidor TCP para la transferencia de programas y un servidor UDP para controlar MechArm.  En consecuencia, estos servidores se unen a la red dom√©stica y escuchan atentamente si hay alguien que quiera cargar un nuevo c√≥digo en MechaArm o enviarlo a alguien. <br><br>  Entonces, encontr√© en la Web que el firmware ya le permite programar AVR a trav√©s del aire, pero el problema principal es que para qu√© m√°s este firmware ya no se puede usar.  Despu√©s de la programaci√≥n, nos gustar√≠a comunicarnos con AVR tambi√©n de forma remota. <br><br>  Qu√© software usaremos: <br><br>  Para PC, escrib√≠ todo en JAVA, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IntelliJ IDEA</a> .  Pero b√°sicamente, puede hacer cualquier cosa, lo principal para nosotros es escribir un cliente que enviar√° el programa para flashear AVR a ESP8266. <br><br>  Yo mismo escribo programas para AVR en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ATMEL STUDIO</a> , en lenguaje C, rara vez en ensamblador.  No utilizo bocetos de Arduino en principio, casi cualquier biblioteca necesaria est√° escrita en una o dos horas, con una comprensi√≥n completa de su trabajo.  Prob√© bocetos, pero siempre que no tenga un sistema operativo en el AVR, los bocetos le quitar√°n perif√©ricos a un amigo y fallar√°n regularmente.  S√≠, el IDE Arduino en s√≠ mismo, en comparaci√≥n con ATMEL STUDIO, es, por supuesto, algo muy primitivo.  Pero aqu√≠ la pregunta es, por supuesto, controvertida, para las humanidades y los escolares ser√° m√°s divertido y m√°s f√°cil, probablemente, con bocetos. <br><br>  Para programar el ESP8266, utilic√© el firmware NodeMCU y escrib√≠ programas en Lua.  No, me encantar√≠a escribir en Java y C, pero no hay ninguno en ESP.  El lenguaje Lu aplicado a nuestra tarea no es dif√≠cil, dominar un par de trivialidades.  Y en realidad, para descargar programas y depurarlos en ESP, tom√© el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IDE ESPlorer</a> .  Un producto dom√©stico gratuito (pero puede donarlo al autor), que por supuesto no se puede comparar con los medios mencionados anteriormente, pero como dice el caballo de regalo ... Pero para usar ESPlorer y escribir en LUA, primero tenemos que cambiar el firmware base (suministrado por el fabricante) en el chip ESP8266 a uno nuevo  El programa PyFlasher NODE MCU nos ayudar√° en esta empresa.  Quiero decir, ayudar√° a volver a actualizarlo.  Y crearemos el firmware nosotros mismos y lo pondremos en manos del sitio web de los creadores: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NodeMCU</a> . Y puede leer m√°s sobre este proceso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠:</a> <br><br>  Todo es muy accesible y comprensible.  Agregamos soporte SPI y operaciones de bit a las bibliotecas base (en LUA, en nuestro caso, las operaciones de bit est√°n sobrecargadas e in√∫tiles).  Muchas bibliotecas no deben introducirse en el firmware de las bibliotecas, porque debido a la presencia de cualquier software en el ESP8266, queda muy poca memoria, alg√∫n tipo de pat√©tico 20 kB. <br><br>  Por supuesto, puede tomar el firmware terminado, del cual muchos ya est√°n pasando el rato en Internet, pero no lo recomiendo.  Al menos porque algunos de ellos no tienen soporte para operaciones de bits (y los necesitamos) y no hay regulaci√≥n de la velocidad de transferencia de datos a trav√©s de SPI. <br>  En consecuencia, se transmiten por defecto a una velocidad de 40 MHz dividida por alg√∫n coeficiente peque√±o y, por lo tanto, el AVR no tiene tiempo para digerirlos. <br><br>  Qui√©n es demasiado vago para crear firmware, puede descargar el m√≠o desde la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nube</a> . <br><br>  Ahora tenemos el firmware y necesitamos cargarlo en el ESP8266 en lugar del base.  Para hacer esto, necesitamos un adaptador USB simple: UART. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/48a/a27/8c7/48aa278c709446c38f3c89dd7b063bb6.jpg"></div><br>  Conectamos las patas TXD a RXD, y RXD a TXD, hacemos la conexi√≥n a tierra com√∫n, pero no utilizamos, como parec√≠a, una salida de alimentaci√≥n de 3,3 V conveniente en el adaptador.  En la mayor√≠a de los casos, el ESP8266 lo drenar√° por completo.  Por lo tanto, lo alimentamos por separado.  Luego ponemos el ESP en modo de programaci√≥n (GP0 en el suelo, si alguien lo olvid√≥) y ejecutamos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NODE MCU PyFlasher</a> . <br><br><img src="https://habrastorage.org/web/437/bd0/676/437bd067628f4a9db96466bb8d0d793b.png"><br><br>  Es importante destacar que no olvide borrar la memoria flash (s√≠, borra todos los datos), de lo contrario, dependiendo de la versi√≥n del firmware, despu√©s de la programaci√≥n, puede quedar basura innecesaria en la memoria, que a su vez arrojar√° basura en la consola durante el trabajo posterior.  Antes de eso, usaba software, donde no hab√≠a opci√≥n de borrar la memoria de antemano, estaba terriblemente atormentado, ya que nada funcionaba.  Y el ata√∫d se acaba de abrir, solo la verdad en el foro en ingl√©s de los creadores de NODE MCU. <br><br>  Habiendo adquirido el firmware necesario, ahora podemos escribir y depurar programas LUA (tambi√©n hay MicroPython, pero no lo us√©) usando API muy convenientes de NODE MCU.  Lanzamos el ya mencionado ESPlorer. <br><br><img src="https://habrastorage.org/web/8c0/a47/d1f/8c0a47d1fbfa41c8a1413852852a1513.png"><br><br>  Tambi√©n lo configuramos para que funcione con ESP8266, establecemos los par√°metros de la conexi√≥n en serie.  Todo es bastante simple y se menciona repetidamente en Internet. <br><br>  Ahora escribimos el programa en LUA, que luego cargamos en ESP8266: <br><br><div class="spoiler">  <b class="spoiler_title">Lua bootloader para AVR escrito en ESP8266</b> <div class="spoiler_text"><pre><code class="lua hljs">&lt;b&gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstrProgrammingEnable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- instruction for MC "enable programming"&lt;/b&gt; p=0 while p&lt;31 do p=p+1 pin=8 gpio.write(pin, gpio.LOW) spi.send(1, 0xAC,0x53) read = spi.recv( 1, 8) spi.send(1,0,0) gpio.write(pin, gpio.HIGH) if (string.byte(read)== 83) then print("connection established") p=33 if(p==31) then print("no connection") end end end end &lt;b&gt;function ProgrammingDisable ()&lt;/b&gt; pin=2--END OF ESET FOR MK gpio.mode(pin, gpio.INPUT) pin=8 gpio.mode(pin, gpio.INPUT) pin=5--CLK MASTER for SPI gpio.mode(pin, gpio.INPUT) pin=6--MISO MASTER for SPI gpio.mode(pin, gpio.INPUT) pin=7--MOSI MASTER for SPI gpio.mode(pin, gpio.INPUT) end &lt;b&gt;function ProgrammingEnable ()&lt;/b&gt; pin=2-- RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) pin=2--POZITIV FOR 4MSEC RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(4) gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) tmr.delay(25000) end &lt;b&gt;function InstrFlashErase() &lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0xAC,0x80,0,0) gpio.write(pin, gpio.HIGH) tmr.delay(15000) pin=2--RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(20000) gpio.write(pin, gpio.LOW) print( "FLASH is erased") InstrProgrammingEnable () end &lt;b&gt;function InstrStorePAGE(H, address, data)&lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,H,0,address,data) gpio.write(pin, gpio.HIGH) tmr.delay(500) end &lt;b&gt;function InstrWriteFLASH(page_address_low,page_address_high)&lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0x4C,page_address_high,page_address_low,0) gpio.write(pin, gpio.HIGH) tmr.delay(5000)--        end &lt;b&gt;function Programming (payload)&lt;/b&gt; pin=8--CS MASTER for SPI gpio.mode(pin, gpio.OUTPUT, gpio.PULLUP) pin=4--LED LIGHTS ON LOW gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) print(string.len(payload)) page_count = 7 --  1  for k =0 ,page_count ,1 do--quantity of pages for i=0 , 127, 2 do-- -1 address = i/2 data=payload:byte(i+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x40,address,data) -- tmr.delay(100)-- otherwise not in time write data =payload:byte(i+1+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x48,address,data) -- tmr.delay(100) end page_address_low=bit.band(k ,3)*64 -- 3   11 page_address_high=k/4+frame1024*2 tmr.delay(1000) InstrWriteFLASH(page_address_low,page_address_high) tmr.wdclr() end pin=4--LED gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) end &lt;b&gt;--MAIN BLOCK&lt;/b&gt; wifi.setmode(wifi.STATION) --wifi.sta.config(" ","") -- set SSID and password of your access point station_cfg={} tmr.delay(30000) station_cfg.ssid=" " tmr.delay(30000) station_cfg.pwd="" tmr.delay(30000) wifi.sta.config(station_cfg) tmr.delay(30000) wifi.sta.connect() tmr.delay(1000000) print(wifi.sta.status()) print(wifi.sta.getip()) while ( wifi.sta.status()~=1 ) do if( wifi.sta.status()==5) then break end end sv=net.createServer(net.TCP,30) tmr.delay(100) print("SERVER READY") sv:listen(4000,function(c) c:on("receive", function(c, payload) print(payload) if (payload =="program\r\n") then c:send("ready\r\n") print("ready for program\r\n") spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8,320,spi.FULLDUPLEX) ProgrammingEnable () tmr.delay(100) InstrProgrammingEnable () tmr.delay(100) InstrFlashErase() tmr.delay(100) frame1024=0--    st=net.createServer(net.TCP,30) st:listen(4001,function(c) c:on("receive", function(c, payload) tmr.wdclr() Programming (payload) frame1024=frame1024+1 end) end) end if (payload =="data\r\n") then c:send("ready\r\n") print("ready for data\r\n") srv=net.createServer(net.UDP) tmr.delay(1000) pin=10 gpio.write(pin, gpio.HIGH) uart.setup(0,9600,8,0,1,0) srv:listen(5000) srv:on("receive", function(srv, pl) pl=pl*1 --print(pl) uart.write(0,pl) tmr.wdclr() end) end if (payload =="stop\r\n") then if(st~=nil) then st:close() frame1024=0 ProgrammingDisable () print("stop program") end if(srv~=nil) then srv:close() print("stop data") end end end) end) end)</span></span></code> </pre> <br><br></div></div><br>  Donde las funciones relevantes realizan las siguientes acciones: <br><br>  <b>function InstrProgrammingEnable ()</b> : pone el microcontrolador en modo de programaci√≥n con un comando especial enviado a trav√©s de SPI. <br><br>  <b>function ProgrammingEnable ()</b> : solo reinicie AVR durante 25 ms antes de comenzar la programaci√≥n <br><br>  <b>function ProgrammingDisable ()</b> : despu√©s del final de la programaci√≥n, traducimos las salidas SPI en ESP8266 a un estado inactivo para que no interfieran con nosotros al ejecutar el c√≥digo en el microcontrolador (de repente se usan all√≠) <br><br>  <b>funci√≥n InstrFlashErase ()</b> : <b>borramos</b> la memoria flash del microcontrolador antes de programar.  Por qu√© esto necesita ser explicado no es necesario. <br><br>  <b>funci√≥n InstrStorePAGE (H, direcci√≥n, datos)</b> : este comando escribe el byte del programa en el b√∫fer interno del microcontrolador.  Pero este no es el registro flash en s√≠, ya que el flash se escribe aqu√≠ p√°gina por p√°gina a 128 bytes. <br><br>  <b>funci√≥n InstrWriteFLASH (page_address_low, page_address_high)</b> - pero este es un registro flash y toma tiempo, preste atenci√≥n al retraso de 5,000 Œºs. <br><br>  <b>Programaci√≥n de la funci√≥n (carga √∫til)</b> : la funci√≥n m√°s grande e importante que utiliza las funciones anteriores.  Toma el programa transmitido en fragmentos de 1024 bytes, los divide en bytes y forma las direcciones para ellos, luego lo env√≠a al microcontrolador en el b√∫fer interno e inicializa el registro flash cada 128 bytes.  Luego toma el siguiente kilobyte de c√≥digo y repite la operaci√≥n, naturalmente con un desplazamiento en las direcciones, para escribir m√°s y no sobrescribir el grabado.  Al principio, intent√© reenviar todo el programa, pero cuando supero los 6 kilobytes en ESP8266, la memoria disponible simplemente termina y se bloquea.  Un kilobyte result√≥ ser la unidad m√°s conveniente, ya que se divide cuidadosamente en partes y se transmite convenientemente a trav√©s de TCP (a√∫n necesitamos obtenerlo de la computadora).  Tampoco se necesita un tama√±o mayor, TCP, ya sabes, en la versi√≥n actual limita el paquete transmitido a 1500 o bytes (pero por alguna raz√≥n me transmitieron 1440, m√°s o menos). <br><br>  Como si nada complicado, pero algunas trampas tuvieron que ser superadas. <br><br>  El siguiente es el BLOQUE PRINCIPAL.  En ella nosotros: <br><br>  Estamos registrados en una red inal√°mbrica. <br><br>  Primero creamos un servidor TCP que escucha tres comandos: <br><br>  1. "programa" (programaremos) <br><br>  2. "datos" (cambiaremos los datos), <br><br>  3. "parar" (paramos todo). <br><br>  Si programamos, primero inicializamos el SPI y creamos otro servidor TCP que toma los datos (c√≥digo de firmware) por kilobyte y llama a las funciones de programaci√≥n del microcontrolador para ellos.  Entiendo que parece tonto crear un segundo servidor, pero esto es una necesidad, porque la API local admite la creaci√≥n de un solo socket, y necesitamos separar los comandos "programa" y "datos" con los datos transmitidos, porque a simple vista no difieren, hay bytes y Aqu√≠ hay bytes. <br><br>  Si no queremos programar, sino intercambiar datos, envi√°ndolos en nuestro caso al microcontrolador, primero enviamos la cadena "datos" a trav√©s de TCP.  En respuesta a esto, ya se crear√° un servidor UDP (le recuerdo que no gestionamos din√°micamente con una mano mec√°nica y que no necesitamos retrasos con la formaci√≥n de paquetes TCP, y de hecho enviamos un byte como un sobretono de trama TCP completo).  Y los datagramas UDP ser√°n peque√±os y se formar√°n r√°pidamente. <br><br>  Despu√©s de que se inicializa UART, y cada byte recibido de forma inal√°mbrica ya se env√≠a a trav√©s del cable TXD al microcontrolador, que est√° obligado a aceptarlo si el programa correspondiente se actualiza all√≠.  El intercambio de datos en otra direcci√≥n tampoco es dif√≠cil de organizar, pero a√∫n no lo he implementado. <br><br>  Bueno, con el comando "detener", los servidores mencionados anteriormente (excepto el primero) cierran las conexiones y el servidor principal vuelve al estado de espera de los comandos "programa" y "datos". <br><br>  Dado que la interfaz SPI se emula mediante programaci√≥n en ESP8266, puertos de E / S para se√±ales CS, CLK, MISO, MOSI, RESET (para AVR), puede usar cualquiera de los disponibles, y no los indicados en mi gestor de arranque.  Adem√°s, result√≥ que CS y MISO, en principio, tambi√©n se pueden interrumpir en este caso, funcionar√° sin ellos.  Bueno, se usa un pin en el LED incorporado en la placa ESP8266 para que a veces parpadee e indique que el programa a√∫n est√° activo. <br><br>  No se realizan comprobaciones de errores de grabaci√≥n (con la excepci√≥n de la primera solicitud a AVR, pero esta informaci√≥n simplemente se muestra en la consola), EEPROM no est√° programado, no se cosen m√°s de 32 KB; en resumen, a√∫n queda trabajo por hacer.  La velocidad de intercambio SPI es de aproximadamente 115 Kbit, en unos segundos todo se muestra, aproximadamente, como con un programador en serie regular como ISP500). <br><br>  Tome el c√≥digo, ingrese sus redes y contrase√±as, comp√≠lelo en ESplorer, ll√°melo "init" (para que comience en el reinicio) y env√≠elo a ESP8266.  Deber√≠a funcionar  En el sentido de trabajar como programador inal√°mbrico, al menos. <br><br>  Ahora nos ocuparemos de la parte administradora: una computadora personal. <br><br>  De hecho, necesitamos tomar el archivo HEX en el que se convierten sus programas escritos en el entorno ATMEL STUDIO y enviarlo a trav√©s de WI-FI al puerto de socket que conocemos (en este caso 4000).  El peque√±o inconveniente es que necesitamos un archivo BIN binario para la transferencia, y ATMEL STUDIO solo nos complace con un HEX.  Hay dos salidas;  o convi√©rtalo a formato BIN con un convertidor de programa especial, como WinHex, o h√°galo usted mismo en su programa.  Todav√≠a no lo he hecho, pero parece que no es dif√≠cil, all√≠ debes cortar el t√≠tulo y hacer otra cosa. <br><br>  Como resultado, escrib√≠ el programa del gestor de arranque en JAVA (principalmente porque no s√© c√≥mo hacer nada m√°s), trabajando en el entorno IntelliJ IDEA simplemente hermoso y gratuito.  Crea un cliente TCP que busca un servidor que se ejecuta en ESP8266.  Si lo encuentra, lo contacta y le env√≠a un archivo ubicado en dicha direcci√≥n.  El c√≥digo est√° abajo. <br><br><div class="spoiler">  <b class="spoiler_title">Descargador de archivos JAVA basado en PC</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Net</span></span></span><span class="hljs-class"> </span></span>{ &lt;b&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Http_client(<span class="hljs-number"><span class="hljs-number">4000</span></span>); }&lt;/b&gt; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http_client</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port; String s; String Greetings_from_S; Http_client(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//192.168.1.113 -  ESP8266   .  ,      //    ,    try (Socket socket = new Socket("192.168.1.113", port)) { PrintWriter pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()),true); pw.println("program");// Greetings with SERVER System.out.println("program"); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); Greetings_from_S = br.readLine(); System.out.println(Greetings_from_S); if(Greetings_from_S.equals("ready")) { try { File file = new File("d:BlinkOUT.bin");//    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); byte [] data = new byte[bis.available()]; bis.read(data); byte [] data_buffer = new byte[1024]; int frames = data.length/1024; System.out.println(frames); int residy = data.length%1024; for (int i = 0; i &lt; frames;i++) { for (int k = 0; k&lt; (1024); k++) { data_buffer[k] = data[k+1024*(i)]; } sendingChunk(data_buffer); } byte [] data_buffer2= new byte[residy]; for (int i = 0; i &lt; residy;i++) { data_buffer2[i] = data[i+1024*(frames)]; } sendingChunk(data_buffer2); pw.println("stop");// System.out.println("stop program"); } catch (Exception e) { System.out.println(e); } } } catch (Exception e) { System.out.println(e); } } public void sendingChunk (byte [] data_buffer){ try (Socket socket = new Socket("192.168.1.113", 4001)){ BufferedOutputStream bos = new BufferedOutputStream((socket.getOutputStream())); bos.write(data_buffer); bos.flush(); System.out.println(data_buffer.length); } catch (Exception e) { System.out.println(e); } } }</span></span></code> </pre><br><br></div></div><br>  Aqu√≠, por supuesto, se hiri√≥ demasiado, no se necesitan todo tipo de preparados, en principio.  Si se establece la conexi√≥n TCP, entonces se establece.  El √∫nico problema era que el archivo no quer√≠a enviarse en partes iguales de 1024 bytes de ninguna manera, como realmente lo necesitaba, aunque indiqu√© expl√≠citamente el tama√±o.  Aparentemente, hay alg√∫n tipo de b√∫fer final inaccesible desde JAVA, y env√≠a paquetes del tama√±o que desea, lo cual es completamente inaceptable para el lado receptor.  Al principio trat√© de retrasarme para que el b√∫fer se cansara de esperar las siguientes piezas y enviarlo como est√°.  Pero el retraso comenz√≥ a funcionar cuando lleg√≥ a 10 segundos, lo que de alguna manera parec√≠a demasiado para un kilobyte transferido. <br><br>  Pero luego me di cuenta de que, por alguna raz√≥n, la primera pieza siempre es suave, cu√°l fue ordenada, y ya a partir de la segunda comienza una bacanal impredecible.  Por lo tanto, hice que el cliente abra la conexi√≥n, env√≠e una porci√≥n del c√≥digo en 1024 bytes y cierre la conexi√≥n.  Y as√≠ sucesivamente hasta que se env√≠e todo el archivo.  Todo funcion√≥ bien. <br><br>  Lo √∫nico para comenzar es instalar el tiempo de ejecuci√≥n JAVA en la computadora.  Pero generalmente empiezo de inmediato con IntelliJ IDEA porque all√≠ siempre puedes ver lo que est√° sucediendo en la consola (pero aqu√≠ necesitas un entorno JAVA).  Aunque, por supuesto, de manera inteligente necesita hacer una GUI.  Es decir, la ventana donde cae la ruta al archivo, la capacidad de cambiar los n√∫meros de puerto en la ventana y, bueno, otras cosas necesarias.  Y para recopilar todo esto en forma de un archivo ejecutable. <br><br>  Y tapericha, como sol√≠a decir Koroviev, volvamos a los ciudadanos, de hecho, a la extremidad mec√°nica MechArm, que se mencion√≥ al principio.  Ahora tenemos la oportunidad de programarlo de forma remota y luego administrarlo.  Pasemos al programa de control al costado del microcontrolador. <br><br>  En este caso, necesitamos controlar cuatro servos.  Aqu√≠ est√°n esos. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/d29/b6c/8ee/d29b6c8ee960405b9070649d8dc0b2a2.jpg"></div><br>  Tal accionamiento est√° controlado por pulsos rectangulares de un per√≠odo de 20 ms (50 Hz) con un factor de trabajo del 2 al 4 por ciento.  Es decir, 2% es un giro completo en una direcci√≥n, 4% en la otra.  La tarea es solo para el PWM integrado en el AVR. <br><br><img src="https://habrastorage.org/web/9a8/385/2f6/9a83852f6093435abf70b5a8f8d5f29c.png"><br><br>  Un servoaccionamiento se usa para moverse hacia la izquierda y hacia la derecha;  el segundo sobre uno mismo - de uno mismo;  tercero arriba y abajo;  el cuarto es la propia garra, que debe comprimirse y expandirse.  Todo est√° escrito en C y compilado en un archivo HEX en ATMEL STUDIO.  Un tipo de programa un poco extra√±o se debe al hecho de que inicialmente la mano se controlaba desde el teclado atado con cables al microcontrolador.  Pero los cables de ayer, debemos evolucionar m√°s. <br><br>  Por supuesto, puede usar bocetos para servos de "ARDUINO", pero no me gustaron.  Es m√°s interesante escribirte t√∫ mismo.  Adem√°s, los cuatro servos deber√≠an funcionar simult√°neamente, y no en modo multiplexado, cuando el PWM cambia a cada servo por turno.  Porque nadie ha cancelado la gravedad, y una extremidad elevada descender√° inmediatamente si los impulsos de control dejan de llegar al servoaccionamiento correspondiente.  No estoy seguro de que el boceto "ARDUINO" proporcione operaci√≥n simult√°nea para cuatro servos.  Pero nosotros mismos podemos escribir un programa que cumpla con los requisitos necesarios.  En general, en ausencia de un sistema operativo que separe a los corderos de las cabras, el uso de bocetos que compiten por los dispositivos perif√©ricos del microcontrolador (y ni siquiera sabemos cu√°les de antemano) es demasiado defectuoso. <br><br>  Aqu√≠ est√° el c√≥digo en s√≠ que escribimos al Arduino Nano usando el ESP8266-07. <br><br><div class="spoiler">  <b class="spoiler_title">Programa para controlar MechArm para microcontrolador AVRmega328P</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;stdint.h&gt;//    #include &lt;avr/interrupt.h&gt; #include &lt;math.h&gt; //  #include &lt;stdio.h&gt; // - #include &lt;avr/eeprom.h&gt; #include &lt;setjmp.h&gt; #include &lt;stdlib.h&gt; //  #define UART_BAUD_RATE 115200 //  1    20 #define COUNTER1_OFF TCCR1B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER1_ON TCCR1B=0b00000011 //  0       0  1 #define COUNTER0_OFF TCCR0B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER0_ON TCCR0B=0b00000100 //  2       B2(PD6)  3(PD7) #define COUNTER2_OFF TCCR2B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER2_ON TCCR2B=0b00000110 volatile uint16_t period_20ms; volatile uint8_t State_of_keyboard; volatile uint8_t start_position [6]; volatile int8_t number_servo; ISR(USART_RX_vect)//   UART { State_of_keyboard=UDR0; return; } ISR(TIMER0_COMPA_vect)//  0    { PORTB &amp;=~(1&lt;&lt;0); TIMSK0&amp;=~(1&lt;&lt;OCIE0A); TIFR0 |=(1&lt;&lt;OCF0A); return; } ISR(TIMER0_COMPB_vect) //  1    { PORTB &amp;=~(1&lt;&lt;1); TIFR0 |=(1&lt;&lt;OCF0B); TIMSK0 &amp;=~(1&lt;&lt;OCIE0B); return; } ISR(TIMER2_COMPA_vect)//  2(PD6)    { PORTD &amp;=~(1&lt;&lt;6); TIFR2 |=(1&lt;&lt;OCF2A); TIMSK2 &amp;=~(1&lt;&lt;OCIE2A); return; } ISR(TIMER2_COMPB_vect)//  3(PD7)    { PORTD &amp;=~(1&lt;&lt;7); TIFR2 |=(1&lt;&lt;OCF2B); TIMSK2 &amp;=~(1&lt;&lt;OCIE2B); return; } ISR(TIMER1_OVF_vect){//   20      COUNTER1_OFF; COUNTER0_OFF; COUNTER2_OFF; TIFR0 |=(1&lt;&lt;OCF0A); TIFR0 |=(1&lt;&lt;OCF0B); TIFR2 |=(1&lt;&lt;OCF2A); TIFR2 |=(1&lt;&lt;OCF2B); TIFR1 |=(1&lt;&lt;TOV1); PORTB |=(1&lt;&lt;0)|(1&lt;&lt;1); PORTD |=(1&lt;&lt;6)|(1&lt;&lt;7); TCNT1 = period_20ms; //  20  TCNT0 = 0; TCNT2 = 0; TIMSK0|=(1&lt;&lt;OCIE0A)|(1&lt;&lt;OCIE0B); TIMSK2|=(1&lt;&lt;OCIE2A)|(1&lt;&lt;OCIE2B); OCR0A=start_position[1];//  0  0 OCR0B=start_position[2];//  0  1 OCR2A=start_position[3];//  0  2 OCR2B=start_position[4];//  0  3 COUNTER1_ON; COUNTER2_ON; COUNTER0_ON; return; } void time_delay(long i) { cli();sei(); long k; i*=2000; for(k=0;k&lt;i;k++){;;}; } void timer_counter0_1_2_INIT()//   0,1,2 { // 1 TCCR1A &amp;=~(1&lt;&lt;COM1A0)|~(1&lt;&lt;COM1A1)|~(1&lt;&lt;COM1B0)|~(1&lt;&lt;COM1B1);//   TCCR1A &amp;=~(1&lt;&lt;WGM10)|~(1&lt;&lt;WGM11); TCCR1B &amp;=~(1&lt;&lt;WGM12)|~(1&lt;&lt;WGM13);//    period_20ms=60575; TCNT1 = period_20ms; TIMSK1|=(1&lt;&lt;TOIE1);//|    //TIFR0   TOV0 // 0 TCCR0A &amp;=~(1&lt;&lt;COM0A0)|~(1&lt;&lt;COM0A1)|~(1&lt;&lt;COM0B0)|~(1&lt;&lt;COM0B1);//   TCCR0A &amp;=~(1&lt;&lt;WGM00)|~(1&lt;&lt;WGM01); TCCR0B &amp;=~(1&lt;&lt;WGM02);//    // 2 TCCR2A &amp;=~(1&lt;&lt;COM2A0)|~(1&lt;&lt;COM2A1)|~(1&lt;&lt;COM2B0)|~(1&lt;&lt;COM2B1);//   TCCR2A &amp;=~(1&lt;&lt;WGM20)|~(1&lt;&lt;WGM21); TCCR2B &amp;=~(1&lt;&lt;WGM22);//    COUNTER1_ON; } void servo_reset() { start_position[1]=97;//  0  0 start_position[2]=70;//  0  1 start_position[3]=92;//  0  2 start_position[4]=124; // 0  3 COUNTER1_ON; time_delay(100); } void servo_go( int8_t moven, uint8_t servo_position_max, uint8_t servo_position_min)// { switch (moven){ case 1: start_position[number_servo]++; if(start_position[number_servo]==servo_position_max){start_position[number_servo]--;};//  +90  break; case 2: start_position[number_servo]--; if(start_position[number_servo]==servo_position_min){start_position[number_servo]++;};//6  -90  break; }; time_delay(20); return; } //PORTB-0,1, PORTD - 6,7 -  , 8-  COUNTER 0 int main(void) { uint8_t servo_positionmin=0, servo_positionmax=0; int8_t const servo_position1max = 122, servo_position1min=58; //  int8_t const servo_position2max = 120, servo_position2min=36;// int8_t const servo_position3max = 125, servo_position3min=68;// int8_t const servo_position4max = 129, servo_position4min=108;// 128 108 sei(); DDRD = 0B11000010; //   D2-D5  , D0  RX, D1  TX, D6 D7   3  4 PORTD = 0B00111110; //     DDRB |=(1&lt;&lt;0)|(1&lt;&lt;1);//         PORTB &amp;=(~1&lt;&lt;0)|(~1&lt;&lt;1); UCSR0A=0;// UART UCSR0B=0b10010000; UCSR0C=0b00000110; UBRR0L=103;//  115200 UBRR0H=0; timer_counter0_1_2_INIT(); servo_reset(); PORTB |=(1&lt;&lt;5); while (1) { switch (State_of_keyboard) { case 1://   1 PD0(PB0) number_servo=1; servo_positionmin=servo_position1min; servo_positionmax=servo_position1max; break; case 2: //   1 PD0(PB0) number_servo=1; servo_positionmin=servo_position1min; servo_positionmax=servo_position1max; break; case 5: number_servo=2; //   2 PD1(PB1) servo_positionmin=servo_position2min; servo_positionmax=servo_position2max; break; case 6: number_servo=2; //   2 PD1(PB1) servo_positionmin=servo_position2min; servo_positionmax=servo_position2max; break; case 7: number_servo=3;//   3 PD6 servo_positionmin=servo_position3min; servo_positionmax=servo_position3max; break; case 8: number_servo=3;//   3 PD6 servo_positionmin=servo_position3min; servo_positionmax=servo_position3max; break; case 3: number_servo=4; //   4 PD7 servo_positionmin=servo_position4min; servo_positionmax=servo_position4max; break;//  case 4: number_servo=4; //   4 PD7 servo_positionmin=servo_position4min; servo_positionmax=servo_position4max; break;//  // c    - ,       4-  //        ,         } if(State_of_keyboard==1||State_of_keyboard==3||State_of_keyboard==5||State_of_keyboard==7) { servo_go(1,servo_positionmax,servo_positionmin);// } if(State_of_keyboard==2||State_of_keyboard==4||State_of_keyboard==6||State_of_keyboard==8) //     { servo_go(2,servo_positionmax,servo_positionmin);// } time_delay(20); } }</span></span></span></span></code> </pre><br><br></div></div><br>  La esencia del programa es clara por el texto y los comentarios.  Usamos un contador T1 durante un per√≠odo ejemplar de 20 ms y T0, contadores T2 para emitir se√±ales PWM a cuatro l√≠neas del puerto de E / S, ya que cada uno de estos dos contadores puede funcionar en dos dispositivos. <br>  El programa establece las posiciones iniciales de los servos mediante la carga de los registros de conteo OCR0A, OCR0B, OCR2A, OCR2B.  Tambi√©n se introducen constantes de restricci√≥n, ya que no siempre necesitamos un intervalo de 180 grados.  Bueno y m√°s, por interrupci√≥n de UART, el programa capta el n√∫mero enviado por ESP8266 (del 1 al 8) y lo traduce en un comando para el servo correspondiente.  Hay cuatro unidades, cada una trabajando en dos direcciones, por lo que los enteros del uno al ocho son suficientes.  Una vez que se selecciona el n√∫mero, el contenido de los registros de contador anteriores se incrementa o disminuye, cambiando respectivamente el ciclo de trabajo del pulso de control y el √°ngulo de rotaci√≥n del servoaccionamiento seleccionado.  Esas unidades que no seleccionamos conservan el valor anterior del √°ngulo de rotaci√≥n (ya que el contenido de los registros correspondientes, aunque se actualizaron, no cambiaron) y contin√∫an manteniendo el brazo mec√°nico en la misma posici√≥n. <br><br>  Ahora solo tenemos que escribir un programa de control, perd√≥n por la tautalog√≠a, para controlar una mano mec√°nica directamente desde la computadora a trav√©s de WI-FI. <br>  El c√≥digo tambi√©n est√° escrito en JAVA, pero un poco ennoblecido.  Hab√≠a una GUI y la capacidad de editar los n√∫meros de puerto y la direcci√≥n de red del ESP8266. <br><br><img src="https://habrastorage.org/web/d48/d3e/27a/d48d3e27af904919b00d0873de532d3d.png"><br><br>  Lo que sucede all√≠ est√° claro desde la ventana.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proporciono el</a> texto del programa aqu√≠ (est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Github</a> ), por la siguiente raz√≥n: aproximadamente el 95% de su volumen es la creaci√≥n de ventanas y el procesamiento de se√±ales desde el teclado.  Pero la esencia es la misma que el programa anterior en JAVA.  Se crea un cliente, solo UDP, que, dependiendo de la tecla presionada, env√≠a un n√∫mero del 1 al 8, a la direcci√≥n especificada en el puerto especificado. <br>  O puede obtener inmediatamente el ejecutable <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aqu√≠</a> .  Para m√°quinas de 64 bits con Windows.  Incluso un entorno JAVA instalado no es necesario.  Todo ya se ha metido en 178 MB. <br><br>  Entonces, la pluma mec√°nica fue ensamblada, depurada y presentada a su hermano para su aniversario.  Puede recoger pilas de pl√°stico con vodka, en Skype desde otra ciudad.  Aunque para el brazo mec√°nico de Howard Volovitsa de la serie "The Big Bang Theory", ella todav√≠a est√° lejos. <br><br>  Pero luego, en los siguientes art√≠culos (si alguien est√° interesado) podremos administrarlo desde un tel√©fono m√≥vil, hacer lo mismo con un carro rob√≥tico de cuatro ruedas y actualizar la hora en relojes electr√≥nicos desde servidores de reloj en Internet.  Luego colocamos el viejo tel√©fono inteligente en el carrito y llevamos el video desde √©l a la red neuronal con reconocimiento de patrones, y luego las se√±ales de control a los motores, <s>oh, algo ya me lleva ...</s> <br><br>  Y todo esto con la hermosa ESP8266. <br>  Me alegrar√≠a si alguien encontrara el art√≠culo interesante. <br><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pinout y especificaciones de ESP8266</a> <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conectando el ESP8266.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Inicio r√°pido</a> <br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Actualizaci√≥n de firmware de NodeMCU a trav√©s de la nube</a> <br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NODE MCU PyFlasher</a> <br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ESPlorer - IDE para ESP8266</a> <br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programaci√≥n en C para AVR</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revisi√≥n de art√≠culos: ‚ÄúProgramaci√≥n de microcontroladores en lenguaje C‚Äù</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [8] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descripci√≥n de la API de NodeMCU</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [9] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencia de Lua</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [10] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guiones y m√≥dulos de Lua</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [11] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntelliJ IDEA</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [12] ¬° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descarga Java a tu computadora de escritorio ahora! </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estudio Atmel</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es406559/">https://habr.com/ru/post/es406559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es406547/index.html">Revisi√≥n de tableros en SoC ARM + FPGA. Primera parte Xilinx World</a></li>
<li><a href="../es406549/index.html">Una gu√≠a de materiales el√©ctricos para todos. Parte 9</a></li>
<li><a href="../es406551/index.html">Monowheel: dos temporadas de experiencia</a></li>
<li><a href="../es406553/index.html">Las 10 mejores m√°quinas de escritorio CNC para el hogar 2017</a></li>
<li><a href="../es406555/index.html">Tu, yo y mi inteligencia artificial</a></li>
<li><a href="../es406561/index.html">Microm√°quinas en el tratamiento de enfermedades estomacales</a></li>
<li><a href="../es406563/index.html">¬øPor qu√© tu cerebro necesita m√°s descanso?</a></li>
<li><a href="../es406567/index.html">Bajo los golpes de los elementos: el Centro Espacial Kennedy se est√° preparando para el hurac√°n "Irma"</a></li>
<li><a href="../es406569/index.html">XRONOS - agregador</a></li>
<li><a href="../es406571/index.html">C√≥mo vencer al envejecimiento - plan de acci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>