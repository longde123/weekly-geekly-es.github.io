<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥗 🚋 🖤 Cara tidur benar dan salah 😌 🧑🏻 🆘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Belum lama ini, sebuah artikel bagus mengalir melewati kami tentang kondisi kinerja perangkat lunak modern yang mengerikan ( asli dalam bahasa Inggris...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara tidur benar dan salah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/427843/">  Belum lama ini, sebuah artikel bagus mengalir melewati kami tentang kondisi kinerja perangkat lunak modern yang mengerikan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asli dalam bahasa Inggris</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan dalam bahasa Habré</a> ).  Artikel ini mengingatkan saya pada salah satu antipattern dari kode, yang sangat umum dan umumnya berfungsi, tetapi menyebabkan kerugian kinerja kecil di sana-sini.  Nah, Anda tahu, hal sepele, yang tangan tidak akan menggapai dengan cara apa pun.  Satu-satunya masalah adalah bahwa selusin "hal-hal sepele" ini yang tersebar di berbagai tempat dalam kode mulai menimbulkan masalah seperti "Saya memiliki Intel Core i7 terbaru, dan menggulir kedutan." <br><br><img src="https://habrastorage.org/webt/ri/na/rs/rinarsug4i1qt6b8kzc0i-6tcjy.png" align="right">  Saya berbicara tentang penggunaan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tidur yang tidak benar</a> (kasing dapat bervariasi tergantung pada bahasa pemrograman dan platform).  Jadi, apa itu Tidur?  Dokumentasi menjawab pertanyaan ini dengan sangat sederhana: ini adalah jeda dalam pelaksanaan utas saat ini untuk jumlah milidetik yang ditentukan.  Perlu dicatat keindahan estetika dari prototipe fungsi ini: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD dwMilliseconds)</span></span></span></span>;</code> </pre> <br>  Hanya satu parameter (sangat jelas), tidak ada kode kesalahan atau pengecualian - selalu berfungsi.  Ada beberapa fungsi yang bagus dan mudah dimengerti! <br><br><div class="spoiler">  <b class="spoiler_title">Anda mendapatkan lebih banyak rasa hormat untuk fungsi ini ketika Anda membaca cara kerjanya.</b> <div class="spoiler_text">  Fungsi ini pergi ke scheduler thread OS dan memberitahu itu, “Thread saya dan saya ingin menolak waktu CPU yang dialokasikan untuk kami, sekarang dan untuk milidetik di masa depan.  Berikan kepada orang miskin! "  Penjadwal, yang sedikit terkejut dengan kemurahan hati seperti itu, mengeluarkan fungsi rasa terima kasih atas nama prosesor, memberikan sisa waktu kepada orang berikutnya (dan selalu ada yang) dan tidak termasuk utas yang menyebabkan Sleep berpura-pura mengirimkan konteks eksekusi untuk jumlah milidetik yang ditentukan.  Cantik! <br></div></div><br>  Apa yang salah?  Fakta bahwa pemrogram menggunakan fitur yang luar biasa ini bukan untuk apa yang dimaksudkan. <br><a name="habracut"></a><br>  Dan itu dimaksudkan untuk simulasi perangkat lunak dari beberapa eksternal, yang ditentukan oleh sesuatu yang nyata, proses jeda. <br><br><h3>  Contoh yang benar nomor 1 </h3><br>  Kami sedang menulis aplikasi "jam", di mana satu detik sekali Anda perlu mengubah nomor di layar (atau posisi panah).  Fungsi Tidur di sini sangat cocok: kami benar-benar tidak ada hubungannya untuk jangka waktu yang jelas (tepat satu detik).  Kenapa tidak tidur? <br><br><h3>  Contoh yang benar nomor 2 </h3><br>  Kami sedang menulis pengontrol <s>nonsen untuk mesin</s> roti.  Algoritma operasi diatur oleh salah satu program dan terlihat seperti ini: <br><br><ol><li>  Pergi ke mode 1. </li><li>  Kerjakan selama 20 menit </li><li>  Pergi ke mode 2. </li><li>  Kerjakan selama 10 menit </li><li>  Matikan. </li></ol><br>  Semuanya di sini juga jelas: kita bekerja dengan waktu, itu diatur oleh proses teknologi.  Menggunakan Sleep dapat diterima. <br><br>  Sekarang mari kita lihat contoh penyalahgunaan Tidur. <br><br>  Ketika saya membutuhkan beberapa contoh kode C ++ yang salah, saya pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> kode editor teks Notepad ++.  Kodenya sangat mengerikan sehingga antipattern pasti ada di sana, saya bahkan pernah menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang ini.  Notepad ++ juga tidak mengecewakan saya!  Mari kita lihat bagaimana menggunakan Sleep. <br><br><h3>  Contoh buruk nomor 1 </h3><br>  Saat startup, Notepad ++ memeriksa untuk melihat apakah instance lain dari prosesnya sudah berjalan dan, jika demikian, mencari jendelanya dan mengirimkannya pesan, dan ditutup.  Untuk mendeteksi proses lain, metode standar digunakan - global bernama mutex.  Tetapi kode berikut ditulis untuk mencari windows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!isMultiInst) &amp;&amp; (!TheFirstOne)) { HWND hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ;!hNotepad_plus &amp;&amp; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> ; ++i) { Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hNotepad_plus) { ... } ... }</code> </pre> <br><br>  Programmer yang menulis kode ini mencoba menemukan jendela untuk Notepad ++ yang sudah diluncurkan dan bahkan membayangkan situasi di mana dua proses dimulai secara harfiah pada saat yang sama, jadi yang pertama dari mereka sudah membuat global mutex, tetapi belum membuat jendela editor.  Dalam hal ini, proses kedua akan menunggu pembuatan jendela "5 kali dalam 100 ms".  Akibatnya, kami tidak akan menunggu sama sekali, atau kehilangan hingga 100 ms antara saat pembuatan jendela sebenarnya dan keluar dari Sleep. <br><br>  Ini adalah antipattern pertama (dan salah satu yang utama) menggunakan Sleep.  Kami tidak menunggu terjadinya acara, tetapi "selama beberapa milidetik, tiba-tiba itu akan beruntung."  Kami sangat menunggu sehingga di satu sisi kami tidak benar-benar mengganggu pengguna, dan di sisi lain, kami memiliki kesempatan untuk menunggu acara yang kami butuhkan.  Ya, pengguna mungkin tidak melihat jeda 100 ms saat memulai aplikasi.  Tetapi jika praktik "menunggu sedikit dari buldoser" diterima dan diizinkan dalam proyek, ini mungkin berakhir dengan fakta bahwa kami akan menunggu di setiap langkah untuk alasan yang paling sepele.  Di sini 100 ms, ada 50 ms lagi, dan di sini 200 ms - dan di sini program kami sudah "entah bagaimana melambat selama beberapa detik." <br><br>  Selain itu, secara estetika tidak menyenangkan melihat kode yang berjalan untuk waktu yang lama sementara itu bisa bekerja dengan cepat.  Dalam kasus khusus ini, seseorang dapat menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SetWindowsHookEx</a> dengan berlangganan ke acara HSHELL_WINDOWCREATED - dan menerima pemberitahuan pembuatan jendela secara instan.  Ya, kode menjadi sedikit lebih rumit, tetapi secara harfiah 3-4 baris.  Dan kami menang hingga 100 ms!  Dan yang paling penting - kita tidak lagi menggunakan fungsi harapan tanpa syarat di mana harapan itu tidak tanpa syarat. <br><br><h3>  Contoh buruk nomor 2 </h3><br><pre> <code class="cpp hljs">HANDLE hThread = ::CreateThread(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, threadTextTroller, &amp;trollerParams, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sleepTime = <span class="hljs-number"><span class="hljs-number">1000</span></span> / x * y; ::Sleep(sleepTime);</code> </pre> <br>  Saya tidak benar-benar mengerti apa sebenarnya dan untuk berapa lama kode ini menunggu di Notepad ++, tetapi saya sering melihat antipattern umum untuk "memulai aliran dan menunggu".  Orang-orang mengharapkan hal-hal berbeda: mulai dari aliran lain, penerimaan beberapa data darinya, akhir pekerjaannya.  Dua hal buruk di sini segera: <br><br><ol><li>  Pemrograman multithreaded diperlukan untuk melakukan sesuatu multithreaded.  Yaitu  peluncuran utas kedua mengasumsikan bahwa kita akan terus melakukan sesuatu pada yang pertama, pada saat ini utas kedua akan melakukan pekerjaan lain, dan yang pertama, setelah menyelesaikan pekerjaannya (dan, mungkin, setelah menunggu lebih lama), akan mendapatkan hasilnya dan menggunakannya entah bagaimana.  Jika kita mulai "tidur" segera setelah memulai utas kedua - mengapa itu diperlukan sama sekali? </li><li>  Perlu untuk berharap dengan benar.  Untuk ekspektasi yang tepat, ada praktik yang terbukti: penggunaan acara, fungsi tunggu, panggilan balik.  Jika kami menunggu kode untuk mulai bekerja di utas kedua, atur acara untuk ini dan beri sinyal pada utas kedua.  Jika kita menunggu utas kedua selesai bekerja - dalam C ++ ada kelas utas luar biasa dan metode penggabungannya (well, atau, sekali lagi, metode khusus platform seperti WaitForSingleObject dan HANDLE pada Windows).  Menunggu pekerjaan diselesaikan di utas lain "selama beberapa milidetik" benar-benar bodoh, karena jika kita tidak memiliki OS waktu nyata, tidak ada yang akan memberi Anda jaminan berapa lama utas kedua akan mulai atau mencapai tahap tertentu dari pekerjaannya. </li></ol><br><h3>  Contoh buruk nomor 3 </h3><br>  Di sini kita melihat utas latar belakang yang sedang tidur menunggu beberapa acara. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CReadChangesServer</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (m_nOutstandingRequests || !m_bTerminate) { ::SleepEx(INFINITE, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestTermination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_bTerminate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ... } ... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_bTerminate; };</code> </pre><br>  Saya harus mengakui bahwa bukan Sleep yang digunakan di sini, melainkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SleepEx</a> , yang lebih cerdas dan dapat mengganggu menunggu beberapa peristiwa (seperti penyelesaian operasi asinkron).  Tetapi ini sama sekali tidak membantu!  Faktanya adalah bahwa while (! M_bTerminate) memiliki hak untuk bekerja tanpa henti, mengabaikan metode RequestTermination () dipanggil dari utas lainnya, mengatur ulang variabel m_bTerminate menjadi true.  Saya menulis tentang sebab dan akibat dari hal ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> .  Untuk menghindari ini, Anda harus menggunakan sesuatu yang dijamin berfungsi dengan baik di antara utas: atomik, peristiwa, atau yang serupa. <br><br>  Ya, secara resmi SleepEx tidak bisa disalahkan atas masalah menggunakan variabel Boolean yang biasa untuk menyinkronkan utas, ini adalah kesalahan terpisah dari kelas lain.  Tetapi mengapa itu menjadi mungkin dalam kode ini?  Karena pada awalnya programmer berpikir "kamu perlu tidur di sini", dan kemudian berpikir tentang berapa lama dan dalam kondisi apa untuk berhenti melakukan ini.  Dan dalam skenario yang tepat, dia seharusnya tidak memiliki pemikiran pertama.  Pikiran "harus menunggu acara" seharusnya muncul di kepala saya - dan mulai sekarang, pikiran itu akan bekerja untuk memilih mekanisme yang tepat untuk menyinkronkan data di antara utas, yang akan mengecualikan variabel Boolean dan penggunaan SleepEx. <br><br><h3>  Contoh buruk nomor 4 </h3><br>  Dalam contoh ini, kita akan melihat fungsi backupDocument, yang bertindak sebagai "penyimpanan otomatis", berguna jika terjadi crash editor yang tidak terduga.  Secara default, dia tidur selama 7 detik, lalu memberikan perintah untuk menyimpan perubahan (jika ada). <br><br><pre> <code class="cpp hljs">DWORD WINAPI Notepad_plus::backupDocument(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-comment"><span class="hljs-comment">/*param*/</span></span>) { ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isSnapshotMode) { ... ::Sleep(DWORD(timer)); ... ::PostMessage(Notepad_plus_Window::gNppHWND, NPPM_INTERNAL_SAVEBACKUP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; }</code> </pre> <br>  Interval dapat diubah, tetapi ini bukan masalahnya.  Interval apa pun akan terlalu panjang dan terlalu pendek pada saat bersamaan.  Jika kita mengetikkan satu huruf per menit, tidak masuk akal untuk tidur hanya 7 detik.  Jika kami menyalin-tempel 10 megabita teks dari suatu tempat, kami tidak perlu menunggu 7 detik setelah itu, itu adalah volume yang cukup besar untuk segera memulai pencadangan (tiba-tiba kami hentikan itu dari suatu tempat dan hilang di sana, dan editor mogok setelah satu detik). <br><br>  Yaitu  dengan harapan sederhana, kami mengganti algoritma yang lebih cerdas yang hilang di sini. <br><br><h3>  Contoh buruk nomor 5 </h3><br>  Notepad ++ dapat "mengetik teks" - mis.  meniru input teks manusia dengan menjeda di antara penyisipan huruf.  Tampaknya ditulis sebagai "telur Paskah", tetapi Anda dapat menemukan beberapa jenis aplikasi yang berfungsi dari fitur ini ( <s>menipu Upwork, ya</s> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pauseTimeArray[nbPauseTime] = {<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">600</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxRange = <span class="hljs-number"><span class="hljs-number">200</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ranNum = getRandomNumber(maxRange); ::Sleep(ranNum + pauseTimeArray[ranNum%nbPauseTime]); ::SendMessage(pCurrentView-&gt;getHSelf(), SCI_DELETEBACK, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Masalahnya di sini adalah bahwa kode memiliki ide semacam "orang biasa" berhenti selama 400-800 ms antara setiap tombol yang ditekan.  Ok, mungkin itu "rata-rata" dan normal.  Tapi tahukah Anda, jika program yang saya gunakan membuat beberapa jeda dalam pekerjaan saya hanya karena mereka tampak cantik dan cocok untuknya - ini tidak berarti sama sekali bahwa saya membagikan pendapatnya.  Saya ingin dapat menyesuaikan durasi data jeda.  Dan, jika dalam kasus Notepad ++ ini tidak terlalu kritis, maka di program lain saya kadang-kadang bertemu pengaturan seperti "memperbarui data: sering, biasanya, jarang", di mana "sering" tidak cukup untuk saya sering, dan "jarang" tidak cukup jarang.  Ya, dan "normal" tidak normal.  Fungsionalitas seperti itu harus memungkinkan pengguna untuk secara akurat menunjukkan jumlah milidetik yang ia ingin tunggu sampai tindakan yang diinginkan selesai.  Dengan opsi wajib untuk memasukkan "0".  Selain itu, 0 dalam hal ini bahkan tidak boleh diteruskan sebagai argumen ke fungsi Sleep, tetapi cukup mengecualikan panggilannya (Sleep (0) tidak benar-benar kembali secara instan, tetapi memberikan sisa potongan slot waktu yang diberikan oleh penjadwal ke utas lain). <br><br><h2>  Kesimpulan </h2><br>  Dengan bantuan Sleep, seseorang dapat dan harus memenuhi harapan ketika itu adalah harapan yang diberikan tanpa syarat untuk periode waktu tertentu dan ada beberapa penjelasan logis mengapa seperti ini: "sesuai dengan proses teknologi", "waktu dihitung berdasarkan rumus ini", "tunggu begitu banyak kata pelanggan. "  Menunggu beberapa acara atau utas sinkronisasi tidak boleh dilaksanakan menggunakan fungsi Sleep. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427843/">https://habr.com/ru/post/id427843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427829/index.html">Mengawasi atau melakukan outsourcing? Itu pertanyaannya</a></li>
<li><a href="../id427833/index.html">Laporan Konferensi Joker 2018</a></li>
<li><a href="../id427837/index.html">Hari-hari pertama di tim pengembangan - seperti yang terjadi pada kami</a></li>
<li><a href="../id427839/index.html">Otorisasi pengguna di Django melalui GSSAPI dan pendelegasian hak pengguna ke server</a></li>
<li><a href="../id427841/index.html">Magic Leap Scam</a></li>
<li><a href="../id427845/index.html">Cara memuat jutaan bintang di iPhone</a></li>
<li><a href="../id427847/index.html">Keingintahuan dan penundaan dalam pembelajaran mesin</a></li>
<li><a href="../id427849/index.html">Garis lurus dengan TM. v3.0</a></li>
<li><a href="../id427853/index.html">Refleksi pada TDD. Mengapa metodologi ini tidak dikenal secara luas</a></li>
<li><a href="../id427855/index.html">Mitos MOSDROID di FunCorp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>