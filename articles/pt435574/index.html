<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì± üëäüèæ ü§¶üèø Como o zig funciona? üëÑ üöâ üìÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De um tradutor: esta postagem foi publicada no blog do autor em 15 de mar√ßo de 2018. √Ä medida que uma linguagem evolui, sua sintaxe pode ser diferente...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o zig funciona?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435574/">  <i>De um tradutor: esta postagem foi publicada no blog do autor em 15 de mar√ßo de 2018.</i>  <i>√Ä medida que uma linguagem evolui, sua sintaxe pode ser diferente no momento.</i>  <i>Tudo descrito est√° relacionado ao Zig 0.2.0, a vers√£o atual do idioma √© Zig 0.3.0.</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entrei em contato com o autor da postagem e ele gentilmente forneceu um link para o reposit√≥rio com a vers√£o atual das fontes do projeto no Zig 0.3.0</a></i> <i><br></i> <br>  Ol√°  Vamos escrever um int√©rprete de Brainfuck!  "Por qu√™?"  "Voc√™ pode perguntar, mas n√£o encontrar√° a resposta aqui." <br><br>  Eu vou fazer isso no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zig</a> . <br><img src="https://habrastorage.org/webt/p2/l1/zs/p2l1zsmnlu7j_yqwm6fczu4ycay.jpeg"><br><h3>  Zig √© ... </h3><br>  ... uma nova linguagem de programa√ß√£o.  Ainda est√° em beta e est√° se desenvolvendo rapidamente.  Se voc√™ j√° viu o c√≥digo Zig antes, o c√≥digo nesta postagem pode parecer um pouco diferente para voc√™.  Ele √© realmente diferente!  O Zig 0.2.0 acaba de ser lan√ßado, coincidindo com o lan√ßamento do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LLVM 6 h√°</a> algumas semanas, e inclui muitas altera√ß√µes de sintaxe e melhorias gerais de linguagem.  Principalmente, muitos "feiti√ßos" foram substitu√≠dos por palavras-chave.  Veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> uma explica√ß√£o mais profunda de todas as altera√ß√µes! <br><br>  O Zig foi projetado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para ser leg√≠vel</a> e relativamente intuitivo para aqueles familiarizados com linguagens compiladas e digitadas, como C, C ++ e, em alguns momentos, Rust. <br><br>  O c√≥digo foi compilado e testado com o Zig 0.2.0, que est√° dispon√≠vel no momento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">atrav√©s de v√°rios canais</a> , incluindo homebrew, se voc√™ estiver no OSX: brew install zig. <br><a name="habracut"></a><br><h3>  Vamos come√ßar </h3><br>  Para saber como o Brainfuck funciona, veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  N√£o h√° quase nada para aprender l√°, mas √© uma linguagem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">completa de Turing</a> , o que significa que voc√™ pode escrever <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">qualquer coisa</a> nela. <br><br>  Publiquei o c√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , caso voc√™ queira ver o produto final ou as confirma√ß√µes antecipadas. <br><br>  Zig √© uma linguagem compilada.  Quando voc√™ compila um programa, o bin√°rio resultante (se voc√™ estiver compilando um bin√°rio execut√°vel, n√£o uma biblioteca) deve ter uma fun√ß√£o principal que marca o ponto de entrada. <br><br>  Ent√£o ... <br><br><pre><code class="plaintext hljs">// main.zig fn main() void { }</code> </pre> <br>  ... e come√ßar ... <br><br><pre> <code class="bash hljs">$ zig build-exe main.zig</code> </pre> <br>  ... d√° ... <br><br><pre> <code class="bash hljs">/zig/std/special/bootstrap.zig:70:33: error: <span class="hljs-string"><span class="hljs-string">'main'</span></span> is private /zigfuck/main.zig:2:1: note: declared here</code> </pre> <br>  main deve ser declarado como p√∫blico para ser vis√≠vel fora do m√≥dulo ... <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { }</code> </pre> <br>  Deixe o programa brainfuck usar uma matriz de 30.000 bytes como mem√≥ria, eu farei essa matriz. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8; }</code> </pre> <br>  Posso declarar uma constante (const) ou uma vari√°vel (var).  Aqui, declarei mem como uma matriz de 30.000 bytes n√£o assinados (u) (8 bits). <br><br>  Isso n√£o compila. <br><br><pre> <code class="bash hljs">/main.zig:3:5: error: variables must be initialized</code> </pre> <br>  Um programa C equivalente seria compilado normalmente: eu posso declarar uma vari√°vel sem inicializa√ß√£o, mas o Zig me obriga a tomar uma decis√£o agora, no momento em que a vari√°vel √© declarada.  Posso n√£o me importar com o que est√° escrito nele, mas devo indicar isso explicitamente.  Farei isso inicializando a vari√°vel com um valor indefinido (indefinido). <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8 = undefined; }</code> </pre> <br>  A inicializa√ß√£o de uma vari√°vel com um valor indefinido n√£o oferece nenhuma garantia sobre o valor da vari√°vel na mem√≥ria.  √â o mesmo que uma declara√ß√£o de vari√°vel n√£o inicializada em C, exceto que voc√™ precisa indicar isso explicitamente. <br><br>  Mas talvez eu n√£o me importe com como inicializar essa mem√≥ria.  Talvez eu queira ter uma garantia de que os zeros ou algum valor arbitr√°rio sejam escritos l√°.  Nesse caso, tamb√©m devo declarar explicitamente isso: <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem = []u8{0} ** 30000; }</code> </pre> <br>  Pode parecer estranho, mas ** √© o operador usado para expandir matrizes.  Declaro uma matriz de 0 bytes e, em seguida, expanda-a para 30.000 e obtenho o valor final de inicializa√ß√£o de 30.000 zero bytes.  Esta opera√ß√£o ocorre uma vez, <i>no momento da compila√ß√£o</i> .  comptime √© uma das grandes id√©ias de Zig, e voltarei a ela em uma das seguintes postagens. <br><br>  Agora vamos escrever um programa no brainfuck que n√£o faz nada al√©m de incrementar o primeiro slot de mem√≥ria cinco vezes! <br><br><pre> <code class="plaintext hljs">pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; }</code> </pre> <br>  No Zig, cadeias de caracteres s√£o matrizes de bytes.  N√£o devo declarar src como uma matriz de bytes, porque o compilador implica isso.  Isso √© opcional, mas se voc√™ quiser, √© poss√≠vel: <br><br><pre> <code class="plaintext hljs">const src: [5]u8 = "+++++";</code> </pre> <br>  Isso ir√° compilar bem.  No entanto, isto: <br><br><pre> <code class="plaintext hljs">const src: [6]u8= "+++++";</code> </pre> <br>  n√£o ser√°. <br><br><pre> <code class="bash hljs">main.zig:5:22: error: expected <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'[6]u8'</span></span>, found <span class="hljs-string"><span class="hljs-string">'[5]u8'</span></span></code> </pre> <br>  Mais uma observa√ß√£o: como as strings s√£o apenas matrizes, elas n√£o terminam com zero.  No entanto, voc√™ pode declarar uma cadeia C. com termina√ß√£o nula. Como literal, ela ter√° a seguinte apar√™ncia: <br><br><pre> <code class="plaintext hljs">c"Hello I am a null terminated string";</code> </pre> <br><h3>  Para o bem comum ... </h3><br>  Eu quero fazer <i>algo</i> com cada caractere em uma string.  Eu consigo!  No in√≠cio do main.zig, importo algumas fun√ß√µes da biblioteca padr√£o: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">A importa√ß√£o</a> , como praticamente tudo o que come√ßa com o sinal @, √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√£o interna do compilador</a> .  Esses recursos est√£o sempre dispon√≠veis globalmente.  Importar aqui funciona de maneira semelhante ao javascript - voc√™ pode importar qualquer coisa cavando o espa√ßo para nome e extrair dele quaisquer fun√ß√µes ou vari√°veis ‚Äã‚Äãpublicamente dispon√≠veis.  No exemplo acima, importo diretamente a fun√ß√£o warn e a atribuo, de repente, √† constante warn.  Agora ela pode ser chamada.  Este √© um padr√£o comum: importamos diretamente do namespace std e, em seguida, chamamos std.debug.warn () ou o atribu√≠mos √† vari√°vel warn.  √â assim: <br><br><pre> <code class="plaintext hljs">const std = @import("std"); const warn = std.debug.warn;</code> </pre> <br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; // main.zig pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { warn("{}", c); } }</code> </pre> <br>  Durante a depura√ß√£o e o desenvolvimento e teste inicial, eu apenas quero imprimir algo na tela.  O zig √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">propenso a erros</a> e o stdout tamb√©m √© propenso a erros.  N√£o quero fazer isso agora e posso imprimir diretamente no stderr usando o warn, que importamos da biblioteca padr√£o. <br><br>  warn usa uma string formatada, como printf em C!  O c√≥digo acima ser√° impresso: <br><br><pre> <code class="plaintext hljs">4343434343</code> </pre> <br>  43 √© o c√≥digo de caractere ascii +.  Eu tamb√©m posso escrever: <br><br><pre> <code class="plaintext hljs">warn("{c}", c);</code> </pre> <br>  e obtenha: <br><br><pre> <code class="plaintext hljs">+++++</code> </pre> <br>  Ent√£o, inicializamos o espa√ßo da mem√≥ria e escrevemos o programa.  Agora estamos percebendo a pr√≥pria linguagem.  Come√ßarei com + e substituirei o corpo do loop for pelo switch: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1 } }</code> </pre> <br>  Eu recebo dois erros: <br><br><pre> <code class="plaintext hljs">/main.zig:10:7: error: switch must handle all possibilities switch(c) { ^ /main.zig:11:25: error: cannot assign to constant '+' =&gt; mem[0] += 1 ^</code> </pre> <br>  Obviamente, n√£o posso atribuir um novo valor a uma vari√°vel, que √© uma constante!  mem precisa ser transformado em uma vari√°vel ... <br><br><pre> <code class="plaintext hljs">var mem = []u8{0} ** 30000;</code> </pre> <br>  como em outros erros, minha constru√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">switch</a> deve saber o que fazer se o personagem n√£o for +, mesmo que nada precise ser feito.  No meu caso, √© exatamente isso que eu quero.  Encho este caso com um bloco vazio: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } }</code> </pre> <br>  Agora eu posso compilar o programa.  Ligue para avisar no final e execute: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } } warn("{}", mem[0]); }</code> </pre> <br>  Recebo o n√∫mero 5 impresso em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">stderr</a> , como eu esperava. <br><br><h3>  Vamos seguir em frente ... </h3><br>  Da mesma forma, apoiamos. <br><br><pre> <code class="plaintext hljs">switch(c) { '+' =&gt; mem[0] += 1, '-' =&gt; mem[0] -= 1, else =&gt; {} }</code> </pre> <br>  Para usar&gt; e &lt;, voc√™ precisa usar uma vari√°vel adicional, que serve como um "ponteiro" na mem√≥ria que eu aloquei para o programa de foda cerebral do usu√°rio. <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0;</code> </pre> <br>  Como um 16-bit n√£o assinado pode ter no m√°ximo 65535, √© mais do que suficiente indexar 30.000 bytes de espa√ßo de endere√ßo. <br><br><blockquote>  <i>de fato, 15 bits seriam suficientes para n√≥s, o que nos permite endere√ßar 32767 bytes.</i>  <i>O Zig permite tipos com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">larguras diferentes</a> , mas ainda n√£o o u15.</i> <i><br><br></i>  <i>voc√™ pode realmente fazer o u15 desta maneira:</i> <i><br><br></i> <pre> <code class="plaintext hljs">const u15 = @IntType(false, 15):</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√â proposto</a> que qualquer tipo [iu] \ d + seja v√°lido como um tipo inteiro. </blockquote><br>  Agora, em vez de usar mem [0], eu posso usar essa vari√°vel. <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1,</code> </pre> <br>  &lt;e&gt; simplesmente incremente e diminua esse ponteiro. <br><br><pre> <code class="plaintext hljs">'&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1,</code> </pre> <br>  √ìtimo  Podemos escrever um programa real agora! <br><br><h3>  Cheque 1,2,3 </h3><br>  O Zig possui um mecanismo de teste embutido.  Em qualquer lugar em qualquer arquivo, posso escrever um bloco de teste: <br><br><pre> <code class="plaintext hljs">test "Name of Test" { // test code }</code> </pre> <br>  e execute o teste na linha de comando: zig test $ FILENAME.  O restante dos blocos de teste √© igual ao c√≥digo regular. <br><br>  Vamos olhar para isso: <br><br><pre> <code class="plaintext hljs">// test.zig test "testing tests" {} zig test test.zig Test 1/1 testing tests...OK</code> </pre> <br>  Obviamente, um teste vazio √© in√∫til.  Eu posso usar assert para realmente confirmar a execu√ß√£o dos testes. <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "test true" { assert(true); } test "test false" { assert(false); }</code> </pre> <br><pre> <code class="bash hljs">zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.zig <span class="hljs-string"><span class="hljs-string">"thing.zig"</span></span> 10L, 127C written :!zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> thing.zig Test 1/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> true...OK Test 2/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> false...assertion failure [37;1m_panic.7 [0m: [2m0x0000000105260f34 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_panic [0m: [2m0x0000000105260d6b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_assert [0m: [2m0x0000000105260619 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_test <span class="hljs-literal"><span class="hljs-literal">false</span></span> [0m: [2m0x0000000105260cfb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main.0 [0m: [2m0x00000001052695ea <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMain [0m: [2m0x0000000105269379 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMainWithArgs [0m: [2m0x00000001052692f9 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main [0m: [2m0x0000000105269184 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x00007fff5c75c115 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x0000000000000001 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m</code> </pre> <br>  O teste caiu.  Use o seguinte comando para reproduzir o erro: <br><br><pre> <code class="plaintext hljs">./zig-cache/test</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O rastreamento de pilha na papoula ainda est√° em desenvolvimento.</a> <br><br>  Para testar isso com efici√™ncia, preciso dividi-lo em peda√ßos.  Vamos come√ßar com isso: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: [30000]u8) void { var memptr: u16 = 0; for (src) |c| { switch(c) { '+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, else =&gt; {} } } } pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; bf(src, mem); }</code> </pre> <br>  Parece funcionar, certo? <br><br>  Mas ... <br><br><pre> <code class="plaintext hljs">/main.zig:1:29: error: type '[30000]u8' is not copyable; cannot pass by value</code> </pre> <br><blockquote>  isso √© descrito em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/zig-lang/zig/issues/733</a> . </blockquote><br>  Zig √© rigoroso sobre isso.  Tipos complexos e todos os objetos que podem ser redimensionados n√£o podem ser transmitidos por valor.  Isso torna a aloca√ß√£o de pilha previs√≠vel e l√≥gica, al√©m de evitar c√≥pias desnecess√°rias.  Se voc√™ deseja usar a sem√¢ntica da transfer√™ncia por valor em seu programa, voc√™ pode implement√°-lo usando sua estrat√©gia de aloca√ß√£o, mas o pr√≥prio idioma n√£o suporta isso em circunst√¢ncias comuns. <br><br>  A maneira natural de contornar essa limita√ß√£o √© passar um ponteiro em vez de um valor (passar por refer√™ncia).  O Zig usa uma estrat√©gia diferente, fatias.  Uma fatia √© um ponteiro com um comprimento anexado a ela e com uma verifica√ß√£o de queda nas bordas.  A sintaxe na assinatura da fun√ß√£o √© semelhante a esta: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: []u8) void { ... }</code> </pre> <br>  e ao chamar a fun√ß√£o, fica assim: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..mem.len]);</code> </pre> <br>  Observe que eu defini o limite superior simplesmente referindo-se ao comprimento da matriz.  Existe uma forma abreviada de nota√ß√£o para esses casos: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..]);</code> </pre> <br>  Agora posso come√ßar a escrever testes que testam diretamente a fun√ß√£o bf ().  Vou adicionar fun√ß√µes de teste ao final do arquivo por enquanto ... <br><br><pre> <code class="plaintext hljs">test "+" { var mem = []u8{0}; const src = "+++"; bf(src, mem[0..]); assert(mem[0] == 3); }</code> </pre> <br>  Pego a matriz mem de um byte e depois verifico o que deve acontecer (o byte √© incrementado tr√™s vezes).  Isso funciona! <br><br><pre> <code class="plaintext hljs">Test 1/1 +...OK</code> </pre> <br>  "-" √© verificado da mesma maneira: <br><br><pre> <code class="plaintext hljs">test "-" { var mem = []u8{0}; const src = "---"; bf(src, mem[0..]); assert(mem[0] == 253); }</code> </pre> <br>  N√£o funciona!  Quando tento subtrair 1 de 0, recebo ... <br><br><pre> <code class="bash hljs">Test 2/2 -...<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> overflow</code> </pre> <br>  mem √© uma matriz de bytes n√£o assinados e subtrair 1 de 0 causa um estouro.  Mais uma vez, Zig me faz declarar o que quero explicitamente.  Nesse caso, n√£o preciso me preocupar com estouro, de fato, quero que isso aconte√ßa, j√° que estamos lidando com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aritm√©tica modular</a> , de acordo com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o do c√©rebro</a> .  Isso significa que decrementar uma c√©lula com o n√∫mero 0 me dar√° 255 e um incremento de 255 me dar√° 0. <br><br>  O Zig possui v√°rias opera√ß√µes aritm√©ticas auxiliares que oferecem a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sem√¢ntica do "empacotamento" garantido</a> . <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] +%= 1, '-' =&gt; mem[memptr] -%= 1,</code> </pre> <br>  Isso resolve todo o problema do estouro e faz o que eu esperava. <br><br>  Para testar &lt;e&gt;, navego por uma pequena matriz e verifico o valor da c√©lula incrementada: <br><br><pre> <code class="plaintext hljs">test "&gt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++"; bf(src, mem[0..]); assert(mem[3] == 3); }</code> </pre> <br>  e ... <br><br><pre> <code class="plaintext hljs">test "&lt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, mem[0..]); assert(mem[3] == 3); assert(mem[2] == 2); assert(mem[1] == 1); }</code> </pre> <br>  Neste √∫ltimo caso, posso comparar diretamente o resultado com uma matriz est√°tica usando ... <br><br><pre> <code class="plaintext hljs">const mem = std.mem;</code> </pre> <br>  Lembre-se de que eu j√° importei std.  No exemplo abaixo, eu uso o mem.eql neste espa√ßo para nome: <br><br><pre> <code class="plaintext hljs">test "&lt;" { var storage = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, storage[0..]); assert(mem.eql(u8, storage, []u8{ 0, 1, 2, 3, 0 })); }</code> </pre> <br>  ... e lembre-se, literais de string, s√£o apenas matrizes u8 em zig, e eu posso colocar literais hexadecimais neles, ou seja,  O c√≥digo a seguir funcionar√° da mesma maneira! <br><br><pre> <code class="plaintext hljs">assert(mem.eql(u8, storage, "\x00\x01\x02\x03\x00"));</code> </pre> <br>  Adicione o "."!  Simplesmente imprime como caractere o valor do byte na c√©lula que o ponteiro aponta.  Estou usando o aviso agora, mas mais tarde vou substitu√≠-lo por stdout.  Isso √© f√°cil de fazer conceitualmente, mas um pouco confuso na implementa√ß√£o.  Farei isso mais tarde! <br><br><pre> <code class="plaintext hljs">'.' =&gt; warn("{c}", storage[memptr]),</code> </pre> <br>  Ciclos <br>  [e] - a m√°gica come√ßa aqui .... <br><br>  [- se o valor da c√©lula atual for zero, pule as etapas para o colchete de fechamento sem executar o c√≥digo. <br>  ] - se o valor da c√©lula atual n√£o for zero, retorne ao colchete de abertura e execute o c√≥digo novamente. <br><br>  Desta vez, vou come√ßar com um teste, vou test√°-los juntos (obviamente, n√£o faz sentido test√°-los separadamente).  O primeiro caso de teste - a c√©lula de armazenamento [2] deve estar vazia, embora o loop deva increment√°-lo se for iniciado: <br><br><pre> <code class="plaintext hljs">test "[] skips execution and exits" { var storage = []u8{0} ** 3; const src = "+++++&gt;[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 5); assert(storage[1] == 0); assert(storage[2] == 0); }</code> </pre> <br>  e vou criar espa√ßos em branco para a instru√ß√£o switch: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { }, ']' =&gt; if (storage[memptr] == 0) { },</code> </pre> <br>  O que fazer agora?  Voc√™ pode usar uma abordagem ing√™nua.  Eu apenas incremento o ponteiro src at√© encontr√°-lo].  Mas n√£o posso usar o loop for em zig para isso, ele foi criado apenas para iterar pelas cole√ß√µes, sem perder seus elementos.  Uma constru√ß√£o adequada aqui √© enquanto: <br><br>  foi: <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; for (src) |c| { switch(c) { ... } }</code> </pre> <br>  tornou-se ... <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { ... } srcptr += 1; }</code> </pre> <br>  Agora posso reatribuir o ponteiro srcptr no meio do bloco, farei isso: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { while (src[srcptr] != ']') srcptr += 1; },</code> </pre> <br>  Isso satisfaz o teste "[] ignora a execu√ß√£o do c√≥digo e sai" <br>  Isso satisfaz o teste "[] pula a execu√ß√£o e sai", embora n√£o seja totalmente confi√°vel, como veremos. <br><br>  E quanto a fechar colchetes?  Eu acredito que pode ser escrito simplesmente por analogia: <br><br><pre> <code class="plaintext hljs">test "[] executes and exits" { var storage = []u8{0} ** 2; const src = "+++++[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 25); } ']' =&gt; if (storage[memptr] != 0) { while (src[srcptr] != '[') srcptr -= 1; },</code> </pre> <br>  Voc√™ pode ver o que acontece ... Uma solu√ß√£o ing√™nua com dois colchetes tem uma falha fatal e quebra completamente em loops aninhados.  Considere o seguinte: <br><br><pre> <code class="plaintext hljs">++&gt;[&gt;++[-]++&lt;-]</code> </pre> <br>  O resultado deve ser {2, 0}, mas o primeiro colchete aberto simplesmente se move estupidamente para o primeiro colchete, e tudo fica confuso.  Voc√™ precisa pular para o pr√≥ximo colchete de fechamento no mesmo n√≠vel de aninhamento.  √â f√°cil adicionar um contador de profundidade e rastre√°-lo √† medida que avan√ßa pela linha.  Fazemos isso nas duas dire√ß√µes: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { var depth:u16 = 1; srcptr += 1; while (depth &gt; 0) { srcptr += 1; switch(src[srcptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } }, ']' =&gt; if (storage[memptr] != 0) { var depth:u16 = 1; srcptr -= 1; while (depth &gt; 0) { srcptr -= 1; switch(src[srcptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } },</code> </pre> <br>  e testes relacionados: observe que src nos dois testes inclui um loop interno. <br><br><pre> <code class="plaintext hljs">test "[] skips execution with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++&gt;[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 2); assert(storage[1] == 0); } test "[] executes with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 2); }</code> </pre> <br><blockquote>  Separadamente, observe [-] - o idioma do c√©rebro, significando "zere esta c√©lula".  Voc√™ pode ver que n√£o importa qual o valor da c√©lula no in√≠cio, ela ser√° decrementada at√© atingir 0 e a execu√ß√£o continuar√°. </blockquote><br><h3>  Caminho azarado </h3><br>  N√£o contei com a possibilidade de o programa em bf ser interrompido.  O que acontece se eu enviar um programa de entrada incorreto ao meu int√©rprete?  Por exemplo, simplesmente [sem um colchete de fechamento, ou &lt;, que imediatamente vai al√©m da matriz de mem√≥ria?  (Posso quebrar o ponteiro da mem√≥ria, mas √© melhor considerar isso como um erro). <br><br>  Vou olhar um pouco √† frente e explicar todas as diferen√ßas no c√≥digo.  Vou colocar a fun√ß√£o int√©rprete bf em um arquivo separado e tamb√©m a funcionalidade seekBack e seekForward em minhas pr√≥prias fun√ß√µes. <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; const sub = @import("std").math.sub; fn seekBack(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr = sub(u16, ptr, 1) catch return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } return ptr; } fn seekForward(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr += 1; if (ptr &gt;= src.len) return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } return ptr; } pub fn bf(src: []const u8, storage: []u8) !void { var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { '+' =&gt; storage[memptr] +%= 1, '-' =&gt; storage[memptr] -%= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, '[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr), '.' =&gt; warn("{c}", storage[memptr]), else =&gt; {} } srcptr += 1; } }</code> </pre> <br>  Isso facilita muito a leitura, na minha opini√£o, do askForward e do askBack e parece muito semelhante, e fiquei tentado a refator√°-los para algo mais inteligente e compacto, mas no final eles fazem coisas diferentes e lidam com erros tamb√©m de maneiras diferentes.  Mais f√°cil de copiar e ajustar, e assim ficar√° mais claro.  Tamb√©m ajustarei o askForward mais tarde, em algum momento, possivelmente em uma postagem subsequente. <br><br>  Eu adicionei algumas coisas importantes!  Observe que todas as tr√™s fun√ß√µes agora est√£o retornando um tipo! .. Esta √© a nova sintaxe para o que costumava ser o tipo% T (uni√£o de erro).  Isso significa que a fun√ß√£o pode retornar um determinado tipo ou um erro.  Quando tento chamar essa fun√ß√£o, devo usar try antes de chamar a fun√ß√£o, que lan√ßa o erro na pilha de chamadas se o erro ocorrer ou usar catch: <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch {}</code> </pre> <br>  Onde eu manejo erros em um bloco catch.  Como est√° escrito, o catch pode engolir quaisquer erros.  Essa √© uma pr√°tica ruim, mas aqui o Zig nos faz faz√™-lo explicitamente.  Se eu pegar um erro em um bloco vazio, declaro que n√£o acho que possa ocorrer um erro ou n√£o preciso lidar com isso.  Na pr√°tica, pode ser algo como TODO e, de fato, √© muito f√°cil torn√°-lo expl√≠cito! <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch { @panic("TODO") }</code> </pre> <br>  Lembre-se de que esse caso nunca acontecer√° no c√≥digo de produ√ß√£o.  Estou notificando o compilador que sei o que estou fazendo.  Se um erro pudesse ocorrer, eu teria que adicionar o tratamento de erros. <br><br>  Ent√£o, quais erros devo retornar do seekBack ou seekForward? <br><br>  Em seekBack: <br><br><pre> <code class="plaintext hljs">ptr = sub(u16, ptr, 1) catch return error.OutOfBounds;</code> </pre> <br>  Substitu√≠ o ponteiro de decremento para usar a sub-fun√ß√£o std lib, que gera um erro de estouro se ocorrer um estouro.  Quero pegar esse erro e retornar o erro OutOfBounds, que eu criei aqui apenas usando-o. <br><br><blockquote>  <i>Erros O Zig √© basicamente uma matriz de c√≥digos de erro gerados pelo compilador quando voc√™ usa o erro.</i>  <i>Eles s√£o garantidos como √∫nicos e podem ser usados ‚Äã‚Äãcomo valores em um bloco de chave.</i> </blockquote><br>  Quero usar OutOfBounds aqui porque, semanticamente, se o ponteiro da mem√≥ria se tornar menor que zero, pe√ßo que o tempo de execu√ß√£o v√° al√©m do espa√ßo de mem√≥ria que aloquei. <br><br>  da mesma forma na fun√ß√£o seekForward: <br><br><pre> <code class="plaintext hljs">if (ptr &gt;= src.len) return error.OutOfBounds;</code> </pre> <br>  Nesse caso, se o ponteiro for maior que src.len, eu pego o erro aqui e retorno o mesmo erro. <br><br>  ao ligar para: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr),</code> </pre> <br>  Eu tento chamar essas fun√ß√µes.  Se eles forem chamados com √™xito, ser√£o executados corretamente e tente retorna srcptr.  Se n√£o tiverem √™xito, tente encerra a fun√ß√£o e retorna um erro no local da chamada para toda a fun√ß√£o bf. <br><br>  A chamada pode ser da principal! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; // yes, hello const hello_world = "++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;."; pub fn main() void { storage = []u8{0} ** 30000; bf(hello_world, storage[0..]) catch {}; }</code> </pre> <br>  Eu engulo esse erro aqui, e isso n√£o deve ser feito, mas observaremos um ponto importante sobre a facilidade com que o zig pode transmitir erros na pilha de chamadas.  N√£o √© responsabilidade da fun√ß√£o de chamada verificar todos os casos de erro, mas o compilador for√ßa a chamada de todas as fun√ß√µes que podem falhar com uma tentativa.  Isso sempre deve ser feito, mesmo que os erros sejam ignorados! <br><br><blockquote>  <i>A nova sintaxe try / catch elimina muitos feiti√ßos como %% e% que as pessoas n√£o gostam tanto.</i> </blockquote><br>  Agora, eu implementei 7 dos 8 caracteres do c√©rebro, e isso √© suficiente para executar um programa "significativo". <br><br><h3>  Um programa significativo </h3><br>  Aqui est√° o programa: <br><br><pre> <code class="plaintext hljs">//   ,   const fib = "++++++++++++++++++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++++&gt;++++++++++++++++&gt;&gt;+&lt;&lt;[&gt;&gt;&gt;&gt;++++++++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[&lt;+&gt;-]&gt;[-]&gt;&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;&lt;&lt;++++++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&gt;.&gt;&gt;[&gt;&gt;+&lt;&lt;-]&gt;[&gt;+&lt;&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]&lt;&lt;++...";</code> </pre> <br>  Vamos correr ... <br><br><pre> <code class="plaintext hljs">pub fn main() void { storage = []u8{0} ** 30000; bf(fib, storage[0..]) catch {}; }</code> </pre> <br>  voila! <br><br><pre> <code class="plaintext hljs">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 121, 98, 219,</code> </pre> <br><blockquote>  <i>Uma lembran√ßa volta a mim toda vez que penso em uma s√©rie de Fibonacci ... eu a descobri no programa PBS (Public Broadcasting Service, um servi√ßo de transmiss√£o de televis√£o n√£o comercial americano) nos anos 80, e sempre me lembro disso.</i>  <i>Eu pensei que seria esquecido, mas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Youtube √© uma grande coisa</a> .</i> </blockquote><br><h3>  Como posso melhorar isso? </h3><br>  Eu j√° sugeri alguns TODOs.  Eu n√£o deveria ter usado stderr para sa√≠da.  Eu quero usar stdout. <br><br>  Cada vez que abro o int√©rprete, abro o fluxo no stdout e imprimo nele: <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br>  O que est√° acontecendo aqui?   io.getStdOut(),     (          catch unreachable ‚Äî     ,  !).   ,    ,      ,       print. print   ,   warn,     . print    ,      . <br><br>    ,         stdout,        stdout. Zig         ,   ,    . <br><br>  ,   ,        ?              ,      ,            ?  ,        ?  , Zig  ! <br><br>     ,  ! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch unreachable; }</code> </pre> <br><br>  ,  bf   ,     !void.       ,   main.          ,      : <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br>    ! <br><br><pre> <code class="bash hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> switch shell returned 1</code> </pre> <br>      ,      bf   !   ,     ,  stdout,     bf.  ,   ,       ,  try. ,   ,  ,  catch,   try,      ,       . <br><br> , : <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br> : <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(try io.getStdOut())).stream); ... '.' =&gt; try stdout.print("{c}", storage[memptr]), ...</code> </pre> <br> : <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br>      ,    ,  ! <br><br><pre> <code class="plaintext hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.SystemResources not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OperationAborted not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.IoPending not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.BrokenPipe not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.Unexpected not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.WouldBlock not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileClosed not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DestinationAddressRequired not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DiskQuota not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileTooBig not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.InputOutput not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoSpaceLeft not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.AccessDenied not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoStdHandles not handled in switch shell returned 1</code> </pre> <br> Zig       ,       !   switch   ,  ,   ,  ,     . <br><br><pre> <code class="plaintext hljs">pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { error.OutOfBounds =&gt; @panic("Out Of Bounds!"), else =&gt; @panic("IO error") }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainda n√£o est√° correto o tratamento de erros, a rigor, mas s√≥ quero demonstrar como o Zig √© inteligente, relatando todos os tipos de casos de erro √† fun√ß√£o de chamada! </font><font style="vertical-align: inherit;">E quando ocorre um erro, voc√™ obt√©m um </font><font style="vertical-align: inherit;">rastreamento de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erro em</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vez de um rastreamento de pilha! </font><font style="vertical-align: inherit;">Coisa legal!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem muitas melhorias diferentes que voc√™ pode fazer com o int√©rprete! Na verdade, voc√™ precisa lidar corretamente com todos os erros e implementar o operador ",", que no brainfuck atua como a fun√ß√£o getc, permitindo inserir dados no programa quando ele √© executado. Voc√™ tamb√©m precisa tornar poss√≠vel ler o arquivo de origem no buffer e interpret√°-lo, em vez de usar o c√≥digo-fonte bf codificado. Existem tamb√©m algumas melhorias que n√£o s√£o estritamente necess√°rias, mas podem ilustrar alguns dos recursos do Zig. Em vez de despej√°-los todos no final do post, vou dividi-los em partes e public√°-los em posts futuros, que ser√£o menores e mais f√°ceis de digerir.</font></font><br><br><h3>  Conclus√£o </h3><br>  ,           ,     Zig       . Zig    ,       ,     ,  ,     ,          ++.        ,  ,   .     ,   ,   . Zig ,   ,       ,      . <br><br>         Zig,    ,      0.2.0  !  ,   ,   debug-,          ,    !   --release-fast  --release-safe,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> .             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br>        Zig.     ,       1.0.0,      Zig,    ,    ,       ! <br><br> ,    #zig  freenode   ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435574/">https://habr.com/ru/post/pt435574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435560/index.html">Primeiro computador qu√¢ntico comercial - IBM</a></li>
<li><a href="../pt435562/index.html">O caminho de um fumante: como ingressar na profiss√£o de programador, se voc√™ √© humanista</a></li>
<li><a href="../pt435564/index.html">Usando GtkApplication. Recursos de renderiza√ß√£o Librsvg</a></li>
<li><a href="../pt435568/index.html">Roteador VyOS OpenSource</a></li>
<li><a href="../pt435572/index.html">Anycubic i3 Mega: remake de qualidade do Prusa i3</a></li>
<li><a href="../pt435576/index.html">1C, sem dor</a></li>
<li><a href="../pt435578/index.html">Passeio espacial no Natal</a></li>
<li><a href="../pt435580/index.html">Servi√ßos Java, Spring, Kurento e M√≠dia</a></li>
<li><a href="../pt435582/index.html">Como adicionar um √≠ndice em um sistema carregado 24/7, sem tempo de inatividade?</a></li>
<li><a href="../pt435584/index.html">Slush 2018. Primeiro dia, segundo dia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>