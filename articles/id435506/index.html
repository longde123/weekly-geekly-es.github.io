<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌄 👨🏽‍⚕️ ♨️ Game Boy Supercomputer 🧛🏾 🧝🏽 👼🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada kecepatan lebih dari 1 miliar frame per detik, ini bisa dibilang yang tercepat dari cluster konsol 8-bit di dunia. 


 Distributed Tetris (1989) ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Game Boy Supercomputer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435506/">  Pada kecepatan lebih dari 1 miliar frame per detik, ini bisa dibilang yang tercepat dari cluster konsol 8-bit di dunia. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e7/0fa/97d/4e70fa97d86589ec00f0a570a3835feb.gif"><br>  <i>Distributed Tetris (1989)</i> <br><br><h2>  Bagaimana cara membangun komputer seperti itu? </h2><br><h3>  Resep </h3><br>  Ambil segenggam silikon, terapkan pelatihan penguatan, pengalaman dengan superkomputer, hasrat untuk arsitektur komputer, tambahkan keringat dan air mata, aduk 1000 jam hingga mendidih - dan voila. <br><br><h2>  Mengapa ada orang yang membutuhkan komputer seperti itu? </h2><br>  Singkatnya: bergerak ke arah meningkatkan kecerdasan buatan. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/1bd/3ef/d7f1bd3ef8197d18fc1612235bfbc0df.png"><br>  <i>Salah satu dari 48 papan Komputer Neural IBM digunakan untuk percobaan</i> <br><br><h2>  Dan ini adalah versi yang lebih detail </h2><br>  Tahun 2016.  Pembelajaran mendalam ada di mana-mana.  Pengenalan gambar dapat dianggap sebagai tugas yang diselesaikan berkat jaringan saraf convolutional, dan minat penelitian saya berusaha keras untuk jaringan saraf dengan memori dan pembelajaran yang diperkuat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa6/7e2/2de/aa67e22de1d4c2eb58f415beb61628e9.png"><br><br>  Secara khusus, dalam karya kepengarangan Google Deepmind ditunjukkan bahwa adalah mungkin untuk mencapai tingkat seseorang atau bahkan melampaui itu di berbagai game untuk Atari 2600 (konsol game rumah, dirilis pada tahun 1977), menggunakan algoritma pembelajaran sederhana yang didukung oleh Deep Q-Neural Network.  Dan semua ini terjadi hanya ketika melihat gameplay.  Itu menarik perhatian saya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e3e/dd5/f97/e3edd5f97096170a43b775859b539087.gif"><br>  <i>Salah satu game dengan Atari 2600, Breakout.</i>  <i>Mesin itu dilatih menggunakan algoritma pembelajaran penguatan sederhana.</i>  <i>Setelah jutaan iterasi, komputer mulai bermain lebih baik daripada manusia.</i> <br><br>  Saya mulai bereksperimen dengan game Atari 2600. Breakout, meskipun mengesankan, tidak bisa disebut rumit.  Kesulitan dapat ditentukan oleh tingkat kesulitan sesuai dengan tindakan Anda (joystick) dan hasil Anda (poin).  Masalah muncul ketika efeknya harus menunggu lama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/849/950/f41849950d6af5392b78e51f838ec707.gif"><br>  <i>Ilustrasi masalah menggunakan game yang lebih kompleks sebagai contoh.</i>  <i>Left - Breakout (ATARI 2600) [penulis salah, ini adalah game Pong / kira-kira.</i>  <i>trans.] dengan respons yang sangat cepat dan umpan balik yang cepat.</i>  <i>Kanan - Mario Land (Nintendo Game Boy) tidak memberikan informasi instan tentang efek tindakan, pengamatan yang tidak relevan dalam waktu yang lama dapat muncul di antara dua peristiwa penting.</i> <br><br>  Untuk membuat pembelajaran lebih efektif, orang dapat membayangkan upaya untuk mentransfer beberapa pengetahuan dari game yang lebih sederhana.  Tugas ini sekarang tetap belum terselesaikan, dan merupakan topik aktif untuk penelitian.  Sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tugas yang</a> baru-baru ini diterbitkan dari OpenAI sedang mencoba mengukur hal itu. <br><br>  Kemampuan untuk mentransfer pengetahuan tidak hanya akan mempercepat pelatihan - saya percaya bahwa beberapa masalah belajar tidak dapat diselesaikan sama sekali tanpa adanya pengetahuan dasar.  Kami membutuhkan efisiensi data.  Ambil game Prince of Persia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/139/4d7/aa6/1394d7aa679b5a687d07cd97a5c68d4b.gif"><br><br>  Tidak ada poin jelas di dalamnya. <br>  Butuh 60 menit untuk menyelesaikan permainan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/c4d/5b7/11bc4d5b76ad0a167c31067edd0d30ea.gif"><br><br>  Apakah mungkin untuk menerapkan pendekatan yang sama yang digunakan saat menulis karya pada Atari 2600?  Seberapa besar kemungkinan Anda bisa sampai pada akhirnya dengan menekan tombol acak? <br><br>  Pertanyaan ini mendorong saya untuk berkontribusi pada komunitas, yang terdiri dari mencoba menyelesaikan masalah ini.  Faktanya, kita memiliki tugas ayam dan telur - kita membutuhkan algoritma yang lebih baik yang akan memungkinkan kita untuk mengirimkan pesan, namun, ini memerlukan penelitian, dan eksperimen memakan waktu, karena kita tidak memiliki algoritma yang lebih efisien. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc9/009/5f1/fc90095f174e9052dfb677996562ac14.png"><br>  <i>Contoh transfer pengetahuan: bayangkan bahwa kami pertama kali belajar memainkan permainan sederhana, seperti yang ada di sebelah kiri.</i>  <i>Kemudian kita menyimpan konsep seperti "ras", "mobil", "trek", "menang" dan belajar warna atau model tiga dimensi.</i>  <i>Kami berpendapat bahwa konsep umum dapat "dibawa" antar gim.</i>  <i>Kesamaan game dapat ditentukan oleh jumlah pengetahuan yang ditransfer di antara mereka.</i>  <i>Misalnya, game Tetris dan F1 tidak akan serupa.</i> <br><br>  Oleh karena itu, saya memutuskan untuk menggunakan pendekatan ideal kedua, menghindari perlambatan awal, secara dramatis mempercepat sistem.  Tujuan saya adalah: <br>  - Lingkungan dipercepat (bayangkan bahwa Prince of Persia dapat diselesaikan 100 kali lebih cepat) dan peluncuran simultan 100.000 game. <br>  - lingkungan yang lebih cocok untuk penelitian (kami berkonsentrasi pada tugas, tetapi tidak pada perhitungan awal, kami memiliki akses ke berbagai permainan). <br><br>  Awalnya, saya berpikir bahwa bottleneck kinerja entah bagaimana tergantung pada kompleksitas kode emulator (misalnya, basis kode Stella besar, dan bergantung pada abstraksi C ++ - bukan pilihan terbaik untuk emulator). <br><br><h2>  Konsol </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/900/dc8/c32/900dc8c322e070709af65b0f89d55146.jpg"><br><br>  Secara total, saya bekerja di beberapa platform, dimulai dengan salah satu game pertama yang pernah dibuat (bersama dengan game Pong) - Arcade Space Invaders, Atari 2600, NES dan Game Boy.  Dan semua ini ditulis dalam C. <br><br>  Saya berhasil mencapai frame rate maksimum 2000-3000 per detik.  Untuk mulai mendapatkan hasil eksperimen, kami membutuhkan jutaan atau milyaran frame, sehingga jaraknya sangat besar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/677/cd2/ebd/677cd2ebda80be7e5eace8380911c084.gif"><br>  <i>Space Invaders bekerja di FPGA - mode debugging kecepatan rendah.</i>  <i>Penghitung FPGA menunjukkan jumlah siklus jam yang telah berlalu.</i> <br><br>  Dan kemudian saya berpikir - bagaimana jika kita dapat mempercepat lingkungan yang tepat dengan besi.  Misalnya, Space Invaders asli pergi ke CPU 8080 dengan frekuensi 1 MHz.  Saya berhasil meniru CPU 8080 40 MHz pada prosesor Xeon 3 GHz.  Tidak buruk, tetapi setelah saya meletakkan semua ini di dalam FPGA, frekuensinya naik menjadi 400 MHz.  Itu berarti 24.000 FPS dari satu aliran - setara dengan 30 GHz Xeon!  Apakah saya menyebutkan bahwa Anda dapat menjejalkan 100 8080 prosesor menjadi FPGA rata-rata?  Ini sudah menghasilkan 2,4 juta FPS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/415/82a/dd1/41582add164c44c52b01fdfec7160e20.gif"><br>  <i>Space Invaders dengan akselerasi perangkat keras 100 MHz, seperempat kecepatan penuh</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90d/8a8/4e0/90d8a84e0053c30eb4b337b27c15dcfc.png"><br>  <i>Lebih dari seratus core di dalam Xilinx Kintex 7045 FPGA (ditunjukkan oleh warna-warna cerah; titik biru di tengah adalah logika umum untuk demonstrasi).</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c1/dc9/f93/4c1dc9f93c26391a762466a8216053f9.png"><br>  <i>Jalur eksekusi tidak rata</i> <br><br>  Anda mungkin bertanya, bagaimana dengan GPU?  Singkatnya, kita membutuhkan konkurensi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MIMD</a> , bukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SIMD</a> .  Sebagai seorang mahasiswa, saya bekerja selama beberapa waktu untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengimplementasikan</a> pencarian pohon Monte Carlo pada GPU (pencarian semacam itu digunakan di AlphaGo). <br><br>  Pada saat itu, saya menghabiskan waktu berjam-jam mencoba untuk mendapatkan GPU dan perangkat keras lainnya bekerja pada prinsip SIMD (IBM Cell, Xeon Phi, AVX CPU) untuk mengeksekusi kode seperti itu, dan tidak ada yang datang darinya.  Beberapa tahun yang lalu, saya mulai berpikir bahwa akan menyenangkan untuk dapat secara mandiri mengembangkan perangkat keras yang dirancang khusus untuk memecahkan masalah yang terkait dengan pelatihan penguatan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/479/730/b57/479730b5758c7bbccecd7be47f8ca310.gif"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d98/4ee/ad9/d984eead9cd837908580a0545210918b.png"><br>  <i>Konkurensi MIMD</i> <br><br><h2>  ATARI 2600, NES atau Game Boy? </h2><br>  Pada 8080, saya mengimplementasikan Space Invaders, NES, 2600, dan Game Boy.  Dan inilah beberapa fakta tentang mereka dan manfaatnya masing-masing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f26/475/be6/f26475be6707be383030b9e116222a71.png"><br>  <i>NES Pacman</i> <br><br>  Space Invaders hanyalah pemanasan.  Kami berhasil membuat mereka bekerja, tetapi itu hanya satu pertandingan, jadi hasilnya tidak terlalu berguna. <br><br>  Atari 2600 sebenarnya adalah standar dalam penelitian pembelajaran penguatan.  Prosesor MOS 6507 adalah versi sederhana dari 6502 yang terkenal, desainnya lebih elegan dan lebih efisien daripada 8080. Saya memilih 2600 bukan hanya karena batasan tertentu terkait dengan game dan grafiknya. <br><br>  Saya juga menerapkan NES (Nintendo Entertainment System), berbagi CPU dengan 2600. Ada permainan yang jauh lebih baik daripada 2600. Tetapi kedua konsol menderita dari pipa pemrosesan grafis yang terlalu rumit dan beberapa format kartrid yang perlu didukung. <br><br>  Sementara itu, saya menemukan kembali Nintendo Game Boy.  Dan itulah yang saya cari. <br><br><h2>  Mengapa Game Boy sangat keren? </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/447/518/78d/44751878d5be5df4e754fdee7913d224.jpg" alt="gambar"><br>  <i>1049 game klasik dan 576 game untuk Game Boy Color</i> <br><br>  Secara total, lebih dari 1000 game, variasi yang sangat luas, kualitas tinggi, beberapa di antaranya cukup kompleks (Prince), game dapat dikelompokkan dan diberikan kompleksitas untuk penelitian transfer pengetahuan dan pelatihan (misalnya, ada pilihan untuk Tetris, game balap, Mario).  Untuk menyelesaikan permainan Prince of Persia, Anda mungkin perlu mentransfer pengetahuan dari beberapa game serupa lainnya yang poinnya ditunjukkan dengan jelas (dalam Prince ini bukan). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ff/f8e/9e7/5fff8e9e75b38f13eb5161b316c76030.gif"><br>  <i>Nintendo Game Boy adalah platform penelitian transfer pengetahuan favorit saya.</i>  <i>Pada grafik, saya mencoba mengelompokkan permainan berdasarkan kompleksitas (subyektif) dan kesamaan (konsep seperti balap, melompat, menembak, berbagai permainan seperti Tetris; apakah ada yang bermain HATRIS?).</i> <br><br>  Game Boy klasik memiliki layar yang sangat sederhana (160x144, warna 2-bit), sehingga pemrosesan awal menjadi sederhana, dan Anda dapat berkonsentrasi pada hal-hal penting.  Pada 2600, bahkan game sederhana memiliki banyak warna.  Selain itu, pada objek Game Boy diperlihatkan jauh lebih baik, tanpa berkedip dan tanpa perlu mengambil maksimum dua frame berturut-turut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/740/9ae/843/7409ae843366b71257755bc7701af3c8.gif"><br><br>  Tidak ada tata letak memori yang gila, seperti NES atau 2600. Sebagian besar game dapat dibuat bekerja dengan 2-3 pemetaan. <br><br>  Kode ringkas - Saya berhasil menyesuaikan seluruh emulator di C dalam tidak lebih dari 700 baris kode, dan implementasi Verilog saya muat dalam 500 baris. <br><br>  Ada versi sederhana yang sama dari Space Invaders seperti di arcade. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10f/5d0/838/10f5d0838acb88b453ff82b778389265.gif"><br><br>  Dan inilah dia, Game Boy dot-matrix 1989 saya dan versi FPGA yang bekerja melalui HDMI pada layar 4K. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/dd5/77d/ca2dd577d1711be2ddb2d3426dc07c39.png"><br><br>  Dan inilah yang tidak bisa dilakukan Game Boy lama saya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/343/e65/d45/343e65d45de2b5bac8bd31ffccb7be6e.gif"><br>  <i>Tetris dipercepat dengan besi - merekam dari layar secara real time, kecepatannya adalah 1/4 dari maksimum.</i> <br><br><h2>  Apakah ada manfaat nyata untuk ini? </h2><br>  Ya ada.  Sejauh ini, saya telah menguji sistem dalam kondisi sederhana, dengan jaringan aturan eksternal yang berinteraksi dengan masing-masing Game Boys.  Lebih khusus lagi, saya menggunakan algoritma A3C (Advantage Actor Critic), dan saya berencana untuk menggambarkannya dalam posting terpisah.  Rekan saya menghubungkannya ke jaringan convolutional pada FPGA, dan itu berfungsi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/202/75a/cb720275a2f42cf3e17fc28167ec55f0.png"><br>  <i>Bagaimana FGPA berkomunikasi dengan jaringan saraf</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da4/f65/160/da4f6516036832a572de98a4bec081e4.png"><br>  <i>A3C yang didistribusikan</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3c/2b2/607/c3c2b26079064aa7ab6fee6f4a7f373e.gif"><br>  <i>Mario land: kondisi awal.</i>  <i>Keystroke acak tidak akan membawa kita jauh.</i>  <i>Pojok kanan atas menunjukkan waktu yang tersisa.</i>  <i>Jika kita beruntung, kita akan segera mengakhiri permainan setelah menyentuh gumba.</i>  <i>Jika tidak, butuh 400 detik untuk "kalah".</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/088/0a9/618/0880a9618a01a45c6358469604dea92d.gif"><br>  <i>Mario tanah: setelah satu jam bermain, Mario belajar berlari, melompat dan bahkan membuka ruang rahasia, merangkak ke dalam pipa.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3b/d37/a82/b3bd37a82e9692319784667a7be9c13c.gif"><br>  <i>Pac Man: setelah sekitar satu jam pelatihan, jaringan saraf bahkan bisa menyelesaikan seluruh permainan satu kali (dengan memakan semua poin).</i> <br><br><h2>  Kesimpulan </h2><br>  Saya ingin berpikir bahwa dekade berikutnya akan menjadi periode ketika superkomputer dan AI menemukan satu sama lain.  Saya ingin memiliki perangkat keras yang memungkinkan saya untuk mengatur diri saya ke tingkat tertentu untuk beradaptasi dengan algoritma AI yang diinginkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d06/248/162/d062481627eb1e355c5488ead2ca7ef7.png"><br>  <i>Dekade berikutnya</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode untuk Game Boy di C.</a> <br><br><h2>  Debugging </h2><br>  Orang sering bertanya kepada saya: apa yang paling sulit?  Itu saja - seluruh proyek cukup menyakitkan.  Sebagai permulaan, tidak ada spesifikasi untuk Game Boy.  Segala sesuatu yang kami pelajari, kami dapatkan berkat rekayasa balik, yaitu, kami meluncurkan tugas perantara, seperti permainan, dan menyaksikan bagaimana itu dilakukan.  Ini sangat berbeda dari debugging perangkat lunak standar, karena di sini kita men-debug perangkat keras yang menjalankan program.  Saya harus menemukan cara yang berbeda untuk mencapai ini.  Dan saya berbicara tentang betapa sulitnya memonitor suatu proses ketika beroperasi pada frekuensi 100 MHz?  Oh, dan tidak ada printf di sana. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9df/173/ab1/9df173ab1b05d831461a16152646be72.png"><br>  <i>Salah satu pendekatan untuk mengimplementasikan CPU adalah mengelompokkan instruksi pada fungsinya.</i>  <i>Dengan 6502 jauh lebih mudah.</i>  <i>LR35092 menjejalkan banyak omong kosong “acak” dan ada banyak pengecualian.</i>  <i>Saya menggunakan tabel ini ketika bekerja dengan CPU Game Boy.</i>  <i>Saya menggunakan strategi serakah - saya mengambil instruksi terbesar, menerapkannya dan menghapusnya, lalu mengulanginya.</i>  <i>1/4 dari instruksi adalah ALU, 1/4 adalah register loading, yang dapat diimplementasikan dengan cepat.</i>  <i>Di sisi lain spektrum ada segala macam hal yang terpisah, seperti "unggah dari HL ke SP dengan tanda," yang harus diproses secara terpisah.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96b/ec9/38b/96bec938bbac5dbab9b8c71f6024d31b.jpg"><br>  <i>Debugging: jalankan kode pada perangkat keras yang Anda debug, tulis log implementasi Anda dan informasi tambahan (di sini perbandingan kode Verilog di sebelah kiri dengan C-emulator saya di sebelah kanan ditampilkan).</i>  <i>Kemudian jalankan diff untuk log untuk menemukan inkonsistensi (biru).</i>  <i>Salah satu alasan untuk menggunakan otomatisasi adalah bahwa dalam banyak kasus saya menemukan masalah setelah jutaan siklus eksekusi ketika satu flag CPU menyebabkan efek bola salju.</i>  <i>Saya mencoba beberapa pendekatan, dan yang ini ternyata yang paling efektif.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e50/bea/455/e50bea45577d7225024a0aa66174f9bd.png"><br>  <i>Anda akan membutuhkan banyak kopi!</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/196/d2e/4eb/196d2e4ebf91bda8e1943dc5e7f81a89.png"><br>  <i>Buku-buku ini berusia 40 tahun.</i>  <i>Sungguh menakjubkan menggeledah mereka dan melihat dunia komputer melalui mata para pengguna saat itu - saya merasa seperti tamu dari masa depan.</i> <br><br><h2>  Permintaan Penelitian OpenAI </h2><br>  Pada awalnya saya ingin bekerja dengan game dalam hal memori, seperti yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> dari OpenAI. <br><br>  Anehnya, mendapatkan Q-learning agar bekerja dengan baik pada input yang mewakili kondisi memori ternyata sulit. <br><br>  Proyek ini mungkin tidak memiliki solusi.  Tidak disangka mengetahui bahwa belajar-Q tidak akan pernah berhasil bekerja dengan memori di Atari, tetapi ada kemungkinan bahwa tugas ini akan sangat sulit. <br><br>  Menimbang bahwa permainan di Atari hanya menggunakan memori 128 b, tampaknya sangat menarik untuk memproses 128 b ini alih-alih bingkai layar penuh.  Saya mendapat hasil yang beragam, jadi saya mulai mencari tahu. <br><br>  Dan meskipun saya tidak dapat membuktikan bahwa tidak mungkin untuk belajar dari ingatan, saya dapat menunjukkan bahwa anggapan bahwa ingatan mencerminkan keadaan permainan sepenuhnya adalah salah.  CPU Atari 2600 (6507) menggunakan memori 128 b, tetapi masih memiliki akses ke register tambahan yang hidup di sirkuit terpisah (TIA, adaptor untuk TV, sesuatu seperti GPU).  Register ini digunakan untuk menyimpan dan memproses informasi tentang objek (raket, roket, bola, tabrakan).  Dengan kata lain, mereka tidak akan dapat diakses jika kita hanya mempertimbangkan ingatan.  NES dan Game Boy juga memiliki register tambahan yang digunakan untuk mengontrol layar dan gulir.  Hanya satu memori yang tidak mencerminkan kondisi permainan sepenuhnya. <br><br>  Hanya 8080 yang secara langsung menyimpan data dalam memori video, yang memungkinkan Anda untuk mengekstrak seluruh kondisi permainan.  Dalam kasus lain, register "GPU" terhubung antara CPU dan buffer layar, sementara di luar RAM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b9/d23/019/0b9d2301998c1cc9dcf414c36fe8e1e3.png"><br><br>  Fakta menarik: jika Anda melakukan penelitian tentang sejarah GPU, maka 8080 mungkin menjadi "akselerator grafis" pertama - ini memiliki register geser eksternal yang memungkinkan Anda untuk memindahkan penjajah ruang angkasa dengan satu perintah, yang membongkar CPU. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HyzD8pNlpwI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><img src="https://habrastorage.org/getpro/habr/post_images/899/16c/2d0/89916c2d015f8b881ec16411906ab2aa.png"><br>  Eof </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435506/">https://habr.com/ru/post/id435506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435496/index.html">Tesla menggugat karena kecelakaan di mana pengemudi dan penumpang Model S meninggal</a></li>
<li><a href="../id435498/index.html">Perpanjangan Direktur vCloud: Migrasi</a></li>
<li><a href="../id435500/index.html">Sarung tangan biometrik di motorsport</a></li>
<li><a href="../id435502/index.html">Studi ini mengungkapkan pro dan kontra perfeksionisme</a></li>
<li><a href="../id435504/index.html">Monster tangan dalam perjuangan untuk kebersihan: pilihan vacuum cleaner manual Xiaomi</a></li>
<li><a href="../id435508/index.html">Bagaimana cara membuat komputer terbaik di Rusia? Wawancara dengan Artyom Smirnov dari HYPERPC</a></li>
<li><a href="../id435510/index.html">Mikroelektronika, neurofisiologi dan pembelajaran mesin, goyang tetapi tidak tercampur</a></li>
<li><a href="../id435512/index.html">Pengembang Royole Menunjukkan Smartphone Fleksibel yang Dapat Dilipat</a></li>
<li><a href="../id435514/index.html">Di Rusia, mereka mengembangkan prosesor untuk mempercepat jaringan saraf</a></li>
<li><a href="../id435520/index.html">Kami menulis bahasa pemrograman kami, bagian 3: Arsitektur penerjemah. Analisis struktur bahasa dan ekspresi matematika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>