<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíµ üï¶ üóª Recursos de filtragem de janelas no FPGA üíáüèø üõÑ üë©üèæ‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! Este artigo se concentrar√° em uma parte importante do processamento de sinal digital - a filtragem do sinal da janela, em particular nos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recursos de filtragem de janelas no FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427361/"> Ol√° pessoal!  Este artigo se concentrar√° em uma parte importante do processamento de sinal digital - a filtragem do sinal da janela, em particular nos FPGAs.  O artigo mostrar√° como projetar janelas cl√°ssicas de comprimento padr√£o e janelas "longas" de amostras de 64K a 16M +.  A principal linguagem de desenvolvimento √© VHDL, a base do elemento s√£o os cristais Xilinx FPGA mais recentes das fam√≠lias mais recentes: s√£o Ultrascale, Ultrascale +, 7-series.  O artigo demonstrar√° a implementa√ß√£o do CORDIC - o kernel b√°sico para configurar fun√ß√µes de janela de qualquer dura√ß√£o, bem como fun√ß√µes b√°sicas de janela.  O artigo descreve o m√©todo de design usando linguagens de alto n√≠vel C / C ++ no Vivado HLS.  Como de costume, no final do artigo, voc√™ encontrar√° um link para os c√≥digos-fonte do projeto. <br><br>  KDPV: um esquema t√≠pico de transmiss√£o de sinal atrav√©s de n√≥s DSP para tarefas de an√°lise de espectro. <br><br><img src="https://habrastorage.org/webt/hq/5j/_l/hq5j_lnsfr_k8oaex-cesewdeyi.png"><br><a name="habracut"></a><br><h3>  1. Introdu√ß√£o </h3><br>  No curso ‚ÄúProcessamento digital de sinais‚Äù, muitas pessoas sabem que, para uma forma de onda senoidal infinita no tempo, seu espectro √© uma fun√ß√£o delta na frequ√™ncia do sinal.  Na pr√°tica, o espectro de um sinal harm√¥nico limitado em tempo real √© equivalente √† fun√ß√£o <b>~ sin (x) / x</b> , e a largura do lobo principal depende da dura√ß√£o do intervalo de an√°lise de sinal <b>T.</b>  O limite de tempo nada mais √© do que multiplicar o sinal por um envelope retangular.  Sabe-se pelo curso DSP que a multiplica√ß√£o de sinais no dom√≠nio do tempo √© uma convolu√ß√£o de seus espectros no dom√≠nio da frequ√™ncia (e vice-versa); portanto, o espectro do envelope retangular limitado do sinal harm√¥nico √© equivalente a ~ sinc (x).  Isso tamb√©m se deve ao fato de n√£o podermos integrar o sinal por um intervalo de tempo infinito, e a transformada de Fourier, de forma discreta, expressa por uma soma finita, √© limitada pelo n√∫mero de amostras.  Como regra, o comprimento da FFT nos modernos dispositivos de processamento digital FPGA leva os valores <b>NFFT</b> de 8 a v√°rios milh√µes de pontos.  Em outras palavras, o espectro do sinal de entrada √© calculado no intervalo <b>T</b> , que em muitos casos √© igual a <b>NFFT</b> .  Limitando o sinal ao intervalo <b>T</b> , impomos assim uma ‚Äújanela‚Äù retangular com uma dura√ß√£o de amostras <b>T.</b>  Portanto, o espectro resultante √© o espectro do sinal harm√¥nico multiplicado e o envelope retangular.  Nas tarefas DSP, janelas de v√°rias formas s√£o inventadas h√° muito tempo, as quais, quando sobrepostas a um sinal no dom√≠nio do tempo, podem melhorar suas caracter√≠sticas espectrais.  Um grande n√∫mero de v√°rias janelas se deve principalmente a um dos principais recursos de qualquer sobreposi√ß√£o de janela.  Esse recurso √© expresso na rela√ß√£o entre o n√≠vel dos lobos laterais e a largura do lobo central.  Um padr√£o bem conhecido: quanto mais forte a supress√£o dos lobos laterais, maior o lobo principal e vice-versa. <br><br>  Uma das aplica√ß√µes das fun√ß√µes da janela: detec√ß√£o de sinais fracos contra o fundo dos mais fortes, suprimindo o n√≠vel dos lobos laterais.  As fun√ß√µes da janela principal nas tarefas DSP s√£o uma janela triangular, sinusoidal, Lanczos, Hann, Hamming, Blackman, Harris, Blackman-Harris, janela flat-top, Natall, Gauss, Kaiser e muitas outras.  A maioria deles √© expressa atrav√©s de uma s√©rie finita pela soma de sinais harm√¥nicos com pesos espec√≠ficos.  As janelas de formato complexo s√£o calculadas usando um expoente (janela Gaussiana) ou uma fun√ß√£o Bessel modificada (janela Kaiser) e n√£o ser√£o consideradas neste artigo.  Voc√™ pode ler mais sobre fun√ß√µes de janela na literatura, que tradicionalmente darei no final do artigo. <br><br>  A figura a seguir mostra as fun√ß√µes t√≠picas da janela e suas caracter√≠sticas espectrais criadas usando as ferramentas CAD do Matlab. <br><br><img src="https://habrastorage.org/webt/nf/dw/pm/nfdwpmdfjlxbkjx4thfjo3d3wrq.png"><br><br><h3>  Implementa√ß√£o </h3><br>  No in√≠cio do artigo, inseri o KDPV, que mostra em termos gerais um diagrama estrutural da multiplica√ß√£o dos dados de entrada por uma fun√ß√£o da janela.  Obviamente, a maneira mais f√°cil de implementar o armazenamento de uma fun√ß√£o de janela no FPGA √© grav√°-la na mem√≥ria (bloco <i>RAMB</i> ou Distributed <i>Distributed</i> - isso n√£o importa muito) e, em seguida, recuperar dados ciclicamente no momento das amostras do sinal de entrada.  Como regra, nos modernos FPGAs, a quantidade de mem√≥ria interna permite armazenar fun√ß√µes de janela de tamanhos relativamente pequenos, que s√£o ent√£o multiplicados pelos sinais de entrada recebidos.  Por pequena, quero dizer que a janela funciona com at√© 64K amostras de comprimento. <br><br>  Mas e se a fun√ß√£o da janela for muito longa?  Por exemplo, 1 milh√£o de leituras.  √â f√°cil calcular que, para essa fun√ß√£o de janela apresentada em uma grade de 32 bits, s√£o necess√°rias c√©lulas de mem√≥ria de bloco NRAMB = 1024 * 1024 * 32/32768 = 1024 dos cristais FPGA Xilinx do tipo RAMB36K.  E para amostras de 16 milh√µes?  16 mil c√©lulas de mem√≥ria!  Nem um √∫nico FPGA moderno tem tanta mem√≥ria.  Para muitos FPGAs, isso √© demais e, em outros casos, √© um uso desnecess√°rio dos recursos do FPGA (e, √© claro, do dinheiro do cliente). <br><br>  Nesse sentido, voc√™ precisa criar um m√©todo para gerar amostras de fun√ß√£o de janela diretamente para o FPGA em tempo real, sem gravar coeficientes do dispositivo remoto na mem√≥ria do bloco.  Felizmente, as coisas b√°sicas j√° foram inventadas para n√≥s.  Usando um algoritmo como o <b>CORDIC</b> (o m√©todo <i>d√≠gito por d√≠gito</i> ), √© poss√≠vel projetar muitas fun√ß√µes de janela cujas f√≥rmulas s√£o expressas em termos de sinais harm√¥nicos (Blackman-Harris, Hann, Hamming, Nattal, etc.) <br><br><h3>  CORDIC </h3><br>  O CORDIC √© um m√©todo iterativo simples e conveniente para calcular a rota√ß√£o de um sistema de coordenadas, que permite calcular fun√ß√µes complexas executando opera√ß√µes primitivas de adi√ß√£o e deslocamento.  Usando o algoritmo CORDIC, √© poss√≠vel calcular os valores dos sinais harm√¥nicos sin (x), cos (x), encontrar as fases - atan (x) e atan2 (x, y), fun√ß√µes trigonom√©tricas hiperb√≥licas, girar o vetor, extrair a raiz do n√∫mero, etc. <br><br>  No come√ßo, eu queria pegar o kernel CORDIC finalizado e reduzir a quantidade de trabalho, mas tenho uma longa antipatia pelos kernels Xilinx.  Depois de estudar os reposit√≥rios no github, percebi que todos os kernels apresentados n√£o s√£o adequados por v√°rias raz√µes (mal documentados e ileg√≠veis, n√£o universais, criados para uma tarefa ou base de elementos espec√≠fica, <s>escritas em verilog</s> etc.).  Ent√£o pedi ao camarada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">lazifo</a> que fizesse esse trabalho para mim.  Obviamente, ele lidou com isso, porque a implementa√ß√£o do CORDIC √© uma das tarefas mais simples no campo do DSP.  Mas como sou impaciente, paralelamente ao trabalho dele, escrevi <s>minha bicicleta com</s> meu <s>pr√≥prio</s> n√∫cleo parametrizado.  Os principais recursos s√£o a profundidade de bits configur√°vel dos sinais de sa√≠da <b>DATA_WIDTH</b> e a fase de entrada normalizada <b>PHASE_WIDTH</b> de -1 a 1, e a precis√£o dos c√°lculos de <b>PRECISION</b> .  O n√∫cleo CORDIC √© executado de acordo com o circuito paralelo da tubula√ß√£o - a cada ciclo do rel√≥gio, o n√∫cleo est√° pronto para realizar c√°lculos e receber amostras de entrada.  O kernel gasta N ciclos para calcular a amostra de sa√≠da, cujo n√∫mero depende da capacidade das amostras de sa√≠da (quanto mais capacidade, mais itera√ß√µes para calcular o valor de sa√≠da).  Todos os c√°lculos ocorrem em paralelo.  Assim, CORDIC √© o n√∫cleo b√°sico para a cria√ß√£o de fun√ß√µes da janela. <br><br><h3>  Fun√ß√µes da janela </h3><br>  Na estrutura deste artigo, percebo apenas as fun√ß√µes da janela que s√£o expressas atrav√©s de sinais harm√¥nicos (Hann, Hamming, Blackman-Harris de v√°rias ordens, etc.).  O que √© necess√°rio para isso?  Em termos gerais, a f√≥rmula para construir uma janela se parece com uma s√©rie de comprimento finito. <br><br><img src="https://habrastorage.org/webt/it/ih/tg/itihtgetk0lxnpoavnivrrot0ou.png"><br><br>  Um certo conjunto de coeficientes <b><sub>ak</sub></b> e membros da s√©rie determina o nome da janela.  A mais popular e frequentemente usada √© a janela Blackman-Harris: de ordem diferente (de 3 a 11).  A seguir, √© apresentada uma tabela de coeficientes para janelas Blackman-Harris: <br><br><img src="https://habrastorage.org/webt/fy/ss/_4/fyss_4cniul5oacholwxdvxfhli.jpeg"><br><br>  Em princ√≠pio, o conjunto de janelas Blackman-Harris √© aplic√°vel em muitos problemas de an√°lise espectral e n√£o √© necess√°rio tentar usar janelas complexas, como Gauss ou Kaiser.  As janelas Nattal ou flat-top s√£o apenas um tipo de janela com pesos diferentes, mas os mesmos princ√≠pios b√°sicos que a Blackman-Harris.  Sabe-se que quanto mais membros da s√©rie, mais forte √© a supress√£o do n√≠vel dos lobos laterais (sujeita a uma escolha razo√°vel da profundidade de bits da fun√ß√£o da janela).  Com base na tarefa, o desenvolvedor apenas precisa escolher o tipo de janela usada. <br><br><h3>  Implementa√ß√£o de FPGA - abordagem tradicional </h3><br>  Todos os n√∫cleos de fun√ß√µes de janela s√£o projetados usando a abordagem cl√°ssica para descrever circuitos digitais em FPGAs e s√£o escritos na linguagem VHDL.  Abaixo est√° uma lista dos componentes feitos: <br><br><ul><li>  <i>bh_win_7term</i> - Blackman-Harris 7, uma janela com supress√£o m√°xima de andaimes laterais. </li><li>  <i>bh_win_5term</i> - <i>pedido da</i> Blackman-Harris 5, inclui uma janela com uma parte superior plana. </li><li>  <i>bh_win_4term</i> - Blackman-Harris 4 pedidos, inclui a janela Nattal e Blackman-Nattal. </li><li>  <i>bh_win_3term</i> - Blackman-Harris 3 pedidos, </li><li>  <i>hamming_win</i> - janelas de Hamming e Hann. </li></ul><br>  O c√≥digo fonte do componente de janela Blackman-Harris √© de 3 ordens de grandeza: <br><br><pre><code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">entity</span></span> bh_win_3term <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span> ( TD : <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>:=<span class="hljs-number"><span class="hljs-number">0.5</span></span>ns; <span class="hljs-comment"><span class="hljs-comment">--! Time delay PHI_WIDTH : integer:=10; --! Signal period = 2^PHI_WIDTH DAT_WIDTH : integer:=16; --! Output data width XSERIES : string:="ULTRA" --! for 6/7 series: "7SERIES"; for ULTRASCALE: "ULTRA"; ); port ( RESET : in std_logic; --! Global reset CLK : in std_logic; --! System clock AA0 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A0 AA1 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A1 AA2 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A2 ENABLE : in std_logic; --! Clock enable DT_WIN : out std_logic_vector(DAT_WIDTH-1 downto 0); --! Output DT_VLD : out std_logic --! Output data valid ); end bh_win_3term;</span></span></code> </pre> <br>  Em alguns casos, usei a biblioteca <i>UNISIM</i> para incorporar os <b>n√≥s DSP48E1 e DSP48E2</b> no projeto, o que finalmente <b>me</b> permite aumentar a velocidade dos c√°lculos devido √† tubula√ß√£o dentro desses blocos, mas, como a pr√°tica demonstrou, √© mais r√°pido e f√°cil dar r√©dea livre e escrever algo como <b>P = A * B + C</b> e especifique as seguintes diretivas no c√≥digo: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> USE_DSP <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> &lt;signal_name&gt;: <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">"YES"</span></span>;</code> </pre> <br>  Isso funciona bem e define rigidamente o tipo de elemento no qual a fun√ß√£o matem√°tica √© implementada para o sintetizador. <br><br><h3>  Vivado hls </h3><br>  Al√©m disso, implementei todos os n√∫cleos usando as ferramentas <b>Vivado HLS</b> .  Vou listar as principais <b>vantagens do</b> Vivado HLS: alta velocidade de design ( <i>time-to-market</i> ) em linguagens de alto n√≠vel C ou C ++, modelagem r√°pida de n√≥s desenvolvidos devido √† falta de um conceito de frequ√™ncia de rel√≥gio, configura√ß√£o flex√≠vel de solu√ß√µes (em termos de recursos e desempenho), introduzindo pragmas e diretrizes do projeto, bem como um baixo limite de entrada para desenvolvedores em idiomas de alto n√≠vel.  A principal desvantagem √© o custo sub√≥timo dos recursos FPGA em compara√ß√£o com a abordagem cl√°ssica.  Al√©m disso, n√£o √© poss√≠vel atingir as velocidades fornecidas pelos m√©todos antigos cl√°ssicos de RTL (VHDL, Verilog, SV).  Bem, a maior <b>desvantagem</b> √© dan√ßar com um pandeiro, mas isso √© caracter√≠stico de todo CAD da Xilinx.  (Nota: no depurador Vivado HLS e no modelo C ++ real, muitas vezes foram obtidos resultados diferentes, porque o Vivado HLS trabalha de maneira torta usando as vantagens da <i>precis√£o arbitr√°ria</i> ). <br><br>  A imagem a seguir mostra o log do kernel CORDIC sintetizado no Vivado HLS.  √â bastante informativo e exibe muitas informa√ß√µes √∫teis: a quantidade de recursos utilizados, a interface do usu√°rio do kernel, os loops e suas propriedades, o atraso na computa√ß√£o, o intervalo para o c√°lculo do valor de sa√≠da (importante ao projetar circuitos seriais e paralelos): <br><br><img src="https://habrastorage.org/webt/oe/e3/zh/oee3zhonsadxnqugfhd8geg7hca.png"><br><br>  Voc√™ tamb√©m pode ver a maneira de calcular dados em v√°rios componentes (fun√ß√µes).  Pode-se observar que na fase zero, os dados da fase s√£o lidos e nas etapas 7 e 8, o resultado do n√≥ CORDIC √© exibido. <br><img src="https://habrastorage.org/webt/kw/nf/j7/kwnfj7uftmtnnv6iaxoecjvji1g.png"><br><br>  O resultado do Vivado HLS: um kernel RTL sintetizado criado a partir do c√≥digo C.  O log mostra que na an√°lise de tempo, o kernel passa com √™xito todas as restri√ß√µes: <br><br><img src="https://habrastorage.org/webt/83/tb/hw/83tbhwy9j5jqkgn2tdz697dz-na.png"><br><br>  Outra grande vantagem do Vivado HLS √© que, para verificar o resultado, ela mesma faz um banco de testes do c√≥digo RTL sintetizado com base no modelo usado para verificar o c√≥digo C.  Este pode ser um teste primitivo, mas acredito que seja muito interessante e conveniente o suficiente para comparar a opera√ß√£o do algoritmo em C e em HDL.  Abaixo est√° uma captura de tela do Vivado mostrando uma simula√ß√£o do modelo de fun√ß√£o do kernel de uma fun√ß√£o de janela obtida pelo Vivado HLS: <br><br><img src="https://habrastorage.org/webt/6q/zw/3m/6qzw3mcmm6xixm-wh9kpumqpzx8.png"><br><br>  Assim, para todas as fun√ß√µes da janela, resultados semelhantes foram obtidos, independentemente do m√©todo de design - em VHDL ou em C ++.  No entanto, no primeiro caso, √© obtida uma maior frequ√™ncia de opera√ß√£o e um n√∫mero menor de recursos, e no segundo caso, a velocidade m√°xima do projeto √© alcan√ßada.  Ambas as abordagens t√™m direito √† vida. <br><br>  Calculei especificamente quanto tempo gastaria no desenvolvimento usando m√©todos diferentes.  Eu implementei um projeto C ++ no Vivado HLS ~ 12 vezes mais r√°pido que no VHDL. <br><br><h3>  Compara√ß√£o de abordagens </h3><br>  Compare o c√≥digo-fonte para HDL e C ++ para o n√∫cleo CORDIC.  O algoritmo, como foi dito anteriormente, √© baseado nas opera√ß√µes de adi√ß√£o, subtra√ß√£o e deslocamento.  No VHDL, fica assim: existem tr√™s vetores de dados - um √© respons√°vel pela rota√ß√£o do √¢ngulo e os outros dois determinam o comprimento do vetor ao longo dos eixos X e Y, o que √© equivalente a sin e cos (veja a figura no wiki): <br><br><img src="https://habrastorage.org/webt/ab/3w/hv/ab3whvtkvcgl-ycqnkz3mjzr0lk.png"><br><br>  Ao calcular iterativamente o valor Z, os valores X e Y s√£o calculados em paralelo. O processo de pesquisa c√≠clica dos valores de sa√≠da no HDL: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> ROM_LUT : rom_array := ( x<span class="hljs-string"><span class="hljs-string">"400000000000"</span></span>, x<span class="hljs-string"><span class="hljs-string">"25C80A3B3BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"13F670B6BDC7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0A2223A83BBB"</span></span>, x<span class="hljs-string"><span class="hljs-string">"05161A861CB1"</span></span>, x<span class="hljs-string"><span class="hljs-string">"028BAFC2B209"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0145EC3CB850"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00A2F8AA23A9"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00517CA68DA2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0028BE5D7661"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00145F300123"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000A2F982950"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000517CC19C0"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00028BE60D83"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000145F306D6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000A2F9836D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000517CC1B7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000028BE60DC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000145F306E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000A2F9837"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000517CC1B"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000028BE60E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000145F307"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000A2F983"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000517CC2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000028BE61"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000145F30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000A2F98"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000517CC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000028BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000145F3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000A2FA"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000517D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000028BE"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000145F"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000A30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000518"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000028C"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000146"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000000A3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000051"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000029"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000014"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000000A"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000005"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000003"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000001"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000000"</span></span> ); pr_crd: <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(clk, reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reset = <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">---- Reset sine / cosine / angle vector ---- sigX &lt;= (others =&gt; (others =&gt; '0')); sigY &lt;= (others =&gt; (others =&gt; '0')); sigZ &lt;= (others =&gt; (others =&gt; '0')); elsif rising_edge(clk) then sigX(0) &lt;= init_x; sigY(0) &lt;= init_y; sigZ(0) &lt;= init_z; ---- calculate sine &amp; cosine ---- lpXY: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigX(ii+1) &lt;= sigX(ii) + sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) - sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); else sigX(ii+1) &lt;= sigX(ii) - sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) + sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); end if; end loop; ---- calculate phase ---- lpZ: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigZ(ii+1) &lt;= sigZ(ii) + ROM_TABLE(ii); else sigZ(ii+1) &lt;= sigZ(ii) - ROM_TABLE(ii); end if; end loop; end if; end process;</span></span></code> </pre><br>  No C ++, no Vivado HLS, o c√≥digo parece quase o mesmo, mas o registro √© v√°rias vezes menor: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Unrolled loop // int k; stg: for (k = 0; k &lt; NWIDTH; k++) { #pragma HLS UNROLL if (z[k] &lt; 0) { x[k+1] = x[k] + (y[k] &gt;&gt; k); y[k+1] = y[k] - (x[k] &gt;&gt; k); z[k+1] = z[k] + lut_angle[k]; } else { x[k+1] = x[k] - (y[k] &gt;&gt; k); y[k+1] = y[k] + (x[k] &gt;&gt; k); z[k+1] = z[k] - lut_angle[k]; } }</span></span></code> </pre><br><br>  Aparentemente, o mesmo ciclo com turnos e acr√©scimos √© usado.  No entanto, por padr√£o, todos os loops no Vivado HLS s√£o "recolhidos" e executados sequencialmente, conforme planejado para a linguagem C ++.  A introdu√ß√£o do <b>pragma HLS UNROLL</b> ou <b>HLS PIPELINE</b> converte serial em c√°lculos paralelos.  Isso leva a um aumento nos recursos do FPGA, no entanto, permite calcular e enviar novos valores ao n√∫cleo a cada ciclo do rel√≥gio. <br><br>  Os resultados da s√≠ntese do projeto em VHDL e C ++ s√£o apresentados na figura abaixo.  Como voc√™ pode ver, logicamente, a diferen√ßa √© duas vezes a favor da abordagem tradicional.  Para outros recursos do FPGA, a discrep√¢ncia √© insignificante.  N√£o me aprofundou na otimiza√ß√£o do projeto em C ++, mas, sem ambiguidade, ao definir v√°rias diretivas ou alterar parcialmente o c√≥digo, o n√∫mero de recursos utilizados pode ser reduzido.  Em ambos os casos, os tempos convergiram para uma dada frequ√™ncia principal de ~ 350 MHz. <br><img src="https://habrastorage.org/webt/lp/id/ic/lpidicvwz-edguptklqfahlo0ya.png"><br><br><h3>  Recursos de implementa√ß√£o </h3><br>  Como os c√°lculos s√£o realizados em um formato de ponto fixo, as fun√ß√µes da janela possuem v√°rios recursos que devem ser levados em considera√ß√£o ao projetar sistemas DSP em FPGAs.  Por exemplo, quanto maior a profundidade de bits dos dados da fun√ß√£o da janela, melhor a precis√£o da sobreposi√ß√£o da janela.  Por outro lado, com profundidade de bits insuficiente da fun√ß√£o da janela, distor√ß√µes ser√£o introduzidas na forma de onda resultante, o que afetar√° a qualidade das caracter√≠sticas espectrais.  Por exemplo, uma fun√ß√£o de janela deve ter pelo menos 20 bits quando multiplicada por um sinal com dura√ß√£o de 2 ^ 20 = 1M de amostras. <br><br><h3>  Conclus√£o </h3><br>  Este artigo mostra uma maneira de criar fun√ß√µes de janela sem usar mem√≥ria externa ou mem√≥ria de bloco FPGA.  O m√©todo de usar recursos exclusivamente l√≥gicos de FPGAs (e em alguns casos blocos DSP) √© fornecido.  Utilizando o algoritmo CORDIC, √© poss√≠vel obter fun√ß√µes de janela com qualquer profundidade de bits (dentro da raz√£o), de qualquer comprimento e ordem, e, portanto, ter um conjunto de praticamente todas as caracter√≠sticas espectrais da janela. <br><br>  Como parte de um dos estudos, consegui obter um n√∫cleo est√°vel da fun√ß√£o de janela Blackman-Harris de 5 e 7 ordens de magnitude em amostras de 1M a uma frequ√™ncia de ~ 375 MHz e tamb√©m para criar um gerador de coeficientes rotativos para uma FFT baseada em CORDIC a uma frequ√™ncia de ~ 400 MHz.  Cristal FPGA usado: Kintex Ultrascale + (xcku11p-ffva1156-2-e). <br><br>  Link para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o projeto <b>github</b> aqui</a> .  O projeto cont√©m um modelo matem√°tico no Matlab, c√≥digos-fonte para fun√ß√µes de janela e CORDIC em VHDL, bem como modelos das fun√ß√µes de janela listadas em C ++ para Vivado HLS. <br><br><h3>  Artigos √∫teis </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fun√ß√µes da janela DSPLib</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Algumas fun√ß√µes da janela DSPlib</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wiki de filtragem de janelas expandida</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo do Wiki sobre CORDIC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia do usu√°rio do Vivado HLS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O artigo sobre an√°lise espectral no Habr</a> </li></ul><br>  Tamb√©m aconselho um livro muito popular sobre DSP - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ayficher E., Jervis B. Processamento de sinais digitais.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Abordagem pr√°tica</a> <br><br>  Obrigado pela aten√ß√£o! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427361/">https://habr.com/ru/post/pt427361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427351/index.html">Semana 40 de seguran√ßa: Vulnerabilidades no CMS Drupal e mais</a></li>
<li><a href="../pt427353/index.html">Drones mostram: como coordenamos um enxame de helic√≥pteros dan√ßantes</a></li>
<li><a href="../pt427355/index.html">Compila√ß√£o CJM, principais habilidades do diretor de arte e compreens√£o do usu√°rio</a></li>
<li><a href="../pt427357/index.html">Escrevendo shaders no Unity. GrabPass, PerRendererData</a></li>
<li><a href="../pt427359/index.html">Como ECS, C # Job System e SRP alteram a arquitetura</a></li>
<li><a href="../pt427363/index.html">Implementa√ß√£o do LoRaWAN em uma empresa agr√≠cola. Tudo sobre constru√ß√£o, lan√ßamento e solu√ß√µes</a></li>
<li><a href="../pt427365/index.html">Relat√≥rio do RedSlerm sobre monitoramento (Monit, Zabbix)</a></li>
<li><a href="../pt427367/index.html">Confer√™ncia BLACK HAT USA. Como um hacker de Hollywood usa c√¢meras de vigil√¢ncia. Parte 1</a></li>
<li><a href="../pt427369/index.html">Confer√™ncia BLACK HAT USA. Como um hacker de Hollywood usa c√¢meras de vigil√¢ncia. Parte 2</a></li>
<li><a href="../pt427371/index.html">Curso em v√≠deo "Fundamentos do trabalho com nota√ß√µes BPMN". Gr√°tis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>