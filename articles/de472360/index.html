<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéå üöµüèø üôã Scannen des Codes von Orchard CMS auf Fehler ‚ò¶Ô∏è üë®‚Äç‚ù§Ô∏è‚Äçüë® üëæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden die Ergebnisse einer zweiten √úberpr√ºfung des Orchard-Projekts mit dem statischen Analyseger√§t PVS-Studio √ºberpr√ºft. Orchard i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Scannen des Codes von Orchard CMS auf Fehler</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/472360/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/c02/394/ef5c023947badf157fb4c97b6562ab91.png" alt="Bild 6"></div><br>  In diesem Artikel werden die Ergebnisse einer zweiten √úberpr√ºfung des Orchard-Projekts mit dem statischen Analyseger√§t PVS-Studio √ºberpr√ºft.  Orchard ist ein Open-Source-Content-Manager-System, das als Teil der ASP.NET Open Source-Galerie unter der gemeinn√ºtzigen Outercurve Foundation bereitgestellt wird.  Die heutige √úberpr√ºfung ist besonders interessant, da sowohl das Projekt als auch der Analysator seit der ersten √úberpr√ºfung einen langen Weg zur√ºckgelegt haben. Dieses Mal werden wir uns neue Diagnosemeldungen und einige nette Fehler ansehen. <br><a name="habracut"></a><br>  <b>√úber Orchard CMS</b> <br><br>  Wir haben Orchard vor drei Jahren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºberpr√ºft</a> .  Der C # -Analysator von PVS-Studio hat sich seitdem stark weiterentwickelt: Wir haben die Datenflussanalyse verbessert, eine interprozedurale Analyse und neue Diagnosen hinzugef√ºgt und eine Reihe von Fehlalarmen behoben.  Dar√ºber hinaus ergab die zweite √úberpr√ºfung, dass die Entwickler von Orchard alle im ersten Artikel gemeldeten Fehler behoben hatten, was bedeutet, dass wir unser Ziel erreicht hatten, d. H., Dass sie ihren Code verbessert hatten. <br><br>  Ich hoffe, dass sie auch auf diesen Artikel achten und die notwendigen Korrekturen vornehmen oder, noch besser, PVS-Studio f√ºr die regelm√§√üige Verwendung √ºbernehmen.  Zur Erinnerung, wir stellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open-Source-</a> Entwicklern eine kostenlose Lizenz zur Verf√ºgung.  √úbrigens gibt es auch andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optionen</a> , die propriet√§re Projekte genie√üen k√∂nnen. <br><br>  Der Quellcode von Orchard steht hier zum Download zur Verf√ºgung.  Die vollst√§ndige Projektbeschreibung finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Wenn Sie noch keine PVS-Studio-Kopie haben, k√∂nnen Sie die Testversion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterladen</a> .  Ich habe PVS-Studio 7.05 Beta verwendet und werde einige seiner Warnungen in diesen Artikel aufnehmen.  Ich hoffe, diese Bewertung wird Sie davon √ºberzeugen, dass PVS-Studio ein n√ºtzliches Werkzeug ist.  Denken Sie daran, dass es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">regelm√§√üig</a> verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden soll</a> . <br><br>  <b>Analyseergebnisse</b> <br><br>  Hier sind einige der Zahlen aus der ersten √úberpr√ºfung von Orchard, damit Sie nicht zum Vergleich zwischen den beiden Artikeln wechseln m√ºssen. <br><br>  Bei der vorherigen √úberpr√ºfung "haben wir alle Quellcodedateien (3739 Elemente) mit der Erweiterung .cs analysiert.  Insgesamt gab es 214.564 Codezeilen.  Das Ergebnis der √úberpr√ºfung waren 137 Warnungen.  Genauer gesagt gab es 39 erste (hohe) Warnungen.  Es gab auch 60 Sekunden (mittlere) Warnungen. ‚Äú <br><br>  Die aktuelle Version von Orchard besteht aus 2.767 CS-Dateien, d. H. Es sind ungef√§hr tausend Dateien kleiner.  Die Verkleinerung und Umbenennung des Repositorys l√§sst darauf schlie√üen, dass die Entwickler den Kern des Projekts ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit 966</a> ) isoliert haben, der 108.287 LOC lang ist.  Der Analysator gab 153 Warnungen aus: 33 Warnungen der ersten und 70 Warnungen der zweiten Ebene.  Wir enthalten normalerweise keine Warnungen der dritten Ebene, und ich werde mich an die Tradition halten. <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3110</a> M√∂gliche unendliche Rekursion innerhalb der Methode 'TryValidateModel'.  PrefixedModuleUpdater.cs 48 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryValidateModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> model, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prefix</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TryValidateModel(model, Prefix(prefix)); }</code> </pre> <br>  Beginnen wir mit einem unendlichen Rekursionsfehler, wie wir es im ersten Artikel getan haben.  Diesmal sind die genauen Absichten des Entwicklers nicht klar, aber ich habe festgestellt, dass die <i>TryValidateModel-</i> Methode eine √ºberladene Version mit einem Parameter hatte: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryValidateModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> model</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _updateModel.TryValidateModel(model); }</code> </pre> <br>  Ich denke, dass der Entwickler genau wie bei der √ºberladenen Version beabsichtigte, die Methode √ºber <i>_updateModel aufzurufen.</i>  Der Compiler hat den Fehler nicht bemerkt.  <i>_updateModel</i> ist vom Typ <i>IUpdateModel</i> , und die aktuelle Klasse implementiert auch diese Schnittstelle.  Da die Methode keine Pr√ºfung gegen <i>StackOverflowException enth√§lt</i> , wurde sie wahrscheinlich nie aufgerufen, obwohl ich nicht damit rechnen w√ºrde.  Wenn meine Annahme richtig ist, sollte die feste Version folgenderma√üen aussehen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryValidateModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> model, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prefix</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _updateModel.TryValidateModel(model, Prefix(prefix)); }</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3008</a> Der Variablen 'content' werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 197, 190. DynamicCacheTagHelper.cs 197 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... IHtmlContent content; .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> output.GetChildContentAsync(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _cacheScopeManager.ExitScope(); } content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ProcessContentAsync(output, cacheContext); .... }</code> </pre> <br>  Der Analysator hat zwei Zuordnungen zum <i>Inhalt</i> der lokalen Variablen festgestellt <i>.</i>  <i>GetChildContentAsync</i> ist eine Bibliotheksmethode, die zu selten verwendet wird, als dass wir uns die M√ºhe machen <i>k√∂nnten</i> , sie zu untersuchen und mit Anmerkungen zu versehen.  Ich f√ºrchte, weder wir noch der Analysator wissen etwas √ºber das R√ºckgabeobjekt und die Nebenwirkungen der Methode.  Wir wissen jedoch mit Sicherheit, dass die Zuweisung des R√ºckgabewerts zum <i>Inhalt</i> keinen Sinn ergibt, wenn er nicht weiter im Code verwendet wird.  Vielleicht ist es eher eine redundante Operation als ein Fehler.  Ich kann nicht sagen, wie genau dies behoben werden soll, also √ºberlasse ich es den Entwicklern. <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie 'itemTag'.  CoreShapes.cs 92 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IHtmlContent&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">List</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ItemTag....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> itemTagName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ItemTag != <span class="hljs-string"><span class="hljs-string">"-"</span></span>) { itemTagName = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(ItemTag) ? <span class="hljs-string"><span class="hljs-string">"li"</span></span> : ItemTag; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemTag = String.IsNullOrEmpty(itemTagName) ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : ....; .... itemTag.InnerHtml.AppendHtml(itemContent); listTag.InnerHtml.AppendHtml(itemTag); ++index; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listTag; }</code> </pre> <br>  Der Analysator hat eine unsichere Dereferenzierung von <i>itemTag festgestellt</i> .  Dieses Snippet ist ein gutes Beispiel daf√ºr, wie sich ein statisches Analysetool von einem menschlichen Entwickler unterscheidet, der Code√ºberpr√ºfungen durchf√ºhrt.  Die Methode hat einen Parameter namens <i>ItemTag</i> und eine lokale Variable namens <i>itemTag</i> .  Sie m√ºssen Ihnen nicht sagen, dass dies einen gro√üen Unterschied f√ºr den Compiler darstellt!  Dies sind zwei verschiedene, obwohl verwandte Variablen.  Die Art und Weise, wie sie zusammenh√§ngen, erfolgt √ºber eine dritte Variable, <i>itemTagName.</i>  Hier ist die Reihenfolge der Schritte, die zur m√∂glichen Ausnahme f√ºhren: Wenn das <i>ItemTag-</i> Argument gleich "-" ist, wird <i>itemTagName</i> kein Wert zugewiesen, sodass es eine <i>Nullreferenz</i> bleibt. Wenn es sich um eine <i>Nullreferenz handelt</i> , wird die lokale Variable <i>itemTag verwendet</i> wird auch zu einer Nullreferenz.  Meiner Meinung nach ist es besser, nach der Zeichenfolgenpr√ºfung eine Ausnahme auszul√∂sen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IHtmlContent&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">List</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ItemTag....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> itemTagName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ItemTag != <span class="hljs-string"><span class="hljs-string">"-"</span></span>) { itemTagName = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(ItemTag) ? <span class="hljs-string"><span class="hljs-string">"li"</span></span> : ItemTag; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemTag = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(String.IsNullOrEmpty(itemTag)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> .... .... itemTag.InnerHtml.AppendHtml(itemContent); listTag.InnerHtml.AppendHtml(itemTag); ++index; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listTag; }</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095</a> Das Objekt 'remoteClient' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 49, 51. ImportRemoteInstanceController.cs 49 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Import</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImportViewModel model</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> remoteClient = remoteClientList.RemoteClients.FirstOrDefault(....); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> apiKey = Encoding.UTF8.GetString(....(remoteClient.ProtectedApiKey)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remoteClient == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || ....) { .... } .... }</code> </pre> <br>  Der Analysator hat eine Dereferenzierung von <i>remoteClient festgestellt,</i> gefolgt von einer <i>Nullpr√ºfung</i> einige Zeilen sp√§ter.  Dies ist in der Tat eine potenzielle <i>NullReferenceException,</i> da die <i>FirstOrDefault-</i> Methode m√∂glicherweise einen Standardwert <i>zur√ºckgibt</i> (der f√ºr Referenztypen <i>null</i> ist).  Ich denke, dieses Snippet kann repariert werden, indem einfach die √úberpr√ºfung so verschoben wird, dass sie der Dereferenzierungsoperation vorausgeht: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Import</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImportViewModel model</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> remoteClient = remoteClientList.RemoteClients.FirstOrDefault(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remoteClient != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> apiKey = UTF8.GetString(....remoteClient.ProtectedApiKey); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... } .... }</code> </pre> <br>  Oder vielleicht sollte es behoben werden, indem <i>FirstOrDefault</i> durch <i>First ersetzt</i> und die Pr√ºfung insgesamt entfernt wird. <br><br>  <b>Warnungen von PVS-Studio 7.05 Beta:</b> <br><br>  Inzwischen haben wir alle <i>orDefault-</i> Methoden von <i>LINQ</i> mit Anmerkungen versehen.  Diese Informationen werden von der neuen Diagnose verwendet, an der wir arbeiten: Sie erkennt F√§lle, in denen die von diesen Methoden zur√ºckgegebenen Werte ohne vorherige √úberpr√ºfung dereferenziert werden.  Jede <i>orDefault-</i> Methode verf√ºgt √ºber ein Gegenst√ºck, das eine Ausnahme <i>ausl√∂st</i> , wenn kein √ºbereinstimmendes Element gefunden wurde.  Diese Ausnahme ist beim Aufsp√ºren des Problems hilfreicher als die abstrakte <i>NullReferenceException</i> . <br><br>  Ich kann nur die Ergebnisse teilen, die ich aus dieser Diagnose f√ºr das Orchard-Projekt erhalten habe.  Es gibt 27 potenziell gef√§hrliche Stellen.  Hier sind einige davon: <br><br>  ContentTypesAdminNodeNavigationBuilder.cs 71: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> treeBuilder = treeNodeBuilders.Where(....).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> treeBuilder.BuildNavigationAsync(childNode, builder, treeNodeBuilders);</code> </pre> <br>  ListPartDisplayDriver.cs 217: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentTypePartDefinition = ....Parts.FirstOrDefault(....); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentTypePartDefinition.Settings....;</code> </pre> <br>  ContentTypesAdminNodeNavigationBuilder.cs 113: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeEntry = node.ContentTypes.Where(....).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AddPrefixToClasses(typeEntry.IconClass);</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung des Methodenr√ºckgabewerts.  Betrachten Sie Folgendes: CreateScope ().  SetupService.cs 136 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupInternalAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SetupContext context</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shellContext = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ....) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> shellContext.CreateScope().UsingAsync(....); } .... }</code> </pre> <br>  Der Analysator erw√§hnte eine Dereferenzierung des von der <i>CreateScope-</i> Methode zur√ºckgegebenen <i>Werts</i> .  <i>CreateScope</i> ist eine winzige Methode. Hier ist die vollst√§ndige Implementierung: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ShellScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_placeHolder) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ShellScope(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A new scope can be only used on a non released shell. if (!released) { return scope; } scope.Dispose(); return null; }</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, gibt es zwei F√§lle, in denen <i>null zur√ºckgegeben werden kann</i> .  Der Analysator wei√ü nicht, welchem ‚Äã‚ÄãZweig der Ausf√ºhrungsfluss folgen wird, geht also auf Nummer sicher und meldet den Code als verd√§chtig.  Wenn ich so einen Code schreiben w√ºrde, w√ºrde ich sofort einen Null-Check schreiben. <br><br>  Vielleicht ist meine Meinung voreingenommen, aber ich glaube, dass jede asynchrone Methode so weit wie m√∂glich vor <i>NullReferenceException</i> gesch√ºtzt werden sollte, da das Debuggen <i>solcher Dinge alles andere</i> als unterhaltsam ist. <br><br>  In diesem speziellen Fall wird die <i>CreateScope-</i> Methode viermal aufgerufen: Zwei dieser Aufrufe werden von √úberpr√ºfungen begleitet, die anderen beiden nicht.  Die beiden letztgenannten Aufrufe (ohne Pr√ºfung) scheinen Copy-Paste-Klone zu sein (dieselbe Klasse, dieselbe Methode, dieselbe Methode zum Dereferenzieren des Ergebnisses f√ºr den Aufruf von UsingAsync).  Der erste dieser beiden Anrufe wurde oben angezeigt, und Sie k√∂nnen sicher sein, dass der zweite dieselbe Warnung ausgel√∂st hat: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung des Methodenr√ºckgabewerts.  Betrachten Sie Folgendes: CreateScope ().  SetupService.cs 192 <br><br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3127</a> Es wurden zwei √§hnliche Codefragmente gefunden.  M√∂glicherweise ist dies ein Tippfehler, und die Variable 'AccessTokenSecret' sollte anstelle von 'ConsumerSecret' TwitterClientMessageHandler.cs 52 verwendet werden <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureOAuthAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequestMessage request</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.ConsumerSecret)) settings.ConsumerSecret = protrector.Unprotect(settings.ConsumerSecret); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.ConsumerSecret)) settings.AccessTokenSecret = protrector.Unprotect(settings.AccessTokenSecret); .... }</code> </pre> <br>  Das ist ein klassischer Fehler beim Kopieren und Einf√ºgen.  <i>ConsumerSecret</i> wurde zweimal √ºberpr√ºft, w√§hrend <i>AccessTokenSecret √ºberhaupt</i> nicht √ºberpr√ºft wurde.  Offensichtlich ist dies wie folgt behoben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureOAuthAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequestMessage request</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.ConsumerSecret)) settings.ConsumerSecret = protrector.Unprotect(settings.ConsumerSecret); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.AccessTokenSecret)) settings.AccessTokenSecret = protrector.Unprotect(settings.AccessTokenSecret); .... }</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3139</a> Zwei oder mehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fallzweige</a> f√ºhren dieselben Aktionen aus.  SerialDocumentExecuter.cs 23 <br><br>  Ein weiterer Fehler beim Kopieren und Einf√ºgen.  Zur Verdeutlichung finden Sie hier die vollst√§ndige Klassenimplementierung (klein). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerialDocumentExecuter</span></span> : <span class="hljs-title"><span class="hljs-title">DocumentExecuter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IExecutionStrategy ParallelExecutionStrategy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParallelExecutionStrategy(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IExecutionStrategy SerialExecutionStrategy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerialExecutionStrategy(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IExecutionStrategy SubscriptionExecutionStrategy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SubscriptionExecutionStrategy(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IExecutionStrategy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectExecutionStrategy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; } } }</code> </pre> <br>  Dem Analysator gefielen die beiden identischen Fallzweige nicht.  In der Tat hat die Klasse drei Entit√§ten, w√§hrend die switch-Anweisung nur zwei davon zur√ºckgibt.  Wenn dieses Verhalten beabsichtigt ist und die dritte Entit√§t eigentlich nicht verwendet werden soll, kann der Code verbessert werden, indem der dritte Zweig entfernt wird, der die beiden wie folgt zusammengef√ºhrt hat: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  Wenn dies ein Fehler beim Kopieren und Einf√ºgen ist, sollte das erste der doppelten R√ºckgabefelder wie folgt behoben werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParallelExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  Oder es sollte der zweite Fallzweig sein.  Ich kenne die Projektdetails nicht und kann daher die Korrelation zwischen den Namen der Operationstypen und Strategien nicht bestimmen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParallelExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die √úberpr√ºfung "Anfrage".  GraphQLMiddleware.cs 148 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context....</span></span></span><span class="hljs-function">)</span></span> { .... GraphQLRequest request = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HttpMethods.IsPost(context.Request.Method)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HttpMethods.IsGet(context.Request.Method)) { .... request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLRequest(); .... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queryToExecute = request.Query; .... }</code> </pre> <br>  Der <i>Anforderungsvariablen</i> wird im ersten <i>if-</i> Block mehrmals ein anderer Wert als <i>null</i> zugewiesen, jedoch jedes Mal mit verschachtelten Bedingungen.  Das Einbeziehen all dieser Bedingungen w√ºrde das Beispiel zu lang machen, daher werden wir nur mit den ersten <i>fortfahren</i> , die den Typ der http-Methode <i>IsGet</i> oder <i>IsPost √ºberpr√ºfen</i> .  Die <i>Microsoft.AspNetCore.Http.HttpMethods-</i> Klasse verf√ºgt √ºber neun statische Methoden zum √úberpr√ºfen des Abfragetyps.  Wenn Sie beispielsweise eine <i>Delete-</i> oder <i>Set-</i> Abfrage an die <i>ExecuteAsync-</i> Methode √ºbergeben, wird eine <i>NullReferenceException ausgel√∂st</i> .  Selbst wenn solche Methoden derzeit √ºberhaupt nicht unterst√ºtzt werden, ist es dennoch ratsam, eine Ausnahmepr√ºfung hinzuzuf√ºgen.  Schlie√ülich k√∂nnen sich die Systemanforderungen √§ndern.  Hier ist ein Beispiel f√ºr eine solche Pr√ºfung: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queryToExecute = request.Query; .... }</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung des Methodenr√ºckgabewerts.  Betrachten Sie Folgendes: Holen Sie sich &lt;ContentPart&gt; (...).  ContentPartHandlerCoordinator.cs 190 <br><br>  Die meisten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080-</a> Warnungen lassen sich bequemer in der Entwicklungsumgebung anzeigen, da Sie die Methodennavigation, die Hervorhebung von Typen und die freundliche Atmosph√§re der IDE ben√∂tigen.  Ich versuche, den Text von Beispielen so weit wie m√∂glich zu reduzieren, um sie lesbar zu halten.  Aber wenn ich es nicht richtig mache oder wenn Sie Ihre Programmierkenntnisse testen und alles selbst herausfinden m√∂chten, empfehle ich, das Ergebnis dieser Diagnose in einem Open-Source-Projekt oder nur in Ihrem eigenen Code zu √ºberpr√ºfen. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LoadContentContext context</span></span></span><span class="hljs-function">)</span></span> { .... context.ContentItem.Get&lt;ContentPart&gt;(typePartDefinition.Name) .Weld(fieldName, fieldActivator.CreateInstance()); .... }</code> </pre> <br>  Der Analysator meldet diese Zeile.  Werfen wir einen Blick auf die <i>Get-</i> Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TElement Get&lt;TElement&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ContentElement contentElement....) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TElement : ContentElement { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TElement)contentElement.Get(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TElement), name); }</code> </pre> <br>  Es ruft seine √ºberladene Version auf.  Lassen Sie es uns auch √ºberpr√ºfen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ContentElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ContentElement contentElement....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementData = contentElement.Data[name] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> JObject; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elementData == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } .... }</code> </pre> <br>  Es stellt sich heraus, dass die <i>Get-</i> Methode <i>null</i> <i>zur√ºckgibt</i> , wenn wir mit dem <i>Namensindexer</i> eine Entit√§t eines mit <i>JObject nicht</i> kompatiblen <i>Typs</i> von <i>Data erhalten</i> .  Ich wei√ü nicht genau, wie wahrscheinlich das ist, da diese Typen aus der <i>Newtonsoft.Json-</i> Bibliothek stammen, mit der ich nicht viel gearbeitet habe.  Der Autor des Codes vermutete jedoch, dass das gesuchte Element m√∂glicherweise nicht vorhanden ist. Daher sollten wir dies ber√ºcksichtigen, wenn wir auch auf das Ergebnis der Leseoperation zugreifen.  Pers√∂nlich w√ºrde ich beim allerersten <i>Get</i> eine Ausnahme <i>ausl√∂sen,</i> wenn wir glauben, dass der Knoten vorhanden sein muss, oder vor der Dereferenzierung eine Pr√ºfung hinzuf√ºgen, wenn die Nichtexistenz des Knotens die Gesamtlogik nicht √§ndert (zum Beispiel erhalten wir eine Standardwert). <br><br>  L√∂sung 1: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ContentElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ContentElement contentElement....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementData = contentElement.Data[name] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> JObject; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elementData == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>.... } .... }</code> </pre> <br>  L√∂sung 2: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LoadContentContext context</span></span></span><span class="hljs-function">)</span></span> { .... context.ContentItem.Get&lt;ContentPart&gt;(typePartDefinition.Name) ?.Weld(fieldName, fieldActivator.CreateInstance()); .... }</code> </pre> <br>  <b>PVS-Studio-Diagnosemeldung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die √úberpr√ºfung der "Ergebnisse".  ContentQueryOrchardRazorHelperExtensions.cs 19 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;IEnumerable&lt;ContentItem&gt;&gt; ContentQueryAsync(....) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> orchardHelper.QueryAsync(queryName, parameters); .... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results) { .... } .... }</code> </pre> <br>  Dies ist ein recht einfaches Beispiel im Vergleich zum vorherigen.  Der Analysator vermutet, dass die <i>QueryAsync-</i> Methode m√∂glicherweise eine <i>Nullreferenz zur√ºckgibt</i> .  Hier ist die Implementierung der Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IEnumerable&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueryAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> queryManager.GetQueryAsync(queryName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } .... }</code> </pre> <br>  Da <i>GetQueryAsync</i> eine Schnittstellenmethode ist, k√∂nnen Sie sich bei jeder Implementierung nicht sicher sein, insbesondere wenn wir bedenken, dass das Projekt auch die folgende Version enth√§lt: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Query&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> document = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetDocumentAsync(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(document.Queries.TryGetValue(name, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> query; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Die mehrfachen Aufrufe externer Funktionen und Cache-Zugriffe erschweren die Analyse von <i>GetDocumentAsync. Nehmen</i> wir also an, dass die Pr√ºfung erforderlich ist - umso mehr, als die Methode asynchron ist. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;IEnumerable&lt;ContentItem&gt;&gt; ContentQueryAsync(....) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> orchardHelper.QueryAsync(queryName, parameters); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(results == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; .... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results) { .... } .... }</code> </pre> <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41f/fb1/e08/41ffb1e086795cd7ba94b22ed53ce33c.png" alt="Bild 14"></div><br><br>  <b>Fazit</b> <br><br>  Ich kann nur die hohe Qualit√§t des Orchard-Codes erw√§hnen!  Es gab zwar einige andere M√§ngel, die ich hier nicht besprochen habe, aber ich habe Ihnen die schwerwiegendsten Fehler gezeigt.  Dies bedeutet nat√ºrlich nicht, dass es ausreicht, Ihren Quellcode alle drei Jahre einmal zu √ºberpr√ºfen.  Wenn Sie sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">regelm√§√üig</a> verwenden, k√∂nnen Sie die statische Analyse optimal nutzen, da Sie auf diese Weise garantiert Fehler in den fr√ºhesten Entwicklungsphasen erkennen und beheben k√∂nnen, in denen die Fehlerbehebung am billigsten und einfachsten ist. <br><br>  Auch wenn einmalige √úberpr√ºfungen nicht viel helfen, empfehle ich Ihnen dennoch, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> herunterzuladen und es in Ihrem Projekt auszuprobieren: Wer wei√ü, vielleicht finden Sie auch einige interessante Fehler. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472360/">https://habr.com/ru/post/de472360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472350/index.html">Wie Methodius zu Anna wurde: die Erfahrung, Sprachnachrichten-Klassifikatoren zu entwickeln und zu starten. Teil 1</a></li>
<li><a href="../de472352/index.html">TechnoText, Folge II. Wir erz√§hlen, wie die Autoren von Habr an Artikeln leben und arbeiten</a></li>
<li><a href="../de472354/index.html">Zwischen dem Stuhl und dem Monitor befindet sich die Hauptschwachstelle im System: VAP-Person</a></li>
<li><a href="../de472356/index.html">Microsoft vs IBM: Wichtige √Ñnderungen in der Java-Unterst√ºtzung</a></li>
<li><a href="../de472358/index.html">30. Oktober um 17:00 Uhr Webinar ‚ÄûBereitstellen des Kubernetes-Clusters in einer Stunde in der CROC-Cloud‚Äú</a></li>
<li><a href="../de472362/index.html">Wir suchen und analysieren Fehler im Orchard CMS-Code</a></li>
<li><a href="../de472364/index.html">PostgreSQL- und Datensatzkonsistenzeinstellungen f√ºr jede bestimmte Verbindung</a></li>
<li><a href="../de472366/index.html">Neuer Pfadfinder-Algorithmus in Factorio</a></li>
<li><a href="../de472368/index.html">Sprachfischen: Wir analysieren Angriffsmethoden und Schutzmethoden gegen sie</a></li>
<li><a href="../de472372/index.html">Android-Automatisierung Super einfache Anleitung zum Erstellen Ihres ersten Espresso-Tests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>