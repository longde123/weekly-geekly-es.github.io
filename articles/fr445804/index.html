<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏻 🧑 🖋️ Encapsulation pour de vrais samouraïs ou les nuances associées au mot-clé interne en C # 🌉 🍹 🎖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue: interne est un nouveau public 


 Chacun de nous rêvait d'un projet où tout serait bien fait. Cela semble assez naturel. Dès que vous appren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Encapsulation pour de vrais samouraïs ou les nuances associées au mot-clé interne en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445804/"><h2>  Prologue: interne est un nouveau public </h2><br><p>  Chacun de nous rêvait d'un projet où tout serait bien fait.  Cela semble assez naturel.  Dès que vous apprenez la possibilité même d'écrire du bon code, dès que vous entendez des légendes sur le même code qui peuvent être facilement lues et modifiées, vous vous allumez immédiatement "bien, maintenant je vais le faire correctement, je suis intelligent et je lis McConnell." </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/34f/ba6/d7e34fba6115e561d2016fa85f7a846a.jpg" alt="image"><br><br><p>  Un tel projet s'est produit dans ma vie.  Un autre.  Et je le fais sous supervision volontaire, où chaque ligne que je suis.  En conséquence, non seulement je le voulais, mais je devais tout faire correctement.  L'un des «corrects» était «respectez l'encapsulation et proche du maximum, car vous avez toujours le temps d'ouvrir, puis il sera trop tard pour refermer».  Et donc, partout où j'ai pu, j'ai commencé à utiliser le modificateur d'accès interne au lieu de public pour les cours.  Et, bien sûr, lorsque vous commencez à utiliser activement une nouvelle fonctionnalité de langue pour vous, certaines nuances apparaissent.  Je veux en parler dans l'ordre. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Aide de base offensive</b> <div class="spoiler_text"><p>  Uniquement pour rappeler et étiqueter. </p><br><ul><li>  L'assemblage est la plus petite unité de déploiement dans .NET et l'une des unités de compilation de base.  En l'état, il s'agit de .dll ou .exe.  Ils disent qu'il peut être divisé en plusieurs fichiers appelés modules. </li><li>  public - modificateur d'accès, ce qui signifie qu'il est accessible à tous ceux qui y sont marqués. </li><li>  internal - modificateur d'accès, ce qui signifie qu'il est marqué uniquement disponible à l'intérieur de l'assemblage. </li><li>  protected - un modificateur d'accès qui indique qu'il est marqué uniquement disponible pour les héritiers de la classe dans laquelle le marqué est situé. </li><li>  privé - un modificateur d'accès qui indique qu'il est marqué uniquement disponible pour la classe dans laquelle il se trouve.  Et personne d'autre. </li></ul><br></div></div><br><h2>  Tests unitaires et versions conviviales </h2><br><p>  En C ++, il y avait une caractéristique aussi étrange que les classes amies.  Les cours pouvaient être assignés comme amis, puis la frontière d'encapsulation entre eux était effacée.  Je soupçonne que ce n'est pas la fonctionnalité la plus étrange en C ++.  Peut-être que même le top dix des plus étranges n'est pas inclus.  Mais se tirer une balle dans le pied en reliant plusieurs classes étroitement, est en quelque sorte trop facile, et il est très difficile de trouver un étui approprié pour cette fonctionnalité. </p><br><p>  Le plus surprenant a été d'apprendre qu'en .NET il y a des assemblées amicales, une sorte de repenser.  Autrement dit, vous pouvez faire voir à un assemblage ce qui est caché derrière le verrou interne dans un autre assemblage.  Quand j'ai découvert cela, j'ai été quelque peu surpris.  Eh bien, comment le ferait-il, pourquoi?  À quoi ça sert?  Qui liera étroitement les deux assemblées, engagées dans leur séparation?  Les cas où, dans une situation incompréhensible, ils façonnent le public, nous ne les considérons pas dans cet article. </p><br><p>  Et puis dans le même projet, j'ai commencé à apprendre l'une des branches du chemin d'un vrai samouraï: le test unitaire.  Et dans le Feng Shui, les tests unitaires doivent être dans un assemblage séparé.  Pour le même Feng Shui tout ce qui peut être caché à l'intérieur de l'assemblage, vous devez vous cacher à l'intérieur de l'assemblage.  J'ai fait face à un choix très, très désagréable.  Soit les tests se dérouleront côte à côte et iront au client avec le code qui lui sera utile, soit tout sera couvert par le mot-clé public, depuis combien de temps le pain repose dans l'humidité. </p><br><p>  Et ici, quelque part dans les poubelles de ma mémoire, quelque chose a été obtenu sur les assemblées amies.  Il s'est avéré que si vous avez l'assembly "YourAssemblyName", alors vous pouvez écrire comme ceci: </p><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: InternalsVisibleTo(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"YourAssemblyName.Tests"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre> <br><p>  Et l'assembly "YourAssemblyName.Tests" verra ce qui est marqué avec le mot-clé interne dans "YourAssemblyName".  Cette ligne peut être entrée, juste un peu, dans AssemblyInfo.cs, que VS crée spécifiquement pour stocker de tels attributs. </p><br><div class="spoiler">  <b class="spoiler_title">Retour abusif à l'aide de base</b> <div class="spoiler_text">  Dans .NET, en plus d'attributs ou de mots clés déjà intégrés comme abstrait, public, interne, statique, vous pouvez créer le vôtre.  Et accrochez-les sur tout ce que vous voulez: champs, propriétés, classes, méthodes, événements et assemblages entiers.  En C #, pour cela, vous écrivez simplement le nom de l'attribut entre crochets avant ce à quoi vous vous accrochez.  L'exception est l'assemblage lui-même, car il n'y a aucune indication directe nulle part dans le code que "l'assemblage commence ici".  Là, avant le nom de l'attribut, vous devez ajouter l'assembly: <br></div></div><br><p>  Ainsi, les loups restent pleins, les moutons sont en sécurité, tout ce qui est possible se cache toujours à l'intérieur de l'assemblage, les tests unitaires vivent dans un assemblage séparé, comme il se doit, et une fonctionnalité dont je me souviens à peine obtient une raison de l'utiliser.  Peut-être la seule raison existante. </p><br><p>  J'ai presque oublié un point important.  L'action d'attribut InternalsVisibleTo est unidirectionnelle. </p><br><h2>  protégé &lt;interne? </h2><br><p>  Donc la situation: A et B étaient assis sur une pipe. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String SomeProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-comment"><span class="hljs-comment">//ERROR!!! The accessibility modifier of the 'B.OtherProperty.set' accessor must be more //restrictive than the property or indexer 'B.OtherProperty' internal String OtherProperty { get; protected set; } } }</span></span></code> </pre><br><p>  A a été détruit dans le processus de révision du code, car il n'est pas utilisé en dehors de l'assembly, mais pour une raison quelconque, se permet d'avoir un modificateur d'accès public, B a provoqué une erreur de compilation, ce qui pourrait entraîner une stupeur dans les premières minutes. </p><br><p>  Fondamentalement, le message d'erreur est logique.  L'accesseur de propriété ne peut pas révéler plus que la propriété elle-même.  N'importe qui réagira avec compréhension si le compilateur donne un en-tête pour cela: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Mais les revendications sur cette ligne brisent immédiatement le cerveau: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Je note qu'il n'y aura aucune réclamation concernant cette ligne: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Si vous ne pensez pas beaucoup, la hiérarchie suivante est construite dans votre tête: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre> <br><p>  Et cette hiérarchie semble même fonctionner.  Sauf pour un endroit.  Où interne&gt; protégé.  Pour comprendre l'essence des revendications du compilateur, rappelons quelles restrictions sont imposées par internes et protégées.  interne - uniquement à l'intérieur de l'assemblage.  protégés - seuls héritiers.  Remarquez les héritiers.  Et si la classe B est marquée comme publique, alors dans un autre assembly, vous pouvez définir ses descendants.  Et puis l'accesseur set obtient vraiment accès là où la propriété entière ne l'a pas.  Puisque le compilateur C # est paranoïaque, il ne peut même pas permettre une telle possibilité. </p><br><p>  Merci à lui pour cela, mais nous devons donner aux héritiers l'accès à l'accesseur.  Et spécifiquement pour de tels cas, il existe un modificateur d'accès interne protégé. </p><br><div class="spoiler">  <b class="spoiler_title">Cette aide n'est pas si offensante</b> <div class="spoiler_text"><ul><li>  protégé interne - un modificateur d'accès qui indique que celui marqué est disponible à l'intérieur de l'assemblage <strong>ou aux</strong> héritiers de la classe dans laquelle se trouve celui marqué. </li></ul><br></div></div><br><p>  Donc, si nous voulons que le compilateur nous permette d'utiliser cette propriété et de la définir dans les héritiers, nous devons le faire: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><p>  Et la hiérarchie correcte des modificateurs d'accès ressemble à ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre><br><h2>  Interfaces </h2><br><p>  Donc, la situation: A, I, B étaient assis sur le tuyau. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//'A' does not implement interface member 'I.SomeMethod()'. //'A.SomeMethod()' cannot implement an interface member because it is not public. } } internal class B : I { internal void SomeMethod() { //'B' does not implement interface member 'I.SomeMethod()'. //'B.SomeMethod()' cannot implement an interface member because it is not public. } } }</span></span></code> </pre><br><p>  Nous nous sommes assis exactement et ne nous sommes pas mêlés de l'extérieur de l'assemblée.  Mais ils ont été rejetés par le compilateur.  Ici, l'essence des revendications ressort clairement du message d'erreur.  L'implémentation de l'interface doit être ouverte.  Même si l'interface elle-même est fermée.  Il serait logique de lier l'accès à la mise en œuvre de l'interface à sa disponibilité, mais ce qui ne l'est pas, ne l'est pas.  L'implémentation de l'interface doit être publique. </p><br><p>  Et nous avons deux issues.  Premièrement: à travers le grincement et les grincements de dents, accrochez un modificateur d'accès public à la mise en œuvre de l'interface.  Deuxièmement: implémentation explicite de l'interface.  Cela ressemble à ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Veuillez noter que dans le deuxième cas, il n'y a pas de modificateur d'accès.  À qui dans ce cas la mise en œuvre de la méthode est-elle disponible?  Disons simplement que personne.  Il est plus facile de montrer avec un exemple: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); <span class="hljs-comment"><span class="hljs-comment">//'B' does not contain a definition for 'SomeMethod' and no accessible extension method //'SomeMethod' accepting a first argument of type 'B' could be found //(are you missing a using directive or an assembly reference?) b.SomeMethod(); //OK (b as I).SomeMethod();</span></span></code> </pre><br><p>  L'implémentation explicite de l'interface I signifie que tant que nous ne convertissons pas explicitement la variable en type I, aucune méthode n'implémente cette interface.  L'écriture (b comme I) .SomeMethod () à chaque fois peut être une surcharge.  Comme ((I) b) .Quelque méthode ().  Et j'ai trouvé deux façons de contourner cela.  J'ai pensé à un moi-même et honnêtement googlé le second. </p><br><p>  La première façon est l'usine: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Factory</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> I </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); } }</code> </pre><br><p>  Eh bien, ou tout autre motif qui vous permet de masquer cette nuance. </p><br><p>  Deuxième méthode - méthodes d'extension: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } }</code> </pre><br><p>  Étonnamment, cela fonctionne.  Ces lignes cessent de générer une erreur: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.SomeMethod();</code> </pre><br><p>  Après tout, l'appel vient, comme nous le dit IntelliSense dans Visual Studio, non pas aux méthodes pour implémenter explicitement l'interface, mais aux méthodes d'extension.  Et personne n'interdit de se tourner vers eux.  Et les méthodes d'extension d'interface peuvent être appelées sur toutes ses implémentations. </p><br><p>  Mais il reste une mise en garde.  À l'intérieur de la classe elle-même, vous devez accéder à cette méthode via le mot-clé this, sinon le compilateur ne comprendra pas que nous voulons faire référence à la méthode d'extension: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Error!!! SomeMethod(); //OK this.SomeMethod(); } void I.SomeMethod() { } }</span></span></code> </pre><br><p>  Et ainsi, et ainsi, nous avons ou public, où il ne devrait pas être, mais là, il ne <em>semble</em> pas faire de mal, ou un peu de code supplémentaire pour chaque interface interne.  Choisissez le moindre mal à votre goût. </p><br><h2>  La réflexion </h2><br><p>  Je l'ai frappé douloureusement lorsque j'ai essayé de trouver un constructeur par la réflexion, qui, bien sûr, était marquée comme interne dans la classe interne.  Et il s'est avéré que la réflexion ne donnera rien qui ne soit pas public.  Et cela, en principe, est logique. </p><br><p>  Tout d'abord, réflexion, si je me souviens bien de ce que les gens intelligents ont écrit dans les livres intelligents, il s'agit de trouver des informations dans les métadonnées d'assemblage.  Ce qui, en théorie, ne devrait pas trop en révéler (je le pensais du moins).  Deuxièmement, l'utilisation principale de la réflexion est de rendre votre programme extensible.  Vous fournissez une sorte d'interface aux étrangers (peut-être même sous forme d'interfaces, fiy-ha!).  Et ils l'implémentent et fournissent des plugins, des mods, des extensions sous la forme d'un assemblage chargé en déplacement, d'où la réflexion les obtient.  Et en soi, votre API sera publique.  C'est-à-dire que regarder l'intérieur par la réflexion n'est pas techniquement et inutile d'un point de vue pratique. </p><br><p>  <strong>Mettre à jour</strong>  Ici, dans les commentaires, il s'est avéré que la réflexion permet, si vous le demandez explicitement, de tout refléter.  Que ce soit même interne, même privé.  Si vous n'écrivez pas une sorte d'outil d'analyse de code, essayez de ne pas le faire, s'il vous plaît.  Le texte ci-dessous est toujours pertinent pour les cas où nous recherchons des types de membres ouverts.  Et en général, ne passez pas de commentaires, il y a beaucoup de choses intéressantes. </p><br><p>  Cela pourrait être terminé par la réflexion, mais revenons à l'exemple précédent, où A, I, B étaient assis sur un tuyau: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  L'auteur de la classe A a décidé qu'il ne se passerait rien de mal si la méthode de la classe interne était marquée comme publique, de sorte que le compilateur ne souffrait pas et qu'il n'était pas nécessaire de mettre plus de code dedans.  L'interface est marquée comme interne, la classe qui l'implémente est marquée comme interne, de l'extérieur il semble qu'il n'y ait aucun moyen d'accéder à la méthode marquée comme publique. </p><br><p>  Et puis la porte s'ouvre et la réflexion se glisse doucement: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pipe; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(I), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IExtensions), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindThroughReflection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type, String methodName</span></span></span><span class="hljs-function">)</span></span> { MethodInfo methodInfo = type.GetMethod(methodName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInfo != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"In type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string"> we found </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodInfo}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"NULL! Can't find method </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodName}</span></span></span><span class="hljs-string"> in type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string">"</span></span>); } } }</code> </pre><br><p>  Étudiez ce code, introduisez-le dans le studio, si vous le souhaitez.  Ici, nous essayons d'utiliser la réflexion pour trouver toutes les méthodes de tous les types de notre pipe (pipe namespace).  Et voici les résultats qu'il nous donne: </p><br><blockquote>  Dans le type I, nous avons trouvé Void SomeMethod () <br>  NULL!  Impossible de trouver la méthode SomeMethod dans le type IExtensions <br>  Dans le type A, nous avons trouvé Void SomeMethod () <br>  NULL!  Impossible de trouver la méthode OtherMethod dans le type A <br>  NULL!  Impossible de trouver la méthode SomeMethod dans le type B <br>  NULL!  Impossible de trouver la méthode OtherMethod dans le type B <br></blockquote><br><p>  Je dois dire tout de suite qu'en utilisant un objet de type MethodInfo, la méthode trouvée peut être appelée.  Autrement dit, si la réflexion a trouvé quelque chose, alors l'encapsulation peut être violée purement théoriquement.  Et nous avons trouvé quelque chose.  Tout d'abord, le même public annule SomeMethod () de la classe A. On s'attendait à quoi d'autre à dire.  Cette indulgence peut encore avoir des conséquences.  Deuxièmement, annulez SomeMethod () de l'interface I. C'est déjà plus intéressant.  Peu importe comment nous nous enfermons, les méthodes abstraites placées dans l'interface (ou ce que le CLR y place réellement) sont réellement ouvertes.  D'où la conclusion d'un paragraphe distinct: </p><br><p>  <em>Examinez attentivement qui et quel type de type de système que vous donnez.</em> </p><br><p>  Mais il y a une nuance de plus avec ces deux méthodes trouvées, que je voudrais considérer.  Les méthodes d'interface interne et les méthodes publiques des classes internes peuvent être trouvées en utilisant la réflexion.  En tant que personne raisonnable, je conclurai qu'ils font partie des métadonnées.  En tant que personne expérimentée, je vérifierai cette conclusion.  Et dans cet ILDasm nous aidera. </p><br><div class="spoiler">  <b class="spoiler_title">Jetez un œil au trou du lapin dans les métadonnées de notre pipe</b> <div class="spoiler_text"><p>  L'assemblage a été assemblé dans la version Release </p><br> <code>TypeDef #2 (02000003) <br> ------------------------------------------------------- <br> TypDefName: Pipe.I (02000003) <br> Flags : [NotPublic] [AutoLayout] [Interface] [Abstract] [AnsiClass] (000000a0) <br> Extends : 01000000 [TypeRef] <br> Method #1 (06000004) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000004) <br> Flags : [Public] [Virtual] [HideBySig] [NewSlot] [Abstract] (000005c6) <br> RVA : 0x00000000 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> TypeDef #3 (02000004) <br> ------------------------------------------------------- <br> TypDefName: Pipe.IExtensions (02000004) <br> Flags : [NotPublic] [AutoLayout] [Class] [Abstract] [Sealed] [AnsiClass] [BeforeFieldInit] (00100180) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000005) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000005) <br> Flags : [Assem] [Static] [HideBySig] [ReuseSlot] (00000093) <br> RVA : 0x00002134 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> ReturnType: Void <br> 1 Arguments <br> Argument #1: Class Pipe.I <br> 1 Parameters <br> (1) ParamToken : (08000004) Name : i flags: [none] (00000000) <br> CustomAttribute #1 (0c000011) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> CustomAttribute #1 (0c000010) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> TypeDef #4 (02000005) <br> ------------------------------------------------------- <br> TypDefName: Pipe.A (02000005) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000006) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000006) <br> Flags : [Public] [Final] [Virtual] [HideBySig] [NewSlot] (000001e6) <br> RVA : 0x0000213c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (06000007) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000007) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x0000213e <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (06000008) <br> ------------------------------------------------------- <br> MethodName: .ctor (06000008) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x00002140 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> InterfaceImpl #1 (09000001) <br> ------------------------------------------------------- <br> Class : Pipe.A <br> Token : 02000003 [TypeDef] Pipe.I <br> <br> TypeDef #5 (02000006) <br> ------------------------------------------------------- <br> TypDefName: Pipe.B (02000006) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000009) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000009) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x00002148 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (0600000a) <br> ------------------------------------------------------- <br> MethodName: Pipe.I.SomeMethod (0600000A) <br> Flags : [Private] [Final] [Virtual] [HideBySig] [NewSlot] (000001e1) <br> RVA : 0x0000214a <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (0600000b) <br> ------------------------------------------------------- <br> MethodName: .ctor (0600000B) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x0000214c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> MethodImpl #1 (00000001) <br> ------------------------------------------------------- <br> Method Body Token : 0x0600000a <br> Method Declaration Token : 0x06000004 <br> <br> InterfaceImpl #1 (09000002) <br> ------------------------------------------------------- <br> Class : Pipe.B <br> Token : 02000003 [TypeDef] Pipe.I <br></code> <br></div></div><br><p>  Un coup d'œil rapide montre que <strong>tout</strong> entre dans les métadonnées, peu importe comment elles sont marquées.  La réflexion nous cache toujours soigneusement que les étrangers ne sont pas censés voir.  Il se peut donc bien que les cinq lignes de code supplémentaires pour chaque méthode de l'interface interne ne soient pas un si grand mal.  Cependant, la principale conclusion reste la même: </p><br><p>  <em>Examinez attentivement qui et quel type de type de système que vous donnez.</em> </p><br><p>  Mais c'est, bien sûr, le niveau suivant, après l'adhésion du mot-clé interne à tous les endroits où il n'y a pas besoin de public. </p><br><h2>  PS </h2><br><p>  Vous savez que la chose la plus cool à propos de l'utilisation du mot-clé interne est partout dans l'assemblage?  Quand il grandit, vous devez le diviser en deux ou plus.  Et dans le processus, vous devez faire une pause pour ouvrir certains types.  Et vous devez penser exactement aux types qui méritent d'être ouverts.  Au moins brièvement. </p><br><p>  Cela signifie ce qui suit: <em>cette pratique d'écriture de code vous fera réfléchir à nouveau sur la forme que prendra la frontière architecturale entre les assemblages de nouveau-nés.</em>  Quoi de plus beau? </p><br><h2>  PPS </h2><br><p>  À partir de la version C # 7.2, un nouveau modificateur d'accès, privé protégé, est apparu.  Et je n'ai toujours aucune idée de ce que c'est et avec quoi on le mange.  Depuis pas rencontré dans la pratique.  Mais je serai heureux de savoir dans les commentaires.  Mais pas le copier-coller de la documentation, mais des cas réels où ce modificateur d'accès peut être nécessaire. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445804/">https://habr.com/ru/post/fr445804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445794/index.html">Les géants de l'informatique dévoilent une solution de déploiement de cloud hybride hybride</a></li>
<li><a href="../fr445796/index.html">Fintech Digest: Dorsey paie avec des bitcoins, la stratégie de la blockchain en Australie, l'introduction en bourse de Levi, le maire de Chicago et l'inévitabilité du bitcoin</a></li>
<li><a href="../fr445798/index.html">Rhinocéros à l'intérieur du chat - exécutez le firmware dans l'émulateur Kopycat</a></li>
<li><a href="../fr445800/index.html">Monades en 15 minutes</a></li>
<li><a href="../fr445802/index.html">5 choses que tout le monde devrait savoir sur Internet</a></li>
<li><a href="../fr445806/index.html">Comment l'intelligence artificielle change la science</a></li>
<li><a href="../fr445808/index.html">Nous détestons et chassons: la vie dangereuse d'un pirate de virus qui se fait de puissants ennemis</a></li>
<li><a href="../fr445814/index.html">Comment un robot de livraison a changé les habitudes culinaires des étudiants américains</a></li>
<li><a href="../fr445816/index.html">Comment nous avons vu le rendu du serveur et ce qui en est ressorti</a></li>
<li><a href="../fr445820/index.html">MVCC-3. Versions en ligne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>