<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèª üßë üñãÔ∏è Encapsulation pour de vrais samoura√Øs ou les nuances associ√©es au mot-cl√© interne en C # üåâ üçπ üéñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue: interne est un nouveau public 


 Chacun de nous r√™vait d'un projet o√π tout serait bien fait. Cela semble assez naturel. D√®s que vous appren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Encapsulation pour de vrais samoura√Øs ou les nuances associ√©es au mot-cl√© interne en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445804/"><h2>  Prologue: interne est un nouveau public </h2><br><p>  Chacun de nous r√™vait d'un projet o√π tout serait bien fait.  Cela semble assez naturel.  D√®s que vous apprenez la possibilit√© m√™me d'√©crire du bon code, d√®s que vous entendez des l√©gendes sur le m√™me code qui peuvent √™tre facilement lues et modifi√©es, vous vous allumez imm√©diatement "bien, maintenant je vais le faire correctement, je suis intelligent et je lis McConnell." </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/34f/ba6/d7e34fba6115e561d2016fa85f7a846a.jpg" alt="image"><br><br><p>  Un tel projet s'est produit dans ma vie.  Un autre.  Et je le fais sous supervision volontaire, o√π chaque ligne que je suis.  En cons√©quence, non seulement je le voulais, mais je devais tout faire correctement.  L'un des ¬´corrects¬ª √©tait ¬´respectez l'encapsulation et proche du maximum, car vous avez toujours le temps d'ouvrir, puis il sera trop tard pour refermer¬ª.  Et donc, partout o√π j'ai pu, j'ai commenc√© √† utiliser le modificateur d'acc√®s interne au lieu de public pour les cours.  Et, bien s√ªr, lorsque vous commencez √† utiliser activement une nouvelle fonctionnalit√© de langue pour vous, certaines nuances apparaissent.  Je veux en parler dans l'ordre. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Aide de base offensive</b> <div class="spoiler_text"><p>  Uniquement pour rappeler et √©tiqueter. </p><br><ul><li>  L'assemblage est la plus petite unit√© de d√©ploiement dans .NET et l'une des unit√©s de compilation de base.  En l'√©tat, il s'agit de .dll ou .exe.  Ils disent qu'il peut √™tre divis√© en plusieurs fichiers appel√©s modules. </li><li>  public - modificateur d'acc√®s, ce qui signifie qu'il est accessible √† tous ceux qui y sont marqu√©s. </li><li>  internal - modificateur d'acc√®s, ce qui signifie qu'il est marqu√© uniquement disponible √† l'int√©rieur de l'assemblage. </li><li>  protected - un modificateur d'acc√®s qui indique qu'il est marqu√© uniquement disponible pour les h√©ritiers de la classe dans laquelle le marqu√© est situ√©. </li><li>  priv√© - un modificateur d'acc√®s qui indique qu'il est marqu√© uniquement disponible pour la classe dans laquelle il se trouve.  Et personne d'autre. </li></ul><br></div></div><br><h2>  Tests unitaires et versions conviviales </h2><br><p>  En C ++, il y avait une caract√©ristique aussi √©trange que les classes amies.  Les cours pouvaient √™tre assign√©s comme amis, puis la fronti√®re d'encapsulation entre eux √©tait effac√©e.  Je soup√ßonne que ce n'est pas la fonctionnalit√© la plus √©trange en C ++.  Peut-√™tre que m√™me le top dix des plus √©tranges n'est pas inclus.  Mais se tirer une balle dans le pied en reliant plusieurs classes √©troitement, est en quelque sorte trop facile, et il est tr√®s difficile de trouver un √©tui appropri√© pour cette fonctionnalit√©. </p><br><p>  Le plus surprenant a √©t√© d'apprendre qu'en .NET il y a des assembl√©es amicales, une sorte de repenser.  Autrement dit, vous pouvez faire voir √† un assemblage ce qui est cach√© derri√®re le verrou interne dans un autre assemblage.  Quand j'ai d√©couvert cela, j'ai √©t√© quelque peu surpris.  Eh bien, comment le ferait-il, pourquoi?  √Ä quoi √ßa sert?  Qui liera √©troitement les deux assembl√©es, engag√©es dans leur s√©paration?  Les cas o√π, dans une situation incompr√©hensible, ils fa√ßonnent le public, nous ne les consid√©rons pas dans cet article. </p><br><p>  Et puis dans le m√™me projet, j'ai commenc√© √† apprendre l'une des branches du chemin d'un vrai samoura√Ø: le test unitaire.  Et dans le Feng Shui, les tests unitaires doivent √™tre dans un assemblage s√©par√©.  Pour le m√™me Feng Shui tout ce qui peut √™tre cach√© √† l'int√©rieur de l'assemblage, vous devez vous cacher √† l'int√©rieur de l'assemblage.  J'ai fait face √† un choix tr√®s, tr√®s d√©sagr√©able.  Soit les tests se d√©rouleront c√¥te √† c√¥te et iront au client avec le code qui lui sera utile, soit tout sera couvert par le mot-cl√© public, depuis combien de temps le pain repose dans l'humidit√©. </p><br><p>  Et ici, quelque part dans les poubelles de ma m√©moire, quelque chose a √©t√© obtenu sur les assembl√©es amies.  Il s'est av√©r√© que si vous avez l'assembly "YourAssemblyName", alors vous pouvez √©crire comme ceci: </p><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: InternalsVisibleTo(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"YourAssemblyName.Tests"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre> <br><p>  Et l'assembly "YourAssemblyName.Tests" verra ce qui est marqu√© avec le mot-cl√© interne dans "YourAssemblyName".  Cette ligne peut √™tre entr√©e, juste un peu, dans AssemblyInfo.cs, que VS cr√©e sp√©cifiquement pour stocker de tels attributs. </p><br><div class="spoiler">  <b class="spoiler_title">Retour abusif √† l'aide de base</b> <div class="spoiler_text">  Dans .NET, en plus d'attributs ou de mots cl√©s d√©j√† int√©gr√©s comme abstrait, public, interne, statique, vous pouvez cr√©er le v√¥tre.  Et accrochez-les sur tout ce que vous voulez: champs, propri√©t√©s, classes, m√©thodes, √©v√©nements et assemblages entiers.  En C #, pour cela, vous √©crivez simplement le nom de l'attribut entre crochets avant ce √† quoi vous vous accrochez.  L'exception est l'assemblage lui-m√™me, car il n'y a aucune indication directe nulle part dans le code que "l'assemblage commence ici".  L√†, avant le nom de l'attribut, vous devez ajouter l'assembly: <br></div></div><br><p>  Ainsi, les loups restent pleins, les moutons sont en s√©curit√©, tout ce qui est possible se cache toujours √† l'int√©rieur de l'assemblage, les tests unitaires vivent dans un assemblage s√©par√©, comme il se doit, et une fonctionnalit√© dont je me souviens √† peine obtient une raison de l'utiliser.  Peut-√™tre la seule raison existante. </p><br><p>  J'ai presque oubli√© un point important.  L'action d'attribut InternalsVisibleTo est unidirectionnelle. </p><br><h2>  prot√©g√© &lt;interne? </h2><br><p>  Donc la situation: A et B √©taient assis sur une pipe. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String SomeProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-comment"><span class="hljs-comment">//ERROR!!! The accessibility modifier of the 'B.OtherProperty.set' accessor must be more //restrictive than the property or indexer 'B.OtherProperty' internal String OtherProperty { get; protected set; } } }</span></span></code> </pre><br><p>  A a √©t√© d√©truit dans le processus de r√©vision du code, car il n'est pas utilis√© en dehors de l'assembly, mais pour une raison quelconque, se permet d'avoir un modificateur d'acc√®s public, B a provoqu√© une erreur de compilation, ce qui pourrait entra√Æner une stupeur dans les premi√®res minutes. </p><br><p>  Fondamentalement, le message d'erreur est logique.  L'accesseur de propri√©t√© ne peut pas r√©v√©ler plus que la propri√©t√© elle-m√™me.  N'importe qui r√©agira avec compr√©hension si le compilateur donne un en-t√™te pour cela: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Mais les revendications sur cette ligne brisent imm√©diatement le cerveau: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Je note qu'il n'y aura aucune r√©clamation concernant cette ligne: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Si vous ne pensez pas beaucoup, la hi√©rarchie suivante est construite dans votre t√™te: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre> <br><p>  Et cette hi√©rarchie semble m√™me fonctionner.  Sauf pour un endroit.  O√π interne&gt; prot√©g√©.  Pour comprendre l'essence des revendications du compilateur, rappelons quelles restrictions sont impos√©es par internes et prot√©g√©es.  interne - uniquement √† l'int√©rieur de l'assemblage.  prot√©g√©s - seuls h√©ritiers.  Remarquez les h√©ritiers.  Et si la classe B est marqu√©e comme publique, alors dans un autre assembly, vous pouvez d√©finir ses descendants.  Et puis l'accesseur set obtient vraiment acc√®s l√† o√π la propri√©t√© enti√®re ne l'a pas.  Puisque le compilateur C # est parano√Øaque, il ne peut m√™me pas permettre une telle possibilit√©. </p><br><p>  Merci √† lui pour cela, mais nous devons donner aux h√©ritiers l'acc√®s √† l'accesseur.  Et sp√©cifiquement pour de tels cas, il existe un modificateur d'acc√®s interne prot√©g√©. </p><br><div class="spoiler">  <b class="spoiler_title">Cette aide n'est pas si offensante</b> <div class="spoiler_text"><ul><li>  prot√©g√© interne - un modificateur d'acc√®s qui indique que celui marqu√© est disponible √† l'int√©rieur de l'assemblage <strong>ou aux</strong> h√©ritiers de la classe dans laquelle se trouve celui marqu√©. </li></ul><br></div></div><br><p>  Donc, si nous voulons que le compilateur nous permette d'utiliser cette propri√©t√© et de la d√©finir dans les h√©ritiers, nous devons le faire: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><p>  Et la hi√©rarchie correcte des modificateurs d'acc√®s ressemble √† ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre><br><h2>  Interfaces </h2><br><p>  Donc, la situation: A, I, B √©taient assis sur le tuyau. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//'A' does not implement interface member 'I.SomeMethod()'. //'A.SomeMethod()' cannot implement an interface member because it is not public. } } internal class B : I { internal void SomeMethod() { //'B' does not implement interface member 'I.SomeMethod()'. //'B.SomeMethod()' cannot implement an interface member because it is not public. } } }</span></span></code> </pre><br><p>  Nous nous sommes assis exactement et ne nous sommes pas m√™l√©s de l'ext√©rieur de l'assembl√©e.  Mais ils ont √©t√© rejet√©s par le compilateur.  Ici, l'essence des revendications ressort clairement du message d'erreur.  L'impl√©mentation de l'interface doit √™tre ouverte.  M√™me si l'interface elle-m√™me est ferm√©e.  Il serait logique de lier l'acc√®s √† la mise en ≈ìuvre de l'interface √† sa disponibilit√©, mais ce qui ne l'est pas, ne l'est pas.  L'impl√©mentation de l'interface doit √™tre publique. </p><br><p>  Et nous avons deux issues.  Premi√®rement: √† travers le grincement et les grincements de dents, accrochez un modificateur d'acc√®s public √† la mise en ≈ìuvre de l'interface.  Deuxi√®mement: impl√©mentation explicite de l'interface.  Cela ressemble √† ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Veuillez noter que dans le deuxi√®me cas, il n'y a pas de modificateur d'acc√®s.  √Ä qui dans ce cas la mise en ≈ìuvre de la m√©thode est-elle disponible?  Disons simplement que personne.  Il est plus facile de montrer avec un exemple: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); <span class="hljs-comment"><span class="hljs-comment">//'B' does not contain a definition for 'SomeMethod' and no accessible extension method //'SomeMethod' accepting a first argument of type 'B' could be found //(are you missing a using directive or an assembly reference?) b.SomeMethod(); //OK (b as I).SomeMethod();</span></span></code> </pre><br><p>  L'impl√©mentation explicite de l'interface I signifie que tant que nous ne convertissons pas explicitement la variable en type I, aucune m√©thode n'impl√©mente cette interface.  L'√©criture (b comme I) .SomeMethod () √† chaque fois peut √™tre une surcharge.  Comme ((I) b) .Quelque m√©thode ().  Et j'ai trouv√© deux fa√ßons de contourner cela.  J'ai pens√© √† un moi-m√™me et honn√™tement googl√© le second. </p><br><p>  La premi√®re fa√ßon est l'usine: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Factory</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> I </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); } }</code> </pre><br><p>  Eh bien, ou tout autre motif qui vous permet de masquer cette nuance. </p><br><p>  Deuxi√®me m√©thode - m√©thodes d'extension: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } }</code> </pre><br><p>  √âtonnamment, cela fonctionne.  Ces lignes cessent de g√©n√©rer une erreur: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.SomeMethod();</code> </pre><br><p>  Apr√®s tout, l'appel vient, comme nous le dit IntelliSense dans Visual Studio, non pas aux m√©thodes pour impl√©menter explicitement l'interface, mais aux m√©thodes d'extension.  Et personne n'interdit de se tourner vers eux.  Et les m√©thodes d'extension d'interface peuvent √™tre appel√©es sur toutes ses impl√©mentations. </p><br><p>  Mais il reste une mise en garde.  √Ä l'int√©rieur de la classe elle-m√™me, vous devez acc√©der √† cette m√©thode via le mot-cl√© this, sinon le compilateur ne comprendra pas que nous voulons faire r√©f√©rence √† la m√©thode d'extension: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Error!!! SomeMethod(); //OK this.SomeMethod(); } void I.SomeMethod() { } }</span></span></code> </pre><br><p>  Et ainsi, et ainsi, nous avons ou public, o√π il ne devrait pas √™tre, mais l√†, il ne <em>semble</em> pas faire de mal, ou un peu de code suppl√©mentaire pour chaque interface interne.  Choisissez le moindre mal √† votre go√ªt. </p><br><h2>  La r√©flexion </h2><br><p>  Je l'ai frapp√© douloureusement lorsque j'ai essay√© de trouver un constructeur par la r√©flexion, qui, bien s√ªr, √©tait marqu√©e comme interne dans la classe interne.  Et il s'est av√©r√© que la r√©flexion ne donnera rien qui ne soit pas public.  Et cela, en principe, est logique. </p><br><p>  Tout d'abord, r√©flexion, si je me souviens bien de ce que les gens intelligents ont √©crit dans les livres intelligents, il s'agit de trouver des informations dans les m√©tadonn√©es d'assemblage.  Ce qui, en th√©orie, ne devrait pas trop en r√©v√©ler (je le pensais du moins).  Deuxi√®mement, l'utilisation principale de la r√©flexion est de rendre votre programme extensible.  Vous fournissez une sorte d'interface aux √©trangers (peut-√™tre m√™me sous forme d'interfaces, fiy-ha!).  Et ils l'impl√©mentent et fournissent des plugins, des mods, des extensions sous la forme d'un assemblage charg√© en d√©placement, d'o√π la r√©flexion les obtient.  Et en soi, votre API sera publique.  C'est-√†-dire que regarder l'int√©rieur par la r√©flexion n'est pas techniquement et inutile d'un point de vue pratique. </p><br><p>  <strong>Mettre √† jour</strong>  Ici, dans les commentaires, il s'est av√©r√© que la r√©flexion permet, si vous le demandez explicitement, de tout refl√©ter.  Que ce soit m√™me interne, m√™me priv√©.  Si vous n'√©crivez pas une sorte d'outil d'analyse de code, essayez de ne pas le faire, s'il vous pla√Æt.  Le texte ci-dessous est toujours pertinent pour les cas o√π nous recherchons des types de membres ouverts.  Et en g√©n√©ral, ne passez pas de commentaires, il y a beaucoup de choses int√©ressantes. </p><br><p>  Cela pourrait √™tre termin√© par la r√©flexion, mais revenons √† l'exemple pr√©c√©dent, o√π A, I, B √©taient assis sur un tuyau: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  L'auteur de la classe A a d√©cid√© qu'il ne se passerait rien de mal si la m√©thode de la classe interne √©tait marqu√©e comme publique, de sorte que le compilateur ne souffrait pas et qu'il n'√©tait pas n√©cessaire de mettre plus de code dedans.  L'interface est marqu√©e comme interne, la classe qui l'impl√©mente est marqu√©e comme interne, de l'ext√©rieur il semble qu'il n'y ait aucun moyen d'acc√©der √† la m√©thode marqu√©e comme publique. </p><br><p>  Et puis la porte s'ouvre et la r√©flexion se glisse doucement: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pipe; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(I), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IExtensions), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindThroughReflection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type, String methodName</span></span></span><span class="hljs-function">)</span></span> { MethodInfo methodInfo = type.GetMethod(methodName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInfo != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"In type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string"> we found </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodInfo}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"NULL! Can't find method </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodName}</span></span></span><span class="hljs-string"> in type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string">"</span></span>); } } }</code> </pre><br><p>  √âtudiez ce code, introduisez-le dans le studio, si vous le souhaitez.  Ici, nous essayons d'utiliser la r√©flexion pour trouver toutes les m√©thodes de tous les types de notre pipe (pipe namespace).  Et voici les r√©sultats qu'il nous donne: </p><br><blockquote>  Dans le type I, nous avons trouv√© Void SomeMethod () <br>  NULL!  Impossible de trouver la m√©thode SomeMethod dans le type IExtensions <br>  Dans le type A, nous avons trouv√© Void SomeMethod () <br>  NULL!  Impossible de trouver la m√©thode OtherMethod dans le type A <br>  NULL!  Impossible de trouver la m√©thode SomeMethod dans le type B <br>  NULL!  Impossible de trouver la m√©thode OtherMethod dans le type B <br></blockquote><br><p>  Je dois dire tout de suite qu'en utilisant un objet de type MethodInfo, la m√©thode trouv√©e peut √™tre appel√©e.  Autrement dit, si la r√©flexion a trouv√© quelque chose, alors l'encapsulation peut √™tre viol√©e purement th√©oriquement.  Et nous avons trouv√© quelque chose.  Tout d'abord, le m√™me public annule SomeMethod () de la classe A. On s'attendait √† quoi d'autre √† dire.  Cette indulgence peut encore avoir des cons√©quences.  Deuxi√®mement, annulez SomeMethod () de l'interface I. C'est d√©j√† plus int√©ressant.  Peu importe comment nous nous enfermons, les m√©thodes abstraites plac√©es dans l'interface (ou ce que le CLR y place r√©ellement) sont r√©ellement ouvertes.  D'o√π la conclusion d'un paragraphe distinct: </p><br><p>  <em>Examinez attentivement qui et quel type de type de syst√®me que vous donnez.</em> </p><br><p>  Mais il y a une nuance de plus avec ces deux m√©thodes trouv√©es, que je voudrais consid√©rer.  Les m√©thodes d'interface interne et les m√©thodes publiques des classes internes peuvent √™tre trouv√©es en utilisant la r√©flexion.  En tant que personne raisonnable, je conclurai qu'ils font partie des m√©tadonn√©es.  En tant que personne exp√©riment√©e, je v√©rifierai cette conclusion.  Et dans cet ILDasm nous aidera. </p><br><div class="spoiler">  <b class="spoiler_title">Jetez un ≈ìil au trou du lapin dans les m√©tadonn√©es de notre pipe</b> <div class="spoiler_text"><p>  L'assemblage a √©t√© assembl√© dans la version Release </p><br> <code>TypeDef #2 (02000003) <br> ------------------------------------------------------- <br> TypDefName: Pipe.I (02000003) <br> Flags : [NotPublic] [AutoLayout] [Interface] [Abstract] [AnsiClass] (000000a0) <br> Extends : 01000000 [TypeRef] <br> Method #1 (06000004) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000004) <br> Flags : [Public] [Virtual] [HideBySig] [NewSlot] [Abstract] (000005c6) <br> RVA : 0x00000000 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> TypeDef #3 (02000004) <br> ------------------------------------------------------- <br> TypDefName: Pipe.IExtensions (02000004) <br> Flags : [NotPublic] [AutoLayout] [Class] [Abstract] [Sealed] [AnsiClass] [BeforeFieldInit] (00100180) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000005) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000005) <br> Flags : [Assem] [Static] [HideBySig] [ReuseSlot] (00000093) <br> RVA : 0x00002134 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> ReturnType: Void <br> 1 Arguments <br> Argument #1: Class Pipe.I <br> 1 Parameters <br> (1) ParamToken : (08000004) Name : i flags: [none] (00000000) <br> CustomAttribute #1 (0c000011) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> CustomAttribute #1 (0c000010) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> TypeDef #4 (02000005) <br> ------------------------------------------------------- <br> TypDefName: Pipe.A (02000005) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000006) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000006) <br> Flags : [Public] [Final] [Virtual] [HideBySig] [NewSlot] (000001e6) <br> RVA : 0x0000213c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (06000007) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000007) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x0000213e <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (06000008) <br> ------------------------------------------------------- <br> MethodName: .ctor (06000008) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x00002140 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> InterfaceImpl #1 (09000001) <br> ------------------------------------------------------- <br> Class : Pipe.A <br> Token : 02000003 [TypeDef] Pipe.I <br> <br> TypeDef #5 (02000006) <br> ------------------------------------------------------- <br> TypDefName: Pipe.B (02000006) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000009) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000009) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x00002148 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (0600000a) <br> ------------------------------------------------------- <br> MethodName: Pipe.I.SomeMethod (0600000A) <br> Flags : [Private] [Final] [Virtual] [HideBySig] [NewSlot] (000001e1) <br> RVA : 0x0000214a <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (0600000b) <br> ------------------------------------------------------- <br> MethodName: .ctor (0600000B) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x0000214c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> MethodImpl #1 (00000001) <br> ------------------------------------------------------- <br> Method Body Token : 0x0600000a <br> Method Declaration Token : 0x06000004 <br> <br> InterfaceImpl #1 (09000002) <br> ------------------------------------------------------- <br> Class : Pipe.B <br> Token : 02000003 [TypeDef] Pipe.I <br></code> <br></div></div><br><p>  Un coup d'≈ìil rapide montre que <strong>tout</strong> entre dans les m√©tadonn√©es, peu importe comment elles sont marqu√©es.  La r√©flexion nous cache toujours soigneusement que les √©trangers ne sont pas cens√©s voir.  Il se peut donc bien que les cinq lignes de code suppl√©mentaires pour chaque m√©thode de l'interface interne ne soient pas un si grand mal.  Cependant, la principale conclusion reste la m√™me: </p><br><p>  <em>Examinez attentivement qui et quel type de type de syst√®me que vous donnez.</em> </p><br><p>  Mais c'est, bien s√ªr, le niveau suivant, apr√®s l'adh√©sion du mot-cl√© interne √† tous les endroits o√π il n'y a pas besoin de public. </p><br><h2>  PS </h2><br><p>  Vous savez que la chose la plus cool √† propos de l'utilisation du mot-cl√© interne est partout dans l'assemblage?  Quand il grandit, vous devez le diviser en deux ou plus.  Et dans le processus, vous devez faire une pause pour ouvrir certains types.  Et vous devez penser exactement aux types qui m√©ritent d'√™tre ouverts.  Au moins bri√®vement. </p><br><p>  Cela signifie ce qui suit: <em>cette pratique d'√©criture de code vous fera r√©fl√©chir √† nouveau sur la forme que prendra la fronti√®re architecturale entre les assemblages de nouveau-n√©s.</em>  Quoi de plus beau? </p><br><h2>  PPS </h2><br><p>  √Ä partir de la version C # 7.2, un nouveau modificateur d'acc√®s, priv√© prot√©g√©, est apparu.  Et je n'ai toujours aucune id√©e de ce que c'est et avec quoi on le mange.  Depuis pas rencontr√© dans la pratique.  Mais je serai heureux de savoir dans les commentaires.  Mais pas le copier-coller de la documentation, mais des cas r√©els o√π ce modificateur d'acc√®s peut √™tre n√©cessaire. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445804/">https://habr.com/ru/post/fr445804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445794/index.html">Les g√©ants de l'informatique d√©voilent une solution de d√©ploiement de cloud hybride hybride</a></li>
<li><a href="../fr445796/index.html">Fintech Digest: Dorsey paie avec des bitcoins, la strat√©gie de la blockchain en Australie, l'introduction en bourse de Levi, le maire de Chicago et l'in√©vitabilit√© du bitcoin</a></li>
<li><a href="../fr445798/index.html">Rhinoc√©ros √† l'int√©rieur du chat - ex√©cutez le firmware dans l'√©mulateur Kopycat</a></li>
<li><a href="../fr445800/index.html">Monades en 15 minutes</a></li>
<li><a href="../fr445802/index.html">5 choses que tout le monde devrait savoir sur Internet</a></li>
<li><a href="../fr445806/index.html">Comment l'intelligence artificielle change la science</a></li>
<li><a href="../fr445808/index.html">Nous d√©testons et chassons: la vie dangereuse d'un pirate de virus qui se fait de puissants ennemis</a></li>
<li><a href="../fr445814/index.html">Comment un robot de livraison a chang√© les habitudes culinaires des √©tudiants am√©ricains</a></li>
<li><a href="../fr445816/index.html">Comment nous avons vu le rendu du serveur et ce qui en est ressorti</a></li>
<li><a href="../fr445820/index.html">MVCC-3. Versions en ligne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>