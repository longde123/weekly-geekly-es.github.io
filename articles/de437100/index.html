<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔰 🏹 🤳🏽 Das Reverse Engineering des Renderings von The Witcher 3 🙎🏿 👨🏻‍💼 🎅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der erste Teil der Übersetzung ist hier . In diesem Teil werden wir über die Auswirkungen von Schärfe, durchschnittlicher Helligkeit, Mondphasen und a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Reverse Engineering des Renderings von The Witcher 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437100/">  Der erste Teil der Übersetzung ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  In diesem Teil werden wir über die Auswirkungen von Schärfe, durchschnittlicher Helligkeit, Mondphasen und atmosphärischen Phänomenen während des Regens sprechen. <br><br><h2>  Teil 6. Schärfen </h2><br>  In diesem Teil werden wir uns einen weiteren Nachbearbeitungseffekt von The Witcher 3 - Sharpen genauer ansehen. <br><br>  Durch das Schärfen wird das Ausgabebild etwas schärfer.  Dieser Effekt ist uns aus Photoshop und anderen Grafikeditoren bekannt. <br><br>  In The Witcher 3 hat das Schärfen zwei Möglichkeiten: niedrig und hoch.  Ich werde unten auf den Unterschied zwischen ihnen eingehen, aber jetzt schauen wir uns die Screenshots an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/285/1fc/6bc/2851fc6bc19e39660e0307f2775b0322.png" alt="Bild"></div><br>  <i>Option „Niedrig“ - bis zu</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/cd4/4cd/dc2cd44cd83306f2c08bbf7f87831d8c.png" alt="Bild"></div><br>  <i>Option “Niedrig” - danach</i> <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aad/807/2aa/aad8072aa3977f32549856c0be24206b.png"></div><br>  <i>Hohe Option - bis zu</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/3ce/0f3/b873ce0f320a785f4fb4bc83e9a696f5.png"></div><br>  <i>Option "Hoch" - nach</i> <br><br>  Wenn Sie sich detailliertere (interaktive) Vergleiche ansehen möchten, lesen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt im Nvidia The Witcher 3-Leistungshandbuch</a> .  Wie Sie sehen, macht sich der Effekt besonders bei Gras und Laub bemerkbar. <br><br>  In diesem Teil des Beitrags werden wir den Rahmen von Anfang an studieren: Ich habe ihn absichtlich gewählt, weil wir hier das Relief (lange Zeichenentfernung) und die Kuppel des Himmels sehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/898/e97/895/898e9789593705231157a07ebcf34f5e.png"></div><br>  In Bezug auf die Eingabe erfordert das Schärfen einen Farbpuffer <b>t0</b> (LDR nach Tonkorrektur und Linseneffekten) und einen Tiefenpuffer <b>t1</b> . <br><br>  Lassen Sie uns den Assembler-Code für den Pixel-Shader untersuchen: <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb3[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_input_ps_siv v0.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 7 <br> 0: ftoi r0.xy, v0.xyxx <br> 1: mov r0.zw, l(0, 0, 0, 0) <br> 2: ld_indexable(texture2d)(float,float,float,float) r0.x, r0.xyzw, t1.xyzw <br> 3: mad r0.x, r0.x, cb12[22].x, cb12[22].y <br> 4: mad r0.y, r0.x, cb12[21].x, cb12[21].y <br> 5: max r0.y, r0.y, l(0.000100) <br> 6: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 7: mad_sat r0.y, r0.y, cb3[1].z, cb3[1].w <br> 8: add r0.z, -cb3[1].x, cb3[1].y <br> 9: mad r0.y, r0.y, r0.z, cb3[1].x <br> 10: add r0.y, r0.y, l(1.000000) <br> 11: ge r0.x, r0.x, l(1.000000) <br> 12: movc r0.x, r0.x, l(0), l(1.000000) <br> 13: mul r0.z, r0.x, r0.y <br> 14: round_z r1.xy, v0.xyxx <br> 15: add r1.xy, r1.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000) <br> 16: div r1.xy, r1.xyxx, cb3[0].zwzz <br> 17: sample_l(texture2d)(float,float,float,float) r2.xyz, r1.xyxx, t0.xyzw, s0, l(0) <br> 18: lt r0.z, l(0), r0.z <br> 19: if_nz r0.z <br> 20: div r3.xy, l(0.500000, 0.500000, 0.000000, 0.000000), cb3[0].zwzz <br> 21: add r0.zw, r1.xxxy, -r3.xxxy <br> 22: sample_l(texture2d)(float,float,float,float) r4.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 23: mov r3.zw, -r3.xxxy <br> 24: add r5.xyzw, r1.xyxy, r3.zyxw <br> 25: sample_l(texture2d)(float,float,float,float) r6.xyz, r5.xyxx, t0.xyzw, s0, l(0) <br> 26: add r4.xyz, r4.xyzx, r6.xyzx <br> 27: sample_l(texture2d)(float,float,float,float) r5.xyz, r5.zwzz, t0.xyzw, s0, l(0) <br> 28: add r4.xyz, r4.xyzx, r5.xyzx <br> 29: add r0.zw, r1.xxxy, r3.xxxy <br> 30: sample_l(texture2d)(float,float,float,float) r1.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 31: add r1.xyz, r1.xyzx, r4.xyzx <br> 32: mul r3.xyz, r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000) <br> 33: mad r1.xyz, -r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000), r2.xyzx <br> 34: max r0.z, abs(r1.z), abs(r1.y) <br> 35: max r0.z, r0.z, abs(r1.x) <br> 36: mad_sat r0.z, r0.z, cb3[2].x, cb3[2].y <br> 37: mad r0.x, r0.y, r0.x, l(-1.000000) <br> 38: mad r0.x, r0.z, r0.x, l(1.000000) <br> 39: dp3 r0.y, l(0.212600, 0.715200, 0.072200, 0.000000), r2.xyzx <br> 40: dp3 r0.z, l(0.212600, 0.715200, 0.072200, 0.000000), r3.xyzx <br> 41: max r0.w, r0.y, l(0.000100) <br> 42: div r1.xyz, r2.xyzx, r0.wwww <br> 43: add r0.y, -r0.z, r0.y <br> 44: mad r0.x, r0.x, r0.y, r0.z <br> 45: max r0.x, r0.x, l(0) <br> 46: mul r2.xyz, r0.xxxx, r1.xyzx <br> 47: endif <br> 48: mov o0.xyz, r2.xyzx <br> 49: mov o0.w, l(1.000000) <br> 50: ret</code> <br> <br>  50 Zeilen Assembler-Code scheinen eine machbare Aufgabe zu sein.  Kommen wir zur Lösung. <br><br><h3>  Wertschöpfung schärfen </h3><br>  Der erste Schritt ist das Laden des Tiefenpuffers (Zeile 1).  Es ist erwähnenswert, dass der „The Witcher 3“ eine umgekehrte Tiefe verwendet (1,0 - nah, 0,0 - fern).  Wie Sie vielleicht wissen, ist die Hardwaretiefe nichtlinear gebunden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einzelheiten finden</a> Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> ). <br><br>  Die Zeilen 3-6 bieten eine sehr interessante Möglichkeit, diese Hardwaretiefe [1.0 - 0.0] mit [Nah-Fern] -Werten zu verknüpfen (wir setzen sie in der MatrixPerspectiveFov-Phase).  Betrachten Sie die Werte aus dem konstanten Puffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/636/345/52a/63634552ae9daf03f14305c118cccc25.png"></div><br>  Mit dem Wert "close" von 0,2 und dem Wert "far" 5000 können wir die Werte von cb12_v21.xy wie folgt berechnen: <br><br> <code>cb12_v21.y = 1.0 / near <br> cb12_v21.x = - (1.0 / near) + (1.0 / near) * (near / far)</code> <br> <br>  Dieser Code ist in TW3-Shadern weit verbreitet, daher denke ich, dass er nur eine Funktion ist. <br><br>  Nach Erhalt der „Tiefe der Sichtbarkeitspyramide“ verwendet Zeile 7 die Skalierung / Verzerrung, um den Interpolationskoeffizienten zu erstellen (hier verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sättigung</a> , um die Werte auf das Intervall [0-1] zu beschränken). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/efd/571/e89efd5711cb2aa1a3c544e9deda9321.png"></div><br>  cb3_v1.xy und cb3_v2.xy - Dies ist die Helligkeit des Schärfeeffekts bei kurzen und langen Entfernungen.  Nennen wir sie sharpenNear und sharpenFar.  Und dies ist der einzige Unterschied zwischen den Optionen "Niedrig" und "Hoch" dieses Effekts in The Witcher 3. <br><br>  Jetzt ist es Zeit, das resultierende Verhältnis zu verwenden.  Die Zeilen 8-9 führen nur <code>lerp(sharpenNear, sharpenFar, interpolationCoeff)</code> .  Wofür ist das?  Dank dessen erhalten wir unterschiedliche Helligkeit in der Nähe von Geralt und von ihm weg.  Schauen Sie mal rein: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/233/515/6462335151728759f236b58f14b894dd.png"></div><br>  Vielleicht ist dies kaum wahrnehmbar, aber hier haben wir basierend auf dem Abstand die Schärfehelligkeit neben dem Player (2.177151) interpoliert und die Effekthelligkeit ist sehr weit (1.91303).  Nach dieser Berechnung addieren wir 1,0 zur Helligkeit (Zeile 10).  Warum wird das benötigt?  Angenommen, die oben gezeigte Operation lerp ergab 0,0.  Nach dem Hinzufügen von 1.0 erhalten wir natürlich 1.0, und dies ist ein Wert, der das Pixel beim Schärfen nicht beeinflusst.  Lesen Sie weiter unten mehr darüber. <br><br>  Beim Schärfen möchten wir den Himmel nicht beeinflussen.  Dies kann durch Hinzufügen einer einfachen bedingten Prüfung erreicht werden: <br><br> <code>//   sharpen   <br> float fSkyboxTest = (fDepth &gt;= 1.0) ? 0 : 1;</code> <br> <br>  In The Witcher 3 beträgt der Wert der Pixeltiefe des Himmels 1,0, daher verwenden wir ihn, um eine Art „Binärfilter“ zu erhalten (eine interessante Tatsache: In diesem Fall funktioniert der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schritt</a> nicht richtig). <br><br>  Jetzt können wir die interpolierte Helligkeit mit einem „Himmelsfilter“ multiplizieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/ed1/f50/63ced1f5036d9ee63cfe54de6a501bc1.png"></div><br>  Diese Multiplikation wird in Zeile 13 durchgeführt. <br><br>  Shader-Codebeispiel: <br><br> <code>//    sharpen <br> float fSharpenAmount = fSharpenIntensity * fSkyboxTest;</code> <br> <br><h3>  Pixel Sampling Center </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SV_Position</a> hat einen Aspekt, der hier wichtig sein wird: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen halben</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pixelversatz</a> .  Es stellt sich heraus, dass dieses Pixel in der oberen linken Ecke (0, 0) keine Koordinaten (0, 0) in Bezug auf SV_Position.xy hat, sondern (0,5, 0,5).  Wow! <br><br>  Hier wollen wir ein Beispiel in der Mitte des Pixels nehmen, schauen wir uns also die Zeilen 14-16 an.  Sie können sie in HLSL schreiben: <br><br> <code>//   . <br> //   ""   SV_Position.xy. <br> float2 uvCenter = trunc( Input.Position.xy ); <br> <br> //   ,       <br> uvCenter += float2(0.5, 0.5); <br> uvCenter /= g_Viewport.xy</code> <br> <br>  Und später probieren wir die Eingabefarbtextur von texcoords „uvCenter“ aus.  Keine Sorge, das Ergebnis der Stichprobe ist das gleiche wie bei der „normalen“ Methode (SV_Position.xy / ViewportSize.xy). <br><br><h3>  Schärfen oder nicht schärfen </h3><br>  Die Entscheidung, ob Sharpen verwendet werden soll, hängt von fSharpenAmount ab. <br><br> <code>//     <br> float3 colorCenter = TexColorBuffer.SampleLevel( samplerLinearClamp, uvCenter, 0 ).rgb; <br> <br> //   <br> float3 finalColor = colorCenter; <br> <br> if ( fSharpenAmount &gt; 0 ) <br> { <br> //   sharpening... <br> } <br> <br> return float4( finalColor, 1 );</code> <br> <br><h3>  Schärfen </h3><br>  Es ist Zeit, einen Blick auf die Innenseiten des Algorithmus selbst zu werfen. <br><br>  Im Wesentlichen werden die folgenden Aktionen ausgeführt: <br><br>  - Abtastung der vierfachen Eingabefarbtextur an den Ecken des Pixels, <br><br>  - fügt Stichproben hinzu und berechnet den Durchschnittswert, <br><br>  - berechnet die Differenz zwischen "Mitte" und "Eckdurchschnitt", <br><br>  - findet die maximale absolute Komponente der Differenz, <br><br>  - korrigiert max.  abs.  Komponente unter Verwendung von Skala + Bias-Werten, <br><br>  - bestimmt die Stärke des Effekts mit max.  abs.  Komponente <br><br>  - berechnet den Helligkeitswert (Luma) für "centerColor" und "durchschnittlichColor", <br><br>  - teilt colorCenter in seine Luma, <br><br>  - berechnet einen neuen, interpolierten Luma-Wert basierend auf der Stärke des Effekts, <br><br>  - Multipliziert colorCenter mit dem neuen Luma-Wert. <br><br>  Viel Arbeit, und es war schwierig für mich, es herauszufinden, weil ich noch nie mit Schärfefiltern experimentiert hatte. <br><br>  Beginnen wir mit dem Stichprobenmuster.  Wie Sie im Assembler-Code sehen können, werden vier Texturlesevorgänge durchgeführt. <br><br>  Dies wird am besten anhand eines Beispiels eines Pixelbilds gezeigt (das Können des Künstlers ist <i>ein Experte</i> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e3/d46/5fa/5e3d465fadc0bccd551256c40c6e5368.png"></div><br>  Alle Lesevorgänge im Shader verwenden bilineares Sampling (D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT). <br><br>  Der Versatz von der Mitte zu jedem der Winkel beträgt (± 0,5, ± 0,5), abhängig vom Winkel. <br><br>  Sehen Sie, wie dies auf HLSL implementiert werden kann?  Mal sehen: <br><br> <code>float2 uvCorner; <br> float2 uvOffset = float2( 0.5, 0.5 ) / g_Viewport.xy; // remember about division! <br> <br> float3 colorCorners = 0; <br> <br> //    <br> // -0,5, -0.5 <br> uvCorner = uvCenter - uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, -0.5 <br> uvCorner = uvCenter + float2(uvOffset.x, -uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // -0.5, +0.5 <br> uvCorner = uvCenter + float2(-uvOffset.x, uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, +0.5 <br> uvCorner = uvCenter + uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb;</code> <br> <br>  Jetzt sind alle vier Beispiele in der Variablen „colorCorners“ zusammengefasst.  Befolgen wir diese Schritte: <br><br> <code>//     <br> float3 averageColorCorners = colorCorners / 4.0; <br> <br> //    <br> float3 diffColor = colorCenter - averageColorCorners; <br> <br> //  . . RGB-  <br> float fDiffColorMaxComponent = max( abs(diffColor.x), max( abs(diffColor.y), abs(diffColor.z) ) ); <br> <br> //    <br> float fDiffColorMaxComponentScaled = saturate( fDiffColorMaxComponent * sharpenLumScale + sharpenLumBias ); <br> <br> //     . <br> //   "1.0" -      fSharpenIntensity  1.0. <br> float fPixelSharpenAmount = lerp(1.0, fSharpenAmount, fDiffColorMaxComponentScaled); <br> <br> //   ""     . <br> float lumaCenter = dot( LUMINANCE_RGB, finalColor ); <br> float lumaCornersAverage = dot( LUMINANCE_RGB, averageColorCorners ); <br> <br> //  "centerColor"    <br> float3 fColorBalanced = colorCenter / max( lumaCenter, 1e-4 ); <br> <br> //    <br> float fPixelLuminance = lerp(lumaCornersAverage, lumaCenter, fPixelSharpenAmount); <br> <br> //     <br> finalColor = fColorBalanced * max(fPixelLuminance, 0.0); <br> } <br> <br> return float4(finalColor, 1.0);</code> <br> <br>  Die Kantenerkennung erfolgt durch Berechnung von max.  abs.  Differenzkomponente.  Kluger Schachzug!  Schauen Sie sich die Visualisierung an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/a26/44a/aa9a2644a16b1b79c6213f7d4effe068.jpg"></div><br>  <i>Visualisierung der maximalen absoluten Komponente der Differenz.</i> <br><br>  Großartig.  Der fertige HLSL-Shader ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verfügbar.  Entschuldigung für die ziemlich schlechte Formatierung.  Sie können mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HLSLexplorer-</a> Programm verwenden und mit dem Code experimentieren. <br><br>  Ich kann glücklich sagen, dass der obige Code den gleichen Assembler-Code wie im Spiel erzeugt! <br><br>  Zusammenfassend: Der Schärfeshader Witcher 3 ist sehr gut geschrieben (beachten Sie, dass fPixelSharpenAmount größer als 1,0 ist! Dies ist interessant ...).  Darüber hinaus ist die Helligkeit von Nah- / Fernobjekten die Hauptmethode zum Ändern der Helligkeit des Effekts.  In diesem Spiel sind sie keine Konstanten;  Ich habe einige Beispiele für Werte gesammelt: <br><br>  Skellige: <br><br><table><tbody><tr><th></th><th>  sharpenNear </th><th>  sharpenFar </th><th>  sharpenDistanceScale </th><th>  sharpenDistanceBias </th><th>  sharpenLumScale </th><th>  sharpenLumBias </th></tr><tr><td>  <b>niedrig</b> </td></tr></tbody><tbody><tr><td>  <b>hoch</b> </td><td>  2.0 </td><td>  1.8 </td><td>  0,025 <br></td><td>  -0,25 <br></td><td>  -13,333333 <br></td><td>  1,33333 </td></tr></tbody></table><br>  Kaer Morhen: <br><br><table><tbody><tr><th></th><th>  sharpenNear <br></th><th>  sharpenFar <br></th><th>  sharpenDistanceScale <br></th><th>  sharpenDistanceBias <br></th><th>  sharpenLumScale <br></th><th>  sharpenLumBias <br></th></tr><tr><td>  niedrig <br></td><td>  0,57751 <br></td><td>  0,31303 <br></td><td>  0,06665 <br></td><td>  -0,33256 <br></td><td>  -1,0 <br></td><td>  2.0 <br></td></tr><tr><td>  hoch <br></td><td>  2.17751 <br></td><td>  1,91303 <br></td><td>  0,06665 <br></td><td>  -0,33256 <br></td><td>  -1,0 <br></td><td>  2.0 </td></tr></tbody></table><br><h2>  Teil 7. Durchschnittliche Helligkeit </h2><br>  Die Berechnung der durchschnittlichen Helligkeit des aktuellen Frames ist in fast jedem modernen Videospiel möglich.  Dieser Wert wird häufig später für den Effekt der Augenanpassung und Tonwertkorrektur verwendet (siehe im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teil des</a> Beitrags).  In einfachen Lösungen wird die Helligkeitsberechnung beispielsweise für die Textur 512 <sup>2 verwendet</sup> , dann die Berechnung ihrer Mip-Pegel und deren Anwendung.  Dies funktioniert normalerweise, schränkt jedoch die Möglichkeiten stark ein.  Bei komplexeren Lösungen werden Computer-Shader verwendet, die beispielsweise eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">parallele Reduktion durchführen</a> . <br><br>  Lassen Sie uns in The Witcher 3 herausfinden, wie das CD Projekt Red-Team dieses Problem gelöst hat.  Im vorherigen Teil habe ich bereits die Tonwertkorrektur und Anpassung des Auges untersucht, sodass das einzige verbleibende Puzzleteil die durchschnittliche Helligkeit war. <br><br>  Die durchschnittliche Helligkeitsberechnung von The Witcher 3 besteht zunächst aus zwei Durchgängen.  Aus Gründen der Klarheit habe ich beschlossen, sie in separate Teile zu zerlegen, und zunächst betrachten wir den ersten Durchgang - „Helligkeitsverteilung“ (Berechnung des Helligkeitshistogramms). <br><br><h3>  Helligkeitsverteilung </h3><br>  Diese beiden Durchgänge sind in jedem Frame-Analysator ziemlich leicht zu finden.  Dies sind die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versandaufrufe</a> in der richtigen Reihenfolge, bevor die Augenanpassung durchgeführt wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/5fb/09c/7de5fb09ce00453f14262f9e2b1bae30.png"></div><br>  Schauen wir uns die Eingabe für diesen Durchgang an.  Er braucht zwei Texturen: <br><br>  1) HDR-Farbpuffer, dessen Skalierung auf 1/4 x 1/4 reduziert ist (z. B. von 1920 x 1080 auf 480 x 270), <br><br>  2) Vollbild-Tiefenpuffer <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/021/38b/795/02138b795946d192f553eadc20d34366.png"></div><br>  <i>1/4 x 1/4 HDR-Farbpuffer.</i>  <i>Beachten Sie den kniffligen Trick - dieser Puffer ist Teil eines größeren Puffers.</i>  <i>Das Wiederverwenden von Puffern ist eine gute Praxis.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/62d/c97/0e362dc97908f75db564cff0f46b1e7e.png"></div><br>  <i>Vollbild-Tiefenpuffer</i> <br><br>  Warum den Farbpuffer verkleinern?  Ich denke, es geht nur um Leistung. <br><br>  Die Ausgabe dieses Durchlaufs ist ein strukturierter Puffer.  256 Elemente zu je 4 Bytes. <br><br>  Shader haben hier keine Debugging-Informationen. Nehmen wir also an, es handelt sich nur um einen Puffer mit vorzeichenlosen int-Werten. <br><br>  Wichtig: Der erste Schritt bei der Berechnung der durchschnittlichen Helligkeit ruft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ClearUnorderedAccessViewUint</a> auf, um alle Elemente des strukturierten Puffers auf Null zurückzusetzen. <br><br>  Lassen Sie uns den Assembler-Code des Computer-Shaders untersuchen (dies ist der erste Computer-Shader in unserer gesamten Analyse!) <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[3], immediateIndexed <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_uav_structured u0, 4 <br> dcl_input vThreadGroupID.x <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 6 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: store_structured g0.x, vThreadIDInGroup.x, l(0), l(0) <br> 1: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 2: store_structured g0.x, r0.x, l(0), l(0) <br> 3: store_structured g0.x, r0.y, l(0), l(0) <br> 4: store_structured g0.x, r0.z, l(0), l(0) <br> 5: sync_g_t <br> 6: ftoi r1.x, cb0[2].z <br> 7: mov r2.y, vThreadGroupID.x <br> 8: mov r2.zw, l(0, 0, 0, 0) <br> 9: mov r3.zw, l(0, 0, 0, 0) <br> 10: mov r4.yw, l(0, 0, 0, 0) <br> 11: mov r1.y, l(0) <br> 12: loop <br> 13: utof r1.z, r1.y <br> 14: ge r1.z, r1.z, cb0[0].x <br> 15: breakc_nz r1.z <br> 16: iadd r2.x, r1.y, vThreadIDInGroup.x <br> 17: utof r1.z, r2.x <br> 18: lt r1.z, r1.z, cb0[0].x <br> 19: if_nz r1.z <br> 20: ld_indexable(texture2d)(float,float,float,float) r5.xyz, r2.xyzw, t0.xyzw <br> 21: dp3 r1.z, r5.xyzx, l(0.212600, 0.715200, 0.072200, 0.000000) <br> 22: imul null, r3.xy, r1.xxxx, r2.xyxx <br> 23: ld_indexable(texture2d)(float,float,float,float) r1.w, r3.xyzw, t1.yzwx <br> 24: eq r1.w, r1.w, cb0[2].w <br> 25: and r1.w, r1.w, cb0[2].y <br> 26: add r2.x, -r1.z, cb0[2].x <br> 27: mad r1.z, r1.w, r2.x, r1.z <br> 28: add r1.z, r1.z, l(1.000000) <br> 29: log r1.z, r1.z <br> 30: mul r1.z, r1.z, l(88.722839) <br> 31: ftou r1.z, r1.z <br> 32: umin r4.x, r1.z, l(255) <br> 33: atomic_iadd g0, r4.xyxx, l(1) <br> 34: endif <br> 35: iadd r1.y, r1.y, l(64) <br> 36: endloop <br> 37: sync_g_t <br> 38: ld_structured r1.x, vThreadIDInGroup.x, l(0), g0.xxxx <br> 39: mov r4.z, vThreadIDInGroup.x <br> 40: atomic_iadd u0, r4.zwzz, r1.x <br> 41: ld_structured r1.x, r0.x, l(0), g0.xxxx <br> 42: mov r0.w, l(0) <br> 43: atomic_iadd u0, r0.xwxx, r1.x <br> 44: ld_structured r0.x, r0.y, l(0), g0.xxxx <br> 45: atomic_iadd u0, r0.ywyy, r0.x <br> 46: ld_structured r0.x, r0.z, l(0), g0.xxxx <br> 47: atomic_iadd u0, r0.zwzz, r0.x <br> 48: ret</code> <br> <br>  Und ein konstanter Puffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/805/dc6/c14805dc6b7ffd431d9307cc46dcba0d.png"></div><br>  Wir wissen bereits, dass der erste Eingang ein HDR-Farbpuffer ist.  Bei FullHD beträgt die Auflösung 480 x 270.  Schauen wir uns den Versandaufruf an. <br><br>  Versand (270, 1, 1) - Dies bedeutet, dass 270 Thread-Gruppen ausgeführt werden.  Einfach ausgedrückt, führen wir eine Gruppe von Threads pro Zeile des Farbpuffers aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/a97/7e3/e9aa977e3f9a60104fe9a66d797a27cc.png"></div><br>  <i>Jede Thread-Gruppe führt eine Zeile HDR-Farbpuffer aus</i> <br><br>  Nachdem wir diesen Kontext haben, versuchen wir herauszufinden, was der Shader tut. <br><br>  Jede Thread-Gruppe hat 64 Threads in X-Richtung (dcl_thread_group 64, 1, 1) sowie gemeinsam genutzten Speicher, 256 Elemente mit jeweils 4 Bytes (dcl_tgsm_structured g0, 4, 256). <br><br>  Beachten Sie, dass wir im Shader <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SV_GroupThreadID</a> (vThreadIDInGroup.x) [0-63] und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SV_GroupID</a> (vThreadGroupID.x) [0-269] verwenden. <br><br>  1) Wir beginnen damit, allen Elementen des gemeinsam genutzten Speichers Nullwerte zuzuweisen.  Da der Gesamtspeicher 256 Elemente und 64 Threads pro Gruppe enthält, kann dies bequem mit einer einfachen Schleife durchgeführt werden: <br><br> <code>//   -      . <br> //        64 ,          4 . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = 0; <br> }</code> <br> <br>  2) Danach setzen wir die Barriere mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GroupMemoryBarrierWithGroupSync</a> (sync_g_t).  Wir tun dies, um sicherzustellen, dass alle Threads im gemeinsam genutzten Speicher der Gruppen auf Null zurückgesetzt werden, bevor Sie mit dem nächsten Schritt fortfahren. <br><br>  3) Jetzt führen wir eine Schleife aus, die grob wie folgt geschrieben werden kann: <br><br> <code>// cb0_v0.x -      .  1920x1080   1920/4 = 480; <br> float ViewportSizeX = cb0_v0.x; <br> [loop] for ( uint PositionX = 0; PositionX &lt; ViewportSizeX; PositionX += 64 ) <br> { <br> ...</code> <br> <br>  Dies ist eine einfache for-Schleife mit einem Inkrement von 64 (haben Sie bereits verstanden, warum?). <br><br>  Der nächste Schritt besteht darin, die Position des geladenen Pixels zu berechnen. <br><br>  Lass uns darüber nachdenken. <br><br>  Für die Y-Koordinate können wir SV_GroupID.x verwenden, da wir 270 Thread-Gruppen gestartet haben. <br><br>  Für die X-Koordinate können wir ... den aktuellen Gruppenfluss nutzen!  Lass es uns versuchen. <br><br>  Da jede Gruppe 64 Threads enthält, werden bei einer solchen Lösung alle Pixel umgangen. <br><br>  Betrachten Sie die Thread-Gruppe (0, 0, 0). <br><br>  - Der Stream (0, 0, 0) verarbeitet die Pixel (0, 0), (64, 0), (128, 0), (192, 0), (256, 0), (320, 0), (384, 0), (448,0). <br><br>  - Der Stream (1, 0, 0) verarbeitet die Pixel (1, 0), (65, 0), (129, 0), (193, 0), (257, 0), (321, 0), (385, 0), (449, 0) ... <br><br>  - Der Stream (63, 0, 0) verarbeitet die Pixel (63, 0), (127, 0), (191, 0), (255, 0), (319, 0), (383, 0), (447, 0) <br><br>  Somit werden alle Pixel verarbeitet. <br><br>  Wir müssen auch sicherstellen, dass wir keine Pixel von außerhalb des Farbpuffers laden: <br><br> <code>//      X.  Y  GroupID. <br> uint CurrentPixelPositionX = PositionX + threadID; <br> uint CurrentPixelPositionY = groupID; <br> if ( CurrentPixelPositionX &lt; ViewportSizeX ) <br> { <br> // HDR- . <br> //   HDR-    ,     . <br> uint2 colorPos = uint2(CurrentPixelPositionX, CurrentPixelPositionY); <br> float3 color = texture0.Load( int3(colorPos, 0) ).rgb; <br> float luma = dot(color, LUMA_RGB);</code> <br> <br>  Sehen Sie?  Es ist ziemlich einfach! <br><br>  Ich habe auch die Helligkeit berechnet (Zeile 21 des Assembler-Codes). <br><br>  Großartig, wir haben die Helligkeit bereits aus einem Farbpixel berechnet.  Der nächste Schritt ist das Laden (keine Probe!) Des entsprechenden Tiefenwerts. <br><br>  Aber hier haben wir ein Problem, weil wir den Puffer der Tiefen voller Auflösung verbunden haben.  Was tun? <br><br>  Dies ist überraschend einfach - multiplizieren Sie colorPos einfach mit einer Konstanten (cb0_v2.z).  Wir haben den HDR-Farbpuffer viermal verkleinert.  daher ist der Wert 4! <br><br> <code>const int iDepthTextureScale = (int) cb0_v2.z; <br> uint2 depthPos = iDepthTextureScale * colorPos; <br> float depth = texture1.Load( int3(depthPos, 0) ).x;</code> <br> <br>  So weit so gut!  Aber ... wir müssen die Zeilen 24-25 erreichen ... <br><br> <code>24: eq r2.x, r2.x, cb0[2].w <br> 25: and r2.x, r2.x, cb0[2].y</code> <br> <br>  Also  Zuerst haben wir einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich der</a> Gleitkomma- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gleichheit</a> , ihr Ergebnis ist in r2.x geschrieben, und gleich danach geht ... was?  Bitweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und</a> ??  Wirklich?  Für einen Gleitkommawert?  Was zur Hölle??? <br><br>  <b>Das Problem 'eq + and'</b> <br><br>  Lassen Sie mich nur sagen, dass es für mich der schwierigste Teil des Shaders war.  Ich habe sogar seltsame Asint / Asfloat-Kombinationen ausprobiert ... <br><br>  Und wenn Sie einen etwas anderen Ansatz verwenden?  Lassen Sie uns einfach den üblichen Float-Float-Vergleich in HLSL durchführen. <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y); <br> return test; <br> }</code> <br> <br>  Und hier ist die Ausgabe im Assembler-Code: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, l(0x3f800000) <br> 2: ret</code> <br> <br>  Interessant, oder?  Ich hatte nicht erwartet, "und" hier zu sehen. <br><br>  0x3f800000 ist nur 1.0f ... Es ist logisch, weil wir sonst 1.0 und 0.0 erhalten, wenn der Vergleich erfolgreich ist. <br><br>  Aber was ist, wenn wir 1.0 durch einen anderen Wert ersetzen?  Zum Beispiel so: <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y) ? cb0_v0.z : 0.0; <br> return test; <br> }</code> <br> <br>  Wir erhalten folgendes Ergebnis: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, cb0[0].z <br> 2: ret</code> <br> <br>  Ha!  Es hat funktioniert.  Dies ist nur die Magie des HLSL-Compilers.  Hinweis: Wenn Sie 0.0 durch etwas anderes ersetzen, erhalten Sie nur movc. <br><br>  Kehren wir zum Computational Shader zurück.  Der nächste Schritt besteht darin, zu überprüfen, ob die Tiefe gleich cb0_v2.w ist.  Es ist immer gleich 0.0 - mit anderen Worten, wir prüfen, ob sich ein Pixel in einer fernen Ebene (am Himmel) befindet.  Wenn ja, dann weisen wir diesem Koeffizienten einen Wert von ungefähr 0,5 zu (ich habe mehrere Frames überprüft). <br><br>  Dieser berechnete Koeffizient wird verwendet, um zwischen der Helligkeit der Farbe und der Helligkeit des „Himmels“ zu interpolieren (cb0_v2.x-Wert, der häufig ungefähr gleich 0,0 ist).  Ich gehe davon aus, dass dies notwendig ist, um die Bedeutung des Himmels für die Berechnung der durchschnittlichen Helligkeit zu kontrollieren.  Normalerweise wird die Wichtigkeit reduziert.  Sehr clevere Idee. <br><br> <code>// ,       ( ).  ,    ,    <br> //    . <br> float value = (depth == cb0_v2.w) ? cb0_v2.y : 0.0; <br> <br> //  'value'  0.0,   lerp    'luma'.   'value'  <br> // (  0.50),   luma    . (cb0_v2.x    0.0). <br> float lumaOk = lerp( luma, cb0_v2.x, value );</code> <br> <br>  Da wir lumaOk haben, besteht der nächste Schritt darin, seinen natürlichen Logarithmus zu berechnen, um eine gute Verteilung zu erstellen.  Aber warten Sie, sagen wir, lumaOk ist 0.0.  Wir wissen, dass der Wert von log (0) undefiniert ist, also addieren wir 1.0, weil log (1) = 0.0 ist. <br><br>  Danach skalieren wir den berechneten Logarithmus auf 128, um ihn in 256 Zellen zu verteilen.  Sehr schlau! <br><br>  Und von hier aus wird dieser Wert 88.722839 genommen.  Dies ist ein <code>128 *   (2)</code> . <br><br>  Auf diese Weise berechnet HLSL Logarithmen. <br><br>  Es gibt nur eine Funktion im HLSL-Assembler-Code, die Logarithmen berechnet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">log</a> , und sie hat eine Basis von 2. <br><br> <code>// ,  lumaOk  0.0. <br> // log(0)   undefined <br> // log(1) = 0. <br> //     <br> lumaOk = log(lumaOk + 1.0); <br> <br> //     128 <br> lumaOk *= 128;</code> <br> <br>  Schließlich berechnen wir den Index der Zelle aus der logarithmisch verteilten Helligkeit und addieren 1 zur entsprechenden Zelle im gemeinsam genutzten Speicher. <br><br> <code>//   .    Uint,    256 , <br> //  ,      . <br> uint uLuma = (uint) lumaOk; <br> uLuma = min(uLuma, 255); <br> <br> //  1    . <br> InterlockedAdd( shared_data[uLuma], 1 );</code> <br> <br>  Im nächsten Schritt wird erneut eine Barriere festgelegt, um sicherzustellen, dass alle Pixel in der Zeile verarbeitet wurden. <br><br>  Der letzte Schritt besteht darin, dem strukturierten Puffer Werte aus dem gemeinsam genutzten Speicher hinzuzufügen.  Dies geschieht auf die gleiche Weise über eine einfache Schleife: <br><br> <code>// ,       <br> GroupMemoryBarrierWithGroupSync(); <br> <br> //      . <br> [unroll] for (uint idx = 0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> <br> uint data = shared_data[offset]; <br> InterlockedAdd( g_buffer[offset], data ); <br> }</code> <br> <br>  Nachdem alle 64 Threads in der Thread-Gruppe die gemeinsamen Daten ausgefüllt haben, fügt jeder Thread dem Ausgabepuffer 4 Werte hinzu. <br><br>  Betrachten Sie den Ausgabepuffer.  Lass uns darüber nachdenken.  Die Summe aller Werte im Puffer entspricht der Gesamtzahl der Pixel!  (bei 480 × 270 = 129.600).  Das heißt, wir wissen, wie viele Pixel einen bestimmten Helligkeitswert haben. <br><br>  Wenn Sie sich mit Computer-Shadern (wie ich) schlecht auskennen, ist dies zunächst möglicherweise nicht klar. Lesen Sie den Beitrag daher noch einige Male, nehmen Sie Papier und einen Bleistift und versuchen Sie, die Konzepte zu verstehen, auf denen diese Technik basiert. <br><br>  Das ist alles!  So berechnet The Witcher 3 ein Helligkeitshistogramm.  Persönlich habe ich beim Schreiben dieses Teils viel gelernt.  Herzlichen Glückwunsch an die Jungs von CD Projekt Red für ihre hervorragende Arbeit! <br><br>  Wenn Sie an einem vollständigen HLSL-Shader interessiert sind, finden Sie ihn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Ich bemühe mich immer, den Assembler-Code so nah wie möglich am Spiel zu haben und bin vollkommen froh, dass es mir wieder gelungen ist! <br><br><h2>  Berechnung der durchschnittlichen Helligkeit </h2><br>  Dies ist der zweite Teil der Analyse von Berechnungen mittlerer Helligkeit in „The Witcher 3: Wild Hunt“. <br><br>  Bevor wir uns mit einem anderen Computational Shader messen, wiederholen wir kurz, was im letzten Teil passiert ist: Wir haben mit einem HDR-Farbpuffer mit einer Skalierung auf 1 / 4x1 / 4 gearbeitet.  Nach dem ersten Durchgang erhielten wir ein Helligkeitshistogramm (strukturierter Puffer mit 256 vorzeichenlosen ganzzahligen Werten).  Wir haben den Logarithmus für die Helligkeit jedes Pixels berechnet, ihn auf 256 Zellen verteilt und den entsprechenden Wert des strukturierten Puffers um 1 pro Pixel erhöht.  Aus diesem Grund entspricht die Gesamtsumme aller Werte in diesen 256 Zellen der Anzahl der Pixel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/89c/d16/3c389cd16ec2eed7617dcf9334429c6e.png"></div><br>  <i>Ein Beispiel für die Ausgabe des ersten Durchgangs.</i>  <i>Es gibt 256 Elemente.</i> <br><br>  Unser Vollbildpuffer hat beispielsweise eine Größe von 1920 x 1080.  Nach dem Verkleinern wurde beim ersten Durchgang ein Puffer von 480 x 270 verwendet.  Die Summe aller 256 Werte im Puffer entspricht 480 * 270 = 129 600. <br><br>  Nach dieser kurzen Einführung sind wir bereit, mit dem nächsten Schritt fortzufahren: dem Rechnen. <br><br>  Diesmal wird nur eine Thread-Gruppe verwendet (Dispatch (1, 1, 1)). <br><br>  Schauen wir uns den Assembler-Code des Computational Shader an: <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_uav_structured u0, 4 <br> dcl_uav_typed_texture2d (float,float,float,float) u1 <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 4 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, vThreadIDInGroup.x, l(0), u0.xxxx <br> 1: store_structured g0.x, vThreadIDInGroup.x, l(0), r0.x <br> 2: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 3: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.w, r0.x, l(0), u0.xxxx <br> 4: store_structured g0.x, r0.x, l(0), r0.w <br> 5: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.y, l(0), u0.xxxx <br> 6: store_structured g0.x, r0.y, l(0), r0.x <br> 7: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.z, l(0), u0.xxxx <br> 8: store_structured g0.x, r0.z, l(0), r0.x <br> 9: sync_g_t <br> 10: if_z vThreadIDInGroup.x <br> 11: mul r0.x, cb0[0].y, cb0[0].x <br> 12: ftou r0.x, r0.x <br> 13: utof r0.y, r0.x <br> 14: mul r0.yz, r0.yyyy, cb0[0].zzwz <br> 15: ftoi r0.yz, r0.yyzy <br> 16: iadd r0.x, r0.x, l(-1) <br> 17: imax r0.y, r0.y, l(0) <br> 18: imin r0.y, r0.x, r0.y <br> 19: imax r0.z, r0.y, r0.z <br> 20: imin r0.x, r0.x, r0.z <br> 21: mov r1.z, l(-1) <br> 22: mov r2.xyz, l(0, 0, 0, 0) <br> 23: loop <br> 24: breakc_nz r2.x <br> 25: ld_structured r0.z, r2.z, l(0), g0.xxxx <br> 26: iadd r3.x, r0.z, r2.y <br> 27: ilt r0.z, r0.y, r3.x <br> 28: iadd r3.y, r2.z, l(1) <br> 29: mov r1.xy, r2.yzyy <br> 30: mov r3.z, r2.x <br> 31: movc r2.xyz, r0.zzzz, r1.zxyz, r3.zxyz <br> 32: endloop <br> 33: mov r0.w, l(-1) <br> 34: mov r1.yz, r2.yyzy <br> 35: mov r1.xw, l(0, 0, 0, 0) <br> 36: loop <br> 37: breakc_nz r1.x <br> 38: ld_structured r2.x, r1.z, l(0), g0.xxxx <br> 39: iadd r1.y, r1.y, r2.x <br> 40: utof r2.x, r2.x <br> 41: utof r2.w, r1.z <br> 42: add r2.w, r2.w, l(0.500000) <br> 43: mul r2.w, r2.w, l(0.011271) <br> 44: exp r2.w, r2.w <br> 45: add r2.w, r2.w, l(-1.000000) <br> 46: mad r3.z, r2.x, r2.w, r1.w <br> 47: ilt r2.x, r0.x, r1.y <br> 48: iadd r2.w, -r2.y, r1.y <br> 49: itof r2.w, r2.w <br> 50: div r0.z, r3.z, r2.w <br> 51: iadd r3.y, r1.z, l(1) <br> 52: mov r0.y, r1.z <br> 53: mov r3.w, r1.x <br> 54: movc r1.xzw, r2.xxxx, r0.wwyz, r3.wwyz <br> 55: endloop <br> 56: store_uav_typed u1.xyzw, l(0, 0, 0, 0), r1.wwww <br> 57: endif <br> 58: ret</code> <br> <br>  Es gibt einen konstanten Puffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbe/13a/0ab/bbe13a0abe0d79f47b0a59d33d51ab9c.png"></div><br>  Werfen Sie einen kurzen Blick auf den Assembler-Code: Zwei UAVs sind angehängt (u0: Eingabepuffer aus dem ersten Teil und u1: Ausgabetextur im Format 1x1 R32_FLOAT).  Wir sehen auch, dass es 64 Threads pro Gruppe und 256 Elemente des gemeinsam genutzten 4-Byte-Gruppenspeichers gibt. <br><br>  Wir beginnen damit, den gemeinsam genutzten Speicher mit Daten aus dem Eingabepuffer zu füllen.  Wir haben 64 Threads, daher müssen Sie fast das Gleiche tun wie zuvor. <br><br>  Um absolut sicher zu sein, dass alle Daten zur weiteren Verarbeitung geladen wurden, setzen wir danach eine Barriere. <br><br> <code>//   -        . <br> //        64 ,    4     <br> //    . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = g_buffer[offset]; <br> } <br> //    ,       ,     <br> //             . <br> GroupMemoryBarrierWithGroupSync();</code> <br> <br>  Alle Berechnungen werden nur in einem Thread ausgeführt, alle anderen werden einfach zum Laden von Werten aus dem Puffer in den gemeinsam genutzten Speicher verwendet. <br><br>  Der "Computer" -Stream hat einen Index von 0. Warum?  Theoretisch können wir jeden Stream aus dem Intervall [0-63] verwenden, aber dank eines Vergleichs mit 0 können wir zusätzliche Ganzzahl-Ganzzahl-Vergleiche ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dhq-</a> Anweisungen) vermeiden. <br><br>  Der Algorithmus basiert auf der Angabe des Pixelintervalls, das bei der Operation berücksichtigt wird. <br><br>  In Zeile 11 multiplizieren wir width * height, um die Gesamtzahl der Pixel zu erhalten, und multiplizieren sie mit zwei Zahlen aus dem Intervall [0.0f-1.0f], wobei der Beginn und das Ende des Intervalls angegeben werden.  Weitere Einschränkungen werden verwendet, um sicherzustellen, dass <code>0 &lt;= Start &lt;= End &lt;= totalPixels - 1</code> : <br><br> <code>//        0. <br> [branch] if (threadID == 0) <br> { <br> //         <br> uint totalPixels = cb0_v0.x * cb0_v0.y; <br> <br> //   (,  ,    ), <br> //        . <br> int pixelsToConsiderStart = totalPixels * cb0_v0.z; <br> int pixelsToConsiderEnd = totalPixels * cb0_v0.w; <br> <br> int pixelsMinusOne = totalPixels - 1; <br> <br> pixelsToConsiderStart = clamp( pixelsToConsiderStart, 0, pixelsMinusOne ); <br> pixelsToConsiderEnd = clamp( pixelsToConsiderEnd, pixelsToConsiderStart, pixelsMinusOne );</code> <br> <br>  Wie Sie sehen können, gibt es unten zwei Zyklen.  Das Problem mit ihnen (oder mit ihrem Assembler-Code) ist, dass es seltsame bedingte Übergänge an den Enden von Schleifen gibt.  Es war sehr schwierig für mich, sie nachzubilden.  Schauen Sie sich auch Zeile 21 an. Warum gibt es "-1"?  Ich werde es unten etwas erklären. <br><br>  Die Aufgabe des ersten Zyklus besteht darin, <i>pixelsToConsiderStart</i> zu <i>löschen</i> und den Index der Pufferzelle <i>anzugeben,</i> in der <i>pixelsToConsiderStart</i> +1 vorhanden ist (sowie die Anzahl aller Pixel in den vorherigen Zellen). <br><br>  <i>Angenommen</i> , <i>pixelsToConsiderStart entspricht</i> ungefähr 30.000, und im Puffer befinden sich 37.000 Pixel in der Zelle „Null“ (dies geschieht nachts im Spiel).  Daher möchten wir die Analyse der Helligkeit mit ungefähr dem Pixel 30001 beginnen, das in der Zelle "Null" vorhanden ist.  In diesem Fall verlassen wir sofort die Schleife und erhalten den Startindex '0' und null verworfene Pixel. <br><br>  Schauen Sie sich den HLSL-Code an: <br><br> <code>//     <br> int numProcessedPixels = 0; <br> <br> //   [0-255] <br> int lumaValue = 0; <br> <br> //      <br> bool bExitLoop = false; <br> <br> //    -  "pixelsToConsiderStart" . <br> //          lumaValue,      . <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> // ,      lumaValue <br> int tempSum = numProcessedPixels + numPixels; <br> <br> //  ,  pixelsToConsiderStart,    . <br> // ,      lumaValue. <br> //  , pixelsToConsiderStart -   "" ,   ,    . <br> [flatten] <br> if (tempSum &gt; pixelsToConsiderStart) <br> { <br> bExitLoop = true; <br> } <br> else <br> { <br> numProcessedPixels = tempSum; <br> lumaValue++; <br> } <br> }</code> <br> <br>  Die mysteriöse Zahl "-1" aus Zeile 21 des Assembler-Codes ist mit der Booleschen Bedingung für die Schleifenausführung verbunden (ich habe dies fast zufällig entdeckt). <br><br>  Nachdem wir die Anzahl der Pixel von <i>lumaValue-</i> Zellen und <i>lumaValue</i> selbst erhalten haben, können wir mit dem zweiten Zyklus <i>fortfahren</i> . <br><br>  Die Aufgabe des zweiten Zyklus besteht darin, den Einfluss von Pixeln und der durchschnittlichen Helligkeit zu berechnen. <br><br>  Wir beginnen mit <i>lumaValue, das</i> in der ersten Schleife berechnet wurde. <br><br> <code>float finalAvgLuminance = 0.0f; <br> <br> //       <br> uint numProcessedPixelStart = numProcessedPixels; <br> <br> //    -      . <br> //    ,    ,        lumaValue. <br> //      [0-255],     ,    ,   ,    <br> //    pixelsToConsiderEnd. <br> //          . <br> bExitLoop = false; <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> //      <br> numProcessedPixels += numPixels; <br> <br> //    ,    [0-255] (uint) <br> uint encodedLumaUint = lumaValue; <br> <br> //        <br> float numberOfPixelsWithCurrentLuma = numPixels; <br> <br> //    ,    [0-255] (float) <br> float encodedLumaFloat = encodedLumaUint;</code> <br> <br>  Zu diesem Zeitpunkt erhielten wir den im Intervall [0.0f-255.f] codierten Helligkeitswert. <br><br>  Der Dekodierungsprozess ist recht einfach - Sie müssen die Berechnung der Kodierungsstufe umkehren. <br><br>  Eine kurze Wiederholung des Codierungsprozesses: <br><br> <code>float luma = dot( hdrPixelColor, float3(0.2126, 0.7152, 0.0722) ); <br> ... <br> float outLuma; <br> <br> //   log(0)  undef,  log(1) = 0 <br> outLuma = luma + 1.0; <br> <br> //   <br> outLuma = log( outLuma ); <br> <br> //   128,   log(1) * 128 = 0, log(2,71828) * 128 = 128, log(7,38905) * 128 = 256 <br> outLuma = outLuma * 128 <br> <br> //   uint <br> uint outLumaUint = min( (uint) outLuma, 255);</code> <br> <br>  Um die Helligkeit zu dekodieren, kehren wir den Kodierungsprozess beispielsweise wie folgt um: <br><br> <code>//    0.5f (  ,    ) <br> float fDecodedLuma = encodedLumaFloat + 0.5; <br> <br> //   : <br> <br> //   128 <br> fDecodedLuma /= 128.0; <br> <br> // exp(x),   log(x) <br> fDecodedLuma = exp(fDecodedLuma); <br> <br> //  1.0 <br> fDecodedLuma -= 1.0;</code> <br> <br>  Dann berechnen wir die Verteilung, indem wir die Anzahl der Pixel mit einer bestimmten Helligkeit mit der decodierten Helligkeit multiplizieren und sie summieren, bis wir zur Verarbeitung von <i>pixelsToConsiderEnd-</i> Pixeln gelangen. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach teilen wir den Gesamteffekt auf die Anzahl der analysierten Pixel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist der Rest der Schleife (und der Shader): Der </font><font style="vertical-align: inherit;">vollständige Shader ist </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hier</font></a><font style="vertical-align: inherit;"> verfügbar </font><font style="vertical-align: inherit;">. Es ist vollständig kompatibel mit meinem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">HLSLexplorer-</font></a><font style="vertical-align: inherit;"> Programm </font><font style="vertical-align: inherit;">, ohne das ich die durchschnittliche Helligkeitsberechnung in The Witcher 3 (und allen anderen Effekten auch!) Nicht effektiv </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">nachbilden könnte</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Abschließend noch ein paar Gedanken. Bei der Berechnung der durchschnittlichen Helligkeit war dieser Shader schwer wiederherzustellen. Die Hauptgründe: </font><font style="vertical-align: inherit;">1) Seltsame "ausstehende" Überprüfungen der Ausführung des Zyklus, es dauerte viel länger als ich bisher dachte. </font><font style="vertical-align: inherit;">2) Probleme beim Debuggen dieses Computer-Shaders in RenderDoc (Version 1.2).</font></font><br><br> <code>//     <br> float fCurrentLumaContribution = numberOfPixelsWithCurrentLuma * fDecodedLuma; <br> <br> // ()       . <br> float tempTotalContribution = fCurrentLumaContribution + finalAvgLuminance; <br> <br> <br> [flatten] <br> if (numProcessedPixels &gt; pixelsToConsiderEnd ) <br> { <br> //     <br> bExitLoop = true; <br> <br> //      ,     . <br> //         <br> int diff = numProcessedPixels - numProcessedPixelStart; <br> <br> //     <br> finalAvgLuminance = tempTotalContribution / float(diff); <br> } <br> else <br> { <br> //       lumaValue <br> finalAvgLuminance = tempTotalContribution; <br> lumaValue++; <br> } <br> } <br> <br> //    <br> g_avgLuminance[uint2(0,0)] = finalAvgLuminance;</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Operationen "ld_structured_indexable" werden nicht vollständig unterstützt, obwohl das Ergebnis des Lesens aus Index 0 den korrekten Wert ergibt, alle anderen geben Nullen zurück, weshalb die Zyklen unbegrenzt fortgesetzt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl ich nicht den gleichen Assembler-Code wie im Original erzielen konnte (Unterschiede siehe Screenshot unten), konnte ich mit RenderDoc diesen Shader in die Pipeline einfügen - und die Ergebnisse waren dieselben!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/a0e/74f/de1a0e74f0f6619994d1edc9621d148d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ergebnis der Schlacht. </font><font style="vertical-align: inherit;">Links ist mein Shader, rechts ist der ursprüngliche Assembler-Code.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 8. Der Mond und seine Phasen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im achten Teil des Artikels untersuche ich den Mond-Shader aus The Witcher 3 (und genauer gesagt aus der Blood and Wine-Erweiterung). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Mond ist ein wichtiges Element des Nachthimmels, und es kann ziemlich schwierig sein, ihn glaubwürdig zu machen, aber für mich war es ein echtes Vergnügen, nachts in TW3 zu laufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schau dir diese Szene an!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/099/b6c/53f099b6ccfcef0eeb0755ced73894b9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir uns mit dem Pixel-Shader befassen, möchte ich einige Worte zu den Nuancen des Renderns sagen. Aus geometrischer Sicht ist der Mond nur eine Kugel (siehe unten) mit Texturkoordinaten, Normal- und Tangentenvektoren. Der Vertex-Shader berechnet die Position im Weltraum sowie die normalisierten Vektoren von Normalen, tangential und tangential zu zwei Punkten (unter Verwendung eines Vektorprodukts), multipliziert mit der Weltmatrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen , </font><font style="vertical-align: inherit;">dass der Mond liegt ganz auf den entfernten Ebene, Felder und MinDepth MaxDepth Struktur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D3D11_VIEWPORT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Wert 0,0 (den gleichen Trick, der </font><font style="vertical-align: inherit;">für den Himmel Kuppel verwendet wurde) zugewiesen. Der Mond wird unmittelbar nach dem Himmel gerendert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f5/999/ec7/6f5999ec7ca1176dfac370f60820d97f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kugel, mit der der Mond</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gezeichnet wurde </font><i><font style="vertical-align: inherit;">.</font></i><font style="vertical-align: inherit;"> Nun, ich denke, alles, was Sie tun können. </font><font style="vertical-align: inherit;">Werfen wir einen Blick auf den Pixel-Shader: Der </font><font style="vertical-align: inherit;">Hauptgrund, warum ich mich für einen Shader von Blood and Wine entschieden habe, ist einfach - er ist kürzer. </font><font style="vertical-align: inherit;">Zuerst berechnen wir den Versatz, um die Textur abzutasten. </font><font style="vertical-align: inherit;">cb0 [0] .w wird als Versatz entlang der X-Achse verwendet. Mit diesem einfachen Trick können wir die Drehung des Mondes um seine Achse simulieren.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[267], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_input_ps linear v1.w <br> dcl_input_ps linear v2.xyzw <br> dcl_input_ps linear v3.xy <br> dcl_input_ps linear v4.xy <br> dcl_output o0.xyzw <br> dcl_temps 3 <br> 0: mov r0.x, -cb0[0].w <br> 1: mov r0.y, l(0) <br> 2: add r0.xy, r0.xyxx, v2.xyxx <br> 3: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, r0.xyxx, t0.xyzw, s0 <br> 4: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 5: log r0.w, r0.w <br> 6: mul r0.w, r0.w, l(2.200000) <br> 7: exp r0.w, r0.w <br> 8: add r0.xyz, r0.xyzx, r0.xyzx <br> 9: dp3 r1.x, r0.xyzx, r0.xyzx <br> 10: rsq r1.x, r1.x <br> 11: mul r0.xyz, r0.xyzx, r1.xxxx <br> 12: mul r1.xy, r0.yyyy, v3.xyxx <br> 13: mad r0.xy, v4.xyxx, r0.xxxx, r1.xyxx <br> 14: mad r0.xy, v2.zwzz, r0.zzzz, r0.xyxx <br> 15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185) <br> 17: sincos r1.x, r2.x, r0.z <br> 18: mov r2.y, r1.x <br> 19: dp2_sat r0.x, r0.xyxx, r2.xyxx <br> 20: mul r0.xyz, r0.xxxx, cb12[266].xyzx <br> 21: mul r0.xyz, r0.xyzx, r0.wwww <br> 22: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 23: add_sat r0.w, -v1.w, l(1.000000) <br> 24: mul r0.w, r0.w, cb2[2].w <br> 25: mul o0.xyz, r0.wwww, r0.xyzx <br> 26: mov o0.w, l(0) <br> 27: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc2/ddb/c02/fc2ddbc0262d27002f70d837a623c366.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele für Werte aus dem konstanten Puffer:</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine Textur (1024 x 512) wird als Eingabe angehängt. </font><font style="vertical-align: inherit;">Die normale Karte ist in den RGB-Kanälen und die Farbe der Mondoberfläche im Alphakanal codiert. </font><font style="vertical-align: inherit;">Clever!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/733/1a1/3927331a17867d712e667c36a0ee6641.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Alpha-Kanal einer Textur ist die Farbe der Mondoberfläche.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/542/d70/c64542d70a7e3b58aa9426f12e8880d7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textur-RGB-Kanäle sind eine normale Karte.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir die richtigen Texturkoordinaten erhalten haben, probieren wir die RGBA-Kanäle aus. Wir müssen die normale Karte auspacken und eine Gammakorrektur der Oberflächenfarbe durchführen. Derzeit kann ein HLSL-Shader folgendermaßen geschrieben werden: </font><font style="vertical-align: inherit;">Der nächste Schritt besteht darin, eine normale Bindung durchzuführen, jedoch nur in XY-Komponenten. (In The Witcher 3 ist die Z-Achse oben und der gesamte Z-Kanal der Textur ist 1,0). Wir können es so machen: </font><font style="vertical-align: inherit;">Jetzt ist es Zeit für meinen Lieblingsteil dieses Shaders. </font><font style="vertical-align: inherit;">Schauen Sie sich noch </font><font style="vertical-align: inherit;">einmal die Zeilen 15-16 an: </font><font style="vertical-align: inherit;">Was ist das für ein mysteriöses 0.033864? Zunächst scheint es keinen Sinn zu machen, aber wenn wir den umgekehrten Wert berechnen, erhalten wir ungefähr 29,53, was der Dauer des </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">synodischen Monats entspricht</font></a></font><br><br> <code>float4 MoonPS(in InputStruct IN) : SV_Target0 <br> { <br> //  Texcoords <br> float2 uvOffsets = float2(-cb0_v0.w, 0.0); <br> <br> //  texcoords <br> float2 uv = IN.param2.xy + uvOffsets; <br> <br> //   <br> float4 sampledTexture = texture0.Sample( sampler0, uv); <br> <br> //    -  - <br> float moonColorTex = pow(sampledTexture.a, 2.2 ); <br> <br> //     [0,1]   [-1,1]. <br> // : sampledTexture.xyz * 2.0 - 1.0    <br> float3 sampledNormal = normalize((sampledTexture.xyz - 0.5) * 2);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>//    <br> float3 Tangent = IN.param4.xyz; <br> float3 Normal = float3(IN.param2.zw, IN.param3.w); <br> float3 Bitangent = IN.param3.xyz; <br> <br> //  TBN <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> <br> //    XY <br> //   TBN  float3x2: 3 , 2  <br> float2 vNormal = mul(sampledNormal, (float3x2)TBN).xy;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185)</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Tagen! </font><font style="vertical-align: inherit;">Das ist es, was ich auf Details aufmerksam mache! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können zuverlässig davon ausgehen, dass cb0 [0] .y die Anzahl der Tage ist, die während des Spiels vergangen sind. </font><font style="vertical-align: inherit;">Hier wird eine zusätzliche Abweichung verwendet, die als Versatz entlang der x-Achse der Textur verwendet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir diesen Koeffizienten erhalten haben, multiplizieren wir ihn mit 2 * Pi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann berechnen wir mit sincos einen weiteren 2d-Vektor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Berechnung des Skalarprodukts zwischen dem Normalenvektor und dem "Mond" -Vektor wird eine Mondphase simuliert. </font><font style="vertical-align: inherit;">Schauen Sie sich die Screenshots mit verschiedenen Mondphasen an:</font></font><br><br> <code>//  . <br> //   days/29.53 + bias. <br> float phase = cb0_v0.y * (1.0 / SYNODIC_MONTH_LENGTH) + cb0_v0.w; <br> <br> //   2*PI.  , 29.53     <br> //   sin/cos. <br> phase *= TWOPI; <br> <br> //      . <br> float outSin = 0.0; <br> float outCos = 0.0; <br> sincos(phase, outSin, outCos); <br> <br> //    <br> float lunarPhase = saturate( dot(vNormal, float2(outCos, outSin)) );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c54/e7f/648/c54e7f6488b10d402a7f4b45e61d455d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/133/edc/899133edc0c04c67ffb4987748e908b7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Schritt besteht darin, eine Reihe von Multiplikationsoperationen durchzuführen, um die endgültige Farbe zu berechnen. </font><font style="vertical-align: inherit;">Sie verstehen wahrscheinlich nicht, warum dieser Shader einen Alpha-Wert von 0,0 an die Ausgabe sendet. </font><font style="vertical-align: inherit;">Dies liegt daran, dass der Mond mit aktivierter Überblendung gerendert wird:</font></font><br><br> <code>//        . <br> <br> // cb12_v266.xyz ,      . <br> //  (1.54, 2.82, 4.13) <br> float3 moonSurfaceGlowColor = cb12_v266.xyz; <br> <br> float3 moonColor = lunarPhase * moonSurfaceGlowColor; <br> moonColor = moonColorTex * moonColor; <br> <br> // cb_v2.xyz - , , ,  (1.0, 1.0, 1.0) <br> moonColor *= cb2_v2.xyz; <br> <br> //   ,    , .  -   . <br> //     ,         , <br> //   . <br> float paramHorizon = saturate(1.0 - IN.param1.w); <br> paramHorizon *= cb2_v2.w; <br> <br> moonColor *= paramHorizon; <br> <br> //        <br> return float4(moonColor, 0.0);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/549/32c/2d954932c188bcdcdd0a156796b85da7.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem Ansatz können Sie die Hintergrundfarbe (Himmelfarbe) abrufen, wenn dieser Shader Schwarz zurückgibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie an einem vollständigen Shader interessiert sind, können Sie ihn </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier herunterladen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es hat große konstante Puffer und sollte bereits für die Injektion in RenderDoc anstelle des ursprünglichen Shaders bereit sein (benennen Sie einfach "MoonPS" in "EditedShaderPS" um). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und das letzte: Ich wollte die Ergebnisse mit Ihnen teilen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links ist mein Shader, rechts ist der ursprüngliche Shader aus dem Spiel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Unterschied ist minimal und hat keinen Einfluss auf die Ergebnisse.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff8/c4a/8fa/ff8c4a8fa103b9592941c965ad060729.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie Sie sehen können, war dieser Shader ziemlich einfach neu zu erstellen. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 9. G-Puffer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werde ich einige Details des Gbuffers in The Witcher 3 enthüllen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir gehen davon aus, dass Sie die Grundlagen der verzögerten Schattierung kennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurze Wiederholung: Die Idee des Verschiebens besteht nicht darin, die gesamte fertige Beleuchtung und Beschattung auf einmal zu berechnen, sondern die Berechnungen in zwei Stufen zu unterteilen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im ersten (Geometrie-Durchgang) füllen wir den GBuffer mit Oberflächendaten (Position, Normalen, Spiegelfarbe usw. ...) und im zweiten (Beleuchtungs-Durchgang) kombinieren wir alles und berechnen die Beleuchtung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die verzögerte Schattierung ist ein sehr beliebter Ansatz, da Sie mit einem einzigen Vollbilddurchlauf Techniken wie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verzögerte Schattierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Kacheln</font></a><font style="vertical-align: inherit;"> berechnen können </font><font style="vertical-align: inherit;">, wodurch die Leistung erheblich verbessert wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfach ausgedrückt ist GBuffer eine Reihe von Texturen mit Geometrieeigenschaften. </font><font style="vertical-align: inherit;">Es ist sehr wichtig, die richtige Struktur dafür zu schaffen. </font><font style="vertical-align: inherit;">Als Beispiel aus dem wirklichen Leben können Sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crysis 3-Rendering-Technologie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> studieren </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns nach dieser kurzen Einführung einen Beispielrahmen aus The Witcher 3 an: Blood and Wine:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/6f5/537/2c36f5537e82217c31d0f5f682b17b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eines der vielen Hotels in Toussent</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basic GBuffer besteht aus drei Vollbild-Renderzielen im Format DXGI_FORMAT_R8G8B8A8_UNORM und einem Tiefen- + Schablonenpuffer im Format DXGI_FORMAT_D24_UNORM_S8_UINT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind ihre Screenshots:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/dec/857/309dec857a7839f41984b44ff82516ab.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderziel 0 - RGB-Kanäle, Oberflächenfarbe</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/44c/b90/16c44cb90b067cb420d921e101319bb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderziel 0 - Alpha-Kanal. </font><font style="vertical-align: inherit;">Ehrlich gesagt habe ich keine Ahnung, was diese Informationen sind.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/f1a/cf3/de9f1acf36c9f9e18ec6f4a9708ede11.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderziel 1 - RGB-Kanäle. </font><font style="vertical-align: inherit;">Hier werden die Normalenvektoren im Intervall [0-1] aufgezeichnet.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/a60/1e8/0a5a601e893d88a619b94f1ed7d21ae2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderziel 1 - Alpha-Kanal. </font><font style="vertical-align: inherit;">Sieht aus wie Reflektivität!</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fa/8f5/d61/7fa8f5d61cfc903b764eec1e9b46c431.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderziel 2 - RGB-Kanäle. </font><font style="vertical-align: inherit;">Sieht aus wie Spiegelfarbe! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Szene ist der Alphakanal schwarz (wird aber später verwendet).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/27d/dab/e7e27ddab2102174b3f63bb9037e28a0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puffertiefen. </font><font style="vertical-align: inherit;">Beachten Sie, dass hier die invertierte Tiefe verwendet wird.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/77d/daa/e4e77ddaa01705381f956410f546fdf4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schablonenpuffer zum Markieren eines bestimmten</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixeltyps </font><i><font style="vertical-align: inherit;">(z. B. Haut, Vegetation usw.)</font></i><font style="vertical-align: inherit;"> Dies ist nicht der gesamte GB-Puffer. </font><font style="vertical-align: inherit;">Der Beleuchtungspass verwendet auch Beleuchtungssonden und andere Puffer, aber ich werde sie in diesem Artikel nicht diskutieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor ich zum "Hauptteil" des Beitrags übergehe, werde ich allgemeine Bemerkungen machen:</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Allgemeine Beobachtungen </font></font></h3><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Der einzige zu reinigende Puffer ist der Tiefen- / Schablonenpuffer.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie die oben genannten Texturen in einem guten Frame-Analysator analysieren, werden Sie ein wenig überrascht sein, da sie den Aufruf „Löschen“ mit Ausnahme von Tiefe / Schablone nicht verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das heißt, in Wirklichkeit sieht RenderTarget1 so aus (beachten Sie die „verschwommenen“ Pixel auf der anderen Ebene):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/16a/3a7/22a16a3a7df971c2d1609f15e254cd06.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine einfache und intelligente Optimierung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine wichtige Lektion: </font><font style="vertical-align: inherit;">Sie müssen Ressourcen </font><font style="vertical-align: inherit;">für </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClearRenderTargetView-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufrufe </font><font style="vertical-align: inherit;">ausgeben. Verwenden Sie sie daher nur bei Bedarf. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Inverted Tiefe - es ist kühl</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vielen </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikeln </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bereits </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über die Genauigkeit des Tiefenpuffers mit Gleitkomma. Hexer 3 verwendet umgekehrt-z. Dies ist die natürliche Wahl für ein solches Open-World-Spiel mit langen Rendering-Entfernungen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wechsel zu DirectX wird nicht schwierig sein: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Wir löschen den Tiefenpuffer, indem wir "0" und nicht "1" schreiben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim traditionellen Ansatz wurde der Fernwert „1“ verwendet, um den Tiefenpuffer zu löschen. Nach dem Tiefenwechsel wurde der neue "entfernte" Wert 0, sodass Sie alles ändern müssen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Vertauschen Sie bei der Berechnung der Projektionsmatrix die nahen und fernen Grenzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Ändern Sie die Tiefenprüfung von „weniger“ auf „mehr“. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei OpenGL muss etwas mehr Arbeit geleistet werden (siehe die oben genannten Artikel), aber es lohnt sich. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Wir behalten unsere Position in der Welt nicht bei.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ja, alles ist so einfach. </font><font style="vertical-align: inherit;">Im Durchgang der Beleuchtung schaffen wir aus den Tiefen eine Position in der Welt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil wollte ich genau den Pixel-Shader zeigen, der GBuffer Oberflächendaten liefert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt wissen wir also bereits, wie man Farben, Normalen und Spiegelbilder speichert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich ist nicht alles so einfach, wie Sie vielleicht denken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem mit dem Pixel-Shader ist, dass er viele Optionen hat. </font><font style="vertical-align: inherit;">Sie unterscheiden sich in der Anzahl der auf sie übertragenen Texturen und der Anzahl der aus dem konstanten Puffer verwendeten Parameter (wahrscheinlich aus dem das Material beschreibenden konstanten Puffer). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für die Analyse habe ich mich für dieses schöne Fass entschieden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/635/aa0/262635aa0a42dde5353586c867bc91d1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser heldenhaftes Fass! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte begrüßen Sie die Texturen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/fde/9bb/9e4fde9bbe2ebcc3c1088eff5e3ea40d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben also Albedo, eine normale Karte und eine spiegelnde Farbe. Ziemlich normaler Fall. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir beginnen, ein paar Worte zur Geometrieeingabe: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geometrie wird mit Positions-, Texkoordinaten-, Normal- und Tangentenpuffern übertragen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Vertex-Shader gibt </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mindestens</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texcoords, normalisierte Tangenten- / Normal- / Tangentenvektoren, an zwei Punkte aus, die zuvor mit der Weltmatrix multipliziert wurden. Bei komplexeren Materialien (z. B. mit zwei diffusen Karten oder zwei normalen Karten) kann der Vertex-Shader andere Daten ausgeben, aber ich wollte hier ein einfaches Beispiel zeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel-Shader im Assembler-Code: Ein </font><font style="vertical-align: inherit;">Shader besteht aus mehreren Schritten. Ich werde jeden Hauptteil dieses Shaders separat beschreiben.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[3], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t2 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 3 <br> 0: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, v1.xyxx, t1.xyzw, s0 <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t0.xyzw, s0 <br> 2: add r1.w, r1.y, r1.x <br> 3: add r1.w, r1.z, r1.w <br> 4: mul r2.x, r1.w, l(0.333300) <br> 5: add r2.y, l(-1.000000), cb4[1].x <br> 6: mul r2.y, r2.y, l(0.500000) <br> 7: mov_sat r2.z, r2.y <br> 8: mad r1.w, r1.w, l(-0.666600), l(1.000000) <br> 9: mad r1.w, r2.z, r1.w, r2.x <br> 10: mul r2.xzw, r1.xxyz, cb4[0].xxyz <br> 11: mul_sat r2.xzw, r2.xxzw, l(1.500000, 0.000000, 1.500000, 1.500000) <br> 12: mul_sat r1.w, abs(r2.y), r1.w <br> 13: add r2.xyz, -r1.xyzx, r2.xzwx <br> 14: mad r1.xyz, r1.wwww, r2.xyzx, r1.xyzx <br> 15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx <br> 21: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r1.xyz, v3.xyzx, r0.xxxx, r1.xyzx <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r1.xyzx <br> 28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w <br> 46: dp3 r0.w, r0.xyzx, r0.xyzx <br> 47: rsq r0.w, r0.w <br> 48: mul r0.xyz, r0.wwww, r0.xyzx <br> 49: max r0.w, abs(r0.y), abs(r0.x) <br> 50: max r0.w, r0.w, abs(r0.z) <br> 51: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 52: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 53: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 54: lt r1.z, r1.y, r1.x <br> 55: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 56: div r1.z, r1.y, r1.x <br> 57: div r0.xyz, r0.xyzx, r0.wwww <br> 58: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 59: mul r0.xyz, r0.wwww, r0.xyzx <br> 60: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 61: mov o0.w, cb4[2].x <br> 62: mov o2.w, l(0) <br> 63: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aber zuerst wie gewohnt - ein Screenshot mit den Werten aus dem konstanten Puffer: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e94/24c/abb/e9424cabbd31630a47b7489e0e32c6af.jpg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Albedo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden mit komplexen Dingen beginnen. </font><font style="vertical-align: inherit;">Es ist nicht nur </font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"OutputColor.rgb = Texture.Sample (uv) .rgb".</font></font></strike> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach dem Abtasten der RGB- </font><strike><font style="vertical-align: inherit;">Farbtextur</font></strike><font style="vertical-align: inherit;"> (Zeile 1) werden die nächsten 14 Zeilen als "Sättigungsreduzierungspuffer" bezeichnet. </font><font style="vertical-align: inherit;">Lassen Sie mich Ihnen den HLSL-Code zeigen: </font><font style="vertical-align: inherit;">Bei den meisten Objekten gibt dieser Code nur die ursprüngliche Farbe aus der Textur zurück. </font><font style="vertical-align: inherit;">Dies wird durch die entsprechenden Werte des „Materialpuffers“ erreicht. </font><font style="vertical-align: inherit;">cb4_v1.x hat den Wert 1.0, der eine Maske von 0.0 und die Eingabefarbe aus der </font><i><font style="vertical-align: inherit;">Lerp-</font></i><font style="vertical-align: inherit;"> Anweisung </font><i><font style="vertical-align: inherit;">zurückgibt</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es gibt jedoch einige Ausnahmen. </font><font style="vertical-align: inherit;">Der größte </font><i><font style="vertical-align: inherit;">Entsättigungsfaktor, den</font></i><font style="vertical-align: inherit;"> ich </font><i><font style="vertical-align: inherit;">gefunden habe,</font></i><font style="vertical-align: inherit;"> ist 4.0 (er ist nie kleiner als 1.0) und </font><i><font style="vertical-align: inherit;">desaturatedColor</font></i></font><br><br> <code>float3 albedoColorFilter( in float3 color, in float desaturationFactor, in float3 desaturationValue ) <br> { <br> float sumColorComponents = color.r + color.g + color.b; <br> <br> float averageColorComponentValue = 0.3333 * sumColorComponents; <br> float oneMinusAverageColorComponentValue = 1.0 - averageColorComponentValue; <br> <br> float factor = 0.5 * (desaturationFactor - 1.0); <br> <br> float avgColorComponent = lerp(averageColorComponentValue, oneMinusAverageColorComponentValue, saturate(factor)); <br> float3 desaturatedColor = saturate(color * desaturationValue * 1.5); <br> <br> float mask = saturate( avgColorComponent * abs(factor) ); <br> <br> float3 finalColor = lerp( color, desaturatedColor, mask ); <br> return finalColor; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommt auf das Material an. </font><font style="vertical-align: inherit;">Es kann so etwas wie (0,2, 0,3, 0,4) sein; </font><font style="vertical-align: inherit;">Es gibt keine strengen Regeln. </font><font style="vertical-align: inherit;">Natürlich, ich konnte nicht helfen , </font><font style="vertical-align: inherit;">aber weiß , </font><font style="vertical-align: inherit;">das in seinem eigenen DX11-Rahmen, und hier sind die Ergebnisse, wo alle der Werte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturatedColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleich float3 (0,25, 0,3, 0,45)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12f/184/2d9/12f1842d9d272fc057f35bc73439c4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entsättigungsfaktor = 1,0 (hat keine Wirkung)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/ead/3a3/03cead3a3d5a713e051e7d863d99ecb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entsättigungsfaktor = 2,0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caf/c81/992/cafc81992ebb70914c1e9d6605b8ba17.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entsättigungsfaktor = 3,0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f37/193/7fb/f371937fb39f94a887410a951f9eb628.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 4.0</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich bin sicher, dass dies nur eine Anwendung von Materialparametern ist, aber nicht am Ende des Albedo-Teils durchgeführt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zeilen 15 bis 20 fügen den letzten Schliff hinzu: </font><font style="vertical-align: inherit;">v0.z ist die Ausgabe des Vertex-Shaders und sie sind Null. </font><font style="vertical-align: inherit;">Vergessen Sie es nicht, denn v0.z wird später einige Male verwendet. </font><font style="vertical-align: inherit;">Es scheint, als wäre es eine Art Koeffizient, und der gesamte Code sieht aus wie eine kleine Dimmalbedo, aber da v0.z 0 ist, bleibt die Farbe unverändert. </font><font style="vertical-align: inherit;">HLSL: </font><font style="vertical-align: inherit;">In Bezug auf RT0.a wird es, wie wir sehen können, aus dem Materialkonstantenpuffer entnommen, aber da der Shader keine Debugging-Informationen hat, ist es schwer zu sagen, was es ist. </font><font style="vertical-align: inherit;">Vielleicht Transluzenz? </font><font style="vertical-align: inherit;">Wir sind mit dem ersten Renderziel fertig!</font></font><br><br> <code>15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* ALBEDO */ <br> //     (?) <br> float3 albedoColor = albedoColorFilter( colorTex, cb4_v1.x, cb4_v0.rgb ); <br> float albedoMaxComponent = getMaxComponent( albedoColor ); <br> <br> //   ,   <br> //       "paramZ"   0 <br> float paramZ = Input.out0.z; // ,    0 <br> <br> // ,  0.70  0.85      <br> //       lerp,     . <br> float param = (albedoMaxComponent &gt; 0.22) ? 0.70 : 0.85; <br> float mulParam = lerp(1, param, paramZ); <br> <br> //  <br> pout.RT0.rgb = albedoColor * mulParam; <br> pout.RT0.a = cb4_v2.x;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem Auspacken der normalen Karte und binden dann wie üblich die Normalen: </font><font style="vertical-align: inherit;">Bisher nichts Überraschendes. </font><i><font style="vertical-align: inherit;">Schauen Sie sich die Zeilen 28-33 an:</font></i><font style="vertical-align: inherit;"> Wir können sie grob wie folgt schreiben: </font><font style="vertical-align: inherit;">Nicht sicher, ob das Schreiben korrekt ist. </font><font style="vertical-align: inherit;">Wenn Sie wissen, was diese mathematische Operation ist, lassen Sie es mich wissen. </font><font style="vertical-align: inherit;">Wir sehen, dass der Pixel-Shader SV_IsFrontFace verwendet.</font></font><br><br> <code>/*  */ <br> float3 sampledNormal = ((normalTex.xyz - 0.5) * 2); <br> <br> //     TBN <br> float3 Tangent = Input.TangentW.xyz; <br> float3 Normal = Input.NormalW.xyz; <br> float3 Bitangent; <br> Bitangent.x = Input.out0.w; <br> Bitangent.yz = Input.out1.zw; <br> <br> //      ;  ,  ,   normal-tbn <br> //      'mad'   'mov' <br> Bitangent = saturate(Bitangent); <br> <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> float3 normal = mul( sampledNormal, TBN );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <i><font style="vertical-align: inherit;"></font></i> <br><br> <code>28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>[branch] if (bIsFrontFace &lt;= 0) <br> { <br> float cosTheta = dot(Input.NormalW, normal); <br> float3 invNormal = cosTheta * Input.NormalW; <br> normal = normal - 2*invNormal; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br>  Was ist das?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hilft </font><font style="vertical-align: inherit;">mir (ich wollte "msdn" schreiben, aber ...):</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legt fest, ob das Dreieck auf die Kamera schaut. </font><font style="vertical-align: inherit;">Für Linien und Punkte gilt IsFrontFace. </font><font style="vertical-align: inherit;">Eine Ausnahme bilden die aus Dreiecken gezogenen Linien (Drahtgittermodus), die IsFrontFace ähnlich wie das Rasteren eines Dreiecks im durchgezogenen Modus festlegen. </font><font style="vertical-align: inherit;">Das Schreiben darauf kann von einem Geometrie-Shader und das Lesen von einem Pixel-Shader erfolgen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wollte es selbst ausprobieren. </font><font style="vertical-align: inherit;">Tatsächlich macht sich der Effekt nur im Drahtgittermodus bemerkbar. </font><font style="vertical-align: inherit;">Ich glaube, dieser Code wird für die korrekte Berechnung von Normalen (und damit der Beleuchtung) im Drahtgittermodus benötigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ein Vergleich: Sowohl die Farben des Rahmens der fertigen Szene mit diesem Trick ein / aus als auch die Textur der gbuffer [0-1] -Normalen mit dem Trick ein / aus:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/46b/81b/59846b81b8b9ed57f0441f29e22e6656.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Szenenfarbe ohne Spielerei</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/590/7e1/a97/5907e1a978e58b6fa362ef2e4b6187a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbszene mit Stunt</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/09a/c0e/74509ac0e56fa639ec4ae2d70a39be44.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal [0-1] kein Trick</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/2f8/622/db82f86223182135807d316fe479ff08.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal [0-1] mit einem Trick</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Haben Sie bemerkt, dass jedes Renderziel in GBuffer das Format R8G8B8A8_UNORM hat? Dies bedeutet, dass es 256 mögliche Werte pro Komponente gibt. Reicht das aus, um Normalen zu speichern? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Speichern hochwertiger Normalen mit genügend Bytes in Gbuffer ist ein bekanntes Problem, aber zum Glück gibt es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viele </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verschiedene </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materialien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aus denen man </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lernen kann</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht wissen einige von Ihnen bereits, welche Technik hier verwendet wird. Ich muss sagen, dass im gesamten Durchgang der Geometrie eine zusätzliche Textur an Steckplatz 13 angebracht ist ...:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/e4a/0bf/ab1e4a0bf128bfed8837d3cd081748f8.jpg"></div><br><br>  Ha!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Witcher 3 verwendet eine Technik namens " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Best Fit Normals</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Hier werde ich es nicht im Detail erklären (siehe Präsentation). </font><font style="vertical-align: inherit;">Es wurde zwischen 2009 und 2010 von Crytek erfunden. Da CryEngine Open Source hat, ist BFN auch </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open Source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFN verleiht der Textur der Normalen ein "körniges" Aussehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Normalen mit BFN skaliert haben, codieren wir sie vom Intervall [-1; 1] bis [0, 1] neu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiegel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit Zeile 34 und probieren Sie die Spiegelstruktur aus: </font><font style="vertical-align: inherit;">Wie Sie sehen, gibt es einen Dimmfilter, den wir von Albedo kennen: Wir </font><font style="vertical-align: inherit;">berechnen die Komponente mit max. </font><font style="vertical-align: inherit;">Wert, und berechnen Sie dann die „abgedunkelte“ Farbe und interpolieren Sie sie mit der ursprünglichen Spiegelfarbe, wobei Sie den Parameter aus dem Vertex-Shader nehmen ... der 0 ist. Bei der Ausgabe erhalten wir also die Farbe aus der Textur. </font><font style="vertical-align: inherit;">HLSL:</font></font><br><br> <code>34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* SPECULAR */ <br> float3 specularTex = texture2.Sample( samplerAnisoWrap, Texcoords ).rgb; <br> <br> //   ,    Albedo.  . ,    <br> // -        "". <br> //      paramZ   0,    <br> //  . <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> float3 specB = (specularMaxComponent &gt; 0.2) ? specularTex : float3(0.12, 0.12, 0.12); <br> float3 finalSpec = lerp(specularTex, specB, paramZ); <br> pout.RT2.xyz = finalSpec;</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reflexionsvermögen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe keine Ahnung, ob dieser Name für diesen Parameter geeignet ist, da ich nicht weiß, wie er den Durchgang der Beleuchtung beeinflusst. </font><font style="vertical-align: inherit;">Tatsache ist, dass der Alpha-Kanal der normalen Eingabekarte zusätzliche Daten enthält:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/9e5/bd1/5d29e5bd1cb4888593139c38630e3f8e.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alpha-Kanal-Textur "normale Karte". </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembler-Code: </font><font style="vertical-align: inherit;">Begrüßen Sie unseren alten Freund - v0.z! </font><font style="vertical-align: inherit;">Seine Bedeutung ist ähnlich wie Albedo und Spiegel:</font></font><br><br> <code>41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>/* REFLECTIVITY */ <br> float reflectivity = normalTex.a; <br> float reflectivity2 = (reflectivity &lt; 0.33) ? (reflectivity * 0.95) : 0.33; <br> <br> float finalReflectivity = lerp(reflectivity, reflectivity2, paramZ); <br> pout.RT1.a = finalReflectivity;</code> <br> <br>  Großartig!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist das Ende der Analyse der ersten Version des Pixel-Shaders. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Vergleich meines Shaders (links) mit dem Original (rechts):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/f18/47b/2c1f1847b5ceef3cd0e2f8dfba45d2a6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Unterschiede wirken sich nicht auf die Berechnungen aus, sodass meine Arbeit hier abgeschlossen ist. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader: Albedo + Normal Option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich beschloss, eine weitere Option anzuzeigen, jetzt nur mit Albedo und normalen Karten, ohne spiegelnde Textur. Der Assembler-Code ist etwas länger: </font><font style="vertical-align: inherit;">Der Unterschied zwischen dieser und den vorherigen Optionen ist wie folgt: </font><font style="vertical-align: inherit;">a) </font><b><font style="vertical-align: inherit;">Zeilen 1, 19</font></b><font style="vertical-align: inherit;"> : Der Interpolationsparameter v0.z wird mit cb4 [0] .x aus dem konstanten Puffer multipliziert, aber dieses Produkt wird nur für die Interpolationsalbedo in Zeile 19 verwendet. Für andere Ausgaben wird der "normale" Wert von v0.z verwendet. </font><font style="vertical-align: inherit;">b) </font><b><font style="vertical-align: inherit;">Zeilen 54-55</font></b><font style="vertical-align: inherit;"> : o2.w wird nun unter der Bedingung gesetzt, dass (cb4 [7] .x&gt; 0.0) </font><font style="vertical-align: inherit;">dieses Muster „eine Art Vergleich - UND“ bereits aus der Berechnung des Helligkeitshistogramms erkennt. Es kann so geschrieben werden: </font><font style="vertical-align: inherit;">c) </font><b><font style="vertical-align: inherit;">Zeilen 34-42</font></b><font style="vertical-align: inherit;"> : eine völlig andere Spiegelberechnung.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 4 <br> 0: mul r0.x, v0.z, cb4[0].x <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyzw, v1.xyxx, t1.xyzw, s0 <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.yzw, v1.xyxx, t0.wxyz, s0 <br> 3: add r2.x, r0.z, r0.y <br> 4: add r2.x, r0.w, r2.x <br> 5: add r2.z, l(-1.000000), cb4[2].x <br> 6: mul r2.yz, r2.xxzx, l(0.000000, 0.333300, 0.500000, 0.000000) <br> 7: mov_sat r2.w, r2.z <br> 8: mad r2.x, r2.x, l(-0.666600), l(1.000000) <br> 9: mad r2.x, r2.w, r2.x, r2.y <br> 10: mul r3.xyz, r0.yzwy, cb4[1].xyzx <br> 11: mul_sat r3.xyz, r3.xyzx, l(1.500000, 1.500000, 1.500000, 0.000000) <br> 12: mul_sat r2.x, abs(r2.z), r2.x <br> 13: add r2.yzw, -r0.yyzw, r3.xxyz <br> 14: mad r0.yzw, r2.xxxx, r2.yyzw, r0.yyzw <br> 15: max r2.x, r0.w, r0.z <br> 16: max r2.x, r0.y, r2.x <br> 17: lt r2.x, l(0.220000), r2.x <br> 18: movc r2.x, r2.x, l(-0.300000), l(-0.150000) <br> 19: mad r0.x, r0.x, r2.x, l(1.000000) <br> 20: mul o0.xyz, r0.xxxx, r0.yzwy <br> 21: add r0.xyz, r1.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r0.xyw, v3.xyxz, r0.xxxx, r1.xyxz <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r0.xywx <br> 28: uge r0.w, l(0), v4.x <br> 29: if_nz r0.w <br> 30: dp3 r0.w, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r0.wwww, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx <br> 43: max r0.w, r1.z, r1.y <br> 44: max r0.w, r0.w, r1.x <br> 45: lt r0.w, l(0.200000), r0.w <br> 46: movc r2.xyz, r0.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 47: add r2.xyz, -r1.xyzx, r2.xyzx <br> 48: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 49: lt r0.w, r1.w, l(0.330000) <br> 50: mul r1.x, r1.w, l(0.950000) <br> 51: movc r0.w, r0.w, r1.x, l(0.330000) <br> 52: add r0.w, -r1.w, r0.w <br> 53: mad o1.w, v0.z, r0.w, r1.w <br> 54: lt r0.w, l(0), cb4[7].x <br> 55: and o2.w, r0.w, l(0.064706) <br> 56: dp3 r0.w, r0.xyzx, r0.xyzx <br> 57: rsq r0.w, r0.w <br> 58: mul r0.xyz, r0.wwww, r0.xyzx <br> 59: max r0.w, abs(r0.y), abs(r0.x) <br> 60: max r0.w, r0.w, abs(r0.z) <br> 61: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 62: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 63: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 64: lt r1.z, r1.y, r1.x <br> 65: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 66: div r1.z, r1.y, r1.x <br> 67: div r0.xyz, r0.xyzx, r0.wwww <br> 68: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 69: mul r0.xyz, r0.wwww, r0.xyzx <br> 70: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 71: mov o0.w, cb4[6].x <br> 72: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>pout.RT2.w = (cb4_v7.x &gt; 0.0) ? (16.5/255.0) : 0.0;</code> <br> <br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier gibt es keine spiegelnde Textur. </font><font style="vertical-align: inherit;">Schauen wir uns den Assembler-Code an, der für diesen Teil verantwortlich ist: </font><font style="vertical-align: inherit;">Beachten Sie, dass wir ihn hier verwendet haben (1 - reflektierte Fähigkeit). </font><font style="vertical-align: inherit;">Glücklicherweise ist das Schreiben in HLSL recht einfach: </font><font style="vertical-align: inherit;">Ich möchte hinzufügen, dass in dieser Version der konstante Puffer mit Materialdaten etwas größer ist. </font><font style="vertical-align: inherit;">Hier werden diese zusätzlichen Werte verwendet, um die Spiegelfarbe zu emulieren. </font><font style="vertical-align: inherit;">Der Rest des Shaders ist der gleiche wie in der vorherigen Version. </font><font style="vertical-align: inherit;">72 Zeilen Assembler-Code sind zu viel, um in WinMerge angezeigt zu werden. Nehmen Sie also mein Wort: Mein Code war fast der gleiche wie im Original. </font><font style="vertical-align: inherit;">Oder Sie können meinen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">und sich selbst davon </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">überzeugen</font></a><font style="vertical-align: inherit;"> !</font></font><br><br> <code>34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>float oneMinusReflectivity = 1.0 - normalTex.a; <br> float3 specularTex = pow(cb4_v3.rgb, 2.2); <br> oneMinusReflectivity = oneMinusReflectivity * cb4_v4.x + cb4_v5.x; <br> specularTex = saturate(specularTex * oneMinusReflectivity); <br> specularTex = pow(specularTex, 1.0/2.2); <br> <br> //     ... <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> ...</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenfassend </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... und wenn Sie es hier lesen, dann möchten Sie wahrscheinlich etwas tiefer gehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was im wirklichen Leben einfach erscheint, ist oft nicht der Fall, und die Datenübertragung zu gbuffer The Witcher 3 war keine Ausnahme. </font><font style="vertical-align: inherit;">Ich habe Ihnen nur die einfachsten Versionen der dafür verantwortlichen Pixel-Shader gezeigt und auch allgemeine Beobachtungen gemacht, die sich auf die verzögerte Schattierung im Allgemeinen beziehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für die meisten Patienten gibt es zwei Optionen für Pixel-Shader im Pastebin: </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option 1 - mit spiegelnder Textur </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option 2 - ohne spiegelnde Textur</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 10. Regenvorhänge in der Ferne </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werden wir einen wunderbaren atmosphärischen Effekt betrachten, den ich wirklich mag - entfernte </font><font style="vertical-align: inherit;">Regen- / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lichtvorhänge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Nähe des Horizonts. </font><font style="vertical-align: inherit;">Im Spiel sind sie auf den Skellig-Inseln am einfachsten zu treffen.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VXt4PEEqV2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich persönlich mag dieses atmosphärische Phänomen sehr und war gespannt, wie die Grafikprogrammierer von CD Projekt Red es implementiert haben. </font><font style="vertical-align: inherit;">Lass es uns herausfinden! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind zwei Screenshots vor und nach dem Anbringen der Regenvorhänge:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/62a/eb6/a9a62aeb6050efd2404f9d352fc89d33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu den Regenvorhängen</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9aa/e43/fcf/9aae43fcf34413a4810778e101b8a209.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach den Vorhängen des Regens</font></font></i> <br><br><h3>  Geometrie </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst konzentrieren wir uns auf die Geometrie. </font><font style="vertical-align: inherit;">Die Idee ist, einen kleinen Zylinder zu verwenden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc4/df3/add/fc4df3addf2524bc18f91c46a42fcd6a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Zylinder im lokalen Raum</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus Sicht seiner Position im lokalen Raum ist er ziemlich klein - seine Position liegt im Bereich (0,0 - 1,0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eingangsschaltung für diesen Draw-Aufruf sieht folgendermaßen aus ...</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1d/a35/c00/c1da35c0080225e7a47d8010c42aeab8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes ist für uns hier wichtig: Texcoords und Instance_Transform. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texcoords werden ganz einfach gewickelt: U der oberen und unteren Basis liegen im Intervall [0.02777 - 1.02734]. V an der unteren Basis ist 1,0 und an der oberen - 0,0. Wie Sie sehen, können Sie dieses Netz ganz einfach auch prozedural erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir diesen kleinen Zylinder im lokalen Raum erhalten haben, multiplizieren wir ihn mit der Weltmatrix, die für jede Instanz des Eingabeelements INSTANCE_TRANSFORM bereitgestellt wird. Lassen Sie uns die Werte dieser Matrix überprüfen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e88/791/17e/e8879117edb6f1dd9b53d3e7334a22df.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adf/fb8/697/adffb8697a86ac86b935a00d6ae23dda.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/608/599/f6c/608599f6cf3930889c92df1a256991af.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sieht ziemlich beängstigend aus, oder? </font><font style="vertical-align: inherit;">Aber keine Sorge, wir werden diese Matrix analysieren und sehen, was sie verbirgt! </font><font style="vertical-align: inherit;">Die Ergebnisse sind sehr interessant: </font><font style="vertical-align: inherit;">Es ist wichtig, die Kameraposition in diesem bestimmten Bild zu kennen: (-116.5338, 234.8695, 2.09) </font><font style="vertical-align: inherit;">Wie Sie sehen können, haben wir den Zylinder so skaliert, dass er im Weltraum ziemlich groß ist (in TW3 ist die Z-Achse nach oben gerichtet) und relativ zur Kameraposition verschoben und drehte sich um. </font><font style="vertical-align: inherit;">So sieht der Zylinder nach der Konvertierung mit dem Vertex-Shader aus:</font></font><br><br> <code>XMMATRIX mat( -227.7472, 159.8043, 374.0736, -116.4951, <br> -194.7577, -173.3836, -494.4982, 238.6908, <br> -14.16466, -185.4743, 784.564, -1.45565, <br> 0.0, 0.0, 0.0, 1.0 ); <br> <br> mat = XMMatrixTranspose( mat ); <br> <br> XMVECTOR vScale; <br> XMVECTOR vRotateQuat; <br> XMVECTOR vTranslation; <br> XMMatrixDecompose( &amp;vScale, &amp;vRotateQuat, &amp;vTranslation, mat ); <br> <br> //  ... <br> XMMATRIX matRotate = XMMatrixRotationQuaternion( vRotateQuat );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>vRotateQuat: (0.0924987569, -0.314900011, 0.883411944, -0.334462732) <br> <br> vScale: (299.999969, 300.000000, 1000.00012) <br> <br> vTranslation: (-116.495102, 238.690796, -1.45564997)</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f60/457/ca6/f60457ca61dd2d15ec3805b387e71def.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zylinder nach Umbau durch Vertex Shader. </font><font style="vertical-align: inherit;">Sehen Sie, wie es sich relativ zur Sichtbarkeitspyramide befindet.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertex-Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingabegeometrie und Vertex-Shader sind streng voneinander abhängig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns den Assembler-Code für den Vertex-Shader genauer an: </font><font style="vertical-align: inherit;">Neben der einfachen Übergabe von Texcoords (Zeile 0) und Instance_LOD_Params (Zeile 8) werden zwei weitere Elemente für die Ausgabe benötigt: SV_Position (dies ist offensichtlich) und Height (Komponente .z) der Position in der Welt. </font><font style="vertical-align: inherit;">Denken Sie daran, dass der lokale Raum im Bereich [0-1] liegt? Kurz vor dem Anwenden der Weltmatrix verwendet der Vertex-Shader Skalierung und Abweichung, um die lokale Position zu ändern. Kluger Schachzug! </font><font style="vertical-align: inherit;">In diesem Fall ist scale = float3 (4, 4, 2) und Bias = float3 (-2, -2, -1). &lt; </font><font style="vertical-align: inherit;">Das Muster, das zwischen den Zeilen 9 und 28 erkennbar ist, ist die Multiplikation zweier Zeilenhauptmatrizen. </font><font style="vertical-align: inherit;">Schauen wir uns nur den fertigen Vertex-Shader in HLSL an:</font></font><br><br> <code>vs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb1[7], immediateIndexed <br> dcl_constantbuffer cb2[6], immediateIndexed <br> dcl_input v0.xyz <br> dcl_input v1.xy <br> dcl_input v4.xyzw <br> dcl_input v5.xyzw <br> dcl_input v6.xyzw <br> dcl_input v7.xyzw <br> dcl_output o0.xyz <br> dcl_output o1.xyzw <br> dcl_output_siv o2.xyzw, position <br> dcl_temps 2 <br> 0: mov o0.xy, v1.xyxx <br> 1: mul r0.xyzw, v5.xyzw, cb1[6].yyyy <br> 2: mad r0.xyzw, v4.xyzw, cb1[6].xxxx, r0.xyzw <br> 3: mad r0.xyzw, v6.xyzw, cb1[6].zzzz, r0.xyzw <br> 4: mad r0.xyzw, cb1[6].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 5: mad r1.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx <br> 6: mov r1.w, l(1.000000) <br> 7: dp4 o0.z, r1.xyzw, r0.xyzw <br> 8: mov o1.xyzw, v7.xyzw <br> 9: mul r0.xyzw, v5.xyzw, cb1[0].yyyy <br> 10: mad r0.xyzw, v4.xyzw, cb1[0].xxxx, r0.xyzw <br> 11: mad r0.xyzw, v6.xyzw, cb1[0].zzzz, r0.xyzw <br> 12: mad r0.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 13: dp4 o2.x, r1.xyzw, r0.xyzw <br> 14: mul r0.xyzw, v5.xyzw, cb1[1].yyyy <br> 15: mad r0.xyzw, v4.xyzw, cb1[1].xxxx, r0.xyzw <br> 16: mad r0.xyzw, v6.xyzw, cb1[1].zzzz, r0.xyzw <br> 17: mad r0.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 18: dp4 o2.y, r1.xyzw, r0.xyzw <br> 19: mul r0.xyzw, v5.xyzw, cb1[2].yyyy <br> 20: mad r0.xyzw, v4.xyzw, cb1[2].xxxx, r0.xyzw <br> 21: mad r0.xyzw, v6.xyzw, cb1[2].zzzz, r0.xyzw <br> 22: mad r0.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 23: dp4 o2.z, r1.xyzw, r0.xyzw <br> 24: mul r0.xyzw, v5.xyzw, cb1[3].yyyy <br> 25: mad r0.xyzw, v4.xyzw, cb1[3].xxxx, r0.xyzw <br> 26: mad r0.xyzw, v6.xyzw, cb1[3].zzzz, r0.xyzw <br> 27: mad r0.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 28: dp4 o2.w, r1.xyzw, r0.xyzw <br> 29: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>cbuffer cbPerFrame : register (b1) <br> { <br> row_major float4x4 g_viewProjMatrix; <br> row_major float4x4 g_rainShaftsViewProjMatrix; <br> } <br> <br> cbuffer cbPerObject : register (b2) <br> { <br> float4x4 g_mtxWorld; <br> float4 g_modelScale; <br> float4 g_modelBias; <br> } <br> <br> struct VS_INPUT <br> { <br> float3 PositionW : POSITION; <br> float2 Texcoord : TEXCOORD; <br> float3 NormalW : NORMAL; <br> float3 TangentW : TANGENT; <br> float4 InstanceTransform0 : INSTANCE_TRANSFORM0; <br> float4 InstanceTransform1 : INSTANCE_TRANSFORM1; <br> float4 InstanceTransform2 : INSTANCE_TRANSFORM2; <br> float4 InstanceLODParams : INSTANCE_LOD_PARAMS; <br> }; <br> <br> struct VS_OUTPUT <br> { <br> float3 TexcoordAndZ : Texcoord0; <br> <br> float4 LODParams : LODParams; <br> float4 PositionH : SV_Position; <br> }; <br> <br> VS_OUTPUT RainShaftsVS( VS_INPUT Input ) <br> { <br> VS_OUTPUT Output = (VS_OUTPUT)0; <br> <br> //    <br> Output.TexcoordAndZ.xy = Input.Texcoord; <br> Output.LODParams = Input.InstanceLODParams; <br> <br> //   <br> float3 meshScale = g_modelScale.xyz; // float3( 4, 4, 2 ); <br> float3 meshBias = g_modelBias.xyz; // float3( -2, -2, -1 ); <br> float3 PositionL = Input.PositionW * meshScale + meshBias; <br> <br> //    instanceWorld  float4s: <br> float4x4 matInstanceWorld = float4x4(Input.InstanceTransform0, Input.InstanceTransform1, <br> Input.InstanceTransform2 , float4(0, 0, 0, 1) ); <br> <br> //     (.z) <br> float4x4 matWorldInstanceLod = mul( g_rainShaftsViewProjMatrix, matInstanceWorld ); <br> Output.TexcoordAndZ.z = mul( float4(PositionL, 1.0), transpose(matWorldInstanceLod) ).z; <br> <br> // SV_Posiiton <br> float4x4 matModelViewProjection = mul(g_viewProjMatrix, matInstanceWorld ); <br> Output.PositionH = mul( float4(PositionL, 1.0), transpose(matModelViewProjection) ); <br> <br> return Output; <br> }</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergleich meines Shaders (links) und des Originals (rechts): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef3/4f3/4ed/ef34f34edbc63113a08f47b7cde00df0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiede wirken sich nicht auf Berechnungen aus. </font><font style="vertical-align: inherit;">Ich habe meinen Shader in den Rahmen gespritzt und alles war noch in Ordnung!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader </font></font></h3><br>  Endlich!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu Beginn zeige ich Ihnen die Eingabe: Hier werden </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei Texturen verwendet: die Rauschtextur und der Tiefenpuffer:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83a/558/fc3/83a558fc3c8c7e723eb85308b12657d6.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/0da/111/db50da111880f6b934d8bed6b74491e6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werte aus konstanten Puffern: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a12/394/bdc/a12394bdc039e522beeff97b8e41cd80.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37a/c47/485/37ac47485335960b2efbefc9f315ef14.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/e70/38a/4e7e7038a1bc956aadbb695d70b80ded.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/775/bc4/7ae775bc4a9388feceaa1ddf8c0a214a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und der Pixel-Shader-Assembler-Code: </font><font style="vertical-align: inherit;">Wow! Ziemlich viel, aber in der Tat ist nicht alles so schlecht. </font><font style="vertical-align: inherit;">Was ist hier los? Zunächst berechnen wir animierte UVs anhand der verstrichenen Zeit aus cbuffer (cb0 [0] .x) und scale / offset. Diese Texcoords werden zum Abtasten aus der Rauschtextur verwendet (Zeile 2). </font><font style="vertical-align: inherit;">Nachdem wir den Rauschwert von der Textur erhalten haben, interpolieren wir zwischen den Min / Max-Werten (normalerweise 0 und 1). </font><font style="vertical-align: inherit;">Dann multiplizieren wir zum Beispiel mit der Koordinate der Textur V (denken Sie daran, dass die Koordinate V von 1 nach 0 geht?) - Zeile 5. </font><font style="vertical-align: inherit;">So haben wir die „Helligkeitsmaske“ berechnet - es sieht so aus:</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[8], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s15, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t15 <br> dcl_input_ps linear v0.xyz <br> dcl_input_ps linear v1.w <br> dcl_input_ps_siv v2.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 1 <br> 0: mul r0.xy, cb0[0].xxxx, cb4[5].xyxx <br> 1: mad r0.xy, v0.xyxx, cb4[4].xyxx, r0.xyxx <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t0.xyzw, s0 <br> 3: add r0.y, -cb4[2].x, cb4[3].x <br> 4: mad_sat r0.x, r0.x, r0.y, cb4[2].x <br> 5: mul r0.x, r0.x, v0.y <br> 6: mul r0.x, r0.x, v1.w <br> 7: mul r0.x, r0.x, cb4[1].x <br> 8: mul r0.yz, v2.xxyx, cb0[1].zzwz <br> 9: sample_l(texture2d)(float,float,float,float) r0.y, r0.yzyy, t15.yxzw, s15, l(0) <br> 10: mad r0.y, r0.y, cb12[22].x, cb12[22].y <br> 11: mad r0.y, r0.y, cb12[21].x, cb12[21].y <br> 12: max r0.y, r0.y, l(0.000100) <br> 13: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 14: add r0.y, r0.y, -v0.z <br> 15: mul_sat r0.y, r0.y, cb4[6].x <br> 16: mul_sat r0.x, r0.y, r0.x <br> 17: mad r0.y, cb0[7].y, r0.x, -r0.x <br> 18: mad r0.x, cb4[7].x, r0.y, r0.x <br> 19: mul r0.xyz, r0.xxxx, cb4[0].xyzx <br> 20: log r0.xyz, r0.xyzx <br> 21: mul r0.xyz, r0.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 22: exp r0.xyz, r0.xyzx <br> 23: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 24: mul o0.xyz, r0.xyzx, cb2[2].wwww <br> 25: mov o0.w, l(0) <br> 26: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/1a8/801/0641a88012fb6ec18797c0b143fb5f27.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass entfernte Objekte (ein Leuchtturm, Berge ...) verschwunden sind. </font><font style="vertical-align: inherit;">Dies geschah, weil der Zylinder den Tiefentest besteht - der Zylinder befindet sich nicht in der Fernebene und wird auf diese Objekte gezeichnet:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/8f5/ffd/1068f5ffde6b0efba2c4894b88d5ddf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefentest</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir möchten simulieren, dass der Regenvorhang weiter entfernt ist (aber nicht unbedingt auf der anderen Ebene). </font><font style="vertical-align: inherit;">Dazu berechnen wir eine andere Maske, die "Maske entfernter Objekte". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird nach folgender Formel berechnet: </font></font><br><br> <code>farObjectsMask = saturate( (FrustumDepth - CylinderWorldSpaceHeight) * 0.001 );</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0,001 wird aus dem Puffer entnommen), wodurch wir die gewünschte Maske erhalten:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/02a/153/9ff02a1534054fb27b370d5cd58e7a75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(In dem Teil über den Schärfeeffekt habe ich bereits oberflächlich erklärt, wie die Tiefe der Sichtbarkeitspyramide aus dem Tiefenpuffer extrahiert wird.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persönlich scheint es mir, dass dieser Effekt kostengünstiger realisiert werden könnte, ohne die Höhe im Weltraum zu berechnen, indem beispielsweise die Tiefe der Sichtbarkeitspyramide mit einer kleineren Zahl multipliziert wird 0,0004. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn beide Masken multipliziert werden, erhält man die letzte:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c49/fb2/c1e/c49fb2c1e1dd2ee8d38d81c0cccb0daf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir diese endgültige Maske erhalten haben (Zeile 16), führen wir eine weitere Interpolation durch, die (zumindest im getesteten Fall) fast nichts bewirkt, multiplizieren dann die endgültige Maske mit der Farbe der Vorhänge (Zeile 19) und führen eine Gammakorrektur durch (Zeilen 20) -22) und endgültige Multiplikationen (23-24). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende geben wir eine Farbe mit einem Alpha-Wert von Null zurück. Dies liegt daran, dass das Mischen in diesem Durchgang aktiviert ist: </font></font><br><br> <code>FinalColor = SourceColor * 1.0 + (1.0 - SourceAlpha) * DestColor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie nicht </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genau </font><font style="vertical-align: inherit;">verstehen, wie das Mischen funktioniert, finden Sie hier eine kurze Erklärung: </font><font style="vertical-align: inherit;">SourceColor ist die RGB-Ausgabe des Pixel-Shaders und DestColor ist die aktuelle RGB-Farbe des Pixels im Renderziel . Da SourceAlpha immer auf 0,0 gleich, reduziert sich </font><font style="vertical-align: inherit;">die obige Gleichung zu: </font></font><code>FinalColor = SourceColor + DestColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfach ausgedrückt, hier führen wir ein additives Mischen durch. </font><font style="vertical-align: inherit;">Wenn der Pixel-Shader zurückkehrt (0, 0, 0), bleibt die Farbe gleich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist der fertige HLSL-Code - ich denke, dass es nach der Erklärung viel einfacher zu verstehen sein wird: </font><font style="vertical-align: inherit;">Ich kann glücklich sagen, dass mein Pixel-Shader den gleichen Assembler-Code wie im Original erstellt. </font><font style="vertical-align: inherit;">Ich hoffe dir hat der Artikel gefallen. </font><font style="vertical-align: inherit;">Danke fürs Lesen!</font></font><br><br> <code>struct VS_OUTPUT <br> { <br> float3 TexcoordAndWorldspaceHeight : Texcoord0; <br> float4 LODParams : LODParams; // float4(1,1,1,1) <br> float4 PositionH : SV_Position; <br> }; <br> <br> float getFrustumDepth( in float depth ) <br> { <br> // from [1-0] to [0-1] <br> float d = depth * cb12_v22.x + cb12_v22.y; <br> <br> // special coefficents <br> d = d * cb12_v21.x + cb12_v21.y; <br> <br> // return frustum depth <br> return 1.0 / max(d, 1e-4); <br> } <br> <br> float4 EditedShaderPS( in VS_OUTPUT Input ) : SV_Target0 <br> { <br> // * Input from Vertex Shader <br> float2 InputUV = Input.TexcoordAndWorldspaceHeight.xy; <br> float WorldHeight = Input.TexcoordAndWorldspaceHeight.z; <br> float LODParam = Input.LODParams.w; <br> <br> // * Inputs <br> float elapsedTime = cb0_v0.x; <br> float2 uvAnimation = cb4_v5.xy; <br> float2 uvScale = cb4_v4.xy; <br> float minValue = cb4_v2.x; // 0.0 <br> float maxValue = cb4_v3.x; // 1.0 <br> float3 shaftsColor = cb4_v0.rgb; // RGB( 147, 162, 173 ) <br> <br> float3 finalColorFilter = cb2_v2.rgb; // float3( 1.175, 1.296, 1.342 ); <br> float finalEffectIntensity = cb2_v2.w; <br> <br> float2 invViewportSize = cb0_v1.zw; <br> <br> float depthScale = cb4_v6.x; // 0.001 <br> <br> // sample noise <br> float2 uvOffsets = elapsedTime * uvAnimation; <br> float2 uv = InputUV * uvScale + uvOffsets; <br> float disturb = texture0.Sample( sampler0, uv ).x; <br> <br> // * Intensity mask <br> float intensity = saturate( lerp(minValue, maxValue, disturb) ); <br> intensity *= InputUV.y; // transition from (0, 1) <br> intensity *= LODParam; // usually 1.0 <br> intensity *= cb4_v1.x; // 1.0 <br> <br> // Sample depth <br> float2 ScreenUV = Input.PositionH.xy * invViewportSize; <br> float hardwareDepth = texture15.SampleLevel( sampler15, ScreenUV, 0 ).x; <br> float frustumDepth = getFrustumDepth( hardwareDepth ); <br> <br> <br> // * Calculate mask covering distant objects behind cylinder. <br> <br> // Seems that the input really is world-space height (.z component, see vertex shader) <br> float depth = frustumDepth - WorldHeight; <br> float distantObjectsMask = saturate( depth * depthScale ); <br> <br> // * calculate final mask <br> float finalEffectMask = saturate( intensity * distantObjectsMask ); <br> <br> // cb0_v7.y and cb4_v7.x are set to 1.0 so I didn't bother with naming them :) <br> float paramX = finalEffectMask; <br> float paramY = cb0_v7.y * finalEffectMask; <br> float effectAmount = lerp(paramX, paramY, cb4_v7.x); <br> <br> // color of shafts comes from contant buffer <br> float3 effectColor = effectAmount * shaftsColor; <br> <br> // gamma correction <br> effectColor = pow(effectColor, 2.2); <br> <br> // final multiplications <br> effectColor *= finalColorFilter; <br> effectColor *= finalEffectIntensity; <br> <br> // return with zero alpha 'cause the blending used here is: <br> // SourceColor * 1.0 + (1.0 - SrcAlpha) * DestColor <br> return float4( effectColor, 0.0 ); <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437100/">https://habr.com/ru/post/de437100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437088/index.html">Förderung eines Startups im Ausland: Wie man mit Medium Hunderttausende englischsprachiger Leser erreicht</a></li>
<li><a href="../de437092/index.html">Die Sicherheit von Algorithmen für maschinelles Lernen. Python-Angriffe</a></li>
<li><a href="../de437094/index.html">Wir haben den Atlassian Service Desk gepumpt - die Ankündigung des Mitaps und der Live-Übertragung</a></li>
<li><a href="../de437096/index.html">UDB. Was ist das Teil 4. Datenpfad ALU</a></li>
<li><a href="../de437098/index.html">6. Februar, Moskau, DI Telegraph - Große QIWI-Küche zum Thema Produktdesign</a></li>
<li><a href="../de437102/index.html">Neues Lego-Champion-Treffen: Lego Boost</a></li>
<li><a href="../de437104/index.html">Introskop: Nun, sehr fauler Unit-Test</a></li>
<li><a href="../de437106/index.html">IT in der Zone .it</a></li>
<li><a href="../de437108/index.html">Die meisten Texte im Internet werden von Verrückten geschrieben.</a></li>
<li><a href="../de437110/index.html">Nanomaterialien verändern unsere Welt, und wir haben immer noch keine Verfahren zur Überprüfung ihrer Sicherheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>