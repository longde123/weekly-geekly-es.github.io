<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî∞ üèπ ü§≥üèΩ Das Reverse Engineering des Renderings von The Witcher 3 üôéüèø üë®üèª‚Äçüíº üéÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der erste Teil der √úbersetzung ist hier . In diesem Teil werden wir √ºber die Auswirkungen von Sch√§rfe, durchschnittlicher Helligkeit, Mondphasen und a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Reverse Engineering des Renderings von The Witcher 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437100/">  Der erste Teil der √úbersetzung ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  In diesem Teil werden wir √ºber die Auswirkungen von Sch√§rfe, durchschnittlicher Helligkeit, Mondphasen und atmosph√§rischen Ph√§nomenen w√§hrend des Regens sprechen. <br><br><h2>  Teil 6. Sch√§rfen </h2><br>  In diesem Teil werden wir uns einen weiteren Nachbearbeitungseffekt von The Witcher 3 - Sharpen genauer ansehen. <br><br>  Durch das Sch√§rfen wird das Ausgabebild etwas sch√§rfer.  Dieser Effekt ist uns aus Photoshop und anderen Grafikeditoren bekannt. <br><br>  In The Witcher 3 hat das Sch√§rfen zwei M√∂glichkeiten: niedrig und hoch.  Ich werde unten auf den Unterschied zwischen ihnen eingehen, aber jetzt schauen wir uns die Screenshots an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/285/1fc/6bc/2851fc6bc19e39660e0307f2775b0322.png" alt="Bild"></div><br>  <i>Option ‚ÄûNiedrig‚Äú - bis zu</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/cd4/4cd/dc2cd44cd83306f2c08bbf7f87831d8c.png" alt="Bild"></div><br>  <i>Option ‚ÄúNiedrig‚Äù - danach</i> <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aad/807/2aa/aad8072aa3977f32549856c0be24206b.png"></div><br>  <i>Hohe Option - bis zu</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/3ce/0f3/b873ce0f320a785f4fb4bc83e9a696f5.png"></div><br>  <i>Option "Hoch" - nach</i> <br><br>  Wenn Sie sich detailliertere (interaktive) Vergleiche ansehen m√∂chten, lesen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt im Nvidia The Witcher 3-Leistungshandbuch</a> .  Wie Sie sehen, macht sich der Effekt besonders bei Gras und Laub bemerkbar. <br><br>  In diesem Teil des Beitrags werden wir den Rahmen von Anfang an studieren: Ich habe ihn absichtlich gew√§hlt, weil wir hier das Relief (lange Zeichenentfernung) und die Kuppel des Himmels sehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/898/e97/895/898e9789593705231157a07ebcf34f5e.png"></div><br>  In Bezug auf die Eingabe erfordert das Sch√§rfen einen Farbpuffer <b>t0</b> (LDR nach Tonkorrektur und Linseneffekten) und einen Tiefenpuffer <b>t1</b> . <br><br>  Lassen Sie uns den Assembler-Code f√ºr den Pixel-Shader untersuchen: <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb3[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_input_ps_siv v0.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 7 <br> 0: ftoi r0.xy, v0.xyxx <br> 1: mov r0.zw, l(0, 0, 0, 0) <br> 2: ld_indexable(texture2d)(float,float,float,float) r0.x, r0.xyzw, t1.xyzw <br> 3: mad r0.x, r0.x, cb12[22].x, cb12[22].y <br> 4: mad r0.y, r0.x, cb12[21].x, cb12[21].y <br> 5: max r0.y, r0.y, l(0.000100) <br> 6: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 7: mad_sat r0.y, r0.y, cb3[1].z, cb3[1].w <br> 8: add r0.z, -cb3[1].x, cb3[1].y <br> 9: mad r0.y, r0.y, r0.z, cb3[1].x <br> 10: add r0.y, r0.y, l(1.000000) <br> 11: ge r0.x, r0.x, l(1.000000) <br> 12: movc r0.x, r0.x, l(0), l(1.000000) <br> 13: mul r0.z, r0.x, r0.y <br> 14: round_z r1.xy, v0.xyxx <br> 15: add r1.xy, r1.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000) <br> 16: div r1.xy, r1.xyxx, cb3[0].zwzz <br> 17: sample_l(texture2d)(float,float,float,float) r2.xyz, r1.xyxx, t0.xyzw, s0, l(0) <br> 18: lt r0.z, l(0), r0.z <br> 19: if_nz r0.z <br> 20: div r3.xy, l(0.500000, 0.500000, 0.000000, 0.000000), cb3[0].zwzz <br> 21: add r0.zw, r1.xxxy, -r3.xxxy <br> 22: sample_l(texture2d)(float,float,float,float) r4.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 23: mov r3.zw, -r3.xxxy <br> 24: add r5.xyzw, r1.xyxy, r3.zyxw <br> 25: sample_l(texture2d)(float,float,float,float) r6.xyz, r5.xyxx, t0.xyzw, s0, l(0) <br> 26: add r4.xyz, r4.xyzx, r6.xyzx <br> 27: sample_l(texture2d)(float,float,float,float) r5.xyz, r5.zwzz, t0.xyzw, s0, l(0) <br> 28: add r4.xyz, r4.xyzx, r5.xyzx <br> 29: add r0.zw, r1.xxxy, r3.xxxy <br> 30: sample_l(texture2d)(float,float,float,float) r1.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 31: add r1.xyz, r1.xyzx, r4.xyzx <br> 32: mul r3.xyz, r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000) <br> 33: mad r1.xyz, -r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000), r2.xyzx <br> 34: max r0.z, abs(r1.z), abs(r1.y) <br> 35: max r0.z, r0.z, abs(r1.x) <br> 36: mad_sat r0.z, r0.z, cb3[2].x, cb3[2].y <br> 37: mad r0.x, r0.y, r0.x, l(-1.000000) <br> 38: mad r0.x, r0.z, r0.x, l(1.000000) <br> 39: dp3 r0.y, l(0.212600, 0.715200, 0.072200, 0.000000), r2.xyzx <br> 40: dp3 r0.z, l(0.212600, 0.715200, 0.072200, 0.000000), r3.xyzx <br> 41: max r0.w, r0.y, l(0.000100) <br> 42: div r1.xyz, r2.xyzx, r0.wwww <br> 43: add r0.y, -r0.z, r0.y <br> 44: mad r0.x, r0.x, r0.y, r0.z <br> 45: max r0.x, r0.x, l(0) <br> 46: mul r2.xyz, r0.xxxx, r1.xyzx <br> 47: endif <br> 48: mov o0.xyz, r2.xyzx <br> 49: mov o0.w, l(1.000000) <br> 50: ret</code> <br> <br>  50 Zeilen Assembler-Code scheinen eine machbare Aufgabe zu sein.  Kommen wir zur L√∂sung. <br><br><h3>  Wertsch√∂pfung sch√§rfen </h3><br>  Der erste Schritt ist das Laden des Tiefenpuffers (Zeile 1).  Es ist erw√§hnenswert, dass der ‚ÄûThe Witcher 3‚Äú eine umgekehrte Tiefe verwendet (1,0 - nah, 0,0 - fern).  Wie Sie vielleicht wissen, ist die Hardwaretiefe nichtlinear gebunden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einzelheiten finden</a> Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> ). <br><br>  Die Zeilen 3-6 bieten eine sehr interessante M√∂glichkeit, diese Hardwaretiefe [1.0 - 0.0] mit [Nah-Fern] -Werten zu verkn√ºpfen (wir setzen sie in der MatrixPerspectiveFov-Phase).  Betrachten Sie die Werte aus dem konstanten Puffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/636/345/52a/63634552ae9daf03f14305c118cccc25.png"></div><br>  Mit dem Wert "close" von 0,2 und dem Wert "far" 5000 k√∂nnen wir die Werte von cb12_v21.xy wie folgt berechnen: <br><br> <code>cb12_v21.y = 1.0 / near <br> cb12_v21.x = - (1.0 / near) + (1.0 / near) * (near / far)</code> <br> <br>  Dieser Code ist in TW3-Shadern weit verbreitet, daher denke ich, dass er nur eine Funktion ist. <br><br>  Nach Erhalt der ‚ÄûTiefe der Sichtbarkeitspyramide‚Äú verwendet Zeile 7 die Skalierung / Verzerrung, um den Interpolationskoeffizienten zu erstellen (hier verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">S√§ttigung</a> , um die Werte auf das Intervall [0-1] zu beschr√§nken). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/efd/571/e89efd5711cb2aa1a3c544e9deda9321.png"></div><br>  cb3_v1.xy und cb3_v2.xy - Dies ist die Helligkeit des Sch√§rfeeffekts bei kurzen und langen Entfernungen.  Nennen wir sie sharpenNear und sharpenFar.  Und dies ist der einzige Unterschied zwischen den Optionen "Niedrig" und "Hoch" dieses Effekts in The Witcher 3. <br><br>  Jetzt ist es Zeit, das resultierende Verh√§ltnis zu verwenden.  Die Zeilen 8-9 f√ºhren nur <code>lerp(sharpenNear, sharpenFar, interpolationCoeff)</code> .  Wof√ºr ist das?  Dank dessen erhalten wir unterschiedliche Helligkeit in der N√§he von Geralt und von ihm weg.  Schauen Sie mal rein: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/233/515/6462335151728759f236b58f14b894dd.png"></div><br>  Vielleicht ist dies kaum wahrnehmbar, aber hier haben wir basierend auf dem Abstand die Sch√§rfehelligkeit neben dem Player (2.177151) interpoliert und die Effekthelligkeit ist sehr weit (1.91303).  Nach dieser Berechnung addieren wir 1,0 zur Helligkeit (Zeile 10).  Warum wird das ben√∂tigt?  Angenommen, die oben gezeigte Operation lerp ergab 0,0.  Nach dem Hinzuf√ºgen von 1.0 erhalten wir nat√ºrlich 1.0, und dies ist ein Wert, der das Pixel beim Sch√§rfen nicht beeinflusst.  Lesen Sie weiter unten mehr dar√ºber. <br><br>  Beim Sch√§rfen m√∂chten wir den Himmel nicht beeinflussen.  Dies kann durch Hinzuf√ºgen einer einfachen bedingten Pr√ºfung erreicht werden: <br><br> <code>//   sharpen   <br> float fSkyboxTest = (fDepth &gt;= 1.0) ? 0 : 1;</code> <br> <br>  In The Witcher 3 betr√§gt der Wert der Pixeltiefe des Himmels 1,0, daher verwenden wir ihn, um eine Art ‚ÄûBin√§rfilter‚Äú zu erhalten (eine interessante Tatsache: In diesem Fall funktioniert der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schritt</a> nicht richtig). <br><br>  Jetzt k√∂nnen wir die interpolierte Helligkeit mit einem ‚ÄûHimmelsfilter‚Äú multiplizieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/ed1/f50/63ced1f5036d9ee63cfe54de6a501bc1.png"></div><br>  Diese Multiplikation wird in Zeile 13 durchgef√ºhrt. <br><br>  Shader-Codebeispiel: <br><br> <code>//    sharpen <br> float fSharpenAmount = fSharpenIntensity * fSkyboxTest;</code> <br> <br><h3>  Pixel Sampling Center </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SV_Position</a> hat einen Aspekt, der hier wichtig sein wird: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen halben</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pixelversatz</a> .  Es stellt sich heraus, dass dieses Pixel in der oberen linken Ecke (0, 0) keine Koordinaten (0, 0) in Bezug auf SV_Position.xy hat, sondern (0,5, 0,5).  Wow! <br><br>  Hier wollen wir ein Beispiel in der Mitte des Pixels nehmen, schauen wir uns also die Zeilen 14-16 an.  Sie k√∂nnen sie in HLSL schreiben: <br><br> <code>//   . <br> //   ""   SV_Position.xy. <br> float2 uvCenter = trunc( Input.Position.xy ); <br> <br> //   ,       <br> uvCenter += float2(0.5, 0.5); <br> uvCenter /= g_Viewport.xy</code> <br> <br>  Und sp√§ter probieren wir die Eingabefarbtextur von texcoords ‚ÄûuvCenter‚Äú aus.  Keine Sorge, das Ergebnis der Stichprobe ist das gleiche wie bei der ‚Äûnormalen‚Äú Methode (SV_Position.xy / ViewportSize.xy). <br><br><h3>  Sch√§rfen oder nicht sch√§rfen </h3><br>  Die Entscheidung, ob Sharpen verwendet werden soll, h√§ngt von fSharpenAmount ab. <br><br> <code>//     <br> float3 colorCenter = TexColorBuffer.SampleLevel( samplerLinearClamp, uvCenter, 0 ).rgb; <br> <br> //   <br> float3 finalColor = colorCenter; <br> <br> if ( fSharpenAmount &gt; 0 ) <br> { <br> //   sharpening... <br> } <br> <br> return float4( finalColor, 1 );</code> <br> <br><h3>  Sch√§rfen </h3><br>  Es ist Zeit, einen Blick auf die Innenseiten des Algorithmus selbst zu werfen. <br><br>  Im Wesentlichen werden die folgenden Aktionen ausgef√ºhrt: <br><br>  - Abtastung der vierfachen Eingabefarbtextur an den Ecken des Pixels, <br><br>  - f√ºgt Stichproben hinzu und berechnet den Durchschnittswert, <br><br>  - berechnet die Differenz zwischen "Mitte" und "Eckdurchschnitt", <br><br>  - findet die maximale absolute Komponente der Differenz, <br><br>  - korrigiert max.  abs.  Komponente unter Verwendung von Skala + Bias-Werten, <br><br>  - bestimmt die St√§rke des Effekts mit max.  abs.  Komponente <br><br>  - berechnet den Helligkeitswert (Luma) f√ºr "centerColor" und "durchschnittlichColor", <br><br>  - teilt colorCenter in seine Luma, <br><br>  - berechnet einen neuen, interpolierten Luma-Wert basierend auf der St√§rke des Effekts, <br><br>  - Multipliziert colorCenter mit dem neuen Luma-Wert. <br><br>  Viel Arbeit, und es war schwierig f√ºr mich, es herauszufinden, weil ich noch nie mit Sch√§rfefiltern experimentiert hatte. <br><br>  Beginnen wir mit dem Stichprobenmuster.  Wie Sie im Assembler-Code sehen k√∂nnen, werden vier Texturlesevorg√§nge durchgef√ºhrt. <br><br>  Dies wird am besten anhand eines Beispiels eines Pixelbilds gezeigt (das K√∂nnen des K√ºnstlers ist <i>ein Experte</i> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e3/d46/5fa/5e3d465fadc0bccd551256c40c6e5368.png"></div><br>  Alle Lesevorg√§nge im Shader verwenden bilineares Sampling (D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT). <br><br>  Der Versatz von der Mitte zu jedem der Winkel betr√§gt (¬± 0,5, ¬± 0,5), abh√§ngig vom Winkel. <br><br>  Sehen Sie, wie dies auf HLSL implementiert werden kann?  Mal sehen: <br><br> <code>float2 uvCorner; <br> float2 uvOffset = float2( 0.5, 0.5 ) / g_Viewport.xy; // remember about division! <br> <br> float3 colorCorners = 0; <br> <br> //    <br> // -0,5, -0.5 <br> uvCorner = uvCenter - uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, -0.5 <br> uvCorner = uvCenter + float2(uvOffset.x, -uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // -0.5, +0.5 <br> uvCorner = uvCenter + float2(-uvOffset.x, uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, +0.5 <br> uvCorner = uvCenter + uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb;</code> <br> <br>  Jetzt sind alle vier Beispiele in der Variablen ‚ÄûcolorCorners‚Äú zusammengefasst.  Befolgen wir diese Schritte: <br><br> <code>//     <br> float3 averageColorCorners = colorCorners / 4.0; <br> <br> //    <br> float3 diffColor = colorCenter - averageColorCorners; <br> <br> //  . . RGB-  <br> float fDiffColorMaxComponent = max( abs(diffColor.x), max( abs(diffColor.y), abs(diffColor.z) ) ); <br> <br> //    <br> float fDiffColorMaxComponentScaled = saturate( fDiffColorMaxComponent * sharpenLumScale + sharpenLumBias ); <br> <br> //     . <br> //   "1.0" -      fSharpenIntensity  1.0. <br> float fPixelSharpenAmount = lerp(1.0, fSharpenAmount, fDiffColorMaxComponentScaled); <br> <br> //   ""     . <br> float lumaCenter = dot( LUMINANCE_RGB, finalColor ); <br> float lumaCornersAverage = dot( LUMINANCE_RGB, averageColorCorners ); <br> <br> //  "centerColor"    <br> float3 fColorBalanced = colorCenter / max( lumaCenter, 1e-4 ); <br> <br> //    <br> float fPixelLuminance = lerp(lumaCornersAverage, lumaCenter, fPixelSharpenAmount); <br> <br> //     <br> finalColor = fColorBalanced * max(fPixelLuminance, 0.0); <br> } <br> <br> return float4(finalColor, 1.0);</code> <br> <br>  Die Kantenerkennung erfolgt durch Berechnung von max.  abs.  Differenzkomponente.  Kluger Schachzug!  Schauen Sie sich die Visualisierung an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/a26/44a/aa9a2644a16b1b79c6213f7d4effe068.jpg"></div><br>  <i>Visualisierung der maximalen absoluten Komponente der Differenz.</i> <br><br>  Gro√üartig.  Der fertige HLSL-Shader ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbar.  Entschuldigung f√ºr die ziemlich schlechte Formatierung.  Sie k√∂nnen mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HLSLexplorer-</a> Programm verwenden und mit dem Code experimentieren. <br><br>  Ich kann gl√ºcklich sagen, dass der obige Code den gleichen Assembler-Code wie im Spiel erzeugt! <br><br>  Zusammenfassend: Der Sch√§rfeshader Witcher 3 ist sehr gut geschrieben (beachten Sie, dass fPixelSharpenAmount gr√∂√üer als 1,0 ist! Dies ist interessant ...).  Dar√ºber hinaus ist die Helligkeit von Nah- / Fernobjekten die Hauptmethode zum √Ñndern der Helligkeit des Effekts.  In diesem Spiel sind sie keine Konstanten;  Ich habe einige Beispiele f√ºr Werte gesammelt: <br><br>  Skellige: <br><br><table><tbody><tr><th></th><th>  sharpenNear </th><th>  sharpenFar </th><th>  sharpenDistanceScale </th><th>  sharpenDistanceBias </th><th>  sharpenLumScale </th><th>  sharpenLumBias </th></tr><tr><td>  <b>niedrig</b> </td></tr></tbody><tbody><tr><td>  <b>hoch</b> </td><td>  2.0 </td><td>  1.8 </td><td>  0,025 <br></td><td>  -0,25 <br></td><td>  -13,333333 <br></td><td>  1,33333 </td></tr></tbody></table><br>  Kaer Morhen: <br><br><table><tbody><tr><th></th><th>  sharpenNear <br></th><th>  sharpenFar <br></th><th>  sharpenDistanceScale <br></th><th>  sharpenDistanceBias <br></th><th>  sharpenLumScale <br></th><th>  sharpenLumBias <br></th></tr><tr><td>  niedrig <br></td><td>  0,57751 <br></td><td>  0,31303 <br></td><td>  0,06665 <br></td><td>  -0,33256 <br></td><td>  -1,0 <br></td><td>  2.0 <br></td></tr><tr><td>  hoch <br></td><td>  2.17751 <br></td><td>  1,91303 <br></td><td>  0,06665 <br></td><td>  -0,33256 <br></td><td>  -1,0 <br></td><td>  2.0 </td></tr></tbody></table><br><h2>  Teil 7. Durchschnittliche Helligkeit </h2><br>  Die Berechnung der durchschnittlichen Helligkeit des aktuellen Frames ist in fast jedem modernen Videospiel m√∂glich.  Dieser Wert wird h√§ufig sp√§ter f√ºr den Effekt der Augenanpassung und Tonwertkorrektur verwendet (siehe im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teil des</a> Beitrags).  In einfachen L√∂sungen wird die Helligkeitsberechnung beispielsweise f√ºr die Textur 512 <sup>2 verwendet</sup> , dann die Berechnung ihrer Mip-Pegel und deren Anwendung.  Dies funktioniert normalerweise, schr√§nkt jedoch die M√∂glichkeiten stark ein.  Bei komplexeren L√∂sungen werden Computer-Shader verwendet, die beispielsweise eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">parallele Reduktion durchf√ºhren</a> . <br><br>  Lassen Sie uns in The Witcher 3 herausfinden, wie das CD Projekt Red-Team dieses Problem gel√∂st hat.  Im vorherigen Teil habe ich bereits die Tonwertkorrektur und Anpassung des Auges untersucht, sodass das einzige verbleibende Puzzleteil die durchschnittliche Helligkeit war. <br><br>  Die durchschnittliche Helligkeitsberechnung von The Witcher 3 besteht zun√§chst aus zwei Durchg√§ngen.  Aus Gr√ºnden der Klarheit habe ich beschlossen, sie in separate Teile zu zerlegen, und zun√§chst betrachten wir den ersten Durchgang - ‚ÄûHelligkeitsverteilung‚Äú (Berechnung des Helligkeitshistogramms). <br><br><h3>  Helligkeitsverteilung </h3><br>  Diese beiden Durchg√§nge sind in jedem Frame-Analysator ziemlich leicht zu finden.  Dies sind die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versandaufrufe</a> in der richtigen Reihenfolge, bevor die Augenanpassung durchgef√ºhrt wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/5fb/09c/7de5fb09ce00453f14262f9e2b1bae30.png"></div><br>  Schauen wir uns die Eingabe f√ºr diesen Durchgang an.  Er braucht zwei Texturen: <br><br>  1) HDR-Farbpuffer, dessen Skalierung auf 1/4 x 1/4 reduziert ist (z. B. von 1920 x 1080 auf 480 x 270), <br><br>  2) Vollbild-Tiefenpuffer <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/021/38b/795/02138b795946d192f553eadc20d34366.png"></div><br>  <i>1/4 x 1/4 HDR-Farbpuffer.</i>  <i>Beachten Sie den kniffligen Trick - dieser Puffer ist Teil eines gr√∂√üeren Puffers.</i>  <i>Das Wiederverwenden von Puffern ist eine gute Praxis.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/62d/c97/0e362dc97908f75db564cff0f46b1e7e.png"></div><br>  <i>Vollbild-Tiefenpuffer</i> <br><br>  Warum den Farbpuffer verkleinern?  Ich denke, es geht nur um Leistung. <br><br>  Die Ausgabe dieses Durchlaufs ist ein strukturierter Puffer.  256 Elemente zu je 4 Bytes. <br><br>  Shader haben hier keine Debugging-Informationen. Nehmen wir also an, es handelt sich nur um einen Puffer mit vorzeichenlosen int-Werten. <br><br>  Wichtig: Der erste Schritt bei der Berechnung der durchschnittlichen Helligkeit ruft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ClearUnorderedAccessViewUint</a> auf, um alle Elemente des strukturierten Puffers auf Null zur√ºckzusetzen. <br><br>  Lassen Sie uns den Assembler-Code des Computer-Shaders untersuchen (dies ist der erste Computer-Shader in unserer gesamten Analyse!) <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[3], immediateIndexed <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_uav_structured u0, 4 <br> dcl_input vThreadGroupID.x <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 6 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: store_structured g0.x, vThreadIDInGroup.x, l(0), l(0) <br> 1: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 2: store_structured g0.x, r0.x, l(0), l(0) <br> 3: store_structured g0.x, r0.y, l(0), l(0) <br> 4: store_structured g0.x, r0.z, l(0), l(0) <br> 5: sync_g_t <br> 6: ftoi r1.x, cb0[2].z <br> 7: mov r2.y, vThreadGroupID.x <br> 8: mov r2.zw, l(0, 0, 0, 0) <br> 9: mov r3.zw, l(0, 0, 0, 0) <br> 10: mov r4.yw, l(0, 0, 0, 0) <br> 11: mov r1.y, l(0) <br> 12: loop <br> 13: utof r1.z, r1.y <br> 14: ge r1.z, r1.z, cb0[0].x <br> 15: breakc_nz r1.z <br> 16: iadd r2.x, r1.y, vThreadIDInGroup.x <br> 17: utof r1.z, r2.x <br> 18: lt r1.z, r1.z, cb0[0].x <br> 19: if_nz r1.z <br> 20: ld_indexable(texture2d)(float,float,float,float) r5.xyz, r2.xyzw, t0.xyzw <br> 21: dp3 r1.z, r5.xyzx, l(0.212600, 0.715200, 0.072200, 0.000000) <br> 22: imul null, r3.xy, r1.xxxx, r2.xyxx <br> 23: ld_indexable(texture2d)(float,float,float,float) r1.w, r3.xyzw, t1.yzwx <br> 24: eq r1.w, r1.w, cb0[2].w <br> 25: and r1.w, r1.w, cb0[2].y <br> 26: add r2.x, -r1.z, cb0[2].x <br> 27: mad r1.z, r1.w, r2.x, r1.z <br> 28: add r1.z, r1.z, l(1.000000) <br> 29: log r1.z, r1.z <br> 30: mul r1.z, r1.z, l(88.722839) <br> 31: ftou r1.z, r1.z <br> 32: umin r4.x, r1.z, l(255) <br> 33: atomic_iadd g0, r4.xyxx, l(1) <br> 34: endif <br> 35: iadd r1.y, r1.y, l(64) <br> 36: endloop <br> 37: sync_g_t <br> 38: ld_structured r1.x, vThreadIDInGroup.x, l(0), g0.xxxx <br> 39: mov r4.z, vThreadIDInGroup.x <br> 40: atomic_iadd u0, r4.zwzz, r1.x <br> 41: ld_structured r1.x, r0.x, l(0), g0.xxxx <br> 42: mov r0.w, l(0) <br> 43: atomic_iadd u0, r0.xwxx, r1.x <br> 44: ld_structured r0.x, r0.y, l(0), g0.xxxx <br> 45: atomic_iadd u0, r0.ywyy, r0.x <br> 46: ld_structured r0.x, r0.z, l(0), g0.xxxx <br> 47: atomic_iadd u0, r0.zwzz, r0.x <br> 48: ret</code> <br> <br>  Und ein konstanter Puffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/805/dc6/c14805dc6b7ffd431d9307cc46dcba0d.png"></div><br>  Wir wissen bereits, dass der erste Eingang ein HDR-Farbpuffer ist.  Bei FullHD betr√§gt die Aufl√∂sung 480 x 270.  Schauen wir uns den Versandaufruf an. <br><br>  Versand (270, 1, 1) - Dies bedeutet, dass 270 Thread-Gruppen ausgef√ºhrt werden.  Einfach ausgedr√ºckt, f√ºhren wir eine Gruppe von Threads pro Zeile des Farbpuffers aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/a97/7e3/e9aa977e3f9a60104fe9a66d797a27cc.png"></div><br>  <i>Jede Thread-Gruppe f√ºhrt eine Zeile HDR-Farbpuffer aus</i> <br><br>  Nachdem wir diesen Kontext haben, versuchen wir herauszufinden, was der Shader tut. <br><br>  Jede Thread-Gruppe hat 64 Threads in X-Richtung (dcl_thread_group 64, 1, 1) sowie gemeinsam genutzten Speicher, 256 Elemente mit jeweils 4 Bytes (dcl_tgsm_structured g0, 4, 256). <br><br>  Beachten Sie, dass wir im Shader <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SV_GroupThreadID</a> (vThreadIDInGroup.x) [0-63] und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SV_GroupID</a> (vThreadGroupID.x) [0-269] verwenden. <br><br>  1) Wir beginnen damit, allen Elementen des gemeinsam genutzten Speichers Nullwerte zuzuweisen.  Da der Gesamtspeicher 256 Elemente und 64 Threads pro Gruppe enth√§lt, kann dies bequem mit einer einfachen Schleife durchgef√ºhrt werden: <br><br> <code>//   -      . <br> //        64 ,          4 . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = 0; <br> }</code> <br> <br>  2) Danach setzen wir die Barriere mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GroupMemoryBarrierWithGroupSync</a> (sync_g_t).  Wir tun dies, um sicherzustellen, dass alle Threads im gemeinsam genutzten Speicher der Gruppen auf Null zur√ºckgesetzt werden, bevor Sie mit dem n√§chsten Schritt fortfahren. <br><br>  3) Jetzt f√ºhren wir eine Schleife aus, die grob wie folgt geschrieben werden kann: <br><br> <code>// cb0_v0.x -      .  1920x1080   1920/4 = 480; <br> float ViewportSizeX = cb0_v0.x; <br> [loop] for ( uint PositionX = 0; PositionX &lt; ViewportSizeX; PositionX += 64 ) <br> { <br> ...</code> <br> <br>  Dies ist eine einfache for-Schleife mit einem Inkrement von 64 (haben Sie bereits verstanden, warum?). <br><br>  Der n√§chste Schritt besteht darin, die Position des geladenen Pixels zu berechnen. <br><br>  Lass uns dar√ºber nachdenken. <br><br>  F√ºr die Y-Koordinate k√∂nnen wir SV_GroupID.x verwenden, da wir 270 Thread-Gruppen gestartet haben. <br><br>  F√ºr die X-Koordinate k√∂nnen wir ... den aktuellen Gruppenfluss nutzen!  Lass es uns versuchen. <br><br>  Da jede Gruppe 64 Threads enth√§lt, werden bei einer solchen L√∂sung alle Pixel umgangen. <br><br>  Betrachten Sie die Thread-Gruppe (0, 0, 0). <br><br>  - Der Stream (0, 0, 0) verarbeitet die Pixel (0, 0), (64, 0), (128, 0), (192, 0), (256, 0), (320, 0), (384, 0), (448,0). <br><br>  - Der Stream (1, 0, 0) verarbeitet die Pixel (1, 0), (65, 0), (129, 0), (193, 0), (257, 0), (321, 0), (385, 0), (449, 0) ... <br><br>  - Der Stream (63, 0, 0) verarbeitet die Pixel (63, 0), (127, 0), (191, 0), (255, 0), (319, 0), (383, 0), (447, 0) <br><br>  Somit werden alle Pixel verarbeitet. <br><br>  Wir m√ºssen auch sicherstellen, dass wir keine Pixel von au√üerhalb des Farbpuffers laden: <br><br> <code>//      X.  Y  GroupID. <br> uint CurrentPixelPositionX = PositionX + threadID; <br> uint CurrentPixelPositionY = groupID; <br> if ( CurrentPixelPositionX &lt; ViewportSizeX ) <br> { <br> // HDR- . <br> //   HDR-    ,     . <br> uint2 colorPos = uint2(CurrentPixelPositionX, CurrentPixelPositionY); <br> float3 color = texture0.Load( int3(colorPos, 0) ).rgb; <br> float luma = dot(color, LUMA_RGB);</code> <br> <br>  Sehen Sie?  Es ist ziemlich einfach! <br><br>  Ich habe auch die Helligkeit berechnet (Zeile 21 des Assembler-Codes). <br><br>  Gro√üartig, wir haben die Helligkeit bereits aus einem Farbpixel berechnet.  Der n√§chste Schritt ist das Laden (keine Probe!) Des entsprechenden Tiefenwerts. <br><br>  Aber hier haben wir ein Problem, weil wir den Puffer der Tiefen voller Aufl√∂sung verbunden haben.  Was tun? <br><br>  Dies ist √ºberraschend einfach - multiplizieren Sie colorPos einfach mit einer Konstanten (cb0_v2.z).  Wir haben den HDR-Farbpuffer viermal verkleinert.  daher ist der Wert 4! <br><br> <code>const int iDepthTextureScale = (int) cb0_v2.z; <br> uint2 depthPos = iDepthTextureScale * colorPos; <br> float depth = texture1.Load( int3(depthPos, 0) ).x;</code> <br> <br>  So weit so gut!  Aber ... wir m√ºssen die Zeilen 24-25 erreichen ... <br><br> <code>24: eq r2.x, r2.x, cb0[2].w <br> 25: and r2.x, r2.x, cb0[2].y</code> <br> <br>  Also  Zuerst haben wir einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vergleich der</a> Gleitkomma- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gleichheit</a> , ihr Ergebnis ist in r2.x geschrieben, und gleich danach geht ... was?  Bitweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und</a> ??  Wirklich?  F√ºr einen Gleitkommawert?  Was zur H√∂lle??? <br><br>  <b>Das Problem 'eq + and'</b> <br><br>  Lassen Sie mich nur sagen, dass es f√ºr mich der schwierigste Teil des Shaders war.  Ich habe sogar seltsame Asint / Asfloat-Kombinationen ausprobiert ... <br><br>  Und wenn Sie einen etwas anderen Ansatz verwenden?  Lassen Sie uns einfach den √ºblichen Float-Float-Vergleich in HLSL durchf√ºhren. <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y); <br> return test; <br> }</code> <br> <br>  Und hier ist die Ausgabe im Assembler-Code: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, l(0x3f800000) <br> 2: ret</code> <br> <br>  Interessant, oder?  Ich hatte nicht erwartet, "und" hier zu sehen. <br><br>  0x3f800000 ist nur 1.0f ... Es ist logisch, weil wir sonst 1.0 und 0.0 erhalten, wenn der Vergleich erfolgreich ist. <br><br>  Aber was ist, wenn wir 1.0 durch einen anderen Wert ersetzen?  Zum Beispiel so: <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y) ? cb0_v0.z : 0.0; <br> return test; <br> }</code> <br> <br>  Wir erhalten folgendes Ergebnis: <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, cb0[0].z <br> 2: ret</code> <br> <br>  Ha!  Es hat funktioniert.  Dies ist nur die Magie des HLSL-Compilers.  Hinweis: Wenn Sie 0.0 durch etwas anderes ersetzen, erhalten Sie nur movc. <br><br>  Kehren wir zum Computational Shader zur√ºck.  Der n√§chste Schritt besteht darin, zu √ºberpr√ºfen, ob die Tiefe gleich cb0_v2.w ist.  Es ist immer gleich 0.0 - mit anderen Worten, wir pr√ºfen, ob sich ein Pixel in einer fernen Ebene (am Himmel) befindet.  Wenn ja, dann weisen wir diesem Koeffizienten einen Wert von ungef√§hr 0,5 zu (ich habe mehrere Frames √ºberpr√ºft). <br><br>  Dieser berechnete Koeffizient wird verwendet, um zwischen der Helligkeit der Farbe und der Helligkeit des ‚ÄûHimmels‚Äú zu interpolieren (cb0_v2.x-Wert, der h√§ufig ungef√§hr gleich 0,0 ist).  Ich gehe davon aus, dass dies notwendig ist, um die Bedeutung des Himmels f√ºr die Berechnung der durchschnittlichen Helligkeit zu kontrollieren.  Normalerweise wird die Wichtigkeit reduziert.  Sehr clevere Idee. <br><br> <code>// ,       ( ).  ,    ,    <br> //    . <br> float value = (depth == cb0_v2.w) ? cb0_v2.y : 0.0; <br> <br> //  'value'  0.0,   lerp    'luma'.   'value'  <br> // (  0.50),   luma    . (cb0_v2.x    0.0). <br> float lumaOk = lerp( luma, cb0_v2.x, value );</code> <br> <br>  Da wir lumaOk haben, besteht der n√§chste Schritt darin, seinen nat√ºrlichen Logarithmus zu berechnen, um eine gute Verteilung zu erstellen.  Aber warten Sie, sagen wir, lumaOk ist 0.0.  Wir wissen, dass der Wert von log (0) undefiniert ist, also addieren wir 1.0, weil log (1) = 0.0 ist. <br><br>  Danach skalieren wir den berechneten Logarithmus auf 128, um ihn in 256 Zellen zu verteilen.  Sehr schlau! <br><br>  Und von hier aus wird dieser Wert 88.722839 genommen.  Dies ist ein <code>128 *   (2)</code> . <br><br>  Auf diese Weise berechnet HLSL Logarithmen. <br><br>  Es gibt nur eine Funktion im HLSL-Assembler-Code, die Logarithmen berechnet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">log</a> , und sie hat eine Basis von 2. <br><br> <code>// ,  lumaOk  0.0. <br> // log(0)   undefined <br> // log(1) = 0. <br> //     <br> lumaOk = log(lumaOk + 1.0); <br> <br> //     128 <br> lumaOk *= 128;</code> <br> <br>  Schlie√ülich berechnen wir den Index der Zelle aus der logarithmisch verteilten Helligkeit und addieren 1 zur entsprechenden Zelle im gemeinsam genutzten Speicher. <br><br> <code>//   .    Uint,    256 , <br> //  ,      . <br> uint uLuma = (uint) lumaOk; <br> uLuma = min(uLuma, 255); <br> <br> //  1    . <br> InterlockedAdd( shared_data[uLuma], 1 );</code> <br> <br>  Im n√§chsten Schritt wird erneut eine Barriere festgelegt, um sicherzustellen, dass alle Pixel in der Zeile verarbeitet wurden. <br><br>  Der letzte Schritt besteht darin, dem strukturierten Puffer Werte aus dem gemeinsam genutzten Speicher hinzuzuf√ºgen.  Dies geschieht auf die gleiche Weise √ºber eine einfache Schleife: <br><br> <code>// ,       <br> GroupMemoryBarrierWithGroupSync(); <br> <br> //      . <br> [unroll] for (uint idx = 0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> <br> uint data = shared_data[offset]; <br> InterlockedAdd( g_buffer[offset], data ); <br> }</code> <br> <br>  Nachdem alle 64 Threads in der Thread-Gruppe die gemeinsamen Daten ausgef√ºllt haben, f√ºgt jeder Thread dem Ausgabepuffer 4 Werte hinzu. <br><br>  Betrachten Sie den Ausgabepuffer.  Lass uns dar√ºber nachdenken.  Die Summe aller Werte im Puffer entspricht der Gesamtzahl der Pixel!  (bei 480 √ó 270 = 129.600).  Das hei√üt, wir wissen, wie viele Pixel einen bestimmten Helligkeitswert haben. <br><br>  Wenn Sie sich mit Computer-Shadern (wie ich) schlecht auskennen, ist dies zun√§chst m√∂glicherweise nicht klar. Lesen Sie den Beitrag daher noch einige Male, nehmen Sie Papier und einen Bleistift und versuchen Sie, die Konzepte zu verstehen, auf denen diese Technik basiert. <br><br>  Das ist alles!  So berechnet The Witcher 3 ein Helligkeitshistogramm.  Pers√∂nlich habe ich beim Schreiben dieses Teils viel gelernt.  Herzlichen Gl√ºckwunsch an die Jungs von CD Projekt Red f√ºr ihre hervorragende Arbeit! <br><br>  Wenn Sie an einem vollst√§ndigen HLSL-Shader interessiert sind, finden Sie ihn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Ich bem√ºhe mich immer, den Assembler-Code so nah wie m√∂glich am Spiel zu haben und bin vollkommen froh, dass es mir wieder gelungen ist! <br><br><h2>  Berechnung der durchschnittlichen Helligkeit </h2><br>  Dies ist der zweite Teil der Analyse von Berechnungen mittlerer Helligkeit in ‚ÄûThe Witcher 3: Wild Hunt‚Äú. <br><br>  Bevor wir uns mit einem anderen Computational Shader messen, wiederholen wir kurz, was im letzten Teil passiert ist: Wir haben mit einem HDR-Farbpuffer mit einer Skalierung auf 1 / 4x1 / 4 gearbeitet.  Nach dem ersten Durchgang erhielten wir ein Helligkeitshistogramm (strukturierter Puffer mit 256 vorzeichenlosen ganzzahligen Werten).  Wir haben den Logarithmus f√ºr die Helligkeit jedes Pixels berechnet, ihn auf 256 Zellen verteilt und den entsprechenden Wert des strukturierten Puffers um 1 pro Pixel erh√∂ht.  Aus diesem Grund entspricht die Gesamtsumme aller Werte in diesen 256 Zellen der Anzahl der Pixel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/89c/d16/3c389cd16ec2eed7617dcf9334429c6e.png"></div><br>  <i>Ein Beispiel f√ºr die Ausgabe des ersten Durchgangs.</i>  <i>Es gibt 256 Elemente.</i> <br><br>  Unser Vollbildpuffer hat beispielsweise eine Gr√∂√üe von 1920 x 1080.  Nach dem Verkleinern wurde beim ersten Durchgang ein Puffer von 480 x 270 verwendet.  Die Summe aller 256 Werte im Puffer entspricht 480 * 270 = 129 600. <br><br>  Nach dieser kurzen Einf√ºhrung sind wir bereit, mit dem n√§chsten Schritt fortzufahren: dem Rechnen. <br><br>  Diesmal wird nur eine Thread-Gruppe verwendet (Dispatch (1, 1, 1)). <br><br>  Schauen wir uns den Assembler-Code des Computational Shader an: <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_uav_structured u0, 4 <br> dcl_uav_typed_texture2d (float,float,float,float) u1 <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 4 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, vThreadIDInGroup.x, l(0), u0.xxxx <br> 1: store_structured g0.x, vThreadIDInGroup.x, l(0), r0.x <br> 2: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 3: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.w, r0.x, l(0), u0.xxxx <br> 4: store_structured g0.x, r0.x, l(0), r0.w <br> 5: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.y, l(0), u0.xxxx <br> 6: store_structured g0.x, r0.y, l(0), r0.x <br> 7: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.z, l(0), u0.xxxx <br> 8: store_structured g0.x, r0.z, l(0), r0.x <br> 9: sync_g_t <br> 10: if_z vThreadIDInGroup.x <br> 11: mul r0.x, cb0[0].y, cb0[0].x <br> 12: ftou r0.x, r0.x <br> 13: utof r0.y, r0.x <br> 14: mul r0.yz, r0.yyyy, cb0[0].zzwz <br> 15: ftoi r0.yz, r0.yyzy <br> 16: iadd r0.x, r0.x, l(-1) <br> 17: imax r0.y, r0.y, l(0) <br> 18: imin r0.y, r0.x, r0.y <br> 19: imax r0.z, r0.y, r0.z <br> 20: imin r0.x, r0.x, r0.z <br> 21: mov r1.z, l(-1) <br> 22: mov r2.xyz, l(0, 0, 0, 0) <br> 23: loop <br> 24: breakc_nz r2.x <br> 25: ld_structured r0.z, r2.z, l(0), g0.xxxx <br> 26: iadd r3.x, r0.z, r2.y <br> 27: ilt r0.z, r0.y, r3.x <br> 28: iadd r3.y, r2.z, l(1) <br> 29: mov r1.xy, r2.yzyy <br> 30: mov r3.z, r2.x <br> 31: movc r2.xyz, r0.zzzz, r1.zxyz, r3.zxyz <br> 32: endloop <br> 33: mov r0.w, l(-1) <br> 34: mov r1.yz, r2.yyzy <br> 35: mov r1.xw, l(0, 0, 0, 0) <br> 36: loop <br> 37: breakc_nz r1.x <br> 38: ld_structured r2.x, r1.z, l(0), g0.xxxx <br> 39: iadd r1.y, r1.y, r2.x <br> 40: utof r2.x, r2.x <br> 41: utof r2.w, r1.z <br> 42: add r2.w, r2.w, l(0.500000) <br> 43: mul r2.w, r2.w, l(0.011271) <br> 44: exp r2.w, r2.w <br> 45: add r2.w, r2.w, l(-1.000000) <br> 46: mad r3.z, r2.x, r2.w, r1.w <br> 47: ilt r2.x, r0.x, r1.y <br> 48: iadd r2.w, -r2.y, r1.y <br> 49: itof r2.w, r2.w <br> 50: div r0.z, r3.z, r2.w <br> 51: iadd r3.y, r1.z, l(1) <br> 52: mov r0.y, r1.z <br> 53: mov r3.w, r1.x <br> 54: movc r1.xzw, r2.xxxx, r0.wwyz, r3.wwyz <br> 55: endloop <br> 56: store_uav_typed u1.xyzw, l(0, 0, 0, 0), r1.wwww <br> 57: endif <br> 58: ret</code> <br> <br>  Es gibt einen konstanten Puffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbe/13a/0ab/bbe13a0abe0d79f47b0a59d33d51ab9c.png"></div><br>  Werfen Sie einen kurzen Blick auf den Assembler-Code: Zwei UAVs sind angeh√§ngt (u0: Eingabepuffer aus dem ersten Teil und u1: Ausgabetextur im Format 1x1 R32_FLOAT).  Wir sehen auch, dass es 64 Threads pro Gruppe und 256 Elemente des gemeinsam genutzten 4-Byte-Gruppenspeichers gibt. <br><br>  Wir beginnen damit, den gemeinsam genutzten Speicher mit Daten aus dem Eingabepuffer zu f√ºllen.  Wir haben 64 Threads, daher m√ºssen Sie fast das Gleiche tun wie zuvor. <br><br>  Um absolut sicher zu sein, dass alle Daten zur weiteren Verarbeitung geladen wurden, setzen wir danach eine Barriere. <br><br> <code>//   -        . <br> //        64 ,    4     <br> //    . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = g_buffer[offset]; <br> } <br> //    ,       ,     <br> //             . <br> GroupMemoryBarrierWithGroupSync();</code> <br> <br>  Alle Berechnungen werden nur in einem Thread ausgef√ºhrt, alle anderen werden einfach zum Laden von Werten aus dem Puffer in den gemeinsam genutzten Speicher verwendet. <br><br>  Der "Computer" -Stream hat einen Index von 0. Warum?  Theoretisch k√∂nnen wir jeden Stream aus dem Intervall [0-63] verwenden, aber dank eines Vergleichs mit 0 k√∂nnen wir zus√§tzliche Ganzzahl-Ganzzahl-Vergleiche ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dhq-</a> Anweisungen) vermeiden. <br><br>  Der Algorithmus basiert auf der Angabe des Pixelintervalls, das bei der Operation ber√ºcksichtigt wird. <br><br>  In Zeile 11 multiplizieren wir width * height, um die Gesamtzahl der Pixel zu erhalten, und multiplizieren sie mit zwei Zahlen aus dem Intervall [0.0f-1.0f], wobei der Beginn und das Ende des Intervalls angegeben werden.  Weitere Einschr√§nkungen werden verwendet, um sicherzustellen, dass <code>0 &lt;= Start &lt;= End &lt;= totalPixels - 1</code> : <br><br> <code>//        0. <br> [branch] if (threadID == 0) <br> { <br> //         <br> uint totalPixels = cb0_v0.x * cb0_v0.y; <br> <br> //   (,  ,    ), <br> //        . <br> int pixelsToConsiderStart = totalPixels * cb0_v0.z; <br> int pixelsToConsiderEnd = totalPixels * cb0_v0.w; <br> <br> int pixelsMinusOne = totalPixels - 1; <br> <br> pixelsToConsiderStart = clamp( pixelsToConsiderStart, 0, pixelsMinusOne ); <br> pixelsToConsiderEnd = clamp( pixelsToConsiderEnd, pixelsToConsiderStart, pixelsMinusOne );</code> <br> <br>  Wie Sie sehen k√∂nnen, gibt es unten zwei Zyklen.  Das Problem mit ihnen (oder mit ihrem Assembler-Code) ist, dass es seltsame bedingte √úberg√§nge an den Enden von Schleifen gibt.  Es war sehr schwierig f√ºr mich, sie nachzubilden.  Schauen Sie sich auch Zeile 21 an. Warum gibt es "-1"?  Ich werde es unten etwas erkl√§ren. <br><br>  Die Aufgabe des ersten Zyklus besteht darin, <i>pixelsToConsiderStart</i> zu <i>l√∂schen</i> und den Index der Pufferzelle <i>anzugeben,</i> in der <i>pixelsToConsiderStart</i> +1 vorhanden ist (sowie die Anzahl aller Pixel in den vorherigen Zellen). <br><br>  <i>Angenommen</i> , <i>pixelsToConsiderStart entspricht</i> ungef√§hr 30.000, und im Puffer befinden sich 37.000 Pixel in der Zelle ‚ÄûNull‚Äú (dies geschieht nachts im Spiel).  Daher m√∂chten wir die Analyse der Helligkeit mit ungef√§hr dem Pixel 30001 beginnen, das in der Zelle "Null" vorhanden ist.  In diesem Fall verlassen wir sofort die Schleife und erhalten den Startindex '0' und null verworfene Pixel. <br><br>  Schauen Sie sich den HLSL-Code an: <br><br> <code>//     <br> int numProcessedPixels = 0; <br> <br> //   [0-255] <br> int lumaValue = 0; <br> <br> //      <br> bool bExitLoop = false; <br> <br> //    -  "pixelsToConsiderStart" . <br> //          lumaValue,      . <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> // ,      lumaValue <br> int tempSum = numProcessedPixels + numPixels; <br> <br> //  ,  pixelsToConsiderStart,    . <br> // ,      lumaValue. <br> //  , pixelsToConsiderStart -   "" ,   ,    . <br> [flatten] <br> if (tempSum &gt; pixelsToConsiderStart) <br> { <br> bExitLoop = true; <br> } <br> else <br> { <br> numProcessedPixels = tempSum; <br> lumaValue++; <br> } <br> }</code> <br> <br>  Die mysteri√∂se Zahl "-1" aus Zeile 21 des Assembler-Codes ist mit der Booleschen Bedingung f√ºr die Schleifenausf√ºhrung verbunden (ich habe dies fast zuf√§llig entdeckt). <br><br>  Nachdem wir die Anzahl der Pixel von <i>lumaValue-</i> Zellen und <i>lumaValue</i> selbst erhalten haben, k√∂nnen wir mit dem zweiten Zyklus <i>fortfahren</i> . <br><br>  Die Aufgabe des zweiten Zyklus besteht darin, den Einfluss von Pixeln und der durchschnittlichen Helligkeit zu berechnen. <br><br>  Wir beginnen mit <i>lumaValue, das</i> in der ersten Schleife berechnet wurde. <br><br> <code>float finalAvgLuminance = 0.0f; <br> <br> //       <br> uint numProcessedPixelStart = numProcessedPixels; <br> <br> //    -      . <br> //    ,    ,        lumaValue. <br> //      [0-255],     ,    ,   ,    <br> //    pixelsToConsiderEnd. <br> //          . <br> bExitLoop = false; <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> //      <br> numProcessedPixels += numPixels; <br> <br> //    ,    [0-255] (uint) <br> uint encodedLumaUint = lumaValue; <br> <br> //        <br> float numberOfPixelsWithCurrentLuma = numPixels; <br> <br> //    ,    [0-255] (float) <br> float encodedLumaFloat = encodedLumaUint;</code> <br> <br>  Zu diesem Zeitpunkt erhielten wir den im Intervall [0.0f-255.f] codierten Helligkeitswert. <br><br>  Der Dekodierungsprozess ist recht einfach - Sie m√ºssen die Berechnung der Kodierungsstufe umkehren. <br><br>  Eine kurze Wiederholung des Codierungsprozesses: <br><br> <code>float luma = dot( hdrPixelColor, float3(0.2126, 0.7152, 0.0722) ); <br> ... <br> float outLuma; <br> <br> //   log(0)  undef,  log(1) = 0 <br> outLuma = luma + 1.0; <br> <br> //   <br> outLuma = log( outLuma ); <br> <br> //   128,   log(1) * 128 = 0, log(2,71828) * 128 = 128, log(7,38905) * 128 = 256 <br> outLuma = outLuma * 128 <br> <br> //   uint <br> uint outLumaUint = min( (uint) outLuma, 255);</code> <br> <br>  Um die Helligkeit zu dekodieren, kehren wir den Kodierungsprozess beispielsweise wie folgt um: <br><br> <code>//    0.5f (  ,    ) <br> float fDecodedLuma = encodedLumaFloat + 0.5; <br> <br> //   : <br> <br> //   128 <br> fDecodedLuma /= 128.0; <br> <br> // exp(x),   log(x) <br> fDecodedLuma = exp(fDecodedLuma); <br> <br> //  1.0 <br> fDecodedLuma -= 1.0;</code> <br> <br>  Dann berechnen wir die Verteilung, indem wir die Anzahl der Pixel mit einer bestimmten Helligkeit mit der decodierten Helligkeit multiplizieren und sie summieren, bis wir zur Verarbeitung von <i>pixelsToConsiderEnd-</i> Pixeln gelangen. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach teilen wir den Gesamteffekt auf die Anzahl der analysierten Pixel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist der Rest der Schleife (und der Shader): Der </font><font style="vertical-align: inherit;">vollst√§ndige Shader ist </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hier</font></a><font style="vertical-align: inherit;"> verf√ºgbar </font><font style="vertical-align: inherit;">. Es ist vollst√§ndig kompatibel mit meinem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">HLSLexplorer-</font></a><font style="vertical-align: inherit;"> Programm </font><font style="vertical-align: inherit;">, ohne das ich die durchschnittliche Helligkeitsberechnung in The Witcher 3 (und allen anderen Effekten auch!) Nicht effektiv </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">nachbilden k√∂nnte</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Abschlie√üend noch ein paar Gedanken. Bei der Berechnung der durchschnittlichen Helligkeit war dieser Shader schwer wiederherzustellen. Die Hauptgr√ºnde: </font><font style="vertical-align: inherit;">1) Seltsame "ausstehende" √úberpr√ºfungen der Ausf√ºhrung des Zyklus, es dauerte viel l√§nger als ich bisher dachte. </font><font style="vertical-align: inherit;">2) Probleme beim Debuggen dieses Computer-Shaders in RenderDoc (Version 1.2).</font></font><br><br> <code>//     <br> float fCurrentLumaContribution = numberOfPixelsWithCurrentLuma * fDecodedLuma; <br> <br> // ()       . <br> float tempTotalContribution = fCurrentLumaContribution + finalAvgLuminance; <br> <br> <br> [flatten] <br> if (numProcessedPixels &gt; pixelsToConsiderEnd ) <br> { <br> //     <br> bExitLoop = true; <br> <br> //      ,     . <br> //         <br> int diff = numProcessedPixels - numProcessedPixelStart; <br> <br> //     <br> finalAvgLuminance = tempTotalContribution / float(diff); <br> } <br> else <br> { <br> //       lumaValue <br> finalAvgLuminance = tempTotalContribution; <br> lumaValue++; <br> } <br> } <br> <br> //    <br> g_avgLuminance[uint2(0,0)] = finalAvgLuminance;</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Operationen "ld_structured_indexable" werden nicht vollst√§ndig unterst√ºtzt, obwohl das Ergebnis des Lesens aus Index 0 den korrekten Wert ergibt, alle anderen geben Nullen zur√ºck, weshalb die Zyklen unbegrenzt fortgesetzt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl ich nicht den gleichen Assembler-Code wie im Original erzielen konnte (Unterschiede siehe Screenshot unten), konnte ich mit RenderDoc diesen Shader in die Pipeline einf√ºgen - und die Ergebnisse waren dieselben!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/a0e/74f/de1a0e74f0f6619994d1edc9621d148d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ergebnis der Schlacht. </font><font style="vertical-align: inherit;">Links ist mein Shader, rechts ist der urspr√ºngliche Assembler-Code.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 8. Der Mond und seine Phasen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im achten Teil des Artikels untersuche ich den Mond-Shader aus The Witcher 3 (und genauer gesagt aus der Blood and Wine-Erweiterung). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Mond ist ein wichtiges Element des Nachthimmels, und es kann ziemlich schwierig sein, ihn glaubw√ºrdig zu machen, aber f√ºr mich war es ein echtes Vergn√ºgen, nachts in TW3 zu laufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schau dir diese Szene an!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/099/b6c/53f099b6ccfcef0eeb0755ced73894b9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir uns mit dem Pixel-Shader befassen, m√∂chte ich einige Worte zu den Nuancen des Renderns sagen. Aus geometrischer Sicht ist der Mond nur eine Kugel (siehe unten) mit Texturkoordinaten, Normal- und Tangentenvektoren. Der Vertex-Shader berechnet die Position im Weltraum sowie die normalisierten Vektoren von Normalen, tangential und tangential zu zwei Punkten (unter Verwendung eines Vektorprodukts), multipliziert mit der Weltmatrix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um sicherzustellen , </font><font style="vertical-align: inherit;">dass der Mond liegt ganz auf den entfernten Ebene, Felder und MinDepth MaxDepth Struktur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D3D11_VIEWPORT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Wert 0,0 (den gleichen Trick, der </font><font style="vertical-align: inherit;">f√ºr den Himmel Kuppel verwendet wurde) zugewiesen. Der Mond wird unmittelbar nach dem Himmel gerendert.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f5/999/ec7/6f5999ec7ca1176dfac370f60820d97f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kugel, mit der der Mond</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gezeichnet wurde </font><i><font style="vertical-align: inherit;">.</font></i><font style="vertical-align: inherit;"> Nun, ich denke, alles, was Sie tun k√∂nnen. </font><font style="vertical-align: inherit;">Werfen wir einen Blick auf den Pixel-Shader: Der </font><font style="vertical-align: inherit;">Hauptgrund, warum ich mich f√ºr einen Shader von Blood and Wine entschieden habe, ist einfach - er ist k√ºrzer. </font><font style="vertical-align: inherit;">Zuerst berechnen wir den Versatz, um die Textur abzutasten. </font><font style="vertical-align: inherit;">cb0 [0] .w wird als Versatz entlang der X-Achse verwendet. Mit diesem einfachen Trick k√∂nnen wir die Drehung des Mondes um seine Achse simulieren.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[267], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_input_ps linear v1.w <br> dcl_input_ps linear v2.xyzw <br> dcl_input_ps linear v3.xy <br> dcl_input_ps linear v4.xy <br> dcl_output o0.xyzw <br> dcl_temps 3 <br> 0: mov r0.x, -cb0[0].w <br> 1: mov r0.y, l(0) <br> 2: add r0.xy, r0.xyxx, v2.xyxx <br> 3: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, r0.xyxx, t0.xyzw, s0 <br> 4: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 5: log r0.w, r0.w <br> 6: mul r0.w, r0.w, l(2.200000) <br> 7: exp r0.w, r0.w <br> 8: add r0.xyz, r0.xyzx, r0.xyzx <br> 9: dp3 r1.x, r0.xyzx, r0.xyzx <br> 10: rsq r1.x, r1.x <br> 11: mul r0.xyz, r0.xyzx, r1.xxxx <br> 12: mul r1.xy, r0.yyyy, v3.xyxx <br> 13: mad r0.xy, v4.xyxx, r0.xxxx, r1.xyxx <br> 14: mad r0.xy, v2.zwzz, r0.zzzz, r0.xyxx <br> 15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185) <br> 17: sincos r1.x, r2.x, r0.z <br> 18: mov r2.y, r1.x <br> 19: dp2_sat r0.x, r0.xyxx, r2.xyxx <br> 20: mul r0.xyz, r0.xxxx, cb12[266].xyzx <br> 21: mul r0.xyz, r0.xyzx, r0.wwww <br> 22: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 23: add_sat r0.w, -v1.w, l(1.000000) <br> 24: mul r0.w, r0.w, cb2[2].w <br> 25: mul o0.xyz, r0.wwww, r0.xyzx <br> 26: mov o0.w, l(0) <br> 27: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc2/ddb/c02/fc2ddbc0262d27002f70d837a623c366.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele f√ºr Werte aus dem konstanten Puffer:</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine Textur (1024 x 512) wird als Eingabe angeh√§ngt. </font><font style="vertical-align: inherit;">Die normale Karte ist in den RGB-Kan√§len und die Farbe der Mondoberfl√§che im Alphakanal codiert. </font><font style="vertical-align: inherit;">Clever!</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/733/1a1/3927331a17867d712e667c36a0ee6641.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Alpha-Kanal einer Textur ist die Farbe der Mondoberfl√§che.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/542/d70/c64542d70a7e3b58aa9426f12e8880d7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textur-RGB-Kan√§le sind eine normale Karte.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir die richtigen Texturkoordinaten erhalten haben, probieren wir die RGBA-Kan√§le aus. Wir m√ºssen die normale Karte auspacken und eine Gammakorrektur der Oberfl√§chenfarbe durchf√ºhren. Derzeit kann ein HLSL-Shader folgenderma√üen geschrieben werden: </font><font style="vertical-align: inherit;">Der n√§chste Schritt besteht darin, eine normale Bindung durchzuf√ºhren, jedoch nur in XY-Komponenten. (In The Witcher 3 ist die Z-Achse oben und der gesamte Z-Kanal der Textur ist 1,0). Wir k√∂nnen es so machen: </font><font style="vertical-align: inherit;">Jetzt ist es Zeit f√ºr meinen Lieblingsteil dieses Shaders. </font><font style="vertical-align: inherit;">Schauen Sie sich noch </font><font style="vertical-align: inherit;">einmal die Zeilen 15-16 an: </font><font style="vertical-align: inherit;">Was ist das f√ºr ein mysteri√∂ses 0.033864? Zun√§chst scheint es keinen Sinn zu machen, aber wenn wir den umgekehrten Wert berechnen, erhalten wir ungef√§hr 29,53, was der Dauer des </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">synodischen Monats entspricht</font></a></font><br><br> <code>float4 MoonPS(in InputStruct IN) : SV_Target0 <br> { <br> //  Texcoords <br> float2 uvOffsets = float2(-cb0_v0.w, 0.0); <br> <br> //  texcoords <br> float2 uv = IN.param2.xy + uvOffsets; <br> <br> //   <br> float4 sampledTexture = texture0.Sample( sampler0, uv); <br> <br> //    -  - <br> float moonColorTex = pow(sampledTexture.a, 2.2 ); <br> <br> //     [0,1]   [-1,1]. <br> // : sampledTexture.xyz * 2.0 - 1.0    <br> float3 sampledNormal = normalize((sampledTexture.xyz - 0.5) * 2);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>//    <br> float3 Tangent = IN.param4.xyz; <br> float3 Normal = float3(IN.param2.zw, IN.param3.w); <br> float3 Bitangent = IN.param3.xyz; <br> <br> //  TBN <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> <br> //    XY <br> //   TBN  float3x2: 3 , 2  <br> float2 vNormal = mul(sampledNormal, (float3x2)TBN).xy;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185)</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Tagen! </font><font style="vertical-align: inherit;">Das ist es, was ich auf Details aufmerksam mache! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen zuverl√§ssig davon ausgehen, dass cb0 [0] .y die Anzahl der Tage ist, die w√§hrend des Spiels vergangen sind. </font><font style="vertical-align: inherit;">Hier wird eine zus√§tzliche Abweichung verwendet, die als Versatz entlang der x-Achse der Textur verwendet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir diesen Koeffizienten erhalten haben, multiplizieren wir ihn mit 2 * Pi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann berechnen wir mit sincos einen weiteren 2d-Vektor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Berechnung des Skalarprodukts zwischen dem Normalenvektor und dem "Mond" -Vektor wird eine Mondphase simuliert. </font><font style="vertical-align: inherit;">Schauen Sie sich die Screenshots mit verschiedenen Mondphasen an:</font></font><br><br> <code>//  . <br> //   days/29.53 + bias. <br> float phase = cb0_v0.y * (1.0 / SYNODIC_MONTH_LENGTH) + cb0_v0.w; <br> <br> //   2*PI.  , 29.53     <br> //   sin/cos. <br> phase *= TWOPI; <br> <br> //      . <br> float outSin = 0.0; <br> float outCos = 0.0; <br> sincos(phase, outSin, outCos); <br> <br> //    <br> float lunarPhase = saturate( dot(vNormal, float2(outCos, outSin)) );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c54/e7f/648/c54e7f6488b10d402a7f4b45e61d455d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/133/edc/899133edc0c04c67ffb4987748e908b7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Schritt besteht darin, eine Reihe von Multiplikationsoperationen durchzuf√ºhren, um die endg√ºltige Farbe zu berechnen. </font><font style="vertical-align: inherit;">Sie verstehen wahrscheinlich nicht, warum dieser Shader einen Alpha-Wert von 0,0 an die Ausgabe sendet. </font><font style="vertical-align: inherit;">Dies liegt daran, dass der Mond mit aktivierter √úberblendung gerendert wird:</font></font><br><br> <code>//        . <br> <br> // cb12_v266.xyz ,      . <br> //  (1.54, 2.82, 4.13) <br> float3 moonSurfaceGlowColor = cb12_v266.xyz; <br> <br> float3 moonColor = lunarPhase * moonSurfaceGlowColor; <br> moonColor = moonColorTex * moonColor; <br> <br> // cb_v2.xyz - , , ,  (1.0, 1.0, 1.0) <br> moonColor *= cb2_v2.xyz; <br> <br> //   ,    , .  -   . <br> //     ,         , <br> //   . <br> float paramHorizon = saturate(1.0 - IN.param1.w); <br> paramHorizon *= cb2_v2.w; <br> <br> moonColor *= paramHorizon; <br> <br> //        <br> return float4(moonColor, 0.0);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/549/32c/2d954932c188bcdcdd0a156796b85da7.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem Ansatz k√∂nnen Sie die Hintergrundfarbe (Himmelfarbe) abrufen, wenn dieser Shader Schwarz zur√ºckgibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie an einem vollst√§ndigen Shader interessiert sind, k√∂nnen Sie ihn </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier herunterladen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es hat gro√üe konstante Puffer und sollte bereits f√ºr die Injektion in RenderDoc anstelle des urspr√ºnglichen Shaders bereit sein (benennen Sie einfach "MoonPS" in "EditedShaderPS" um). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und das letzte: Ich wollte die Ergebnisse mit Ihnen teilen: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links ist mein Shader, rechts ist der urspr√ºngliche Shader aus dem Spiel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Unterschied ist minimal und hat keinen Einfluss auf die Ergebnisse.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff8/c4a/8fa/ff8c4a8fa103b9592941c965ad060729.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie Sie sehen k√∂nnen, war dieser Shader ziemlich einfach neu zu erstellen. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 9. G-Puffer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werde ich einige Details des Gbuffers in The Witcher 3 enth√ºllen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir gehen davon aus, dass Sie die Grundlagen der verz√∂gerten Schattierung kennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurze Wiederholung: Die Idee des Verschiebens besteht nicht darin, die gesamte fertige Beleuchtung und Beschattung auf einmal zu berechnen, sondern die Berechnungen in zwei Stufen zu unterteilen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im ersten (Geometrie-Durchgang) f√ºllen wir den GBuffer mit Oberfl√§chendaten (Position, Normalen, Spiegelfarbe usw. ...) und im zweiten (Beleuchtungs-Durchgang) kombinieren wir alles und berechnen die Beleuchtung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die verz√∂gerte Schattierung ist ein sehr beliebter Ansatz, da Sie mit einem einzigen Vollbilddurchlauf Techniken wie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verz√∂gerte Schattierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Kacheln</font></a><font style="vertical-align: inherit;"> berechnen k√∂nnen </font><font style="vertical-align: inherit;">, wodurch die Leistung erheblich verbessert wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfach ausgedr√ºckt ist GBuffer eine Reihe von Texturen mit Geometrieeigenschaften. </font><font style="vertical-align: inherit;">Es ist sehr wichtig, die richtige Struktur daf√ºr zu schaffen. </font><font style="vertical-align: inherit;">Als Beispiel aus dem wirklichen Leben k√∂nnen Sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crysis 3-Rendering-Technologie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> studieren </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns nach dieser kurzen Einf√ºhrung einen Beispielrahmen aus The Witcher 3 an: Blood and Wine:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/6f5/537/2c36f5537e82217c31d0f5f682b17b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eines der vielen Hotels in Toussent</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basic GBuffer besteht aus drei Vollbild-Renderzielen im Format DXGI_FORMAT_R8G8B8A8_UNORM und einem Tiefen- + Schablonenpuffer im Format DXGI_FORMAT_D24_UNORM_S8_UINT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind ihre Screenshots:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/dec/857/309dec857a7839f41984b44ff82516ab.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderziel 0 - RGB-Kan√§le, Oberfl√§chenfarbe</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/44c/b90/16c44cb90b067cb420d921e101319bb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderziel 0 - Alpha-Kanal. </font><font style="vertical-align: inherit;">Ehrlich gesagt habe ich keine Ahnung, was diese Informationen sind.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/f1a/cf3/de9f1acf36c9f9e18ec6f4a9708ede11.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderziel 1 - RGB-Kan√§le. </font><font style="vertical-align: inherit;">Hier werden die Normalenvektoren im Intervall [0-1] aufgezeichnet.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/a60/1e8/0a5a601e893d88a619b94f1ed7d21ae2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderziel 1 - Alpha-Kanal. </font><font style="vertical-align: inherit;">Sieht aus wie Reflektivit√§t!</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fa/8f5/d61/7fa8f5d61cfc903b764eec1e9b46c431.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderziel 2 - RGB-Kan√§le. </font><font style="vertical-align: inherit;">Sieht aus wie Spiegelfarbe! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Szene ist der Alphakanal schwarz (wird aber sp√§ter verwendet).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/27d/dab/e7e27ddab2102174b3f63bb9037e28a0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puffertiefen. </font><font style="vertical-align: inherit;">Beachten Sie, dass hier die invertierte Tiefe verwendet wird.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/77d/daa/e4e77ddaa01705381f956410f546fdf4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schablonenpuffer zum Markieren eines bestimmten</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixeltyps </font><i><font style="vertical-align: inherit;">(z. B. Haut, Vegetation usw.)</font></i><font style="vertical-align: inherit;"> Dies ist nicht der gesamte GB-Puffer. </font><font style="vertical-align: inherit;">Der Beleuchtungspass verwendet auch Beleuchtungssonden und andere Puffer, aber ich werde sie in diesem Artikel nicht diskutieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor ich zum "Hauptteil" des Beitrags √ºbergehe, werde ich allgemeine Bemerkungen machen:</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Allgemeine Beobachtungen </font></font></h3><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Der einzige zu reinigende Puffer ist der Tiefen- / Schablonenpuffer.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie die oben genannten Texturen in einem guten Frame-Analysator analysieren, werden Sie ein wenig √ºberrascht sein, da sie den Aufruf ‚ÄûL√∂schen‚Äú mit Ausnahme von Tiefe / Schablone nicht verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, in Wirklichkeit sieht RenderTarget1 so aus (beachten Sie die ‚Äûverschwommenen‚Äú Pixel auf der anderen Ebene):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/16a/3a7/22a16a3a7df971c2d1609f15e254cd06.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine einfache und intelligente Optimierung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine wichtige Lektion: </font><font style="vertical-align: inherit;">Sie m√ºssen Ressourcen </font><font style="vertical-align: inherit;">f√ºr </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClearRenderTargetView-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufrufe </font><font style="vertical-align: inherit;">ausgeben. Verwenden Sie sie daher nur bei Bedarf. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Inverted Tiefe - es ist k√ºhl</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vielen </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikeln </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bereits </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ºber die Genauigkeit des Tiefenpuffers mit Gleitkomma. Hexer 3 verwendet umgekehrt-z. Dies ist die nat√ºrliche Wahl f√ºr ein solches Open-World-Spiel mit langen Rendering-Entfernungen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wechsel zu DirectX wird nicht schwierig sein: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Wir l√∂schen den Tiefenpuffer, indem wir "0" und nicht "1" schreiben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim traditionellen Ansatz wurde der Fernwert ‚Äû1‚Äú verwendet, um den Tiefenpuffer zu l√∂schen. Nach dem Tiefenwechsel wurde der neue "entfernte" Wert 0, sodass Sie alles √§ndern m√ºssen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Vertauschen Sie bei der Berechnung der Projektionsmatrix die nahen und fernen Grenzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) √Ñndern Sie die Tiefenpr√ºfung von ‚Äûweniger‚Äú auf ‚Äûmehr‚Äú. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei OpenGL muss etwas mehr Arbeit geleistet werden (siehe die oben genannten Artikel), aber es lohnt sich. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Wir behalten unsere Position in der Welt nicht bei.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ja, alles ist so einfach. </font><font style="vertical-align: inherit;">Im Durchgang der Beleuchtung schaffen wir aus den Tiefen eine Position in der Welt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil wollte ich genau den Pixel-Shader zeigen, der GBuffer Oberfl√§chendaten liefert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt wissen wir also bereits, wie man Farben, Normalen und Spiegelbilder speichert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich ist nicht alles so einfach, wie Sie vielleicht denken. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem mit dem Pixel-Shader ist, dass er viele Optionen hat. </font><font style="vertical-align: inherit;">Sie unterscheiden sich in der Anzahl der auf sie √ºbertragenen Texturen und der Anzahl der aus dem konstanten Puffer verwendeten Parameter (wahrscheinlich aus dem das Material beschreibenden konstanten Puffer). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr die Analyse habe ich mich f√ºr dieses sch√∂ne Fass entschieden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/635/aa0/262635aa0a42dde5353586c867bc91d1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser heldenhaftes Fass! </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte begr√º√üen Sie die Texturen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/fde/9bb/9e4fde9bbe2ebcc3c1088eff5e3ea40d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben also Albedo, eine normale Karte und eine spiegelnde Farbe. Ziemlich normaler Fall. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir beginnen, ein paar Worte zur Geometrieeingabe: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geometrie wird mit Positions-, Texkoordinaten-, Normal- und Tangentenpuffern √ºbertragen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Vertex-Shader gibt </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mindestens</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texcoords, normalisierte Tangenten- / Normal- / Tangentenvektoren, an zwei Punkte aus, die zuvor mit der Weltmatrix multipliziert wurden. Bei komplexeren Materialien (z. B. mit zwei diffusen Karten oder zwei normalen Karten) kann der Vertex-Shader andere Daten ausgeben, aber ich wollte hier ein einfaches Beispiel zeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel-Shader im Assembler-Code: Ein </font><font style="vertical-align: inherit;">Shader besteht aus mehreren Schritten. Ich werde jeden Hauptteil dieses Shaders separat beschreiben.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[3], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t2 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 3 <br> 0: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, v1.xyxx, t1.xyzw, s0 <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t0.xyzw, s0 <br> 2: add r1.w, r1.y, r1.x <br> 3: add r1.w, r1.z, r1.w <br> 4: mul r2.x, r1.w, l(0.333300) <br> 5: add r2.y, l(-1.000000), cb4[1].x <br> 6: mul r2.y, r2.y, l(0.500000) <br> 7: mov_sat r2.z, r2.y <br> 8: mad r1.w, r1.w, l(-0.666600), l(1.000000) <br> 9: mad r1.w, r2.z, r1.w, r2.x <br> 10: mul r2.xzw, r1.xxyz, cb4[0].xxyz <br> 11: mul_sat r2.xzw, r2.xxzw, l(1.500000, 0.000000, 1.500000, 1.500000) <br> 12: mul_sat r1.w, abs(r2.y), r1.w <br> 13: add r2.xyz, -r1.xyzx, r2.xzwx <br> 14: mad r1.xyz, r1.wwww, r2.xyzx, r1.xyzx <br> 15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx <br> 21: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r1.xyz, v3.xyzx, r0.xxxx, r1.xyzx <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r1.xyzx <br> 28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w <br> 46: dp3 r0.w, r0.xyzx, r0.xyzx <br> 47: rsq r0.w, r0.w <br> 48: mul r0.xyz, r0.wwww, r0.xyzx <br> 49: max r0.w, abs(r0.y), abs(r0.x) <br> 50: max r0.w, r0.w, abs(r0.z) <br> 51: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 52: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 53: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 54: lt r1.z, r1.y, r1.x <br> 55: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 56: div r1.z, r1.y, r1.x <br> 57: div r0.xyz, r0.xyzx, r0.wwww <br> 58: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 59: mul r0.xyz, r0.wwww, r0.xyzx <br> 60: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 61: mov o0.w, cb4[2].x <br> 62: mov o2.w, l(0) <br> 63: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aber zuerst wie gewohnt - ein Screenshot mit den Werten aus dem konstanten Puffer: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e94/24c/abb/e9424cabbd31630a47b7489e0e32c6af.jpg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Albedo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden mit komplexen Dingen beginnen. </font><font style="vertical-align: inherit;">Es ist nicht nur </font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"OutputColor.rgb = Texture.Sample (uv) .rgb".</font></font></strike> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach dem Abtasten der RGB- </font><strike><font style="vertical-align: inherit;">Farbtextur</font></strike><font style="vertical-align: inherit;"> (Zeile 1) werden die n√§chsten 14 Zeilen als "S√§ttigungsreduzierungspuffer" bezeichnet. </font><font style="vertical-align: inherit;">Lassen Sie mich Ihnen den HLSL-Code zeigen: </font><font style="vertical-align: inherit;">Bei den meisten Objekten gibt dieser Code nur die urspr√ºngliche Farbe aus der Textur zur√ºck. </font><font style="vertical-align: inherit;">Dies wird durch die entsprechenden Werte des ‚ÄûMaterialpuffers‚Äú erreicht. </font><font style="vertical-align: inherit;">cb4_v1.x hat den Wert 1.0, der eine Maske von 0.0 und die Eingabefarbe aus der </font><i><font style="vertical-align: inherit;">Lerp-</font></i><font style="vertical-align: inherit;"> Anweisung </font><i><font style="vertical-align: inherit;">zur√ºckgibt</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es gibt jedoch einige Ausnahmen. </font><font style="vertical-align: inherit;">Der gr√∂√üte </font><i><font style="vertical-align: inherit;">Ents√§ttigungsfaktor, den</font></i><font style="vertical-align: inherit;"> ich </font><i><font style="vertical-align: inherit;">gefunden habe,</font></i><font style="vertical-align: inherit;"> ist 4.0 (er ist nie kleiner als 1.0) und </font><i><font style="vertical-align: inherit;">desaturatedColor</font></i></font><br><br> <code>float3 albedoColorFilter( in float3 color, in float desaturationFactor, in float3 desaturationValue ) <br> { <br> float sumColorComponents = color.r + color.g + color.b; <br> <br> float averageColorComponentValue = 0.3333 * sumColorComponents; <br> float oneMinusAverageColorComponentValue = 1.0 - averageColorComponentValue; <br> <br> float factor = 0.5 * (desaturationFactor - 1.0); <br> <br> float avgColorComponent = lerp(averageColorComponentValue, oneMinusAverageColorComponentValue, saturate(factor)); <br> float3 desaturatedColor = saturate(color * desaturationValue * 1.5); <br> <br> float mask = saturate( avgColorComponent * abs(factor) ); <br> <br> float3 finalColor = lerp( color, desaturatedColor, mask ); <br> return finalColor; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kommt auf das Material an. </font><font style="vertical-align: inherit;">Es kann so etwas wie (0,2, 0,3, 0,4) sein; </font><font style="vertical-align: inherit;">Es gibt keine strengen Regeln. </font><font style="vertical-align: inherit;">Nat√ºrlich, ich konnte nicht helfen , </font><font style="vertical-align: inherit;">aber wei√ü , </font><font style="vertical-align: inherit;">das in seinem eigenen DX11-Rahmen, und hier sind die Ergebnisse, wo alle der Werte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturatedColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleich float3 (0,25, 0,3, 0,45)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12f/184/2d9/12f1842d9d272fc057f35bc73439c4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ents√§ttigungsfaktor = 1,0 (hat keine Wirkung)</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/ead/3a3/03cead3a3d5a713e051e7d863d99ecb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ents√§ttigungsfaktor = 2,0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caf/c81/992/cafc81992ebb70914c1e9d6605b8ba17.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ents√§ttigungsfaktor = 3,0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f37/193/7fb/f371937fb39f94a887410a951f9eb628.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 4.0</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich bin sicher, dass dies nur eine Anwendung von Materialparametern ist, aber nicht am Ende des Albedo-Teils durchgef√ºhrt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zeilen 15 bis 20 f√ºgen den letzten Schliff hinzu: </font><font style="vertical-align: inherit;">v0.z ist die Ausgabe des Vertex-Shaders und sie sind Null. </font><font style="vertical-align: inherit;">Vergessen Sie es nicht, denn v0.z wird sp√§ter einige Male verwendet. </font><font style="vertical-align: inherit;">Es scheint, als w√§re es eine Art Koeffizient, und der gesamte Code sieht aus wie eine kleine Dimmalbedo, aber da v0.z 0 ist, bleibt die Farbe unver√§ndert. </font><font style="vertical-align: inherit;">HLSL: </font><font style="vertical-align: inherit;">In Bezug auf RT0.a wird es, wie wir sehen k√∂nnen, aus dem Materialkonstantenpuffer entnommen, aber da der Shader keine Debugging-Informationen hat, ist es schwer zu sagen, was es ist. </font><font style="vertical-align: inherit;">Vielleicht Transluzenz? </font><font style="vertical-align: inherit;">Wir sind mit dem ersten Renderziel fertig!</font></font><br><br> <code>15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* ALBEDO */ <br> //     (?) <br> float3 albedoColor = albedoColorFilter( colorTex, cb4_v1.x, cb4_v0.rgb ); <br> float albedoMaxComponent = getMaxComponent( albedoColor ); <br> <br> //   ,   <br> //       "paramZ"   0 <br> float paramZ = Input.out0.z; // ,    0 <br> <br> // ,  0.70  0.85      <br> //       lerp,     . <br> float param = (albedoMaxComponent &gt; 0.22) ? 0.70 : 0.85; <br> float mulParam = lerp(1, param, paramZ); <br> <br> //  <br> pout.RT0.rgb = albedoColor * mulParam; <br> pout.RT0.a = cb4_v2.x;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem Auspacken der normalen Karte und binden dann wie √ºblich die Normalen: </font><font style="vertical-align: inherit;">Bisher nichts √úberraschendes. </font><i><font style="vertical-align: inherit;">Schauen Sie sich die Zeilen 28-33 an:</font></i><font style="vertical-align: inherit;"> Wir k√∂nnen sie grob wie folgt schreiben: </font><font style="vertical-align: inherit;">Nicht sicher, ob das Schreiben korrekt ist. </font><font style="vertical-align: inherit;">Wenn Sie wissen, was diese mathematische Operation ist, lassen Sie es mich wissen. </font><font style="vertical-align: inherit;">Wir sehen, dass der Pixel-Shader SV_IsFrontFace verwendet.</font></font><br><br> <code>/*  */ <br> float3 sampledNormal = ((normalTex.xyz - 0.5) * 2); <br> <br> //     TBN <br> float3 Tangent = Input.TangentW.xyz; <br> float3 Normal = Input.NormalW.xyz; <br> float3 Bitangent; <br> Bitangent.x = Input.out0.w; <br> Bitangent.yz = Input.out1.zw; <br> <br> //      ;  ,  ,   normal-tbn <br> //      'mad'   'mov' <br> Bitangent = saturate(Bitangent); <br> <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> float3 normal = mul( sampledNormal, TBN );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <i><font style="vertical-align: inherit;"></font></i> <br><br> <code>28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>[branch] if (bIsFrontFace &lt;= 0) <br> { <br> float cosTheta = dot(Input.NormalW, normal); <br> float3 invNormal = cosTheta * Input.NormalW; <br> normal = normal - 2*invNormal; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br>  Was ist das?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hilft </font><font style="vertical-align: inherit;">mir (ich wollte "msdn" schreiben, aber ...):</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legt fest, ob das Dreieck auf die Kamera schaut. </font><font style="vertical-align: inherit;">F√ºr Linien und Punkte gilt IsFrontFace. </font><font style="vertical-align: inherit;">Eine Ausnahme bilden die aus Dreiecken gezogenen Linien (Drahtgittermodus), die IsFrontFace √§hnlich wie das Rasteren eines Dreiecks im durchgezogenen Modus festlegen. </font><font style="vertical-align: inherit;">Das Schreiben darauf kann von einem Geometrie-Shader und das Lesen von einem Pixel-Shader erfolgen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wollte es selbst ausprobieren. </font><font style="vertical-align: inherit;">Tats√§chlich macht sich der Effekt nur im Drahtgittermodus bemerkbar. </font><font style="vertical-align: inherit;">Ich glaube, dieser Code wird f√ºr die korrekte Berechnung von Normalen (und damit der Beleuchtung) im Drahtgittermodus ben√∂tigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ein Vergleich: Sowohl die Farben des Rahmens der fertigen Szene mit diesem Trick ein / aus als auch die Textur der gbuffer [0-1] -Normalen mit dem Trick ein / aus:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/46b/81b/59846b81b8b9ed57f0441f29e22e6656.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Szenenfarbe ohne Spielerei</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/590/7e1/a97/5907e1a978e58b6fa362ef2e4b6187a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbszene mit Stunt</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/09a/c0e/74509ac0e56fa639ec4ae2d70a39be44.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal [0-1] kein Trick</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/2f8/622/db82f86223182135807d316fe479ff08.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal [0-1] mit einem Trick</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Haben Sie bemerkt, dass jedes Renderziel in GBuffer das Format R8G8B8A8_UNORM hat? Dies bedeutet, dass es 256 m√∂gliche Werte pro Komponente gibt. Reicht das aus, um Normalen zu speichern? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Speichern hochwertiger Normalen mit gen√ºgend Bytes in Gbuffer ist ein bekanntes Problem, aber zum Gl√ºck gibt es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viele </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verschiedene </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materialien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aus denen man </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lernen kann</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht wissen einige von Ihnen bereits, welche Technik hier verwendet wird. Ich muss sagen, dass im gesamten Durchgang der Geometrie eine zus√§tzliche Textur an Steckplatz 13 angebracht ist ...:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/e4a/0bf/ab1e4a0bf128bfed8837d3cd081748f8.jpg"></div><br><br>  Ha!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Witcher 3 verwendet eine Technik namens " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Best Fit Normals</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Hier werde ich es nicht im Detail erkl√§ren (siehe Pr√§sentation). </font><font style="vertical-align: inherit;">Es wurde zwischen 2009 und 2010 von Crytek erfunden. Da CryEngine Open Source hat, ist BFN auch </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open Source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFN verleiht der Textur der Normalen ein "k√∂rniges" Aussehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Normalen mit BFN skaliert haben, codieren wir sie vom Intervall [-1; 1] bis [0, 1] neu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiegel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit Zeile 34 und probieren Sie die Spiegelstruktur aus: </font><font style="vertical-align: inherit;">Wie Sie sehen, gibt es einen Dimmfilter, den wir von Albedo kennen: Wir </font><font style="vertical-align: inherit;">berechnen die Komponente mit max. </font><font style="vertical-align: inherit;">Wert, und berechnen Sie dann die ‚Äûabgedunkelte‚Äú Farbe und interpolieren Sie sie mit der urspr√ºnglichen Spiegelfarbe, wobei Sie den Parameter aus dem Vertex-Shader nehmen ... der 0 ist. Bei der Ausgabe erhalten wir also die Farbe aus der Textur. </font><font style="vertical-align: inherit;">HLSL:</font></font><br><br> <code>34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* SPECULAR */ <br> float3 specularTex = texture2.Sample( samplerAnisoWrap, Texcoords ).rgb; <br> <br> //   ,    Albedo.  . ,    <br> // -        "". <br> //      paramZ   0,    <br> //  . <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> float3 specB = (specularMaxComponent &gt; 0.2) ? specularTex : float3(0.12, 0.12, 0.12); <br> float3 finalSpec = lerp(specularTex, specB, paramZ); <br> pout.RT2.xyz = finalSpec;</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reflexionsverm√∂gen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe keine Ahnung, ob dieser Name f√ºr diesen Parameter geeignet ist, da ich nicht wei√ü, wie er den Durchgang der Beleuchtung beeinflusst. </font><font style="vertical-align: inherit;">Tatsache ist, dass der Alpha-Kanal der normalen Eingabekarte zus√§tzliche Daten enth√§lt:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/9e5/bd1/5d29e5bd1cb4888593139c38630e3f8e.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alpha-Kanal-Textur "normale Karte". </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembler-Code: </font><font style="vertical-align: inherit;">Begr√º√üen Sie unseren alten Freund - v0.z! </font><font style="vertical-align: inherit;">Seine Bedeutung ist √§hnlich wie Albedo und Spiegel:</font></font><br><br> <code>41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>/* REFLECTIVITY */ <br> float reflectivity = normalTex.a; <br> float reflectivity2 = (reflectivity &lt; 0.33) ? (reflectivity * 0.95) : 0.33; <br> <br> float finalReflectivity = lerp(reflectivity, reflectivity2, paramZ); <br> pout.RT1.a = finalReflectivity;</code> <br> <br>  Gro√üartig!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist das Ende der Analyse der ersten Version des Pixel-Shaders. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Vergleich meines Shaders (links) mit dem Original (rechts):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/f18/47b/2c1f1847b5ceef3cd0e2f8dfba45d2a6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Unterschiede wirken sich nicht auf die Berechnungen aus, sodass meine Arbeit hier abgeschlossen ist. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader: Albedo + Normal Option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich beschloss, eine weitere Option anzuzeigen, jetzt nur mit Albedo und normalen Karten, ohne spiegelnde Textur. Der Assembler-Code ist etwas l√§nger: </font><font style="vertical-align: inherit;">Der Unterschied zwischen dieser und den vorherigen Optionen ist wie folgt: </font><font style="vertical-align: inherit;">a) </font><b><font style="vertical-align: inherit;">Zeilen 1, 19</font></b><font style="vertical-align: inherit;"> : Der Interpolationsparameter v0.z wird mit cb4 [0] .x aus dem konstanten Puffer multipliziert, aber dieses Produkt wird nur f√ºr die Interpolationsalbedo in Zeile 19 verwendet. F√ºr andere Ausgaben wird der "normale" Wert von v0.z verwendet. </font><font style="vertical-align: inherit;">b) </font><b><font style="vertical-align: inherit;">Zeilen 54-55</font></b><font style="vertical-align: inherit;"> : o2.w wird nun unter der Bedingung gesetzt, dass (cb4 [7] .x&gt; 0.0) </font><font style="vertical-align: inherit;">dieses Muster ‚Äûeine Art Vergleich - UND‚Äú bereits aus der Berechnung des Helligkeitshistogramms erkennt. Es kann so geschrieben werden: </font><font style="vertical-align: inherit;">c) </font><b><font style="vertical-align: inherit;">Zeilen 34-42</font></b><font style="vertical-align: inherit;"> : eine v√∂llig andere Spiegelberechnung.</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 4 <br> 0: mul r0.x, v0.z, cb4[0].x <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyzw, v1.xyxx, t1.xyzw, s0 <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.yzw, v1.xyxx, t0.wxyz, s0 <br> 3: add r2.x, r0.z, r0.y <br> 4: add r2.x, r0.w, r2.x <br> 5: add r2.z, l(-1.000000), cb4[2].x <br> 6: mul r2.yz, r2.xxzx, l(0.000000, 0.333300, 0.500000, 0.000000) <br> 7: mov_sat r2.w, r2.z <br> 8: mad r2.x, r2.x, l(-0.666600), l(1.000000) <br> 9: mad r2.x, r2.w, r2.x, r2.y <br> 10: mul r3.xyz, r0.yzwy, cb4[1].xyzx <br> 11: mul_sat r3.xyz, r3.xyzx, l(1.500000, 1.500000, 1.500000, 0.000000) <br> 12: mul_sat r2.x, abs(r2.z), r2.x <br> 13: add r2.yzw, -r0.yyzw, r3.xxyz <br> 14: mad r0.yzw, r2.xxxx, r2.yyzw, r0.yyzw <br> 15: max r2.x, r0.w, r0.z <br> 16: max r2.x, r0.y, r2.x <br> 17: lt r2.x, l(0.220000), r2.x <br> 18: movc r2.x, r2.x, l(-0.300000), l(-0.150000) <br> 19: mad r0.x, r0.x, r2.x, l(1.000000) <br> 20: mul o0.xyz, r0.xxxx, r0.yzwy <br> 21: add r0.xyz, r1.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r0.xyw, v3.xyxz, r0.xxxx, r1.xyxz <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r0.xywx <br> 28: uge r0.w, l(0), v4.x <br> 29: if_nz r0.w <br> 30: dp3 r0.w, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r0.wwww, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx <br> 43: max r0.w, r1.z, r1.y <br> 44: max r0.w, r0.w, r1.x <br> 45: lt r0.w, l(0.200000), r0.w <br> 46: movc r2.xyz, r0.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 47: add r2.xyz, -r1.xyzx, r2.xyzx <br> 48: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 49: lt r0.w, r1.w, l(0.330000) <br> 50: mul r1.x, r1.w, l(0.950000) <br> 51: movc r0.w, r0.w, r1.x, l(0.330000) <br> 52: add r0.w, -r1.w, r0.w <br> 53: mad o1.w, v0.z, r0.w, r1.w <br> 54: lt r0.w, l(0), cb4[7].x <br> 55: and o2.w, r0.w, l(0.064706) <br> 56: dp3 r0.w, r0.xyzx, r0.xyzx <br> 57: rsq r0.w, r0.w <br> 58: mul r0.xyz, r0.wwww, r0.xyzx <br> 59: max r0.w, abs(r0.y), abs(r0.x) <br> 60: max r0.w, r0.w, abs(r0.z) <br> 61: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 62: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 63: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 64: lt r1.z, r1.y, r1.x <br> 65: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 66: div r1.z, r1.y, r1.x <br> 67: div r0.xyz, r0.xyzx, r0.wwww <br> 68: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 69: mul r0.xyz, r0.wwww, r0.xyzx <br> 70: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 71: mov o0.w, cb4[6].x <br> 72: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>pout.RT2.w = (cb4_v7.x &gt; 0.0) ? (16.5/255.0) : 0.0;</code> <br> <br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier gibt es keine spiegelnde Textur. </font><font style="vertical-align: inherit;">Schauen wir uns den Assembler-Code an, der f√ºr diesen Teil verantwortlich ist: </font><font style="vertical-align: inherit;">Beachten Sie, dass wir ihn hier verwendet haben (1 - reflektierte F√§higkeit). </font><font style="vertical-align: inherit;">Gl√ºcklicherweise ist das Schreiben in HLSL recht einfach: </font><font style="vertical-align: inherit;">Ich m√∂chte hinzuf√ºgen, dass in dieser Version der konstante Puffer mit Materialdaten etwas gr√∂√üer ist. </font><font style="vertical-align: inherit;">Hier werden diese zus√§tzlichen Werte verwendet, um die Spiegelfarbe zu emulieren. </font><font style="vertical-align: inherit;">Der Rest des Shaders ist der gleiche wie in der vorherigen Version. </font><font style="vertical-align: inherit;">72 Zeilen Assembler-Code sind zu viel, um in WinMerge angezeigt zu werden. Nehmen Sie also mein Wort: Mein Code war fast der gleiche wie im Original. </font><font style="vertical-align: inherit;">Oder Sie k√∂nnen meinen </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">und sich selbst davon </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">√ºberzeugen</font></a><font style="vertical-align: inherit;"> !</font></font><br><br> <code>34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>float oneMinusReflectivity = 1.0 - normalTex.a; <br> float3 specularTex = pow(cb4_v3.rgb, 2.2); <br> oneMinusReflectivity = oneMinusReflectivity * cb4_v4.x + cb4_v5.x; <br> specularTex = saturate(specularTex * oneMinusReflectivity); <br> specularTex = pow(specularTex, 1.0/2.2); <br> <br> //     ... <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> ...</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammenfassend </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... und wenn Sie es hier lesen, dann m√∂chten Sie wahrscheinlich etwas tiefer gehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was im wirklichen Leben einfach erscheint, ist oft nicht der Fall, und die Daten√ºbertragung zu gbuffer The Witcher 3 war keine Ausnahme. </font><font style="vertical-align: inherit;">Ich habe Ihnen nur die einfachsten Versionen der daf√ºr verantwortlichen Pixel-Shader gezeigt und auch allgemeine Beobachtungen gemacht, die sich auf die verz√∂gerte Schattierung im Allgemeinen beziehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr die meisten Patienten gibt es zwei Optionen f√ºr Pixel-Shader im Pastebin: </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option 1 - mit spiegelnder Textur </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option 2 - ohne spiegelnde Textur</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 10. Regenvorh√§nge in der Ferne </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Teil werden wir einen wunderbaren atmosph√§rischen Effekt betrachten, den ich wirklich mag - entfernte </font><font style="vertical-align: inherit;">Regen- / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lichtvorh√§nge</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der N√§he des Horizonts. </font><font style="vertical-align: inherit;">Im Spiel sind sie auf den Skellig-Inseln am einfachsten zu treffen.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VXt4PEEqV2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich pers√∂nlich mag dieses atmosph√§rische Ph√§nomen sehr und war gespannt, wie die Grafikprogrammierer von CD Projekt Red es implementiert haben. </font><font style="vertical-align: inherit;">Lass es uns herausfinden! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind zwei Screenshots vor und nach dem Anbringen der Regenvorh√§nge:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/62a/eb6/a9a62aeb6050efd2404f9d352fc89d33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu den Regenvorh√§ngen</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9aa/e43/fcf/9aae43fcf34413a4810778e101b8a209.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach den Vorh√§ngen des Regens</font></font></i> <br><br><h3>  Geometrie </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst konzentrieren wir uns auf die Geometrie. </font><font style="vertical-align: inherit;">Die Idee ist, einen kleinen Zylinder zu verwenden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc4/df3/add/fc4df3addf2524bc18f91c46a42fcd6a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Zylinder im lokalen Raum</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus Sicht seiner Position im lokalen Raum ist er ziemlich klein - seine Position liegt im Bereich (0,0 - 1,0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eingangsschaltung f√ºr diesen Draw-Aufruf sieht folgenderma√üen aus ...</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1d/a35/c00/c1da35c0080225e7a47d8010c42aeab8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes ist f√ºr uns hier wichtig: Texcoords und Instance_Transform. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texcoords werden ganz einfach gewickelt: U der oberen und unteren Basis liegen im Intervall [0.02777 - 1.02734]. V an der unteren Basis ist 1,0 und an der oberen - 0,0. Wie Sie sehen, k√∂nnen Sie dieses Netz ganz einfach auch prozedural erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir diesen kleinen Zylinder im lokalen Raum erhalten haben, multiplizieren wir ihn mit der Weltmatrix, die f√ºr jede Instanz des Eingabeelements INSTANCE_TRANSFORM bereitgestellt wird. Lassen Sie uns die Werte dieser Matrix √ºberpr√ºfen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e88/791/17e/e8879117edb6f1dd9b53d3e7334a22df.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adf/fb8/697/adffb8697a86ac86b935a00d6ae23dda.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/608/599/f6c/608599f6cf3930889c92df1a256991af.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sieht ziemlich be√§ngstigend aus, oder? </font><font style="vertical-align: inherit;">Aber keine Sorge, wir werden diese Matrix analysieren und sehen, was sie verbirgt! </font><font style="vertical-align: inherit;">Die Ergebnisse sind sehr interessant: </font><font style="vertical-align: inherit;">Es ist wichtig, die Kameraposition in diesem bestimmten Bild zu kennen: (-116.5338, 234.8695, 2.09) </font><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, haben wir den Zylinder so skaliert, dass er im Weltraum ziemlich gro√ü ist (in TW3 ist die Z-Achse nach oben gerichtet) und relativ zur Kameraposition verschoben und drehte sich um. </font><font style="vertical-align: inherit;">So sieht der Zylinder nach der Konvertierung mit dem Vertex-Shader aus:</font></font><br><br> <code>XMMATRIX mat( -227.7472, 159.8043, 374.0736, -116.4951, <br> -194.7577, -173.3836, -494.4982, 238.6908, <br> -14.16466, -185.4743, 784.564, -1.45565, <br> 0.0, 0.0, 0.0, 1.0 ); <br> <br> mat = XMMatrixTranspose( mat ); <br> <br> XMVECTOR vScale; <br> XMVECTOR vRotateQuat; <br> XMVECTOR vTranslation; <br> XMMatrixDecompose( &amp;vScale, &amp;vRotateQuat, &amp;vTranslation, mat ); <br> <br> //  ... <br> XMMATRIX matRotate = XMMatrixRotationQuaternion( vRotateQuat );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>vRotateQuat: (0.0924987569, -0.314900011, 0.883411944, -0.334462732) <br> <br> vScale: (299.999969, 300.000000, 1000.00012) <br> <br> vTranslation: (-116.495102, 238.690796, -1.45564997)</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f60/457/ca6/f60457ca61dd2d15ec3805b387e71def.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zylinder nach Umbau durch Vertex Shader. </font><font style="vertical-align: inherit;">Sehen Sie, wie es sich relativ zur Sichtbarkeitspyramide befindet.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertex-Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingabegeometrie und Vertex-Shader sind streng voneinander abh√§ngig. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns den Assembler-Code f√ºr den Vertex-Shader genauer an: </font><font style="vertical-align: inherit;">Neben der einfachen √úbergabe von Texcoords (Zeile 0) und Instance_LOD_Params (Zeile 8) werden zwei weitere Elemente f√ºr die Ausgabe ben√∂tigt: SV_Position (dies ist offensichtlich) und Height (Komponente .z) der Position in der Welt. </font><font style="vertical-align: inherit;">Denken Sie daran, dass der lokale Raum im Bereich [0-1] liegt? Kurz vor dem Anwenden der Weltmatrix verwendet der Vertex-Shader Skalierung und Abweichung, um die lokale Position zu √§ndern. Kluger Schachzug! </font><font style="vertical-align: inherit;">In diesem Fall ist scale = float3 (4, 4, 2) und Bias = float3 (-2, -2, -1). &lt; </font><font style="vertical-align: inherit;">Das Muster, das zwischen den Zeilen 9 und 28 erkennbar ist, ist die Multiplikation zweier Zeilenhauptmatrizen. </font><font style="vertical-align: inherit;">Schauen wir uns nur den fertigen Vertex-Shader in HLSL an:</font></font><br><br> <code>vs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb1[7], immediateIndexed <br> dcl_constantbuffer cb2[6], immediateIndexed <br> dcl_input v0.xyz <br> dcl_input v1.xy <br> dcl_input v4.xyzw <br> dcl_input v5.xyzw <br> dcl_input v6.xyzw <br> dcl_input v7.xyzw <br> dcl_output o0.xyz <br> dcl_output o1.xyzw <br> dcl_output_siv o2.xyzw, position <br> dcl_temps 2 <br> 0: mov o0.xy, v1.xyxx <br> 1: mul r0.xyzw, v5.xyzw, cb1[6].yyyy <br> 2: mad r0.xyzw, v4.xyzw, cb1[6].xxxx, r0.xyzw <br> 3: mad r0.xyzw, v6.xyzw, cb1[6].zzzz, r0.xyzw <br> 4: mad r0.xyzw, cb1[6].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 5: mad r1.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx <br> 6: mov r1.w, l(1.000000) <br> 7: dp4 o0.z, r1.xyzw, r0.xyzw <br> 8: mov o1.xyzw, v7.xyzw <br> 9: mul r0.xyzw, v5.xyzw, cb1[0].yyyy <br> 10: mad r0.xyzw, v4.xyzw, cb1[0].xxxx, r0.xyzw <br> 11: mad r0.xyzw, v6.xyzw, cb1[0].zzzz, r0.xyzw <br> 12: mad r0.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 13: dp4 o2.x, r1.xyzw, r0.xyzw <br> 14: mul r0.xyzw, v5.xyzw, cb1[1].yyyy <br> 15: mad r0.xyzw, v4.xyzw, cb1[1].xxxx, r0.xyzw <br> 16: mad r0.xyzw, v6.xyzw, cb1[1].zzzz, r0.xyzw <br> 17: mad r0.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 18: dp4 o2.y, r1.xyzw, r0.xyzw <br> 19: mul r0.xyzw, v5.xyzw, cb1[2].yyyy <br> 20: mad r0.xyzw, v4.xyzw, cb1[2].xxxx, r0.xyzw <br> 21: mad r0.xyzw, v6.xyzw, cb1[2].zzzz, r0.xyzw <br> 22: mad r0.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 23: dp4 o2.z, r1.xyzw, r0.xyzw <br> 24: mul r0.xyzw, v5.xyzw, cb1[3].yyyy <br> 25: mad r0.xyzw, v4.xyzw, cb1[3].xxxx, r0.xyzw <br> 26: mad r0.xyzw, v6.xyzw, cb1[3].zzzz, r0.xyzw <br> 27: mad r0.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 28: dp4 o2.w, r1.xyzw, r0.xyzw <br> 29: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>cbuffer cbPerFrame : register (b1) <br> { <br> row_major float4x4 g_viewProjMatrix; <br> row_major float4x4 g_rainShaftsViewProjMatrix; <br> } <br> <br> cbuffer cbPerObject : register (b2) <br> { <br> float4x4 g_mtxWorld; <br> float4 g_modelScale; <br> float4 g_modelBias; <br> } <br> <br> struct VS_INPUT <br> { <br> float3 PositionW : POSITION; <br> float2 Texcoord : TEXCOORD; <br> float3 NormalW : NORMAL; <br> float3 TangentW : TANGENT; <br> float4 InstanceTransform0 : INSTANCE_TRANSFORM0; <br> float4 InstanceTransform1 : INSTANCE_TRANSFORM1; <br> float4 InstanceTransform2 : INSTANCE_TRANSFORM2; <br> float4 InstanceLODParams : INSTANCE_LOD_PARAMS; <br> }; <br> <br> struct VS_OUTPUT <br> { <br> float3 TexcoordAndZ : Texcoord0; <br> <br> float4 LODParams : LODParams; <br> float4 PositionH : SV_Position; <br> }; <br> <br> VS_OUTPUT RainShaftsVS( VS_INPUT Input ) <br> { <br> VS_OUTPUT Output = (VS_OUTPUT)0; <br> <br> //    <br> Output.TexcoordAndZ.xy = Input.Texcoord; <br> Output.LODParams = Input.InstanceLODParams; <br> <br> //   <br> float3 meshScale = g_modelScale.xyz; // float3( 4, 4, 2 ); <br> float3 meshBias = g_modelBias.xyz; // float3( -2, -2, -1 ); <br> float3 PositionL = Input.PositionW * meshScale + meshBias; <br> <br> //    instanceWorld  float4s: <br> float4x4 matInstanceWorld = float4x4(Input.InstanceTransform0, Input.InstanceTransform1, <br> Input.InstanceTransform2 , float4(0, 0, 0, 1) ); <br> <br> //     (.z) <br> float4x4 matWorldInstanceLod = mul( g_rainShaftsViewProjMatrix, matInstanceWorld ); <br> Output.TexcoordAndZ.z = mul( float4(PositionL, 1.0), transpose(matWorldInstanceLod) ).z; <br> <br> // SV_Posiiton <br> float4x4 matModelViewProjection = mul(g_viewProjMatrix, matInstanceWorld ); <br> Output.PositionH = mul( float4(PositionL, 1.0), transpose(matModelViewProjection) ); <br> <br> return Output; <br> }</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergleich meines Shaders (links) und des Originals (rechts): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef3/4f3/4ed/ef34f34edbc63113a08f47b7cde00df0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschiede wirken sich nicht auf Berechnungen aus. </font><font style="vertical-align: inherit;">Ich habe meinen Shader in den Rahmen gespritzt und alles war noch in Ordnung!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixel Shader </font></font></h3><br>  Endlich!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu Beginn zeige ich Ihnen die Eingabe: Hier werden </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei Texturen verwendet: die Rauschtextur und der Tiefenpuffer:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83a/558/fc3/83a558fc3c8c7e723eb85308b12657d6.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/0da/111/db50da111880f6b934d8bed6b74491e6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werte aus konstanten Puffern: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a12/394/bdc/a12394bdc039e522beeff97b8e41cd80.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37a/c47/485/37ac47485335960b2efbefc9f315ef14.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/e70/38a/4e7e7038a1bc956aadbb695d70b80ded.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/775/bc4/7ae775bc4a9388feceaa1ddf8c0a214a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und der Pixel-Shader-Assembler-Code: </font><font style="vertical-align: inherit;">Wow! Ziemlich viel, aber in der Tat ist nicht alles so schlecht. </font><font style="vertical-align: inherit;">Was ist hier los? Zun√§chst berechnen wir animierte UVs anhand der verstrichenen Zeit aus cbuffer (cb0 [0] .x) und scale / offset. Diese Texcoords werden zum Abtasten aus der Rauschtextur verwendet (Zeile 2). </font><font style="vertical-align: inherit;">Nachdem wir den Rauschwert von der Textur erhalten haben, interpolieren wir zwischen den Min / Max-Werten (normalerweise 0 und 1). </font><font style="vertical-align: inherit;">Dann multiplizieren wir zum Beispiel mit der Koordinate der Textur V (denken Sie daran, dass die Koordinate V von 1 nach 0 geht?) - Zeile 5. </font><font style="vertical-align: inherit;">So haben wir die ‚ÄûHelligkeitsmaske‚Äú berechnet - es sieht so aus:</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[8], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s15, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t15 <br> dcl_input_ps linear v0.xyz <br> dcl_input_ps linear v1.w <br> dcl_input_ps_siv v2.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 1 <br> 0: mul r0.xy, cb0[0].xxxx, cb4[5].xyxx <br> 1: mad r0.xy, v0.xyxx, cb4[4].xyxx, r0.xyxx <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t0.xyzw, s0 <br> 3: add r0.y, -cb4[2].x, cb4[3].x <br> 4: mad_sat r0.x, r0.x, r0.y, cb4[2].x <br> 5: mul r0.x, r0.x, v0.y <br> 6: mul r0.x, r0.x, v1.w <br> 7: mul r0.x, r0.x, cb4[1].x <br> 8: mul r0.yz, v2.xxyx, cb0[1].zzwz <br> 9: sample_l(texture2d)(float,float,float,float) r0.y, r0.yzyy, t15.yxzw, s15, l(0) <br> 10: mad r0.y, r0.y, cb12[22].x, cb12[22].y <br> 11: mad r0.y, r0.y, cb12[21].x, cb12[21].y <br> 12: max r0.y, r0.y, l(0.000100) <br> 13: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 14: add r0.y, r0.y, -v0.z <br> 15: mul_sat r0.y, r0.y, cb4[6].x <br> 16: mul_sat r0.x, r0.y, r0.x <br> 17: mad r0.y, cb0[7].y, r0.x, -r0.x <br> 18: mad r0.x, cb4[7].x, r0.y, r0.x <br> 19: mul r0.xyz, r0.xxxx, cb4[0].xyzx <br> 20: log r0.xyz, r0.xyzx <br> 21: mul r0.xyz, r0.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 22: exp r0.xyz, r0.xyzx <br> 23: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 24: mul o0.xyz, r0.xyzx, cb2[2].wwww <br> 25: mov o0.w, l(0) <br> 26: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/1a8/801/0641a88012fb6ec18797c0b143fb5f27.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass entfernte Objekte (ein Leuchtturm, Berge ...) verschwunden sind. </font><font style="vertical-align: inherit;">Dies geschah, weil der Zylinder den Tiefentest besteht - der Zylinder befindet sich nicht in der Fernebene und wird auf diese Objekte gezeichnet:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/8f5/ffd/1068f5ffde6b0efba2c4894b88d5ddf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefentest</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir m√∂chten simulieren, dass der Regenvorhang weiter entfernt ist (aber nicht unbedingt auf der anderen Ebene). </font><font style="vertical-align: inherit;">Dazu berechnen wir eine andere Maske, die "Maske entfernter Objekte". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird nach folgender Formel berechnet: </font></font><br><br> <code>farObjectsMask = saturate( (FrustumDepth - CylinderWorldSpaceHeight) * 0.001 );</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0,001 wird aus dem Puffer entnommen), wodurch wir die gew√ºnschte Maske erhalten:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/02a/153/9ff02a1534054fb27b370d5cd58e7a75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(In dem Teil √ºber den Sch√§rfeeffekt habe ich bereits oberfl√§chlich erkl√§rt, wie die Tiefe der Sichtbarkeitspyramide aus dem Tiefenpuffer extrahiert wird.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pers√∂nlich scheint es mir, dass dieser Effekt kosteng√ºnstiger realisiert werden k√∂nnte, ohne die H√∂he im Weltraum zu berechnen, indem beispielsweise die Tiefe der Sichtbarkeitspyramide mit einer kleineren Zahl multipliziert wird 0,0004. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn beide Masken multipliziert werden, erh√§lt man die letzte:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c49/fb2/c1e/c49fb2c1e1dd2ee8d38d81c0cccb0daf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir diese endg√ºltige Maske erhalten haben (Zeile 16), f√ºhren wir eine weitere Interpolation durch, die (zumindest im getesteten Fall) fast nichts bewirkt, multiplizieren dann die endg√ºltige Maske mit der Farbe der Vorh√§nge (Zeile 19) und f√ºhren eine Gammakorrektur durch (Zeilen 20) -22) und endg√ºltige Multiplikationen (23-24). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende geben wir eine Farbe mit einem Alpha-Wert von Null zur√ºck. Dies liegt daran, dass das Mischen in diesem Durchgang aktiviert ist: </font></font><br><br> <code>FinalColor = SourceColor * 1.0 + (1.0 - SourceAlpha) * DestColor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie nicht </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genau </font><font style="vertical-align: inherit;">verstehen, wie das Mischen funktioniert, finden Sie hier eine kurze Erkl√§rung: </font><font style="vertical-align: inherit;">SourceColor ist die RGB-Ausgabe des Pixel-Shaders und DestColor ist die aktuelle RGB-Farbe des Pixels im Renderziel . Da SourceAlpha immer auf 0,0 gleich, reduziert sich </font><font style="vertical-align: inherit;">die obige Gleichung zu: </font></font><code>FinalColor = SourceColor + DestColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfach ausgedr√ºckt, hier f√ºhren wir ein additives Mischen durch. </font><font style="vertical-align: inherit;">Wenn der Pixel-Shader zur√ºckkehrt (0, 0, 0), bleibt die Farbe gleich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist der fertige HLSL-Code - ich denke, dass es nach der Erkl√§rung viel einfacher zu verstehen sein wird: </font><font style="vertical-align: inherit;">Ich kann gl√ºcklich sagen, dass mein Pixel-Shader den gleichen Assembler-Code wie im Original erstellt. </font><font style="vertical-align: inherit;">Ich hoffe dir hat der Artikel gefallen. </font><font style="vertical-align: inherit;">Danke f√ºrs Lesen!</font></font><br><br> <code>struct VS_OUTPUT <br> { <br> float3 TexcoordAndWorldspaceHeight : Texcoord0; <br> float4 LODParams : LODParams; // float4(1,1,1,1) <br> float4 PositionH : SV_Position; <br> }; <br> <br> float getFrustumDepth( in float depth ) <br> { <br> // from [1-0] to [0-1] <br> float d = depth * cb12_v22.x + cb12_v22.y; <br> <br> // special coefficents <br> d = d * cb12_v21.x + cb12_v21.y; <br> <br> // return frustum depth <br> return 1.0 / max(d, 1e-4); <br> } <br> <br> float4 EditedShaderPS( in VS_OUTPUT Input ) : SV_Target0 <br> { <br> // * Input from Vertex Shader <br> float2 InputUV = Input.TexcoordAndWorldspaceHeight.xy; <br> float WorldHeight = Input.TexcoordAndWorldspaceHeight.z; <br> float LODParam = Input.LODParams.w; <br> <br> // * Inputs <br> float elapsedTime = cb0_v0.x; <br> float2 uvAnimation = cb4_v5.xy; <br> float2 uvScale = cb4_v4.xy; <br> float minValue = cb4_v2.x; // 0.0 <br> float maxValue = cb4_v3.x; // 1.0 <br> float3 shaftsColor = cb4_v0.rgb; // RGB( 147, 162, 173 ) <br> <br> float3 finalColorFilter = cb2_v2.rgb; // float3( 1.175, 1.296, 1.342 ); <br> float finalEffectIntensity = cb2_v2.w; <br> <br> float2 invViewportSize = cb0_v1.zw; <br> <br> float depthScale = cb4_v6.x; // 0.001 <br> <br> // sample noise <br> float2 uvOffsets = elapsedTime * uvAnimation; <br> float2 uv = InputUV * uvScale + uvOffsets; <br> float disturb = texture0.Sample( sampler0, uv ).x; <br> <br> // * Intensity mask <br> float intensity = saturate( lerp(minValue, maxValue, disturb) ); <br> intensity *= InputUV.y; // transition from (0, 1) <br> intensity *= LODParam; // usually 1.0 <br> intensity *= cb4_v1.x; // 1.0 <br> <br> // Sample depth <br> float2 ScreenUV = Input.PositionH.xy * invViewportSize; <br> float hardwareDepth = texture15.SampleLevel( sampler15, ScreenUV, 0 ).x; <br> float frustumDepth = getFrustumDepth( hardwareDepth ); <br> <br> <br> // * Calculate mask covering distant objects behind cylinder. <br> <br> // Seems that the input really is world-space height (.z component, see vertex shader) <br> float depth = frustumDepth - WorldHeight; <br> float distantObjectsMask = saturate( depth * depthScale ); <br> <br> // * calculate final mask <br> float finalEffectMask = saturate( intensity * distantObjectsMask ); <br> <br> // cb0_v7.y and cb4_v7.x are set to 1.0 so I didn't bother with naming them :) <br> float paramX = finalEffectMask; <br> float paramY = cb0_v7.y * finalEffectMask; <br> float effectAmount = lerp(paramX, paramY, cb4_v7.x); <br> <br> // color of shafts comes from contant buffer <br> float3 effectColor = effectAmount * shaftsColor; <br> <br> // gamma correction <br> effectColor = pow(effectColor, 2.2); <br> <br> // final multiplications <br> effectColor *= finalColorFilter; <br> effectColor *= finalEffectIntensity; <br> <br> // return with zero alpha 'cause the blending used here is: <br> // SourceColor * 1.0 + (1.0 - SrcAlpha) * DestColor <br> return float4( effectColor, 0.0 ); <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437100/">https://habr.com/ru/post/de437100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437088/index.html">F√∂rderung eines Startups im Ausland: Wie man mit Medium Hunderttausende englischsprachiger Leser erreicht</a></li>
<li><a href="../de437092/index.html">Die Sicherheit von Algorithmen f√ºr maschinelles Lernen. Python-Angriffe</a></li>
<li><a href="../de437094/index.html">Wir haben den Atlassian Service Desk gepumpt - die Ank√ºndigung des Mitaps und der Live-√úbertragung</a></li>
<li><a href="../de437096/index.html">UDB. Was ist das Teil 4. Datenpfad ALU</a></li>
<li><a href="../de437098/index.html">6. Februar, Moskau, DI Telegraph - Gro√üe QIWI-K√ºche zum Thema Produktdesign</a></li>
<li><a href="../de437102/index.html">Neues Lego-Champion-Treffen: Lego Boost</a></li>
<li><a href="../de437104/index.html">Introskop: Nun, sehr fauler Unit-Test</a></li>
<li><a href="../de437106/index.html">IT in der Zone .it</a></li>
<li><a href="../de437108/index.html">Die meisten Texte im Internet werden von Verr√ºckten geschrieben.</a></li>
<li><a href="../de437110/index.html">Nanomaterialien ver√§ndern unsere Welt, und wir haben immer noch keine Verfahren zur √úberpr√ºfung ihrer Sicherheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>