<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ âœ¡ï¸ ğŸ’´ Cara membuat bentuk khusus menggunakan MaterialShapeDrawable ğŸ¥Œ â†–ï¸ ğŸ‘©ğŸ½â€ğŸš’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Material Design 2.0 memperkenalkan beberapa konsep baru. Salah satunya adalah perhatian khusus pada bentuk geometris elemen antarmuka. Dan ada cara mu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara membuat bentuk khusus menggunakan MaterialShapeDrawable</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/426997/"><img src="https://habrastorage.org/getpro/habr/post_images/585/f26/743/585f267433530ce6e9add3c7de072e35.jpg" alt="gambar"><br><br><p>  Material Design 2.0 memperkenalkan beberapa konsep baru.  Salah satunya adalah perhatian khusus pada bentuk geometris elemen antarmuka.  Dan ada cara mudah untuk membuat bentuk kustom yang indah.  Ini disebut MaterialShapeDrawable.  Mari kita lihat betapa bermanfaat dan mudahnya menggunakannya. </p><a name="habracut"></a><br><p>  Ada beberapa cara untuk menambahkan elemen grafis ke layar aplikasi Android.  Yang paling mudah adalah mengimpor bitmap dalam format webp atau png.  Pilihan lain adalah menggunakan VectorDrawable, yang memungkinkan Anda untuk meregangkan gambar ke ukuran yang Anda butuhkan.  Cara lain untuk menambahkan gambar ke layar adalah dengan menggunakan ShapeDrawable.  Yang terakhir adalah cara termudah untuk menambahkan latar belakang sederhana atau bahkan membuat ikon.  Gambar yang dibuat dengan ShapeDrawable tidak tergantung pada kerapatan piksel pada layar.  Mereka dapat dijelaskan dalam file xml, menjadi bagian dari sumber daya grafis lain (misalnya, StateListDrawable) dan hadir di Android SDK, dimulai dengan API v.1. </p><br><p>  Untuk mengubah tampilan gambar, kita bisa mengubah beberapa properti ShapeDrawable: nama gambar, warna isi (atau gradien), dan warna batas gambar.  Untuk persegi panjang, Anda juga dapat mengatur jari-jari sudut.  Dengan menggunakan properti ini, Anda dapat membuat grafik yang akan digunakan sebagai gambar individual di layar, pembagi, latar belakang tombol, atau untuk tujuan lain apa pun.  Jika aplikasi menggunakan API v.21 + dan ShapeDrawable sebagai latar belakang untuk elemen dengan elevasi, maka bayangan di bawah elemen ini juga akan memiliki bentuk yang benar: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/456/6b3/fd7/4566b3fd778a1edfdcce710510d1a2c4.png" alt="gambar"></p><br><p>  ShapeDrawable adalah alat praktis yang hampir selalu melakukan tugasnya dengan baik, tetapi dengan munculnya Material Design 2.0, pengembang membutuhkan sesuatu yang lebih fleksibel.  Sistem desain baru mendorong penggunaan berbagai bentuk untuk menekankan makna, kondisi, dan gaya aplikasi individu.  Saya menulis di atas bahwa ada beberapa cara untuk melakukan yang diinginkan, tetapi yang paling sederhana tidak lagi relevan.  Apakah ini berarti bahwa kita perlu mulai menggunakan grafik vektor dan dengan demikian kehilangan kemampuan untuk "membebaskan" membuat bayangan untuk elemen antarmuka dengan elevasi?  Atau apakah layak untuk kembali menggunakan gambar raster dan membuat sumber daya grafis untuk enam kemungkinan kerapatan piksel pada layar?  Untungnya, dengan munculnya Material Design 2.0, perpustakaan komponen yang benar-benar baru telah muncul. </p><br><p> Perpustakaan ini dibuat untuk menyatukan penampilan dan perilaku UI Desain Bahan pada semua versi Android dan platform lainnya (ada versi perpustakaan ini untuk iOS, web dan untuk Flutter).  Pustaka komponen mengimplementasikan banyak fitur untuk Desain Material baru.  Sebagai contoh, ini termasuk komponen BottomAppBar dengan perilaku yang diharapkan.  Di antara komponen dan utilitas lain, ada kelas MaterialShapeDrawable.  Menurut pendapat saya, ini adalah alat yang diperlukan untuk menyelesaikan tugas-tugas yang diajukan sistem desain baru untuk pengembang. </p><br><p>  Meskipun MaterialShapeDrawable masih dianggap eksperimental dalam rilis pustaka 1.0.0, ini dapat digunakan untuk membuat efek keren dalam aplikasi.  Di kelas MaterialShapeDrawable, Anda bisa mendeskripsikan bentuk dengan menentukan tampilan sisinya dan masing-masing sudutnya.  Properti yang ditentukan ini dapat dikontrol oleh interpolator, yang memungkinkan mereka untuk hidup. </p><br><p>  Untuk membuat MaterialShapeDrawable Anda sendiri, Anda bisa menggunakan konstruktor yang Anda harus melewati objek tipe ShapePathModel di parameter.  Ini menyimpan informasi tentang masing-masing sisi dan setiap sudut gambar di kelas EdgeTreatment dan CornerTreatment, masing-masing (selalu ada empat sisi dan sudut, tetapi ini tidak mengganggu menggambarkan hampir semua angka dengan bantuan mereka).  Anda dapat menentukan deskripsi secara pribadi untuk setiap sisi dan sudut, atau mengaturnya sekaligus untuk seluruh gambar dengan memanggil satu metode. </p><br><p>  Sudah ada beberapa deskripsi siap pakai (perawatan) sisi dan sudut di perpustakaan, yang mencakup sebagian besar inovasi mengenai bentuk komponen yang diperkenalkan dalam Material Design 2.0.  Sudah ada: RoundedCornerTreatment - untuk sudut bulat, CutCornerTreatment - untuk sudut potong, TriangleEdgeTreatment - untuk memotong atau menambahkan segitiga ke samping.  Untuk menunjukkan karya mereka, ada contoh sederhana: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> shapePathModel = ShapePathModel().apply { setAllCorners(CutCornerTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat())) setAllEdges(TriangleEdgeTreatment(dip(<span class="hljs-number"><span class="hljs-number">5</span></span>).toFloat(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> backgroundDrawable = MaterialShapeDrawable(shapePathModel).apply { setTint(ContextCompat.getColor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MainActivity</span></span>, R.color.colorPrimary)) paintStyle = Paint.Style.FILL } textView.background = backgroundDrawable</code> </pre> <br><p>  Ini akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/02b/b43/168/02bb431689af8046223fd77e58fd0f2a.png" alt="gambar"></p><br><p>  Tentu saja, Anda cukup membuat deskripsi wajah dan sudut Anda sendiri.  Bentuknya selalu diatur untuk elemen kiri atas, dan Drawable akan melakukan operasi rotasi / refleksi untuk mendapatkan bentuk selesai.  Ada contoh kecil untuk menunjukkan ini: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CutoutCornersTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : CornerTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCornerPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(angle: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.reset(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, size * interpolation) shapePath.lineTo(size * interpolation, size * interpolation) shapePath.lineTo(size * interpolation, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurvedEdgeTreatment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>) : EdgeTreatment() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEdgePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(length: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, interpolation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">, shapePath: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ShapePath</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { shapePath.quadToPoint(length / <span class="hljs-number"><span class="hljs-number">2f</span></span>, size * interpolation, length, <span class="hljs-number"><span class="hljs-number">0f</span></span>) } }</code> </pre> <br><p>  Jika MaterialShapeDrawable ini digunakan sebagai latar belakang, maka hasilnya akan seperti ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/98a/5b5/671/98a5b56711a7a3cec44ed62c459deaf2.png" alt="gambar"></p><br><p>  Paket bottomappbar dari Perpustakaan Komponen Bahan baru memiliki BottomAppBarTopEdgeTreatment.  Ini menjelaskan guntingan di BottomAppBar untuk tombol FloatingActionButton.  Sisi atasnya dapat dianimasikan tergantung pada posisi dan ukuran tombol.  Saya menyarankan Anda untuk membaca kode dari kelas-kelas ini untuk melihat dengan mata kepala Anda sendiri bahwa MaterialShapeDrawable sangat fleksibel untuk digunakan dan hampir semuanya dapat dilakukan dengan itu. </p><br><p>  Jika kita berbicara tentang ShapeDrawable yang biasa, ada detail lain yang layak disebut - kemampuan untuk melemparkan bayangan bentuk yang sesuai dengan kontur.  Karena Anda sekarang dapat membuat garis bentuk yang sangat tidak biasa menggunakan MaterialShapeDrawable, akan mengecewakan jika tidak membawa bentuk bayangan ke bentuk gambar, terutama ketika bayangan ini dapat dilihat di mana-mana di Matarial Design 2.0.  MaterialShapeDrawable juga menghitung penampilan bayangan.  Menggunakan properti shadowEnabled, Anda dapat mengaktifkan bayangan, yang persis akan mengikuti garis besar gambar itu sendiri, juga dimungkinkan untuk menentukan jari-jari, ketinggian dan warna bayangan.  Kedengarannya terlalu bagus untuk menjadi kenyataan?  Sayangnya ya.  Jika Anda menggunakan bayangan MaterialShapeDrawable, Anda mendapatkan bayangan normal (digambar oleh metode setShadowLayer () dari kelas Paint, yang dibuat untuk menggambar bayangan pada teks), tetapi dipotong ke perbatasan komponen UI di mana hasilnya ditampilkan: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e8b/134/5aae8b1341f9adabf86daaefeccb09fa.png" alt="gambar"></p><br><p>  Perlu diingat bahwa MaterialShapeDrawable masih dianggap eksperimental, seperti API-nya, dan dapat berubah di masa mendatang.  Penting juga dicatat bahwa kode untuk pustaka Komponen Material baru terbuka, jadi membuat tiket di pelacak bug atau bahkan menarik permintaan dengan memperbaiki masalah yang diketahui sangat disambut.  Bahkan, ketika Anda membaca baris-baris ini, API sudah sedikit berbeda di cabang utama perpustakaan (misalnya, ShapeAppearanceModel akan digunakan sebagai ganti ShapePathModel), yang menunjukkan pekerjaan aktif.  Salah satu fitur yang menjanjikan dalam rilis berikutnya mungkin adalah kemampuan untuk menentukan sisi / sudut default untuk keseluruhan tema aplikasi.  Anda dapat mempelajari lebih lanjut tentang ini dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> atau sumber perpustakaan. </p><br><blockquote>  <em>Dari penerjemah:</em> <br>  <em>Sangat keren bahwa ada alat yang menambahkan fitur baru ke ShapeDrawable yang biasa dan membantu untuk membuat bukan grafik yang paling sederhana.</em>  <em>Hal ini memungkinkan pengembang untuk tidak menarik desainer untuk setiap hal kecil, tetapi untuk menyelesaikan masalah sendiri, dan membutuhkan waktu yang jauh lebih sedikit.</em>  <em>Kami sedang menunggu versi berikutnya dari pustaka Komponen Material untuk mencoba dalam praktiknya cara-cara baru untuk menyelesaikan masalah yang ada.</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426997/">https://habr.com/ru/post/id426997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426985/index.html">kubebox dan cangkang konsol lainnya untuk Kubernetes</a></li>
<li><a href="../id426987/index.html">Pelajari OpenGL. Pelajaran 6.3 - Pencahayaan Berbasis Gambar. Iradiasi difus</a></li>
<li><a href="../id426991/index.html">Startup Digest: 10 acara IT mendatang di Moskow</a></li>
<li><a href="../id426993/index.html">Apakah saya perlu belajar C untuk memahami cara kerja komputer?</a></li>
<li><a href="../id426995/index.html">Daur ulang membahayakan produk dan karyawan</a></li>
<li><a href="../id426999/index.html">Mengikuti tren, atau bergerak menuju RxJava dan LiveData</a></li>
<li><a href="../id427003/index.html">Hexagon maps in Unity: kabut perang, riset peta, pembuatan prosedural</a></li>
<li><a href="../id427005/index.html">Pengembang AI - profesi jutawan?</a></li>
<li><a href="../id427009/index.html">"Berjalan" dari elektron: manipulasi dengan muatan di dalam struktur ikatan tak jenuh</a></li>
<li><a href="../id427011/index.html">"Hello World!" pada FPGA atau versi UART berikutnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>