<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§–ğŸ¼ ğŸ‘¨ğŸ¾â€ğŸ’¼ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ Disjuntor Istio: Desconecte Recipientes Quebrados ğŸ‘Ÿ ğŸ‘ŠğŸ¼ ğŸ‘†ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As fÃ©rias terminaram e estamos voltando com nosso segundo post na sÃ©rie Istio Service Mesh. 



 O tÃ³pico de hoje Ã© o disjuntor, que, traduzido para o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Disjuntor Istio: Desconecte Recipientes Quebrados</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/483262/">  As fÃ©rias terminaram e estamos voltando com nosso segundo post na sÃ©rie Istio Service Mesh. <br><br><img src="https://habrastorage.org/webt/vb/9o/rl/vb9orlnb9lwiilx0aknfy1ikqs0.png" width="100%"><br><br>  O tÃ³pico de hoje Ã© o disjuntor, que, traduzido para o russo como eletrotÃ©cnico, significa "disjuntor", em linguagem comum - "disjuntor".  Somente no Istio esta mÃ¡quina desconecta nÃ£o circuitos em curto ou sobrecarregados, mas recipientes com defeito. <br><a name="habracut"></a><br><h3>  Como deve funcionar idealmente </h3><br>  Quando os microsserviÃ§os sÃ£o gerenciados pelo Kubernetes, por exemplo, como parte da plataforma OpenShift, eles aumentam e diminuem automaticamente, dependendo da carga.  Como os microsserviÃ§os funcionam em pods, pode haver vÃ¡rias instÃ¢ncias de microsserviÃ§o em contÃªiner em um ponto de extremidade, e o Kubernetes encaminharÃ¡ solicitaÃ§Ãµes e equilibrarÃ¡ a carga entre elas.  E - idealmente - tudo isso deve funcionar perfeitamente. <br><br>  Lembramos que os microsserviÃ§os sÃ£o pequenos e efÃªmeros.  A efemeridade, que aqui significa a simplicidade da emergÃªncia e do desaparecimento, Ã© frequentemente subestimada.  O nascimento e a morte da prÃ³xima instÃ¢ncia do microsserviÃ§o em pod sÃ£o bastante esperados, o OpenShift e o Kubernetes fazem isso bem, e tudo funciona muito bem - mas, novamente, em teoria. <br><br><h3>  Como isso realmente funciona </h3><br>  Agora imagine que uma instÃ¢ncia especÃ­fica do microsserviÃ§o, ou seja, o contÃªiner, se tornou inutilizÃ¡vel: ele nÃ£o responde (erro 503) ou, o que Ã© mais desagradÃ¡vel, reage, mas muito lentamente.  Em outras palavras, ele silencia ou nÃ£o responde Ã s solicitaÃ§Ãµes, mas nÃ£o o remove automaticamente do pool.  O que deve ser feito neste caso?  Tentar de novo?  RemovÃª-lo do esquema de roteamento?  E o que significa "muito lento" - quanto custa em nÃºmeros e quem os determina?  Talvez apenas lhe dÃª uma pausa e tente mais tarde?  Se sim, quanto tempo depois? <br><br><h3>  O que Ã© EjeÃ§Ã£o de Piscina no Istio </h3><br>  E aqui o Istio vem em socorro com seus disjuntores, que removem temporariamente contÃªineres defeituosos do pool de recursos de roteamento e balanceamento de carga, implementando o procedimento de EjeÃ§Ã£o de Pool. <br><br>  Usando uma estratÃ©gia de detecÃ§Ã£o externa, o Istio detecta curvas de pods que sÃ£o eliminadas da linha geral e as remove do pool de recursos por um determinado perÃ­odo, chamado de â€œjanela de suspensÃ£oâ€. <br><br>  Para mostrar como isso funciona no Kubernetes na plataforma OpenShift, comeÃ§amos com uma captura de tela dos microsserviÃ§os que normalmente funcionam do exemplo no repositÃ³rio <a href="https://github.com/redhat-developer-demos/istio-tutorial">Red Hat Developer Demos</a> .  Aqui temos dois pods, v1 e v2, em cada um dos quais um contÃªiner funciona.  Quando as regras de roteamento do Istio nÃ£o sÃ£o usadas, o Kubernetes, por padrÃ£o, aplica o roteamento round-robin uniformemente equilibrado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bh/b0/dr/bhb0drqlbvo9j0ataogejcgpwue.png"></div><br><h3>  Preparando-se para uma falha </h3><br>  Antes de executar a EjeÃ§Ã£o de Pool, vocÃª deve criar uma regra de roteamento do Istio.  Suponha que desejemos distribuir solicitaÃ§Ãµes entre os pods em relaÃ§Ã£o a 50/50.  AlÃ©m disso, aumentaremos o nÃºmero de contÃªineres v2 de um para dois, assim: <br><br><pre><code class="plaintext hljs">oc scale deployment recommendation-v2 --replicas=2 -n tutorial</code> </pre> <br>  Agora, definimos uma regra de roteamento para que o trÃ¡fego seja distribuÃ­do entre os pods em uma proporÃ§Ã£o de 50/50. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w2/51/pz/w251pzvoaokm49bpul5ehfwsewm.png"></div><br>  E aqui estÃ¡ o resultado desta regra: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/22/ww/wy22wwbkg2vync-id4jbhv22ftk.png"></div><br>  Ã‰ possÃ­vel reclamar que nesta tela nÃ£o Ã© 50/50, mas 14: 9, mas com o tempo a situaÃ§Ã£o vai melhorar. <br><br><h3>  NÃ³s organizamos uma falha </h3><br>  E agora desabilitaremos um dos dois contÃªineres v2 para que tenhamos um contÃªiner Ã­ntegro v1, um contÃªiner Ã­ntegro v2 e um contÃªiner com falha v2: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/or/0x/w1/or0xw1jvinlrjkmz3lnttvdh0zo.png"></div><br><h3>  Corrigir a falha </h3><br>  Portanto, temos um contÃªiner com defeito e Ã© hora da EjeÃ§Ã£o do Pool.  Usando uma configuraÃ§Ã£o muito simples, excluiremos esse contÃªiner com falha de qualquer esquema de roteamento por 15 segundos, na expectativa de que ele retorne a um estado Ã­ntegro (serÃ¡ reiniciado ou restaurarÃ¡ o desempenho).  Aqui estÃ¡ a aparÃªncia dessa configuraÃ§Ã£o e os resultados de seu trabalho: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/6u/7e/xz6u7emeucpeqn6ozq7rnsibtxy.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/m6/3t/ykm63tdppq-qphkyhikilfcwkai.png"></div><br>  Como vocÃª pode ver, o contÃªiner com falha v2 nÃ£o Ã© mais usado no roteamento de solicitaÃ§Ãµes, pois foi removido do pool.  Mas, apÃ³s 15 segundos, ele retornarÃ¡ automaticamente para a piscina.  Na verdade, apenas mostramos como a EjeÃ§Ã£o de Pool funciona. <br><br><h3>  Comece a construir a arquitetura </h3><br>  A EjeÃ§Ã£o de Pool, combinada aos recursos de monitoramento do Istio, permite que vocÃª comece a criar uma estrutura para substituir automaticamente os contÃªineres defeituosos para reduzir ou atÃ© mesmo eliminar o tempo de inatividade e as falhas. <br><br>  A NASA tem um lema de alto nÃ­vel - Failure Is Not a Option, de autoria do diretor de vÃ´o <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D0%25BD%25D1%2586,_%25D0%2594%25D0%25B6%25D0%25B8%25D0%25BD">Gene Krantz</a> .  Pode ser traduzido para o russo como "Derrota nÃ£o Ã© uma opÃ§Ã£o", e o ponto aqui Ã© que tudo pode ser feito para funcionar com vontade suficiente.  No entanto, na vida real, as falhas nÃ£o acontecem apenas, sÃ£o inevitÃ¡veis, em todos os lugares e em tudo.  E como lidar com eles no caso de microsserviÃ§os?  Em nossa opiniÃ£o, Ã© melhor confiar nÃ£o na forÃ§a de vontade, mas nas capacidades dos contÃªineres, <a href="https://developers.redhat.com/topics/kubernetes/">Kubernetes</a> , <a href="https://developers.redhat.com/products/openshift/overview/">Red Hat OpenShift</a> e <a href="https://developers.redhat.com/topics/service-mesh/">Istio</a> . <br><br>  Istio, como escrevemos acima, implementa o conceito de disjuntores, que se provou no mundo fÃ­sico.  E assim como uma mÃ¡quina automÃ¡tica desconecta uma parte problemÃ¡tica de um circuito, o disjuntor do software no Istio desconecta a conexÃ£o entre o fluxo de solicitaÃ§Ã£o e o contÃªiner do problema quando algo estÃ¡ errado com o terminal, por exemplo, quando o servidor trava ou comeÃ§a a desacelerar. <br><br>  AlÃ©m disso, no segundo caso, existem apenas mais problemas, jÃ¡ que os freios de um contÃªiner nÃ£o apenas causam uma cascata de atrasos nos serviÃ§os que o acessam e, como resultado, reduzem o desempenho do sistema como um todo, mas tambÃ©m causam solicitaÃ§Ãµes repetidas ao serviÃ§o que jÃ¡ estÃ¡ lento, o que apenas agrava a situaÃ§Ã£o. . <br><br><h3>  Disjuntor em teoria </h3><br>  O disjuntor Ã© um proxy que controla o fluxo de solicitaÃ§Ãµes para o terminal.  Quando esse ponto pÃ¡ra de funcionar ou, dependendo das configuraÃ§Ãµes, comeÃ§a a ficar mais lento, o proxy se desconecta do contÃªiner.  O trÃ¡fego Ã© entÃ£o redirecionado para outros contÃªineres, bem, apenas por causa do balanceamento de carga.  A conexÃ£o permanece aberta (aberta) por uma determinada janela de suspensÃ£o, por exemplo, dois minutos e, em seguida, Ã© considerada semiaberta (semiaberta).  Tentar enviar a prÃ³xima solicitaÃ§Ã£o determina o estado adicional da comunicaÃ§Ã£o.  Se tudo estiver bem com o serviÃ§o, a conexÃ£o retornarÃ¡ ao estado operacional e novamente serÃ¡ fechada.  Se ainda houver algo errado com o serviÃ§o, a conexÃ£o serÃ¡ aberta e a janela de suspensÃ£o serÃ¡ reativada.  Aqui estÃ¡ a aparÃªncia do diagrama simplificado de estados do disjuntor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qg/0g/z4/qg0gz47wjymiayq4bgshfsrceyy.png"></div><br>  Ã‰ importante observar aqui que tudo isso acontece no nÃ­vel da arquitetura do sistema, por assim dizer.  Portanto, em algum momento, vocÃª precisarÃ¡ ensinar seus aplicativos a trabalhar com o disjuntor, por exemplo, fornecer um valor padrÃ£o em resposta ou, se possÃ­vel, ignorar a existÃªncia do serviÃ§o.  Um padrÃ£o de antepara Ã© usado para isso, mas estÃ¡ alÃ©m do escopo deste artigo. <br><br><h3>  Disjuntor na prÃ¡tica </h3><br>  Por exemplo, lanÃ§aremos no OpenShift duas versÃµes do nosso microsserviÃ§o de recomendaÃ§Ãµes.  A versÃ£o 1 funcionarÃ¡ bem, mas na v2 criaremos um atraso para simular os freios no servidor.  Para visualizar os resultados, use a ferramenta de <a href="https://github.com/JoeDog/siege">cerco</a> : <br><br><pre> <code class="plaintext hljs">siege -r 2 -c 20 -v customer-tutorial.$(minishift ip).nip.io</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/qa/e_/knqae_n13cpibc7tc9lk7fc5lqq.png"></div><br>  Tudo parece funcionar, mas a que custo?  Ã€ primeira vista, temos 100% de disponibilidade, mas observe mais de perto - a duraÃ§Ã£o mÃ¡xima da transaÃ§Ã£o Ã© de atÃ© 12 segundos.  Isso Ã© claramente um gargalo e precisa ser bordado. <br><br>  Para fazer isso, usaremos o Istio para eliminar o acesso a contÃªineres lentos.  Aqui estÃ¡ a aparÃªncia da configuraÃ§Ã£o correspondente usando o Disjuntor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eh/ld/f4/ehldf4gh5qxkwqckn3naufhfs2a.png"></div><br>  A Ãºltima linha com o parÃ¢metro httpMaxRequestsPerConnection sinaliza que a conexÃ£o com deve abrir ao tentar criar mais uma - a segunda - conexÃ£o alÃ©m da existente.  Como nosso contÃªiner imita um serviÃ§o de frenagem, essas situaÃ§Ãµes ocorrem periodicamente, e o Istio retornarÃ¡ um erro 503, e aqui estÃ¡ o que o cerco mostrarÃ¡: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/9h/g5/vv9hg56bzoliqjb6tay19as6mn0.png"></div><br><h3>  OK, temos disjuntor, o que vem a seguir? </h3><br>  Por isso, implementamos um desligamento automÃ¡tico, sem tocar no cÃ³digo fonte dos prÃ³prios serviÃ§os.  Usando o disjuntor e o procedimento de ejeÃ§Ã£o de pool descrito acima, podemos remover os contÃªineres de freio do pool de recursos atÃ© que retornem ao normal e verificar seu status com a frequÃªncia especificada - em nosso exemplo, sÃ£o dois minutos (parÃ¢metro sleepWindow). <br><br>  Observe que a capacidade do aplicativo de responder ao erro 503 ainda estÃ¡ definida no nÃ­vel do seu cÃ³digo-fonte.  Existem muitas estratÃ©gias para trabalhar com o disjuntor, que sÃ£o aplicadas dependendo da situaÃ§Ã£o. <br><br>  <b>No prÃ³ximo post:</b> falaremos sobre rastreamento e monitoramento, que jÃ¡ sÃ£o integrados ou facilmente adicionados ao Istio, alÃ©m de como introduzir intencionalmente erros no sistema. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt483262/">https://habr.com/ru/post/pt483262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt483252/index.html">Maximalismo juvenil e o espÃ­rito de contradiÃ§Ã£o em adolescentes do ponto de vista da neurologia</a></li>
<li><a href="../pt483254/index.html">Nos bastidores da vida de um moderador de estouro de pilha</a></li>
<li><a href="../pt483256/index.html">Uma compilaÃ§Ã£o de fatos estatÃ­sticos divertidos # 3</a></li>
<li><a href="../pt483258/index.html">Plataformas de baixo cÃ³digo: uma panacÃ©ia ou uma aposta arriscada?</a></li>
<li><a href="../pt483260/index.html">Como tomar decisÃµes e priorizar tarefas ao criar um produto</a></li>
<li><a href="../pt483264/index.html">Dijkstra: A maior vitÃ³ria do Ocidente na Guerra Fria sobre a URSS foi a transiÃ§Ã£o para a IBM - mito quebrado</a></li>
<li><a href="../pt483266/index.html">IndependÃªncia financeira. O que mudou ao longo do ano</a></li>
<li><a href="../pt483268/index.html">O livro "Moda, fÃ©, fantasia e a nova fÃ­sica do universo"</a></li>
<li><a href="../pt483270/index.html">A evoluÃ§Ã£o dos aplicativos HighLoad no exemplo de um portal regional de serviÃ§os pÃºblicos</a></li>
<li><a href="../pt483272/index.html">O caminho do negÃ³cio de restaurantes para a empresa de TI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>