<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¢ üíç üìπ Alto desempenho e particionamento nativo: Zabbix com suporte ao TimescaleDB üêÇ üåè üçÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Zabbix √© um sistema de monitoramento. Como qualquer outro sistema, ele enfrenta tr√™s problemas principais em todos os sistemas de monitoramento: col...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alto desempenho e particionamento nativo: Zabbix com suporte ao TimescaleDB</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/470902/">  O Zabbix √© um sistema de monitoramento.  Como qualquer outro sistema, ele enfrenta tr√™s problemas principais em todos os sistemas de monitoramento: coleta e processamento de dados, armazenamento de hist√≥rico e limpeza. <br><br>  As etapas de aquisi√ß√£o, processamento e grava√ß√£o de dados levam tempo.  N√£o √© muito, mas para um sistema grande, isso pode resultar em grandes atrasos.  O problema de armazenamento √© um problema de acesso a dados.  Eles s√£o usados ‚Äã‚Äãpara relat√≥rios, verifica√ß√µes e gatilhos.  Atrasos no acesso a dados tamb√©m afetam o desempenho.  Quando o banco de dados cresce, dados irrelevantes devem ser exclu√≠dos.  A remo√ß√£o √© uma opera√ß√£o dif√≠cil que tamb√©m consome alguns dos recursos. <br><br><img src="https://habrastorage.org/webt/jb/yy/zo/jbyyzopzw6gtfio8uhqbgushzo8.jpeg"><br><br>  Os problemas de atrasos durante a coleta e o armazenamento no Zabbix s√£o resolvidos atrav√©s do cache: v√°rios tipos de caches, cache no banco de dados.  Para resolver o terceiro problema, o armazenamento em cache n√£o √© adequado; portanto, o Zabbix usou o TimescaleDB.  <strong>Andrey Gushchin</strong> , engenheiro de suporte t√©cnico da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zabbix SIA,</a> falar√° sobre isso.  Andrey apoia o Zabbix h√° mais de 6 anos e est√° enfrentando diretamente o desempenho. <br><br>  Como o TimescaleDB funciona, qual desempenho ele pode oferecer em compara√ß√£o com o PostgreSQL comum?  Qual o papel do Zabbix no TimescaleDB?  Como executar a partir do zero e como migrar com o PostgreSQL e qual desempenho √© melhor?  Sobre tudo isso sob o corte. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/umRk94j5M8o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Desafios de desempenho </h2><br>  Cada sistema de monitoramento enfrenta desafios espec√≠ficos de desempenho.  Vou falar sobre tr√™s deles: coleta e processamento de dados, armazenamento, hist√≥rico de limpeza. <br><br>  <strong>R√°pida coleta e processamento de dados.</strong>  Um bom sistema de monitoramento deve receber rapidamente todos os dados e process√°-los de acordo com as express√µes de gatilho - de acordo com seus pr√≥prios crit√©rios.  Ap√≥s o processamento, o sistema tamb√©m deve salvar rapidamente esses dados no banco de dados para us√°-los posteriormente. <br><br>  <strong>Mantendo uma hist√≥ria.</strong>  Um bom sistema de monitoramento deve armazenar o hist√≥rico no banco de dados e fornecer acesso conveniente √†s m√©tricas.  √â necess√°ria uma hist√≥ria para us√°-la em relat√≥rios, gr√°ficos, gatilhos, limites e itens de dados calculados para alertas. <br><br>  <strong>Limpar hist√≥rico.</strong>  √Äs vezes chega um dia em que voc√™ n√£o precisa armazenar m√©tricas.  Por que voc√™ precisa dos dados coletados h√° 5 anos, um m√™s ou dois: alguns n√≥s s√£o exclu√≠dos, alguns hosts ou m√©tricas n√£o s√£o mais necess√°rios, porque est√£o desatualizados e pararam de coletar.  Um bom sistema de monitoramento deve armazenar dados hist√≥ricos e exclu√≠-los de tempos em tempos, para que o banco de dados n√£o cres√ßa. <br><br><blockquote>  A limpeza de dados desatualizados √© um problema importante que tem um grande impacto no desempenho do banco de dados. </blockquote><br><h2>  Cache do Zabbix </h2><br>  No Zabbix, a primeira e a segunda chamadas s√£o resolvidas usando o cache.  A RAM √© usada para coleta e processamento de dados.  Para armazenamento - hist√≥rias em gatilhos, gr√°ficos e elementos de dados calculados.  No lado do banco de dados, h√° um certo armazenamento em cache para as principais amostras, por exemplo, gr√°ficos. <br><br>  O armazenamento em cache na lateral do servidor Zabbix √©: <br><br><ul><li>  ConfigurationCache; </li><li>  ValueCache; </li><li>  HistoryCache; </li><li>  TrendsCache. </li></ul><br>  Vamos consider√°-los com mais detalhes. <br><br><h3>  ConfigurationCache </h3><br>  Esse √© o principal cache no qual armazenamos m√©tricas, hosts, elementos de dados, gatilhos - tudo o que √© necess√°rio para o Pr√©-processamento e a coleta de dados. <br><br><img src="https://habrastorage.org/webt/g0/zd/er/g0zderqgjgddgeq0frjdyvgj-q0.png"><br><br>  Tudo isso √© armazenado no ConfigurationCache para n√£o criar consultas desnecess√°rias no banco de dados.  Ap√≥s o in√≠cio do servidor, atualizamos esse cache, criamos e atualizamos periodicamente as configura√ß√µes. <br><br><h3>  Coleta de dados </h3><br>  O esquema √© bastante amplo, mas o principal √© os <strong>montadores</strong> .  Estes s√£o os v√°rios "pollers" - processos de montagem.  Eles s√£o respons√°veis ‚Äã‚Äãpor diferentes tipos de montagem: eles coletam dados via SNMP, IPMI e transferem tudo para o Pr√©-processamento. <br><br><img src="https://habrastorage.org/webt/z2/2r/jq/z22rjqgzyoam-61aadugsmowsbe.jpeg">  <em>Os coletores s√£o circulados em laranja.</em> <br><br>  O Zabbix calculou os elementos de dados de agrega√ß√£o necess√°rios para agregar valida√ß√µes.  Se os tivermos, coletamos os dados diretamente do ValueCache. <br><br><h3>  Hist√≥rico de Pr√©-ProcessamentoCache </h3><br>  Todos os coletores usam o ConfigurationCache para receber trabalhos.  Em seguida, eles os passam para o pr√©-processamento. <br><br><img src="https://habrastorage.org/webt/f9/f-/yc/f9f-ycupjcyofnnz20injlmynty.png"><br><br>  O pr√©-processamento usa o ConfigurationCache para receber as etapas de pr√©-processamento.  Ele processa esses dados de v√°rias maneiras. <br><br>  Depois de processar os dados usando o Pr√©-processamento, salvamos no HistoryCache para process√°-los.  Isso encerra a coleta de dados e seguimos para o processo principal no Zabbix - <strong>sincronizador de hist√≥rico</strong> , pois √© uma arquitetura monol√≠tica. <br><br>  <em>Nota: O pr√©-processamento √© uma opera√ß√£o bastante dif√≠cil.</em>  <em>Desde a vers√£o 4.2, ele foi enviado para proxy.</em>  <em>Se voc√™ possui um Zabbix muito grande com um grande n√∫mero de elementos de dados e uma frequ√™ncia de coleta, isso facilita muito o trabalho.</em> <br><br><h3>  Cache do ValueCache, hist√≥rico e tend√™ncias </h3><br><blockquote>  O sincronizador de hist√≥rico √© o principal processo que processa atomicamente cada elemento de dados, ou seja, cada valor. </blockquote><br>  O sincronizador de hist√≥rico obt√©m valores do HistoryCache e verifica na Configura√ß√£o os gatilhos para c√°lculos.  Se forem, ele calcula. <br><br>  O sincronizador de hist√≥rico cria um evento, uma escala√ß√£o para criar alertas, se necess√°rio pela configura√ß√£o, e registros.  Se houver gatilhos para processamento subseq√ºente, ele se lembrar√° desse valor no ValueCache para n√£o acessar a tabela de hist√≥rico.  Portanto, o ValueCache √© preenchido com dados necess√°rios para o c√°lculo de gatilhos, elementos calculados. <br><br>  O sincronizador de hist√≥rico grava todos os dados no banco de dados e √© gravado no disco.  O processo de processamento termina aqui. <br><br><img src="https://habrastorage.org/webt/u7/v0/08/u7v0080wzx7v_fh8ej-fas7b1wg.jpeg"><br><br><h3>  Armazenamento em cache do banco de dados </h3><br>  No lado do banco de dados, existem v√°rios caches quando voc√™ deseja assistir a gr√°ficos ou relat√≥rios de eventos: <br><br><ul><li> <code>Innodb_buffer_pool</code> no lado do MySQL; </li><li>  <code>shared_buffers</code> no lado do PostgreSQL; </li><li>  <code>effective_cache_size</code> no lado do Oracle; </li><li>  <code>shared_pool</code> no lado do DB2. </li></ul><br>  Existem muitos outros caches, mas esses s√£o os principais para todos os bancos de dados.  Eles permitem que voc√™ mantenha na mem√≥ria os dados que geralmente s√£o necess√°rios para consultas.  Eles t√™m suas pr√≥prias tecnologias para isso. <br><br><h3>  O desempenho do banco de dados √© cr√≠tico </h3><br>  O Zabbix-server constantemente coleta dados e os grava.  Ao reiniciar, ele tamb√©m l√™ o hist√≥rico para preencher o ValueCache.  Scripts e relat√≥rios usam a <strong>API</strong> do <strong>Zabbix</strong> , constru√≠da com base na interface da Web.  A API do Zabbix entra em contato com o banco de dados e recebe os dados necess√°rios para gr√°ficos, relat√≥rios, listas de eventos e problemas recentes. <br><br><img src="https://habrastorage.org/webt/b5/48/rc/b548rcjuhprytj6zcpi_buqdr2c.png"><br><br>  Para visualiza√ß√£o - <strong>Grafana</strong> .  Entre nossos usu√°rios, esta √© uma solu√ß√£o popular.  Ele pode enviar solicita√ß√µes diretamente pela API do Zabbix e para o banco de dados, al√©m de criar certa competitividade para o recebimento de dados.  Portanto, precisamos de um ajuste mais refinado e melhor do banco de dados para corresponder √† r√°pida produ√ß√£o de resultados e testes. <br><br><h2>  Governanta </h2><br>  O terceiro desafio de desempenho no Zabbix √© limpar a hist√≥ria com a governanta.  Ele segue todas as configura√ß√µes - os elementos de dados indicam quanto manter a din√¢mica das mudan√ßas (tend√™ncias) em dias. <br><br>  Computamos o TrendsCache em tempo real.  Quando os dados chegam, agregamos em uma hora e os escrevemos em tabelas para a din√¢mica das mudan√ßas de tend√™ncia. <br><br>  Governanta inicia e exclui informa√ß√µes do banco de dados com os "seletores" habituais.  Isso nem sempre √© eficaz, o que pode ser entendido a partir dos gr√°ficos de desempenho dos processos internos. <br><br><img src="https://habrastorage.org/webt/m0/3q/x_/m03qx_0sgbs_2bpjc_toewzmsbo.png"><br><br>  Um gr√°fico vermelho indica que o sincronizador de hist√≥rico est√° constantemente ocupado.  O gr√°fico laranja acima √© Governanta, que est√° em execu√ß√£o constante.  Ele espera que o banco de dados exclua todas as linhas que ele especificou. <br><br>  Quando desligar a governanta?  Por exemplo, existe um "ID do item" e voc√™ precisa excluir as √∫ltimas 5 mil linhas em um determinado per√≠odo de tempo.  Obviamente, isso acontece por √≠ndice.  Mas geralmente o conjunto de dados √© muito grande e o banco de dados ainda l√™ do disco e o eleva para o cache.  Essa sempre √© uma opera√ß√£o muito cara para o banco de dados e, dependendo do tamanho do banco de dados, pode levar a problemas de desempenho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/c4/y7/w4c4y7m_lwigpvwzq4bfsftktw8.png" width="500"></div><br><br>  Governanta √© apenas uma desconex√£o.  Na interface da Web, h√° uma configura√ß√£o no "Administra√ß√£o geral" para Governanta.  Desative a limpeza interna para o hist√≥rico de tend√™ncias interno e ele n√£o gerencia mais isso. <br><br>  A governanta foi desligada, os gr√°ficos foram nivelados - qual poderia ser o problema nesse caso e o que poderia ajudar na solu√ß√£o da terceira chamada de desempenho? <br><br><h2>  Particionamento - particionamento ou particionamento </h2><br>  Normalmente, o particionamento √© configurado de maneira diferente em cada banco de dados relacional listado.  Cada um tem sua pr√≥pria tecnologia, mas s√£o semelhantes, em geral.  Criar uma nova parti√ß√£o geralmente leva a certos problemas. <br><br>  As parti√ß√µes geralmente s√£o configuradas dependendo da "configura√ß√£o" - a quantidade de dados criados em um dia.  Como regra, o particionamento √© exposto em um dia, isso √© o m√≠nimo.  Para tend√™ncias da nova parti√ß√£o - por 1 m√™s. <br><br>  Os valores podem mudar no caso de uma "configura√ß√£o" muito grande.  Se a pequena "configura√ß√£o" for de at√© 5.000 nvps (novos valores por segundo), a m√©dia √© de 5.000 a 25.000, e a grande estar√° acima de 25.000 nvps.  Estas s√£o instala√ß√µes grandes e muito grandes que requerem uma configura√ß√£o cuidadosa do banco de dados. <br><br>  Em instala√ß√µes muito grandes, uma execu√ß√£o de um dia pode n√£o ser a ideal.  Eu vi no MySQL parti√ß√µes de 40 GB ou mais por dia.  Essa √© uma quantidade muito grande de dados que pode levar a problemas e precisa ser reduzida. <br><br><h3>  O que d√° o particionamento? </h3><br>  <strong>Tabelas de Particionamento</strong> .  Geralmente, esses s√£o arquivos separados no disco.  O plano de consulta seleciona melhor uma parti√ß√£o.  O particionamento geralmente √© usado em um intervalo - para o Zabbix, isso tamb√©m √© verdade.  Usamos l√° "timestamp" - tempo desde o in√≠cio da √©poca.  Temos n√∫meros comuns.  Voc√™ define o in√≠cio e o fim do dia - esta √© uma parti√ß√£o. <br><br>  <strong>Exclus√£o r√°pida</strong> - <code>DELETE</code> .  Um √∫nico arquivo / subtabela √© selecionado, n√£o uma sele√ß√£o de linhas a serem exclu√≠das. <br><br>  <strong>Visivelmente acelera a recupera√ß√£o de dados</strong> <code>SELECT</code> - usa uma ou mais parti√ß√µes, n√£o a tabela inteira.  Se voc√™ solicitar dados h√° dois dias, eles ser√£o selecionados no banco de dados mais rapidamente, pois voc√™ precisar√° carregar no cache e emitir apenas um arquivo, n√£o uma tabela grande. <br><br>  Muitas vezes, muitos bancos de dados tamb√©m aceleram inser√ß√µes <code>INSERT</code> na tabela filho. <br><br><h2>  Timescaledb </h2><br>  Para a v 4.2, voltamos nossa aten√ß√£o para o TimescaleDB.  Esta √© uma extens√£o para o PostgreSQL com uma interface nativa.  A extens√£o funciona efetivamente com dados de s√©ries temporais, sem perder os benef√≠cios dos bancos de dados relacionais.  O TimescaleDB tamb√©m particiona automaticamente. <br><br>  O TimescaleDB tem o conceito de uma <strong>hipertabela</strong> que voc√™ cria.  Ele cont√©m <strong>peda√ßos</strong> - parti√ß√µes.  Os peda√ßos s√£o fragmentos controlados automaticamente de uma hipertabela que n√£o afetam outros fragmentos.  Cada peda√ßo tem seu pr√≥prio intervalo de tempo. <br><br><img src="https://habrastorage.org/webt/0p/0g/mh/0p0gmhmshsg_htxuboh2w1xdmeo.jpeg"><br><br><h3>  TimescaleDB vs PostgreSQL </h3><br>  O TimescaleDB funciona realmente eficientemente.  Os fabricantes de extens√µes afirmam que usam um algoritmo de processamento de solicita√ß√£o mais correto, em particular, &lt;code&gt; insere &lt;/code&gt;.  Quando as dimens√µes da inser√ß√£o do conjunto de dados aumentam, o algoritmo mant√©m um desempenho constante. <br><br><img src="https://habrastorage.org/webt/_n/1v/vo/_n1vvoqc1hghllux5r_u7i_23q4.png"><br><br>  Depois de 200 milh√µes de linhas, o PostgreSQL geralmente come√ßa a ceder bastante e perde desempenho at√© 0. O TimescaleDB permite que voc√™ insira ‚Äúinser√ß√µes‚Äù com efici√™ncia para qualquer quantidade de dados. <br><br><h3>  Instala√ß√£o </h3><br>  A instala√ß√£o do TimescaleDB √© f√°cil o suficiente para qualquer pacote.  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> descreve tudo em detalhes - depende dos pacotes oficiais do PostgreSQL.  O TimescaleDB tamb√©m pode ser compilado e compilado manualmente. <br><br>  Para o banco de dados Zabbix, simplesmente ativamos a extens√£o: <br><br><pre> <code class="sql hljs">echo "<span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> EXTENSION <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> timescaledb <span class="hljs-keyword"><span class="hljs-keyword">CASCADE</span></span>;" | sudo -u postgres psql zabbix</code> </pre> <br>  Voc√™ ativa a <code>extension</code> e a cria para o banco de dados Zabbix.  O passo final √© criar uma hipertabela. <br><br><h3>  Migrando Tabelas de Hist√≥rico para o TimescaleDB </h3><br>  Existe uma fun√ß√£o especial <code>create_hypertable</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'history'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'history_unit'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'history_log'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'history_text'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'history_str'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'trends'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_hypertable(<span class="hljs-string"><span class="hljs-string">'trends_unit'</span></span>, <span class="hljs-string"><span class="hljs-string">'clock'</span></span>, chunk_time_interval =&gt; <span class="hljs-number"><span class="hljs-number">86400</span></span>, migrate_data =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> db_extension=<span class="hljs-string"><span class="hljs-string">'timescaledb'</span></span>, hk_history_global=<span class="hljs-number"><span class="hljs-number">1</span></span>, hk_trends_global=<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  A fun√ß√£o possui tr√™s par√¢metros.  A primeira √© uma <strong>tabela no banco</strong> de <strong>dados</strong> para a qual voc√™ precisa criar uma hipertabela.  O segundo √© o <strong>campo</strong> pelo qual criar <code>chunk_time_interval</code> - o intervalo dos blocos de parti√ß√µes que voc√™ deseja usar.  No meu caso, o intervalo √© de um dia - 86.400. <br><br>  O terceiro par√¢metro √© <code><strong>migrate_data</strong></code> .  Se definido como <code>true</code> , todos os dados atuais ser√£o transferidos para os peda√ßos criados anteriormente.  Eu mesmo usei <code>migrate_data</code> .  Eu tinha cerca de 1 TB, o que levou mais de uma hora.  Mesmo em alguns casos, ao testar, exclu√≠ os dados hist√≥ricos dos tipos de caracteres opcionais para armazenamento, para n√£o transferi-los. <br><br>  A √∫ltima etapa √© <code><strong>UPDATE</strong></code> : definimos <code>timescaledb</code> em <code>db_extension</code> para que o banco de dados entenda que existe essa extens√£o.  O Zabbix o ativa e usa corretamente a sintaxe e as consultas j√° existentes no banco de dados - os recursos necess√°rios para o TimescaleDB. <br><br><h2>  Configura√ß√£o de ferro </h2><br>  Eu usei dois servidores.  A primeira √© uma <strong>m√°quina VMware</strong> .  √â pequeno o suficiente: 20 processadores Intel¬Æ Xeon¬Æ E5-2630 v 4 a 2.20GHz, 16 GB de RAM e um SSD de 200 GB. <br><br>  Eu instalei o PostgreSQL 10.8 nele com o Debian 10.8-1.pgdg90 + 1 e o sistema de arquivos xfs.  Eu configurei tudo minimamente para usar esse banco de dados espec√≠fico, menos o que o pr√≥prio Zabbix usar√°. <br><br>  Na mesma m√°quina, havia um servidor Zabbix, PostgreSQL e <strong>agentes de carregamento</strong> .  Eu tinha 50 agentes ativos que usavam o <code>LoadableModule</code> para gerar rapidamente v√°rios resultados: n√∫meros, strings.  Entupi o banco de dados com muitos dados. <br><br>  Inicialmente, a configura√ß√£o continha <strong>5.000 itens de</strong> dados por host.  Quase todos os elementos continham um gatilho, parecendo instala√ß√µes reais.  Em alguns casos, houve mais de um gatilho.  Havia <strong>3.000 a 7.000 gatilhos por</strong> n√≥ de rede. <br><br>  O intervalo para atualizar itens de dados √© de <strong>4-7 segundos</strong> .  Regulei a carga em si, usando n√£o apenas 50 agentes, mas tamb√©m adicionando mais.  Al√©m disso, com a ajuda de elementos de dados, ajustei dinamicamente a carga e reduzi o intervalo de atualiza√ß√£o para 4 s. <br><br><h3>  PostgreSQL  35.000 nvps </h3><br>  A primeira execu√ß√£o neste hardware que tive no PostgreSQL puro - 35 mil valores por segundo.  Como voc√™ pode ver, a inser√ß√£o de dados leva fra√ß√µes de segundo - tudo est√° bem e r√°pido.  A √∫nica coisa que um SSD de 200 GB est√° sendo preenchido rapidamente. <br><br><img src="https://habrastorage.org/webt/wp/pk/vq/wppkvqe33kjs-udv8qc75jynloq.jpeg"><br><br>  Este √© o painel de desempenho padr√£o do servidor Zabbix. <br><br><img src="https://habrastorage.org/webt/nu/h1/jl/nuh1jlhlz3cyoxyrc94cybshjos.png"><br><br>  O primeiro gr√°fico azul √© o n√∫mero de valores por segundo.  O segundo gr√°fico √† direita √© o carregamento dos processos de montagem.  O terceiro est√° carregando os processos internos de montagem: sincronizadores de hist√≥rico e Governanta, que j√° est√° em execu√ß√£o h√° algum tempo. <br><br>  O quarto gr√°fico mostra o uso do HistoryCache.  Este √© um buffer antes de inserir no banco de dados.  O quinto gr√°fico verde mostra o uso do ValueCache, ou seja, quantas ocorr√™ncias do ValueCache para acionadores s√£o v√°rios milhares de valores por segundo. <br><br><h3>  PostgreSQL  50.000 nvps </h3><br>  Aumentei a carga para 50 mil valores por segundo no mesmo hardware. <br><br><img src="https://habrastorage.org/webt/wj/47/u6/wj47u6j2fycdpnx55-mrrqrwcp4.jpeg"><br><br>  Ao carregar do Governanta, uma inser√ß√£o de 10 mil valores foi registrada por 2-3 s. <br><br><img src="https://habrastorage.org/webt/fn/qo/go/fnqogopttou4hwlygqckfoieht0.png"><br>  <em>Governanta j√° est√° come√ßando a atrapalhar.</em> <br><br>  O terceiro gr√°fico mostra que, em geral, o carregamento de ca√ßadores e sincronizadores de hist√≥rico ainda est√° em 60%.  No quarto gr√°fico, o HistoryCache j√° come√ßa a se encher de maneira bastante ativa durante o trabalho de Governanta.  Est√° 20% cheio - √© cerca de 0,5 GB. <br><br><h3>  PostgreSQL  80.000 nvps </h3><br>  Aumentei a carga para 80 mil valores por segundo.  S√£o aproximadamente 400 mil elementos de dados e 280 mil gatilhos. <br><br><img src="https://habrastorage.org/webt/8q/zh/5z/8qzh5zsbwvouradg7j-qxeksqfi.jpeg"><br>  <em>A inser√ß√£o para carregar trinta sincronizadores de hist√≥rico j√° √© bastante alta.</em> <br><br>  Tamb√©m aumentei v√°rios par√¢metros: sincronizadores de hist√≥rico, caches. <br><br><img src="https://habrastorage.org/webt/xs/3m/ia/xs3miafccbymaddfyzzj2l4e494.png"><br><br>  No meu hardware, a carga dos sincronizadores de hist√≥rico aumentou ao m√°ximo.  O HistoryCache foi preenchido rapidamente com dados - os dados para processamento acumulados no buffer. <br><br>  Durante todo esse tempo, observei como o processador, a RAM e outros par√¢metros do sistema eram usados ‚Äã‚Äãe descobri que a utiliza√ß√£o do disco era maximizada. <br><br><img src="https://habrastorage.org/webt/zy/el/im/zyelimg6_immdsthjxburb1gjmw.jpeg"><br><br>  Tirei o <strong>m√°ximo proveito da unidade</strong> neste hardware e nesta m√°quina virtual.  Nessa intensidade, o PostgreSQL come√ßou a despejar dados de maneira bastante ativa, e o disco n√£o teve mais tempo para trabalhar na escrita e na leitura. <br><br><h3>  Segundo servidor </h3><br>  Peguei outro servidor que j√° tinha 48 processadores e 128 GB de RAM.  Ajuste - configure 60 sincronizadores de hist√≥rico e tenha um desempenho aceit√°vel. <br><br><img src="https://habrastorage.org/webt/hl/ae/ig/hlaeigh1dtxphardj6hkwmtas8w.png"><br><br>  De fato, esse j√° √© um limite de desempenho em que algo precisa ser feito. <br><br><h3>  TimescaleDB.  80.000 nvps </h3><br>  Minha principal tarefa √© testar os recursos do TimescaleDB a partir do carregamento do Zabbix.  80 mil valores por segundo √© muito, a frequ√™ncia de coleta de m√©tricas (exceto Yandex, √© claro) e uma "configura√ß√£o" bastante grande. <br><br><img src="https://habrastorage.org/webt/c-/45/yc/c-45yc-ctmrtj7o5td-ajwrtpdm.png"><br><br>  H√° uma falha em cada gr√°fico - isso √© apenas migra√ß√£o de dados.  Ap√≥s falhas no servidor Zabbix, o perfil de inicializa√ß√£o do sincronizador de hist√≥rico mudou muito - caiu tr√™s vezes. <br><br><blockquote>  O TimescaleDB permite inserir dados quase tr√™s vezes mais r√°pido e usar menos HistoryCache. </blockquote><br>  Consequentemente, os dados ser√£o entregues a voc√™ em tempo h√°bil. <br><br><h3>  TimescaleDB.  120.000 nvps </h3><br>  Aumentei o n√∫mero de elementos de dados para 500 mil. A principal tarefa era verificar os recursos do TimescaleDB - obtive o valor calculado de 125 mil valores por segundo. <br><br><img src="https://habrastorage.org/webt/hi/hd/ce/hihdcemwxqcqfxnv3n5-4ypmvic.png"><br><br>  Esta √© uma "configura√ß√£o" funcional que pode funcionar por um longo tempo.  Mas como meu disco tinha apenas 1,5 TB, eu o preenchi em alguns dias. <br><br><img src="https://habrastorage.org/webt/vk/51/wz/vk51wzryy45k4sycilxbcj-pjcq.png"><br><br>  Mais importante, ao mesmo tempo, novas parti√ß√µes do TimescaleDB foram criadas. <br><br>  Para desempenho, isso √© completamente invis√≠vel.  Quando parti√ß√µes s√£o criadas no MySQL, por exemplo, tudo √© diferente.  Geralmente isso acontece √† noite, porque bloqueia a inser√ß√£o geral, trabalhando com tabelas e pode criar degrada√ß√£o do servi√ßo.  No caso do TimescaleDB, n√£o √©. <br><br>  Por exemplo, mostrarei um gr√°fico do conjunto na comunidade.  O TimescaleDB est√° inclu√≠do na imagem, devido a isso a carga no uso de io.weight no processador caiu.  O uso de elementos de processos internos tamb√©m diminuiu.  E essa √© uma m√°quina virtual comum em discos de panqueca comuns, n√£o um SSD. <br><br><img src="https://habrastorage.org/webt/e6/bm/a-/e6bma-otl8o5mcrt9z8wkrsq5du.jpeg"><br><br><h2>  Conclus√µes </h2><br>  <strong>O TimescaleDB √© uma boa solu√ß√£o para pequenas "configura√ß√µes"</strong> que dependem do desempenho do disco.  Isso permitir√° que voc√™ continue trabalhando bem at√© que o banco de dados seja migrado para o ferro mais rapidamente. <br><br>  O TimescaleDB √© f√°cil de configurar, fornece um aumento de desempenho, funciona bem com o Zabbix e <strong>possui vantagens sobre o PostgreSQL</strong> . <br><br>  Se voc√™ usa o PostgreSQL e n√£o planeja alter√°-lo, recomendo <strong>usar o PostgreSQL com a extens√£o TimescaleDB em conjunto com o Zabbix</strong> .  Esta solu√ß√£o funciona de forma eficaz para a "configura√ß√£o" m√©dia. <br><br><blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dizemos</a> "alto desempenho" - queremos dizer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HighLoad ++</a> .  Esperando para se familiarizar com as tecnologias e pr√°ticas que permitem que os servi√ßos atendam a milh√µes de usu√°rios, muito brevemente.  J√° compilamos uma lista de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rios</a> para 7 e 8 de novembro, mas ainda podemos oferecer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mitaps</a> . <br><br>  Assine a nossa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">newsletter</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">telegrama</a> , na qual revelamos as fichas da pr√≥xima confer√™ncia e saiba como tirar o m√°ximo proveito dela. </p></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470902/">https://habr.com/ru/post/pt470902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470882/index.html">Por que voc√™ pegou meu mouse ou um jogo de tabuleiro como modelo de intera√ß√£o social</a></li>
<li><a href="../pt470884/index.html">Escrevendo e lendo dados no blockchain Bitcoin</a></li>
<li><a href="../pt470888/index.html">Legisla√ß√£o russa e internacional no campo da prote√ß√£o de dados pessoais</a></li>
<li><a href="../pt470892/index.html">Implementa√ß√£o simples de pequenas CAM no FPGA</a></li>
<li><a href="../pt470894/index.html">Bullet</a></li>
<li><a href="../pt470904/index.html">O caminho mais suave e peludo do aprendizado de m√°quina e das redes neurais profundas</a></li>
<li><a href="../pt470908/index.html">Pela primeira vez no mundo, com a ajuda de tecnologias aditivas, foi obtido um conjunto de motores de aeronaves de grande porte</a></li>
<li><a href="../pt470910/index.html">O que pode ser feito com anota√ß√µes de contratos de microsservi√ßo?</a></li>
<li><a href="../pt470916/index.html">O ponto de verifica√ß√£o eletr√¥nico "mais barato" na R√∫ssia controlado a partir de um smartphone</a></li>
<li><a href="../pt470918/index.html">F # 9: Op√ß√£o de tipo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>