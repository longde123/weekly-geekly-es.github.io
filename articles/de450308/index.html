<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☄️ 🐀 🚍 GPU Ray Tracing in Unity - Teil 3 👩‍🏭 🌈 🔆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Der erste und zweite Teil.] 


 Heute werden wir einen großen Sprung machen. Wir werden uns von ausschließlich sphärischen Strukturen und der unendl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU Ray Tracing in Unity - Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450308/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweite</a> Teil.] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a8a/4f2/f9fa8a4f2a79b8c394636de6a128d0d5.png"></div><br>  Heute werden wir einen großen Sprung machen.  Wir werden uns von ausschließlich sphärischen Strukturen und der unendlichen Ebene, die wir zuvor verfolgt haben, entfernen und Dreiecke hinzufügen - die ganze Essenz moderner Computergrafik, ein Element, aus dem alle virtuellen Welten bestehen.  Wenn Sie mit dem fortfahren möchten, was wir das letzte Mal beendet haben, verwenden Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code aus Teil 2</a> .  Den fertigen Code für das, was wir heute tun werden, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Fangen wir an! <br><br><h2>  Dreiecke </h2><br>  <em>Ein Dreieck</em> ist nur eine Liste von drei verbundenen <em>Scheitelpunkten</em> , von denen jeder seine eigene Position speichert und manchmal normal ist.  Die Reihenfolge der Durchquerung der Eckpunkte aus Ihrer Sicht bestimmt, was wir betrachten - die Vorder- oder Rückseite des Dreiecks.  Traditionell wird die „Front“ als Durchlaufreihenfolge gegen den Uhrzeigersinn betrachtet. <br><br>  Zunächst müssen wir feststellen können, ob und an welchem ​​Punkt der Strahl ein Dreieck schneidet.  Ein sehr beliebter (aber sicherlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht der einzige</a> ) Algorithmus zur Bestimmung des Schnittpunkts eines Strahls mit einem Dreieck wurde 1997 von den Herren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thomas Akenin-Meller</a> und Ben Trembor vorgeschlagen.  Weitere Informationen finden Sie in ihrem Artikel „Schnelle, minimale Speicher-Ray-Triangle-Kreuzung“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><a name="habracut"></a><br>  Der Code aus dem Artikel kann einfach auf den HLSL-Shader-Code portiert werden: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> EPSILON = <span class="hljs-number"><span class="hljs-number">1e-8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectTriangle_MT97</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, float3 vert0, float3 vert1, float3 vert2, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// find vectors for two edges sharing vert0 float3 edge1 = vert1 - vert0; float3 edge2 = vert2 - vert0; // begin calculating determinant - also used to calculate U parameter float3 pvec = cross(ray.direction, edge2); // if determinant is near zero, ray lies in plane of triangle float det = dot(edge1, pvec); // use backface culling if (det &lt; EPSILON) return false; float inv_det = 1.0f / det; // calculate distance from vert0 to ray origin float3 tvec = ray.origin - vert0; // calculate U parameter and test bounds u = dot(tvec, pvec) * inv_det; if (u &lt; 0.0 || u &gt; 1.0f) return false; // prepare to test V parameter float3 qvec = cross(tvec, edge1); // calculate V parameter and test bounds v = dot(ray.direction, qvec) * inv_det; if (v &lt; 0.0 || u + v &gt; 1.0f) return false; // calculate t, ray intersects triangle t = dot(edge2, qvec) * inv_det; return true; }</span></span></code> </pre> <br>  Um diese Funktion nutzen zu können, benötigen wir einen Strahl und drei Eckpunkte eines Dreiecks.  Der Rückgabewert gibt an, ob sich das Dreieck geschnitten hat.  Im Falle eines Schnittpunkts werden drei zusätzliche Werte berechnet: <code>t</code> beschreibt den Abstand entlang des Strahls zum Schnittpunkt, und <code>u</code> / <code>v</code> sind zwei der drei Schwerpunktkoordinaten, die die Position des Schnittpunkts auf dem Dreieck bestimmen (die letzte Koordinate kann als <code>w = 1 - u - v</code> berechnet werden).  Wenn Sie noch nicht mit Schwerpunktkoordinaten vertraut sind, lesen Sie deren hervorragende Erklärung auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scratchapixel</a> . <br><br>  Lassen Sie uns ohne allzu große Verzögerung ein Dreieck mit den im Code angegebenen Eckpunkten verfolgen!  Suchen Sie die <code>Trace</code> Funktion im Shader und fügen Sie das folgende Codefragment hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Trace single triangle float3 v0 = float3(-150, 0, -150); float3 v1 = float3(150, 0, -150); float3 v2 = float3(0, 150 * sqrt(2), -150); float t, u, v; if (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { if (t &gt; 0 &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = 0.00f; bestHit.specular = 0.65f * float3(1, 0.4f, 0.2f); bestHit.smoothness = 0.9f; bestHit.emission = 0.0f; } }</span></span></code> </pre> <br>  Wie gesagt, <code>t</code> speichert den Abstand entlang des Strahls, und wir können diesen Wert direkt verwenden, um den Schnittpunkt zu berechnen.  Die Normale, die für die Berechnung der korrekten Reflexion wichtig ist, kann unter Verwendung des Vektorprodukts von zwei beliebigen Kanten des Dreiecks berechnet werden.  Starten Sie den Spielemodus und bewundern Sie Ihr erstes nachgezeichnetes Dreieck: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/65a/a84/b2965aa84ae9d882e6c26f7f44da2af7.png"></div><br>  <strong>Übung:</strong> Versuchen Sie, die Position anhand der Schwerpunktkoordinaten und nicht anhand der Entfernung zu berechnen.  Wenn Sie alles richtig machen, sieht das glänzende Dreieck genauso aus wie zuvor. <br><br><h2>  Dreiecksnetze </h2><br>  Wir haben das erste Hindernis überwunden, aber das Verfolgen ganzer Maschen aus Dreiecken ist eine ganz andere Geschichte.  Zuerst müssen wir einige grundlegende Informationen über Netze lernen.  Wenn Sie sie kennen, können Sie den nächsten Absatz sicher überspringen. <br><br>  In der Computergrafik wird das Netz durch mehrere Puffer definiert, von denen die wichtigsten die <em>Scheitelpunkt-</em> und Indexpuffer sind.  <em>Der Scheitelpunktpuffer</em> ist eine Liste von 3D-Vektoren, die die Position jedes Scheitelpunkts im <em>Objektraum beschreiben</em> (dies bedeutet, dass solche Werte beim Verschieben, Drehen oder Skalieren eines Objekts nicht geändert werden müssen - sie werden mithilfe der Matrixmultiplikation im laufenden Betrieb vom <em>Objektraum</em> in <em>den Weltraum</em> konvertiert). .  <em>Ein Indexpuffer</em> ist eine Liste von Ganzzahlwerten, bei denen es sich um <em>Indizes handelt</em> , die auf den Scheitelpunktpuffer verweisen.  Alle drei Indizes bilden ein Dreieck.  Wenn der Indexpuffer beispielsweise die Form [0, 1, 2, 0, 2, 3] hat, hat er zwei Dreiecke: Das erste Dreieck besteht aus dem ersten, zweiten und dritten Scheitelpunkt im Scheitelpunktpuffer und das zweite Dreieck besteht aus dem ersten, dritten und vierte Spitzen.  Daher bestimmt der Indexpuffer auch die oben erwähnte Durchlaufreihenfolge.  Zusätzlich zu Scheitelpunktpuffern und -indizes können zusätzliche Puffer vorhanden sein, die jedem Scheitelpunkt andere Informationen hinzufügen.  Die gebräuchlichsten zusätzlichen Puffer speichern <em>Normalen</em> , <em>Texturkoordinaten</em> ( <em>Texcoords</em> oder einfach <em>UV genannt</em> ) sowie <em>Scheitelpunktfarben</em> . <br><br><h2>  Verwenden von GameObjects </h2><br>  Zunächst müssen wir herausfinden, welche GameObjects Teil des Raytracing-Prozesses werden sollen.  Eine naive Lösung wäre, einfach <code>FindObjectOfType&lt;MeshRenderer&gt;()</code> , aber etwas flexibleres und schnelleres zu tun.  <code>RayTracingObject</code> wir eine neue <code>RayTracingObject</code> Komponente hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RayTracingObject</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.RegisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.UnregisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br>  Diese Komponente wird jedem Objekt hinzugefügt, das wir für die Raytracing-Funktion verwenden möchten, und wird mit <code>RayTracingMaster</code> .  Fügen Sie dem Assistenten die folgenden Funktionen hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;RayTracingObject&gt; _rayTracingObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;RayTracingObject&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Add(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnregisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Remove(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Alles läuft gut - jetzt wissen wir, welche Objekte verfolgt werden müssen.  Aber der knifflige Teil geht weiter: Wir werden alle Daten aus Unity-Netzen (Matrix, Vertex-Puffer und Indizes - erinnern Sie sich an sie?) Sammeln, sie in unsere eigenen Datenstrukturen schreiben und in die GPU laden, damit der Shader sie verwenden kann.  Beginnen wir mit der Definition von Datenstrukturen und Puffern auf der C # -Seite im Assistenten: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MeshObject { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Matrix4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;MeshObject&gt; _meshObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MeshObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; _vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _meshObjectBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _vertexBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _indexBuffer;</code> </pre> <br>  ... und jetzt machen wir dasselbe im Shader.  Bist du daran gewöhnt? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MeshObject</span></span></span><span class="hljs-class"> {</span></span> float4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; }; StructuredBuffer&lt;MeshObject&gt; _MeshObjects; StructuredBuffer&lt;float3&gt; _Vertices; StructuredBuffer&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _Indices;</code> </pre> <br>  Datenstrukturen sind fertig und wir können sie mit realen Daten füllen.  Wir sammeln alle Eckpunkte aller Netze in einer großen <code>List&lt;Vector3&gt;</code> und alle Indizes in einer großen <code>List&lt;int&gt;</code> .  Es gibt keine Probleme mit den Scheitelpunkten, aber die Indizes müssen geändert werden, damit sie weiterhin auf den richtigen Scheitelpunkt in unserem großen Puffer zeigen.  Stellen Sie sich vor, wir haben bereits Objekte aus 1000 Eckpunkten hinzugefügt und fügen jetzt einen einfachen Netzwürfel hinzu.  Das erste Dreieck kann aus Indizes [0, 1, 2] bestehen. Da wir jedoch bereits 1000 Scheitelpunkte im Puffer hatten, müssen wir die Indizes verschieben, bevor wir dem Würfel Scheitelpunkte hinzufügen.  Das heißt, sie werden zu [1000, 1001, 1002].  So sieht es im Code aus: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RebuildMeshObjectBuffers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_meshObjectsNeedRebuilding) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _currentSample = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Clear all lists _meshObjects.Clear(); _vertices.Clear(); _indices.Clear(); // Loop over all objects and gather their data foreach (RayTracingObject obj in _rayTracingObjects) { Mesh mesh = obj.GetComponent&lt;MeshFilter&gt;().sharedMesh; // Add vertex data int firstVertex = _vertices.Count; _vertices.AddRange(mesh.vertices); // Add index data - if the vertex buffer wasn't empty before, the // indices need to be offset int firstIndex = _indices.Count; var indices = mesh.GetIndices(0); _indices.AddRange(indices.Select(index =&gt; index + firstVertex)); // Add the object itself _meshObjects.Add(new MeshObject() { localToWorldMatrix = obj.transform.localToWorldMatrix, indices_offset = firstIndex, indices_count = indices.Length }); } CreateComputeBuffer(ref _meshObjectBuffer, _meshObjects, 72); CreateComputeBuffer(ref _vertexBuffer, _vertices, 12); CreateComputeBuffer(ref _indexBuffer, _indices, 4); }</span></span></code> </pre> <br>  Wir rufen <code>RebuildMeshObjectBuffers</code> in der <code>OnRenderImage</code> Funktion auf und vergessen nicht, neue Puffer in <code>OnDisable</code> .  Hier sind zwei Hilfsfunktionen, die ich im obigen Code verwendet habe, um die Pufferbehandlung ein wenig zu vereinfachen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateComputeBuffer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ComputeBuffer buffer, List&lt;T&gt; data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do we already have a compute buffer? if (buffer != null) { // If no data or buffer doesn't match the given criteria, release it if (data.Count == 0 || buffer.count != data.Count || buffer.stride != stride) { buffer.Release(); buffer = null; } } if (data.Count != 0) { // If the buffer has been released or wasn't there to // begin with, create it if (buffer == null) { buffer = new ComputeBuffer(data.Count, stride); } // Set data on the buffer buffer.SetData(data); } } private void SetComputeBuffer(string name, ComputeBuffer buffer) { if (buffer != null) { RayTracingShader.SetBuffer(0, name, buffer); } }</span></span></code> </pre> <br>  Großartig, wir haben Puffer erstellt und sie sind mit den notwendigen Daten gefüllt!  Jetzt müssen wir dies nur noch dem Shader melden.  Fügen Sie <code>SetShaderParameters</code> den folgenden Code <code>SetShaderParameters</code> (und dank neuer <code>SetShaderParameters</code> können wir den Code des <code>SetShaderParameters</code> reduzieren): <br><br><pre> <code class="cs hljs">SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Spheres"</span></span>, _sphereBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_MeshObjects"</span></span>, _meshObjectBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Vertices"</span></span>, _vertexBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Indices"</span></span>, _indexBuffer);</code> </pre> <br>  Die Arbeit ist also langweilig, aber lassen Sie uns sehen, was wir gerade getan haben: Wir haben alle internen Daten der Netze (Matrix, Eckpunkte und Indizes) gesammelt, sie in eine bequeme und einfache Struktur gebracht und sie dann an die GPU gesendet, auf die wir uns jetzt freuen Sie können verwendet werden. <br><br><h2>  Netzverfolgung </h2><br>  Lassen wir ihn nicht warten.  Im Shader haben wir bereits den Trace-Code eines einzelnen Dreiecks, und das Netz besteht tatsächlich nur aus vielen Dreiecken.  Der einzige neue Aspekt hierbei ist, dass wir die Matrix verwenden, um die Scheitelpunkte vom Objektraum in den Weltraum mithilfe der integrierten <code>mul</code> Funktion (kurz für Multiplizieren) zu transformieren.  Die Matrix enthält die Translation, Rotation und Skalierung des Objekts.  Es hat eine Größe von 4 × 4, daher benötigen wir für die Multiplikation einen 4d-Vektor.  Die ersten drei Komponenten (x, y, z) werden aus dem Scheitelpunktpuffer entnommen.  Wir setzen die vierte Komponente (w) auf 1, weil es sich um einen Punkt handelt.  Wenn dies die Richtung wäre, würden wir 0 darin schreiben, um alle Übersetzungen und Skalierungen in der Matrix zu ignorieren.  Ist das verwirrend für dich?  Dann lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Tutorial</a> mindestens acht Mal.  Hier ist der Shader-Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectMeshObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, inout RayHit bestHit, MeshObject meshObject)</span></span></span><span class="hljs-function"> </span></span>{ uint offset = meshObject.indices_offset; uint count = offset + meshObject.indices_count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = offset; i &lt; count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { float3 v0 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v1 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v2 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t, u, v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; bestHit.specular = <span class="hljs-number"><span class="hljs-number">0.65f</span></span>; bestHit.smoothness = <span class="hljs-number"><span class="hljs-number">0.99f</span></span>; bestHit.emission = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } } } }</code> </pre> <br>  Wir sind nur einen Schritt davon entfernt, alles in Aktion zu sehen.  Lassen Sie uns die <code>Trace</code> Funktion ein wenig umstrukturieren und eine Spur von Netzobjekten hinzufügen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">RayHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray)</span></span></span><span class="hljs-function"> </span></span>{ RayHit bestHit = CreateRayHit(); uint count, stride, i; <span class="hljs-comment"><span class="hljs-comment">// Trace ground plane IntersectGroundPlane(ray, bestHit); // Trace spheres _Spheres.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectSphere(ray, bestHit, _Spheres[i]); } // Trace mesh objects _MeshObjects.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectMeshObject(ray, bestHit, _MeshObjects[i]); } return bestHit; }</span></span></code> </pre> <br><h2>  Ergebnisse </h2><br>  Das ist alles!  <code>RayTracingObject</code> wir einige einfache Netze hinzu (Unity- <code>RayTracingObject</code> sind in Ordnung), geben Sie ihnen die <code>RayTracingObject</code> Komponente und beobachten Sie die Magie.  <strong>Verwenden Sie noch keine</strong> detaillierten Netze (mehr als ein paar hundert Dreiecke)!  Unser Shader ist nicht optimiert, und wenn Sie es übertreiben, kann es Sekunden oder sogar Minuten dauern, bis mindestens ein Sample pro Pixel verfolgt wird.  Infolgedessen stoppt das System den GPU-Treiber, die Unity-Engine kann abstürzen und der Computer muss neu gestartet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/1d4/40e/c801d440e5a0a21f660b5a7e82e1b368.png"></div><br>  Beachten Sie, dass unsere Netze keine glatte, sondern flache Schattierung haben.  Da wir die Normalen der Eckpunkte noch nicht in den Puffer geladen haben, müssen wir ein Vektorprodukt ausführen, um die Normalen der Eckpunkte jedes Dreiecks zu erhalten.  Außerdem können wir nicht über den Bereich des Dreiecks interpolieren.  Wir werden uns im nächsten Teil des Tutorials mit diesem Problem befassen. <br><br>  Aus Gründen des Interesses habe ich Stanford Bunny aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Morgan McGwire-Archiv</a> heruntergeladen und mit dem Dezimierungsmodifikator des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blender-</a> Pakets die Anzahl der Scheitelpunkte auf 431 reduziert. In der <code>IntersectMeshObject</code> Shader-Funktion können Sie mit Beleuchtungsparametern und fest codiertem Material experimentieren.  Hier ist ein dielektrisches Kaninchen mit schönen weichen Schatten und ein wenig diffuser globaler Beleuchtung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grafitti Shelter</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0da/860/bb4/0da860bb41d9465f2dc21d649a509a66.png"></div><br>  ... und hier ist ein Metallkaninchen unter dem starken Richtungslicht von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cape Hill</a> , das Disco-Blendung auf die Bodenebene wirft: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a76/bb1/a64/a76bb1a642d620929ecd250f92e1ef1f.jpg"></div><br>  ... und hier sind zwei kleine Kaninchen, die sich unter dem großen Stein Suzanne unter dem blauen Himmel verstecken. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kiara 9 Dusk</a> (Ich habe für das zweite Objekt alternatives Material verschrieben und überprüft, ob die Indexverschiebung Null ist): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ef/196/a4f/7ef196a4f818b366b4838f2b1e4148f5.png"></div><br><h2>  Was weiter? </h2><br>  Es ist großartig, zum ersten Mal ein echtes Netz in Ihrem eigenen Tracer zu sehen, oder?  Heute haben wir einige Daten verarbeitet, mithilfe des Meller-Trambor-Algorithmus Informationen über die Kreuzung erhalten und alles gesammelt, damit wir die GameObjects-Engine der Unity-Engine sofort verwenden können.  Darüber hinaus haben wir einen der Vorteile der Raytracing-Funktion erkannt: Sobald Sie dem Code einen neuen Schnittpunkt hinzufügen, funktionieren alle schönen Effekte (weiche Schatten, reflektierte und diffuse globale Beleuchtung usw.) sofort. <br><br>  Das Rendern eines glänzenden Kaninchens nahm viel Zeit in Anspruch, und ich musste immer noch ein wenig filtern, um das offensichtlichste Geräusch zu beseitigen.  Um dieses Problem zu lösen, wird eine Szene normalerweise in einer räumlichen Struktur geschrieben, beispielsweise in einem Raster, einem K-dimensionalen Baum oder einer Hierarchie von Begrenzungsvolumina, was die Geschwindigkeit beim Rendern großer Szenen erheblich erhöht. <br><br>  Aber wir müssen uns in der richtigen Reihenfolge bewegen: Außerdem werden wir das Problem mit Normalen beseitigen, damit unsere Netze (auch solche mit niedrigem Polygehalt) glatter aussehen als jetzt.  Es wäre auch schön, Matrizen beim Verschieben von Objekten automatisch zu aktualisieren und direkt auf Unity-Materialien zu verweisen und sie nicht nur in den Code zu schreiben.  Dies werden wir im nächsten Teil der Tutorial-Reihe tun.  Danke fürs Lesen und wir sehen uns in Teil 4! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450308/">https://habr.com/ru/post/de450308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450294/index.html">Die gruseligsten Gifte</a></li>
<li><a href="../de450298/index.html">Quantum Future (Fortsetzung)</a></li>
<li><a href="../de450300/index.html">Hören Sie auf, über funktionale Programmierung und OOP zu streiten</a></li>
<li><a href="../de450302/index.html">Amateurfunktechnologie: Prototyp der Leiterplattenherstellung in einer chinesischen Fabrik</a></li>
<li><a href="../de450304/index.html">Carapuzik reitet auf einer Ameise: 100 Millionen Jahre Myrmekophilie</a></li>
<li><a href="../de450310/index.html">So funktioniert Philips VideoWRITER Erst Bilder von Eisen, dann etwas Langeweile</a></li>
<li><a href="../de450312/index.html">Docker Compose Starter Guide</a></li>
<li><a href="../de450314/index.html">TensorFlow für Anfänger. Teil 1: Allgemeine Informationen, Installation der Bibliothek</a></li>
<li><a href="../de450316/index.html">TDD: Eine Entwicklungsmethode, die mein Leben verändert hat</a></li>
<li><a href="../de450318/index.html">Entwurfsmuster in der modernen JavaScript-Entwicklung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>