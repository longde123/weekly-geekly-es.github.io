<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÑÔ∏è üêÄ üöç GPU Ray Tracing in Unity - Teil 3 üë©‚Äçüè≠ üåà üîÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Der erste und zweite Teil.] 


 Heute werden wir einen gro√üen Sprung machen. Wir werden uns von ausschlie√ülich sph√§rischen Strukturen und der unendl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU Ray Tracing in Unity - Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450308/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweite</a> Teil.] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a8a/4f2/f9fa8a4f2a79b8c394636de6a128d0d5.png"></div><br>  Heute werden wir einen gro√üen Sprung machen.  Wir werden uns von ausschlie√ülich sph√§rischen Strukturen und der unendlichen Ebene, die wir zuvor verfolgt haben, entfernen und Dreiecke hinzuf√ºgen - die ganze Essenz moderner Computergrafik, ein Element, aus dem alle virtuellen Welten bestehen.  Wenn Sie mit dem fortfahren m√∂chten, was wir das letzte Mal beendet haben, verwenden Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code aus Teil 2</a> .  Den fertigen Code f√ºr das, was wir heute tun werden, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Fangen wir an! <br><br><h2>  Dreiecke </h2><br>  <em>Ein Dreieck</em> ist nur eine Liste von drei verbundenen <em>Scheitelpunkten</em> , von denen jeder seine eigene Position speichert und manchmal normal ist.  Die Reihenfolge der Durchquerung der Eckpunkte aus Ihrer Sicht bestimmt, was wir betrachten - die Vorder- oder R√ºckseite des Dreiecks.  Traditionell wird die ‚ÄûFront‚Äú als Durchlaufreihenfolge gegen den Uhrzeigersinn betrachtet. <br><br>  Zun√§chst m√ºssen wir feststellen k√∂nnen, ob und an welchem ‚Äã‚ÄãPunkt der Strahl ein Dreieck schneidet.  Ein sehr beliebter (aber sicherlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht der einzige</a> ) Algorithmus zur Bestimmung des Schnittpunkts eines Strahls mit einem Dreieck wurde 1997 von den Herren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thomas Akenin-Meller</a> und Ben Trembor vorgeschlagen.  Weitere Informationen finden Sie in ihrem Artikel ‚ÄûSchnelle, minimale Speicher-Ray-Triangle-Kreuzung‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><a name="habracut"></a><br>  Der Code aus dem Artikel kann einfach auf den HLSL-Shader-Code portiert werden: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> EPSILON = <span class="hljs-number"><span class="hljs-number">1e-8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectTriangle_MT97</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, float3 vert0, float3 vert1, float3 vert2, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// find vectors for two edges sharing vert0 float3 edge1 = vert1 - vert0; float3 edge2 = vert2 - vert0; // begin calculating determinant - also used to calculate U parameter float3 pvec = cross(ray.direction, edge2); // if determinant is near zero, ray lies in plane of triangle float det = dot(edge1, pvec); // use backface culling if (det &lt; EPSILON) return false; float inv_det = 1.0f / det; // calculate distance from vert0 to ray origin float3 tvec = ray.origin - vert0; // calculate U parameter and test bounds u = dot(tvec, pvec) * inv_det; if (u &lt; 0.0 || u &gt; 1.0f) return false; // prepare to test V parameter float3 qvec = cross(tvec, edge1); // calculate V parameter and test bounds v = dot(ray.direction, qvec) * inv_det; if (v &lt; 0.0 || u + v &gt; 1.0f) return false; // calculate t, ray intersects triangle t = dot(edge2, qvec) * inv_det; return true; }</span></span></code> </pre> <br>  Um diese Funktion nutzen zu k√∂nnen, ben√∂tigen wir einen Strahl und drei Eckpunkte eines Dreiecks.  Der R√ºckgabewert gibt an, ob sich das Dreieck geschnitten hat.  Im Falle eines Schnittpunkts werden drei zus√§tzliche Werte berechnet: <code>t</code> beschreibt den Abstand entlang des Strahls zum Schnittpunkt, und <code>u</code> / <code>v</code> sind zwei der drei Schwerpunktkoordinaten, die die Position des Schnittpunkts auf dem Dreieck bestimmen (die letzte Koordinate kann als <code>w = 1 - u - v</code> berechnet werden).  Wenn Sie noch nicht mit Schwerpunktkoordinaten vertraut sind, lesen Sie deren hervorragende Erkl√§rung auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scratchapixel</a> . <br><br>  Lassen Sie uns ohne allzu gro√üe Verz√∂gerung ein Dreieck mit den im Code angegebenen Eckpunkten verfolgen!  Suchen Sie die <code>Trace</code> Funktion im Shader und f√ºgen Sie das folgende Codefragment hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Trace single triangle float3 v0 = float3(-150, 0, -150); float3 v1 = float3(150, 0, -150); float3 v2 = float3(0, 150 * sqrt(2), -150); float t, u, v; if (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { if (t &gt; 0 &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = 0.00f; bestHit.specular = 0.65f * float3(1, 0.4f, 0.2f); bestHit.smoothness = 0.9f; bestHit.emission = 0.0f; } }</span></span></code> </pre> <br>  Wie gesagt, <code>t</code> speichert den Abstand entlang des Strahls, und wir k√∂nnen diesen Wert direkt verwenden, um den Schnittpunkt zu berechnen.  Die Normale, die f√ºr die Berechnung der korrekten Reflexion wichtig ist, kann unter Verwendung des Vektorprodukts von zwei beliebigen Kanten des Dreiecks berechnet werden.  Starten Sie den Spielemodus und bewundern Sie Ihr erstes nachgezeichnetes Dreieck: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/65a/a84/b2965aa84ae9d882e6c26f7f44da2af7.png"></div><br>  <strong>√úbung:</strong> Versuchen Sie, die Position anhand der Schwerpunktkoordinaten und nicht anhand der Entfernung zu berechnen.  Wenn Sie alles richtig machen, sieht das gl√§nzende Dreieck genauso aus wie zuvor. <br><br><h2>  Dreiecksnetze </h2><br>  Wir haben das erste Hindernis √ºberwunden, aber das Verfolgen ganzer Maschen aus Dreiecken ist eine ganz andere Geschichte.  Zuerst m√ºssen wir einige grundlegende Informationen √ºber Netze lernen.  Wenn Sie sie kennen, k√∂nnen Sie den n√§chsten Absatz sicher √ºberspringen. <br><br>  In der Computergrafik wird das Netz durch mehrere Puffer definiert, von denen die wichtigsten die <em>Scheitelpunkt-</em> und Indexpuffer sind.  <em>Der Scheitelpunktpuffer</em> ist eine Liste von 3D-Vektoren, die die Position jedes Scheitelpunkts im <em>Objektraum beschreiben</em> (dies bedeutet, dass solche Werte beim Verschieben, Drehen oder Skalieren eines Objekts nicht ge√§ndert werden m√ºssen - sie werden mithilfe der Matrixmultiplikation im laufenden Betrieb vom <em>Objektraum</em> in <em>den Weltraum</em> konvertiert). .  <em>Ein Indexpuffer</em> ist eine Liste von Ganzzahlwerten, bei denen es sich um <em>Indizes handelt</em> , die auf den Scheitelpunktpuffer verweisen.  Alle drei Indizes bilden ein Dreieck.  Wenn der Indexpuffer beispielsweise die Form [0, 1, 2, 0, 2, 3] hat, hat er zwei Dreiecke: Das erste Dreieck besteht aus dem ersten, zweiten und dritten Scheitelpunkt im Scheitelpunktpuffer und das zweite Dreieck besteht aus dem ersten, dritten und vierte Spitzen.  Daher bestimmt der Indexpuffer auch die oben erw√§hnte Durchlaufreihenfolge.  Zus√§tzlich zu Scheitelpunktpuffern und -indizes k√∂nnen zus√§tzliche Puffer vorhanden sein, die jedem Scheitelpunkt andere Informationen hinzuf√ºgen.  Die gebr√§uchlichsten zus√§tzlichen Puffer speichern <em>Normalen</em> , <em>Texturkoordinaten</em> ( <em>Texcoords</em> oder einfach <em>UV genannt</em> ) sowie <em>Scheitelpunktfarben</em> . <br><br><h2>  Verwenden von GameObjects </h2><br>  Zun√§chst m√ºssen wir herausfinden, welche GameObjects Teil des Raytracing-Prozesses werden sollen.  Eine naive L√∂sung w√§re, einfach <code>FindObjectOfType&lt;MeshRenderer&gt;()</code> , aber etwas flexibleres und schnelleres zu tun.  <code>RayTracingObject</code> wir eine neue <code>RayTracingObject</code> Komponente hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RayTracingObject</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.RegisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.UnregisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br>  Diese Komponente wird jedem Objekt hinzugef√ºgt, das wir f√ºr die Raytracing-Funktion verwenden m√∂chten, und wird mit <code>RayTracingMaster</code> .  F√ºgen Sie dem Assistenten die folgenden Funktionen hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;RayTracingObject&gt; _rayTracingObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;RayTracingObject&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Add(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnregisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Remove(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Alles l√§uft gut - jetzt wissen wir, welche Objekte verfolgt werden m√ºssen.  Aber der knifflige Teil geht weiter: Wir werden alle Daten aus Unity-Netzen (Matrix, Vertex-Puffer und Indizes - erinnern Sie sich an sie?) Sammeln, sie in unsere eigenen Datenstrukturen schreiben und in die GPU laden, damit der Shader sie verwenden kann.  Beginnen wir mit der Definition von Datenstrukturen und Puffern auf der C # -Seite im Assistenten: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MeshObject { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Matrix4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;MeshObject&gt; _meshObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MeshObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; _vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _meshObjectBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _vertexBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _indexBuffer;</code> </pre> <br>  ... und jetzt machen wir dasselbe im Shader.  Bist du daran gew√∂hnt? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MeshObject</span></span></span><span class="hljs-class"> {</span></span> float4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; }; StructuredBuffer&lt;MeshObject&gt; _MeshObjects; StructuredBuffer&lt;float3&gt; _Vertices; StructuredBuffer&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _Indices;</code> </pre> <br>  Datenstrukturen sind fertig und wir k√∂nnen sie mit realen Daten f√ºllen.  Wir sammeln alle Eckpunkte aller Netze in einer gro√üen <code>List&lt;Vector3&gt;</code> und alle Indizes in einer gro√üen <code>List&lt;int&gt;</code> .  Es gibt keine Probleme mit den Scheitelpunkten, aber die Indizes m√ºssen ge√§ndert werden, damit sie weiterhin auf den richtigen Scheitelpunkt in unserem gro√üen Puffer zeigen.  Stellen Sie sich vor, wir haben bereits Objekte aus 1000 Eckpunkten hinzugef√ºgt und f√ºgen jetzt einen einfachen Netzw√ºrfel hinzu.  Das erste Dreieck kann aus Indizes [0, 1, 2] bestehen. Da wir jedoch bereits 1000 Scheitelpunkte im Puffer hatten, m√ºssen wir die Indizes verschieben, bevor wir dem W√ºrfel Scheitelpunkte hinzuf√ºgen.  Das hei√üt, sie werden zu [1000, 1001, 1002].  So sieht es im Code aus: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RebuildMeshObjectBuffers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_meshObjectsNeedRebuilding) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _currentSample = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Clear all lists _meshObjects.Clear(); _vertices.Clear(); _indices.Clear(); // Loop over all objects and gather their data foreach (RayTracingObject obj in _rayTracingObjects) { Mesh mesh = obj.GetComponent&lt;MeshFilter&gt;().sharedMesh; // Add vertex data int firstVertex = _vertices.Count; _vertices.AddRange(mesh.vertices); // Add index data - if the vertex buffer wasn't empty before, the // indices need to be offset int firstIndex = _indices.Count; var indices = mesh.GetIndices(0); _indices.AddRange(indices.Select(index =&gt; index + firstVertex)); // Add the object itself _meshObjects.Add(new MeshObject() { localToWorldMatrix = obj.transform.localToWorldMatrix, indices_offset = firstIndex, indices_count = indices.Length }); } CreateComputeBuffer(ref _meshObjectBuffer, _meshObjects, 72); CreateComputeBuffer(ref _vertexBuffer, _vertices, 12); CreateComputeBuffer(ref _indexBuffer, _indices, 4); }</span></span></code> </pre> <br>  Wir rufen <code>RebuildMeshObjectBuffers</code> in der <code>OnRenderImage</code> Funktion auf und vergessen nicht, neue Puffer in <code>OnDisable</code> .  Hier sind zwei Hilfsfunktionen, die ich im obigen Code verwendet habe, um die Pufferbehandlung ein wenig zu vereinfachen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateComputeBuffer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ComputeBuffer buffer, List&lt;T&gt; data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do we already have a compute buffer? if (buffer != null) { // If no data or buffer doesn't match the given criteria, release it if (data.Count == 0 || buffer.count != data.Count || buffer.stride != stride) { buffer.Release(); buffer = null; } } if (data.Count != 0) { // If the buffer has been released or wasn't there to // begin with, create it if (buffer == null) { buffer = new ComputeBuffer(data.Count, stride); } // Set data on the buffer buffer.SetData(data); } } private void SetComputeBuffer(string name, ComputeBuffer buffer) { if (buffer != null) { RayTracingShader.SetBuffer(0, name, buffer); } }</span></span></code> </pre> <br>  Gro√üartig, wir haben Puffer erstellt und sie sind mit den notwendigen Daten gef√ºllt!  Jetzt m√ºssen wir dies nur noch dem Shader melden.  F√ºgen Sie <code>SetShaderParameters</code> den folgenden Code <code>SetShaderParameters</code> (und dank neuer <code>SetShaderParameters</code> k√∂nnen wir den Code des <code>SetShaderParameters</code> reduzieren): <br><br><pre> <code class="cs hljs">SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Spheres"</span></span>, _sphereBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_MeshObjects"</span></span>, _meshObjectBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Vertices"</span></span>, _vertexBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Indices"</span></span>, _indexBuffer);</code> </pre> <br>  Die Arbeit ist also langweilig, aber lassen Sie uns sehen, was wir gerade getan haben: Wir haben alle internen Daten der Netze (Matrix, Eckpunkte und Indizes) gesammelt, sie in eine bequeme und einfache Struktur gebracht und sie dann an die GPU gesendet, auf die wir uns jetzt freuen Sie k√∂nnen verwendet werden. <br><br><h2>  Netzverfolgung </h2><br>  Lassen wir ihn nicht warten.  Im Shader haben wir bereits den Trace-Code eines einzelnen Dreiecks, und das Netz besteht tats√§chlich nur aus vielen Dreiecken.  Der einzige neue Aspekt hierbei ist, dass wir die Matrix verwenden, um die Scheitelpunkte vom Objektraum in den Weltraum mithilfe der integrierten <code>mul</code> Funktion (kurz f√ºr Multiplizieren) zu transformieren.  Die Matrix enth√§lt die Translation, Rotation und Skalierung des Objekts.  Es hat eine Gr√∂√üe von 4 √ó 4, daher ben√∂tigen wir f√ºr die Multiplikation einen 4d-Vektor.  Die ersten drei Komponenten (x, y, z) werden aus dem Scheitelpunktpuffer entnommen.  Wir setzen die vierte Komponente (w) auf 1, weil es sich um einen Punkt handelt.  Wenn dies die Richtung w√§re, w√ºrden wir 0 darin schreiben, um alle √úbersetzungen und Skalierungen in der Matrix zu ignorieren.  Ist das verwirrend f√ºr dich?  Dann lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Tutorial</a> mindestens acht Mal.  Hier ist der Shader-Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectMeshObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, inout RayHit bestHit, MeshObject meshObject)</span></span></span><span class="hljs-function"> </span></span>{ uint offset = meshObject.indices_offset; uint count = offset + meshObject.indices_count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = offset; i &lt; count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { float3 v0 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v1 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v2 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t, u, v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; bestHit.specular = <span class="hljs-number"><span class="hljs-number">0.65f</span></span>; bestHit.smoothness = <span class="hljs-number"><span class="hljs-number">0.99f</span></span>; bestHit.emission = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } } } }</code> </pre> <br>  Wir sind nur einen Schritt davon entfernt, alles in Aktion zu sehen.  Lassen Sie uns die <code>Trace</code> Funktion ein wenig umstrukturieren und eine Spur von Netzobjekten hinzuf√ºgen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">RayHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray)</span></span></span><span class="hljs-function"> </span></span>{ RayHit bestHit = CreateRayHit(); uint count, stride, i; <span class="hljs-comment"><span class="hljs-comment">// Trace ground plane IntersectGroundPlane(ray, bestHit); // Trace spheres _Spheres.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectSphere(ray, bestHit, _Spheres[i]); } // Trace mesh objects _MeshObjects.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectMeshObject(ray, bestHit, _MeshObjects[i]); } return bestHit; }</span></span></code> </pre> <br><h2>  Ergebnisse </h2><br>  Das ist alles!  <code>RayTracingObject</code> wir einige einfache Netze hinzu (Unity- <code>RayTracingObject</code> sind in Ordnung), geben Sie ihnen die <code>RayTracingObject</code> Komponente und beobachten Sie die Magie.  <strong>Verwenden Sie noch keine</strong> detaillierten Netze (mehr als ein paar hundert Dreiecke)!  Unser Shader ist nicht optimiert, und wenn Sie es √ºbertreiben, kann es Sekunden oder sogar Minuten dauern, bis mindestens ein Sample pro Pixel verfolgt wird.  Infolgedessen stoppt das System den GPU-Treiber, die Unity-Engine kann abst√ºrzen und der Computer muss neu gestartet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/1d4/40e/c801d440e5a0a21f660b5a7e82e1b368.png"></div><br>  Beachten Sie, dass unsere Netze keine glatte, sondern flache Schattierung haben.  Da wir die Normalen der Eckpunkte noch nicht in den Puffer geladen haben, m√ºssen wir ein Vektorprodukt ausf√ºhren, um die Normalen der Eckpunkte jedes Dreiecks zu erhalten.  Au√üerdem k√∂nnen wir nicht √ºber den Bereich des Dreiecks interpolieren.  Wir werden uns im n√§chsten Teil des Tutorials mit diesem Problem befassen. <br><br>  Aus Gr√ºnden des Interesses habe ich Stanford Bunny aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Morgan McGwire-Archiv</a> heruntergeladen und mit dem Dezimierungsmodifikator des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blender-</a> Pakets die Anzahl der Scheitelpunkte auf 431 reduziert. In der <code>IntersectMeshObject</code> Shader-Funktion k√∂nnen Sie mit Beleuchtungsparametern und fest codiertem Material experimentieren.  Hier ist ein dielektrisches Kaninchen mit sch√∂nen weichen Schatten und ein wenig diffuser globaler Beleuchtung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grafitti Shelter</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0da/860/bb4/0da860bb41d9465f2dc21d649a509a66.png"></div><br>  ... und hier ist ein Metallkaninchen unter dem starken Richtungslicht von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cape Hill</a> , das Disco-Blendung auf die Bodenebene wirft: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a76/bb1/a64/a76bb1a642d620929ecd250f92e1ef1f.jpg"></div><br>  ... und hier sind zwei kleine Kaninchen, die sich unter dem gro√üen Stein Suzanne unter dem blauen Himmel verstecken. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kiara 9 Dusk</a> (Ich habe f√ºr das zweite Objekt alternatives Material verschrieben und √ºberpr√ºft, ob die Indexverschiebung Null ist): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ef/196/a4f/7ef196a4f818b366b4838f2b1e4148f5.png"></div><br><h2>  Was weiter? </h2><br>  Es ist gro√üartig, zum ersten Mal ein echtes Netz in Ihrem eigenen Tracer zu sehen, oder?  Heute haben wir einige Daten verarbeitet, mithilfe des Meller-Trambor-Algorithmus Informationen √ºber die Kreuzung erhalten und alles gesammelt, damit wir die GameObjects-Engine der Unity-Engine sofort verwenden k√∂nnen.  Dar√ºber hinaus haben wir einen der Vorteile der Raytracing-Funktion erkannt: Sobald Sie dem Code einen neuen Schnittpunkt hinzuf√ºgen, funktionieren alle sch√∂nen Effekte (weiche Schatten, reflektierte und diffuse globale Beleuchtung usw.) sofort. <br><br>  Das Rendern eines gl√§nzenden Kaninchens nahm viel Zeit in Anspruch, und ich musste immer noch ein wenig filtern, um das offensichtlichste Ger√§usch zu beseitigen.  Um dieses Problem zu l√∂sen, wird eine Szene normalerweise in einer r√§umlichen Struktur geschrieben, beispielsweise in einem Raster, einem K-dimensionalen Baum oder einer Hierarchie von Begrenzungsvolumina, was die Geschwindigkeit beim Rendern gro√üer Szenen erheblich erh√∂ht. <br><br>  Aber wir m√ºssen uns in der richtigen Reihenfolge bewegen: Au√üerdem werden wir das Problem mit Normalen beseitigen, damit unsere Netze (auch solche mit niedrigem Polygehalt) glatter aussehen als jetzt.  Es w√§re auch sch√∂n, Matrizen beim Verschieben von Objekten automatisch zu aktualisieren und direkt auf Unity-Materialien zu verweisen und sie nicht nur in den Code zu schreiben.  Dies werden wir im n√§chsten Teil der Tutorial-Reihe tun.  Danke f√ºrs Lesen und wir sehen uns in Teil 4! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450308/">https://habr.com/ru/post/de450308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450294/index.html">Die gruseligsten Gifte</a></li>
<li><a href="../de450298/index.html">Quantum Future (Fortsetzung)</a></li>
<li><a href="../de450300/index.html">H√∂ren Sie auf, √ºber funktionale Programmierung und OOP zu streiten</a></li>
<li><a href="../de450302/index.html">Amateurfunktechnologie: Prototyp der Leiterplattenherstellung in einer chinesischen Fabrik</a></li>
<li><a href="../de450304/index.html">Carapuzik reitet auf einer Ameise: 100 Millionen Jahre Myrmekophilie</a></li>
<li><a href="../de450310/index.html">So funktioniert Philips VideoWRITER Erst Bilder von Eisen, dann etwas Langeweile</a></li>
<li><a href="../de450312/index.html">Docker Compose Starter Guide</a></li>
<li><a href="../de450314/index.html">TensorFlow f√ºr Anf√§nger. Teil 1: Allgemeine Informationen, Installation der Bibliothek</a></li>
<li><a href="../de450316/index.html">TDD: Eine Entwicklungsmethode, die mein Leben ver√§ndert hat</a></li>
<li><a href="../de450318/index.html">Entwurfsmuster in der modernen JavaScript-Entwicklung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>