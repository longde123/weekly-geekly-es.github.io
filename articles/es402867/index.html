<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕 💊 🤧 Caja negra de fumador ✡️ 🐳 📜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muchas personas fuman demasiado, especialmente cuando son adictas a algo y no se dan cuenta de cómo fuman un cigarrillo tras otro. La caja negra del f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caja negra de fumador</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402867/">  Muchas personas fuman demasiado, especialmente cuando son adictas a algo y no se dan cuenta de cómo fuman un cigarrillo tras otro.  La caja negra del fumador (CJK) no le permite tomar el próximo cigarrillo hasta que haya pasado un cierto período de tiempo.  En este artículo, prestaré atención a algunos detalles que pueden ser útiles para otros desarrollos, especialmente el no tan famoso controlador LC Teensy (familia Arduino). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mRDSiEAsiAI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <b>La mecanica</b> <br><br>  Los detalles de ChYAK se imprimen en una impresora 3D y después del ensamblaje de las partes inferior, media y superior se unen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/353/eb5/369/353eb5369a304723be064ac6e07722e9.jpg"></div><br><br>  El mecanismo de bloqueo está hecho de forma electromecánica, mientras que las funciones básicas de bloqueo se realizan de forma puramente mecánica, esto hace que sea difícil romper el NJC manipulando los espacios y retirando las baterías. <br><br>  El sistema de bloqueo consiste en un estante con dientes y un trinquete biestable, que permite que la bandeja se mueva solo en la dirección de cierre.  Al alcanzar un período de tiempo predeterminado, el servo realiza un solo movimiento hacia adelante y hacia atrás y empuja el trinquete, que se establece en el segundo estado estable "abierto".  El CFC permanece abierto hasta que el usuario extraiga mecánicamente la bandeja.  Cuando se extiende, la bandeja empuja el trinquete y lo coloca nuevamente en el estado armado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a0b/9a1/c0e/a0b9a1c0eaf74795b582073f40f55b93.jpg"></div><br><br>  El cargador está hecho en forma de tambor con 4 cavidades para cigarrillos.  Para evitar tratar de hacer pasar un cigarrillo a través del cargador, el mecanismo de trinquete no permite el movimiento en la dirección opuesta, desde el lado del cual están hechos los parachoques. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/69b/1af/cb9/69b1afcb91214e94a40b24be99f6895e.jpg"></div><br><br>  Las ranuras se hicieron en la tapa superior, le permiten eliminar posibles distorsiones de los cigarrillos dentro de la caja y sacudir las chispas de tabaco. <br><br>  <b>Interfaz</b> <br><br>  Para controlar el tiempo, la cantidad de cigarrillos en CHYAK y la cantidad de cigarrillos sacados, se monitoriza la pantalla OLED.  Se apaga casi todo el tiempo para no descargar la batería y se enciende solo por una señal del sensor capacitivo central, que se activa cuando se acerca una mano al CHYAK o una señal del botón al cargar cigarrillos.  Otro botón captura el momento en que se cierra la bandeja y comienza el siguiente ciclo de retraso.  Dos sensores capacitivos adicionales se encuentran en la pared posterior y se utilizan para ajustar los contadores de cigarrillos (necesarios, por ejemplo, al cambiar las baterías). <br><br>  <b>Electrónica</b> <br><br>  El microcontrolador es un Teensy LC.  Este dispositivo tipo arduin, compatible con la mayoría de las bibliotecas Arduino, fue elegido porque tiene soporte para sensores capacitivos (interfaz de detección táctil (TSI)).  Los sensores son tan sensibles que pueden sentir fácilmente la mano levantada a una distancia de un centímetro.  Teensy LC tiene el llamado modo LLWU, en este modo todos los módulos están en modo de suspensión, con la excepción del oscilador de 1 kHz.  Puede salir de este modo de suspensión de 4 maneras: a) obtenga una interrupción del sensor capacitivo, b) obtenga una interrupción del pin, c) obtenga un desbordamiento del contador de 1 kHz (temporizador de baja potencia, LPTMR), d) obtenga una interrupción de la alarma. <br><br>  Aquí el autor estaba en problemas: en los planes iniciales era usar TSI para despertarse cuando se presentaba una mano, y LPTMR para interrupciones periódicas para ajustar los niveles de TSI (dependiendo de las condiciones ambientales) y el control del tiempo.  Pero resultó que LPTMR se usa para el funcionamiento de TSI y, en consecuencia, no se puede usar como contador de tiempo.  (La interrupción de desbordamiento de LPTMR es activación de hardware para TSI y, por supuesto, debe ser rápida para monitorear el sensor. Por lo general, este contador está preestablecido en menos uno para que TSI se sondee con la frecuencia más alta posible de 1 kHz). <br><br>  Otra posibilidad sería utilizar la alarma de alarma RTC, pero el hecho es que Tenncy LC no tiene un reloj de tiempo real (RTC).  Por el contrario, RTC está en el procesador, pero no hay cableado para el cuarzo RTC en la placa.  Sin embargo, el desarrollador del procesador ha dejado algunas lagunas para las mentes inquisitivas.  El oscilador de 1 kHz (que funciona en modo de suspensión) se puede utilizar como fuente para los registros RTC del controlador.  Entonces resulta que RTC no puede contar segundos intervalos (como cuando se usa cuarzo a 32 kHz), sino 32 segundos si se usa un oscilador de 1 kHz.  Esta precisión, por supuesto, no es suficiente.  Pero hay una salida. <br><br>  Así es como funciona: <br><br>  Hay un registro de preescalador de tiempo RTC (RTC_TPR).  Este registro de 16 bits cuenta los pulsos del oscilador.  Cuando se desborda, el Registro de segundos de tiempo RTC (RTC_TSR) aumenta en uno.  En el modo clásico, estos son los segundos, que se comparan con el Registro de alarma de tiempo RTC (RTC_TAR), y cuando coinciden, se genera una interrupción de alarma.  Cuando se utiliza cuarzo normal de 32 kHz, RTC_TSR no está preinstalado, sino que se cuenta desde cero cada vez (32768 a desbordamiento (segundos)).  Pero si preinstalamos RTC_TSR cada vez, teniendo en cuenta que tenemos un oscilador lento de 1 kHz, podemos obtener una alarma de interrupción de hasta milisegundos de precisión (sin tener en cuenta la inexactitud del oscilador).  Por supuesto, RTC_TAR también debe recalcularse en consecuencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/719/cc7/057/719cc7057df74632be110832ac93d99b.png"></div><br><br>  Por ejemplo, si queremos establecer el período en 87 segundos, debemos escribir 2 en RTC_TSR (2 * 32768 = 65536ms = 65.536s), 2 en RTC_TAR y 32768- (87 * 1000-65536) = 11304 en RTC_TSR.  Luego pasarán 32.768-11.304 = 21.464 segundos antes del primer desbordamiento RTC_TPR, y se les agregarán dos ciclos completos 2 * 32.768 = 65.536, que serán solo 21.464 + 65.536 = 87 segundos <br>  En general, así: <br><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAlarm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seconds )</span></span></span><span class="hljs-function"> </span></span>{ RTC_SR = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//disable RTC RTC_TPR=32768-(seconds*1000%32768); RTC_TSR=0; //RTC counter RTC_SR = RTC_SR_TCE; //enable RTC RTC_TAR = seconds*1000/32768; }</span></span></code> </pre> <br>  E incluso podemos controlar el tiempo total (hasta un error de 1 kHz del oscilador), por ejemplo, si al comienzo del programa todos los registros RTC eran cero: <br><br><pre> <code class="hljs lisp">timeEllapsed=(<span class="hljs-name"><span class="hljs-name">RTC_TSR*32768+RTC_TPR</span></span>)/1000</code> </pre> <br>  La precisión del oscilador de 1 kHz es pequeña, pero para nuestros propósitos será suficiente.  Debe tenerse en cuenta que al iniciar una nueva alarma, modificamos los registros RTC, por lo que si necesita controlar el tiempo, debe recordarlos antes de que comience la alarma, y ​​después de salir de la interrupción de la alarma, se recalculan nuevamente teniendo en cuenta el tiempo pasado en hibernación.  Lo describí en detalle aquí: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre RTC para Teency LC</a> <br><br>  En CJC, una interrupción cada 10 minutos mide y almacena el nivel de señal de los sensores capacitivos en ausencia de una mano.  Esto se hace para poder seguir de manera confiable los cambios en las señales a medida que se acercan.  Con un fondo de ~ 500 unidades, utilizamos un nivel de exceso de ~ 20 unidades, esto hace posible sentir la mano a una distancia de 5-10 mm.  El nivel de fondo depende de la temperatura y la humedad, por lo que, para mayor fiabilidad, debe ajustarse periódicamente.  Esto, creo, es una falla en los desarrolladores de procesadores.  ¿Por qué no dieron la oportunidad de despertarse de TSI y algún otro contador de baja potencia al mismo tiempo (solo agregue un registro más), ya que el ajuste periódico de los niveles de TSI es casi obligatorio, incluso si no necesita un temporizador para otros fines! <br><br>  Ahora sobre la energía consumida.  En el modo de reposo LLWU, el Teensy LC consume alrededor de 15 uA cuando no hay un kit para el cuerpo.  Tuvimos que conectar otra pantalla OLED y un servo.  Ambos dispositivos tienen grandes corrientes de fuga incluso en estado pasivo. <br><br>  Todo es simple con OLED, esta es la pantalla OLED Adafruit 0.96 ”monocromática de 128x64, está alimentada por 3.3V, consume corriente de aproximadamente 20 mA cuando está encendida (dependiendo del número de píxeles involucrados) y es controlada por SPI.  Es decir, simplemente conecte su entrada de potencia a la salida de 20 miliamperios del Teensy LC (Teency tiene diferentes tipos de salidas) y listo.  Cuando todos duermen, esta salida simplemente se transfiere al tercer estado y la corriente no pasa por la pantalla, con la activación, la salida se transfiere al estado alto de salida y se convierte en Vcc para la pantalla. <br><br>  El servo es un poco más complicado.  El servo en modo de espera consume una corriente de aproximadamente 2 mA, que, por supuesto, no es aceptable.  Por lo tanto, debe apagarlo por completo mientras duerme.  A diferencia del Arduin clásico, Teensy LC tiene una selección bastante pequeña de fuentes de alimentación: ya sea 1.7-3.3 V conectadas directamente, o 2.6-5.5 V (con el regulador de voltaje interno encendido).  Por lo general, los servos accesibles funcionan desde al menos 1S Lipo, y esto es 3.3-4.2 V. Por lo tanto, necesitamos encender tres baterías estándar en serie para tener de 3.3 (descarga) a 4.6 V (nuevo).  Para la mayoría de los servos, 3.3 V está en el límite de operación, por lo que no se pueden usar directamente las salidas Teensy (como para OLED).  Sí, y la corriente durante la rotación es de aproximadamente 50 mA, que es un poco demasiado para el Teensy LC.  Por lo tanto, el servo se enciende a través de MOSFET: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d87/121/7a3/d871217a39f04ecfb537dff032ac7fb1.png"></div><br><br>  Con este encendido, puede parecer que no es seguro, ya que cuando el MOSFET está apagado, el voltaje en la entrada de control PWM supera los 3,3 V, y las entradas LC Tennsy no son tolerantes a 5V (a diferencia del Arduin clásico).  Pero no debe tener miedo de esto, recordando que el PWM ctrl actual es muy pequeño, y no hay que tener miedo del diodo limitante en la entrada del procesador (la razón de la inadmisibilidad de exceder Vcc + 0.5 está en este diodo), además, en corrientes comparables a las corrientes del diodo cerrado él ni siquiera estará en el estado abierto. <br><br>  en CHYAK utilizo HK282 con un umbral de 3.3V (solo porque lo tenía).  Se puede alimentar algún tipo de servo de bajo voltaje y baja potencia directamente desde las salidas Teensy, de acuerdo con el esquema utilizado para OLED. <br><br>  Como resultado, la corriente en el modo de suspensión resultó ser de aproximadamente 50 uA, probablemente fue posible reducirla aún más, pero decidí que esto era suficiente (si solo estaba dormido, las baterías deberían durar más de 4 años: 2000mAh / 0.05mA). <br><br>  <b>Técnica</b> <br><br>  Impreso en una impresora Monoprice Ultimate 3D, plástico PLA, boquilla de 0.4 mm, capa de 0.2 mm.  Para detalles del mecanismo de bloqueo, una capa de 0.1 mm para mayor precisión.  Los resortes también se imprimen en una impresora 3D.  Escribe durante mucho tiempo.  Por ejemplo, la mayor parte del medio (tiene muchas partes internas y paredes dobles para electrónica y cables) se imprimió durante 20 horas.  Estaba pegado con pegamento de acrilato de cian.  Si algo se rompe por dentro, es imposible distinguirlo (protección contra los fumadores maníacos), tendrá que romperlo como una alcancía e imprimir nuevamente (un argumento a favor de las impresoras 3D).  Los dibujos y las animaciones se realizan en SolidWorks, el entorno de desarrollo de AtmelStudio (sí, AVR (adolescencia) es compatible desde el primer momento, como Arduino, a través de VisualMicro). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es402867/">https://habr.com/ru/post/es402867/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es402853/index.html">La tercera ola de soluciones blockchain trae tecnología CAT</a></li>
<li><a href="../es402859/index.html">Portátiles al servicio de la policía.</a></li>
<li><a href="../es402861/index.html">Primera vez: para el estreno</a></li>
<li><a href="../es402863/index.html">Un modelo de contrato honesto como mecanismo de autorregulación de las relaciones públicas.</a></li>
<li><a href="../es402865/index.html">Dos vuelos de una etapa Falcon 9 en un video</a></li>
<li><a href="../es402869/index.html">Rastreadores de moda a la moda: Samsung, Polar, Withings, que no se esperaban</a></li>
<li><a href="../es402871/index.html">Cómo abrir un banco en Europa: licencias y blockchain</a></li>
<li><a href="../es402873/index.html">El libro "No te mueras! Comida en la lucha por la vida "</a></li>
<li><a href="../es402875/index.html">Matrices para cámaras de CCTV. ¿A qué prestar atención?</a></li>
<li><a href="../es402877/index.html">Presentación de impresoras de chocolate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>