<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏿 👲🏽 🍨 计算机世界中学生的大脑有什么能力 🐊 🖖🏽 🧜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好 

 在Bash上写完另一个脚本后，我意识到一切都应该完全不同，但是一切都可以。 我想向您展示我为解决问题写了哪些亵渎和拐杖，但到目前为止还没有足够的知识。 换句话说，是编程的讽刺漫画。 

 挑战赛 
 有必要进行以下操作： 


- 除了方格外，每个单词都印有很多押韵 
- 越过两个词的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>计算机世界中学生的大脑有什么能力</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474448/"> 大家好 <br><br> 在Bash上写完另一个脚本后，我意识到一切都应该完全不同，但是一切都可以。 我想向您展示我为解决问题写了哪些亵渎和拐杖，但到目前为止还没有足够的知识。 换句话说，是编程的讽刺漫画。 <br><a name="habracut"></a><br><h1>  <font color="#4682B4"><b>挑战赛</b></font> </h1><br> 有必要进行以下操作： <br><ul><li> 除了方格外，每个单词都印有很多押韵 </li><li> 越过两个词的押韵 </li></ul><br> 为了什么 好了-就是这样。 <br> 谁不知道，方形押韵（通常称为方形）是两个单词，其拼写的最后两个字母（通常仅此一个）使它们成为押韵。 例如，玫瑰-霜冻； 轮胎是汽车。 由于正方形的原始性，因此在现代版本化中使用正方形并没有得到人们的特别认可。 <br><br><h1>  <font color="#4682B4"><b>解决方案</b></font> </h1><br> 在我看来，最简单的解决方案是使用已有的押韵生成器-HOST在Bash上编写脚本，该主机首先根据和声而不是通过拼写选择它们。 什么是主机？ 因为如果您指定网站的真实名称-他们会说该广告。 为什么不继续使用它呢？ 首先，尽管它具有根据和声选择韵律的优势，但它经常会产生方格。 其次，您仍然需要动脑筋，花时间在制表符之间切换，记住记住列表中重复单词以找到两个单词的押韵的强度。 <br><br><h2>  <font color="#4682B4"><b>越来越强的押韵</b></font> </h2><br> 我知道什么 我知道<b>wget</b>实用程序，它将以指定的URL下载页面。 好吧，我们满足了请求-我们在文件中获得了HTML页面，这被称为押韵单词。 例如，查找单词“ here”： <br><br><pre><code class="bash hljs">wget https://HOST/rifma/</code> </pre> <br> 但是我只需要一个单词列表，如何摆脱其他一切？ 我们看到，单词列表是按列表的形式排列的，尽管看起来可能很奇怪，但是单词在&lt;li&gt; &lt;/ li&gt;标记中。 好吧，我们有一个很棒的<b>sed</b>实用程序-写下来： <br><a name="Filters"></a><br><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$word</span></span> | grep <span class="hljs-string"><span class="hljs-string">'&lt;li&gt;'</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">"s%&lt;li&gt;%%"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">"s%&lt;/li&gt;%%"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">"s/ //g"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">"/^$/d"</span></span> 1&gt; <span class="hljs-variable"><span class="hljs-variable">$word</span></span></code> </pre> <br> 首先，从<abbr title="您自己知道，不是变量$单词，而是押韵单词，它将被称为带有HTML页面的文件">word</abbr>文件中，选择包含&lt;li&gt;标记的行-我们得到了一堆空标记和带有单词的行。 我们删除了标签本身及其结束符-在这里使用百分号代替斜杠，因为&lt;/ li&gt;标签已经有斜杠，这就是<b>sed</b>有点不理解您的原因。 有兴趣的，一切都很好。 我们从文件中删除所有空格，删除空行。  Voila-单词的完整列表。 <br><br> 为了删除由于最后一个字母而押韵的单词，请从原始单词中选择最后两个字母并清除列表： <br><br><pre> <code class="bash hljs">squad=<span class="hljs-variable"><span class="hljs-variable">${word:((${#word}</span></span>-2)):2} cat <span class="hljs-variable"><span class="hljs-variable">$word</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">"/.</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$squad</span></span></span><span class="hljs-string">$/d"</span></span> 1&gt; <span class="hljs-variable"><span class="hljs-variable">$word</span></span></code> </pre> <br> 我们看一下，尝试-一切正常...如此，但是“ play”一词的清单在哪里？ 还有“我要来”这个词吗？ 该文件为空！ 这都是因为这些词是动词，我们知道它们与押韵成动词的人有什么关系。 对于俄语中最多的动词，甚至所有具有相同结尾的动词，动词韵律甚至都比平方动词差，这就是为什么在检查结尾后它们没有出现在最终文件中的原因。 <br><br> 但是，并不着急。 每个词不仅有韵律，而且还有谐音，有时听起来比韵律要好得多，因为它们也是谐音（法语谐音，来自拉丁语assono，我听起来不错）。 <br><br><h2>  <font color="#4682B4"><b>获得共鸣</b></font> </h2><br> 有趣的地方从这里开始：通过执行脚本，发送HTTP请求并接收响应，共鸣出现在单独的URL和同一页面上。 如何告诉<b>wget</b> '单击按钮？ 但是无论如何。 真伤心 <br><br> 注意到该行中的URL仍在以某种方式更改，因此我切换到共鸣音后复制了其中的内容，并将其粘贴到新的浏览器选项卡中-强烈的押韵。 不是那样 <br><br> 实际上，我认为，服务器不必关心发送请求的脚本是否已执行，或者人员是否手动键入请求。 那呢 谁知道，我们去检查一下。 <br><br> 寄到哪里？ 发送什么？ 对服务器IP的HTTP请求，类似GET ...，然后是HTTP / 1.1 ...，我们需要查看浏览器发送的内容和位置。 安装<b>wireshark</b> ，查看流量： <br><br> <code>0040 37 5d a3 84 27 e7 fb 13 6d 93 ed cd 56 04 9d 82 7]£.'çû.m.íÍV... <br> 0050 32 7c fb 67 46 71 dd 36 4d 42 3d f3 62 1b e0 ad 2|ûgFqÝ6MB=ób.à. <br> 0060 ef 87 be 05 6a f9 e1 01 41 fc 25 5b c0 77 d3 94 ï.¾.jùá.Aü%[ÀwÓ. <br></code> <br> 嗯...什么？ 哦，是的，我们有HTTPS。 怎么办 为自己安排一次MITM攻击？ 理想情况下，受害者本人会帮助我们。 <br><br> 总的来说，我猜是要爬上浏览器，我仍然找到了请求本身和接收者。 出发： <br><br><div class="spoiler">  <b class="spoiler_title">与终端对话框</b> <div class="spoiler_text"><pre> <code class="xml hljs">telnet IP PORT Trying IP... Connected to IP. Escape character is '^]'. GET /rifma/%D0%BC%D0%B0%D1%82%D1%8C?mode=block&amp;type=asn HTTP/1.1 Host: HOST Accept-Language: en-US,en;q=0.5 X-Requested-With: XMLHttpRequest Connection: close HTTP/1.1 400 Bad Request Server: nginx/1.8.0 Date: Sun, 03 Nov 2019 20:06:59 GMT Content-Type: text/html; charset=utf-8 Content-Length: 270 Connection: close <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>400 The plain HTTP request was sent to HTTPS port<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bgcolor</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"white"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>400 Bad Request<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span>The plain HTTP request was sent to HTTPS port<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span>nginx/1.8.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> Connection closed by foreign host.</code> </pre> </div></div> 嗯 嘿嘿 确实，我期望通过向HTTPS端口发送裸HTTP请求来实现。 现在加密吗？ 所有这些都与RSA密钥有关，然后与SHA256无关。 以及为什么有<b>OpenSSL</b>处理此类问题。 好了，我们已经知道该怎么做，只需首先删除Referer和Cookie字段-我认为它们不会对问题产生很大影响： <br><br><div class="spoiler">  <b class="spoiler_title">与终端对话框</b> <div class="spoiler_text"><pre> <code class="bash hljs">openssl s_client -connect IP:PORT { , } GET /rifma/%D0%B7%D0%B4%D0%B5%D1%81%D1%8C?mode=block&amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>=asn HTTP/1.1 Host: HOST User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/javascript,text/html,application/xml,text/xml,*/* Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate, br X-Requested-With: XMLHttpRequest Connection: keep-alive HTTP/1.1 200 OK Content-Type: text/html;charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive Vary: Accept-Encoding Status: 200 OK Date: Sun, 03 Nov 2019 20:34:33 GMT Set-Cookie: COOKIE X-Powered-By: Phusion Passenger 5.0.16 Server: nginx/1.8.0 + Phusion Passenger 5.0.16 Expires: Thu, 01 Jan 1970 00:00:01 GMT Cache-Control: no-cache Strict-Transport-Security: max-age=31536000 Content-Security-Policy: block-all-mixed-content Content-Encoding: gzip</code> </pre><br><img src="https://habrastorage.org/webt/em/5g/ad/em5gadtuwjrl7hr3crjozgutiug.png"><br></div></div><br> 这是服务器上的死将军吗？ 好吧，至少200 OK回答了我，这意味着Cookies和引荐来源网址不会影响任何内容。  Gzip压缩，但是在复制时会复制ASCII字符。 同样，您可以删除“ <b>接受编码”行</b> 。 一切都很好-我们现在有了一个带有谐音的HTML文档。 但是这里有两个问题：如何运行OpenSSL并使用脚本将数据传递给它？ 以及如何读取输出，如果在收到答案后我们仍然留在OpenSSL的“外壳”中？ 如果您可以想到第二个，但第一个... <br><br> 最好有一个<font color="#4682B4"><b>Habr</b></font> ，我在这里阅读了<font color="#4682B4"><b>Expect</b></font>实用程序，该实用程序使与等待人类交互的程序进行交互的过程自动化。 更具吸引力的是<b>autoexpect命令</b>的存在，该<b>命令</b> <b>会</b>为您的操作生成<b>期望</b>脚本。 好吧，运行，全部完成，这是完成的脚本。 只是它非常大，而且都是因为<b>OpenSSL</b>显示证书，密钥，并且<b>期望</b>它能显示所有这些。 我们需要这个吗？ 不行 我们删除第一个提示，仅保留最后一个换行符'\ r'。 我们还会从请求中删除“用户代理”和“接受”字段-它们不会影响任何内容。 因此，让我们开始吧。 该脚本已执行，但是令人垂涎的HTML文档在哪里？  <b>期待</b>吃它。 为了让他吐出来，您需要输入： <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> results <span class="hljs-variable"><span class="hljs-variable">$expect_out</span></span>(buffer)</code> </pre> <br> 在脚本结束之前-这是将如何编写和显示所执行的<b>Expect命令</b>的输出的方式。 总而言之，是这样的： <br><br><div class="spoiler">  <b class="spoiler_title">期望脚本</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/expect -f set timeout -1 spawn openssl s_client -connect IP:PORT match_max 100000 expect -exact " ---\r " send -- "GET /rifma/%d0%b7%d0%b4%d0%b5%d1%81%d1%8c?mode=block&amp;type=asn HTTP/1.1\rHost: HOST\rAccept-Language: en-US,en;q=0.5\rX-Requested-With: XMLHttpRequest\rConnection: close" expect -exact "GET /rifma/%d0%b7%d0%b4%d0%b5%d1%81%d1%8c?mode=block&amp;type=asn HTTP/1.1\r Host: HOST\r Accept-Language: en-US,en;q=0.5\r X-Requested-With: XMLHttpRequest\r Connection: close" send -- "\r" set results $expect_out(buffer) expect -exact "\r " send -- "\r" expect eof</span></span></code> </pre> </div></div><br> 但这还不是全部！ 如您所见，在所有示例中，请求URL都是静态的，但是由谁负责将共鸣音显示到哪个单词。 因此，事实证明，我们将不断在ASCII中搜索单词“％d0％b7％d0％b4％d0％b5％d1％81％d1％8c”或在UTF-8中搜索“ here”。 怎么办 当然，只是每次生成一个新脚本，朋友！ 不仅不会<b>自动预期</b> 'ohm，而且<b>还会自动</b>产生<b>echo</b> ，因为 在我们国家，除了这个词，没有任何变化。 长期存在的新问题是：我们如何以一种智能的方式将西里尔文字转换成URL格式？ 终端的东西也没什么特别的。 好吧，什么都可以，我们可以吗？ 我们可以： <br><br><div class="spoiler">  <b class="spoiler_title">看看我能做什么！</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> furl { furl=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$word</span></span></span><span class="hljs-string">"</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s::%d0%90:g;s::%d0%91:g;s::%d0%92:g;s::%d0%93:g;s::%d0%94:g;s::%d0%95:g;s::%d0%96:g;s::%d0%97:g;s::%d0%98:g;s::%d0%99:g;s::%d0%9a:g;s::%d0%9b:g;s::%d0%9c:g;s::%d0%9d:g;s::%d0%9e:g;s::%d0%9f:g;s::%d0%a0:g;s::%d0%a1:g;s::%d0%a2:g;s::%d0%a3:g;s::%d0%a4:g;s::%d0%a5:g;s::%d0%a6:g;s::%d0%a7:g;s::%d0%a8:g;s::%d0%a9:g;s::%d0%aa:g;s::%d0%ab:g;s::%d0%ac:g;s::%d0%ad:g;s::%d0%ae:g;s::%d0%af:g;s::%d0%b0:g;s::%d0%b1:g;s::%d0%b2:g;s::%d0%b3:g;s::%d0%b4:g;s::%d0%b5:g;s::%d0%b6:g;s::%d0%b7:g;s::%d0%b8:g;s::%d0%b9:g;s::%d0%ba:g;s::%d0%bb:g;s::%d0%bc:g;s::%d0%bd:g;s::%d0%be:g;s::%d0%bf:g;s::%d1%80:g;s::%d1%81:g;s::%d1%82:g;s::%d1%83:g;s::%d1%84:g;s::%d1%85:g;s::%d1%86:g;s::%d1%87:g;s::%d1%88:g;s::%d1%89:g;s::%d1%8a:g;s::%d1%8b:g;s::%d1%8c:g;s::%d1%8d:g;s::%d1%8e:g;s::%d1%8f:g;s::%d1%91:g;s::%d0%81:g'</span></span>)}</code> </pre> </div></div><br> 总的来说，我们有一个脚本将单词转换为ASCII文本，并生成另一个脚本，该脚本以一致的方式通过站点的OpenSSL服务器页面进行请求。 然后，我们将最后一个脚本的输出重定向到文件，并以旧的方式将其通过多余的，正方形的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“过滤器”</a> ，然后将其添加到文件中。 <br><br><h2>  <font color="#4682B4"><b>集的相交。</b></font>  <font color="#4682B4"><b>总结</b></font> </h2><br> 实际上，这正是导致最少问题的原因。 我们对两个单词执行上述过程，然后从两个列表中将每个单词与每个单词进行比较，如果找到匹配项，则显示它。 现在，我们有了一个脚本，该脚本将两个单词输入，并显示了一个单词列表，其中考虑了共鸣音，并且无需手动在四个选项卡之间切换并记住单词“通过眼睛”就可以将所有单词都押韵-就是这样自动收集，记录和丢弃。 太好了 <br><br> 该出版物的目的是表明，如果一个人需要某些东西，那么无论如何他都会这样做。 非常低效，歪曲，令人毛骨悚然，但这是可行的。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474448/">https://habr.com/ru/post/zh-CN474448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474436/index.html">由于政策原因，GitLab终止了从俄罗斯和中国招募工程师</a></li>
<li><a href="../zh-CN474438/index.html">简单，使用C ++。 Userver Basics-用于编写异步微服务的框架</a></li>
<li><a href="../zh-CN474440/index.html">iOS应用程序中自动续订订阅的收入计算困难</a></li>
<li><a href="../zh-CN474442/index.html">爱尔兰延寿故事</a></li>
<li><a href="../zh-CN474444/index.html">针对开发人员的另外5个大胆的培训项目（层，Squeosh，计算器，网站抓取工具，音乐播放器）</a></li>
<li><a href="../zh-CN474450/index.html">停止为DNS使用非常小的TTL</a></li>
<li><a href="../zh-CN474452/index.html">Haxe秋季状态报告</a></li>
<li><a href="../zh-CN474458/index.html">SQL中的累积总数</a></li>
<li><a href="../zh-CN474460/index.html">使用TableGen的LLVM中的处理器体系结构描述</a></li>
<li><a href="../zh-CN474462/index.html">俄语语音版本1.0的巨大开放数据集</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>