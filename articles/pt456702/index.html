<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçº ‚öúÔ∏è üë©üèº‚Äçüîß Seguran√ßa do OAuth 2.0 m√≥vel üôÉ üå∂Ô∏è üé≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A popularidade dos aplicativos m√≥veis continua a crescer. O mesmo acontece com o protocolo OAuth 2.0 em aplicativos m√≥veis. N√£o √© suficiente implement...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seguran√ßa do OAuth 2.0 m√≥vel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/456702/"><img src="https://habrastorage.org/getpro/habr/post_images/def/8b1/158/def8b1158655952902bf05be9fb7f308.jpg" alt="imagem"><br><br>  A popularidade dos aplicativos m√≥veis continua a crescer.  O mesmo acontece com o protocolo OAuth 2.0 em aplicativos m√≥veis.  N√£o √© suficiente implementar o padr√£o, como √© fazer o protocolo OAuth 2.0 seguro l√°.  √â preciso considerar as especificidades dos aplicativos m√≥veis e aplicar alguns mecanismos de seguran√ßa adicionais. <br><br>  Neste artigo, quero compartilhar os conceitos de ataques m√≥veis do OAuth 2.0 e mecanismos de seguran√ßa usados ‚Äã‚Äãpara evitar esses problemas.  Os conceitos descritos n√£o s√£o novos, mas h√° uma falta de informa√ß√µes estruturadas sobre este t√≥pico.  O principal objetivo do artigo √© preencher essa lacuna. <br><a name="habracut"></a><br><h1>  Natureza e finalidade do OAuth 2.0 </h1><br>  OAuth 2.0 √© um protocolo de <i>autoriza√ß√£o</i> que descreve uma maneira de um servi√ßo de cliente obter um acesso seguro aos recursos do usu√°rio em um provedor de servi√ßos.  Gra√ßas ao OAuth 2.0, o usu√°rio n√£o precisa digitar sua senha fora do provedor de servi√ßos: todo o processo √© reduzido ao clicar no bot√£o "Concordo em fornecer acesso a ...". <br><br>  Um provedor √© um servi√ßo que possui os dados do usu√°rio e, com permiss√£o do usu√°rio, fornece servi√ßos de terceiros (clientes) com um acesso seguro a esses dados.  Um cliente √© um aplicativo que deseja obter os dados do usu√°rio armazenados pelo provedor. <br><br>  Logo ap√≥s o lan√ßamento do protocolo OAuth 2.0, ele foi adaptado para <i>autentica√ß√£o</i> , embora n√£o fosse para isso.  O uso do OAuth 2.0 para autentica√ß√£o muda um vetor de ataque dos dados armazenados no provedor de servi√ßos para as contas de usu√°rio do servi√ßo ao cliente. <br><br>  Mas a autentica√ß√£o era apenas o come√ßo.  Em tempos de aplicativos m√≥veis e glorifica√ß√£o de convers√µes, acessar um aplicativo com apenas um bot√£o parecia bom.  Os desenvolvedores adaptaram o OAuth 2.0 para uso m√≥vel.  Obviamente, muitos n√£o se preocupam com a seguran√ßa e os detalhes dos aplicativos m√≥veis: zap e na produ√ß√£o em que foram!  Por outro lado, o OAuth 2.0 n√£o funciona bem fora dos aplicativos da Web: existem os mesmos problemas nos aplicativos para celular e para desktop. <br><br>  Ent√£o, vamos descobrir como tornar o OAuth 2.0 m√≥vel seguro. <br><br><h1>  Como isso funciona? </h1><br>  Existem dois principais problemas de seguran√ßa do OAuth 2.0 para dispositivos m√≥veis: <br><br><ol><li>  Cliente n√£o confi√°vel.  Alguns aplicativos m√≥veis n√£o possuem back-end para o OAuth 2.0, portanto, a parte do cliente do fluxo do protocolo fica no dispositivo m√≥vel. <br></li><li>  Os redirecionamentos de um navegador para um aplicativo m√≥vel se comportam de maneira diferente, dependendo das configura√ß√µes do sistema, da ordem em que os aplicativos s√£o instalados e de outras formas m√°gicas. <br></li></ol><br>  Vamos analisar em profundidade essas quest√µes. <br><br><h4>  Aplicativo m√≥vel √© um cliente p√∫blico </h4><br>  Para entender as ra√≠zes e as consequ√™ncias do primeiro problema, vamos ver como o OAuth 2.0 funciona no caso de intera√ß√£o servidor para servidor e, em seguida, compar√°-lo com o OAuth 2.0 no caso de intera√ß√£o cliente-servidor. <br><br>  Nos dois casos, tudo come√ßa com os registros do servi√ßo ao cliente no servi√ßo do provedor e recebe <code>client_id</code> e <code>,</code> em alguns casos <code>, client_secret. client_id</code>  <code>, client_secret. client_id</code> √© um valor p√∫blico e √© necess√°rio para a identifica√ß√£o do servi√ßo ao cliente, em oposi√ß√£o ao valor <code>client_secret</code> , que √© privado.  Voc√™ pode ler mais sobre o processo de registro na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC 7591</a> . <br><br>  O esquema abaixo mostra o modo como o OAuth 2.0 opera em caso de intera√ß√£o servidor a servidor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/689/61f/9a668961fd270118492bec6134a1aca9.png"><br>  <i>Origem da imagem: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  O protocolo OAuth 2.0 pode ser dividido em tr√™s etapas principais: <br><br><ol><li>  [etapas AC] Receba um <code>code</code> <code>authorization_code</code> (daqui em diante, <code>code</code> ). <br></li><li>  [etapas DE] Troca de <code>code</code> para <code>access_token</code> . <br></li><li>  Obtenha recursos via <code>access_token</code> . </li></ol><br><br>  Vamos elaborar o processo de obten√ß√£o <code>code</code> valor do <code>code</code> : <br><br><ol><li>  [Etapa A] O cliente redireciona o usu√°rio para o provedor de servi√ßos. <br></li><li>  [Etapa B] O provedor de servi√ßos solicita permiss√£o do usu√°rio para fornecer ao cliente os dados (seta B para cima).  O usu√°rio fornece acesso a dados (seta B √† direita). <br></li><li>  [Etapa C] O provedor de servi√ßos retorna o <code>code</code> para o navegador do usu√°rio, que redireciona o <code>code</code> para o cliente. <br></li></ol><br>  Vamos falar mais sobre o processo de obter <code>access_token</code> : <br><br><ol><li>  [Etapa D] O servidor cliente envia uma solicita√ß√£o para <code>access_token</code> .  <code>Code</code> , <code>client_secret</code> e <code>redirect_uri</code> est√£o inclu√≠dos na solicita√ß√£o. <br></li><li>  [Etapa E] No caso de <code>code</code> v√°lido, <code>client_secret</code> e <code>redirect_uri</code> , <code>access_token</code> √© fornecido. <br></li></ol><br>  A solicita√ß√£o para <code>access_token</code> √© feita de acordo com o esquema servidor para servidor: portanto, em geral, o invasor precisa hackear o servidor de servi√ßo ao cliente ou o servidor do provedor de servi√ßos para roubar o <code>access_token</code> . <br><br>  Agora, vejamos o esquema m√≥vel do OAuth 2.0 sem back-end (intera√ß√£o cliente-servidor). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>Origem da imagem: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  O esquema principal √© dividido nas mesmas etapas principais: <br><br><ol><li>  [etapas 1 a 4 na imagem] Obtenha <code>code</code> . </li><li>  [etapas 5 a 6 da figura] Troque <code>code</code> para <code>access_token</code> </li><li>  Obtenha acesso a recursos via <code>access_token</code> </li></ol><br>  No entanto, nesse caso, o aplicativo m√≥vel tamb√©m possui as fun√ß√µes do servidor;  portanto, <code>client_secret</code> seria incorporado ao aplicativo.  Como resultado, o <code>client_secret</code> n√£o pode ser mantido escondido do invasor em dispositivos m√≥veis.  O <code>client_secret</code> incorporado pode ser extra√≠do de duas maneiras: analisando o tr√°fego do aplicativo para o servidor ou fazendo engenharia reversa.  Ambos podem ser facilmente implementados, e √© por isso que <code>client_secret</code> √© in√∫til em dispositivos m√≥veis. <br><br>  Voc√™ pode perguntar: "Por que n√£o temos acesso ao <code>access_token</code> imediatamente?"  Voc√™ pode pensar que esta etapa extra √© desnecess√°ria.  Al√©m disso, existe o esquema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">concess√£o impl√≠cita</a> que permite que um cliente receba <code>access_token</code> imediatamente.  Mesmo assim, ele pode ser usado em alguns casos, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implicit Grant</a> n√£o funcionaria para o OAuth 2.0 m√≥vel seguro. <br><br><h4>  Redirecionamento em dispositivos m√≥veis </h4><br>  Em geral, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esquema URI personalizado</a> e os mecanismos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppLink</a> s√£o usados ‚Äã‚Äãpara redirecionar do navegador para o aplicativo.  Nenhum desses mecanismos pode ser t√£o seguro quanto o navegador redireciona por si pr√≥prio. <br><br>  <i>O esquema de URI personalizado</i> (ou link direto) √© usado da seguinte maneira: um desenvolvedor determina um esquema de aplicativo antes da implanta√ß√£o.  O esquema pode ser qualquer, e um dispositivo pode ter v√°rios aplicativos com o mesmo esquema. <br><br>  Isso facilita as coisas quando todos os esquemas de um dispositivo correspondem a um aplicativo.  Mas e se dois aplicativos registrarem o mesmo esquema em um dispositivo?  Como o sistema operacional decide qual aplicativo abrir quando contatado pelo esquema URI personalizado?  O Android mostrar√° uma janela com a escolha de um aplicativo e um link a seguir.  O iOS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o possui um procedimento para isso</a> e, portanto, qualquer aplicativo pode ser aberto.  De qualquer forma, o invasor tem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a chance de interceptar o c√≥digo ou acessar o token</a> . <br><br>  Diferente do esquema de URI personalizado, o <i>AppLink</i> garante a abertura do aplicativo certo, mas esse mecanismo possui v√°rias falhas: <br><br><ol><li>  Todo cliente de servi√ßo deve passar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pelo procedimento de verifica√ß√£o</a> . <br></li><li>  Os usu√°rios do Android podem desativar o AppLink para um aplicativo espec√≠fico nas configura√ß√µes. <br></li><li>  Vers√µes Android anteriores √† 6.0 e vers√µes iOS anteriores √† 9.0 n√£o s√£o compat√≠veis com o AppLink. <br></li></ol><br>  Todas essas falhas do AppLink aumentam a curva de aprendizado de poss√≠veis clientes de servi√ßo e podem resultar em falha do OAuth 2.0 do usu√°rio em algumas circunst√¢ncias.  √â por isso que muitos desenvolvedores n√£o escolhem o mecanismo AppLink como substituto para o redirecionamento do navegador no protocolo OAuth 2.0. <br><br><h1>  OK, o que h√° para atacar? </h1><br>  Os problemas do Mobile OAuth 2.0 criaram alguns ataques espec√≠ficos.  Vamos ver o que s√£o e como funcionam. <br><br><a name="1"></a><h4>  Ataque de intercepta√ß√£o de c√≥digo de autoriza√ß√£o </h4><br>  Vamos considerar a situa√ß√£o em que o dispositivo do usu√°rio possui um aplicativo leg√≠timo (cliente OAuth 2.0) e um aplicativo malicioso que registrou o mesmo esquema que o leg√≠timo.  A imagem abaixo mostra o esquema de ataque. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d79/b98/46e/d79b9846e18e85a546b32a5927cdd627.png"><br>  <i>Origem da imagem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Aqui est√° o problema: na quarta etapa, o navegador retorna o <code>code</code> no aplicativo via Custom URI Scheme e, portanto, o <code>code</code> pode ser interceptado por um aplicativo mal-intencionado (j√° que ele registrou o mesmo esquema que um aplicativo leg√≠timo).  Em seguida, o aplicativo malicioso altera o <code>code</code> para <code>access_token</code> e recebe acesso aos dados do usu√°rio. <br><br>  Qual √© a prote√ß√£o?  Em alguns casos, voc√™ pode usar a comunica√ß√£o entre processos;  falaremos sobre isso mais tarde.  Em geral, voc√™ precisa de um esquema chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Proof Key for Code Exchange</a> .  Est√° descrito no esquema abaixo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac2/289/967/ac2289967122b9d5f458e35ab2a0d902.png"><br>  <i>Origem da imagem: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  A solicita√ß√£o do cliente possui v√°rios par√¢metros extras: <code>code_verifier</code> , <code>code_challenge</code> (no esquema <code>t(code_verifier)</code> ) e <code>code_challenge_method</code> (no esquema <code>t_m</code> ). <br><br>  <code>Code_verifier</code> - √© um n√∫mero aleat√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">com um comprimento m√≠nimo de 256 bits</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usado apenas uma vez</a> .  Portanto, um cliente deve gerar um novo <code>code_verifier</code> para cada solicita√ß√£o de <code>code</code> . <br><br>  <code>Code_challenge_method</code> - este √© um nome de uma fun√ß√£o de convers√£o, principalmente SHA-256. <br><br>  <code>Code_challenge</code> - √© o <code>code_verifier</code> ao qual a convers√£o <code>code_challenge_method</code> foi aplicada e codificada no URL Safe Base64. <br><br>  A convers√£o de <code>code_verifier</code> em <code>code_challenge</code> √© necess√°ria para rejeitar os vetores de ataque com base na intercepta√ß√£o <code>code_verifier</code> (por exemplo, nos logs do sistema do dispositivo) ao solicitar <code>code</code> . <br><br>  Caso um dispositivo de usu√°rio <b>n√£o suporte</b> SHA-256, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>client is allowed to use plain conversion of code_verifier</code></a> .  Em todos os outros casos, o SHA-256 deve ser usado. <br><br>  √â assim que este esquema funciona: <br><br><ol><li>  O cliente gera o <code>code_verifier</code> e o memoriza. <br></li><li>  O cliente escolhe <code>code_challenge_method</code> e recebe <code>code_challenge</code> do <code>code_verifier</code> . <br></li><li>  [Etapa A] O cliente solicita <code>code</code> , com <code>code_challenge</code> e <code>code_challenge_method</code> adicionados √† solicita√ß√£o. <br></li><li>  [Etapa B] O provedor armazena <code>code_challenge</code> e <code>code_challenge_method</code> no servidor e retorna o <code>code</code> para um cliente. <br></li><li>  [Etapa C] O cliente solicita o <code>access_token</code> , com o <code>code_verifier</code> adicionado a ele. <br></li><li>  O provedor recebe <code>code_challenge</code> do <code>code_challenge</code> recebido e o compara ao <code>code_challenge</code> que ele salvou. <br></li><li>  [Etapa D] Se os valores corresponderem, o provedor <code>access_token</code> cliente o acesso. <br></li></ol><br>  Para entender por que <code>code_challenge</code> intercepta√ß√£o de c√≥digo, vamos ver como o fluxo do protocolo se parece da perspectiva do invasor. <br><br><ol><li>  Primeiro, o <code>code</code> solicita√ß√µes leg√≠timas de aplicativos ( <code>code_challenge</code> e <code>code_challenge_method</code> s√£o enviados junto com a <b>solicita√ß√£o</b> ). <br></li><li>  O aplicativo malicioso intercepta o <code>code</code> (mas n√£o o <code>code_challenge</code> , pois o c√≥digo <code>_challenge</code> n√£o est√° na resposta). <br></li><li>  Aplicativo malicioso solicita <code>access_token</code> (com <code>code</code> v√°lido, mas <b>sem</b> <code>code_verifier</code> v√°lido). <br></li><li>  O servidor percebe incompatibilidade de <code>code_challenge</code> e gera uma mensagem de erro. <br></li></ol><br>  Observe que o invasor n√£o consegue adivinhar o <code>code_verifier</code> (valor aleat√≥rio de 256 bits!) Ou encontra-o em algum lugar nos logs (desde que a primeira solicita√ß√£o realmente transmitiu <code>code_challenge</code> ). <br><br>  Portanto, <code>code_challenge</code> responde √† pergunta do provedor de servi√ßos: "O <code>access_token</code> √© solicitado pelo mesmo cliente de aplicativo que solicitou o <code>code</code> ou um <code>code</code> diferente?". <br><br><h4>  CSRF do OAuth 2.0 </h4><br>  O OAuth 2.0 CSRF √© relativamente inofensivo quando o OAuth 2.0 √© usado para autoriza√ß√£o.  √â uma hist√≥ria completamente diferente quando o OAuth 2.0 √© usado para autentica√ß√£o.  Nesse caso, o OAuth 2.0 CSRF geralmente leva √† aquisi√ß√£o de contas. <br><br>  Vamos falar mais sobre o ataque CSRF em conformidade com o OAuth 2.0 por meio do exemplo de cliente de aplicativo de t√°xi e provedor provider.com.  Primeiro, um invasor em seu pr√≥prio dispositivo efetua login na conta <code>attacker@provider.com</code> e recebe o <code>code</code> para o t√°xi.  Em seguida, ele interrompe o processo do OAuth 2.0 e gera um link: <br><br><pre> <code class="plaintext hljs">com.taxi.app://oauth? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4</code> </pre> <br>  Em seguida, o atacante envia esse link para a v√≠tima, por exemplo, na forma de um email ou mensagem de texto de um t√°xi.  A v√≠tima clica no link, o aplicativo de t√°xi √© aberto e recebe <code>access_token</code> .  Como resultado, eles se encontram na conta de t√°xi <b>do atacante</b> .  Sem saber disso, a v√≠tima usa esta conta: fa√ßa viagens, insira dados pessoais etc. <br><br>  Agora, o invasor pode fazer login na conta de t√°xi da v√≠tima a qualquer momento, pois est√° vinculada a <a href=""><code>attacker@provider.com</code></a> .  O ataque de login do CSRF permitiu ao infrator roubar uma conta. <br><br>  Os ataques de CSRF geralmente s√£o rejeitados com um token de CSRF (tamb√©m chamado de <code>state</code> ), e o OAuth 2.0 n√£o √© exce√ß√£o.  Como usar o token CSRF: <br><br><ol><li>  O aplicativo cliente gera e salva o token CSRF no dispositivo m√≥vel de um cliente. <br></li><li>  O aplicativo cliente inclui o token CSRF na solicita√ß√£o de acesso ao <code>code</code> . <br></li><li>  O servidor retorna o mesmo token CSRF com o <code>code</code> em sua resposta. <br></li><li>  O aplicativo cliente compara os tokens CSRF recebidos e salvos.  Se seus valores coincidirem, o processo continuar√°. <br></li></ol><br>  Requisitos de token CSRF: o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nonce</a> deve ter pelo menos 256 bits e ser recebido de uma boa fonte de sequ√™ncias pseudo-aleat√≥rias. <br><br>  Em poucas palavras, o token CSRF permite que um cliente de aplicativo responda √† seguinte pergunta: "Fui eu quem iniciou a solicita√ß√£o <code>access_token</code> ou algu√©m est√° tentando me enganar?". <br><br><h4>  Segredo do cliente codificado </h4><br>  √Äs vezes, aplicativos m√≥veis sem back-end armazenam valores <code>client_id</code> e <code>client_secret</code> codificados.  Claro que eles podem ser facilmente extra√≠dos pelo aplicativo de engenharia reversa. <br><br>  O impacto da exposi√ß√£o de <code>client_id</code> e <code>client_secret</code> depende muito de quanto fornecedor de servi√ßos de confian√ßa coloca em determinado par <code>client_id</code> , <code>client_secret</code> .  Um deles √© usado apenas para distinguir um cliente do outro, enquanto outros abrem pontos finais de API ocultos ou estabelecem limites de taxa mais baixos para alguns clientes. <br><br>  O artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Por que as chaves e segredos da API do OAuth n√£o s√£o seguros em aplicativos para dispositivos m√≥veis</a> detalha mais esse t√≥pico. <br><br><h4>  Aplicativo malicioso que atua como um cliente leg√≠timo </h4><br>  Alguns aplicativos maliciosos podem imitar os leg√≠timos e exibir uma tela de consentimento em seu nome (uma tela de consentimento √© uma tela em que o usu√°rio v√™: "Concordo em fornecer acesso a ...").  O usu√°rio pode clicar em "permitir" e fornecer seus dados ao aplicativo mal-intencionado. <br><br>  Android e iOS fornecem os mecanismos dos aplicativos para verifica√ß√£o cruzada.  Um provedor de aplicativos pode garantir que um aplicativo cliente seja leg√≠timo e vice-versa. <br><br>  Infelizmente, se o mecanismo OAuth 2.0 usa um encadeamento via navegador, √© imposs√≠vel se defender contra esse ataque. <br><br><h4>  Outros ataques </h4><br>  Examinamos de perto os ataques exclusivos do OAuth 2.0 para celular.  No entanto, n√£o vamos esquecer a OAuth 2.0 original: substitui√ß√£o <code>redirect_uri</code> , intercepta√ß√£o de tr√°fego por conex√£o n√£o segura etc.  Voc√™ pode ler mais sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h1>  Como faz√™-lo com seguran√ßa? </h1><br>  Aprendemos como o protocolo OAuth 2.0 funciona e quais vulnerabilidades ele possui em dispositivos m√≥veis.  Agora, vamos juntar as partes separadas para ter um esquema seguro do OAuth 2.0 para dispositivos m√≥veis. <br><br><h4>  Bom, ruim OAuth 2.0 </h4><br>  Vamos come√ßar da maneira correta de usar a tela de consentimento.  Os dispositivos m√≥veis t√™m duas maneiras de abrir uma p√°gina da web em um aplicativo m√≥vel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/740/d1e/75a/740d1e75aedec07de286cf9d7fc49292.png"><br><br>  A primeira maneira √© atrav√©s da guia Personalizada do navegador (√† esquerda na imagem).  <b>Nota</b> : a aba personalizada do navegador para Android √© chamada de aba personalizada do Chrome e para iOS - SafariViewController.  √â apenas uma guia do navegador exibida no aplicativo: n√£o h√° altern√¢ncia visual entre os aplicativos. <br><br>  A segunda maneira √© via WebView (√† direita na foto) e considero ruim em rela√ß√£o ao OAuth 2.0 para celular. <br><br>  O WebView √© um navegador incorporado para um aplicativo m√≥vel. <br><br>  " <i>Navegador incorporado</i> " significa que o WebView √© proibido para cookies, armazenamento, cache, hist√≥rico e outros dados do Safari e Chrome.  O inverso tamb√©m est√° correto: o Safari e o Chrome n√£o podem acessar os dados do WebView. <br><br>  " <i>Navegador de aplicativo m√≥vel</i> " significa que um aplicativo m√≥vel que executa o WebView tem acesso <b>total</b> a cookies, armazenamento, cache, hist√≥rico e outros dados do WebView. <br><br>  Agora, imagine: um usu√°rio clica em "entrar com ..." e o WebView de um aplicativo mal-intencionado solicita seu login e senha ao provedor de servi√ßos. <br><br>  Falha √©pica: <br><br><ol><li>  O usu√°rio digita seu login e senha para a conta do provedor de servi√ßos no aplicativo, que pode facilmente roubar esses dados. <br></li><li>  O Outh 2.0 foi desenvolvido inicialmente para <i>n√£o inserir o login e a senha do provedor de servi√ßos.</i> <i><br></i> <br>  O usu√°rio se acostuma a digitar seu login e senha em qualquer lugar, aumentando assim a possibilidade de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pesca</a> . <br></li></ol><br>  Considerando todos os contras do WebView, uma conclus√£o √≥bvia se oferece: use a Aba personalizada do navegador para obter a tela de consentimento. <br><br>  Se algu√©m tiver argumentos a favor do WebView em vez da guia Personalizada do navegador, agradeceria se voc√™ escrever sobre isso nos coment√°rios. <br><br><h4>  Esquema OAuth 2.0 m√≥vel seguro </h4><br>  Usaremos o esquema de concess√£o de c√≥digo de autoriza√ß√£o, pois ele permite adicionar <code>code_challenge</code> , al√©m de <code>state</code> e defender contra um ataque de intercepta√ß√£o de c√≥digo e o OAuth 2.0 CSRF. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>Origem da imagem: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  A solicita√ß√£o de acesso ao c√≥digo (etapas 1 a 2) ter√° a seguinte apar√™ncia: <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> 3D% 3D &amp; <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br>  Na etapa 3, o navegador obt√©m uma resposta com o redirecionamento: <br><br><pre> <code class="plaintext hljs">com.mail.cloud.app://outh? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> </pre> <br>  Na etapa 4, o navegador abre o esquema de URI personalizado e passa o token CSRF para um aplicativo cliente. <br>  solicita√ß√£o <code>access_token</code> (etapa 5): <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/token? code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br>  A √∫ltima etapa traz uma resposta com <code>access_token</code> . <br><br>  Esse esquema geralmente √© seguro, mas h√° casos especiais em que o OAuth 2.0 pode ser mais simples e mais seguro. <br><br><h4>  Android IPC </h4><br>  O Android possui um mecanismo de comunica√ß√£o de dados bidirecional entre processos: IPC (comunica√ß√£o entre processos).  O IPC √© melhor que o esquema de URI personalizado por dois motivos: <br><br><ol><li>  Um aplicativo que abre o canal IPC pode confirmar a autenticidade de um aplicativo que est√° abrindo pelo certificado.  O inverso tamb√©m √© verdadeiro: o aplicativo aberto pode confirmar a autenticidade do aplicativo que o abriu. <br></li><li>  Se um remetente enviar uma solicita√ß√£o pelo canal IPC, ele poder√° receber uma resposta pelo mesmo canal.  Juntamente com a verifica√ß√£o cruzada (item 1), significa que nenhum processo externo pode interceptar o <code>access_token</code> . <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/dac/d7c/1a9/dacd7c1a98a6d1c7227b7e8e5e24757f.png"><br><br>  Portanto, podemos usar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">concess√£o impl√≠cita</a> para simplificar o esquema m√≥vel do OAuth 2.0.  Nenhum <code>code_challenge</code> e <code>state</code> tamb√©m significam menos superf√≠cie de ataque.  Tamb√©m podemos reduzir os riscos de aplicativos mal-intencionados agirem como clientes leg√≠timos tentando roubar as contas de usu√°rio. <br><br><h4>  SDK para clientes </h4><br>  Al√©m de implementar esse esquema m√≥vel seguro do OAuth 2.0, um provedor deve desenvolver o SDK para seus clientes.  Isso simplificar√° a implementa√ß√£o do OAuth 2.0 no lado do cliente e reduzir√° simultaneamente o n√∫mero de erros e vulnerabilidades. <br><br><h1>  Conclus√µes </h1><br>  Deixe-me resumir para voc√™.  Aqui est√° a <i>lista de verifica√ß√£o</i> (b√°sica) <i>para</i> provedores <i>seguros de OAuth 2.0</i> para OAuth 2.0: <br><br><ol><li>  Uma base s√≥lida √© crucial.  No caso do OAuth 2.0 para dispositivos m√≥veis, a base √© um esquema ou protocolo escolhido para implementa√ß√£o.  √â f√°cil cometer erros ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementar seu pr√≥prio esquema OAuth 2.0</a> .  Outros j√° sofreram pancadas e aprenderam a li√ß√£o;  n√£o h√° nada de errado em aprender com seus erros e fazer uma implementa√ß√£o segura de uma s√≥ vez.  O esquema OAuth 2.0 m√≥vel mais seguro √© descrito em <i>Como fazer isso com seguran√ßa</i> ? <br></li><li>  <code>Access_token</code> e outros dados confidenciais devem ser armazenados no Keychain para iOS e no Internal Storage for Android.  Esses armazenamentos foram desenvolvidos especificamente para isso.  O Provedor de conte√∫do pode ser usado no Android, mas deve ser configurado com seguran√ßa. <br></li><li>  <code>Client_secret</code> √© <b>in√∫til</b> , a menos que seja armazenado no back-end.  N√£o o entregue aos clientes p√∫blicos. <br></li><li>  N√£o use o WebView para obter a tela de consentimento;  use a guia personalizada do navegador. <br></li><li>  Para se defender contra ataques de intercepta√ß√£o de c√≥digo, use <code>code_challenge</code> . <br></li><li>  Para se defender do OAuth 2.0 CSRF, use <code>state</code> . <br></li><li>  Use HTTPS em <b>qualquer lugar</b> , com o downgrade proibido para HTTP.  Aqui est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma demonstra√ß√£o de 3 minutos</a> explicando o porqu√™ (com exemplo de uma recompensa de bug). <br></li><li>  Siga os <b>padr√µes de</b> criptografia (escolha do algoritmo, comprimento dos tokens, etc.).  Voc√™ pode copiar os dados e descobrir por que isso foi feito dessa maneira, mas n√£o role sua pr√≥pria criptografia. <br></li><li>  <code>Code</code> deve ser usado apenas uma vez, com uma vida √∫til curta. <br></li><li>  Do lado do cliente do aplicativo, verifique o que voc√™ abre para o OAuth 2.0;  e do lado do provedor de aplicativos, verifique quem o abre para o OAuth 2.0. <br></li><li>  Lembre-se de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vulnerabilidades comuns do OAuth 2.0</a> .  O OAuth 2.0 para dispositivos m√≥veis aumenta e completa o original, portanto, a verifica√ß√£o <code>redirect_uri</code> para uma correspond√™ncia exata e outras recomenda√ß√µes para o OAuth 2.0 original ainda est√£o em vigor. <br></li><li>  Voc√™ deve fornecer aos seus clientes o SDK.  Eles ter√£o menos bugs e vulnerabilidades e ser√° mais f√°cil implementar o OAuth 2.0. <br></li></ol><br><h1>  Leitura adicional </h1><br><ol><li>  "Vulnerabilidades do OAuth 2.0 para dispositivos m√≥veis" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.youtube.com/watch?v=vjCF_O6aZIg</a> <br></li><li>  Pesquisa de condi√ß√£o de corrida do OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://hackerone.com/reports/55140</a> <br></li><li>  Quase tudo sobre o OAuth 2.0 em um s√≥ lugar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://oauth.net/2/</a> <br></li><li>  Por que as chaves e segredos da API do OAuth n√£o s√£o seguros em aplicativos m√≥veis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://developer.okta.com/blog/2019/01/22/oauth-api-keys-arent-safe-in-mobile-apps</a> <br></li><li>  [RFC] OAuth 2.0 para aplicativos nativos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc8252</a> <br></li><li>  [RFC] Chave de prova para troca de c√≥digo por clientes p√∫blicos do OAuth <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc7636</a> <br></li><li>  [RFC] Modelo de amea√ßa do OAuth 2.0 e considera√ß√µes de seguran√ßa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc6819</a> <br></li><li>  [RFC] Protocolo de registro din√¢mico de cliente OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc7591</a> <br></li><li>  Google OAuth 2.0 para aplicativos para dispositivos m√≥veis e computadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> <br></li></ol><br><h1>  Cr√©ditos </h1><br>  Obrigado a todos que me ajudaram a escrever este artigo.  Especialmente a Sergei Belov, Andrei Sumin, Andrey Labunets pelo feedback sobre detalhes t√©cnicos, a Pavel Kruglov pela tradu√ß√£o em ingl√™s e a Daria Yakovleva pela ajuda no lan√ßamento da vers√£o em russo deste artigo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456702/">https://habr.com/ru/post/pt456702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456684/index.html">Corrigindo um pequeno erro no calc.exe</a></li>
<li><a href="../pt456686/index.html">Os meandros das entrevistas ao contratar udalenka</a></li>
<li><a href="../pt456690/index.html">Todos os dias fones de ouvido por Case Guru - CGPods Sport</a></li>
<li><a href="../pt456692/index.html">A ascens√£o e queda do Visual Basic</a></li>
<li><a href="../pt456700/index.html">GeekUniversity Abre Recrutamento na Faculdade de Gerenciamento de Produtos</a></li>
<li><a href="../pt456704/index.html">Seis maneiras pelas quais os testadores podem se beneficiar (al√©m dos testes funcionais)</a></li>
<li><a href="../pt456710/index.html">O que √© uma plataforma de baixo c√≥digo / sem c√≥digo e CRM, CRM +, ERP</a></li>
<li><a href="../pt456712/index.html">Registro de tr√°fego seletivo para servi√ßos SOAP</a></li>
<li><a href="../pt456714/index.html">Compreendendo os n√∫meros de ponto flutuante (parte 0)</a></li>
<li><a href="../pt456716/index.html">Dados n√£o muito grandes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>