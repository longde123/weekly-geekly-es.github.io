<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€âœˆï¸ ğŸšŒ ğŸ‘µğŸ¾ Tata letak dan gaya auto kesatuan: saluran dan alat baru kami untuk UI ğŸ¦“ â›²ï¸ ğŸ‘©ğŸ»â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya akan mulai dengan hal utama: kami membuat alat tata letak yang nyaman dan mengubah alur kerja. Sekarang sudah beres. 

 Ada banyak antarmuka berb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tata letak dan gaya auto kesatuan: saluran dan alat baru kami untuk UI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/462835/"><img src="https://habrastorage.org/webt/py/zj/bi/pyzjbiha5nept3fqmkkpoezrbms.gif"><br><br>  Saya akan mulai dengan hal utama: kami membuat alat tata letak yang nyaman dan mengubah alur kerja.  Sekarang sudah beres. <br><br>  Ada banyak antarmuka berbeda dalam gim seluler, termasuk HUD dan sejumlah besar layar untuk meta.  Perancang UX mendesainnya, perancang UI menarik, dan agar semua ini muncul di mesin, ada orang yang terlatih khusus - perancang UI teknis.  Baik, atau hanya tata letak desainer.  Bagian dari pekerjaan mereka adalah mentransfer segalanya dengan susah payah dari tata letak PSD ke cetakan, nomor demi nomor.  Mereka juga terlibat dalam animasi UI, mengisi sprite, membuat tata letak adaptif, mengatur kunci pelokalan dan sebagainya. <br><br>  Dan kami menetapkan beberapa tujuan: <br><br><ul><li>  mempercepat pekerjaan perancang tata letak dan menyelamatkannya dari rutin; </li><li>  merampingkan interaksi antara departemen desain dan pengembangan UI; </li><li>  membawa keseragaman ke UI: membuat pedoman dan membentuk aset Persatuan atas dasar mereka; </li><li>  memberikan ekstensibilitas dan fleksibilitas UI, penggunaan kembali aset, resistensi terhadap pengeditan, dan optimisasi yang mudah. </li></ul><br>  Inilah yang terjadi. <a name="habracut"></a><br><br>  Kami mencoba membuat semacam sistem desain dari mesin Unity dan Adobe Photoshop (yang, tampaknya, kecuali untuk pengembang game, hampir tidak digunakan untuk membuat antarmuka).  Secara kasar, kami dihadapkan dengan tugas berteman Photoshop dan Unity. <br><br><img src="https://habrastorage.org/webt/ew/ze/6i/ewze6ipw85qpsvsdfdnlwvvzky8.jpeg"><br><br>  Pertama-tama, perlu memproyeksikan seluruh set "bahasa visual" di Unity.  Untuk melakukan ini, kami memilih gaya dan menyesuaikannya dengan kebutuhan kami sendiri.  Ini adalah praktik yang cukup umum di kalangan perusahaan.  Jadi seperangkat font telah menjadi gaya font, seperangkat tata letak telah menjadi gaya dengan sprite tata letak ini, seperangkat warna telah menjadi gaya dengan warna, dan sebagainya.  Sudah cukup untuk membuat semua ini sekali, dan kemudian hanya menggunakan kembali dan melengkapi bersama dengan ekstensi psd dengan pedoman.  Dengan demikian, perancang UI terpaksa meninggalkan 1001 media pada layar yang berbeda dan membuat beberapa yang universal. <br><br>  Gaya saat ini yaitu: <br><br><ol><li>  <b>Gaya Warna</b> &lt;Nama, Warna&gt; </li><li>  <b>Gaya Teks</b> &lt;Nama, Font, Ukuran font, Bahan font, Penspasian baris&gt; </li><li>  <b>Gaya Font</b> &lt;Judul, Font, Bahan Font&gt; </li><li>  <b>Gaya Tombol</b> &lt;Nama, Pengaturan Tombol&gt; </li><li>  <b>Gaya Tata Letak</b> &lt;Nama, Sprite, Lekukan&gt; </li><li>  <b>Gaya Sprite</b> &lt;Nama, Sprite&gt; </li><li>  <b>Gaya Pelokalan</b> &lt;Nama, Kunci&gt; </li><li>  <b>Ikon Gaya</b> &lt;Nama, Sprite&gt; </li></ol><br>  Dan secara umum, Anda dapat membuat gaya dengan mudah dan sederhana, mewarisinya dari pangkalan.  Sebagai contoh: <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CreateAssetMenu(menuName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UIStyles/ColorStyle"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ColorStyle</span></span> : <span class="hljs-title"><span class="hljs-title">BaseStyle</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Color</span></span>&gt; { }</code> </pre> <br>  Satu-satunya batasan: jenis harus Serializable.  Jadi pengeset pun akan mengatasi penciptaan gaya gayanya sendiri. <br><br><img src="https://habrastorage.org/webt/ap/-u/7g/ap-u7gb-mj4d4jl8ngy3wt3wkb0.jpeg"><br><br>  Beberapa gaya diperlukan untuk mengubah keadaan UI.  Misalnya, Gaya Warna, Gaya Teks, Gaya Sprite, Gaya Tombol, Gaya Lokalisasi.  Semuanya mempengaruhi objek game yang berbeda.  Gambar dilukis dengan warna berbeda, sprite berbeda diganti di dalamnya, dan sebagainya. <br><br>  Sampai sekarang, tidak jelas bagaimana menggunakan semua ini.  Saya akan memberikan contoh sederhana.  Katakanlah kita memiliki satu tombol penawaran warna yang berbeda.  Warna tombol tergantung pada penawaran itu sendiri.  Dan mereka terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/_y/8h/bv/_y8hbvtkew9spcztt21fjn_af5s.jpeg"><br><br>  Kemudian kita membuat satu cetakan dengan Gambar, di mana kita menggantung ColorStyleComponent, masukkan gaya ColorStyle ke dalamnya, di mana semua warna yang dapat dicat ulang tombol akan disimpan, dan kemudian menerapkan gaya tergantung pada penawaran di dalam kode. <br><br><img src="https://habrastorage.org/webt/4z/mz/wp/4zmzwp5ptez9lika0pydr7dzata.jpeg"><br><br>  Gaya FontStyle, IconStyle dan LayoutStyle digunakan untuk auto-builder.  Ini adalah pustaka dari semua font, ikon dan garis bawah dalam proyek. <br><br>  Sistem dengan gaya memiliki sejumlah besar keuntungan (hanya sekelompok aset dalam proyek yang dapat mengganggu): <br><br><ul><li>  digunakan kembali; </li><li>  ketika mengubah gaya, cetakan tidak berubah, tetapi jika sesuatu perlu diubah, ini akan mempengaruhi semua cetakan; </li><li>  jenis huruf membuat gaya sendiri, mengubahnya dan menghapusnya, yang memungkinkan programmer untuk melupakan tumpukan bidang di monobekh dengan bunga; </li><li>  gaya dapat diterapkan langsung di editor karena fakta bahwa untuk Editor BaseStyleComponent &lt;T, TStyle&gt; Editor sendiri ditulis. </li></ul><br>  Untuk mengubah status satu widget besar, beberapa gaya dapat digunakan, objek yang berbeda dapat dihidupkan / dimatikan.  Untuk melakukan ini, StateStyleComponent telah dibuat dalam proyek, yang mengumpulkan semua gaya dan objek yang perlu dihidupkan / dimatikan.  Kemudian, tepat di widget, semua status yang memungkinkan dibuat dan diaktifkan.  Ini menghemat programmer dari banyak kode yang sama untuk beralih warna / font / teks / sprite. <br><br><img src="https://habrastorage.org/webt/ob/oz/6z/oboz6zrkayuamm0ew9bq7nzzcto.png"><br><br><img src="https://habrastorage.org/webt/e0/1e/kx/e01ekxz1euufcifycetldyvgbyg.gif"><br><br>  Lalu kami membuat pembuat mobil.  Ini adalah alat di mana Anda menempel psd, dan pada output prefab mentah dibuat, di mana beberapa sprite sudah dimasukkan, posisi, nama, font, ukuran, alias diletakkan - segala sesuatu yang begitu hati-hati disalin dari psd oleh perancang tata letak dengan pena.  Itu bahkan secara kasar berlabuh dan mempertahankan hierarki.  Dan itu melakukannya dalam hitungan detik, yang pada akhirnya menghemat waktu penyalinan dengan susah payah. <br><br><img src="https://habrastorage.org/webt/xk/tr/mt/xktrmt-ytwtagbt7hdyolid9ou4.jpeg"><br><br>  Jendela autocomputer itu sendiri terlihat sedikit pada pengaturan.  Saat digunakan, pengaturan ini akan ditambahkan. <br><br><img src="https://habrastorage.org/webt/f3/me/uy/f3meuyl1gwvet3kostin0yvheci.png"><br><br>  Untuk mendapatkan semua data, parser psd ditulis khusus untuk kebutuhan ini berdasarkan spesifikasi psd.  Ini adalah proses yang agak membosankan, Anda dapat mengambil perpustakaan yang sudah jadi.  Tetapi karena kami ingin melakukan semuanya dengan satu tombol, saya harus menulis dari awal. <br><br>  Pembuat otomatis menyalin seluruh hierarki di Photoshop.  Pertama, objek root dibuat dengan nama cetakan, yang berlabuh ke tepi layar.  Di dalamnya, objek dibuat sesuai dengan prinsip yang dijelaskan di atas - objek dibuat di objek root, dan kemudian orang tua yang sebenarnya ditugaskan untuk itu sambil mempertahankan posisi global.  Jangkar ditempatkan sesuai dengan prinsip - di mana tepi atau pusat objek terletak paling dekat dengan yang dipakukan, secara terpisah di sepanjang sumbu OX dan OY.  Semua posisi dan ukuran dibuat bilangan bulat.  Pembuat mobil mengabaikan objek tersembunyi. <br><br><img src="https://habrastorage.org/webt/pe/id/cq/peidcqq35yq5dnw-ohma-pdbw0s.jpeg"><br><br>  Di Photoshop, ada 5 jenis lapisan: grup, piksel, bentuk, teks, dan objek pintar. <br><br><ol><li>  <b>Grup (lapisan grup)</b> di pembuat otomatis berubah menjadi objek game kosong, sehingga komponen antarmuka yang besar seperti had, slot, grup slot, dan sebagainya dapat dengan mudah digabungkan menjadi grup. </li><li>  <b>Lapisan piksel</b> hanya menjadi Gambar dengan warna putih.  Itu bisa berupa ikon, punggung, gambar, kunang-kunang.  Kemudian mereka secara manual ditambahkan ke proyek, seperti sprite, dan dimasukkan ke dalam Image. </li><li>  <b>Bentuk (shape layer)</b> menjadi gambar dengan <b>bentuk</b> warna.  Ini bisa berupa elemen vektor: tata letak, ikon, dan lainnya. </li><li>  <b>Teks</b> dalam autocomputer menjadi TextMeshProUGUI dan mewarisi teks, font, warna, stroke, bayangan, gradien, ukuran font, posisi (kanan, tengah, kiri). </li><li>  <b>Benda pintar</b> menjadi <b>objek</b> game kosong yang biasa.  Adalah logis untuk menggunakan objek pintar untuk melakukan apa yang telah dikenakan sebagai prefab bersarang (misalnya, bilah teratas, yang sama di mana-mana) </li></ol><br>  Auto-wrapper juga tahu bagaimana mengumpulkan warna dari semua tempat (misalnya, warna bentuk, warna font, efek warna, lapisan warna) dan mengonversinya menjadi satu hex.  Begitu pula dengan transparansi. <br><br>  Secara terpisah, perancang UI segera menempatkan opsi dalam nama lapisan dan grup (seperti dalam Zeplin). <br><br><div class="spoiler">  <b class="spoiler_title">Contoh opsi dalam tabel</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Opsi </th><th>  Argumen </th><th>  Nilai </th><th>  Contoh </th><th>  Objek dalam Persatuan </th></tr><tr><td>  -l </td><td>  Nama pedoman dari pedoman (tanpa spasi) </td><td>  Menambahkan sprite ke gambar </td><td>  Layout Hud -l pink228 </td><td>  Image_HudLayout dengan komponen Gambar dengan tata letak pink228 sprite dimasukkan dari pedoman </td></tr><tr><td>  -cs </td><td>  Style_name.  Opsional (tanpa spasi) </td><td>  Menambahkan ColorStyleComponent dengan style StyleName. </td><td>  Layout Hud -cs HudLayoutColors <br>  Tata letak hud -cs </td><td>  Image_HudLayout dengan komponen ColorStyleComponent dengan gaya di dalam HudLayoutColors <br>  Image_HudLayout dengan komponen ColorStyleComponent </td></tr><tr><td>  -ts </td><td>  Style_name.  Opsional (tanpa spasi) </td><td>  Menambahkan TextStyleComponent dengan style StyleName. </td><td>  Kemampuan -tsAbilityColors <br>  Kemampuan -ts </td><td>  Text_Ability dengan komponen TextStyle dengan gaya di dalam AbilityColors <br>  Text_Ability dengan komponen TextStyle </td></tr><tr><td>  -b </td><td>  Style_name. <br>  Opsional (tanpa spasi) </td><td>  Menambahkan ButtonStyleComponent dengan style StyleName </td><td>  Mainkan -b -bs </td><td></td></tr><tr><td>  -b </td><td></td><td>  Ini tombolnya. </td><td>  Mainkan -b <br>  Mainkan -b -l 1 </td><td>  Button_Play dengan Tombol dan Gambar <br>  Button_Play dengan komponen Button dan Image dengan tata letak yang disisipkan sprite 1 dari pedoman </td></tr><tr><td>  Opsional </td><td></td><td></td><td></td><td></td></tr><tr><td>  -hg </td><td></td><td>  Grup horizontal (khusus di grup) </td><td>  Modul Tombol - hg </td><td>  ModuleButtons dengan komponen Grup tata letak horizontal </td></tr><tr><td>  -vg </td><td></td><td>  Grup vertikal (khusus pada grup) </td><td>  Modul Tombol - vg </td><td>  ModuleButtons dengan komponen <br>  Grup tata letak vertikal </td></tr></tbody></table></div><br></div></div><br>  Keuntungan alat ini: tata letak yang cepat, menyimpan hierarki, menambahkan komponen yang diperlukan, menyatukan nama-nama objek game, secara otomatis menambahkan gaya dengan nama, mematikan rakecast di tempat yang tidak diperlukan, perkiraan pemasangan. <br><br>  Tetapi pendekatan ini memiliki kelemahan: jika tata letak psd dibuat dari 1000 lapisan untuk satu tombol saja, itu akan praktis tidak berguna, dalam hal ini disarankan untuk menambahkan tombol ke objek pintar.  Selain itu, alat ini membutuhkan penamaan yang normal dan benar dari perancang UI - tidak akan lagi mungkin memberi nama lapisan "Rectangle_copy_21_1005".  Di sisi lain, ini membuat tata letak lebih mudah dibaca untuk desainer UI lainnya. <br><br>  Rencananya akan datang dengan sistem yang akan menyelamatkan dari ekspor sprite substrat. <br><br>  Tata letak dengan sembulan pembuat otomatis dari artikel ini membutuhkan waktu 3 menit 13 detik (kecuali untuk membuang sprite ke dalam proyek).  Pena membutuhkan waktu 18 menit 32 detik.  Pada saat yang sama, ada juga masalah dalam tata letak dengan pena - di beberapa tempat, posisi yang salah bahwa mata tajam seorang desainer UI akan melihat dan harus diulang.  Karena itu, tata letak otomatis juga bagus karena menghilangkan faktor manusia. <br><br>  Dan beberapa ulasan tentang pembuat mobil: <br><blockquote>  <i>"Pembuat mobil secara signifikan mempercepat pekerjaan, tetapi sejauh ini, tampaknya perlu untuk menyederhanakan ambang entri, instalasi, dan konfigurasi"</i> </blockquote><blockquote>  <i>"Saya pikir jika Anda mengatur gaya untuk penata huruf, itu tidak jauh berbeda dalam waktu, tetapi perancang dan pemrogram akan menghemat waktu dan saraf tentunya"</i> </blockquote><blockquote>  <i>"Masalahnya sangat keren))"</i> </blockquote><blockquote>  <i>â€œGaya - topiknya sangat keren, ini tidak cukup dalam proyek kami, karena mereka suka mengecat tombol pada tata letak, teks, dll.</i>  <i>Sangat menyenangkan bahwa sekarang ini dapat diperbaiki di stylist dan tidak ada sakit kepala, bahwa Anda memiliki warna yang berbeda atau sprite berbeda di tempat yang seragam â€</i> </blockquote><blockquote>  <i>â€œDesainer UI sendiri harus melakukan tata letak, karena hanya mereka yang tahu fitur tata letak mereka.</i>  <i>Dan perancang tata letak otomatis adalah hal yang hebat bagi mereka yang tidak ingin memahami seluk-beluk tata letak.</i>  <i>Jika instrumen memiliki antarmuka yang intuitif dan belajar dari Figma, itu akan menjadi sangat mewah. "</i> </blockquote>  Secara pribadi, saya berpikir bahwa segala sesuatu yang dapat diotomatiskan harus otomatis, dan orang-orang harus diberi kesempatan untuk terlibat dalam pekerjaan yang lebih kreatif dan inventif. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462835/">https://habr.com/ru/post/id462835/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462821/index.html">Cara mengevaluasi komputer yang belum ada</a></li>
<li><a href="../id462825/index.html">Laporan Video dari Pertemuan Droid Musim Panas</a></li>
<li><a href="../id462827/index.html">Kehidupan dan Sukses Larry Ellison, Pendiri Oracle</a></li>
<li><a href="../id462831/index.html">Naik Gelombang Web 3.0</a></li>
<li><a href="../id462833/index.html">Buku "Pemodelan prediktif dalam praktik"</a></li>
<li><a href="../id462837/index.html">Pengujian Kotak Hitam</a></li>
<li><a href="../id462843/index.html">Keterbatasan game 8-bit dan rekreasi tepatnya di Unity</a></li>
<li><a href="../id462845/index.html">Pijat untuk otak Anda: bicara tentang ASMR</a></li>
<li><a href="../id462847/index.html">Webinar Hewlett Packard Enterprise pada Agustus-Oktober 2019</a></li>
<li><a href="../id462849/index.html">Sesuatu tentang inode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>