<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóëÔ∏è üßùüèª üÜí Angriffe auf Bypass-Kan√§le: Jetzt werden nicht nur PCs, sondern auch Smartphones angegriffen (analytische √úberpr√ºfung) ü§∏üèº üïü üç®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Obwohl mobile Ger√§te immer mehr nachgefragt werden und Angriffe auf Cache-Speicher-Bypass-Kan√§le (im Folgenden als Cache-Angriffe bezeichnet) eine lei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angriffe auf Bypass-Kan√§le: Jetzt werden nicht nur PCs, sondern auch Smartphones angegriffen (analytische √úberpr√ºfung)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455310/"><p>  Obwohl mobile Ger√§te immer mehr nachgefragt werden und Angriffe auf Cache-Speicher-Bypass-Kan√§le (im Folgenden als Cache-Angriffe bezeichnet) eine leistungsstarke Methode sind, um die moderne Mikroprozessorelektronik zu knacken, gab es bis 2016 nur wenige Ver√∂ffentlichungen zur Anwendbarkeit dieser Angriffe auf Smartphones .  Dar√ºber hinaus beschr√§nkten sich diese fr√ºhen Ver√∂ffentlichungen auf die Ber√ºcksichtigung von Angriffen auf die AES-Tabelle und ber√ºhrten nicht modernere Methoden f√ºr internukleare Angriffe: Prime + Probe [6], Flush + Reload [6], Evict + Reload [7], Flush + Flush [8], Rowhammer [ 9].  Dar√ºber hinaus wurde bis 2016 angenommen, dass interne Cache-Angriffe nur auf Intel- und AMD-Plattformen ausgef√ºhrt werden konnten, k√ºrzlich jedoch auch f√ºr ARM-Plattformen (auf Smartphones und anderen Mobilger√§ten).  [6] </p><br><p>  In den letzten Jahren hat das Interesse von Cybersicherheitsexperten an Cache-Angriffen auf Smartphones stark zugenommen.  Dieser Artikel ist eine analytische √úbersicht √ºber die wichtigsten Entdeckungen in diesem Bereich f√ºr den Zeitraum von 2015 bis 2017. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Geschichte der Bypass-Kan√§le</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Warum Cache-Angriffe auf ARM so einzigartig sind</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Verschiedene Cache-Angriffe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- - R√§umung + Zeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- - Prime + Probe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- - Sp√ºlen + Nachladen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- - R√§umung + Nachladen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- - Sp√ºlen + Sp√ºlen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- - AnC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Rowhammer-Effekt</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Deduplizierung des Systemspeichers</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Pseudoisolation des Kernels des Betriebssystems</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Versteckte interne und Interprozessor-Kan√§le</a> </p><br><p><img src="https://habrastorage.org/webt/ys/jo/7g/ysjo7gybyvqu-okdlkrkilqrnrw.jpeg"></p><a name="habracut"></a><br><p>  Bei Cache-Angriffen auf AES-Tabellen wird die anf√§llige Implementierung von AES-Tabellen weiterhin als De-facto-Standard verwendet, obwohl seit einiger Zeit bekannt ist, dass diese Angriffe <em>m√∂glich</em> sind.  auch in modernen eingebetteten Kryptoger√§ten wie SIM-Karten.  Beispielsweise verwenden 3G / 4G-Netzwerke den AES-Authentifizierungsalgorithmus MILENAGE.  Sein Kompromiss erm√∂glicht es Ihnen, USIM-Karten zu klonen und Gespr√§che zu belauschen.  T.O.  Cache-Angriffe auf Bypass-Kan√§le sind sowohl f√ºr SIM-Karten (f√ºr den Zugriff auf das 2G-Netzwerk) als auch f√ºr USIM-Karten (f√ºr den Zugriff auf 3G / 4G-Netzwerke) relevant.  Im Jahr 2015 wurde der ‚ÄûDifferential Power Attack‚Äú (DPA) beschrieben - ein Angriff, bei dem Verschl√ºsselungsschl√ºssel (vom MILENAGE-Algorithmus verwendet) und andere Geheimnisse der USIM-Karte in nur wenigen Minuten wiederhergestellt werden.  [3] </p><br><a name="a1"></a><br><h1 id="istoriya-obhodnyh-kanalov">  Geschichte der Bypass-Kan√§le </h1><br><ul><li>  Da die Software immer komplexer wird und die Anzahl der erweiterten Softwareschutzfunktionen zunimmt, wird das Hacken des Systems auf Hardwareebene, insbesondere die Verwendung von Cache-Angriffen √ºber Bypass-Kan√§le, zu einer zunehmend attraktiven Alternative.  Diese Angriffe basieren auf Schwachstellen in der Prozessor-Speicher-Architektur.  [4] </li><li>  1985 wurde die Technologie zum Lesen von Informationen von Videodisplays eingef√ºhrt - durch Messung der von ihnen induzierten elektromagnetischen Interferenz [10].  Basierend auf dieser Technologie wurde 2014 ein Keylogger entwickelt, der auf einem Smartphone und einer Radioantenne basiert.  [12] </li><li>  1996 wurde gezeigt, dass durch sorgf√§ltige Messung des Zeitaufwands f√ºr Operationen mit privaten Schl√ºsseln verschiedene kryptografische Systeme wie die DES-Verschl√ºsselung gehackt werden k√∂nnen.  Im Jahr 2016 wurde erstmals der Angriff auf Bypass-Kan√§le auf einem Verschl√ºsselungsger√§t mit fortschrittlicher elliptischer Kryptographie demonstriert.  W√§hrend des Angriffs wurde der geheime Entschl√ºsselungsschl√ºssel vom Zielger√§t in einem anderen Raum extrahiert.  [13] </li><li>  1997 wurde die "Differential Distortion Method" (DFA) eingef√ºhrt - ein Angriff, bei dem verschiedene Modelle von Mikroausf√§llen sowie verschiedene Methoden der Kryptoanalyse verwendet werden.  um geheime Einstellungen von Smartcards und anderen Ger√§ten wiederherzustellen, die vor unbefugtem Zugriff gesch√ºtzt sind.  [11] Wenn Sie physischen Zugriff auf das Ger√§t haben, k√∂nnen Sie die Versorgungsspannung und die Frequenz des Taktsignals √§ndern.  oder Umgebungsbedingungen (Temperatur usw.) - um eine Fehlfunktion der Smartcard zu verursachen.  Dar√ºber hinaus k√∂nnen Fehlfunktionen der Ger√§te ausgel√∂st werden - auch allein durch Software-Eingriffe.  und daher kann es im Fernzugriffsmodus durchgef√ºhrt werden. </li><li>  Im Jahr 2014 wurde ein Angriff auf Cache-Byp√§sse demonstriert.  Bei diesem Angriff werden Informationslecks verwendet, die durch die unterschiedliche Zugriffszeit auf die Daten verursacht werden, je nachdem, ob sie sich im Cache befinden oder nicht.  also  Dieser Angriff macht deutlich, mit welchen Daten der untersuchte Code k√ºrzlich gearbeitet hat.  W√§hrend dieses Angriffs wurde eine vollst√§ndige Wiederherstellung der AES-Schl√ºssel demonstriert.  [9] Wenig sp√§ter, im Jahr 2015, wurde gezeigt, dass Cache-Bypass-Kan√§le nicht nur zum Angriff auf kryptografische Systeme, sondern auch zum Sammeln von Informationen √ºber Tastenanschl√§ge verwendet werden k√∂nnen.  [14] </li><li>  Im Jahr 2014 wurde gezeigt, dass der Zugriff auf dieselbe Speicherzelle mit einer hohen Frequenz eine spontane Bitumschaltung in DRAM-Chips hervorrufen kann (Rowhammer-Effekt).  [9] Da DRAM auf die kleinste Gr√∂√üe skaliert, ist es nicht einfach, elektrische Interferenzen zwischen einzelnen Zellen zu verhindern.  Deshalb f√ºhrt die Aktivierung einer bestimmten Zeile aus dem Speicher zu einer Verzerrung der Daten in benachbarten Zeilen. </li><li>  Im Jahr 2015 wurde gezeigt, dass der Rowhammer-Effekt verwendet werden kann, um die Berechtigungen f√ºr den Superuser zu erh√∂hen.  [15] Im selben Jahr wurde gezeigt, dass eine spontane Bitumschaltung auch durch auf die Website hochgeladenen Java-Code ausgel√∂st werden kann.  [7] Dieses Szenario wurde urspr√ºnglich nur f√ºr Intel- und AMD-Systeme mit DDR3- und DDR4-Modulen implementiert.  [16, 17] 2016 wurde dieser Angriff jedoch auch auf ARM-Plattformen demonstriert.  [1] Im selben Jahr wurde gezeigt, dass Cache-Angriffe auch zur √úberwachung der Cache-Aktivit√§t in TrustZone verwendet werden k√∂nnen.  [1] </li><li>  Im Jahr 2016 wurde ein ‚ÄûReverse Engineering‚Äú f√ºr die DRAM-Adressierungsfunktionen durchgef√ºhrt, die √ºblicherweise in modernen Smartphones verwendet werden.  Infolgedessen wurden zus√§tzliche M√∂glichkeiten zum Umschalten von Bits entdeckt, die f√ºr die Implementierung auf Millionen von Android-Ger√§ten verf√ºgbar sind, ohne dass im privilegierten Modus gearbeitet werden muss.  [1] </li><li>  2016 wurde erstmals der Angriff auf die letzte Ebene des ARM-Prozessor-Cache demonstriert.  Dieser Angriff kann f√ºr interne und Interprozess-Cache-Angriffe auf Bypass-Kan√§le implementiert werden.  [1] </li></ul><br><a name="a2"></a><br><h1 id="chem-tak-unikalny-kesh-ataki-na-arm">  Warum Cache-Angriffe auf ARM so einzigartig sind </h1><br><ul><li>  Angriffsmethoden wie Flush + Reload und Flush + Flush - Verwenden Sie die nicht privilegierte Anweisung zum Zur√ºcksetzen von x86-Clflush, um eine Datenzeile aus dem Cache zu entfernen.  Mit Ausnahme von ARMv8-A-Prozessoren verf√ºgen ARM-Plattformen jedoch nicht √ºber Anweisungen zum Zur√ºcksetzen des Cache.  Daher wurde 2016 eine indirekte Cache-Extrusionsmethode unter Verwendung des Rowhammer-Effekts vorgeschlagen.  [1] </li><li>  Um einen erfolgreichen Cache-Angriff durchzuf√ºhren, werden Informationen wie die genaue Zykluszeit f√ºr den Zugriff auf eine Speicherzelle ben√∂tigt.  Fr√ºhe Cache-Angriffe verwendeten f√ºr diese Zwecke Systemleistungsindikatoren. Diese Methode ist jedoch ineffizient, da diese Z√§hler auf ARM-Prozessoren nur im privilegierten Modus verf√ºgbar sind.  Im Jahr 2016 wurden jedoch drei alternative Synchronisationsquellen vorgeschlagen, einschlie√ülich der im nicht privilegierten Modus verf√ºgbaren.  [1] Eine davon ist der Start eines parallelen Synchronisationsstroms, der eine globale Variable kontinuierlich inkrementiert.  Durch Lesen des Werts dieser Variablen kann ein Angreifer die Zykluszeit f√ºr den Zugriff auf eine Speicherzelle messen. </li><li>  Dar√ºber hinaus ist die sogenannte.  Pseudozuf√§llige Substitutionsrichtlinie, wodurch das Verdr√§ngen des Caches weniger vorhersehbar ist als bei Intel- und AMD-Prozessoren.  Trotzdem wurde 2016 ein effektiver Cache-Angriff auch unter solch lauten Bedingungen demonstriert - f√ºr drei Smartphones: ‚ÄûOnePlus One‚Äú (verwendet ‚ÄûSnapdragon 801 SoC‚Äú mit ‚ÄûKrait 400‚Äú -Prozessor der ARMv7-A-Architektur), ‚ÄûAlcatel One Touch Pop 2 ‚Äú(verwendet‚Äû Snapdragon 410 SoC ‚Äúmit‚Äû CortexA53 ‚Äú-Prozessor der ARMv8-A-Architektur),‚Äû Samsung Galaxy S6 ‚Äú(verwendet‚Äû Samsung Exynos 7 Octa 7420 SoC ‚Äúmit zwei Prozessorclustern‚Äû ARMv8-A ‚Äú).  [1] </li></ul><br><a name="a3"></a><br><h1 id="raznovidnosti-kesh-atak">  Verschiedene Cache-Angriffe </h1><br><ul><li>  Im Allgemeinen kann ein Cache-Angriff auf Bypass-Kan√§le in drei Stufen unterteilt werden: 1) Identifizierung des mikroarchitektonischen Signals, das aus dem "undichten" elektronischen System "sickert";  Typische Beispiele f√ºr solche leckenden mikroarchitektonischen Signale sind der Stromverbrauch und die elektromagnetische Strahlung von integrierten Schaltkreisen.  [2, 3];  2) √úberwachung und Analyse dieses Signals w√§hrend des Systembetriebs;  3) die Identifizierung von Musterunterschieden mikroarchitektonisches Signal.  [2] <a name="a31"></a></li><li>  <strong>R√§umung + Zeit.</strong>  Die Grundidee besteht darin, zu bestimmen, auf welche Cache-Sets das Opferprogramm zugreift.  Algorithmus: 1) Messung der Ausf√ºhrungszeit des Opferprogramms;  2) einen bestimmten Teil des Caches verschieben;  3) Messen Sie die Ausf√ºhrungszeit des Opferprogramms erneut.  Anhand der Zeitdifferenz zwischen den beiden Dimensionen k√∂nnen Sie bestimmen, wie viel Zeit ein bestimmter Teil des Caches zur Laufzeit vom Opfer verwendet wurde.  Im Jahr 2010 wurde eine leistungsstarke Art von Angriff auf der Basis von Evict + Time demonstriert - gegen AES auf OpenSSL;  ohne offene und verschl√ºsselte Texte.  [18, 19] <a name="a32"></a></li><li>  <strong>Prime + Probe.</strong>  Mit dieser Methode kann ein Angreifer - wie mit der vorherigen - bestimmen, auf welche Cache-Sets das Opferprogramm zugreift.  Algorithmus: 1) F√ºllen Sie einen bestimmten Teil des Caches;  2) √úbertragung der Kontrolle auf das Opferprogramm;  3) Bestimmen Sie, welcher Teil des vollst√§ndigen Caches noch zu uns geh√∂rt.  Dies kann durch Messen der Zugriffszeit auf die Adressen erfolgen, mit denen der Angreifer in der ersten Stufe den Cache gef√ºllt hat.  T.O.  Wenn das Opferprogramm Adressen verwendet, die denselben Bereichen des Caches zugeordnet sind wie der Angreifer, werden die Daten des Angreifers aus dem Cache entfernt.  und ein Angreifer kann dies in der dritten Stufe verfolgen.  In [19] wurde ein Angriff mit diesem Mechanismus demonstriert - auf OpenSSL AES und Linux dm-crypt.  Im Jahr 2015 [20] wurde gezeigt, wie Sie mit Prime + Probe den verdeckten Kanal zwischen Kern und Maschine einbinden und dann ElGamal in GnuPG angreifen k√∂nnen.  Im selben Jahr wurde ein erfolgreicher Angriff auf die Implementierung von OpenSSL AES in der Cloud demonstriert.  [21] <a name="a33"></a></li><li>  <strong>Sp√ºlen + Nachladen.</strong>  Im Jahr 2011 [22] wurde gezeigt, wie Clflush verwendet werden kann, um AES anzugreifen.  Clflush wird verwendet, um eine verfolgte Speicherzelle aus dem Cache zu verschieben.  Anschlie√üend wird √ºberpr√ºft, ob diese Zelle erneut in den Cache geladen wurde, nachdem das Opferprogramm eine kleine Anzahl von Anweisungen ausgef√ºhrt hat.  Algorithmus: 1) Projizieren Sie eine Bin√§rdatei (z. B. ein gemeinsam genutztes Objekt) in ihren Adressraum (unter Verwendung eines geeigneten Systemaufrufs wie mmap).  2) Extrudieren der Cache-Zeile (Code oder Daten) aus dem Cache;  3) √úbertragung der Kontrolle auf das Opferprogramm;  4) √úberpr√ºfen Sie, ob diese Cache-Zeile (aus Abschnitt 2) vom Opferprogramm geladen wurde (diese √úberpr√ºfung erfolgt durch Messen der Zugriffszeit auf die Speicherzelle).  Im Jahr 2014 wurde die vollst√§ndige Wiederherstellung des geheimen AES-Schl√ºssels in der virtuellen VMWare-Maschine durch einen Flush + Reload-Cache-Angriff demonstriert.  [23] Im selben Jahr wurde mit demselben Angriff die Wiederherstellung des geheimen Schl√ºssels des OpenSSL-Algorithmus ECDSA (digitaler Signaturalgorithmus basierend auf elliptischen Kurven) demonstriert.  [24] Im Jahr 2015 wurde durch den Flush + Reload-Angriff der Systemmechanismus der ‚ÄûSpeicher-Deduplizierung‚Äú gef√§hrdet.  Infolgedessen besteht die M√∂glichkeit einer nicht autorisierten Kommunikation zwischen virtuellen Maschinen, die auf einer gemeinsamen physischen Maschine ausgef√ºhrt werden.  [25] Im selben Jahr wurde gezeigt, wie mit Flush + Reload Informationen dar√ºber abgerufen werden k√∂nnen, welche kryptografischen Bibliotheken von verschiedenen virtuellen Maschinen verwendet werden, die auf einer gemeinsamen physischen Maschine ausgef√ºhrt werden.  [26] Im Jahr 2015 wurde auch gezeigt, dass die Flush + Reload-Methode nicht nur kryptografische Systeme angreift, sondern auch f√ºr einen Keylogger verwendet werden kann.  [14] <a name="a34"></a></li><li>  <strong>R√§umung + Nachladen.</strong>  Es wurde 2015 eingef√ºhrt [14].  Verwendet Flush + Reload f√ºr die Extrusion - anstelle von Extrusionsanweisungen.  Obwohl dieser Angriff f√ºr x86 nicht sinnvoll ist (da clflush keine Berechtigungen ben√∂tigt), ist er f√ºr ARM-Prozessoren sehr relevant (da eine solche Anweisung nur im privilegierten Modus verf√ºgbar ist).  Das Wesentliche bei Evict + Reload ist, dass wir den Cache mit einer gro√üen Anzahl miteinander verbundener Adressen f√ºllen, um die gew√ºnschte Zelle aus dem Cache herauszudr√ºcken. Infolgedessen entscheidet der f√ºr das Verdr√§ngen verantwortliche Mechanismus, die ben√∂tigte Cache-Zelle herauszudr√ºcken.  Dar√ºber hinaus wurde 2016 gezeigt, dass eine effiziente und schnelle Pr√§ventivstrategie mithilfe von in JavaScript geschriebenen Applets eine spontane Bitumschaltung in benachbarten Zeilen von DRAM-Modulen (aufgrund des Mehrfachzugriffs auf dieselbe Speicherleitung) initiieren kann.  [24] So.  Cache-Angriffe h√§ngen nicht mehr von privilegierten Anweisungen zum Leeren des Cache wie clflush ab. <a name="a35"></a></li><li>  <strong>Sp√ºlen + Sp√ºlen.</strong>  Attacks Flush + Reload und Prime + Probe verursachen zahlreiche Cache-Zugriffe, deren Dauer gemessen werden kann (√ºber Systemleistungsindikatoren).  Der 2015 eingef√ºhrte Flush + Flush-Angriff basiert genau auf diesen Beobachtungen.  [8] Der Angriff ist fast der gleiche wie Flush + Reload.  Ein bin√§res oder geteiltes Dateiobjekt wird dem Adressraum des Angreifers zugeordnet.  Die Speicherzelle wird aus dem Cache gezwungen und die Steuerung wird an das Opferprogramm √ºbertragen.  Anstelle der Neustartphase, in der auf die beobachtete Zelle zugegriffen wird, wird sie jedoch erneut ersetzt.  ohne Fehler zu verursachen, im Vergleich zu Flush + Reload oder Prime + Probe.  T.O.  Es ist leicht zu erkennen, ob ein Speicherort zwischengespeichert ist oder nicht. <a name="a36"></a></li><li>  <strong>AnC.</strong>  Dies ist eine neuere Modifikation des 2017 eingef√ºhrten Cache-Angriffs ‚ÄûEvict + Time‚Äú.  [4] Ein charakteristisches Merkmal von AnC ist, dass dieser Cache-Angriff auf der Analyse von zwischengespeicherten Seitentabellen beruht, die in den meisten modernen Prozessoren (Intel, AMD, ARM) verwendet werden.  [4] Das Herzst√ºck eines jeden Prozessors ist heute eine "Speicherverwaltungseinheit" (MMU), die die Verwaltung des verf√ºgbaren physischen Speichers vereinfacht - durch ihre Virtualisierung.  zur sp√§teren Verwendung durch mehrere Prozesse.  Die MMU verwendet die Datenstruktur "Seitentabelle", um virtuelle und physische Speicherzellen abzubilden.  Seitentabellen sind ein attraktives Ziel f√ºr Hardware-Angriffe.  Zum Beispiel das spontane Umschalten von nur einem Bit (verursacht durch den Rowhammer-Effekt) in der "Seitentabelle" - es kann f√ºr den Angreifer ausreichend sein, die Kontrolle √ºber die physische Adresse des Speichers zu erlangen, auf den er keinen Zugriff erhalten soll;  und dies kann ausreichen, um Superuser-Berechtigungen zu erlangen.  [4] </li></ul><br><a name="a4"></a><br><h1 id="effekt-rowhammer">  Rowhammer-Effekt </h1><br><ul><li>  Ein separater DRAM-Chip hat eine geringe Kapazit√§t und daher sind mehrere Mikroschaltungen auf einer Platine miteinander verbunden - um die sogenannte zu bilden  DRAM-Serie.  Ein DRAM-Speichermodul kann eine oder mehrere DRAM-Zeilen enthalten.  Ein DRAM-Chip besteht aus einer zweidimensionalen Anordnung von Zellen.  Jede DRAM-Zelle ist ein Kondensator;  0 und 1 sind der geladene oder entladene Zustand des Kondensators.  Jede Zelle im Gitter ist √ºber Kabel mit einer benachbarten Zelle verbunden.  Wenn eine Zelle aktiviert ist, wird die Spannung sowohl an ihren Kondensator als auch an alle anderen Kondensatoren derselben Reihe angelegt.  Da Speicherzellen im Zuge des technologischen Fortschritts immer kleiner und n√§her beieinander werden, wirkt sich die durch die Aktivierung einer Speicherleitung verursachte Interferenz sehr h√§ufig auf die Kondensatorladungen benachbarter Leitungen aus.  2014 wurde gezeigt [9], dass ein h√§ufiger Zugriff auf dieselbe DRAM-Speicherzelle zum Rowhammer-Effekt f√ºhrt - spontanes Bit-Switching.  Dieser Effekt kann verwendet werden, um die Berechtigungen zu erh√∂hen (z. B. um die Sicherheits-Sandbox zu verlassen [15]).  Es kann unter anderem durch die Ausf√ºhrung von nicht privilegiertem JavaScript-Code auf der Website implementiert werden. </li><li>  Um eine bestimmte Speicherzelle zu ‚Äûverstopfen‚Äú, muss ein Angreifer zwei Adressen in derselben DRAM-Bank finden - jedoch in unterschiedlichen Leitungen.  Bestimmte Adressbits werden verwendet, um die Leitung, den Kanal und die Bank des Speicherorts auszuw√§hlen.  Wie die Abtastfunktion funktioniert, ist jedoch nicht dokumentiert.  Daher wurde 2015 [27] ein Mechanismus zur vollst√§ndigen Automatisierung des Reverse Engineering der entsprechenden Funktion eingef√ºhrt.  unter Verwendung der Tatsache, dass "String-Konflikte" zu einer Verl√§ngerung der Zugriffszeit auf den Speicher f√ºhren.  Der Ansatz besteht im Wesentlichen darin, nach Adressen zu suchen, die derselben DRAM-Bank zugeordnet sind, jedoch in einer anderen Zeile.  durch wiederholtes Messen der Zugriffszeit auf zwei zuf√§llige Adressen.  Bei einigen Adresspaaren ist die Zugriffszeit l√§nger als bei anderen. Dies bedeutet, dass sie zu verschiedenen Leitungen geh√∂ren, jedoch zur selben Bank.  Dann werden diese Adressen in Gruppen mit demselben Kanal, derselben Leitung und derselben Bank gruppiert.  Diese identifizierten Adressen werden dann verwendet, um die Adressierungsfunktion zu rekonstruieren - indem alle linearen Funktionen erzeugt und auf alle Adressen aus einer willk√ºrlich ausgew√§hlten Teilmenge angewendet werden.  T.O.  Da der Suchraum klein ist, ist Brute Force Brute Force hier sehr effektiv.  [1] </li><li>  Die ersten Implementierungen von Angriffen mit dem Rowhammer-Effekt beruhten entweder auf probabilistischen Methoden (aufgrund derer ein ungeplanter Systemabsturz w√§hrend des Angriffs auftreten k√∂nnte);  oder spezielle Speicherverwaltungsfunktionen: Speicher-Deduplizierung, MMU-Paravirtualisierung, Pagemap-Schnittstelle.  Solche Funktionen auf modernen Ger√§ten sind jedoch entweder √ºberhaupt nicht verf√ºgbar oder aus Sicherheitsgr√ºnden deaktiviert.  [30] </li><li>  Daher wurde 2016 der Drammer-Angriff eingef√ºhrt - frei von den aufgef√ºhrten Nachteilen und Einschr√§nkungen.  Es st√ºtzt sich nur auf die aktuellen Funktionen moderner Betriebssysteme, die ohne Superuser-Rechte verf√ºgbar sind.  Insbesondere das vorhersehbare Verhalten des Teilsystems bei der Verteilung des physischen Speichers.  Diese Vorhersagbarkeit wird verwendet, um die Verteilung des physischen Speichers (in dem vertrauliche Daten verarbeitet werden, z. B. Tabellen mit Speicherseiten) an einem anf√§lligen Ort des vom Angreifer ausgew√§hlten physischen Speichers zu erreichen.  Die entsprechende Technik zum "Massieren des Ged√§chtnisses" wurde Phys Feng Shui genannt.  Um die Funktionsf√§higkeit des Drammer-Angriffs zu demonstrieren, wird eine Exploit-Implementierung bereitgestellt, die den Zugriff auf das Stammverzeichnis eines Android-Ger√§ts erm√∂glicht.  Dieser Exploit kann von jeder Anwendung ohne besondere Erlaubnis gestartet werden.  und ohne eine Software-Schwachstelle auszunutzen.  [30] </li><li>  T.O.    Drammer  ,      Rowhammer       (   Intel  AMD),      (  ARM-);   ,           . [30] </li><li>  2016     ¬´ ¬ª Flip Feng Shui (FFS) ‚Äì     Rowhammer,            ;       ;         .     FFS    ,    Ubuntu/Debian. [31] </li><li>  2017   ,   MLC NAND  -,      SSD-, ‚Äì   ,   Rowhammer.            .      ‚Äì    .  [5] </li></ul><br><a name="a5"></a><br><h1 id="dedublikaciya-sistemnoy-pamyati">    </h1><br><ul><li>   -          ;       .      ,    ;          .  [1] </li><li>   ( ) ‚Äì    ,      ,             .          (      ‚Äì   ,     ).   ,        ‚Äì         ,        .                  ‚Äì      .  [1] </li><li>   ‚Äì          ;        Windows 8.1  10.          ‚Äì    ,     ¬´  ¬ª.       ‚Äì          .      ,        ,      .  ,      ¬´ ¬ª,         ,     . ,      ,      ,       . [35] </li><li>  2016   ,          ‚Äì        .      . -,  ,        , ‚Äì       ;        (,  64- ). -,  ,      ,      ,         . -,  ,            ,     -  ‚Äì         . [35] </li><li>           ,    JavaScript-    Microsoft Edge ‚Äì            .            ;      .  ,    - ngnix  ,      ,     :             ,      . [35] </li><li>  T.O.           .      ,    ,          . [35] </li></ul><br><a name="a6"></a><br><h1 id="psevdoizolyaciya-yadra-operacionnoy-sistemy">     </h1><br><ul><li> ASLR (   )    (    )       .   ¬´¬ª       ,     .  ,    ¬´ ¬ª   ,                .      ,     ASLR ‚Äì -  . [33] </li><li>   2016       ASLR      32-  64-  Linux,      ¬´ ¬ª.      ,          ,     ‚Äì      .        .  T.O. ASLR     . [33] </li><li>      ASLR ‚Äì      ,     ,   .. ¬´- ¬ª (ROP).  ,   ,      ,  ,        .           . [37] </li><li>   2017      KAISER,    ,          .     ,     , ‚Äì      ,     . [37]  , KAISER      BTB (  ),   2016 . [36] </li><li>  2016        (BTB). BTB-   30    .       -,    BTB, ‚Äì     .       ,    30- ,    ‚Äì        .     ,        ,      . BTB-         .          ,   Intel Skylake (Intel Skylake i7-6700K),         .     . [36] </li><li>   2017   ,  ,              -     . [34] </li></ul><br><a name="a7"></a><br><h1 id="mezhyadernye-i-mezhprocessornye-skrytye-kanaly">      </h1><br><ul><li>       .    -        ‚Äì    ,     .   ,              . [29] </li><li> -        - ‚Äì   ;  Flush+Reload, Evict+Reload  Flush+Flush.             -    .      ¬´¬ª    ¬´ ¬ª.    Android     ,        , ‚Äì        ;     (.  [28]).  T.O.     . </li><li>       ,         -  .      ‚Äì        . ,  -    ,   ,   ,  .  [1]     ;      ;   ¬´ ¬ª  ¬´ ¬ª,      ;     .  -  TCP   . </li><li>  2017          ,    SSH,      (45 /);               .   SSH-,    ,   ,    telnet-. [29] </li><li>  2015           ,         .              ‚Äì       (    ,       ),                .            . [32] </li><li>      ,       .     . -,            ;       ,      ; ..        ,      . -,         (       ). [32] </li><li> ,       ,               (16 ).  ,   ¬´ ¬ª   Intel Xeon (    8 )  12,5/.         5   4 . [32] </li><li>   2015          ,           .  ,            ,            ‚Äì        . [32] </li><li>  2016         Android,    250  ,  -    .  [1] </li></ul><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> <strong>1.</strong> <em>Moritz Lipp, Daniel Gruss.</em>  ARMageddon: Cache-Angriffe auf mobile Ger√§te // Ablauf des 25. USENIX-Sicherheitssymposiums.  2016. pp.  549-564. <br>  <strong>2.</strong> <em>Robert Callan.</em>  Eine praktische Methode zur Messung des Seitenkanalsignals, das dem Angreifer f√ºr Ereignisse auf Befehlsebene zur Verf√ºgung steht // 47. Internationales IEEE / ACM-Symposium f√ºr Mikroarchitektur (MICRO), Seiten 242-254, Dezember 2014. <br>  <strong>3.</strong> <em>Junrong Liu.</em>  Kleine √Ñnderungen helfen nicht: Differential Power Analysis von MILENAGE-Implementierungen in 3G / 4G USIM-Karten.  BlackHat 2015. <br>  <strong>4.</strong> <em>Herbert Bos, Ben Gras.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reverse Engineering Hardware-Seitentabellen-Caches mit Seitenkanalangriffen auf die MMU</a> .  2017. <br>  <strong>5.</strong> <em>Yu Cai, Saugata Ghose.</em>  Sicherheitsl√ºcken in der MLC-NAND-Flash-Speicherprogrammierung: Experimentelle Analyse, Exploits und Schadensbegrenzungstechniken // 23. IEEE-Symposium f√ºr Hochleistungscomputerarchitektur, Industriesitzung, Februar 2017. <br>  <strong>6.</strong> <em>Falkner Katrina.</em>  Flush + Reload: Ein hochaufl√∂sender, rauscharmer L3-Cache-Seitenkanalangriff // Ablauf des 23. USENIX-Sicherheitssymposiums.  2014. pp.  719-732. <br>  <strong>7.</strong> <em>Gruss Daniel, Maurice Clementine M angard, Stefan.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rowhammer.js: Ein durch Remote-Software induzierter Fehlerangriff in JavaScript</a> .  2016. <br>  <strong>8.</strong> <em>Gruss Daniel, Wagner Klaus.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flush + Flush: Ein verstohlener Cache-Angriff der letzten Stufe</a> .  2015. <br>  <strong>9.</strong> <em>Kim Yoongu, Daly Ross.</em>  Umbl√§ttern von Bits im Speicher, ohne auf sie zuzugreifen: Eine experimentelle Studie zu DRAM-St√∂rungsfehlern // Fortsetzung des 41. j√§hrlichen internationalen Symposiums f√ºr Computerarchitektur.  Piscataway, NJ, USA: IEEE Press, 2012 (ISCA '14). <br>  <strong>10.</strong> <em>Eck Wim.</em>  Elektromagnetische Strahlung von Videoanzeigeger√§ten: Abh√∂rgefahr?  // Computer und Sicherheit.  Nein, nein.  4, 1985. pp.  269-286. <br>  <strong>11.</strong> <em>Biham Eli, Shamir Adi.</em>  Differenzielle Fehleranalyse des Kryptosystems mit geheimen Schl√ºsseln // Fortschritte in der Kryptologie - CRYPTO '97 Bd.  1294. <br>  <strong>12.</strong> <em>Callan Robert, Zajic Alenka.</em>  Eine praktische Methode zur Messung des Seitenkanalsignals, das dem Angreifer f√ºr Ereignisse auf Befehlsebene zur Verf√ºgung steht // Verfahren des 47. j√§hrlichen IEEE / ACM International Symposium on Microarchitecture.  2014. pp.  242‚Äì254. <br>  <strong>13.</strong> <em>Genkin Daniel.</em>  ECDH-Schl√ºsselextraktion √ºber elektromagnetische Angriffe mit geringer Bandbreite auf PCs // Cryptology ePrint Archive, Report 2016/129. <br>  <strong>14.</strong> <em>Gruss Daniel.</em>  Angriffe auf Cache-Vorlagen: Automatisieren von Angriffen auf inklusive Caches der letzten Ebene // Ablauf des 24. USENIX-Sicherheitssymposiums.  2015. pp.  897‚Äì912. <br>  <strong>15.</strong> <em>Seaborn Mark.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausnutzen des DRAM-Rowhammer-Fehlers, um Kernel-Berechtigungen zu erhalten</a> .  2015. <br>  <strong>16.</strong> <em>Gruss Daniel.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rowhammer Bitflips auf Skylake mit DDR4</a> .  2016. <br>  <strong>17.</strong> <em>Lanteigne Mark.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie Rowhammer verwendet werden kann, um Schwachstellen in Computerhardware auszunutzen</a> .  2016. <br>  <strong>18.</strong> <em>Osvik Dag, Shamir Adi.</em>  Cache-Angriffe und Gegenma√ünahmen: der Fall von AES // Topics in Cryptology.  2005. pp.  1-20. <br>  <strong>19.</strong> <em>Tromer Eran, Osvik Dag.</em>  Effiziente Cache-Angriffe auf AES und Gegenma√ünahmen // Journal of Cryptology.  23 (1), 2010. pp.  37-71. <br>  <strong>20.</strong> <em>Liu Fangfei, Yarom, Yuval.</em>  Cache-Seitenkanalangriffe der letzten Ebene sind praktisch // Verfahren des IEEE-Symposiums f√ºr Sicherheit und Datenschutz Bd.  2015. pp.  605-622. <br>  <strong>21.</strong> <em>Eisenbarth Thomas.</em>  Ein gemeinsamer Cache-Angriff, der kern√ºbergreifend funktioniert und VM-Sandboxing trotzt - und seine Anwendung auf das AES // IEEE-Symposium f√ºr Sicherheit und Datenschutz.  2015. <br>  <strong>22.</strong> <em>Gullasch David, Bangerter Endre.</em>  Cache-Spiele - Bringen Sie zugriffsbasierte Cache-Angriffe auf AES zum √úben // Verfahren des IEEE-Symposiums f√ºr Sicherheit und Datenschutz.  2011. pp.  490-505. <br>  <strong>23.</strong> <em>Irazoqui Gorka, Inci Mehmet.</em>  Warte eine Minute!  Ein schneller, VM -√ºbergreifender Angriff auf AES // Lecture Notes in Computer Science Bd.  2014. pp.  299-319. <br>  <strong>24.</strong> <em>Yarom Yuval, Benger Naomi.</em>  Wiederherstellen von OpenSSL ECDSA-Nonces mithilfe des Flush + Reload-Cache Seitenkanalangriff // Cryptology ePrint Archive, Report 2014/140 (2014). <br>  <strong>25.</strong> <em>Gulmezoglu Berk, Inci Mehmet.</em>  Ein schnellerer und realistischerer Flush + Reload-Angriff auf AES // Vortr√§ge des 6. internationalen Workshops zu konstruktiver Seitenkanalanalyse und sicherem Design.  2015. pp.  111-126. <br>  <strong>26.</strong> <em>Irazoqui Gorka, Inc. Mehmet.</em>  Kennen Sie Ihren Nachbarn: Erkennung von Kryptobibliotheken in der Cloud // Verfahren der Technologien zur Verbesserung der Privatsph√§re.  2015. pp.  25-40. <br>  <strong>27.</strong> <em>Pessl Peter, Gruss Daniel.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reverse Engineering Intel DRAM-Adressierung und -Nutzung</a> .  2015. <br>  <strong>28.</strong> <em>Marforio Claudio, Ritzdorf Hubert.</em>  Analyse der Kommunikation zwischen kolludierenden Anwendungen auf modernen Smartphones // Proceedings of the 28. Annual Computer Security Applications Conference.  2012. pp.  51-60. <br>  <strong>29.</strong> <em>Clementine Maurice, Manuel Webe.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo von der anderen Seite: SSH √ºber robuste Cache-verdeckte Kan√§le in der Cloud</a> .  2017. <br>  <strong>30.</strong> <em>Victor van der Veen, Lindorfer.</em>  Drammer: Deterministische Rowhammer-Angriffe auf mobile Plattformen // Bericht der ACM SIGSAC-Konferenz 2016 √ºber Computer- und Kommunikationssicherheit.  2016. pp.  1675-1689. <br>  <strong>31.</strong> <em>Kaveh Razavi, Ben Gras.</em>  Flip Feng Shui: Eine Nadel in den Software-Stack h√§mmern // Ablauf des 25. USENIX-Sicherheitssymposiums.  2016. pp.  1-18. <br>  <strong>32.</strong> <em>Ramya Jayaram Masti, Devendra Rai.</em>  Thermal Covert Channels auf Multi-Core-Plattformen // Vortr√§ge des 24. USENIX Security Symposium.  2015. pp.  865-880. <br>  <strong>33.</strong> <em>Angelos Oikonomopoulos.</em>  L√∂cher in das Verstecken von Informationen stecken // Proceedings des 25. USENIX Security Symposium.  2016. pp.  121-138. <br>  <strong>34.</strong> <em>Koen Koning.</em>  Keine Notwendigkeit zu verstecken: Schutz sicherer Regionen auf Rohstoffhardware // Tagungsband der Zw√∂lften Europ√§ischen Konferenz √ºber Computersysteme.  2017. pp.  437-452. <br>  <strong>35.</strong> <em>Erik Bosman.</em>  Dedup Est Machina: Speicher-Deduplizierung als Advanced Exploitation Vector // Proceedings des IEEE-Symposiums f√ºr Sicherheit und Datenschutz.  2016. pp.  987-1004. <br>  <strong>36.</strong> <em>Evtyushkin, D., Ponomarev, D.</em> √úber ASLR springen: <em>Zweigpr√§diktoren</em> angreifen, um ASLR zu umgehen // Proceedings of the 49. International Symposium on Microarchitecture.  2016. pp.  1-13. <br>  <strong>37.</strong> <em>Daniel Gruss, Moritz Lipp.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KASLR ist tot: Es lebe KASLR</a> .  2017. </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455310/">https://habr.com/ru/post/de455310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455290/index.html">Der vollst√§ndige Leitfaden zu Prometheus im Jahr 2019</a></li>
<li><a href="../de455292/index.html">So erh√∂hen Sie die Laufzeit von Ger√§ten mit eigener Stromversorgung um das Vierfache</a></li>
<li><a href="../de455302/index.html">Golang API Framework</a></li>
<li><a href="../de455306/index.html">Antworten auf Ihre Fragen, warum Sie einen Verlag ben√∂tigen, um ein Buch zu ver√∂ffentlichen</a></li>
<li><a href="../de455308/index.html">Vielversprechender Ort</a></li>
<li><a href="../de455312/index.html">Ein-Bit-Volladdierer auf ungew√∂hnlichen Chips</a></li>
<li><a href="../de455316/index.html">Wir modifizieren den Bluetooth-Stack, um den Klang von Kopfh√∂rern ohne Codecs AAC, aptX und LDAC zu verbessern</a></li>
<li><a href="../de455319/index.html">Workflow 3D-K√ºnstler. Wie man nicht in einer Menge Informationen ertrinkt. Teil 1</a></li>
<li><a href="../de455325/index.html">Portieren von Desktop-Apps nach .NET Core</a></li>
<li><a href="../de455329/index.html">Ank√ºndigung der Azure IoT Edge Tools-Erweiterung (Vorschau)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>