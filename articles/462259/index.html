<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíï üë®üèº‚Äçüé§ ‚òÇÔ∏è Hacer un controlador para una casa inteligente üïäÔ∏è üë≤üèø üïµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hacemos un controlador para un hogar inteligente y no solo. 

 En un art√≠culo anterior, describ√≠ el desarrollo del sistema como un todo. En esto, desc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hacer un controlador para una casa inteligente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462259/">  Hacemos un controlador para un hogar inteligente y no solo. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">En un art√≠culo anterior,</a> describ√≠ el desarrollo del sistema como un todo.  En esto, describir√© el desarrollo de un controlador que es responsable de sondear sensores y m√≥dulos de E / S.  "¬øPor qu√© reinventar la rueda?"  - usted pregunta  En primer lugar, es interesante, y en segundo lugar, curiosamente, no existe una soluci√≥n OpenSource para dicho controlador que cubra tanto el software como el hardware.  El art√≠culo est√° dirigido a personas que est√°n un poco familiarizadas con la electr√≥nica y el desarrollo integrado de Linux. <br><br>  Hacer un controlador, dices, es muy complicado: necesitas hacer una pizarra, escribir software, imprimir el estuche.  Pero en realidad, todo es un poco m√°s complicado, eso es lo que me ha servido, pero en principio tienes raz√≥n: <br><a name="habracut"></a><br>  1. hardware del controlador <br><br>  - elecci√≥n de la placa de la CPU para el controlador <br>  - elecci√≥n del controlador IO <br>  - elecci√≥n de la fuente de alimentaci√≥n <br>  - diagrama de bloques del controlador <br>  - desarrollo de una tabla cruzada para el controlador <br>  - desarrollo de placas para m√≥dulos RS-485 <br>  - producci√≥n de tableros <br><br>  2. software para el controlador <br><br>  - elecci√≥n del sistema de compilaci√≥n para Linux kernel y rootfs <br>  - estructura de partici√≥n de la tarjeta SD <br>  - elecci√≥n del gestor de arranque y carga de los rootfs necesarios <br>  - cambios en el √°rbol de dispositivos <br>  - la elecci√≥n de un sistema para cobrar d√©bitos negociados <br>  - escribir un sistema de construcci√≥n <br>  - escribir un n√∫cleo de comunicaci√≥n <br>  - escritura de puerta de enlace mqtt (puntos de controlador discreto / anal√≥gico -&gt; temas mqtt) <br>  - escribir un analizador de Google y construir un archivo de configuraci√≥n json para la puerta de enlace <br>  - escribir un monitor de puntos para acceder a los puntos del controlador <br>  - montar el sistema de archivos de solo lectura <br><br>  3. caja del controlador <br><br>  - lo que deber√≠a ser, conectores, refrigeraci√≥n, asientos para una tabla, hipotecas para clips para soportes en un dinrake. <br>  - dise√±o e impresi√≥n <br><br>  Algunas palabras sobre el hardware. <br><br>  Probablemente solo los m√°s desesperados ahora tomen un procesador, memoria, flash, controlador de energ√≠a, un par de cientos de componentes y comiencen a esculpirlo todo junto.  El resto usa los frutos del trabajo de otras personas, es m√°s r√°pido y m√°s f√°cil.  Solo necesita abrir un navegador y escribir "computadora de placa √∫nica" y pasar el resto del d√≠a eligiendo la correcta.  Necesitaba muchos puertos serie y es deseable que la placa soporte de -40 ¬∞ C a + 85 ¬∞ C, por lo que la elecci√≥n recay√≥ en BeagleBone Black (BBB).  Tambi√©n en BBB, todos los perif√©ricos est√°n conectados a dos conectores PBD de 46 pines en incrementos de 2.54, lo cual es conveniente para la creaci√≥n de prototipos y el desarrollo de una placa cruzada.  Se necesita una placa cruzada para combinar todos los componentes en una placa, para m√≠ es una placa de CPU, fuente de alimentaci√≥n, controlador IO y placas de canal RS485.  Adem√°s, es la tabla cruzada la que debe fijarse a la carcasa y tiene conectores para alimentaci√≥n y cable RS485. <br><br><img src="https://habrastorage.org/webt/oy/jo/6j/oyjo6jzy2qtidg-9ehm5zmtnqtg.jpeg"><br><br>  Entonces, descubrimos la placa de la CPU, lo siguiente que debemos decidir es si es necesario colocar un controlador de Entrada / Salida (IO) en la placa cruzada o no.  Lo puse en el tablero y todav√≠a no lo he usado con √©xito.  Lo √∫nico que hace es posponer el inicio del BBB por 1s despu√©s de aplicar la energ√≠a y sirve el bot√≥n de reinicio. <br><br>  La fuente de alimentaci√≥n para el controlador, tom√© el MeanWell NSD10-12S5 ya hecho, desarrollarlo para un solo dispositivo es una tarea sin sentido, simplemente lo recog√≠ para el consumo y eso es todo.  No preste atenci√≥n a la pantalla LCD, est√° en el tablero, pero no implement√© el soporte. <br><br><img src="https://habrastorage.org/webt/uu/ub/hx/uuubhxrvgg7imxkdmtk6rjsojtu.jpeg"><br><br><img src="https://habrastorage.org/webt/hd/wn/l2/hdwnl2uo05wm6isu1pudumcx8zk.jpeg"><br><br>  Algunas palabras sobre las tarjetas de canal RS485. <br><br>  Hay 4 interfaces serie BBB en la placa cruzada.  As√≠ que all√≠ puedes poner cualquier tipo de canal que necesites, RS485, CAN, m√≥dulo Zigbee ... <br><br>  Necesitaba canales RS485, as√≠ que solo los hice, son con control autom√°tico de transmisi√≥n / recepci√≥n y con aislamiento galv√°nico.  ¬øPor qu√© no utilizar el control del transceptor con BBB, porque TI dej√≥ de admitir oficialmente la luz estrobosc√≥pica para RS485 en el controlador del dispositivo en serie?  Puede encontrar un parche para el controlador, puede agregarlo usted mismo, pero ¬øpor qu√©?  Una vez que el canal se ha autobloqueado, puede colocarlo en cualquier placa, por ejemplo, en RaspberyPi, donde nunca ha habido tal soporte, si lo hubo, entonces corr√≠jame.  La luz estrobosc√≥pica para el controlador rs485 est√° configurada en attiny10, barata y alegre. <br><br>  Regresamos al software. <br><br>  Elegir un sistema de compilaci√≥n para el kernel de Linux y rootfs. <br><br>  Existen varios sistemas de este tipo, los m√°s populares son Yocto y BuildRoot.  Si necesita desarrollar un proyecto grande, si tiene mucho tiempo y desea escribir recetas, entonces Yocto es su elecci√≥n.  Con la ayuda de BuildRoot, puede recopilar todo lo que necesita para iniciar f√°cilmente el tablero es muy, muy simple, porque  Estoy haciendo un sistema en Beaglebone Black (en adelante BBB) entonces: <br><br><ol><li>  lea lo que est√° escrito aqu√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/en/post/448638</a> </li><li>  hacer limpio </li><li>  hacer beaglebone_defconfig </li><li>  hacer </li></ol><br>  Eso es todo  Ahora todo lo que necesita para ejecutar el tablero se encuentra en la carpeta / buildroot / output / images. <br><br>  Todo parece muy simple y no interesante, por lo que puedes hacer un poco m√°s complicado: <br><br><ol><li>  integre buildroot en su sistema de compilaci√≥n, desc√°rguelo con un script, recuerde usar una etiqueta estable y no tome el √∫ltimo desarrollo </li><li>  escriba su defconfig y arroje el script en la carpeta / buildroot / configs antes de ensamblar buildroot, no olvide que todos los defconfigs deben terminar con * _defconfig, de lo contrario buildroot no lo ver√° </li><li>  copie su post-build.sh a bordo / beaglebone / post-build.sh </li><li>  prepara un script que haga n1, n2 y n3 por ti </li></ol><br>  Como resultado, buildroot generar√° zImage y rootfs.tar <br><br>  Selecci√≥n de la estructura de partici√≥n de la tarjeta SD: <br><br>  En esto, creo, no es necesario centrar mucha atenci√≥n. <br>  Hice 4 secciones BOOT / ROOT_1 / ROOT_2 / DATA. <br>  La secci√≥n BOOT contiene todo lo que necesita para el arranque: MLO, barebox.bin, barebox.env, am335x-boneblack.dtb, zImage, boot.txt. <br><br>  ROOT_1 y ROOT_2 contienen rootfs, cuya selecci√≥n se escribe en el archivo boot.txt (ver m√°s abajo).  Todas estas particiones se montan como de solo lectura para evitar bloqueos del sistema de archivos cuando se apaga.  DATA contiene configuraciones de dise√±o, al cambiar las cuales no hay necesidad de reconstruir el c√≥digo. <br><br>  Tal estructura de particiones en el futuro facilitar√° la escritura de un componente de actualizaci√≥n de software.  Este componente sobrescribir√° una de las secciones ROOT_1 / ROOT_2, que no se usa ahora, y luego simplemente cambie el archivo boot.txt si no necesita cambiar el kernel. <br><br>  Elegir un gestor de arranque. <br><br>  Tuve muchos experimentos con cargadores de arranque para BBB.  Al principio us√©, como todos los dem√°s, el U-Boot que BuildRoot genera.  Pero no me gust√≥, tal vez, por supuesto, esto es una cuesti√≥n de costumbre, pero me pareci√≥ que era demasiado, es muy pesado y dif√≠cil de configurar.  Entonces, pens√© que no ser√≠a una mala idea iniciar el sistema r√°pidamente, en 2-3 segundos, y archivar el X-Loader para que cargara el kernel, lo logr√©, pero nuevamente hubo un problema de configuraci√≥n y el tiempo de inicio para m√≠ no es cr√≠tico (el sistema en systemd arranca lentamente por s√≠ mismo, incluso si elimina todo lo que no es necesario). <br><br>  Al final, me decid√≠ por barebox, realmente me gust√≥ su simplicidad, adem√°s el sitio tiene toda la documentaci√≥n (www.barebox.org). <br><br>  Por ejemplo, para cargar rootfs desde la primera o segunda partici√≥n, solo necesita: <br><br>  1. en la secci√≥n de arranque, cree el archivo boot.txt que exportar√° una variable del tipo "export BOOT_NUM = X" <br><br>  2. cree dos scripts / env / boot / sdb1 / env / boot / sdb2 en los que describa las opciones de arranque, por ejemplo: <br><br><pre><code class="plaintext hljs">echo "botting with mmcblk0p2 as rootfs..." global.bootm.image=/boot/zImage global.bootm.oftree=/boot/am335x-boneblack.dtb global.linux.bootargs.console="console=ttyO0,115200" global.linux.bootargs.debug="earlyprintk ignore_loglevel" global.linux.bootargs.base="root=/dev/mmcblk0p2 ro rootfstype=ext4 rootwait"</code> </pre> <br>  3. Cree un script / env / boot / sd en el que, dependiendo de BOOT_NUM, inicie el script sdb1 o sdb2 <br><br>  4. establecer la variable boot.default <br><br><pre> <code class="plaintext hljs">nv boot.default=sd saveenv</code> </pre> <br>  5. Cambiando a√∫n m√°s BOOT_NUM en boot.txt cargaremos rootfs desde la primera o segunda partici√≥n, que en el futuro se puede usar para actualizar el software. <br><br>  Cambios en el √°rbol de dispositivos. <br><br>  Como uso MODBUS RTU a trav√©s de RS485 para comunicarme con los m√≥dulos, necesitaba habilitar casi todos los puertos seriales que existen en el BBB.  Para hacer esto, debe volver a habilitarlos en el √°rbol de dispositivos, porque  Por defecto, la mayor√≠a de ellos est√°n desactivados. <br><br>  Ser√≠a correcto hacer su parche para el archivo am335x-bone-common.dtsi del paquete buildrut y aplicarlo cada vez antes de ensamblarlo, pero la pereza gan√≥, y simplemente saqu√© todos los archivos que necesitaba, cambi√© todo lo que necesitaba y lo constru√≠ con mis manos. <br><br>  Porque  Esto se hace una vez, es posible y as√≠: <br><br>  1. Cree una carpeta con los archivos necesarios para el ensamblaje: <br><br><pre> <code class="plaintext hljs">am335x-bone-common.dtsi am335x-boneblack-common.dtsi am335x-boneblack.dts am33xx-clocks.dtsi am33xx.dtsi am33xx.h gpio.h omap.h tps65217.dtsi</code> </pre> <br>  2. En el archivo am335x-bone-common.dtsi, debe configurar correctamente los pines y deshabilitar los controladores de puerto: <br><br><pre> <code class="plaintext hljs">uart1_pins: pinmux_uart1_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x980, PIN_INPUT_PULLUP | MUX_MODE0) AM33XX_IOPAD(0x984, PIN_OUTPUT_PULLDOWN | MUX_MODE0) &gt;; }; uart2_pins: pinmux_uart2_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x950, PIN_INPUT_PULLUP | MUX_MODE1) AM33XX_IOPAD(0x954, PIN_OUTPUT_PULLDOWN | MUX_MODE1) &gt;; }; uart4_pins: pinmux_uart4_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x870, PIN_INPUT_PULLUP | MUX_MODE6) AM33XX_IOPAD(0x874, PIN_OUTPUT_PULLDOWN | MUX_MODE6) &gt;; }; uart5_pins: pinmux_uart5_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x8C4, PIN_INPUT_PULLUP | MUX_MODE4) AM33XX_IOPAD(0x8C0, PIN_OUTPUT_PULLDOWN | MUX_MODE4) &gt;; }; &amp;uart1 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart1_pins&gt;; status = "okay"; }; &amp;uart2 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart2_pins&gt;; status = "okay"; }; &amp;uart4 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart4_pins&gt;; status = "okay"; }; &amp;uart5 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart5_pins&gt;; status = "okay"; };</code> </pre><br>  3. Luego, un poco de magia, y el archivo terminado am335x-boneblack.dtb se encuentra en el mismo directorio: <br><br><pre> <code class="plaintext hljs">a. sudo apt-get install device-tree-compiler</code> </pre> <br>  b.  ejecuta el preprocesador: <br><br><pre> <code class="plaintext hljs">cpp -Wp,-MD,am335x-boneblack.dtb.d.pre.tmp -nostdinc -Iinclude -Isrc -Itestcase-data -undef -D__DTS__ -x assembler-with-cpp -o am335x-boneblack.dtb.dts.tmp am335x-boneblack.dts</code> </pre> <br>  c.  ejecuta el compilador en s√≠: <br><br><pre> <code class="plaintext hljs">dtc -O dtb -o am335x-boneblack.dtb -b 0 -i src -d am335x-boneblack.dtb.d.dtc.tmp am335x-boneblack.dtb.dts.tmp</code> </pre> <br>  4. am335x-boneblack.dtb debe colocarse en la partici√≥n de arranque junto al kernel y en el script de inicio de barebox agregue la siguiente l√≠nea: " <code>global.bootm.oftree=/boot/am335x-boneblack.dtb</code> " <br><br>  Elegir un sistema para cobrar d√©bitos negociados. <br><br>  Como saben, los sistemas sin errores no existen, as√≠ como el an√°lisis de un sistema multiproceso sin rastros.  Es muy conveniente si estos rastros no se muestran simplemente en la consola, sino que se recopilan utilizando algo especialmente creado para esto, de modo que sea posible ordenarlos por procesos, aplicar filtros, etc.  Y solo conozco un buen sistema que es f√°cil de construir tanto en host como en destino.  Esto es DLT, si nunca ha o√≠do hablar de esto, entonces no importa, todas las brechas de conocimiento se pueden cubrir f√°cilmente al leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">at.projects.genivi.org/wiki/display/PROJ/Diagnostic+Log+and+Trace</a> . <br>  Este sistema consta de dlt-daemon y dlt-viewer.  Como su nombre lo indica, dlt-daemon se ejecuta en el destino y dlt-viewer en el host.  Adem√°s de todo esto, a su binario, desde el que queremos recopilar rastros, debe vincular el dlt lib. <br><br><img src="https://habrastorage.org/webt/oi/go/b-/oigob-peuxj5pdvmkdr0vzu5wkc.png"><br><br>  En general, todo es conveniente, c√≥mo recolectar rastros y analizarlos, lo recomiendo. <br><br>  Escribir un sistema de construcci√≥n. <br><br>  ¬øPor qu√© escribir un sistema de compilaci√≥n? Porque puedes descargar todo de los repositorios, compilarlo con tus manos, construir sobre la base de este rootfs y velo, el controlador funciona.  Pero repetir ese truco en un mes ser√° m√°s dif√≠cil, y en dos, esto generalmente es imposible.  Nuevamente, debe recordar qu√©, d√≥nde colocar, qu√© construir y c√≥mo comenzar.  Por lo tanto, despu√©s de pasar mucho tiempo al principio, lo guarda m√°s tarde, adem√°s tiene la oportunidad de construir convenientemente en host y target.  El sistema de compilaci√≥n consiste en un conjunto de scripts que primero preparan al host para la compilaci√≥n, descargan componentes de terceros, como buildroot, mosquitto, DLT daemon, desde sus repositorios, los compilan y los colocan en sus lugares.  Y luego puede iniciar la compilaci√≥n de su proyecto.  Si la compilaci√≥n bajo el host no es dif√≠cil de hacer, entonces siempre debe jugar con la compilaci√≥n bajo el objetivo, y ser√≠a mejor si el script lo hace. <br><br>  Buildroot se puede configurar de modo que invoque un script posterior a la compilaci√≥n despu√©s de formar rootfs, que se ubicar√° en buildroot / output / target.  Esto le brinda una gran oportunidad para poner todo lo que necesita all√≠.  Y luego, la imagen del sistema de archivos ya contendr√° todo lo que necesita para iniciar su sistema. <br><br>  La receta es algo como esto: <br><br><ol><li>  necesita copiar sus archivos binarios en alg√∫n lugar de buildroot / output / target, por ejemplo en / opt / bin </li><li>  si hay configuraciones, haga lo mismo con ellas, solo en / opt / etc. </li><li>  copiar binarios de terceros, para m√≠ es mosquitto, DLT daemon, sus bibliotecas y configuraciones </li><li>  Para iniciar el sistema en s√≠ mismo al cargar el controlador, debe copiar los servicios de systemd, es mejor combinarlos en su destino y volver a habilitarlo haciendo un enlace simb√≥lico en multiusuario. </li><li>  copia el fstab modificado (porque, te lo dir√© m√°s tarde) </li></ol><br>  Despu√©s de eso, solo necesita descomprimir buildroot / output / images / rootfs.tar en la secci√≥n deseada de la tarjeta SD y encender la alimentaci√≥n. <br><br><pre> <code class="plaintext hljs">build git repo: https://github.com/azhigaylo/build</code> </pre> <br>  Escribir un n√∫cleo de comunicaci√≥n. <br><br>  El concepto de esto es tan antiguo como el propio Modbus. <br><br>  Cada dispositivo de E / S en una red Modbus tiene registros (16 bits) disponibles para lectura, lectura / escritura, en los que se almacenan los datos y a trav√©s de los cuales se controlan estos dispositivos.  El controlador, a su vez, tiene conjuntos de puntos discretos (estado y valor de byte) y anal√≥gicos (estado y valor flotante), en los que almacena el estado de todos los par√°metros. <br><br>  Por lo tanto, la tarea del n√∫cleo de comunicaci√≥n es simple: recopilar datos de dispositivos de E / S utilizando el protocolo Modbus, asignarlos a puntos de controlador y proporcionar acceso a estos puntos para el nivel superior.  Y si necesita administrar algo, entonces todo est√° en la otra direcci√≥n: el dispositivo l√≥gico (m√°s sobre eso m√°s adelante) debe suscribirse al punto del controlador y escribir en este punto inicia la traducci√≥n de este par√°metro al dispositivo f√≠sico de salida de agua. <br><br><img src="https://habrastorage.org/webt/1v/zb/x4/1vzbx4smmroaleak2dy4jol9gno.jpeg"><br><br>  Para estructurar de alguna manera los datos y trabajar con dispositivos, puede introducir el concepto de un dispositivo l√≥gico que mostrar√° el estado de un dispositivo f√≠sico en su software. <br><br>  Tambi√©n decid√≠ dividir los dispositivos l√≥gicos en dos grupos: <br><br><ol><li>  Est√°ndar (m√≥dulos Aries de entrada / salida discreta), para los cuales se conocen de antemano los n√∫meros de registros modbus con datos, y es suficiente solo para determinar los puntos del controlador donde guardar estos datos. </li><li>  Dispositivos de usuario, para ellos es necesario describir independientemente el mapeo de los registros modbus a los puntos del controlador. </li></ol><br>  De todo lo anterior, es l√≥gico tener alg√∫n tipo de configurador para el controlador, ya sea solo una configuraci√≥n json o una herramienta autoescrita que genere una configuraci√≥n binaria, todo vale.  Tengo la segunda opci√≥n, porque hab√≠a ideas para escribir un n√∫cleo de comunicaci√≥n para que pudiera ejecutarse f√°cilmente no solo en la placa de Linux sino tambi√©n en Arduin con FreeRtos, cambiando el nivel de PAL en el software. <br><br>  En el configurador para cada dispositivo, debe configurar el n√∫mero de puerto del controlador rs485, la direcci√≥n del dispositivo y el punto del controlador en el que se muestra el estado de comunicaci√≥n con el dispositivo, adem√°s de para cada dispositivo est√°ndar se describen sus canales, y para un dispositivo de usuario, sus registros se asignan a puntos. <br><br><img src="https://habrastorage.org/webt/p7/gh/cu/p7ghcubristizrus5hzq_zlfo5i.jpeg"><br><br><img src="https://habrastorage.org/webt/xr/go/nk/xrgonkcogvsn-6j2vjktiiryrlw.jpeg"><br><br>  Dicho archivo de configuraci√≥n, que contiene todos los datos necesarios sobre la construcci√≥n de la red Modbus, le permite no modificar el c√≥digo fuente del proyecto si necesita agregar / eliminar / cambiar dispositivos de entrada / salida, es suficiente cambiar los par√°metros en el configurador y guardarlos en el archivo de configuraci√≥n. <br><br>  Al inicio, el n√∫cleo de comunicaci√≥n analiza la configuraci√≥n y crea en base a listas de dispositivos l√≥gicos para cada puerto rs485 del controlador, luego se crean subprocesos en cada puerto y comienza un sondeo c√≠clico de dispositivos f√≠sicos. <br><br><pre> <code class="plaintext hljs">core git repo: https://github.com/azhigaylo/homebrain_core</code> </pre> <br>  Escribir mqtt gateway. <br><br>  En realidad, sus puntos de controlador, tanto discretos como anal√≥gicos, con una interfaz patentada para acceder a ellos, son de poco inter√©s para cualquiera.  Entonces, solo hay una salida: mqtt.  Creo que no exagerar√© si digo que este es actualmente el protocolo m√°s com√∫n para intercambiar mensajes peque√±os, adem√°s es muy simple y comprensible de usar.  Entonces, cuando necesitaba transmitir datos desde el controlador, no pens√© mucho en qu√© usar. <br><br><img src="https://habrastorage.org/webt/o_/sf/w0/o_sfw0yj5i-ptu7ohxdqdvnmw68.jpeg"><br><br>  Porque  Tengo muchos par√°metros, siempre hubo confusiones en el archivo de configuraci√≥n de la puerta de enlace, donde se registr√≥ la asignaci√≥n de los puntos del controlador a los temas de la puerta de enlace mqtt.  Google ayud√≥ a la tabla y escribi√≥ un analizador csv de esta tabla en el archivo de configuraci√≥n json para la puerta de enlace. <br><br><img src="https://habrastorage.org/webt/b-/wt/zm/b-wtzmutugygf-_8mj5odnnrguw.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gateway git repo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">analizador git repo</a> <br><br>  Punto de escritura monitor. <br><br>  A veces es muy √∫til ver qu√© sucede con los puntos del controlador, para esto escrib√≠ una peque√±a aplicaci√≥n que se conecta directamente al n√∫cleo de comunicaci√≥n y lee el estado de los puntos discretos y anal√≥gicos.  Soy bastante estricto con la interfaz de usuario, as√≠ que pude de alguna manera lanzar la aplicaci√≥n a QML, funcion√≥ con un chirrido, puedes contar el punto, puedes grabarlo, pero no necesito m√°s. <br><br><pre> <code class="plaintext hljs">pointmonitor git repo: https://github.com/azhigaylo/pointmonitor</code> </pre> <br>  Montar el sistema de archivos de solo lectura. <br><br>  Por lo general, pocas personas prestan atenci√≥n a esto, e incluso en proyectos de producci√≥n, puede encontrar dispositivos en los que se puede escribir la partici√≥n con rootfs.  Esto tarde o temprano conduce a la ca√≠da de cualquiera, incluso el sistema de archivos m√°s estable.  Porque  Dado que el controlador se puede apagar en cualquier momento, solo es cuesti√≥n de tiempo / caso cuando esto sucede.  Para minimizar esta probabilidad, debe jugar un poco con fstab, y antes de construir la imagen rootfs, col√≥quela all√≠, como se describi√≥ anteriormente.  En fstab, en primer lugar, debe montar el sistema de archivos como de solo lectura y, en segundo lugar, todo lo que puede cambiar puede asignarse a tmpfs. <br><br>  Mi fstab es esto, puede ser diferente para ti: <br><br><pre> <code class="plaintext hljs">/dev/root / auto ro 0 1 tmpfs /tmp tmpfs nodev,nosuid,size=50M 0 0 tmpfs /srv tmpfs nodev,size=50M 0 0 tmpfs /var/log tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/tmp tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/run tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/lib tmpfs defaults,noatime,size=10M 0 0</code> </pre> <br>  Cuerpo del controlador <br><br>  Durante mucho tiempo se ha incluido una impresora 3D en las secciones de masthead para cada ingeniero agricultor colectivo, desafortunadamente no la tengo, pero est√° funcionando.  Recientemente, la emoci√≥n de otros empleados por √©l ha desaparecido, lo uso cuando imprimo todo lo que necesito y no necesito, podr√≠a estar convencido de esto al leer mi publicaci√≥n anterior. <br><br>  Dibujamos en FreeCAD, generamos el gcode en Cura y obtenemos un estuche, sin olvidar hacer asientos para el tablero, recortes para conectores y refrigeraci√≥n e hipotecas para clips en un riel DIN. <br><br><img src="https://habrastorage.org/webt/7m/yc/y6/7mycy6gz9axqfvspdk_cmyz5oc8.jpeg"><br><br><img src="https://habrastorage.org/webt/j5/i3/dv/j5i3dvtfcb8wkpn1t0uphq7d9lg.jpeg"><br><br>  Bueno, eso es todo, ahora tenemos una placa, software en una tarjeta SD y un estuche.  Tomamos un archivo (no estoy bromeando) y conectamos todo, conectamos la alimentaci√≥n, los cables RS485 y todo comienza a funcionar.  Y dijiste dif√≠cil, dif√≠cil ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/462259/">https://habr.com/ru/post/462259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../462243/index.html">Mejora del rendimiento front-end de Magento con ReactJS</a></li>
<li><a href="../462245/index.html">auto git bisect como un ejemplo del kernel de Linux</a></li>
<li><a href="../462251/index.html">¬øEs el modo inc√≥gnito en el navegador una ficci√≥n?</a></li>
<li><a href="../462253/index.html">Los primeros experimentos que utilizan el protocolo de transmisi√≥n en el ejemplo de comunicaci√≥n de CPU y procesador en el FPGA Redd</a></li>
<li><a href="../462257/index.html">Kafka en Kubernetes, ¬øest√° bien?</a></li>
<li><a href="../462263/index.html">Pedal to the floor: crea otro manipulador de pies para PC</a></li>
<li><a href="../462265/index.html">Python y cubos</a></li>
<li><a href="../462267/index.html">Conozca el analizador est√°tico PVS-Studio para Java</a></li>
<li><a href="../462269/index.html">John Romero to Doom: 80s Game Dev</a></li>
<li><a href="../462271/index.html">C√≥digo de bloqueo en iOS: c√≥mo Apple cambi√≥ de defensa en defensa a proteger una sola frontera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>