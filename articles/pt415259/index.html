<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öïÔ∏è üë©üèΩ‚Äçüéì ü¶ç select / poll / epoll: diferen√ßa pr√°tica üé± üôçüèæ ü¶ï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao projetar aplicativos de rede de alto desempenho com soquetes sem bloqueio, √© importante decidir qual m√©todo de monitoramento de eventos de rede usa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>select / poll / epoll: diferen√ßa pr√°tica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/415259/">  Ao projetar aplicativos de rede de alto desempenho com soquetes sem bloqueio, √© importante decidir qual m√©todo de monitoramento de eventos de rede usaremos.  Existem v√°rios deles, e cada um √© bom e ruim √† sua maneira.  A escolha do m√©todo certo pode ser fundamental para a arquitetura do seu aplicativo. <br><br>  Neste artigo, consideraremos: <br><br><ul><li>  selecione () </li><li>  sondagem () </li><li>  epoll () </li><li>  libevent </li></ul><a name="habracut"></a><br><h3>  Usando select () </h3><br>  O antigo, comprovado ao longo dos anos, o trabalhador esfor√ßado select () foi criado naqueles dias em que ‚Äúsoquetes‚Äù eram chamados ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">soquetes de Berkeley</a> ‚Äù.  Esse m√©todo n√£o foi inclu√≠do na primeira especifica√ß√£o desses soquetes de Berkeley, pois naquela √©poca ainda n√£o havia conceito de E / S sem bloqueio.  Mas em algum momento nos anos 80 ela apareceu e, com ela, selecione ().  Desde ent√£o, nada mudou significativamente em sua interface. <br><br>  Para usar select (), o desenvolvedor precisa inicializar e preencher v√°rias estruturas fd_set com descritores e eventos que precisam ser monitorados e, em seguida, chamar select ().  Um c√≥digo t√≠pico se parece com isso: <br><br><pre><code class="cpp hljs">fd_set fd_in, fd_out; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeval</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tv</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   FD_ZERO( &amp;fd_in ); FD_ZERO( &amp;fd_out ); //        sock1 FD_SET( sock1, &amp;fd_in ); //        sock2 FD_SET( sock2, &amp;fd_out ); //       (select   ) int largest_sock = sock1 &gt; sock2 ? sock1 : sock2; //    10  tv.tv_sec = 10; tv.tv_usec = 0; //  select int ret = select( largest_sock + 1, &amp;fd_in, &amp;fd_out, NULL, &amp;tv ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { if ( FD_ISSET( sock1, &amp;fd_in ) ) //    sock1 if ( FD_ISSET( sock2, &amp;fd_out ) ) //    sock2 }</span></span></code> </pre> <br>  Quando select () foi projetado, ningu√©m esperava que, no futuro, precisar√≠amos escrever aplicativos multiencadeados que atendessem a milhares de conex√µes.  O Select () possui v√°rias desvantagens significativas que o tornam pouco adequado para trabalhar em tais sistemas.  Os principais s√£o: <br><br><ul><li>  O select seleciona as estruturas fd_sets transmitidas a ele, para que nenhuma delas possa ser reutilizada.  Mesmo que voc√™ n√£o precise alterar nada (por exemplo, depois de receber um dado, voc√™ deseja obter mais), as estruturas fd_sets precisar√£o ser reinicializadas.  Bem, ou copie de um backup salvo anteriormente usando FD_COPY.  E isso ter√° que ser feito repetidamente, antes de cada chamada de sele√ß√£o. </li><li>  Para descobrir exatamente qual descritor gerou o evento, voc√™ deve pesquisar manualmente todos eles com FD_ISSET.  Quando voc√™ monitora 2000 descritores, e o evento aconteceu apenas para um deles (que, de acordo com a lei da maldade, ser√° o √∫ltimo da lista) - voc√™ desperdi√ßar√° muitos recursos do processador. </li><li>  Acabei de mencionar 2000 descritores?  Fiquei empolgado com isso.  O select n√£o suporta tanto.  Bem, pelo menos no Linux comum, com o kernel usual.  O n√∫mero m√°ximo de descritores observados simultaneamente √© limitado pela constante FD_SETSIZE, que √© rigidamente igual a 1024 no Linux. Alguns sistemas operacionais permitem implementar um hack substituindo o valor FD_SETSIZE antes de incluir o arquivo de cabe√ßalho sys / select.h, mas esse hack n√£o faz parte de algum padr√£o comum.  O mesmo Linux ir√° ignor√°-lo. </li><li>  Voc√™ n√£o pode trabalhar com descritores de um conjunto observ√°vel de outro encadeamento.  Imagine um thread executando o c√≥digo acima.  Por isso, iniciou e aguarda eventos em seu select ().  Agora imagine que voc√™ tem outro encadeamento que monitora a carga geral no sistema e agora ele decidiu que os dados do soquete sock1 n√£o chegaram por muito tempo e que estava na hora de interromper a conex√£o.  Como esse soquete pode ser reutilizado para atender novos clientes, seria bom fech√°-lo corretamente.  Mas o primeiro t√≥pico √© observar esse descritor agora.  O que acontecer√° se encerrarmos tudo da mesma maneira?  Ah, a documenta√ß√£o tem uma resposta para essa pergunta e voc√™ n√£o vai gostar: "Se o identificador observado com select () for fechado por outro thread, voc√™ ter√° um comportamento indefinido". </li><li>  O mesmo problema aparece ao tentar enviar alguns dados via sock1.  N√£o enviaremos nada at√© que o select termine seu trabalho. </li><li>  A escolha dos eventos que podemos monitorar √© bastante limitada.  Por exemplo, para determinar se o soquete remoto foi fechado, primeiro voc√™ deve monitorar os eventos de chegada de dados e, em segundo lugar, tentar ler esses dados (read retornar√° 0 para o soquete fechado).  Ainda pode ser considerado aceit√°vel ao ler dados de um soquete (leia 0 - o soquete est√° fechado), mas e se a nossa tarefa atual no momento √© enviar dados para esse soquete e n√£o precisarmos ler dados dele agora? </li><li>  select coloca um encargo desnecess√°rio para voc√™ calcular o ‚Äúmaior descritor‚Äù e pass√°-lo como um par√¢metro separado </li></ul><br>  Obviamente, todas as op√ß√µes acima n√£o s√£o novidade.  Os desenvolvedores de sistemas operacionais est√£o cientes desses problemas e muitos deles foram levados em considera√ß√£o ao projetar o m√©todo de pesquisa.  Nesse ponto, voc√™ pode perguntar: por que estamos estudando hist√≥ria antiga agora, e h√° alguma raz√£o hoje para usar o seleto antigo?  Sim, existem duas raz√µes.  N√£o √© o fato de que eles ser√£o √∫teis para voc√™ algum dia, mas por que n√£o descobrir sobre eles. <br><br>  A primeira raz√£o √© a portabilidade.  O select () est√° conosco h√° um milh√£o de anos.  N√£o importa o que a selva das plataformas de hardware e software lhe traga, se houver uma rede l√°, haver√° sele√ß√£o.  Pode n√£o haver outros m√©todos, mas o select ser√° quase garantido.  E n√£o pense que agora estou caindo em senilidade senil e lembre-se de algo como cart√µes perfurados e ENIAC, n√£o.  N√£o existe um m√©todo de pesquisa mais moderno <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, por exemplo, no Windows XP</a> .  Mas selecione √©. <br><br>  O segundo motivo √© mais ex√≥tico e est√° relacionado ao fato de que o select pode (teoricamente) funcionar com tempos limite da ordem de um nanossegundo (se o hardware permitir), enquanto a pesquisa e epoll suportam apenas a precis√£o de milissegundos.  Isso n√£o deve desempenhar um papel especial em desktops comuns (ou mesmo servidores), onde voc√™ ainda n√£o possui um cron√¥metro de precis√£o de nanossegundos de hardware.  Mas ainda no mundo existem sistemas em tempo real que possuem esses temporizadores.  Ent√£o, eu imploro, quando voc√™ escreve o firmware de um reator nuclear ou foguete - n√£o tenha pregui√ßa de medir o tempo em nanossegundos.  Voc√™ sabe, eu quero viver. <br><br>  O caso descrito acima √© provavelmente o √∫nico no qual voc√™ realmente n√£o tem escolha do que usar (somente o seleto √© adequado).  No entanto, se voc√™ estiver escrevendo um aplicativo regular para trabalhar em hardware comum e operar com um n√∫mero adequado de soquetes (dezenas, centenas - e n√£o mais), a diferen√ßa de pesquisa e desempenho selecionado n√£o ser√° percept√≠vel; portanto, a escolha ser√° baseada em outros fatores. <br><br><h3>  Polling com poll () </h3><br>  poll √© um m√©todo mais novo de soquetes de pesquisa, criado depois que as pessoas come√ßaram a tentar criar servi√ßos de rede grandes e com muita carga.  Ele foi projetado muito melhor e n√£o sofre com a maioria das desvantagens do m√©todo de sele√ß√£o.  Na maioria dos casos, ao escrever aplicativos modernos, voc√™ escolhe entre usar poll e epoll / libevent. <br><br>  Para usar a enquete, um desenvolvedor precisa inicializar membros da estrutura pollfd com descritores e eventos observ√°veis ‚Äã‚Äãe depois chamar poll (). <br>  Um c√≥digo t√≠pico se parece com isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   struct pollfd fds[2]; //  sock1      fds[0].fd = sock1; fds[0].events = POLLIN; //   sock2 -  fds[1].fd = sock2; fds[1].events = POLLOUT; //   10  int ret = poll( &amp;fds, 2, 10000 ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { //  ,  revents      if ( pfd[0].revents &amp; POLLIN ) pfd[0].revents = 0; //     sock1 if ( pfd[1].revents &amp; POLLOUT ) pfd[1].revents = 0; //     sock2 }</span></span></code> </pre> <br>  A enquete foi criada para resolver os problemas do m√©todo select, vamos ver como ficou: <br><br><ul><li>  N√£o h√° limite para o n√∫mero de descritores observados; mais de 1024 podem ser monitorados </li><li>  A estrutura pollfd n√£o √© modificada, o que torna poss√≠vel reutiliz√°-la entre as chamadas para poll () - voc√™ s√≥ precisa redefinir o campo revents. </li><li>  Eventos observados s√£o melhor estruturados.  Por exemplo, voc√™ pode determinar se um cliente remoto est√° desconectado sem precisar ler dados do soquete. </li></ul><br>  J√° falamos sobre as defici√™ncias do m√©todo de pesquisa: ele n√£o est√° dispon√≠vel em algumas plataformas, como o Windows XP.  Desde o Vista, ele existe, mas √© chamado WSAPoll.  O prot√≥tipo √© o mesmo; portanto, para c√≥digo independente de plataforma, voc√™ pode escrever uma substitui√ß√£o, como: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (WIN32) static inline int poll( struct pollfd *pfd, int nfds, int timeout) { return WSAPoll ( pfd, nfds, timeout ); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Bem, a precis√£o dos tempos limite √© de 1 ms, o que n√£o ser√° suficiente muito raramente.  No entanto, a pesquisa tem outras desvantagens: <br><br><ul><li>  Assim como no uso de select, √© imposs√≠vel determinar quais descritores geraram os eventos sem uma passagem completa por todas as estruturas observadas e verificar os campos de retorno neles.  Pior ainda, tamb√©m √© implementado no kernel do sistema operacional. </li><li>  Assim como no select, n√£o h√° como alterar dinamicamente o conjunto de eventos observado </li></ul><br>  No entanto, todos os itens acima podem ser considerados relativamente insignificantes para a maioria dos aplicativos clientes.  A exce√ß√£o √© provavelmente apenas os protocolos p2p, em que cada um dos clientes pode ser associado a milhares de outros.  Esses problemas podem ser ignorados mesmo pela maioria dos aplicativos de servidor.  Portanto, a pesquisa deve ser sua prefer√™ncia padr√£o em rela√ß√£o √† sele√ß√£o, a menos que um dos dois motivos acima o limite. <br><br>  Olhando para o futuro, direi que a pesquisa √© prefer√≠vel, mesmo em compara√ß√£o com o epoll mais moderno (discutido abaixo) nos seguintes casos: <br><br><ul><li>  Voc√™ deseja escrever c√≥digo de plataforma cruzada (epoll √© apenas no Linux) </li><li>  Voc√™ n√£o precisa monitorar mais de 1000 soquetes (o epoll n√£o fornecer√° nada de significativo neste caso) </li><li>  Voc√™ precisa monitorar mais de 1000 soquetes, mas o tempo de conex√£o com cada um deles √© muito pequeno (nesses casos, o desempenho da pesquisa e do epoll ser√° muito pr√≥ximo - o ganho da espera por menos eventos no epoll ser√° riscado pela sobrecarga de adicion√°-los / remov√™-los) </li><li>  Seu aplicativo n√£o foi projetado para alterar eventos de um segmento enquanto outro os espera (ou voc√™ n√£o precisa dele) </li></ul><br><h3>  Sondando epoll () </h3><br>  epoll √© o m√©todo mais novo e melhor de aguardar eventos no Linux (e somente no Linux).  Bem, n√£o √© que o "mais novo" seja direto - ele est√° no centro desde 2002.  Difere da pesquisa e seleciona que fornece uma API para adicionar / remover / modificar a lista de descritores e eventos observados. <br><br>  O uso do epoll requer preparativos um pouco mais detalhados.  O desenvolvedor deve: <br><br><ul><li>  Crie um descritor de epoll chamando epoll_create </li><li>  Inicialize a estrutura epoll_event com os eventos e ponteiros necess√°rios para os contextos de conex√£o.  O "contexto" aqui pode ser qualquer coisa, epoll apenas passa esse valor nos eventos retornados </li><li>  Chame epoll_ctl (... EPOLL_CTL_ADD) para adicionar um identificador √† lista de observ√°veis </li><li>  Ligue para epoll_wait () para aguardar eventos (indicamos exatamente quantos eventos queremos receber por vez, por exemplo, 20).  Diferentemente dos m√©todos anteriores, obtemos esses eventos separadamente, e n√£o nas propriedades das estruturas de entrada.  Se observarmos 200 descritores e 5 deles receberem novos dados - epoll_wait retornar√° apenas 5 eventos.  Se ocorrerem 50 eventos, os 20 primeiros ser√£o devolvidos para n√≥s e os 30 restantes aguardar√£o a pr√≥xima liga√ß√£o, eles n√£o ser√£o perdidos </li><li>  Processar eventos recebidos.  Ser√° um processamento relativamente r√°pido, porque n√£o olhamos para os descritores em que nada aconteceu </li></ul><br>  Um c√≥digo t√≠pico se parece com isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   epoll.       ,      //    (    ,   ),        int pollingfd = epoll_create( 0xCAFE ); if ( pollingfd &lt; 0 ) //  //   epoll_event struct epoll_event ev = { 0 }; //     .    ,   // epoll     . , ,       ev.data.ptr = pConnection1; //    ,     ev.events = EPOLLIN | EPOLLONESHOT; //     .        //      epoll_wait -    if ( epoll_ctl( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;getSocket(), &amp;ev ) != 0 ) // report error //       20    struct epoll_event pevents[ 20 ]; //  10  int ready = epoll_wait( pollingfd, pevents, 20, 10000 ); //    if ( ret == -1 ) //  else if ( ret == 0 ) // ,    else { //     for ( int i = 0; i &lt; ret; i++ ) { if ( pevents[i].events &amp; EPOLLIN ) { //        ,   Connection * c = (Connection*) pevents[i].data.ptr; c-&gt;handleReadEvent(); } } }</span></span></code> </pre> <br>  Vamos come√ßar com as falhas do epoll - elas s√£o √≥bvias no c√≥digo.  Este m√©todo √© mais dif√≠cil de usar, voc√™ precisa escrever mais c√≥digo, faz mais chamadas do sistema. <br><br>  As vantagens tamb√©m s√£o evidentes: <br><br><ul><li>  epoll retorna uma lista apenas dos descritores para os quais os eventos observados realmente ocorreram.  Voc√™ n√£o precisa procurar por milhares de estruturas em busca daquela, possivelmente aquela em que o evento esperado funcionou. </li><li>  Voc√™ pode associar algum contexto significativo a cada evento observado.  No exemplo acima, usamos um ponteiro para um objeto da classe de conex√£o para isso - isso nos salvou outra pesquisa em potencial por uma matriz de conex√µes. </li><li>  Voc√™ pode adicionar ou remover soquetes da lista a qualquer momento.  Voc√™ pode at√© modificar eventos observados.  Tudo funcionar√° corretamente, isso √© oficialmente suportado e documentado. </li><li>  Voc√™ pode iniciar v√°rios encadeamentos aguardando eventos da mesma fila usando epoll_wait.  Algo que de forma alguma pode ser feito com select / poll. </li></ul><br>  Mas voc√™ tamb√©m precisa se lembrar que epoll n√£o √© "uma enquete melhorada".  Tem desvantagens em compara√ß√£o com a pesquisa: <br><br><ul><li>  Alterar os sinalizadores de evento (por exemplo, alternar de READ para WRITE) requer uma chamada extra do sistema epoll_ctl, enquanto que para a pesquisa voc√™ apenas altera a m√°scara de bits (completamente no modo de usu√°rio).  A troca de 5.000 soquetes de leitura para grava√ß√£o exigir√° 5.000 chamadas de sistema e altern√¢ncias de contexto para epoll, enquanto para pesquisas ser√° uma opera√ß√£o de bit trivial em um loop. </li><li>  Para cada nova conex√£o, √© necess√°rio chamar accept () e epoll_ctl () s√£o duas chamadas do sistema.  Se voc√™ usar a enquete, haver√° apenas uma chamada.  Com uma vida √∫til de conex√£o muito curta, isso pode fazer a diferen√ßa. </li><li>  O epoll est√° dispon√≠vel apenas no Linux.  Outros sistemas operacionais possuem mecanismos semelhantes, mas ainda n√£o completamente id√™nticos.  Voc√™ n√£o poder√° escrever c√≥digo com o epoll para que ele construa e funcione, por exemplo, no FreeBSD. </li><li>  Escrever c√≥digo paralelo altamente carregado √© dif√≠cil.  Muitos aplicativos n√£o precisam de uma abordagem t√£o fundamental, pois seu n√≠vel de carga √© facilmente processado usando m√©todos mais simples. </li></ul><br>  Portanto, o epoll deve ser usado apenas quando tudo o que se segue for verdadeiro: <br><br><ul><li>  Seu aplicativo usa um pool de threads para manipular conex√µes de rede.  O ganho do epoll em um aplicativo de thread √∫nico ser√° desprez√≠vel e voc√™ n√£o deve se preocupar com a implementa√ß√£o. </li><li>  Voc√™ espera um n√∫mero relativamente grande de conex√µes (de 1000 e acima).  Em um pequeno n√∫mero de soquetes observados, o epoll n√£o dar√° um ganho de desempenho e, se houver literalmente alguns soquetes, ele pode at√© diminuir a velocidade. </li><li>  Suas conex√µes vivem relativamente longas.  Em uma situa√ß√£o em que uma nova conex√£o transfere apenas alguns bytes de dados e fecha bem ali - a pesquisa funcionar√° mais r√°pido, porque precisar√° fazer menos chamadas do sistema para process√°-la. </li><li>  Voc√™ pretende executar seu c√≥digo no Linux e somente no Linux. </li></ul><br>  Se um ou mais dos itens falharem, considere usar poll ou libevent. <br><br><h3>  libevent </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libevent</a> √© uma biblioteca que agrupa os m√©todos de pesquisa listados neste artigo (assim como alguns outros) em uma API unificada.  A vantagem aqui √© que, depois de escrever o c√≥digo, voc√™ poder√° criar e execut√°-lo em diferentes sistemas operacionais.  No entanto, √© importante entender que o libevent √© apenas um inv√≥lucro, dentro do qual todos os m√©todos acima funcionam, com todas as suas vantagens e desvantagens.  O libevent n√£o for√ßar√° o select a ouvir mais de 1024 soquetes e o epoll n√£o modificar√° a lista de eventos sem uma chamada adicional do sistema.  Portanto, conhecer as tecnologias subjacentes ainda √© importante. <br><br>  A necessidade de oferecer suporte a diferentes m√©todos de pesquisa torna a API da biblioteca libevent mais complexa.  Ainda assim, seu uso √© mais f√°cil do que escrever manualmente dois mecanismos diferentes de sele√ß√£o de eventos para, por exemplo, Linux e FreeBSD (usando epoll e kqueue). <br><br>  Considere usar libevent ao combinar dois eventos: <br><br><ul><li>  Voc√™ analisou os m√©todos de sele√ß√£o e pesquisa e eles definitivamente n√£o funcionaram para voc√™. </li><li>  Voc√™ precisa suportar v√°rios sistemas operacionais </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415259/">https://habr.com/ru/post/pt415259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415249/index.html">Um pequeno passo para um programador √© um grande passo para uma ONG</a></li>
<li><a href="../pt415251/index.html">Funcion√°rios da Amazon, Google e Microsoft protestam contra coopera√ß√£o com militares e policiais</a></li>
<li><a href="../pt415253/index.html">Fotografias do s√©culo XIX foram restauradas usando a tecnologia do s√©culo XXI</a></li>
<li><a href="../pt415255/index.html">Roskosmos anunciou o t√©rmino de voos de m√≠sseis Proton</a></li>
<li><a href="../pt415257/index.html">8 maneiras de melhorar a visualiza√ß√£o de dados</a></li>
<li><a href="../pt415261/index.html">Artista VFX em desenvolvimento de jogos: caracter√≠sticas, carreira, desenvolvimento</a></li>
<li><a href="../pt415263/index.html">Como adicionamos entradas ao mapa e reduzimos o tamanho das bases em 10%</a></li>
<li><a href="../pt415265/index.html">Procurando um sucessor para o KL-7: RACE e AROFLEX</a></li>
<li><a href="../pt415269/index.html">Como o JS funciona: √Årvores de sintaxe abstratas, an√°lise e sua otimiza√ß√£o</a></li>
<li><a href="../pt415271/index.html">Como os gr√°ficos de Gantt simplificam o gerenciamento de projetos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>