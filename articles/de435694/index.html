<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß¢ üíã üë©üèº‚Äç‚öïÔ∏è Wie und warum haben wir den Algorithmus zum Bereinigen von SLAB-Caches im Linux-Kernel optimiert? üíô üë©üèΩ‚Äçüåæ üßëüèº‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die wachsende Beliebtheit von Containern und ihre Verwendung in Verbindung mit Kontrollgruppen ergab ein ernstes Skalierbarkeitsproblem, das bei gro√üe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie und warum haben wir den Algorithmus zum Bereinigen von SLAB-Caches im Linux-Kernel optimiert?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/virtuozzo/blog/435694/">  Die wachsende Beliebtheit von Containern und ihre Verwendung in Verbindung mit Kontrollgruppen ergab ein ernstes Skalierbarkeitsproblem, das bei gro√üen Maschinen zu einem erheblichen Leistungsabfall f√ºhrt.  Das Problem ist, dass die Umgehungszeit von SLAB-Caches quadratisch von der Anzahl der Container abh√§ngt und der aktive Verbrauch gro√üer Speichermengen in kurzer Zeit dazu f√ºhren kann, dass das System in eine Besetztschleife ger√§t und 100% der Prozessorzeit verbraucht.  Heute m√∂chte ich Ihnen sagen, wie wir dieses Problem gel√∂st haben, indem wir den Abrechnungsalgorithmus f√ºr die Verwendung der memcg-Kontrollgruppe zur Verwendung von SLAB-Cache-Objekten ge√§ndert und die Funktion shrink_slab () optimiert haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99b/7f3/83b/99b7f383beadeec2c814a6792e507b6c.jpg" alt="Speicherreinigung"><br><a name="habracut"></a><br>  Warum stellte sich die Frage nach der Optimierung von Prozessen im Kernel?  Alles begann damit, dass einer unserer Kunden, der aktiv Container und Speichersteuerungsgruppen (memcg) verwendete, auf die merkw√ºrdigen Spitzen des Prozessorressourcenverbrauchs aufmerksam machte, die von Zeit zu Zeit auftreten.  Die normale Systemlast betrug etwa 50%, und zu Spitzenzeiten wurden 100% der Prozessorzeit beansprucht, und fast alles davon wurde vom Kernel verbraucht (Systemzeit). <br>  Der Knoten selbst war ein Mehrbenutzer, auf dem ungef√§hr 200 OpenVZ-Container gestartet wurden.  Die Analyse ergab, dass eine gro√üe Anzahl von Benutzern verschachtelte Docker-Container und mehrstufige Hierarchien von Speichersteuerungsgruppen erstellt hat.  Jeder Container der obersten Ebene auf Benutzerebene enthielt ungef√§hr 20 Einh√§ngepunkte und 20 von systemd erstellte Kontrollspeichergruppen (memcg).  Dar√ºber hinaus wurden vom oben genannten Docker Einh√§ngepunkte und Kontrollgruppen erstellt.  Einfach ausgedr√ºckt, der Knoten war stark ausgelastet und die Belastung war viel st√§rker als der Durchschnitt aller unserer anderen Kunden.  Wir waren daran interessiert, den Grund f√ºr das Auftreten dieser Peaks zu finden, da das gleiche Problem auf weniger ausgelasteten Maschinen auftreten kann, auf denen es kaum wahrnehmbar ist (geben Sie beispielsweise Peaks mit einer Systemzeit von + 5% an, die die Leistung beeintr√§chtigen). <br><br>  Durch die Manipulation von Perf gelang es mir, den Gipfel zu erreichen und die Spur zu entfernen.  Es stellte sich heraus, dass der gr√∂√üte Teil der Prozessorzeit f√ºr das L√∂schen von SLAB-Caches aufgewendet wird, n√§mlich f√ºr Superblock-Caches: <br><br><pre><code class="markdown hljs"><span class="hljs-bullet"><span class="hljs-bullet">- </span></span>100,00% 0,00% kswapd0 [kernel.vmlinux] [k] kthread - 99,31% balance<span class="hljs-emphasis"><span class="hljs-emphasis">_pgdat - 82,11% shrink_</span></span>zone - 61,69% shrink<span class="hljs-emphasis"><span class="hljs-emphasis">_slab - 58,29% super_</span></span>cache<span class="hljs-emphasis"><span class="hljs-emphasis">_count + 54,56% list_</span></span>lru<span class="hljs-emphasis"><span class="hljs-emphasis">_count_</span></span>one</code> </pre> <br><br>  Hier lohnt es sich, eine Erkl√§rung abzugeben und n√§her auf dieses Thema einzugehen.  Jeder wei√ü, dass der Kernel nicht verwendete Daten f√ºr eine Weile zwischenspeichert, bevor schlie√ülich Speicher freigegeben wird.  Der Kernel nutzt dieses Prinzip in gro√üem Umfang.  Beispielsweise enth√§lt der Seitencache Seiten mit Daten, die sich auf die Datei beziehen, was den wiederholten Zugriff beim Lesen erheblich beschleunigt (da Sie nicht erneut auf die Festplatte zugreifen m√ºssen).  In unserem Fall trat das Problem mit dem Superblock-Metadaten-Cache auf, der in zwei LRU-Listen enthalten ist: s_dentry_lru und s_inode_lru. <br><br>  <b>LRU (am wenigsten k√ºrzlich verwendet)</b> <b><br></b> <br>  struct lru_list zeigt auf ein Array verkn√ºpfter Listen, und jedes aktive Memcg entspricht einem Element (list_lru_one) in diesem Array.  Wenn ein bestimmtes SLAB-Objekt vom Kernel nicht mehr verwendet wird, f√ºgt der Kernel es einer der verkn√ºpften Listen des Arrays hinzu (abh√§ngig davon, zu welchem ‚Äã‚ÄãMemcg das Objekt geh√∂rt oder grob gesagt, zu welchem ‚Äã‚ÄãMemcg der Prozess, der beim Erstellen dieses Objekts verwendet wurde).  Das Array selbst wird wie folgt beschrieben (lru_list :: node :: memcg_lrus): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_memcg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* array of per cgroup lists, indexed by memcg_cache_id */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lru</span></span></span><span class="hljs-class">[0];</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* may become negative during memcg reparenting */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_items; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> };</code> </pre><br>  lru [0] gibt eine Liste von Objekten an, die sich auf memcg mit der ID 0 beziehen; <br>  lru [1] gibt eine Liste von Objekten an, die sich auf memcg mit der ID 1 beziehen; <br>  ... <br>  lru [n] gibt eine Liste von Objekten an, die sich auf memcg mit der ID n beziehen; <br><br>  LRU-Listen s_dentry_lru und s_inode_lru erscheinen in unserem Problem und enthalten, wie der Name schon sagt, nicht verwendete Dentry- und Inode-Dateisystemobjekte. <br>  Wenn in Zukunft nicht gen√ºgend Speicher im System oder in einem bestimmten Memcg vorhanden ist, werden einige der Listenelemente endg√ºltig freigegeben, und ein spezieller Mechanismus namens Shrinker f√ºhrt dies aus. <br><br>  <b>Schrumpfer</b> <b><br></b> <br>  Wenn der Kernel Speicherseiten zuweisen muss, aber auf dem NUMA-Knoten oder im System kein freier Speicher vorhanden ist, wird der Mechanismus zum Bereinigen gestartet.  Er versucht, eine bestimmte Menge an Datentr√§ger zu werfen oder zu verwerfen: 1) Seiten mit dem Inhalt von Dateien aus dem Seiten-Cache;  2) Seiten, die sich auf anonymen Speicher in einem Swap beziehen, und 3) zwischengespeicherte SLAB-Objekte (das Problem, auf das wir gesto√üen sind, h√§ngt mit ihnen zusammen). <br><br>  Das Verwerfen eines Teils der zwischengespeicherten SLAB-Objekte wirkt sich nicht direkt auf die Freigabe von Seiten aus: Ihre Gr√∂√üe ist in der Regel erheblich kleiner als die Seitengr√∂√üe, und eine Seite enth√§lt Hunderte von Objekten.  Wenn ein Teil der Objekte freigegeben wird, werden auf den SLAB-Seiten freie Speicherl√ºcken angezeigt, mit denen andere SLAB-Objekte erstellt werden k√∂nnen.  Dieser Algorithmus wird absichtlich im Kernel akzeptiert: Er ist einfach und sehr effizient.  Ein interessierter Leser kann die Formel zum Ausw√§hlen eines Teils der zu bereinigenden Objekte in der Funktion do_shrink_slab () sehen. <br><br>  Diese Funktion f√ºhrt die eigentliche Reinigung eines Teils der Objekte durch, basierend auf der Beschreibung, die im Strukturschrumpfer an sie √ºbergeben wurde: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrink_control *shrinkctl, struct shrinker *shrinker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> freeable = shrinker-&gt;count_objects(shrinker, shrinkctl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (freeable == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; total_scan = _(freeable); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (total_scan &gt;= batch_size) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret = shrinker-&gt;scan_objects(shrinker, shrinkctl); total_scan -= shrinkctl-&gt;nr_scanned; } ... }</code> </pre> <br>  In Bezug auf den Schrumpfer-Superblock werden diese Funktionen wie folgt implementiert.  Jeder Superblock verwaltet seine eigenen s_dentry_lru- und s_inode_lru-Listen nicht verwendeter Objekte, die damit zusammenh√§ngen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">super_block</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrinker</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_shrink</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* per-sb shrinker handle */</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_dentry_lru</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_inode_lru</span></span></span><span class="hljs-class">;</span></span> ‚Ä¶ };</code> </pre> <br><br>  Die Methode .count_objects gibt die Anzahl der Objekte zur√ºck: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ total_objects += list_lru_shrink_count(&amp;sb-&gt;s_dentry_lru, sc); total_objects += list_lru_shrink_count(&amp;sb-&gt;s_inode_lru, sc); <span class="hljs-comment"><span class="hljs-comment">/*     ) */</span></span> total_objects = vfs_pressure_ratio(total_objects); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total_objects; }</code> </pre> <br><br>  Die .scan_objects-Methode gibt tats√§chlich Objekte frei: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_scan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     s_dentry_lru */</span></span> prune_dcache_sb(sb, sc); <span class="hljs-comment"><span class="hljs-comment">/*     s_inode_lru */</span></span> prune_icache_sb(sb, sc); }</code> </pre> <br>  Die Anzahl der freizugebenden Objekte wird im Parameter sc √ºbergeben.  Dort ist auch memcg angegeben, dessen Objekte aus der LRU geworfen werden sollen: <br><br><pre> <b><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nid; <span class="hljs-comment"><span class="hljs-comment">/* ID NUMA  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_to_scan; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memcg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* memcg */</span></span> };</code></b> </pre><br>  Daher w√§hlt prune_dcache_sb () eine verkn√ºpfte Liste aus dem Array struct list_lru_memcg :: lru [] aus und arbeitet damit.  Prune_icache_sb () macht dasselbe. <br><br>  <b>Alter Schrumpfer-Bypass-Algorithmus</b> <b><br></b> <br>  Beim Standardansatz werden Objekte aus dem SLAB ‚Äûausgeworfen‚Äú, wenn nicht gen√ºgend Speicher vorhanden ist <br>  sc-&gt; target_mem_cgroup geschieht wie folgt: <br><br><pre> <code class="cpp hljs">shrink_node() { ‚Ä¶ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target_mem_cgroup</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      sc-&gt;target_mem_cgroup  */</span></span> memcg = mem_cgroup_iter(root, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;reclaim); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ‚Ä¶ shrink_slab(memcg, ...); ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((memcg = mem_cgroup_iter(root, memcg, &amp;reclaim))); ... }</code> </pre><br>  Wir gehen alle untergeordneten Memcg durch und rufen f√ºr jeden von ihnen shrink_slab () auf.  Als n√§chstes gehen wir in der Funktion shrink_slab () alle Shrinker durch und rufen f√ºr jeden von ihnen do_shrink_slab () auf: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">gfp_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gfp_mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nid, struct mem_cgroup *memcg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ list_for_each_entry(shrinker, &amp;shrinker_list, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class"> = {</span></span> .nid = nid, .memcg = memcg, }; ret = do_shrink_slab(&amp;sc, shrinker, ...); } }</code> </pre><br>  Denken Sie daran, dass f√ºr jeden Superblock ein eigener Shrinker zu dieser Liste hinzugef√ºgt wird.  Z√§hlen wir, wie oft do_shrink_slab () f√ºr den Fall mit 200 Containern mit jeweils 20 Memcg und 20 Mountpunkten aufgerufen wird.  Insgesamt haben wir 200 * 20 Einh√§ngepunkte und 200 * 20 Kontrollgruppen.  Wenn im obersten Memcg nicht gen√ºgend Speicher vorhanden ist, m√ºssen wir alle untergeordneten Memcg (d. H. Im Allgemeinen alles) umgehen und f√ºr jeden von ihnen jeden Shrinker aus der shrinker_list aufrufen.  Daher ruft der Kernel die Funktion do_shrink_slab () mit 200 * 20 * 200 * 20 = 16000000 auf. <br><br>  Dar√ºber hinaus ist die √ºberw√§ltigende Anzahl von Aufrufen dieser Funktion nutzlos: Container sind normalerweise untereinander isoliert, und die Wahrscheinlichkeit, dass CT1 den in CT2 erstellten super_block2 verwendet, ist im Allgemeinen gering.  Oder was auch immer, wenn memcg1 eine Kontrollgruppe von CT1 ist, dann ist das entsprechende Element des Arrays super_block2-&gt; s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg1_id] eine leere Liste, und es macht keinen Sinn, do_shrink_slab () daf√ºr aufzurufen. <br><br>  Dieses Problem kann mit einem einfachen Bash-Skript modelliert werden (hier werden Daten aus dem Patchset verwendet, das anschlie√üend an den Kernel √ºbergeben wurde): <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 1 &gt; /sys/fs/cgroup/memory/memory.use_hierarchy <span class="hljs-variable"><span class="hljs-variable">$mkdir</span></span> /sys/fs/cgroup/memory/ct <span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 4000M &gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes <span class="hljs-variable"><span class="hljs-variable">$for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `seq 0 4000`; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mkdir /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ &gt; /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/cgroup.procs; mkdir -ps/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; mount -t tmpfs <span class="hljs-variable"><span class="hljs-variable">$is</span></span>/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; touch s/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/file; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br>  Mal sehen, was passiert, wenn Sie die Cache-Reset-Prozedur f√ºnfmal hintereinander aufrufen: <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br>  Die erste Iteration dauert 14 Sekunden, da sich die zwischengespeicherten Objekte tats√§chlich im Speicher befinden: <i>0,00 Benutzer 13,78 System <b>0: 13,78</b> 99% CPU <b>verstrichen</b> .</i> <br>  Die zweite Iteration dauert 5 Sekunden, obwohl keine Objekte mehr vorhanden sind: <i>0.00user 5.59system <b>0: 05.60elapsed</b> 99% CPU.</i> <br>  Die dritte Iteration dauert 5 Sekunden: <i>0.00user 5.48system <b>0: 05.48elapsed</b> 99% CPU</i> <br>  Die vierte Iteration dauert 8 Sekunden: <i>0.00user 8.35system <b>0: 08.35elapsed</b> 99% CPU</i> <br>  Die f√ºnfte Iteration dauert 8 Sekunden: <i>0.00user 8.34system <b>0: 08.35elapsed</b> 99% CPU</i> <br><br>  Es wurde deutlich, dass der vom Vanillekern verwendete Shrinker-Bypass-Algorithmus nicht optimal ist, und wir m√ºssen ihn hinsichtlich der Skalierbarkeit zum Besseren √§ndern. <br><br>  <b>Neuer Shrinker-Bypass-Algorithmus</b> <b><br></b> <br>  Mit dem neuen Algorithmus wollte ich Folgendes erreichen: <br><br><ol><li>  befreie ihn von den Fehlern der alten und </li><li>  F√ºgen Sie keine neuen Sperren hinzu.  Rufen Sie do_shrink_slab () nur dann auf, wenn dies sinnvoll ist (dh die entsprechende verkn√ºpfte Liste aus dem Array s_dentry_lru oder aus dem Array s_inode_lru ist nicht leer), greifen Sie jedoch nicht direkt auf den Speicher der verkn√ºpften Liste zu. </li></ol><br>  Es war klar, dass dies nur durch eine neue Datenstruktur √ºber heterogenen Shrinkern bereitgestellt werden kann (es gibt Shrinker nicht nur des Superblocks, sondern auch anderer Datenobjekte, die in diesem Artikel nicht beschrieben werden. Der Leser kann sich mit ihnen vertraut machen, indem er nach dem Schl√ºsselwort prealloc_shrinker () sucht. im Kernel-Code).  Die neue Datenstruktur sollte die Codierung von zwei Zust√§nden erm√∂glichen: "Es ist sinnvoll, do_shrink_slab () aufzurufen" und "Es macht keinen Sinn, do_shrink_slab () aufzurufen". <br><br>  Datenstrukturen vom Typ IDA wurden abgelehnt, weil  Sie benutzen Schl√∂sser in sich.  Die Datenstruktur des Bitfelds ist f√ºr diese Rolle voll geeignet: Sie erm√∂glicht die atomare Modifikation einzelner Bits und erm√∂glicht in Kombination mit Speicherbarrieren die Erstellung eines effizienten Algorithmus ohne Verwendung von Sperren. <br><br>  Jeder Shrinker erh√§lt eine eigene eindeutige ID (shrinker :: id), und jedes Memcg erh√§lt eine Bitmap, die die gr√∂√üte ID der aktuell registrierten IDs enthalten kann.  Wenn das erste Element zur Liste s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg_id] hinzugef√ºgt wird, wird die entsprechende memcg-Bitmap mit der Nummer shrinker-&gt; id auf 1 Bit gesetzt.  Gleiches gilt f√ºr s_inode_id. <br><br>  Jetzt kann die Schleife in shrink_slab () so optimiert werden, dass nur die erforderlichen Shrinker umgangen werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ for_each_set_bit(i, <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>, shrinker_nr_max) { ‚Ä¶ shrinker = idr_find(&amp;shrinker_idr, i); ‚Ä¶ do_shrink_slab(&amp;sc, shrinker, priority); ‚Ä¶ } }</code> </pre><br>  (Die Bitbereinigung wird auch implementiert, wenn der Shrinker in den Status "Es macht keinen Sinn, do_shrink_slab () aufzurufen. Weitere Informationen finden Sie im Github- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit</a> ." <br><br>  Wenn Sie den Cache-Reset-Test wiederholen, werden mit dem neuen Algorithmus deutlich bessere Ergebnisse angezeigt: <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br>  Erste Iteration: <i>0.00user 1.10system <b>0: 01.10elapsed</b> 99% CPU</i> <i><br></i>  Zweite Iteration: <i>0.00user 0.00system <b>0: 00.01elapsed</b> 64% CPU</i> <i><br></i>  Dritte Iteration: <i>0.00user 0.01system <b>0: 00.01elapsed</b> 82% CPU</i> <i><br></i>  Vierte Iteration: <i>0.00user 0.00system <b>0: 00.01elapsed</b> 64% CPU</i> <i><br></i>  F√ºnfte Iteration: <i>0.00user 0.01system <b>0: 00.01elapsed</b> 82% CPU</i> <br>  Die Dauer der zweiten bis f√ºnften Iteration betr√§gt 0,01 Sekunden, <b>548-mal schneller als zuvor.</b> <br><br>  Da √§hnliche Aktionen zum Zur√ºcksetzen der Caches bei jedem Speichermangel auf dem Computer ausgef√ºhrt werden, verbessert diese Optimierung den Betrieb von Computern mit einer gro√üen Anzahl von Containern und Speichersteuerungsgruppen erheblich.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Reihe von Patches</a> (17 St√ºck) wurde in den Vanillekern aufgenommen und ist dort ab Version 4.19 zu finden. <br><br>  Bei der √úberpr√ºfung der Patches wurde ein Google-Mitarbeiter angezeigt, und es stellte sich heraus, dass er das gleiche Problem hatte.  Daher wurden Patches auf einer anderen Art von Last weiter getestet. <br>  Infolgedessen wurde das Patchset aus der 9. Iteration √ºbernommen.  und sein Eintritt in den Vanillekern dauerte ungef√§hr 4 Monate.  Auch heute ist das Patchset in unserem eigenen Virtuozzo 7-Kernel enthalten, beginnend mit Version vz7.71.9 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435694/">https://habr.com/ru/post/de435694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435684/index.html">Das Oak Ridge National Laboratory hat das Hauptproblem der Entwickler von Weltraumger√§ten gel√∂st: Plutonium-238-Mangel</a></li>
<li><a href="../de435686/index.html">Pavel Durov liquidiert Telegram Messenger LLP</a></li>
<li><a href="../de435688/index.html">Anwendungsbeispiel f√ºr Flutter Client Server</a></li>
<li><a href="../de435690/index.html">[Was ist los mit GraphQL] ... und wie man damit umgeht</a></li>
<li><a href="../de435692/index.html">Y Combinator: ‚ÄûEinige der gr√∂√üten Technologieunternehmen sehen zun√§chst wie Spielzeug aus.‚Äú</a></li>
<li><a href="../de435696/index.html">Antiquit√§ten: 1997 Computerwerbung</a></li>
<li><a href="../de435698/index.html">Schreiben Sie Ihren eigenen guten Speichermanager</a></li>
<li><a href="../de435700/index.html">8 Worst Vue.js Interview Fragen</a></li>
<li><a href="../de435702/index.html">Patenttrolle starten und gewinnen: wie ich ohne Spiel blieb</a></li>
<li><a href="../de435704/index.html">Architekturl√∂sungen f√ºr ein Handyspiel. Teil 2: Befehl und ihre Warteschlangen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>