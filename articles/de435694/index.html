<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧢 💋 👩🏼‍⚕️ Wie und warum haben wir den Algorithmus zum Bereinigen von SLAB-Caches im Linux-Kernel optimiert? 💙 👩🏽‍🌾 🧑🏼‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die wachsende Beliebtheit von Containern und ihre Verwendung in Verbindung mit Kontrollgruppen ergab ein ernstes Skalierbarkeitsproblem, das bei große...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie und warum haben wir den Algorithmus zum Bereinigen von SLAB-Caches im Linux-Kernel optimiert?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/virtuozzo/blog/435694/">  Die wachsende Beliebtheit von Containern und ihre Verwendung in Verbindung mit Kontrollgruppen ergab ein ernstes Skalierbarkeitsproblem, das bei großen Maschinen zu einem erheblichen Leistungsabfall führt.  Das Problem ist, dass die Umgehungszeit von SLAB-Caches quadratisch von der Anzahl der Container abhängt und der aktive Verbrauch großer Speichermengen in kurzer Zeit dazu führen kann, dass das System in eine Besetztschleife gerät und 100% der Prozessorzeit verbraucht.  Heute möchte ich Ihnen sagen, wie wir dieses Problem gelöst haben, indem wir den Abrechnungsalgorithmus für die Verwendung der memcg-Kontrollgruppe zur Verwendung von SLAB-Cache-Objekten geändert und die Funktion shrink_slab () optimiert haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99b/7f3/83b/99b7f383beadeec2c814a6792e507b6c.jpg" alt="Speicherreinigung"><br><a name="habracut"></a><br>  Warum stellte sich die Frage nach der Optimierung von Prozessen im Kernel?  Alles begann damit, dass einer unserer Kunden, der aktiv Container und Speichersteuerungsgruppen (memcg) verwendete, auf die merkwürdigen Spitzen des Prozessorressourcenverbrauchs aufmerksam machte, die von Zeit zu Zeit auftreten.  Die normale Systemlast betrug etwa 50%, und zu Spitzenzeiten wurden 100% der Prozessorzeit beansprucht, und fast alles davon wurde vom Kernel verbraucht (Systemzeit). <br>  Der Knoten selbst war ein Mehrbenutzer, auf dem ungefähr 200 OpenVZ-Container gestartet wurden.  Die Analyse ergab, dass eine große Anzahl von Benutzern verschachtelte Docker-Container und mehrstufige Hierarchien von Speichersteuerungsgruppen erstellt hat.  Jeder Container der obersten Ebene auf Benutzerebene enthielt ungefähr 20 Einhängepunkte und 20 von systemd erstellte Kontrollspeichergruppen (memcg).  Darüber hinaus wurden vom oben genannten Docker Einhängepunkte und Kontrollgruppen erstellt.  Einfach ausgedrückt, der Knoten war stark ausgelastet und die Belastung war viel stärker als der Durchschnitt aller unserer anderen Kunden.  Wir waren daran interessiert, den Grund für das Auftreten dieser Peaks zu finden, da das gleiche Problem auf weniger ausgelasteten Maschinen auftreten kann, auf denen es kaum wahrnehmbar ist (geben Sie beispielsweise Peaks mit einer Systemzeit von + 5% an, die die Leistung beeinträchtigen). <br><br>  Durch die Manipulation von Perf gelang es mir, den Gipfel zu erreichen und die Spur zu entfernen.  Es stellte sich heraus, dass der größte Teil der Prozessorzeit für das Löschen von SLAB-Caches aufgewendet wird, nämlich für Superblock-Caches: <br><br><pre><code class="markdown hljs"><span class="hljs-bullet"><span class="hljs-bullet">- </span></span>100,00% 0,00% kswapd0 [kernel.vmlinux] [k] kthread - 99,31% balance<span class="hljs-emphasis"><span class="hljs-emphasis">_pgdat - 82,11% shrink_</span></span>zone - 61,69% shrink<span class="hljs-emphasis"><span class="hljs-emphasis">_slab - 58,29% super_</span></span>cache<span class="hljs-emphasis"><span class="hljs-emphasis">_count + 54,56% list_</span></span>lru<span class="hljs-emphasis"><span class="hljs-emphasis">_count_</span></span>one</code> </pre> <br><br>  Hier lohnt es sich, eine Erklärung abzugeben und näher auf dieses Thema einzugehen.  Jeder weiß, dass der Kernel nicht verwendete Daten für eine Weile zwischenspeichert, bevor schließlich Speicher freigegeben wird.  Der Kernel nutzt dieses Prinzip in großem Umfang.  Beispielsweise enthält der Seitencache Seiten mit Daten, die sich auf die Datei beziehen, was den wiederholten Zugriff beim Lesen erheblich beschleunigt (da Sie nicht erneut auf die Festplatte zugreifen müssen).  In unserem Fall trat das Problem mit dem Superblock-Metadaten-Cache auf, der in zwei LRU-Listen enthalten ist: s_dentry_lru und s_inode_lru. <br><br>  <b>LRU (am wenigsten kürzlich verwendet)</b> <b><br></b> <br>  struct lru_list zeigt auf ein Array verknüpfter Listen, und jedes aktive Memcg entspricht einem Element (list_lru_one) in diesem Array.  Wenn ein bestimmtes SLAB-Objekt vom Kernel nicht mehr verwendet wird, fügt der Kernel es einer der verknüpften Listen des Arrays hinzu (abhängig davon, zu welchem ​​Memcg das Objekt gehört oder grob gesagt, zu welchem ​​Memcg der Prozess, der beim Erstellen dieses Objekts verwendet wurde).  Das Array selbst wird wie folgt beschrieben (lru_list :: node :: memcg_lrus): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_memcg</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rcu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* array of per cgroup lists, indexed by memcg_cache_id */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lru</span></span></span><span class="hljs-class">[0];</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru_one</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* may become negative during memcg reparenting */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_items; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> };</code> </pre><br>  lru [0] gibt eine Liste von Objekten an, die sich auf memcg mit der ID 0 beziehen; <br>  lru [1] gibt eine Liste von Objekten an, die sich auf memcg mit der ID 1 beziehen; <br>  ... <br>  lru [n] gibt eine Liste von Objekten an, die sich auf memcg mit der ID n beziehen; <br><br>  LRU-Listen s_dentry_lru und s_inode_lru erscheinen in unserem Problem und enthalten, wie der Name schon sagt, nicht verwendete Dentry- und Inode-Dateisystemobjekte. <br>  Wenn in Zukunft nicht genügend Speicher im System oder in einem bestimmten Memcg vorhanden ist, werden einige der Listenelemente endgültig freigegeben, und ein spezieller Mechanismus namens Shrinker führt dies aus. <br><br>  <b>Schrumpfer</b> <b><br></b> <br>  Wenn der Kernel Speicherseiten zuweisen muss, aber auf dem NUMA-Knoten oder im System kein freier Speicher vorhanden ist, wird der Mechanismus zum Bereinigen gestartet.  Er versucht, eine bestimmte Menge an Datenträger zu werfen oder zu verwerfen: 1) Seiten mit dem Inhalt von Dateien aus dem Seiten-Cache;  2) Seiten, die sich auf anonymen Speicher in einem Swap beziehen, und 3) zwischengespeicherte SLAB-Objekte (das Problem, auf das wir gestoßen sind, hängt mit ihnen zusammen). <br><br>  Das Verwerfen eines Teils der zwischengespeicherten SLAB-Objekte wirkt sich nicht direkt auf die Freigabe von Seiten aus: Ihre Größe ist in der Regel erheblich kleiner als die Seitengröße, und eine Seite enthält Hunderte von Objekten.  Wenn ein Teil der Objekte freigegeben wird, werden auf den SLAB-Seiten freie Speicherlücken angezeigt, mit denen andere SLAB-Objekte erstellt werden können.  Dieser Algorithmus wird absichtlich im Kernel akzeptiert: Er ist einfach und sehr effizient.  Ein interessierter Leser kann die Formel zum Auswählen eines Teils der zu bereinigenden Objekte in der Funktion do_shrink_slab () sehen. <br><br>  Diese Funktion führt die eigentliche Reinigung eines Teils der Objekte durch, basierend auf der Beschreibung, die im Strukturschrumpfer an sie übergeben wurde: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrink_control *shrinkctl, struct shrinker *shrinker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ … <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> freeable = shrinker-&gt;count_objects(shrinker, shrinkctl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (freeable == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; total_scan = _(freeable); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (total_scan &gt;= batch_size) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret = shrinker-&gt;scan_objects(shrinker, shrinkctl); total_scan -= shrinkctl-&gt;nr_scanned; } ... }</code> </pre> <br>  In Bezug auf den Schrumpfer-Superblock werden diese Funktionen wie folgt implementiert.  Jeder Superblock verwaltet seine eigenen s_dentry_lru- und s_inode_lru-Listen nicht verwendeter Objekte, die damit zusammenhängen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">super_block</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrinker</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_shrink</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* per-sb shrinker handle */</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_dentry_lru</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_lru</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_inode_lru</span></span></span><span class="hljs-class">;</span></span> … };</code> </pre> <br><br>  Die Methode .count_objects gibt die Anzahl der Objekte zurück: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ total_objects += list_lru_shrink_count(&amp;sb-&gt;s_dentry_lru, sc); total_objects += list_lru_shrink_count(&amp;sb-&gt;s_inode_lru, sc); <span class="hljs-comment"><span class="hljs-comment">/*     ) */</span></span> total_objects = vfs_pressure_ratio(total_objects); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total_objects; }</code> </pre> <br><br>  Die .scan_objects-Methode gibt tatsächlich Objekte frei: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">super_cache_scan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct shrinker *shrink, struct shrink_control *sc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     s_dentry_lru */</span></span> prune_dcache_sb(sb, sc); <span class="hljs-comment"><span class="hljs-comment">/*     s_inode_lru */</span></span> prune_icache_sb(sb, sc); }</code> </pre> <br>  Die Anzahl der freizugebenden Objekte wird im Parameter sc übergeben.  Dort ist auch memcg angegeben, dessen Objekte aus der LRU geworfen werden sollen: <br><br><pre> <b><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nid; <span class="hljs-comment"><span class="hljs-comment">/* ID NUMA  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nr_to_scan; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memcg</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* memcg */</span></span> };</code></b> </pre><br>  Daher wählt prune_dcache_sb () eine verknüpfte Liste aus dem Array struct list_lru_memcg :: lru [] aus und arbeitet damit.  Prune_icache_sb () macht dasselbe. <br><br>  <b>Alter Schrumpfer-Bypass-Algorithmus</b> <b><br></b> <br>  Beim Standardansatz werden Objekte aus dem SLAB „ausgeworfen“, wenn nicht genügend Speicher vorhanden ist <br>  sc-&gt; target_mem_cgroup geschieht wie folgt: <br><br><pre> <code class="cpp hljs">shrink_node() { … <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cgroup</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target_mem_cgroup</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      sc-&gt;target_mem_cgroup  */</span></span> memcg = mem_cgroup_iter(root, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;reclaim); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { … shrink_slab(memcg, ...); … } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((memcg = mem_cgroup_iter(root, memcg, &amp;reclaim))); ... }</code> </pre><br>  Wir gehen alle untergeordneten Memcg durch und rufen für jeden von ihnen shrink_slab () auf.  Als nächstes gehen wir in der Funktion shrink_slab () alle Shrinker durch und rufen für jeden von ihnen do_shrink_slab () auf: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">gfp_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gfp_mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nid, struct mem_cgroup *memcg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority)</span></span></span><span class="hljs-function"> </span></span>{ list_for_each_entry(shrinker, &amp;shrinker_list, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shrink_control</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sc</span></span></span><span class="hljs-class"> = {</span></span> .nid = nid, .memcg = memcg, }; ret = do_shrink_slab(&amp;sc, shrinker, ...); } }</code> </pre><br>  Denken Sie daran, dass für jeden Superblock ein eigener Shrinker zu dieser Liste hinzugefügt wird.  Zählen wir, wie oft do_shrink_slab () für den Fall mit 200 Containern mit jeweils 20 Memcg und 20 Mountpunkten aufgerufen wird.  Insgesamt haben wir 200 * 20 Einhängepunkte und 200 * 20 Kontrollgruppen.  Wenn im obersten Memcg nicht genügend Speicher vorhanden ist, müssen wir alle untergeordneten Memcg (d. H. Im Allgemeinen alles) umgehen und für jeden von ihnen jeden Shrinker aus der shrinker_list aufrufen.  Daher ruft der Kernel die Funktion do_shrink_slab () mit 200 * 20 * 200 * 20 = 16000000 auf. <br><br>  Darüber hinaus ist die überwältigende Anzahl von Aufrufen dieser Funktion nutzlos: Container sind normalerweise untereinander isoliert, und die Wahrscheinlichkeit, dass CT1 den in CT2 erstellten super_block2 verwendet, ist im Allgemeinen gering.  Oder was auch immer, wenn memcg1 eine Kontrollgruppe von CT1 ist, dann ist das entsprechende Element des Arrays super_block2-&gt; s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg1_id] eine leere Liste, und es macht keinen Sinn, do_shrink_slab () dafür aufzurufen. <br><br>  Dieses Problem kann mit einem einfachen Bash-Skript modelliert werden (hier werden Daten aus dem Patchset verwendet, das anschließend an den Kernel übergeben wurde): <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 1 &gt; /sys/fs/cgroup/memory/memory.use_hierarchy <span class="hljs-variable"><span class="hljs-variable">$mkdir</span></span> /sys/fs/cgroup/memory/ct <span class="hljs-variable"><span class="hljs-variable">$echo</span></span> 4000M &gt; /sys/fs/cgroup/memory/ct/memory.kmem.limit_in_bytes <span class="hljs-variable"><span class="hljs-variable">$for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `seq 0 4000`; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mkdir /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ &gt; /sys/fs/cgroup/memory/ct/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/cgroup.procs; mkdir -ps/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; mount -t tmpfs <span class="hljs-variable"><span class="hljs-variable">$is</span></span>/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>; touch s/<span class="hljs-variable"><span class="hljs-variable">$i</span></span>/file; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br>  Mal sehen, was passiert, wenn Sie die Cache-Reset-Prozedur fünfmal hintereinander aufrufen: <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br>  Die erste Iteration dauert 14 Sekunden, da sich die zwischengespeicherten Objekte tatsächlich im Speicher befinden: <i>0,00 Benutzer 13,78 System <b>0: 13,78</b> 99% CPU <b>verstrichen</b> .</i> <br>  Die zweite Iteration dauert 5 Sekunden, obwohl keine Objekte mehr vorhanden sind: <i>0.00user 5.59system <b>0: 05.60elapsed</b> 99% CPU.</i> <br>  Die dritte Iteration dauert 5 Sekunden: <i>0.00user 5.48system <b>0: 05.48elapsed</b> 99% CPU</i> <br>  Die vierte Iteration dauert 8 Sekunden: <i>0.00user 8.35system <b>0: 08.35elapsed</b> 99% CPU</i> <br>  Die fünfte Iteration dauert 8 Sekunden: <i>0.00user 8.34system <b>0: 08.35elapsed</b> 99% CPU</i> <br><br>  Es wurde deutlich, dass der vom Vanillekern verwendete Shrinker-Bypass-Algorithmus nicht optimal ist, und wir müssen ihn hinsichtlich der Skalierbarkeit zum Besseren ändern. <br><br>  <b>Neuer Shrinker-Bypass-Algorithmus</b> <b><br></b> <br>  Mit dem neuen Algorithmus wollte ich Folgendes erreichen: <br><br><ol><li>  befreie ihn von den Fehlern der alten und </li><li>  Fügen Sie keine neuen Sperren hinzu.  Rufen Sie do_shrink_slab () nur dann auf, wenn dies sinnvoll ist (dh die entsprechende verknüpfte Liste aus dem Array s_dentry_lru oder aus dem Array s_inode_lru ist nicht leer), greifen Sie jedoch nicht direkt auf den Speicher der verknüpften Liste zu. </li></ol><br>  Es war klar, dass dies nur durch eine neue Datenstruktur über heterogenen Shrinkern bereitgestellt werden kann (es gibt Shrinker nicht nur des Superblocks, sondern auch anderer Datenobjekte, die in diesem Artikel nicht beschrieben werden. Der Leser kann sich mit ihnen vertraut machen, indem er nach dem Schlüsselwort prealloc_shrinker () sucht. im Kernel-Code).  Die neue Datenstruktur sollte die Codierung von zwei Zuständen ermöglichen: "Es ist sinnvoll, do_shrink_slab () aufzurufen" und "Es macht keinen Sinn, do_shrink_slab () aufzurufen". <br><br>  Datenstrukturen vom Typ IDA wurden abgelehnt, weil  Sie benutzen Schlösser in sich.  Die Datenstruktur des Bitfelds ist für diese Rolle voll geeignet: Sie ermöglicht die atomare Modifikation einzelner Bits und ermöglicht in Kombination mit Speicherbarrieren die Erstellung eines effizienten Algorithmus ohne Verwendung von Sperren. <br><br>  Jeder Shrinker erhält eine eigene eindeutige ID (shrinker :: id), und jedes Memcg erhält eine Bitmap, die die größte ID der aktuell registrierten IDs enthalten kann.  Wenn das erste Element zur Liste s_dentry_lru-&gt; node-&gt; memcg_lrus-&gt; lru [memcg_id] hinzugefügt wird, wird die entsprechende memcg-Bitmap mit der Nummer shrinker-&gt; id auf 1 Bit gesetzt.  Gleiches gilt für s_inode_id. <br><br>  Jetzt kann die Schleife in shrink_slab () so optimiert werden, dass nur die erforderlichen Shrinker umgangen werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shrink_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ … for_each_set_bit(i, <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>, shrinker_nr_max) { … shrinker = idr_find(&amp;shrinker_idr, i); … do_shrink_slab(&amp;sc, shrinker, priority); … } }</code> </pre><br>  (Die Bitbereinigung wird auch implementiert, wenn der Shrinker in den Status "Es macht keinen Sinn, do_shrink_slab () aufzurufen. Weitere Informationen finden Sie im Github- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit</a> ." <br><br>  Wenn Sie den Cache-Reset-Test wiederholen, werden mit dem neuen Algorithmus deutlich bessere Ergebnisse angezeigt: <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$time</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 3 &gt; /proc/sys/vm/drop_caches</code> </pre> <br>  Erste Iteration: <i>0.00user 1.10system <b>0: 01.10elapsed</b> 99% CPU</i> <i><br></i>  Zweite Iteration: <i>0.00user 0.00system <b>0: 00.01elapsed</b> 64% CPU</i> <i><br></i>  Dritte Iteration: <i>0.00user 0.01system <b>0: 00.01elapsed</b> 82% CPU</i> <i><br></i>  Vierte Iteration: <i>0.00user 0.00system <b>0: 00.01elapsed</b> 64% CPU</i> <i><br></i>  Fünfte Iteration: <i>0.00user 0.01system <b>0: 00.01elapsed</b> 82% CPU</i> <br>  Die Dauer der zweiten bis fünften Iteration beträgt 0,01 Sekunden, <b>548-mal schneller als zuvor.</b> <br><br>  Da ähnliche Aktionen zum Zurücksetzen der Caches bei jedem Speichermangel auf dem Computer ausgeführt werden, verbessert diese Optimierung den Betrieb von Computern mit einer großen Anzahl von Containern und Speichersteuerungsgruppen erheblich.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Reihe von Patches</a> (17 Stück) wurde in den Vanillekern aufgenommen und ist dort ab Version 4.19 zu finden. <br><br>  Bei der Überprüfung der Patches wurde ein Google-Mitarbeiter angezeigt, und es stellte sich heraus, dass er das gleiche Problem hatte.  Daher wurden Patches auf einer anderen Art von Last weiter getestet. <br>  Infolgedessen wurde das Patchset aus der 9. Iteration übernommen.  und sein Eintritt in den Vanillekern dauerte ungefähr 4 Monate.  Auch heute ist das Patchset in unserem eigenen Virtuozzo 7-Kernel enthalten, beginnend mit Version vz7.71.9 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435694/">https://habr.com/ru/post/de435694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435684/index.html">Das Oak Ridge National Laboratory hat das Hauptproblem der Entwickler von Weltraumgeräten gelöst: Plutonium-238-Mangel</a></li>
<li><a href="../de435686/index.html">Pavel Durov liquidiert Telegram Messenger LLP</a></li>
<li><a href="../de435688/index.html">Anwendungsbeispiel für Flutter Client Server</a></li>
<li><a href="../de435690/index.html">[Was ist los mit GraphQL] ... und wie man damit umgeht</a></li>
<li><a href="../de435692/index.html">Y Combinator: „Einige der größten Technologieunternehmen sehen zunächst wie Spielzeug aus.“</a></li>
<li><a href="../de435696/index.html">Antiquitäten: 1997 Computerwerbung</a></li>
<li><a href="../de435698/index.html">Schreiben Sie Ihren eigenen guten Speichermanager</a></li>
<li><a href="../de435700/index.html">8 Worst Vue.js Interview Fragen</a></li>
<li><a href="../de435702/index.html">Patenttrolle starten und gewinnen: wie ich ohne Spiel blieb</a></li>
<li><a href="../de435704/index.html">Architekturlösungen für ein Handyspiel. Teil 2: Befehl und ihre Warteschlangen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>