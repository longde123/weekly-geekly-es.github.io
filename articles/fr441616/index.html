<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöæ ‚öúÔ∏è üëµüèº Likbez pour lancer Istio üôÑ üíÇ üî´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Maillage de service Isstio 


 Chez Namely, nous utilisons Istio depuis un an maintenant. Il vient alors de partir. Nous avons eu une grande baisse de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Likbez pour lancer Istio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/441616/"><p> <a href=""><img src="https://habrastorage.org/webt/sh/m2/ja/shm2jainigjyhqewoqvi4cxdlg0.jpeg"></a> <br>  <em>Maillage de service Isstio</em> </p><br><p>  Chez Namely, nous utilisons Istio depuis un an maintenant.  Il vient alors de partir.  Nous avons eu une grande baisse de performances dans le cluster Kubernetes, nous voulions un suivi distribu√© et avons pris Istio pour ex√©cuter Jaeger et le d√©couvrir.  Le maillage de service s'int√®gre si bien dans notre infrastructure que nous avons d√©cid√© d'investir dans cet outil. </p><br><p>  J'ai d√ª souffrir, mais nous l'avons √©tudi√© de tr√®s pr√®s.  Ceci est le premier article d'une s√©rie o√π je d√©crirai comment Istio s'int√®gre √† Kubernetes et ce que nous avons appris sur son travail.  Parfois, nous nous prom√®nerons dans les d√©serts techniques, mais pas tr√®s loin.  De plus, il y aura plus de messages. </p><a name="habracut"></a><br><h3 id="chto-takoe-istio">  Qu'est-ce que Istio? </h3><br><p>  Istio est un outil de configuration de maillage de service.  Il lit l'√©tat du cluster Kubernetes et met √† niveau les proxys L7 (HTTP et gRPC), qui sont impl√©ment√©s en tant que sidecar dans les pods Kubernetes.  Ces sidecar sont des conteneurs Envoy qui lisent la configuration √† partir de l'API Istio Pilot (et du service gRPC) et acheminent le trafic √† travers celle-ci.  Avec le puissant proxy L7 sous le capot, nous pouvons utiliser des m√©triques, des traces, une logique de nouvelle tentative, un disjoncteur, un √©quilibrage de charge et des d√©ploiements canaries. </p><br><h3 id="nachnem-s-nachala-kubernetes">  Commen√ßons par le d√©but: Kubernetes </h3><br><p> Dans Kubernetes, nous cr√©ons sous en utilisant un d√©ploiement ou un StatefulSet.  Ou il peut simplement √™tre ¬´vanille¬ª sous sans contr√¥leur de haut niveau.  Ensuite, Kubernetes fait de son mieux pour maintenir l'√©tat souhait√© - il cr√©e des pods dans le cluster sur le n≈ìud, s'assure qu'ils d√©marrent et red√©marrent.  Lorsqu'un sous est cr√©√©, Kubernetes parcourt le cycle de vie de l'API, s'assure que chaque √©tape r√©ussit, puis cr√©e finalement le sous sur le cluster. </p><br><p>  √âtapes du cycle de vie de l'API: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/dl/dc/t5/dldct5fzrxubc5c1z3zt2m7lchu.png"></a> <br>  <em>Merci √† Banzai Cloud pour la photo sympa.</em> </p><br><p>  L'une des √©tapes consiste √† modifier les webhooks d'admission.  Il s'agit d'une partie distincte du cycle de vie de Kubernetes, o√π les ressources sont personnalis√©es avant de s'engager dans le r√©f√©rentiel etcd, la source de v√©rit√© pour la configuration de Kubernetes.  Et ici, Istio fait sa magie. </p><br><h3 id="modificiruyuschie-vebhuki-dopuska">  Modification des webhooks d'admission </h3><br><p> Lorsqu'un sous est cr√©√© (via <code>kubectl</code> ou <code>Deployment</code> ), il passe par ce cycle de vie, et les webhooks modificateurs d'acc√®s le changent avant de le diffuser dans le grand monde. </p><br><p>  Lors de l'installation d'Istio, l'istio-sidecar-injector est ajout√© comme ressource de configuration pour modifier les webhooks: </p><br><pre> <code class="plaintext hljs">$ kubectl get mutatingwebhookconfiguration NAME AGE istio-sidecar-injector 87d</code> </pre> <br><p>  Et la configuration: </p><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: labels: app: istio-sidecar-injector chart: sidecarInjectorWebhook-1.0.4 heritage: Tiller name: istio-sidecar-injector webhooks: - clientConfig: caBundle: redacted service: name: istio-sidecar-injector namespace: istio-system path: /inject failurePolicy: Fail name: sidecar-injector.istio.io namespaceSelector: matchLabels: istio-injection: enabled rules: - apiGroups: - "" apiVersions: - v1 operations: - CREATE resources: - pods</code> </pre> <br><p>  Il est indiqu√© ici que Kubernetes doit envoyer tous les √©v√©nements de cr√©ation de foyer au service <code>istio-sidecar-injector</code> <code>istio-system</code> dans l'espace de noms <code>istio-system</code> si l'espace de noms a <code>istio-injection=enabled</code> .  L'injecteur comprend deux conteneurs suppl√©mentaires dans PodSpec: un temporaire pour d√©finir des r√®gles de proxy et un pour se procurer lui-m√™me.  L'injecteur side-car ins√®re ces conteneurs selon le mod√®le de la carte de configuration <code>istio-sidecar-injector</code> .  Ce processus est √©galement appel√© side-caring. </p><br><h3 id="sidecar-pody">  Dosettes Sidecar </h3><br><p>  Les side-cars sont les astuces de notre magicien Istio.  Istio ex√©cute tout si habilement que de l'ext√©rieur, c'est juste magique, si vous ne connaissez pas les d√©tails.  Et il est utile de les conna√Ætre si vous devez soudainement d√©boguer des requ√™tes r√©seau. </p><br><h3 id="init--i-proksi-konteynery">  Conteneurs init et proxy </h3><br><p>  Kubernetes dispose de conteneurs init initiaux temporaires qui peuvent √™tre ex√©cut√©s avant les principaux.  Ils mettent en commun des ressources, migrent des bases de donn√©es ou, comme c'est le cas avec Istio, configurent des r√®gles de r√©seau. </p><br><p>  Istio utilise Envoy pour proxy toutes les demandes de soumissions le long des itin√©raires souhait√©s.  Pour ce faire, Istio cr√©e des r√®gles <code>iptables</code> , et ils envoient le trafic entrant et sortant directement √† Envoy, et il projette soigneusement le trafic vers sa destination.  Le trafic fait un petit d√©tour, mais vous avez distribu√© le tra√ßage, les m√©triques de requ√™te et l'application des r√®gles.  Dans ce fichier, √† partir du r√©f√©rentiel Istio, vous <a href="">pouvez voir</a> comment Istio cr√©e des r√®gles iptables. </p><br><p>  <a href="">@jimmysongio a</a> dessin√© un excellent diagramme de connexion entre les r√®gles iptables et le proxy Envoy: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/yl/3m/yc/yl3myca7qv4esodpj8a7iwsp6bc.jpeg"></a> <br>  <em>Envoy - Envoy Traffic</em> </p><br><p>  Envoy re√ßoit tout le trafic entrant et sortant, donc tout le trafic se d√©place g√©n√©ralement √† l'int√©rieur d'Envoy, comme dans le diagramme.  Le proxy Istio est un autre conteneur qui est ajout√© √† tous les pods qui sont modifi√©s par l'injecteur side-car Istio.  Dans ce conteneur, le processus Envoy d√©marre, qui re√ßoit tout le trafic du foyer (√† quelques exceptions pr√®s, comme le trafic de votre cluster Kubernetes). </p><br><p>  Le processus Envoy d√©couvre toutes les routes via l'API Envoy v2, qui impl√©mente Istio. </p><br><h3 id="envoy-i-pilot">  Envoy√© et pilote </h3><br><p>  Envoy lui-m√™me n'a aucune logique pour d√©tecter les pods et les services dans un cluster.  Il s'agit d'un plan de donn√©es et il a besoin d'un plan de contr√¥le pour guider.  Le param√®tre de configuration Envoy demande √† l'h√¥te ou au port de service de recevoir cette configuration via l'API gRPC.  Istio, √† travers son service Pilot, r√©pond aux exigences de l'API gRPC.  Envoy se connecte √† cette API sur la base d'une configuration de side-car impl√©ment√©e via un webhook de modification.  L'API poss√®de toutes les r√®gles de trafic qu'Envoy doit d√©couvrir et acheminer pour le cluster.  Il s'agit du maillage de service. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/lr/kn/bz/lrknbzkkjqescnkyh6k1voy_nyk.png"></a> <br>  <em>√âchange de donn√©es "sous le &lt;-&gt; pilote"</em> </p><br><p>  Pilot se connecte au cluster Kubernetes, lit l'√©tat du cluster et attend les mises √† jour.  Il surveille les foyers, les services et les points d'extr√©mit√© dans le cluster Kubernetes, pour ensuite donner la bonne configuration √† tous les side-cars Envoy connect√©s au Pilot.  C'est le pont entre Kubernetes et Envoy. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/fg/no/hj/fgnohjdngxbyn8kj5u_udcvl6x0.png"></a> <br>  <em>Du pilote au Kubernetes</em> </p><br><p>  Lorsque des pods, des services ou des points de terminaison sont cr√©√©s ou mis √† jour dans Kubernetes, Pilot en prend connaissance et envoie la configuration n√©cessaire √† toutes les instances Envoy connect√©es. </p><br><h3 id="kakaya-konfiguraciya-otpravlyaetsya">  Quelle configuration est envoy√©e? </h3><br><p>  Quelle configuration l'Envoy obtient-il de l'Istio Pilot? </p><br><p>  Par d√©faut, Kubernetes r√©sout vos probl√®mes de r√©seau avec un service (service) qui g√®re les <code>endpoint</code> .  La liste des noeuds finaux peut √™tre ouverte avec la commande: </p><br><pre> <code class="plaintext hljs">kubectl get endpoints</code> </pre> <br><p>  Il s'agit d'une liste de tous les IP et ports du cluster et de leurs adresses (il s'agit g√©n√©ralement de pods cr√©√©s √† partir d'un d√©ploiement).  Istio est important √† conna√Ætre pour configurer et envoyer des donn√©es d'itin√©raire √† Envoy. </p><br><h3 id="servisy-proslushivateli-i-marshruty">  Services, auditeurs et itin√©raires </h3><br><p>  Lorsque vous cr√©ez un service dans un cluster Kubernetes, vous incluez des raccourcis par lesquels tous les pods appropri√©s seront s√©lectionn√©s.  Lorsque vous envoyez du trafic vers l'IP du service, Kubernetes s√©lectionne le trafic pour ce trafic.  Par exemple, la commande </p><br><pre> <code class="plaintext hljs">curl my-service.default.svc.cluster.local:3000</code> </pre> <br><p>  Tout d'abord, il trouvera l'IP virtuelle affect√©e au <code>my-service</code> dans l'espace de noms <code>default</code> , et cette IP transmettra le trafic √† un sous-correspondant √† l'√©tiquette de service. </p><br><p>  Istio et Envoy modifient l√©g√®rement cette logique.  Istio configure Envoy en fonction des services et des points de terminaison du cluster Kubernetes et utilise les fonctions de routage intelligent et d'√©quilibrage de charge d'Envoy pour contourner le service Kubernetes.  Au lieu de mandater une adresse IP √† la fois, Envoy se connecte directement au foyer IP.  <strong>Pour ce faire, Istio mappe la configuration Kubernetes √† la configuration Envoy</strong> . </p><br><p>  Les termes Kubernetes, Istio et Envoy sont l√©g√®rement diff√©rents, et on ne sait pas imm√©diatement ce qu'ils mangent. </p><br><h3 id="servisy">  Les services </h3><br><p>  Un service dans Kubernetes est mapp√© √† un <strong>cluster</strong> dans Envoy.  Le cluster Envoy contient une liste de <strong>points</strong> de <strong>terminaison</strong> , c'est-√†-dire l'IP (ou les noms d'h√¥te) des instances de traitement des demandes.  Pour afficher la liste des clusters configur√©s dans le sidecar-pod <code>istioctl proxy-config cluster &lt; &gt;</code> , ex√©cutez le <code>istioctl proxy-config cluster &lt; &gt;</code> .  Cette commande montre l'√©tat actuel des choses en termes de foyer.  Voici un exemple de l'un de nos environnements: </p><br><pre> <code class="plaintext hljs">$ istioctl proxy-config cluster taxparams-6777cf899c-wwhr7 -n applications SERVICE FQDN PORT SUBSET DIRECTION TYPE BlackHoleCluster - - - STATIC accounts-grpc-gw.applications.svc.cluster.local 80 - outbound EDS accounts-grpc-public.applications.svc.cluster.local 50051 - outbound EDS addressvalidator.applications.svc.cluster.local 50051 - outbound EDS</code> </pre> <br><p>  Tous les m√™mes services sont dans cet espace de noms: </p><br><pre> <code class="plaintext hljs">$ kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) accounts-grpc-gw ClusterIP 10.3.0.91 &lt;none&gt; 80/TCP accounts-grpc-public ClusterIP 10.3.0.202 &lt;none&gt; 50051/TCP addressvalidator ClusterIP 10.3.0.56 &lt;none&gt; 50051/TCP</code> </pre> <br><p>  Comment Istio sait-il quel protocole utilise le service?  Configure les protocoles pour les manifestes de service par le champ de <code>name</code> dans l'entr√©e de port. </p><br><pre> <code class="plaintext hljs">$ kubectl get service accounts-grpc-public -o yaml apiVersion: v1 kind: Service metadata: name: accounts-grpc-public spec: ports: - name: grpc port: 50051 protocol: TCP targetPort: 50051</code> </pre> <br><p>  S'il y a <code>grpc</code> ou le pr√©fixe <code>grpc-</code> , Istio configurera le protocole HTTP2 pour le service.  Nous avons appris par une exp√©rience am√®re comment Istio utilise le nom du port lorsque les configurations de proxy sont corrompues car elles ne sp√©cifient pas les pr√©fixes http ou grpc ... </p><br><p>  Si vous utilisez kubectl et la page de redirection de port d'administration dans Envoy, vous pouvez voir que les points de terminaison account-grpc-public sont impl√©ment√©s par Pilot en tant que cluster dans Envoy avec le protocole HTTP2.  Cela confirme nos hypoth√®ses: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward otherpod-dc56885ff-dqc6t 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... - cluster: circuit_breakers: thresholds: - {} connect_timeout: 1s eds_cluster_config: eds_config: ads: {} service_name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local http2_protocol_options: max_concurrent_streams: 1073741824 name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local type: EDS ...</code> </pre> <br><p>  Le port 15000 est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page d'administration d'Envoy</a> , disponible sur chaque side-car. </p><br><h3 id="proslushivateli">  Auditeurs </h3><br><p>  Les auditeurs reconnaissent les points de terminaison Kubernetes pour transmettre le trafic aux foyers.  Le service de v√©rification d'adresse a un point final ici: </p><br><pre> <code class="plaintext hljs">$ kubectl get ep addressvalidator -o yaml apiVersion: v1 kind: Endpoints metadata: name: addressvalidator subsets: - addresses: - ip: 10.2.26.243 nodeName: ip-10-205-35-230.ec2.internal targetRef: kind: Pod name: addressvalidator-64885ccb76-87l4d namespace: applications ports: - name: grpc port: 50051 protocol: TCP</code> </pre> <br><p>  Par cons√©quent, le foyer de v√©rification d'adresse a un √©couteur sur le port 50051: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward addressvalidator-64885ccb76-87l4d 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... dynamic_active_listeners: - version_info: 2019-01-13T18:39:43Z/651 listener: name: 10.2.26.243_50051 address: socket_address: address: 10.2.26.243 port_value: 50051 filter_chains: - filter_chain_match: transport_protocol: raw_buffer ...</code> </pre> <br><h3 id="marshruty">  Itin√©raires </h3><br><p>  Dans Istio, au lieu de l'objet Kubernetes Ingress standard, une ressource personnalis√©e plus abstraite et efficace est <code>VirtualService</code> - <code>VirtualService</code> .  VirtualService mappe les routes vers les clusters en amont en les liant √† la passerelle.  Voici comment utiliser Kubernetes Ingress avec un contr√¥leur Ingress. </p><br><p>  Chez Namely, nous utilisons la passerelle Istio Ingress-Gateway pour tout le trafic interne GRPC: </p><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: grpc-gateway spec: selector: istio: ingressgateway servers: - hosts: - '*' port: name: http2 number: 80 protocol: HTTP2 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: grpc-gateway spec: gateways: - grpc-gateway hosts: - '*' http: - match: - uri: prefix: /namely.address_validator.AddressValidator retries: attempts: 3 perTryTimeout: 2s route: - destination: host: addressvalidator port: number: 50051</code> </pre> <br><p>  √Ä premi√®re vue, vous ne comprendrez rien dans l'exemple.  Il n'est pas visible ici, mais le d√©ploiement Istio-IngressGateway enregistre les points de terminaison n√©cessaires en fonction du <code>istio: ingressgateway</code> .  Dans cet exemple, IngressGateway achemine le trafic pour tous les domaines sur le port 80 via HTTP2.  VirtualService impl√©mente des routes pour cette passerelle, correspond au pr√©fixe <code>/namely.address_validator.AddressValidator</code> et transmet l' <code>addressvalidator</code> via le port 50051 au service en amont <code>addressvalidator</code> une r√®gle de nouvelle tentative en deux secondes. </p><br><p>  Si nous redirigeons le port pod d'Istio-IngressGateway et voyons la configuration d'Envoy, nous verrons ce que fait VirtualService: </p><br><pre> <code class="plaintext hljs">$ kubectl -n istio-system port-forward istio-ingressgateway-7477597868-rldb5 15000 ... - match: prefix: /namely.address_validator.AddressValidator route: cluster: outbound|50051||addressvalidator.applications.svc.cluster.local timeout: 0s retry_policy: retry_on: 5xx,connect-failure,refused-stream num_retries: 3 per_try_timeout: 2s max_grpc_timeout: 0s decorator: operation: addressvalidator.applications.svc.cluster.local:50051/namely.address_validator.AddressValidator* ...</code> </pre> <br><h3 id="chto-my-guglili-kopayas-v-istio">  Ce que nous avons googl√© en creusant √† Istio </h3><br><p>  <strong>L'erreur 503 ou 404 se produit</strong> </p><br><p>  Les raisons sont diff√©rentes, mais g√©n√©ralement ce sont: </p><br><ul><li>  Les applications Sidecar ne peuvent pas contacter Pilot (v√©rifiez que Pilot est en cours d'ex√©cution). </li><li>  Le manifeste du service Kubernetes a un protocole non valide. </li><li>  La configuration VirtualService / Envoy √©crit la route vers le mauvais cluster en amont.  Commencez avec le service Edge, l√† o√π vous attendez du trafic entrant, et examinez les journaux Envoy.  Ou utilisez quelque chose comme Jaeger pour trouver des erreurs. </li></ul><br><p>  <strong>Que signifie NR / UH / UF dans les journaux de proxy Istio?</strong> </p><br><ul><li>  NR - Pas de route. </li><li>  UH - Upstream Unhealthy (inoperable upstream). </li><li>  UF - Upstream Failure (d√©faillance en amont). </li></ul><br><p>  En savoir plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le site Web d'Envoy</a> . </p><br><p>  <strong>Concernant la haute disponibilit√© avec Istio</strong> </p><br><ul><li>  Ajoutez NodeAffinity aux composants Istio pour r√©partir uniform√©ment les foyers sur diff√©rentes zones de disponibilit√© et augmenter le nombre minimum de r√©pliques. </li><li>  Lancez la nouvelle version de Kubernetes avec la fonction de mise √† l'√©chelle horizontale des pods.  Les foyers les plus importants √©volueront en fonction de la charge. </li></ul><br><p>  <strong>Pourquoi la cronjob ne se termine-t-elle pas?</strong> </p><br><p>  Une fois la charge de travail principale termin√©e, le conteneur de sidecar continue de fonctionner.  Pour contourner le probl√®me, d√©sactivez sidecar dans cronjobs en ajoutant l'annotation <code>sidecar.istio.io/inject: ‚Äúfalse‚Äù</code> √† PodSpec. </p><br><p>  <strong>Comment installer Istio?</strong> </p><br><p>  Nous utilisons Spinnaker pour les d√©ploiements, mais nous prenons g√©n√©ralement les derniers graphiques Helm, les <code>helm template -f values.yml</code> , utilisons le <code>helm template -f values.yml</code> et <code>helm template -f values.yml</code> fichiers sur Github pour voir les changements avant de les appliquer via <code>kubectl apply -f -</code> .  Ceci afin de ne pas modifier accidentellement le CRD ou l'API dans diff√©rentes versions. </p><br><p>  Merci √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bobby Tables</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Michael Hamrah d'</a> avoir aid√© √† √©crire ce message. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441616/">https://habr.com/ru/post/fr441616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441600/index.html">Interface utilisateur faible, programmeur faible</a></li>
<li><a href="../fr441602/index.html">Pourquoi une voiture automatique classique est impossible et n'a aucune perspective commerciale</a></li>
<li><a href="../fr441604/index.html">Les syst√®mes nationaux de surveillance en Chine: une source non seulement de donn√©es, mais aussi un revenu stable</a></li>
<li><a href="../fr441606/index.html">Solutions presque fiables</a></li>
<li><a href="../fr441608/index.html">Dualit√© - un moteur simple et rapide pour igrostroy sous Windows (Ext.)</a></li>
<li><a href="../fr441618/index.html">Cr√©ation de la barre de navigation inf√©rieure sur Kotlin avec Anko</a></li>
<li><a href="../fr441620/index.html">The Prometheus Project: Searching for Fire Using AI</a></li>
<li><a href="../fr441632/index.html">1 mars - Teamlead Meetup: √©valuation et motivation des employ√©s</a></li>
<li><a href="../fr441634/index.html">Y a-t-il de la vie sous Windows 98, deuxi√®me partie - sur les logiciels</a></li>
<li><a href="../fr441636/index.html">Linux Foundation annonce une plate-forme ELISA open source pour le d√©veloppement de syst√®mes automatis√©s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>