<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ ğŸ‘‰ ğŸ”¢ Wenn das Projekt "Theater" ist, verwenden Sie Schauspieler ... ğŸ¤°ğŸ¾ ğŸ‰‘ ğŸ‘¨ğŸ»â€ğŸš€</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird Ã¼ber die Erfahrungen mit der Verwendung des Schauspieleransatzes in einem interessanten Projekt eines automatisierten Steuerung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wenn das Projekt "Theater" ist, verwenden Sie Schauspieler ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438196/"><p>  In diesem Artikel wird Ã¼ber die Erfahrungen mit der Verwendung des Schauspieleransatzes in einem interessanten Projekt eines automatisierten Steuerungssystems fÃ¼r ein Theater berichtet.  Dies ist genau der Eindruck der Nutzung, nichts weiter. </p><a name="habracut"></a><br><p>  Vor kurzem konnte ich an einer sehr interessanten Aufgabe teilnehmen - der Modernisierung, aber tatsÃ¤chlich - der Entwicklung eines neuen automatisierten Steuerungssystems zum Heben von Gestellen fÃ¼r eines der Theater. </p><br><p>  Ein modernes Theater (wenn es groÃŸ ist) ist eine ziemlich komplexe Organisation.  Daran sind viele Menschen, GerÃ¤te und verschiedene Systeme beteiligt.  Eines dieser Systeme ist das Steuerungssystem zum â€Anheben und Absenkenâ€œ der Szenerie auf der BÃ¼hne.  Moderne AuffÃ¼hrungen und immer mehr Opern und Ballette werden von Jahr zu Jahr mit technischen Mitteln gesÃ¤ttigt.  Es verwendet viele komplexe Landschaften und deren Bewegung wÃ¤hrend der Aktion.  Die Szenerie wird aktiv in RegieplÃ¤nen verwendet, um die Bedeutung des Geschehens zu erweitern und sogar â€Ihre eigene Nebenrolle zu spielenâ€œ).  Im Allgemeinen war es sehr interessant, das Backstage-Leben des Theaters kennenzulernen und herauszufinden, was dort wÃ¤hrend der AuffÃ¼hrungen passiert.  SchlieÃŸlich sehen gewÃ¶hnliche Zuschauer nur, was auf der BÃ¼hne passiert. </p><br><p>  Aber dieser Artikel ist immer noch technisch und ich wollte die Erfahrungen mit der Verwendung des Akteuransatzes zur Implementierung des Managements teilen.  Und teilen Sie auch die Erfahrung mit einem der wenigen C ++ - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Actor</a> -Frameworks - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sobjectizer</a> . </p><br><p>  Warum genau er?  Wir haben ihn schon lange beobachtet.  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> Ã¼ber ein Habr, es hat eine ausgezeichnete detaillierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> mit Beispielen.  Das Projekt ist ziemlich ausgereift.  Ein kurzer Blick auf die Beispiele zeigte, dass die Entwickler mit â€vertrautenâ€œ Konzepten (ZustÃ¤nde, Zeitgeber, Ereignisse) arbeiten, d. H.  Es wurden keine groÃŸen Probleme mit dem Verstehen und Beherrschen fÃ¼r die Verwendung in unserem Projekt erwartet.  Und ja, wichtig ist, dass die Entwickler angemessen und freundlich sind und mit Rat und Tat zur Seite stehen <del>  (auf Russisch) </del>  .  Also beschlossen wir es zu versuchen ... </p><br><h2 id="a-chto-delaem">  Was machen wir </h2><br><p>  Wie ist unser â€Kontrollobjektâ€œ?  Das System der Shtanketovy-HebebÃ¼hnen - dies sind 62 Shankets (Metallrohre) Ã¼ber die gesamte Breite der BÃ¼hne, die Ã¼ber dieser Szene hÃ¤ngen, ungefÃ¤hr alle 30 - 40 cm vom Rand der BÃ¼hne in der Tiefe.  Die Schenkel selbst sind an Seilen aufgehÃ¤ngt und kÃ¶nnen bis zur BÃ¼hne auf- oder absteigen (vertikale Bewegung).  In jeder AuffÃ¼hrung (oder Oper oder Ballett) wird ein Teil der Strophen zur Dekoration verwendet.  Die Szenerie wird an sie gehÃ¤ngt und wÃ¤hrend der Aktion verschoben (sofern das Skript dies erfordert).  Die Bewegung selbst wird auf Befehl der Bediener (sie haben spezielle Bedienfelder) mit dem System â€Motor - Kabel - Gegengewichtâ€œ ausgefÃ¼hrt (ungefÃ¤hr so â€‹â€‹wie AufzÃ¼ge in HÃ¤usern).  Die Motoren befinden sich an den BÃ¼hnenrÃ¤ndern (auf mehreren Ebenen), so dass sie fÃ¼r den Betrachter nicht sichtbar sind.  Alle Motoren sind in 8 Gruppen unterteilt und jede Gruppe verfÃ¼gt Ã¼ber drei Frequenzumrichter (IF).  In jeder Gruppe kÃ¶nnen drei Motoren gleichzeitig aktiviert werden, die jeweils an einen eigenen Umrichter angeschlossen sind.  Insgesamt haben wir ein System von 62 Motoren und 24 Umrichtern, die wir steuern mÃ¼ssen. </p><br><p>  Unsere Aufgabe war es, eine BedienoberflÃ¤che fÃ¼r die Verwaltung dieser Wirtschaft zu entwickeln und Verwaltungsalgorithmen zu implementieren.  Das System enthÃ¤lt drei Kontrollposten.  Zwei Kontrollpfosten befinden sich direkt Ã¼ber der BÃ¼hne, und ein Pfosten befindet sich im Maschinenraum (wo sich die SchaltschrÃ¤nke befinden) und dient zur Ãœberwachung der Arbeit eines diensthabenden Elektrikers.  In den SchaltschrÃ¤nken befinden sich Steuerungen, die Befehle ausfÃ¼hren, die PWM steuern, die Motoren mit Strom versorgen und die Position der SchÃ¤fte verfolgen.  Auf den oberen beiden Fernbedienungen befinden sich Monitore, eine Systemeinheit, in der sich Steueralgorithmen und Trackball als â€Mausâ€œ drehen.  Zwischen den Bedienfeldern wird ein Ethernet-Netzwerk verwendet.  Jeder Schaltschrank verfÃ¼gt Ã¼ber einen RS485-Kanal (d. H. 8 KanÃ¤le) von jedem der beiden Bedienfelder.  Die Verwaltung kann gleichzeitig von beiden Fernbedienungen (die sich Ã¼ber der BÃ¼hne befinden) durchgefÃ¼hrt werden. Gleichzeitig wird jedoch nur eine der Fernbedienungen (vom Bediener als Hauptbetreiber bezeichnet) mit den SchrÃ¤nken ausgetauscht. Die zweite Konsole wird derzeit als Backup betrachtet und der Austausch ist deaktiviert. </p><br><h2 id="prichyom-tut-aktory">  Und hier die Schauspieler </h2><br><p>  Aus Sicht der Algorithmen baut das gesamte System auf Ereignissen auf.  Dies sind entweder einige Ã„nderungen an den Sensoren oder die Aktionen des Bedieners oder der Beginn einer bestimmten Zeit (Timer).  Und solche Algorithmen sind sehr gut im System der Akteure platziert, die eingehende Ereignisse verarbeiten, eine Art Antwort bilden und dies alles abhÃ¤ngig von ihrem Zustand.  Im Sobjectizer sind alle diese Mechanismen sofort einsatzbereit.  Die Hauptprinzipien, auf denen ein solches System basiert, kÃ¶nnen zugeschrieben werden: Die Interaktion zwischen Akteuren erfolgt durch Nachrichten, Akteure kÃ¶nnen ZustÃ¤nde haben und sich zwischen ihnen bewegen, in jedem Zustand verarbeitet der Akteur nur die Nachrichten, die ihn im Moment interessieren.  Interessanterweise unterscheidet sich die Arbeit mit Schauspielern in einem Sobjectizer konzeptionell von der Arbeit mit Workflows.  Das heiÃŸt,  Sie kÃ¶nnen die Akteure beschreiben, die Sie benÃ¶tigen, ihre Logik erkennen, ihre Interaktion durch Nachrichten realisieren.  LÃ¶sen Sie dann aber separat das Problem der Zuweisung von Threads (Ressourcen) fÃ¼r ihre Arbeit.  Dies wird durch die sogenannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Dispatcher"</a> sichergestellt, die fÃ¼r eine bestimmte Politik der Arbeit mit Threads verantwortlich sind.  Beispielsweise gibt es einen Dispatcher, der jedem Akteur einen separaten Thread zuweist, mit dem gearbeitet werden soll. Es gibt einen Dispatcher, der einen Pool von Threads bereitstellt (d. H. Es kÃ¶nnen mehr Akteure als Threads vorhanden sein), mit der MÃ¶glichkeit, die maximale Anzahl von Threads festzulegen. Es gibt einen Dispatcher, der einen Thread fÃ¼r alle zuweist.  Das Vorhandensein von Dispatchern bietet einen sehr flexiblen Mechanismus zum Einrichten eines Akteursystems, das Ihren Anforderungen entspricht.  Sie kÃ¶nnen Gruppen von Akteuren kombinieren, um mit einem der Dispatcher zu arbeiten, wÃ¤hrend Sie einen Dispatcher-Typ in einen anderen Ã¤ndern. Dies Ã¤ndert im Wesentlichen eine Codezeile.  Laut den Autoren des Frameworks ist es auch nicht schwierig, einen eigenen Dispatcher zu schreiben.  Dies wurde in unserem Projekt nicht benÃ¶tigt, da sich alles, was wir brauchten, bereits im Sobjectizer befand. </p><br><p>  Ein weiteres interessantes Merkmal ist das Vorhandensein des Konzepts der â€Zusammenarbeitâ€œ von Akteuren.  Kooperation ist eine Gruppe von Akteuren, die entweder alle existieren oder alle zerstÃ¶rt (oder nicht gestartet) werden kÃ¶nnen, wenn mindestens ein Akteur in der Kooperation nicht in der Lage war, die Arbeit aufzunehmen oder abzuschlieÃŸen.  Ich habe keine Angst davor, eine solche Analogie zu geben ( <del>  obwohl es aus einer anderen "Oper" stammt </del>  ) dass das Konzept der "Kooperation" wie das Konzept der "Herde" in den jetzt modischen Kubernetes ist, es scheint nur im Sobjectizer, es ist frÃ¼her entstanden ... </p><br><p>  Zum Zeitpunkt der Erstellung ist jeder Akteur in die Zusammenarbeit einbezogen (die Zusammenarbeit kann aus einem Akteur bestehen), wird an den einen oder anderen Disponenten gebunden und beginnt zu arbeiten.  Gleichzeitig kÃ¶nnen Akteure (und Kooperationen) (leicht) in groÃŸer Zahl dynamisch erstellt werden, und wie die Entwickler versprechen, ist dies nicht teuer.  Alle Akteure tauschen sich Ã¼ber " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mailboxen</a> " (mbox) aus.  Dies ist auch ein interessantes und starkes Konzept im Sobjectizer.  Es bietet einen sehr flexiblen Mechanismus fÃ¼r die Verarbeitung eingehender Nachrichten.  Erstens kann sich mehr als ein EmpfÃ¤nger hinter einer Box verstecken.  Es ist wirklich sehr praktisch.  Beispielsweise wird eine Box erstellt, in der Ereignisse von externen Sensoren empfangen werden und jeder Akteur Ereignisse abonniert, die fÃ¼r ihn von Interesse sind.  Dies bietet einen Betriebsstil "VerÃ¶ffentlichen / Abonnieren".  Zweitens haben die Entwickler die MÃ¶glichkeit geboten, relativ einfach eine eigene Implementierung von PostfÃ¤chern zu erstellen, mit denen eingehende Nachrichten vorverarbeitet werden kÃ¶nnen (z. B. sie irgendwie filtern oder auf besondere Weise an die Verbraucher verteilen kÃ¶nnen).  DarÃ¼ber hinaus verfÃ¼gt jeder Akteur Ã¼ber ein eigenes Postfach und kann beispielsweise sogar einen â€Linkâ€œ in Nachrichten an andere Akteure senden, damit diese eine Art Benachrichtigung als Antwort senden kÃ¶nnen. </p><br><p>  In unserem Projekt wurden alle Steuerobjekte in 8 Gruppen (entsprechend der Anzahl der SchaltschrÃ¤nke) unterteilt, von denen jede drei Arbeiter hatte, um die UnabhÃ¤ngigkeit der Motorgruppen untereinander sowie den â€asynchronenâ€œ Betrieb der Motoren innerhalb der Gruppe sicherzustellen Durchfluss (da nicht mehr als drei Motoren gleichzeitig in einer Gruppe betrieben werden kÃ¶nnen). <br>  Es sollte auch gesagt werden, dass der Sobjectizer (in der aktuellen Version 5.5) keine Interprozess- und Netzwerkinteraktionsmechanismen enthÃ¤lt und diesen Teil den Entwicklern Ã¼berlÃ¤sst.  Die Autoren haben dies ganz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bewusst</a> getan, damit das Framework â€einfacherâ€œ ist.  DarÃ¼ber hinaus existierten die Mechanismen der Netzwerkinteraktion â€einmalâ€œ in frÃ¼heren Versionen, wurden jedoch ausgeschlossen.  Dies verursacht jedoch keine Unannehmlichkeiten, da die Netzwerkinteraktion in der Tat sehr stark von den zu lÃ¶senden Aufgaben, den verwendeten Austauschprotokollen usw. abhÃ¤ngt.  Hier kann eine universelle Implementierung nicht in allen FÃ¤llen optimal sein. </p><br><p>  In unserem Fall haben wir fÃ¼r die Netzwerk- und Interprozesskommunikation eine unserer langjÃ¤hrigen Entwicklungen verwendet - die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libuniset2-</a> Bibliothek.  Infolgedessen sieht die Architektur unseres Systems ungefÃ¤hr so â€‹â€‹aus: </p><br><ul><li>  libuniset bietet Netzwerk- und Interprozesskommunikation (basierend auf Sensoren) </li><li>  Sobjectizer bietet die Schaffung eines Systems von Akteuren, die miteinander (im selben Adressraum) interagieren und Steueralgorithmen implementieren. </li></ul><br><p>  Ich mÃ¶chte Sie daran erinnern, dass wir 62 Motoren haben.  Jeder Motor kann an den Umrichter angeschlossen werden, dem entsprechenden StÃ¤nder kann die Koordinate zugewiesen werden, zu der Sie ankommen mÃ¼ssen, und die Geschwindigkeit, mit der Sie sich bewegen mÃ¼ssen.  DarÃ¼ber hinaus hat der Motor die folgenden Bedingungen: </p><br><ul><li>  bereit zu gehen </li><li>  verbunden </li><li>  Laufen (Spinnen) </li><li>  Unfall </li><li>  Verbindung (Ãœbergangszustand) </li><li>  Herunterfahren (Ãœbergangszustand) </li></ul><br><p>  Infolgedessen wird jede â€Engineâ€œ im System durch einen Akteur dargestellt, der die Logik von ÃœbergÃ¤ngen zwischen ZustÃ¤nden implementiert, Ereignisse von Sensoren verarbeitet und Steuerbefehle ausgibt.  In sobjectizer kÃ¶nnen Schauspieler einfach erstellt werden. Erben Sie einfach Ihre Klasse von der Basisklasse so_5 :: agent_t.  Gleichzeitig muss der Konstruktor den sogenannten :: so_5 :: context_t-Kontext als erstes Argument verwenden, die verbleibenden Argumente werden durch die Notwendigkeit des Entwicklers bestimmt. </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); ... }</code> </pre> <br><p>  Weil  Dieser Artikel ist nicht lehrreich, daher werde ich hier nicht die detaillierten Texte der Beschreibungen von Klassen oder Methoden bereitstellen.  Der Artikel wollte nur zeigen, wie einfach es ist (in wenigen Zeilen), mit Hilfe von sobjectizer all dies zu implementieren.  Ich mÃ¶chte Sie daran erinnern, dass das Projekt eine ausgezeichnete detaillierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> mit einer Reihe verschiedener Beispiele enthÃ¤lt. </p><br><h2 id="a-chto-za-sostoyaniya-u-etih-aktorov-o-chyom-rech">  Und wie sind die â€ZustÃ¤ndeâ€œ dieser Akteure?  WorÃ¼ber sprichst du? </h2><br><p>  Die Verwendung von ZustÃ¤nden und ÃœbergÃ¤ngen zwischen ihnen fÃ¼r ACS ist im Allgemeinen ein natives Thema.  Dieses â€Konzeptâ€œ passt sehr gut zum Event-Handling.  In sobjectizer wird dieses Konzept auf API-Ebene unterstÃ¼tzt.  In einer Schauspielerklasse lassen sich ZustÃ¤nde ziemlich leicht deklarieren </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drive_A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Drive_A( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, ... ); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Drive_A(); <span class="hljs-comment"><span class="hljs-comment">//  state_t st_base {this}; state_t st_disabled{ initial_substate_of{st_base}, "disabled" }; state_t st_preinit{ substate_of{st_base}, "preinit" }; state_t st_off{ substate_of{st_base}, "off" }; state_t st_connecting{ substate_of{st_base}, "connecting" }; state_t st_disconnecting{ substate_of{st_base}, "disconnecting" }; state_t st_connected{ substate_of{st_base}, "connected" }; ... }</span></span></code> </pre><br><p>  und auÃŸerdem bestimmt der Entwickler fÃ¼r jeden Zustand die erforderlichen Handler.  Oft sind einige Aktionen erforderlich, wenn Sie in einen Status eintreten oder ihn verlassen.  Dies ist auch im Sobjectizer vorgesehen. Ebenso einfach definieren Sie Ihre Handler fÃ¼r diese Ereignisse (â€Statuseintragâ€œ, â€Statusausgangâ€œ). <del>  Es wird davon ausgegangen, dass die Entwickler in der Vergangenheit Ã¼ber umfangreiche Erfahrungen mit ACS-shny verfÃ¼gen </del>  ... </p><br><h3 id="obrabotchiki-sobytiy">  Ereignishandler </h3><br><p>  Event-Handler: Hier wird die Logik Ihrer Anwendung implementiert.  Wie oben erwÃ¤hnt, wird ein Abonnement fÃ¼r ein bestimmtes Postfach und fÃ¼r einen bestimmten Status des Akteurs abgeschlossen.  Wenn ein Akteur keine explizit im Code deklarierten ZustÃ¤nde hat, befindet er sich implizit im Sonderzustand "default_state".  In verschiedenen ZustÃ¤nden kÃ¶nnen Sie verschiedene Handler fÃ¼r dieselben Ereignisse definieren.  Wenn Sie den Handler eines Ereignisses in diesem Postfach nicht angegeben haben, wird es einfach ignoriert (d. H. Es ist fÃ¼r den Akteur einfach nicht vorhanden). </p><br><p>  Die Syntax zum Definieren von Handlern ist sehr einfach.  Es reicht aus, Ihre Funktion anzuzeigen.  Es sind keine Typen oder Vorlagenargumente erforderlich.  Alles wird automatisch aus der Funktionsdefinition abgeleitet.  Zum Beispiel: </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_base) .event( &amp;Drive_A::on_get_info ) .event( &amp;Drive_A::on_control ) .event( &amp;Drive_A::off_control );</code> </pre> <br><p>  Hier ist ein Beispiel fÃ¼r das Abonnieren von Ereignissen in einem bestimmten Feld fÃ¼r den Status st_base.  Interessanterweise ist in diesem Beispiel st_base der Basiszustand fÃ¼r andere ZustÃ¤nde, und dementsprechend gilt dieses Abonnement fÃ¼r alle ZustÃ¤nde, die von st_base "geerbt" werden.  Mit diesem Ansatz kÃ¶nnen Sie "Kopieren und EinfÃ¼gen" entfernen, um dieselben Handler fÃ¼r verschiedene Status zu ermitteln.  Gleichzeitig kÃ¶nnen Sie in einem bestimmten Status entweder den angegebenen Handler Ã¼berschreiben oder ihn "deaktivieren" (unterdrÃ¼cken). </p><br><p>  Es gibt eine andere MÃ¶glichkeit, Handler zu definieren.  Dies ist eine direkte Definition von Lambda-Funktionen.  Dies ist eine sehr bequeme Methode, da Handler hÃ¤ufig kurze Funktionen in einigen Aktionen sind, etwas an jemanden senden oder den Status wechseln. </p><br><pre> <code class="cpp hljs">so_subscribe(drv-&gt;so_mbox()) .in(st_disconnecting) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_disconnected_t</span></span>&amp; m) { ... st_off.activate(); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&amp; m ) { ... st_protection.activate(); });</code> </pre> <br><p>  Diese Syntax erscheint zunÃ¤chst kompliziert.  Aber in nur wenigen Tagen aktiver Entwicklung gewÃ¶hnt man sich daran und fÃ¤ngt sogar an, es zu mÃ¶gen.  Weil die gesamte Logik der Arbeit des Schauspielers in dem einen oder anderen Zustand in einen ziemlich kurzen Code passen kann und alles vor Ihren Augen liegt.  In dem gezeigten Beispiel tritt beispielsweise im getrennten Zustand (st_disconnecting) entweder der Ãœbergang in den getrennten Zustand (st_off.) Oder der Schutzzustand (st_protection) auf, wenn eine Meldung Ã¼ber einen Fehler auftritt.  Ein solcher Code ist ziemlich einfach zu lesen. </p><br><p>  Ãœbrigens gibt es fÃ¼r einfache FÃ¤lle, in denen ein Ereignis nur in einen bestimmten Zustand versetzt werden muss, eine noch kÃ¼rzere Syntax: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mbox = drv-&gt;so_mbox(); st_off .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_connected_t</span></span>&gt;(mbox, st_connected) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_failure_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_limit_t</span></span>&gt;(mbox, st_protection) .just_switch_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">msg_on_t</span></span>&gt;(mbox, st_on);</code> </pre><br><h2 id="upravlenie">  Management </h2><br><p>  Wie funktioniert das Management all dieser Wirtschaft?  Wie oben erwÃ¤hnt, sind zwei Fernbedienungen zur direkten Steuerung der Bewegung der Shtankets vorgesehen.  Auf jeder Fernbedienung befinden sich ein Monitor, ein Manipulator (Trackball) und eine Kurzwahl (zusÃ¤tzlich zu dem in der Fernbedienung versteckten â€Computerâ€œ, auf dem sich alles dreht, und jede Menge Konverter aller Art).  Das System verfÃ¼gt Ã¼ber mehrere Modi zur Steuerung der Bewegung der Shtankets.  Manueller und "Skriptmodus".  Ãœber den "Szenariomodus" wird weiter diskutiert, und nun ein wenig Ã¼ber den "manuellen Modus".  In diesem Modus wÃ¤hlt der Bediener den gewÃ¼nschten Schaft aus, bereitet ihn fÃ¼r die Bewegung vor (verbindet den Motor mit dem Umrichter), setzt die Markierung (Zielposition) fÃ¼r den Schaft und sobald die Geschwindigkeit grÃ¶ÃŸer als Null ist, beginnen sich die SchÃ¤fte zu bewegen.  Zum Einstellen der Geschwindigkeit wird ein spezieller physikalischer Einsteller in Form eines â€Potentiometers mit einem Knopfâ€œ verwendet, aber es gibt auch einen â€Bildschirmeinstellerâ€œ fÃ¼r die Geschwindigkeit.  Je mehr "gedreht", desto <del>  lauter </del>  geht schneller.  Die HÃ¶chstgeschwindigkeit ist auf 1,5 m / s begrenzt.  Geschwindigkeitsknopf - einer fÃ¼r alle.  Das heiÃŸt,  Im manuellen Modus bewegen sich alle vom Bediener angeschlossenen SchÃ¤fte mit der gleichen eingestellten Geschwindigkeit.  Obwohl sie sich in verschiedene Richtungen bewegen kÃ¶nnen (hÃ¤ngt davon ab, wohin der Bediener sie geleitet hat).  NatÃ¼rlich ist es fÃ¼r eine Person schwierig, mehr als zwei oder drei Shtankets gleichzeitig im Auge zu behalten, daher bewegen sie sich im manuellen Modus normalerweise nicht viel.  Von zwei Stationen aus kÃ¶nnen Bediener gleichzeitig jeden ihrer Shtankets verwalten.  ZusÃ¤tzlich hat jede Konsole (Bediener) einen eigenen Geschwindigkeitsregler. </p><br><p>  Aus Sicht der Implementierung enthÃ¤lt der manuelle Modus keine spezielle Logik.  Der Befehl zum Verbinden der Engine kommt von der grafischen OberflÃ¤che und wird in eine Nachricht an den entsprechenden Akteur umgewandelt, der daran arbeitet.  Durchlaufen der ZustÃ¤nde "Aus" -&gt; "Verbinden" -&gt; "Verbunden".  Gleiches gilt fÃ¼r das Einstellen der Position fÃ¼r die Bewegung des Stunkets und das Einstellen der Geschwindigkeit.  Alle diese Ereignisse erreichen den Schauspieler in Form von Nachrichten, auf die er reagiert.  Es sei denn, es kann festgestellt werden, dass die grafische OberflÃ¤che und der Steuerungsprozess selbst unterschiedliche Prozesse sind und zwischen ihnen eine "Interprozess" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Interaktion</a> durch die "Sensoren" unter Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libuniset2 besteht</a> . </p><br><h2 id="rezhim-ispolneniya-scenariya-opyat-eti-aktory">  SkriptausfÃ¼hrungsmodus (wieder diese Akteure?) </h2><br><p>  TatsÃ¤chlich wird der manuelle Steuermodus hauptsÃ¤chlich nur zum AbhÃ¤ngen wÃ¤hrend der Proben oder in einfachen FÃ¤llen verwendet.  Der Hauptmodus, in dem das Steuerelement ausgefÃ¼hrt wird, ist der "SkriptausfÃ¼hrungsmodus" oder kurz "Skriptmodus".  In diesem Modus bewegt sich jeder Shtank mit den im Skript angegebenen Parametern (Geschwindigkeit und Zielmarke) an seinen Punkt.  FÃ¼r den Bediener besteht die Steuerung in diesem Modus aus zwei einfachen Befehlen: </p><br><ul><li>  Machen Sie sich bereit (die richtige Gruppe von Motoren ist angeschlossen) </li><li>  Lass uns gehen (die Gruppe bewegt sich zu den jeweils festgelegten Zielpositionen). </li></ul><br><p>  Das gesamte Szenario ist in sogenannte â€Agendenâ€œ unterteilt.  Eine Agenda ist eine Bewegung einer Shtanket-Gruppe.  Das heiÃŸt,  Jede Agenda enthÃ¤lt eine Gruppe von Shtankets mit der Zielgeschwindigkeit und der Marke, zu der Sie kommen mÃ¼ssen.  TatsÃ¤chlich ist das Drehbuch in Handlungen unterteilt, Handlungen sind in GemÃ¤lde unterteilt, GemÃ¤lde sind in Vorladungen unterteilt und Vorladungen bestehen bereits aus â€Zielenâ€œ fÃ¼r bestimmte Schtankets.  Aus Sicht des Managements ist diese Aufteilung jedoch nicht wichtig, weil  Auf der Tagesordnung stehen am Ende bestimmte Parameter der Bewegung. </p><br><p>  Um dieses Regime umzusetzen, wurde das Akteursystem so gut wie mÃ¶glich wieder eingefÃ¼hrt.  Es wurde ein â€Script Playerâ€œ entwickelt, der eine Gruppe spezieller Schauspieler erstellt und diese startet.  Wir haben zwei Arten von Akteuren entwickelt: Schauspieler-Schauspieler, die Aufgaben fÃ¼r einen bestimmten Shtanket ausfÃ¼hren sollen, und einen Schauspieler-Koordinator, der Aufgaben zwischen den Darstellern verteilt.  DarÃ¼ber hinaus werden nach Bedarf darstellende Schauspieler geschaffen, wenn zum Zeitpunkt des nÃ¤chsten Teams nicht frei ist.  Der Koordinator ist fÃ¼r die Erstellung und Pflege des Pools der darstellenden Akteure verantwortlich.  Infolgedessen sieht das Management ungefÃ¤hr so â€‹â€‹aus: </p><br><ul><li>  Anweisung lÃ¤dt das Skript </li><li>  "Kippt" es auf die gewÃ¼nschte Agenda (normalerweise nur in einer Reihe). </li><li>  DrÃ¼cken Sie im richtigen Moment die SchaltflÃ¤che "Vorbereiten", mit der ein Befehl (eine Nachricht) fÃ¼r jedes in der aktuellen Agenda enthaltene Formlet mit Bewegungsparametern an den koordinierenden Akteur gesendet wird. </li><li>  Der Schauspieler-Koordinator schaut sich seinen Pool an frei auftretenden Schauspielern an, nimmt einen freien (wenn er keinen neuen erstellt) und gibt ihm eine Aufgabe (Anzahl der Shankets und Bewegungsparameter). </li><li>  Jeder Schauspieler-Schauspieler, der die Aufgabe erhalten hat, beginnt, den Befehl â€Bereit machenâ€œ zu erfÃ¼llen.  Das heiÃŸt,  Es verbindet den Motor und wechselt in den Standby-Modus des Befehls â€goâ€œ. </li><li>  Wenn die Zeit gekommen ist, gibt der Bediener den Befehl "Los geht's". </li><li>  Das Team "go" kommt zum Koordinator.  Er sendet es an alle seine derzeit aktiven Darsteller und sie beginnen mit der â€Hinrichtungâ€œ. </li></ul><br><p>  Es ist erwÃ¤hnenswert, dass auf der Tagesordnung zusÃ¤tzliche Parameter stehen.  Starten Sie beispielsweise die Bewegung mit einer VerzÃ¶gerung von N Sekunden oder starten Sie die Bewegung erst nach einem separaten speziellen Bedienerbefehl.  Daher ist die Liste der ZustÃ¤nde fÃ¼r jeden darstellenden Akteur ziemlich umfangreich: "Bereit zum AusfÃ¼hren des nÃ¤chsten Befehls", "Bereit zum Bewegen", "VerzÃ¶gerte Bewegung", "Warten auf den Befehl des Bedieners", "Bewegung", "AusfÃ¼hrung abgeschlossen", "Fehlfunktion". . </p><br><p>  Nachdem der Shanket die angegebene Marke erfolgreich (oder nicht) erreicht hat, benachrichtigt der Darsteller den Koordinator Ã¼ber die abgeschlossene Aufgabe.  Der Koordinator gibt entweder den Befehl zum Ausschalten dieser Engine (wenn sie nicht mehr an der aktuellen Agenda teilnimmt) oder gibt neue Bewegungsparameter aus.  Der Darsteller erhielt seinerseits einen Befehl zum Ausschalten der Engine, zum Ausschalten und zum Warten auf neue Befehle oder zum AusfÃ¼hren eines neuen Befehls. </p><br><p>  Aufgrund der Tatsache, dass der Sobjectizer Ã¼ber eine gut durchdachte und bequeme API fÃ¼r die Arbeit mit Status verfÃ¼gt, ist der Implementierungscode recht prÃ¤zise.  Zum Beispiel wird die VerzÃ¶gerung der Bewegung in einer Zeile beschrieben: </p><br><pre> <code class="cpp hljs">st_delay.time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{target-&gt;delay()}, st_moving ); st_delay.activate(); ...</code> </pre><br><p>  Die Funktion time_limit legt ein Zeitlimit fest, wie viel in einem bestimmten Zustand ausgegeben werden kann und welcher Zustand nach einer bestimmten Zeit Ã¼bergeben werden soll (st_moving). </p><br><h2 id="aktory-zaschity">  Schutzakteure </h2><br><p>  NatÃ¼rlich kÃ¶nnen wÃ¤hrend des Betriebs Fehlfunktionen auftreten.  Das System muss diese Situationen bewÃ¤ltigen.  Auch hier gab es einen Platz fÃ¼r den Einsatz von Schauspielern.  Betrachten Sie mehrere dieser SchutzmaÃŸnahmen: </p><br><ul><li>  Ãœberstromschutz </li><li>  Schutz vor Messfehlern </li><li>  Schutz gegen Bewegung in die entgegengesetzte Richtung (und dies kann sein, wenn etwas mit dem Sensor oder MessgerÃ¤t nicht stimmt) </li><li>  Schutz vor Bewegung ohne Befehl </li><li>  Kontrolle Ã¼ber die AusfÃ¼hrung des Teams (Kontrolle darÃ¼ber, dass sich der Shtanket in Bewegung gesetzt hat) </li></ul><br><p>  Sie kÃ¶nnen sehen, dass alle diese SchutzmaÃŸnahmen vom Standpunkt der Implementierung unabhÃ¤ngig (autark) sind und "parallel" funktionieren sollten.  Das heiÃŸt,  Jede Bedingung kann funktionieren.  Gleichzeitig hat die Logik zum ÃœberprÃ¼fen der AuslÃ¶sebedingungen fÃ¼r jeden der Schutzfunktionen ihre eigene, manchmal ist eine VerzÃ¶gerung (Zeitgeber) zum AuslÃ¶sen erforderlich, manchmal ist eine vorlÃ¤ufige Verarbeitung mehrerer vorheriger Messungen erforderlich usw.  Daher erwies sich die Implementierung jeder Art von Schutz als separater kleiner Akteur als sehr praktisch.  Alle diese Akteure werden zusÃ¤tzlich (in Zusammenarbeit) zu dem Hauptakteur gestartet, der die Steuerlogik implementiert.  Dieser Ansatz macht es einfach, zusÃ¤tzliche Arten von Verteidigungen hinzuzufÃ¼gen, indem einfach ein weiterer Akteur zur Gruppe hinzugefÃ¼gt wird.  Gleichzeitig bleibt die Implementierung eines solchen Akteurs ziemlich einfach und verstÃ¤ndlich, weil  Es implementiert nur eine Funktion. </p><br><p>  Schutzakteure haben auch mehrere Staaten.  GrundsÃ¤tzlich schalten sie sich nur dann ein (gehen in den Zustand â€Einâ€œ), wenn der Motor angeschlossen ist oder sich der Schaft bewegt.  Wenn die Schutzbedingungen ausgelÃ¶st werden, verÃ¶ffentlichen sie eine Benachrichtigung Ã¼ber den Schutz (mit einem Sicherheitscode und einigen Details fÃ¼r die Protokollierung). Der Hauptakteur reagiert bereits auf diese Benachrichtigung, die bei Bedarf die Engine ausschaltet und in den Schutzmodus wechselt. </p><br><h2 id="v-kachestve-vyvoda">  Als Fazit .. </h2><br><p>  ... natÃ¼rlich ist dieser Artikel keine "Entdeckung".  Der Akteuransatz wird seit langem in vielen Systemen erfolgreich eingesetzt.  FÃ¼r mich war es jedoch die erste Erfahrung, in einem relativ kleinen Projekt bewusst den Akteuransatz zum Erstellen von Steuerungssystemalgorithmen zu verwenden.  Und die Erfahrung war ziemlich erfolgreich.  Ich hoffe, ich konnte zeigen, dass die Schauspieler den Steuerungsalgorithmen sehr gut Ã¼berlagert sind, sie haben buchstÃ¤blich Ã¼berall einen Platz gefunden. </p><br><p>  Aus den Erfahrungen frÃ¼herer Projekte ging hervor, dass wir auf die eine oder andere Weise â€so etwasâ€œ implementiert haben (Status, Messaging, Flusskontrolle usw.), aber dies war kein einheitlicher Ansatz.  Mit dem Sobjectizer haben wir ein Ã¼bersichtliches, leichtes Entwicklungswerkzeug erhalten, das eine Menge Probleme lÃ¶st.  Es ist nicht mehr erforderlich (explizit), Synchronisationstools (Mutexe usw.) zu verwenden, es gibt keine explizite Arbeit mit Streams, keine Realisierungen der Zustandsmaschine.  All dies ist im Framework, logisch miteinander verbunden und darÃ¼ber hinaus als praktische API dargestellt, ohne die Kontrolle Ã¼ber die Details zu verlieren.  Die Erfahrung war also interessant.  FÃ¼r diejenigen, die immer noch Zweifel haben, empfehle ich, auf den Schauspieleransatz und insbesondere auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sobjectizer-</a> Framework zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">achten</a> .  Er hinterlÃ¤sst positive Emotionen. </p><br><p>  Und der Schauspieleransatz funktioniert wirklich!  Besonders im Theater. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438196/">https://habr.com/ru/post/de438196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438180/index.html">Registrieren Sie eine Immobilientransaktion online</a></li>
<li><a href="../de438182/index.html">Die Studie fand die Vorteile einer moderaten Piraterie fÃ¼r Produzenten und Vertreiber von Inhalten</a></li>
<li><a href="../de438184/index.html">Bericht der Bank of America: 700 Billionen Dollar aus dem All</a></li>
<li><a href="../de438186/index.html">Checkliste: Was musste getan werden, bevor Microservices fÃ¼r die Produktion bereitgestellt wurden?</a></li>
<li><a href="../de438192/index.html">Dell Inspiron 14 (5482): kostengÃ¼nstiges 2-in-1-GerÃ¤t mit guten Upgrade-Optionen</a></li>
<li><a href="../de438198/index.html">Gehen wir tief in die Geschichte ein: Wo wachsen die Beine von Quadrocoptern?</a></li>
<li><a href="../de438202/index.html">JavaScript: Ã–ffentliche und private Klassenfelder</a></li>
<li><a href="../de438204/index.html">Schnelles Compiler-GerÃ¤t. Teil 1</a></li>
<li><a href="../de438206/index.html">26 Empfehlungen fÃ¼r die Verwendung des var-Typs in Java</a></li>
<li><a href="../de438210/index.html">Zivilisation der Quellen, 2/5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>