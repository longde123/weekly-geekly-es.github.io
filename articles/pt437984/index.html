<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëì üë∏üèΩ üå¶Ô∏è Threading no Node.js: m√≥dulo worker_threads ‚ûñ ü§≥üèø üßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em 18 de janeiro, a vers√£o da plataforma Node.js. 11.7.0 foi anunciada . Entre as mudan√ßas not√°veis ‚Äã‚Äãnesta vers√£o, pode-se notar a conclus√£o da categ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Threading no Node.js: m√≥dulo worker_threads</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/437984/">  Em 18 de janeiro, a vers√£o da plataforma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Node.js. 11.7.0 foi anunciada</a> .  Entre as mudan√ßas not√°veis ‚Äã‚Äãnesta vers√£o, pode-se notar a conclus√£o da categoria do m√≥dulo experimental worker_threads, que apareceu no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Node.js. 10.5.0</a> .  Agora a bandeira --experimental-worker n√£o √© necess√°ria para us√°-la.  Este m√≥dulo, desde a sua cria√ß√£o, permaneceu bastante est√°vel e, portanto, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">decis√£o</a> foi tomada, refletida no Node.js. 11.7.0. <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/jp/qj/fk/jpqjfkjewyfpm1cbr5yxaubxt-w.png"></a> <br>  O autor do material, cuja tradu√ß√£o estamos publicando, se oferece para discutir os recursos do m√≥dulo worker_threads, em particular, ele quer falar sobre por que esse m√≥dulo √© necess√°rio e como o multithreading √© implementado no JavaScript e no Node.js por raz√µes hist√≥ricas.  Aqui, falaremos sobre quais problemas est√£o associados √† cria√ß√£o de aplicativos JS multithread, sobre as formas existentes de resolv√™-los e sobre o futuro do processamento paralelo de dados usando os chamados "threads de trabalho", que s√£o chamados de "threads de trabalho" ou apenas "trabalhadores". <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Vida em um mundo de thread √∫nico</font> </h2><br>  O JavaScript foi concebido como uma linguagem de programa√ß√£o de thread √∫nico que roda em um navegador.  ‚ÄúEncadeamento √∫nico‚Äù significa que, no mesmo processo (nos navegadores modernos, estamos falando de guias separadas do navegador), apenas um conjunto de instru√ß√µes pode ser executado por vez. <br><br>  Isso simplifica o desenvolvimento de aplicativos, facilita o trabalho dos programadores.  O JavaScript era originalmente uma linguagem adequada apenas para adicionar alguns recursos interativos √†s p√°ginas da Web, por exemplo, algo como valida√ß√£o de formul√°rio.  Entre as tarefas para as quais o JS foi projetado, n√£o havia nada particularmente complicado exigindo multithreading. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ryan Dahl</a> , criador do Node.js, viu uma oportunidade interessante nessa restri√ß√£o de idioma.  Ele queria implementar uma plataforma de servidor baseada em um subsistema de E / S ass√≠ncrona.  Isso significava que o programador n√£o precisava trabalhar com threads, o que simplifica bastante o desenvolvimento para uma plataforma semelhante.  Ao desenvolver programas projetados para execu√ß√£o paralela de c√≥digo, podem surgir problemas muito dif√≠ceis de resolver.  Por exemplo, se v√°rios threads tentarem acessar a mesma √°rea de mem√≥ria, isso poder√° levar ao chamado "estado de corrida do processo" que interrompe o programa.  Tais erros s√£o dif√≠ceis de reproduzir e corrigir. <br><br><h2>  <font color="#3AC1EF">A plataforma Node.js √© de thread √∫nico?</font> </h2><br>  Os aplicativos Node.js. t√™m um thread?  Sim, de certa forma √©.  De fato, o Node.js permite executar determinadas a√ß√µes em paralelo, mas para isso, o programador n√£o precisa criar threads ou sincroniz√°-las.  A plataforma Node.js e o sistema operacional executam opera√ß√µes de entrada / sa√≠da paralelas por seus pr√≥prios meios e, quando chega a hora do processamento de dados usando nosso c√≥digo JavaScript, ele funciona no modo de thread √∫nico. <br><br>  Em outras palavras, tudo, exceto nosso c√≥digo JS, funciona em paralelo.  Em blocos s√≠ncronos de c√≥digo JavaScript, os comandos s√£o sempre executados um de cada vez, na ordem em que s√£o apresentados no c√≥digo-fonte: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>  <span class="hljs-comment"><span class="hljs-comment">//    -  (     flag)...  //      ,     flag   true.  // -       ,  //      . }</span></span></code> </pre> <br>  Tudo isso √© √≥timo - se todo o nosso c√≥digo estiver ocupado com E / S ass√≠ncrona.  O programa consiste em pequenos blocos de c√≥digo s√≠ncrono que operam rapidamente em dados, por exemplo, enviados para arquivos e fluxos.  O c√≥digo dos fragmentos do programa √© t√£o r√°pido que n√£o impede a execu√ß√£o do c√≥digo de seus outros fragmentos.  Muito mais tempo do que a execu√ß√£o do c√≥digo leva para aguardar os resultados de E / S ass√≠ncrona.  Considere um pequeno exemplo: <br><br><pre> <code class="javascript hljs">db.findOne(<span class="hljs-string"><span class="hljs-string">'SELECT ... LIMIT 1'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) }) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Running query'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hey there'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  √â poss√≠vel que a consulta ao banco de dados mostrada aqui demore cerca de um minuto, mas a mensagem de <code>Running query</code> ser√° enviada ao console imediatamente ap√≥s o in√≠cio dessa consulta.  Nesse caso, a mensagem <code>Hey there</code> ser√° exibida um segundo ap√≥s a execu√ß√£o da solicita√ß√£o, independentemente de sua execu√ß√£o ter sido conclu√≠da ou n√£o.  Nosso aplicativo Node.js simplesmente chama a fun√ß√£o que inicia a solicita√ß√£o, enquanto a execu√ß√£o de seu outro c√≥digo n√£o est√° bloqueada.  Depois que a solicita√ß√£o for conclu√≠da, o aplicativo ser√° informado sobre isso usando a fun√ß√£o de retorno de chamada e receber√° uma resposta a essa solicita√ß√£o. <br><br><h2>  <font color="#3AC1EF">Tarefas intensivas da CPU</font> </h2><br>  O que acontece se, por meio do JavaScript, precisamos fazer computa√ß√£o pesada?  Por exemplo - para processar um grande conjunto de dados armazenados na mem√≥ria?  Isso pode levar ao fato de que o programa conter√° um fragmento de c√≥digo s√≠ncrono, cuja execu√ß√£o leva muito tempo e bloqueia a execu√ß√£o de outro c√≥digo.  Imagine que esses c√°lculos demorem 10 segundos.  Se estivermos falando de um servidor da Web que processa uma determinada solicita√ß√£o, isso significa que ele n√£o poder√° processar outras solicita√ß√µes por pelo menos 10 segundos.  Este √© um grande problema.  De fato, c√°lculos maiores que 100 milissegundos j√° podem causar esse problema. <br><br>  O JavaScript e a plataforma Node.js. n√£o foram originalmente projetados para resolver tarefas que usam intensamente os recursos do processador.  No caso de JS em execu√ß√£o no navegador, executar essas tarefas significa "freios" na interface do usu√°rio.  No Node.js, isso pode limitar a capacidade de solicitar que a plataforma execute novas tarefas de E / S ass√≠ncronas e a capacidade de responder a eventos associados √† sua conclus√£o. <br><br>  Vamos voltar ao nosso exemplo anterior.  Imagine que, em resposta a uma consulta ao banco de dados, v√°rios milhares de registros criptografados entraram, os quais, no c√≥digo JS s√≠ncrono, devem ser descriptografados: <br><br><pre> <code class="javascript hljs">db.findAll(<span class="hljs-string"><span class="hljs-string">'SELECT ...'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, results</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-comment"><span class="hljs-comment">//      ,    . for (const encrypted of results) {   const plainText = decrypt(encrypted)   console.log(plainText) } })</span></span></code> </pre> <br>  Os resultados, ap√≥s receb√™-los, est√£o na fun√ß√£o de retorno de chamada.  Depois disso, at√© o final de seu processamento, nenhum outro c√≥digo JS pode ser executado.  Normalmente, como j√° mencionado, a carga no sistema criada por esse c√≥digo √© m√≠nima, ele executa rapidamente as tarefas atribu√≠das a ele.  Mas, neste caso, o programa recebeu os resultados da consulta, que t√™m uma quantidade consider√°vel, e ainda precisamos process√°-los.  Algo assim pode demorar alguns segundos.  Se estivermos falando de um servidor com o qual muitos usu√°rios trabalham, isso significa que eles poder√£o continuar trabalhando somente ap√≥s a conclus√£o de uma opera√ß√£o que consome muitos recursos. <br><br><h2>  <font color="#3AC1EF">Por que o JavaScript nunca ter√° t√≥picos?</font> </h2><br>  Dado o exposto acima, pode parecer que, para solucionar problemas pesados ‚Äã‚Äãde computa√ß√£o no Node.js., voc√™ precisa adicionar um novo m√≥dulo que permita criar threads e gerenci√°-los.  Como voc√™ pode passar sem algo assim?  √â muito triste que aqueles que usam uma plataforma madura de servidor, como o Node.js., n√£o tenham os meios para resolver belamente os problemas associados ao processamento de grandes quantidades de dados. <br><br>  Tudo isso √© verdade, mas se voc√™ adicionar a capacidade de trabalhar com fluxos em JavaScript, isso levar√° a uma altera√ß√£o na pr√≥pria natureza desse idioma.  Em JS, voc√™ n√£o pode adicionar a capacidade de trabalhar com threads, por exemplo, na forma de um novo conjunto de classes ou fun√ß√µes.  Para fazer isso, voc√™ precisa alterar o pr√≥prio idioma.  Em idiomas que suportam multithreading, o conceito de sincroniza√ß√£o √© amplamente usado.  Por exemplo, em Java, mesmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alguns tipos num√©ricos</a> n√£o s√£o at√¥micos.  Isso significa que, se os mecanismos de sincroniza√ß√£o n√£o forem usados ‚Äã‚Äãpara trabalhar com eles de diferentes threads, tudo isso poder√° resultar, por exemplo, depois de alguns threads simultaneamente tentarem alterar o valor da mesma vari√°vel, v√°rios bytes dessa vari√°vel ser√£o definidos como um fluxo, e alguns outros.  Como resultado, essa vari√°vel conter√° algo incompat√≠vel com a opera√ß√£o normal do programa. <br><br><h2>  <font color="#3AC1EF">Solu√ß√£o primitiva para o problema: itera√ß√£o do loop de eventos</font> </h2><br>  O Node.js n√£o executar√° o pr√≥ximo bloco de c√≥digo na fila de eventos at√© que o bloco anterior seja conclu√≠do.  Isso significa que, para resolver nosso problema, podemos dividi-lo em partes representadas por fragmentos de c√≥digo s√≠ncrono e, em seguida, usar uma constru√ß√£o do formul√°rio <code>setImmediate(callback)</code> para planejar a execu√ß√£o desses fragmentos.  O c√≥digo especificado pela fun√ß√£o de <code>callback</code> nesta constru√ß√£o ser√° executado ap√≥s a conclus√£o das tarefas da itera√ß√£o atual (tick) do loop de eventos.  Depois disso, o mesmo design √© usado para enfileirar o pr√≥ximo lote de c√°lculos.  Isso permite n√£o bloquear o ciclo de eventos e, ao mesmo tempo, resolver problemas volum√©tricos. <br><br>  Imagine que temos uma grande matriz que precisa ser processada, enquanto o processamento de cada elemento dessa matriz exige c√°lculos complexos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-comment"><span class="hljs-comment">/*large array*/</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) { <span class="hljs-comment"><span class="hljs-comment">//         } // ,   ,      .</span></span></code> </pre> <br>  Como j√° mencionado, se decidirmos processar toda a matriz em uma chamada, isso levar√° muito tempo e impedir√° a execu√ß√£o de outro c√≥digo de aplicativo.  Portanto, vamos dividir essa grande tarefa em partes e usar a constru√ß√£o <code>setImmediate(callback)</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crypto = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'crypto'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>).fill(<span class="hljs-string"><span class="hljs-string">'something'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processChunk</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) {   <span class="hljs-comment"><span class="hljs-comment">// ,      } else {   console.log('processing chunk');   //  10         const subarr = arr.splice(0, 10)   for (const item of subarr) {     //           doHeavyStuff(item)   }   //       setImmediate(processChunk) } } processChunk() function doHeavyStuff(item) { crypto.createHmac('sha256', 'secret').update(new Array(10000).fill(item).join('.')).digest('hex') } //       , ,   , //       . let interval = setInterval(() =&gt; { console.log('tick!') if (arr.length === 0) clearInterval(interval) }, 0)</span></span></code> </pre> <br>  Agora, de uma s√≥ vez, processamos dez elementos da matriz, depois dos quais, usando <code>setImmediate()</code> , planejamos o pr√≥ximo lote de c√°lculos.  E isso significa que, se voc√™ precisar executar mais c√≥digo no programa, ele poder√° ser executado entre opera√ß√µes no processamento de fragmentos da matriz.  Para isso, aqui, no final do exemplo, h√° um c√≥digo que usa <code>setInterval()</code> . <br><br>  Como voc√™ pode ver, esse c√≥digo parece muito mais complicado do que sua vers√£o original.  E, muitas vezes, o algoritmo pode ser muito mais complexo que o nosso, o que significa que, quando implementado, n√£o ser√° f√°cil dividir os c√°lculos em peda√ßos e entender onde, para alcan√ßar o equil√≠brio certo, voc√™ precisa definir <code>setImmediate()</code> , planejando a pr√≥xima pe√ßa de c√°lculo.  Al√©m disso, agora o c√≥digo acabou sendo ass√≠ncrono e, se nosso projeto depender de bibliotecas de terceiros, talvez n√£o possamos dividir o processo de resolver uma tarefa dif√≠cil em partes. <br><br><h2>  <font color="#3AC1EF">Processos em segundo plano</font> </h2><br>  Talvez a abordagem acima com <code>setImmediate()</code> funcione bem em casos simples, mas est√° longe de ser ideal.  Al√©m disso, os threads n√£o s√£o usados ‚Äã‚Äãaqui (por raz√µes √≥bvias) e tamb√©m n√£o pretendemos alterar o idioma para isso.  √â poss√≠vel fazer processamento de dados paralelo sem usar threads?  Sim, √© poss√≠vel, e para isso precisamos de algum tipo de mecanismo para o processamento de dados em segundo plano.  Trata-se de iniciar uma determinada tarefa, passar dados para ela e, para que essa tarefa, sem interferir no c√≥digo principal, use tudo o que for necess√°rio, gaste tanto tempo no trabalho quanto necess√°rio e, em seguida, retorne os resultados para c√≥digo principal.  Precisamos de algo semelhante ao seguinte snippet de c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  script.js   ,    . const service = createService('script.js') //          service.compute(data, function(err, result) { //      })</span></span></code> </pre> <br>  A realidade √© que no Node.js voc√™ pode usar processos em segundo plano.  O ponto √© que √© poss√≠vel criar uma bifurca√ß√£o do processo e implementar o esquema de trabalho acima descrito usando o mecanismo de mensagens entre os processos filho e pai.  O processo principal pode interagir com o processo descendente, enviando eventos para ele e recebendo-os dele.  A mem√≥ria compartilhada n√£o √© usada com essa abordagem.  Todos os dados trocados por processos s√£o "clonados", ou seja, quando s√£o feitas altera√ß√µes em uma inst√¢ncia desses dados por um processo, essas altera√ß√µes n√£o s√£o vis√≠veis para outro processo.  Isso √© semelhante a uma solicita√ß√£o HTTP - quando um cliente envia para o servidor, o servidor recebe apenas uma c√≥pia dele.  Se os processos n√£o usam mem√≥ria compartilhada, isso significa que, com sua opera√ß√£o simult√¢nea, √© imposs√≠vel criar um "estado de corrida" e que n√£o precisamos nos sobrecarregar com o trabalho com threads.  Parece que nosso problema foi resolvido. <br><br>  √â verdade que na realidade n√£o √© assim.  Sim - diante de n√≥s est√° uma das solu√ß√µes para a tarefa de realizar c√°lculos intensivos, mas, novamente, √© imperfeita.  Criar uma bifurca√ß√£o de um processo √© uma opera√ß√£o que consome muitos recursos.  Leva tempo para concluir.  De fato, estamos falando sobre a cria√ß√£o de uma nova m√°quina virtual do zero e sobre o aumento da quantidade de mem√≥ria consumida pelo programa, devido ao fato de que os processos n√£o usam mem√≥ria compartilhada.  Diante do exposto, √© apropriado perguntar se √© poss√≠vel, ap√≥s a conclus√£o de uma tarefa, reutilizar a bifurca√ß√£o do processo.  Voc√™ pode dar uma resposta positiva a essa pergunta, mas aqui √© necess√°rio lembrar que est√° planejado transferir a bifurca√ß√£o do processo para v√°rias tarefas com muitos recursos que ser√£o executadas nele de forma s√≠ncrona.  Dois problemas podem ser vistos aqui: <br><br><ul><li>  Embora, com essa abordagem, o processo principal n√£o seja bloqueado, o processo descendente pode executar as tarefas transferidas para ele apenas sequencialmente.  Se tivermos duas tarefas, uma das quais leva 10 segundos e a segunda leva 1 segundo, e vamos conclu√≠-las nessa ordem, √© improv√°vel que gostemos da necessidade de aguardar a conclus√£o da primeira antes da segunda.  Como estamos criando garfos de processo, gostar√≠amos de usar os recursos do sistema operacional para planejar tarefas e usar os recursos de computa√ß√£o de todos os n√∫cleos do nosso processador.  Precisamos de algo que se assemelhe a trabalhar em um computador para uma pessoa que ouve m√∫sica e viaja atrav√©s de p√°ginas da web.  Para fazer isso, voc√™ pode criar dois processos de fork e organizar a execu√ß√£o paralela de tarefas com a ajuda deles. </li><li>  Al√©m disso, se uma das tarefas levar ao final do processo com um erro, todas as tarefas enviadas para esse processo ser√£o n√£o processadas. </li></ul><br>  Para resolver esses problemas, precisamos de v√°rios processos de fork, n√£o um, mas teremos que limitar seu n√∫mero, pois cada um deles utiliza recursos do sistema e leva tempo para criar cada um deles.  Como resultado, seguindo o padr√£o de sistemas que suportam conex√µes com o banco de dados, precisamos de algo como um conjunto de processos prontos para uso.  O sistema de gerenciamento de pool de processos, ap√≥s o recebimento de novas tarefas, utilizar√° processos livres para execut√°-los e, quando um determinado processo lidar com a tarefa, poder√° atribuir um novo a ele.  H√° um sentimento de que esse esquema de trabalho n√£o √© f√°cil de implementar e, de fato, √©.  Usaremos o pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">worker-farm</a> para implementar este esquema: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const workerFarm = require('worker-farm') const service = workerFarm(require.resolve('./script')) service('hello', function (err, output) { console.log(output) }) // script.js //      - module.exports = (input, callback) =&gt; { callback(null, input + ' ' + world) }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">M√≥dulo Worker_threads</font> </h2><br>  Ent√£o, nosso problema foi resolvido?  Sim, podemos dizer que est√° resolvido, mas com essa abordagem, √© necess√°ria muito mais mem√≥ria do que seria necess√°rio se tiv√©ssemos uma solu√ß√£o multithread √† nossa disposi√ß√£o.  Os threads consomem muito menos recursos em compara√ß√£o com os garfos do processo.  √â por isso que o m√≥dulo <code>worker_threads</code> apareceu no <code>worker_threads</code> <br><br>  Os segmentos de trabalho s√£o executados em um contexto isolado.  Eles trocam informa√ß√µes com o processo principal usando mensagens.  Isso nos salva do problema de ‚Äúcondi√ß√£o de corrida‚Äù ao qual est√£o sujeitos os ambientes multiencadeados.  Ao mesmo tempo, os fluxos de trabalho existem no mesmo processo que o programa principal, ou seja, com essa abordagem, em compara√ß√£o com o uso de garfos de processo, muito menos mem√≥ria √© usada. <br><br>  Al√©m disso, trabalhando com trabalhadores, voc√™ pode usar a mem√≥ria compartilhada.  Portanto, especificamente para esse fim, objetos do tipo <code>SharedArrayBuffer</code> s√£o <code>SharedArrayBuffer</code> .  Eles devem ser usados ‚Äã‚Äãapenas nos casos em que o programa precisa executar um processamento complexo de grandes quantidades de dados.  Eles permitem salvar os recursos necess√°rios para serializar e desserializar dados ao organizar a troca de dados entre trabalhadores e o programa principal por meio de mensagens. <br><br><h2>  <font color="#3AC1EF">Trabalhador Trabalhador Fluxos</font> </h2><br>  Se voc√™ usar a plataforma Node.js. antes da vers√£o 11.7.0, para ativar o trabalho com o m√≥dulo <code>worker_threads</code> , ser√° necess√°rio usar o <code>--experimental-worker</code> ao iniciar o <code>--experimental-worker</code> <br><br>  Al√©m disso, vale lembrar que a cria√ß√£o de um trabalhador (bem como a cria√ß√£o de um fluxo em qualquer idioma), embora exija muito menos recursos do que a cria√ß√£o de um fork de um processo, tamb√©m cria uma certa carga no sistema.  Talvez no seu caso, mesmo essa carga possa ser demais.  Nesses casos, a documenta√ß√£o recomenda a cria√ß√£o de um pool de trabalhadores.  Se voc√™ precisar disso, √© claro que poder√° criar sua pr√≥pria implementa√ß√£o desse mecanismo, mas talvez deva procurar algo adequado no registro do NPM. <br><br>  Considere um exemplo de trabalho com threads de trabalho.  Teremos um arquivo principal, <code>index.js</code> , no qual criaremos um thread de trabalho e transmitiremos alguns dados para processamento.  A API correspondente √© baseada em eventos, mas vou usar uma promessa aqui que resolve quando a primeira mensagem do trabalhador chegar: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// index.js //    Node.js   11.7.0,  //      node --experimental-worker index.js const { Worker } = require('worker_threads') function runService(workerData) { return new Promise((resolve, reject) =&gt; {   const worker = new Worker('./service.js', { workerData });   worker.on('message', resolve);   worker.on('error', reject);   worker.on('exit', (code) =&gt; {     if (code !== 0)       reject(new Error(`Worker stopped with exit code ${code}`));   }) }) } async function run() { const result = await runService('world') console.log(result); } run().catch(err =&gt; console.error(err))</span></span></code> </pre> <br>  Como voc√™ pode ver, o uso do mecanismo de fluxo de fluxo de trabalho √© bastante simples.  Ou seja, ao criar um trabalhador, voc√™ precisa passar o caminho para o arquivo com o c√≥digo e os dados do <code>Worker</code> para o designer do <code>Worker</code> .  Lembre-se de que esses dados s√£o clonados, n√£o armazenados na mem√≥ria compartilhada.  Ap√≥s iniciar o trabalhador, esperamos uma mensagem dele, ouvindo o evento da <code>message</code> . <br><br>  Acima, ao criar um objeto do tipo <code>Worker</code> , passamos ao construtor o nome do arquivo com o c√≥digo do worker - <code>service.js</code> .  Aqui est√° o c√≥digo para este arquivo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// , ,    , //    . parentPort.postMessage({ hello: workerData })</span></span></code> </pre> <br>  H√° duas coisas que nos interessam no c√≥digo do trabalhador.  Primeiro, precisamos dos dados transmitidos pelo aplicativo principal.  No nosso caso, eles s√£o representados pela vari√°vel <code>workerData</code> .  Em segundo lugar, precisamos de um mecanismo para transmitir informa√ß√µes para a aplica√ß√£o principal.  Esse mecanismo √© representado pelo objeto <code>parentPort</code> , que possui o m√©todo <code>postMessage()</code> , usando o qual passamos os resultados do processamento de dados para o aplicativo principal.  √â assim que tudo funciona. <br><br>  Aqui est√° um exemplo muito simples, mas usando os mesmos mecanismos, voc√™ pode construir estruturas muito mais complexas.  Por exemplo, de um fluxo de trabalho, voc√™ pode enviar muitas mensagens para o fluxo principal que carregam informa√ß√µes sobre o estado do processamento de dados, caso nosso aplicativo precise de um mecanismo semelhante.  Mesmo do trabalhador, os resultados do processamento de dados podem ser retornados em partes.  Por exemplo, algo assim pode ser √∫til em uma situa√ß√£o em que um trabalhador est√° ocupado, por exemplo, processando milhares de imagens e voc√™, sem esperar que todas sejam processadas, deseja notificar o aplicativo principal sobre a conclus√£o do processamento de cada uma delas. <br><br>  Detalhes sobre o m√≥dulo <code>worker_threads</code> podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h2>  <font color="#3AC1EF">Trabalhadores da Web</font> </h2><br>  Voc√™ pode ter ouvido falar de trabalhadores da web.  Eles s√£o projetados para uso em um ambiente cliente, essa tecnologia existe h√° muito tempo e possui um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bom suporte para</a> navegadores modernos.  A API para trabalhar com trabalhadores da Web √© diferente do que o m√≥dulo Node.js <code>worker_threads</code> nos fornece, trata-se das diferen√ßas nos ambientes em que eles trabalham.  No entanto, essas tecnologias podem resolver problemas semelhantes.  Por exemplo, os trabalhadores da Web podem ser usados ‚Äã‚Äãem aplicativos clientes para executar criptografia e descriptografia de dados, sua compacta√ß√£o e descompacta√ß√£o.  Com a ajuda deles, voc√™ pode processar imagens, implementar sistemas de vis√£o computacional (por exemplo, estamos falando de reconhecimento de rosto) e resolver outros problemas semelhantes em um navegador. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  <code>worker_threads</code> ‚Äî     Node.js.    ,    ,   .       , ,       ,         ¬´ ¬ª.   ,      ? ,    <code>worker_threads</code>      ,        Node.js      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">worker-farm</a> ,    <code>worker_threads</code>  ,   Node.js        . <br><br>  <b>Caros leitores!</b>        Node.js-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437984/">https://habr.com/ru/post/pt437984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437974/index.html">Como ganhar WorldSkills digitais? Em um exemplo pr√°tico</a></li>
<li><a href="../pt437976/index.html">"Vkontakte" permitido esconder registros individuais da pol√≠cia</a></li>
<li><a href="../pt437978/index.html">Bem-vindo ao SuperJob do SphinxSearch-meetup</a></li>
<li><a href="../pt437980/index.html">Semin√°rio on-line aberto "M√©todo de teste em pares em testes de caixa preta"</a></li>
<li><a href="../pt437982/index.html">Novo ataque de criptografia da Shade visa usu√°rios de neg√≥cios russos</a></li>
<li><a href="../pt437986/index.html">Por que o TypeScript est√° no centro de todos os novos aplicativos da web do PayPal?</a></li>
<li><a href="../pt437988/index.html">Tutorial React, Parte 12: Workshop, Aplica√ß√£o TODO da Fase 3</a></li>
<li><a href="../pt437990/index.html">Tutorial Reagir Parte 13: Componentes baseados em classe</a></li>
<li><a href="../pt437992/index.html">Microsservi√ßos. Controle de vers√£o em sistemas de integra√ß√£o cont√≠nua e implanta√ß√£o Estudo de caso de CI / CD usando TFS</a></li>
<li><a href="../pt437994/index.html">Ordenha autom√°tica e estufas autom√°ticas: como funciona uma pequena fazenda de alta tecnologia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>