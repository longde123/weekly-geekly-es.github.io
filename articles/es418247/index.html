<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôèÔ∏è üõ∑ üë©üèæ‚Äçüî¨ Acelere la multiplicaci√≥n de matriz flotante 4x4 con SIMD üëÜüèæ üßòüèø üìô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Han pasado muchos a√±os desde que me familiaric√© con las instrucciones MMX, SSE y m√°s tarde AVX en los procesadores Intel. En un momento, parec√≠an una ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Acelere la multiplicaci√≥n de matriz flotante 4x4 con SIMD</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418247/">  Han pasado muchos a√±os desde que me familiaric√© con las instrucciones MMX, SSE y m√°s tarde AVX en los procesadores Intel.  En un momento, parec√≠an una especie de magia en el contexto del ensamblador x86, que durante mucho tiempo hab√≠a sido algo mundano.  Me engancharon tanto que hace un par de a√±os tuve la idea de escribir mi propio procesador de software para un juego famoso.  Lo que prometi√≥ estas instrucciones me prometi√≥ esto.  En alg√∫n momento, incluso pens√© en escribirlo.  Pero escribir texto result√≥ ser mucho m√°s complicado que el c√≥digo. <br><br>  En ese momento, quer√≠a evitar problemas con el soporte en diferentes procesadores.  Quer√≠a poder verificar mi procesador en la cantidad m√°xima disponible.  Todav√≠a tengo amigos con viejos procesadores AMD, y su techo era SSE3.  Por lo tanto, en ese momento decid√≠ limitarme a un m√°ximo de SSE3.  As√≠ que hab√≠a una biblioteca matem√°tica vectorial, un poco menos que totalmente implementada en SSE, con una rara inclusi√≥n antes de SSE3.  Sin embargo, en alg√∫n momento me pregunt√© qu√© rendimiento m√°ximo podr√≠a obtener del procesador para una serie de operaciones matem√°ticas de vectores cr√≠ticos.  Una de estas operaciones es multiplicar flotador 4 matrices por 4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/ii/cq/kgiicqemuc5agmypikedjioaogc.jpeg"></div><a name="habracut"></a><br>  En realidad, decid√≠ hacer este negocio m√°s por el entretenimiento.  Ya he escrito y he estado usando la multiplicaci√≥n de matrices para la representaci√≥n de mi software en SSE y parece ser suficiente para m√≠.  Pero luego decid√≠ ver cu√°ntas medidas puedo extraer en principio de multiplicar 2 matrices float4x4.  En mi SSE actual, estos son 16 ciclos de reloj.  Es cierto que la transici√≥n reciente a <abbr title="Analizador de c√≥digo de arquitectura Intel">IACA</abbr> 3 comenz√≥ a mostrar 19, ya que comenc√© a escribir 1 * para algunas instrucciones en lugar de 0 *.  Aparentemente antes era solo una falla en el analizador. <br><br><h3>  Brevemente sobre las utilidades utilizadas </h3><br>  Para el an√°lisis de c√≥digo utilic√© la famosa utilidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intel Architecture Code Analyzer</a> .  Para el an√°lisis, uso la arquitectura Haswell (HSW), como m√≠nimo con soporte para AVX2.  Escribir c√≥digo tambi√©n es muy conveniente de usar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intel Intrinsics Guide</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intel optimization manual</a> . <br><br>  Para el ensamblaje, uso MSVS 2017 Community desde la consola.  Escribo el c√≥digo en la versi√≥n con intr√≠nsecos.  Escribe una vez, y generalmente funciona de inmediato en diferentes plataformas.  Adem√°s, el compilador x64 VC ++ no es compatible con el ensamblador en l√≠nea, pero tambi√©n quiero que funcione con x64. <br><br>  Dado que este art√≠culo ya est√° un poco m√°s all√° del nivel de principiante en la programaci√≥n SIMD, no describir√© registros, instrucciones, dibujar√© (o afeitar√©) bellas im√°genes e intentar√© aprender a programar usando las instrucciones SIMD.  El sitio web de Intel est√° lleno de documentaci√≥n excelente, clara y detallada. <br><br><h2>  Quer√≠a hacer todo m√°s f√°cil ... Pero result√≥ como siempre </h2><br>  Aqu√≠ es donde comienza el momento, lo que complica mucho tanto la implementaci√≥n como el art√≠culo.  Por lo tanto, me detendr√© un poco.  No es interesante para m√≠ escribir multiplicaci√≥n matricial con un dise√±o de fila est√°ndar de elementos.  Qui√©n lo necesitaba, por lo que estudiaron en universidades o por su cuenta.  Nuestro objetivo es la productividad.  En primer lugar, cambi√© al dise√±o de columna hace mucho tiempo.  Mi renderizador de software se basa en la API de OpenGL y, por lo tanto, para evitar transposiciones innecesarias, comenc√© a almacenar elementos en columnas.  Esto tambi√©n es importante porque la multiplicaci√≥n de matrices no es tan cr√≠tica.  Bien multiplicado 2-5-10 matrices.  Y eso es todo.  Y luego multiplicamos la matriz terminada por miles o millones de v√©rtices.  Y esta operaci√≥n es mucho m√°s cr√≠tica.  Puedes, por supuesto, transponer cada vez.  Pero por qu√©, si esto se puede evitar. <br><br>  Pero volvamos a las matrices exclusivamente.  Determinamos el almacenamiento en columnas.  Sin embargo, puede ser a√∫n m√°s complicado.  Es m√°s conveniente para m√≠ almacenar los elementos superiores de vectores y filas de matriz en registros SIMD para que <strong>x est√©</strong> en el flotante m√°s alto (√≠ndice 3) <strong>yw</strong> en el menor (√≠ndice 0).  Aqu√≠, aparentemente, tendremos que retirarnos nuevamente sobre por qu√©. <br><br>  El problema es que en un renderizador de software en un vector tienes que manipular el componente <strong>w con</strong> m√°s frecuencia ( <strong>1 / z</strong> se almacena all√≠), y es muy conveniente hacerlo a trav√©s de la versi√≥n <strong>_ss</strong> de la operaci√≥n (operaciones exclusivamente con el componente en el flotador inferior del registro <em>xmm</em> ), sin tocar <strong><nobr>x, y, z</nobr></strong> .  Por lo tanto, en el registro SSE, el vector se almacena en un orden comprensible <strong><nobr>x, y, z, w</nobr></strong> , y en la memoria en el reverso <strong><nobr>w, z, y, x</nobr></strong> . <br><br>  Adem√°s, todas las opciones de multiplicaci√≥n tambi√©n se implementan mediante funciones individuales.  Esto se hace porque los uso para sustituir la opci√≥n deseada seg√∫n el tipo de instrucciones admitidas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bien descrito aqu√≠.</a> <br><br><h2>  Implementamos la funcionalidad b√°sica. </h2><br><h3>  Multiplicaci√≥n con bucles, fila ordenada </h3><br><div class="spoiler">  <b class="spoiler_title">Opci√≥n para dise√±o de l√≠nea de elementos.</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[i][j] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[i][j] += m[i][k] * n[k][j]; } } }</code> </pre> <br></div></div><br>  Aqu√≠ todo es simple y claro.  Para cada elemento hacemos 4 multiplicaciones y 3 sumas.  En total, son 64 multiplicaciones y 48 adiciones.  Y esto sin tener en cuenta la lectura de los elementos de registro. <br><br>  Todo es triste, en resumen.  Para esta opci√≥n, para el ciclo interno, IACA emiti√≥: <em>3.65 ciclos de reloj para ensamblaje x86 y 2.97 relojes para ensamblaje x64</em> .  No preguntes por qu√© n√∫meros fraccionarios.  No lo se  IACA 2.1 no sufri√≥ esto.  En cualquier caso, estos n√∫meros deben multiplicarse por aproximadamente 4 * 4 * 4 = 64. Incluso si toma x64, el resultado es de aproximadamente 192 medidas.  Est√° claro que esta es una estimaci√≥n aproximada.  No veo el punto de evaluar el rendimiento con mayor precisi√≥n para esta opci√≥n. <br><br><h3>  Implementaci√≥n de bucle, columna ordenada </h3><br><div class="spoiler">  <b class="spoiler_title">matriz transpuesta, reorganizar los √≠ndices de fila y columna</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[j][i] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[j][i] += m[k][i] * n[j][k]; } } }</code> </pre><br></div></div><br><h3>  Multiplicaci√≥n de ciclos, almacenamiento orientado a SIMD </h3><br><div class="spoiler">  <b class="spoiler_title">Se agrega el almacenamiento de l√≠neas en el orden inverso en la memoria</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] += m[k][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] * n[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-k]; } } }</code> </pre><br></div></div><br>  Esta implementaci√≥n simplifica un poco la comprensi√≥n de lo que est√° sucediendo en el interior, pero claramente no es suficiente. <br><br><h3>  Clases de ayuda </h3><br>  Para la conveniencia de comprender y escribir referencias y c√≥digos de depuraci√≥n, es conveniente implementar un par de clases auxiliares.  Nada m√°s, todo es solo para comprender.  Observo que la implementaci√≥n de clases de vectores y matrices completas es una pregunta dif√≠cil por separado, y no se incluye en el tema de este art√≠culo. <br><br><div class="spoiler">  <b class="spoiler_title">Clases vectoriales y matriciales</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alignas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(__m128))</span></span></span><span class="hljs-function"> vec4 </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> w, z, y, x; }; __m128 fmm; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> arr[<span class="hljs-number"><span class="hljs-number">4</span></span>]; }; vec4() {} vec4(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d) : w(d), z(c), y(b), x(a) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.00001</span></span></span></span><span class="hljs-function"><span class="hljs-params">f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(ab) &lt; t; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (vec4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; v) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> equ(x, vx) &amp;&amp; equ(y, vy) &amp;&amp; equ(z, vz) &amp;&amp; equ(w, vw); } }; <span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alignas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(__m256))</span></span></span><span class="hljs-function"> mtx4 </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//           union { struct { float _30, _20, _10, _00, _31, _21, _11, _01, _32, _22, _12, _02, _33, _23, _13, _03; }; __m128 r[4]; __m256 s[2]; vec4 v[4]; }; //    mtx4() {} mtx4( float i00, float i01, float i02, float i03, float i10, float i11, float i12, float i13, float i20, float i21, float i22, float i23, float i30, float i31, float i32, float i33) : _00(i00), _01(i01), _02(i02), _03(i03) , _10(i10), _11(i11), _12(i12), _13(i13) , _20(i20), _21(i21), _22(i22), _23(i23) , _30(i30), _31(i31), _32(i32), _33(i33) {} //      operator __m128 const* () const { return r; } operator __m128* () { return r; } //   bool operator == (mtx4 const&amp; m) const { return v[0]==mv[0] &amp;&amp; v[1]==mv[1] &amp;&amp; v[2]==mv[2] &amp;&amp; v[3]==mv[3]; } //  static mtx4 identity() { return mtx4( 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f); } static mtx4 zero() { return mtx4( 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f); } };</span></span></code> </pre><br></div></div><br><h3>  Funci√≥n de referencia para pruebas </h3><br>  Dado que el orden aceptado de los elementos en la matriz complica mucho la comprensi√≥n, tampoco nos molestar√° la funci√≥n <em>comprensible de</em> referencia, que mostrar√° en implementaciones futuras que todo funciona correctamente.  Compararemos los resultados posteriores con √©l. <br><br><div class="spoiler">  <b class="spoiler_title">Para crearlo, solo toma y expande el ciclo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_unroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _n)</span></span></span><span class="hljs-function"> </span></span>{ mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; m = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_m); mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; n = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_n); mtx4&amp; r = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_r); r._00 = m._00*n._00 + m._01*n._10 + m._02*n._20 + m._03*n._30; r._01 = m._00*n._01 + m._01*n._11 + m._02*n._21 + m._03*n._31; r._02 = m._00*n._02 + m._01*n._12 + m._02*n._22 + m._03*n._32; r._03 = m._00*n._03 + m._01*n._13 + m._02*n._23 + m._03*n._33; r._10 = m._10*n._00 + m._11*n._10 + m._12*n._20 + m._13*n._30; r._11 = m._10*n._01 + m._11*n._11 + m._12*n._21 + m._13*n._31; r._12 = m._10*n._02 + m._11*n._12 + m._12*n._22 + m._13*n._32; r._13 = m._10*n._03 + m._11*n._13 + m._12*n._23 + m._13*n._33; r._20 = m._20*n._00 + m._21*n._10 + m._22*n._20 + m._23*n._30; r._21 = m._20*n._01 + m._21*n._11 + m._22*n._21 + m._23*n._31; r._22 = m._20*n._02 + m._21*n._12 + m._22*n._22 + m._23*n._32; r._23 = m._20*n._03 + m._21*n._13 + m._22*n._23 + m._23*n._33; r._30 = m._30*n._00 + m._31*n._10 + m._32*n._20 + m._33*n._30; r._31 = m._30*n._01 + m._31*n._11 + m._32*n._21 + m._33*n._31; r._32 = m._30*n._02 + m._31*n._12 + m._32*n._22 + m._33*n._32; r._33 = m._30*n._03 + m._31*n._13 + m._32*n._23 + m._33*n._33; }</code> </pre><br></div></div><br>  El algoritmo cl√°sico est√° claramente pintado aqu√≠, es dif√≠cil cometer un error (pero puedes :-)).  En √©l, IACA emiti√≥: <em>x86 - 69.95 medidas, x64 - 64 medidas</em> .  Aqu√≠ hay unos 64 ciclos y veremos la aceleraci√≥n de esta operaci√≥n en el futuro. <br><br><h2>  Implementaci√≥n de SSE </h2><br><h3>  Algoritmo SSE cl√°sico </h3><br>  ¬øPor qu√© cl√°sico?  Porque ha estado en la implementaci√≥n de <em>FVec</em> como parte de MSVS.  Para comenzar, escribiremos c√≥mo presentamos los elementos de la matriz en los registros SSE.  Ya parece m√°s simple aqu√≠.  Solo una matriz transpuesta. <br><br><pre> <code class="plaintext hljs">//     00, 10, 20, 30 // m[0] -  SIMD /   01, 11, 21, 31 // m[1] 02, 12, 22, 32 // m[2] 03, 13, 23, 33 // m[3]</code> </pre><br>  Tomamos el c√≥digo de <em>desenrollado</em> de la variante anterior.  De alguna manera √©l es hostil para SSE.  El primer grupo de filas consiste en los resultados para la columna de la matriz resultante: <em><nobr>r._00, r._01, r._02, r._03</nobr></em> .  Tenemos esta columna, pero necesitamos una fila.  S√≠, y <strong>m</strong> , <strong>n</strong> parecen inconvenientes para los c√°lculos.  Por lo tanto, reorganizamos las l√≠neas del algoritmo para que el resultado <strong>r sea</strong> fila-sabio. <br><br><pre> <code class="plaintext hljs">//  ,     r[0] r00 = m00*n00 + m01*n10 + m02*n20 + m03*n30; r10 = m10*n00 + m11*n10 + m12*n20 + m13*n30; r20 = m20*n00 + m21*n10 + m22*n20 + m23*n30; r30 = m30*n00 + m31*n10 + m32*n20 + m33*n30; //  ,     r[1] r01 = m00*n01 + m01*n11 + m02*n21 + m03*n31; r11 = m10*n01 + m11*n11 + m12*n21 + m13*n31; r21 = m20*n01 + m21*n11 + m22*n21 + m23*n31; r31 = m30*n01 + m31*n11 + m32*n21 + m33*n31; //  ,     r[2] r02 = m00*n02 + m01*n12 + m02*n22 + m03*n32; r12 = m10*n02 + m11*n12 + m12*n22 + m13*n32; r22 = m20*n02 + m21*n12 + m22*n22 + m23*n32; r32 = m30*n02 + m31*n12 + m32*n22 + m33*n32; //  ,     r[3] r03 = m00*n03 + m01*n13 + m02*n23 + m03*n33; r13 = m10*n03 + m11*n13 + m12*n23 + m13*n33; r23 = m20*n03 + m21*n13 + m22*n23 + m23*n33; r33 = m30*n03 + m31*n13 + m32*n23 + m33*n33;</code> </pre><br>  Pero esto ya es mucho mejor.  ¬øQu√©, de hecho, vemos?  De acuerdo con las columnas del algoritmo en cada grupo, tenemos las filas de la matriz <strong>m</strong> involucradas: <br><pre> m [0] = {00,10,20,30}, m [1] = {01,11,21,31}, m [2] = {02,12,22,32}, m [3] = {03,13,23,33},
</pre>  que se multiplican por el mismo elemento de la matriz <strong>n</strong> .  Por ejemplo, para el primer grupo es: <em>n._00, n._10, n._20, n._30</em> .  Y los elementos de la matriz <strong>n</strong> para cada grupo de filas del algoritmo nuevamente se encuentran en una fila de la matriz. <br><br>  Entonces todo es simple: simplemente tomamos las filas de la matriz <strong>m</strong> por √≠ndice, pero en cuanto a los elementos <strong>n</strong> , tomamos su fila y la <em>barajamos</em> a trav√©s de los 4 elementos del registro a trav√©s de la instrucci√≥n de <em>barajar</em> , para multiplicar por la fila de la matriz <strong>m</strong> en el registro.  Por ejemplo, para el elemento <em>n._00</em> (recuerde que su desplazamiento en el registro tiene el √≠ndice 3), ser√°: <pre>  _mm_shuffle_ps (n [0], n [0], _MM_SHUFFLE (3,3,3,3)) </pre><br>  En una forma simplificada, el algoritmo se ve as√≠: <br><br><pre> <code class="plaintext hljs">//   n[0]={00,10,20,30} r[0] = m[0] * n00 + m[1] * n10 + m[2] * n20 + m[3] * n30; //   n[1]={01,11,21,31} r[1] = m[0] * n01 + m[1] * n11 + m[2] * n21 + m[3] * n31; //   n[2]={02,12,22,32} r[2] = m[0] * n02 + m[1] * n12 + m[2] * n22 + m[3] * n32; //   n[3]={03,13,23,33} r[3] = m[0] * n03 + m[1] * n13 + m[2] * n23 + m[3] * n33;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Implementaci√≥n b√°sica de SSE</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); }</code> </pre><br></div></div><br>  Ahora cambiamos los elementos <strong>n</strong> en el algoritmo a la <em>combinaci√≥n</em> <em>aleatoria</em> correspondiente, la multiplicaci√≥n por <em>_mm_mul_ps</em> , la suma por <em>_mm_add_ps</em> , y ya <em>est√°</em> .  Funciona  Sin embargo, el c√≥digo parece mucho peor de lo que parec√≠a el algoritmo.  Para este c√≥digo, IACA emiti√≥: <em>x86 - 18.89, x64 - 16 ciclos</em> .  Esto es 4 veces m√°s r√°pido que el anterior.  En SSE registre el 4 ¬∞ flotador.  Relaci√≥n casi lineal. <br><br><h4>  Decorar implementaci√≥n de SSE </h4><br>  A√∫n as√≠, en el c√≥digo se ve horrible.  Intentaremos mejorar esto escribiendo un poco de az√∫car sint√°ctica. <br><br><div class="spoiler">  <b class="spoiler_title">Operadores y Mejoradores</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        ( -    namespace) __m128 operator + (__m128 const a, __m128 const b) { return _mm_add_ps(a, b); } __m128 operator - (__m128 const a, __m128 const b) { return _mm_sub_ps(a, b); } __m128 operator * (__m128 const a, __m128 const b) { return _mm_mul_ps(a, b); } __m128 operator / (__m128 const a, __m128 const b) { return _mm_div_ps(a, b); } //_mm_shuffle_ps(u, v, _MM_SHUFFLE(3,2,1,0))   shuf&lt;3,2,1,0&gt;(u, v) template &lt;int a, int b, int c, int d&gt; __m128 shuf(__m128 const u, __m128 const v) { return _mm_shuffle_ps(u, v, _MM_SHUFFLE(a, b, c, d)); } template &lt;int a, int b, int c, int d&gt; __m128 shuf(__m128 const v) { return _mm_shuffle_ps(v, v, _MM_SHUFFLE(a, b, c, d)); } //    template &lt;int i&gt; __m128 shuf(__m128 const u, __m128 const v) { return _mm_shuffle_ps(u, v, _MM_SHUFFLE(i, i, i, i)); } template &lt;int i&gt; __m128 shuf(__m128 const v) { return _mm_shuffle_ps(v, v, _MM_SHUFFLE(i, i, i, i)); } //  float       , //    ,    template &lt;int a, int b, int c, int d&gt; __m128 shufd(__m128 const v) { return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v), _MM_SHUFFLE(a, b, c, d))); } template &lt;int i&gt; __m128 shufd(__m128 const v) { return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v), _MM_SHUFFLE(i, i, i, i))); }</span></span></code> </pre><br></div></div><br>  El compilador puede alinear perfectamente estas funciones (aunque a veces sin __forceinline de ninguna manera). <br><br><div class="spoiler">  <b class="spoiler_title">Entonces el c√≥digo est√° cambiando ...</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]); }</code> </pre><br></div></div><br>  Y as√≠, ya es mucho mejor y m√°s legible.  Para esto, IACA produjo aproximadamente el resultado esperado: <em>x86 - 19 (y ¬øpor qu√© no fraccional?), X64 - 16</em> .  De hecho, el rendimiento no ha cambiado, pero el c√≥digo es mucho m√°s hermoso y comprensible. <br><br><h4>  Poca contribuci√≥n a la optimizaci√≥n futura </h4><br>  Presentemos una mejora m√°s a nivel de una funci√≥n que apareci√≥ recientemente en la versi√≥n de hierro.  Operaci√≥n <em>de adici√≥n m√∫ltiple (fma)</em> .  <em><nobr>fma (a, b, c) = a * b + c</nobr></em> . <br><br><div class="spoiler">  <b class="spoiler_title">Implementaci√≥n de adici√≥n m√∫ltiple</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">m128 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm_add_ps(_mm_mul_ps(a, b), c); }</code> </pre><br></div></div><br>  ¬øPor qu√© es esto necesario?  En primer lugar, para una futura optimizaci√≥n.  Por ejemplo, simplemente puede reemplazar <em>mad</em> con <em>fma</em> en el c√≥digo terminado a trav√©s de las mismas macros que desee.  Pero sentaremos las bases para la optimizaci√≥n ahora: <br><br><div class="spoiler">  <b class="spoiler_title">Variante con adici√≥n m√∫ltiple</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>])); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  IACA: <em>x86 - 18.89, x64 - 16</em> .  De nuevo fraccional.  A√∫n as√≠, IACA a veces produce resultados extra√±os.  El c√≥digo no ha cambiado tanto.  Probablemente incluso un poco peor.  Pero la optimizaci√≥n a veces requiere tales sacrificios. <br><br><h4>  Pasamos al ahorro a trav√©s de _mm_stream </h4><br>  Varias gu√≠as de optimizaci√≥n recomiendan una vez m√°s no extraer el cach√© para operaciones de guardado masivo.  Esto generalmente se justifica cuando se procesan v√©rtices que son miles o m√°s.  Pero para las matrices, esto quiz√°s no sea tan importante.  Sin embargo, lo agregar√© de todos modos. <br><br><div class="spoiler">  <b class="spoiler_title">Opci√≥n de ahorro de flujo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">1</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">3</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]))); }</code> </pre><br></div></div><br>  Nada ha cambiado en el tiempo aqu√≠, de la palabra en absoluto.  Pero, de acuerdo con las recomendaciones, ahora no volvemos a tocar el cach√©. <br><br><h2>  Implementaci√≥n AVX </h2><br><h3>  Opci√≥n base AVX </h3><br><img src="https://habrastorage.org/webt/8d/l-/1r/8dl-1rgisfl2sqr0dhzmizkmawg.jpeg" align="right"><br>  A continuaci√≥n, pasamos a la siguiente etapa de optimizaci√≥n.  El 4 ¬∞ flotador est√° incluido en el registro SSE, y en el AVX ya es 8. Es decir, existe una posibilidad te√≥rica de reducir el n√∫mero de operaciones realizadas y aumentar la productividad, si no a la mitad, y luego al menos 1,5 veces.  Pero algo me dice que no todo ser√° tan simple con la transici√≥n a AVX.  ¬øPodemos obtener los datos necesarios de registros dobles? <br><br>  Tratemos de resolverlo.  Nuevamente, escribimos nuestro algoritmo de multiplicaci√≥n usado anteriormente.  No podr√≠a hacer esto, pero es m√°s conveniente lidiar con el c√≥digo cuando todo est√° cerca y no tiene que desplazarse media p√°gina hacia arriba. <br><br><pre> <code class="plaintext hljs">//    : 00, 10, 20, 30, 01, 11, 21, 31, 02, 12, 22, 32, 03, 13, 23, 33 //   SSE: r0 = m0*n00 + m1*n10 + m2*n20 + m3*n30 r1 = m0*n01 + m1*n11 + m2*n21 + m3*n31 r2 = m0*n02 + m1*n12 + m2*n22 + m3*n32 r3 = m0*n03 + m1*n13 + m2*n23 + m3*n33</code> </pre><br>  En la salida, esperamos obtener el resultado en <em><nobr>ymm = {r0: r1}</nobr></em> y <em><nobr>ymm = {r2: r3}</nobr></em> .  Si en la versi√≥n SSE nuestro algoritmo se generaliz√≥ a columnas, ahora necesitamos generalizarlo a filas.  Por lo tanto, actuar como en el caso de la opci√≥n SSE no funcionar√°. <br><br>  Si consideramos la matriz <strong>m</strong> en los registros <em>ymm</em> , obtenemos <em><nobr>ymm = {m0: m1}</nobr></em> e <em><nobr>ymm = {m2: m3},</nobr></em> respectivamente.  Anteriormente, solo ten√≠amos columnas matriciales en el registro, y ahora columnas y filas. <br><br>  Si intenta actuar como antes, debe multiplicar <em><nobr>ymm = {m0: m1}</nobr></em> por el registro <em><nobr>ymm = {n00, n00, n00, n00}: {n10, n10, n10, n10}</nobr></em> .  Dado que <em>n00</em> y <em>n01 est√°n</em> en la misma fila de la matriz <strong>n</strong> , a juzgar por el conjunto disponible de instrucciones AVX, dispersarlos por <em>ymm</em> ser√° costoso.  Tanto la <em>combinaci√≥n</em> <em>aleatoria</em> como la <em>permutaci√≥n</em> funcionan por separado para cada una de las cuatro patas de un flotador (alto y bajo <em>xmm</em> ) dentro de los registros <em>ymm</em> . <br><br>  Si tomamos <em>ymm</em> de la matriz <strong>n</strong> , obtenemos ambos elementos <em>n00</em> y <em>n10</em> en el m√°s alto de 2 <em>xmm</em> dentro del registro <em>ymm</em> .  <em><nobr>{n00, n10, n20, n30}: {n01, n11, n21, n31}</nobr></em> .  Por lo general, el √≠ndice para las instrucciones existentes es de 0 a 3. Y las direcciones flotan solo dentro de un registro <em>xmm</em> de dos dentro del registro <em>ymm</em> .  No es posible transferir <em>n10</em> del <em>xmm</em> m√°s <em>antiguo</em> al m√°s joven a <em>bajo precio</em> .  Y luego este enfoque debe repetirse varias veces.  No podemos soportar tal p√©rdida de medidas.  Es necesario llegar a algo m√°s. <br><br>  Sol√≠amos generalizar columnas, pero ahora filas.  Por lo tanto, intentaremos ir de una manera un poco diferente.  Necesitamos obtener el resultado en <em>{r0: r1}</em> .  Esto significa que el algoritmo debe mejorarse no en l√≠neas separadas del algoritmo, sino en dos a la vez.  Y aqu√≠, lo que fue una desventaja en el trabajo de <em>barajar</em> y <em>permutar</em> , ser√° una ventaja para nosotros.  Observamos lo que tendremos en los registros <em>ymm</em> cuando consideramos la matriz <strong>n</strong> . <br><br><pre> <code class="plaintext hljs">n0n1 = {00, 10, 20, 30} : {01, 11, 21, 31} n2n3 = {02, 12, 22, 32} : {03, 13, 23, 33}</code> </pre><br>  S√≠, notamos que en diferentes partes <em>xmm del</em> registro <em>ymm</em> tenemos los elementos <em>00</em> y <em>01</em> .  Se pueden multiplicar may√∫sculas y min√∫sculas mediante el comando permute en <em><nobr>{_00, _00, _00, _00}: {_ 01, _01, _01, _01}</nobr></em> , indicando solo un √≠ndice 3 para ambas partes <em>xmm</em> .  Esto es exactamente lo que necesitamos.  De hecho, los coeficientes tambi√©n se usan en diferentes l√≠neas.  Solo ahora en el registro <em>ymm</em> correspondiente para la multiplicaci√≥n ser√° necesario mantener <em>{m0: m0}</em> , es decir, la primera fila duplicada de la matriz <strong>m</strong> . <br><br>  Entonces, pintamos el algoritmo con m√°s detalle.  Leemos las filas dobles de la matriz <strong>m</strong> en registros <em>ymm</em> : <br><br><pre> <code class="plaintext hljs">mm[0] = {m0:m0} mm[1] = {m1:m1} mm[2] = {m2:m2} mm[3] = {m3:m3}</code> </pre><br>  Y luego calcularemos la multiplicaci√≥n como: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0] * {n00,n00,n00,n00:n01,n01,n01,n01} + // permute&lt;3,3,3,3&gt;(n0n1) mm[1] * {n10,n10,n10,n10:n11,n11,n11,n11} + // permute&lt;2,2,2,2&gt;(n0n1) mm[2] * {n20,n20,n20,n20:n21,n21,n21,n21} + // permute&lt;1,1,1,1&gt;(n0n1) mm[3] * {n30,n30,n30,n30:n31,n31,n31,n31} // permute&lt;0,0,0,0&gt;(n0n1) r2r3 = mm[0] * {n02,n02,n02,n02:n03,n03,n03,n03} + // permute&lt;3,3,3,3&gt;(n2n3) mm[1] * {n12,n12,n12,n12:n13,n13,n13,n13} + // permute&lt;2,2,2,2&gt;(n2n3) mm[2] * {n22,n22,n22,n22:n23,n23,n23,n23} + // permute&lt;1,1,1,1&gt;(n2n3) mm[3] * {n32,n32,n32,n32:n33,n33,n33,n33} // permute&lt;0,0,0,0&gt;(n2n3)</code> </pre><br>  Reescribimos m√°s claramente: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0]*n0n1&lt;3,3,3,3&gt;+mm[1]*n0n1&lt;2,2,2,2&gt;+mm[2]*n0n1&lt;1,1,1,1&gt;+mm[3]*n0n1&lt;0,0,0,0&gt; r2r3 = mm[0]*n2n3&lt;3,3,3,3&gt;+mm[1]*n2n3&lt;2,2,2,2&gt;+mm[2]*n2n3&lt;1,1,1,1&gt;+mm[3]*n2n3&lt;0,0,0,0&gt;</code> </pre><br>  O en forma simplificada: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0]*n0n1&lt;3&gt; + mm[1]*n0n1&lt;2&gt; + mm[2]*n0n1&lt;1&gt; + mm[3]*n0n1&lt;0&gt; r2r3 = mm[0]*n2n3&lt;3&gt; + mm[1]*n2n3&lt;2&gt; + mm[2]*n2n3&lt;1&gt; + mm[3]*n2n3&lt;0&gt;</code> </pre><br>  Todo parece estar claro. <br><br><div class="spoiler">  <b class="spoiler_title">Solo queda escribir una implementaci√≥n</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 mm0 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 mm1 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>]); __m256 mm2 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]); __m256 mm3 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], m[<span class="hljs-number"><span class="hljs-number">3</span></span>]); __m256 n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 y1 = _mm256_permute_ps(n0n1, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>);<span class="hljs-comment"><span class="hljs-comment">//3,3,3,3 __m256 y2 = _mm256_permute_ps(n0n1, 0xAA);//2,2,2,2 __m256 y3 = _mm256_permute_ps(n0n1, 0x55);//1,1,1,1 __m256 y4 = _mm256_permute_ps(n0n1, 0x00);//0,0,0,0 y1 = _mm256_mul_ps(y1, mm0); y2 = _mm256_mul_ps(y2, mm1); y3 = _mm256_mul_ps(y3, mm2); y4 = _mm256_mul_ps(y4, mm3); y1 = _mm256_add_ps(y1, y2); y3 = _mm256_add_ps(y3, y4); y1 = _mm256_add_ps(y1, y3); __m256 n2n3 = _mm256_load_ps(&amp;n[2].m128_f32[0]); __m256 y5 = _mm256_permute_ps(n2n3, 0xFF); __m256 y6 = _mm256_permute_ps(n2n3, 0xAA); __m256 y7 = _mm256_permute_ps(n2n3, 0x55); __m256 y8 = _mm256_permute_ps(n2n3, 0x00); y5 = _mm256_mul_ps(y5, mm0); y6 = _mm256_mul_ps(y6, mm1); y7 = _mm256_mul_ps(y7, mm2); y8 = _mm256_mul_ps(y8, mm3); y5 = _mm256_add_ps(y5, y6); y7 = _mm256_add_ps(y7, y8); y5 = _mm256_add_ps(y5, y7); _mm256_stream_ps(&amp;r[0].m128_f32[0], y1); _mm256_stream_ps(&amp;r[2].m128_f32[0], y5); }</span></span></code> </pre><br></div></div><br>  Aqu√≠ est√°n los n√∫meros interesantes de IACA: <em>x86 - 12.53, x64 - 12</em> .  Aunque, por supuesto, quer√≠a algo mejor.  Perd√≠ algo. <br><br><h3>  Optimizaci√≥n AVX m√°s az√∫car sint√°ctico </h3><br>  Parece que en el c√≥digo anterior, AVX no se utiliz√≥ en todo su potencial.  Encontramos que en lugar de establecer dos l√≠neas id√©nticas en el registro <strong>ymm</strong> , podemos usar <em>broadcast</em> , que puede llenar el registro <em>ymm</em> con dos valores <em>xmm</em> id√©nticos.  Adem√°s, en el camino, agregue algo de "az√∫car sint√°ctico" para las funciones AVX. <br><br><div class="spoiler">  <b class="spoiler_title">Implementaci√≥n AVX mejorada</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_add_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> - (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_sub_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_mul_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> / (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_div_ps(a, b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permute_ps(v, _MM_SHUFFLE(i, i, i, i)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permute_ps(v, _MM_SHUFFLE(a, b, c, d)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permutevar_ps(v, _mm256_set_epi32(i, i, i, i, j, j, j, j)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permutevar_ps(v, _mm256_set_epi32(a, b, c, d, e, f, g, h)); } __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_add_ps(_mm256_mul_ps(a, b), c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[] { _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">0</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">1</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">2</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">3</span></span>) }; __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ mad(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n2n3 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ mad(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  Y aqu√≠ los resultados ya son m√°s interesantes.  IACA produce n√∫meros: <em>x86 - 10, x64 - 8.58</em> , que se ve mucho mejor, pero a√∫n no 2 veces. <br><br><h3>  Opci√≥n AVX + FMA (final) </h3><br>  Hagamos un intento m√°s.  Ahora ser√≠a l√≥gico recuperar el conjunto de instrucciones de FMA nuevamente, ya que se agreg√≥ a los procesadores despu√©s de AVX.  Simplemente cambie <em>mul + add</em> individual para una operaci√≥n.  Aunque todav√≠a utilizamos las instrucciones de multiplicaci√≥n para dar al compilador m√°s oportunidades de optimizaci√≥n, y al procesador para la ejecuci√≥n paralela de multiplicaciones.  Por lo general, miro el c√≥digo generado en el ensamblador para asegurarme de qu√© opci√≥n es mejor. <br><br>  En este caso, necesitamos calcular <em><nobr>a * b + c * d + e * f + g * h</nobr></em> .  Puede hacer esta frente: <em><nobr>fma (a, b, fma (c, d, fma (e, f, g * h)))</nobr></em> .  Pero, como vemos, es imposible realizar una operaci√≥n aqu√≠ sin completar la anterior.  Y esto significa que no podremos usar la capacidad de hacer multiplicaciones emparejadas, como la tuber√≠a SIMD nos permite hacer.  Si transformamos ligeramente los c√°lculos <em><nobr>fma (a, b, c * d) + fma (e, f, g * h)</nobr></em> , veremos que podemos paralelizar los c√°lculos.  Primero haga dos multiplicaciones independientes, y luego dos operaciones <em>fma</em> independientes. <br><br><div class="spoiler">  <b class="spoiler_title">Implementaci√≥n AVX + FMA</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_fmadd_ps(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[]{ _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">0</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">1</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">2</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">3</span></span>) }; __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n2n3 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  IACA: <em>x86 - 9.21, x64 - 8</em> .  Ahora est√° muy bueno.  Alguien probablemente dir√° qu√© se puede hacer a√∫n mejor, pero no s√© c√≥mo. <br><br><h2>  Puntos de referencia </h2><br>  Noto de inmediato que estas cifras no deben tomarse como la verdad √∫ltima.  Incluso con una prueba fija, nadan dentro de ciertos l√≠mites.  Y a√∫n m√°s, se comportan de manera diferente en diferentes plataformas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Con cualquier optimizaci√≥n, tome medidas espec√≠ficamente para su caso. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tabla de contenidos </font></font></h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funci√≥n: nombre de la funci√≥n. </font><font style="vertical-align: inherit;">La terminaci√≥n en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funciona con una transmisi√≥n, mov diferente y normal (sin transmisi√≥n). </font><font style="vertical-align: inherit;">Agregado para mayor claridad, ya que esto es lo suficientemente importante.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ciclos de IACA: n√∫mero de ticks por funci√≥n calculados por IACA </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ciclos medidos: n√∫mero medido de medidas (menos es m√°s) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aceleraci√≥n de IACA: n√∫mero de medidas en una l√≠nea cero / n√∫mero de medidas en una l√≠nea </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aceleraci√≥n medida: n√∫mero de medidas en la l√≠nea cero / n√∫mero de medidas en la l√≠nea (cuanto m√°s, mejor) </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para loop_m, los ticks del art√≠culo se multiplicaron por 64. Es decir, este es un valor muy aproximado. </font><font style="vertical-align: inherit;">De hecho, result√≥ de esa manera.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> i3-3770: </font></font></h3><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funci√≥n </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ciclos IACA </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ciclos medidos </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IACA aceleraci√≥n </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aceleraci√≥n medida </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unroll_m </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 70,00 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 50,75 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.00 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.00 </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loop_m </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 233,60 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 119,21 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,30 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,43 </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sse_v1m </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18,89 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 27,51 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.70 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1,84 </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sse_v2m </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 19.00 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 27,61 </font></font></th><th> 3.68 </th><th> 1.84 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 27.22 </th><th> 3.70 </th><th> 1.86 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 27.18 </th><th> 3.70 </th><th> 1.87 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 19.21 </th><th> 5.38 </th><th> 2.64 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 20.03 </th><th> 5.38 </th><th> 2.53 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 12.91 </th><th> 6.99 </th><th> 3.93 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 17.34 </th><th> 6.99 </th><th> 2.93 </th></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x64</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th>  70 </th><th> 68.60 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 119.37 </th><th> 0.30 </th><th> 0.57 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 21.98 </th><th> 3.70 </th><th> 3.12 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 21.09 </th><th> 3.68 </th><th> 3.25 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 22.19 </th><th> 3.70 </th><th> 3.09 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 22.39 </th><th> 3.70 </th><th> 3.06 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 9.61 </th><th> 5.38 </th><th> 7.13 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 16.90 </th><th> 5.38 </th><th> 4.06 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 9.20 </th><th> 6.99 </th><th> 7.45 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 14.64 </th><th> 6.99 </th><th> 4.68 </th></tr></tbody></table></div></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> i7-8700K: </font></font></h3><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 69.95 </th><th> 40.25 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 79.49 </th><th> 0.30 </th><th> 0.51 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 19.31 </th><th> 3.70 </th><th> 2.09 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 19.98 </th><th> 3.68 </th><th> 2.01 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 19.69 </th><th> 3.70 </th><th> 2.04 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 19.67 </th><th> 3.70 </th><th> 2.05 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 14.22 </th><th> 5.38 </th><th> 2.83 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 14.13 </th><th> 5.38 </th><th> 2.85 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 11.73 </th><th> 6.99 </th><th> 3.43 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 11.81 </th><th> 6.99 </th><th> 3.41 </th></tr><tr><th> AVX+FMAm </th><th> 9.21 </th><th> 10.38 </th><th>  7.60 </th><th> 3.88 </th></tr><tr><th> AVX+FMAs </th><th> 9.21 </th><th> 10.32 </th><th>  7.60 </th><th> 3.90 </th></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x64</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 69.95 </th><th> 57.11 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 75.73 </th><th> 0.30 </th><th> 0.75 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 15.83 </th><th> 3.70 </th><th> 3.61 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 17.22 </th><th> 3.68 </th><th> 3.32 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 15.92 </th><th> 3.70 </th><th> 3.59 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 16.18 </th><th> 3.70 </th><th> 3.53 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 7.03 </th><th> 5.38 </th><th> 8.12 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 12.98 </th><th> 5.38 </th><th> 4.40 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 5.40 </th><th> 6.99 </th><th> 10.57 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 11.39 </th><th> 6.99 </th><th> 5.01 </th></tr><tr><th> AVX+FMAm </th><th> 9.21 </th><th> 9.73 </th><th>  7.60 </th><th> 5.87 </th></tr><tr><th> AVX+FMAs </th><th> 9.21 </th><th> 9.81 </th><th>  7.60 </th><th> 5.82 </th></tr></tbody></table></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√≥digo de prueba en fuente. </font><font style="vertical-align: inherit;">Si hay sugerencias razonables sobre c√≥mo mejorarlas, escriba los comentarios.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BONIFICACI√ìN del reino de la ficci√≥n. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En realidad, es del reino de la ficci√≥n porque si vi procesadores con soporte para AVX512, tal vez en las im√°genes. </font><font style="vertical-align: inherit;">Sin embargo, intent√© implementar el algoritmo. </font><font style="vertical-align: inherit;">Aqu√≠ no explicar√© nada, una analog√≠a completa con AVX + FMA. </font><font style="vertical-align: inherit;">El algoritmo es el mismo, solo que menos operaciones.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como dicen, lo dejar√© aqu√≠</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">__m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_add_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> - (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_sub_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_mul_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> / (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_div_ps(a, b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i&gt; __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_permute_ps(v, _MM_SHUFFLE(i, i, i, i)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d&gt; __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_permute_ps(v, _MM_SHUFFLE(a, b, c, d)); } __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_fmadd_ps(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx512</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _n)</span></span></span><span class="hljs-function"> </span></span>{ __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[]{ _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">0</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">1</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">2</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">3</span></span>]) }; __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n = _mm512_load_ps(&amp;_n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm512_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los n√∫meros son fant√°sticos: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86 - 4.79, x64 - 5.42</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (IACA con arquitectura SKX). </font><font style="vertical-align: inherit;">Esto a pesar del hecho de que el algoritmo tiene 64 multiplicaciones y 48 adiciones.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo PS del art√≠culo </font></font></h2><br><div class="oembed"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/truthfinder/mul_m4_m4</font></font></a> </div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es mi primera experiencia escribiendo un art√≠culo. </font><font style="vertical-align: inherit;">Gracias a todos por sus comentarios. </font><font style="vertical-align: inherit;">Ayudan a mejorar el c√≥digo y el art√≠culo.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418247/">https://habr.com/ru/post/es418247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418237/index.html">Desarrollo de aplicaciones multiinquilino en la plataforma SAP Cloud en Neo, Parte 2: Autorizaci√≥n y autenticaci√≥n</a></li>
<li><a href="../es418239/index.html">48 megap√≠xeles para tel√©fono inteligente</a></li>
<li><a href="../es418241/index.html">¬øPor qu√© gauss? (100 formas de resolver el sistema de ecuaciones)</a></li>
<li><a href="../es418243/index.html">La historia popular de la astronom√≠a est√° equivocada</a></li>
<li><a href="../es418245/index.html">C√≥mo no desarrollar un proyecto en Bitrix</a></li>
<li><a href="../es418249/index.html">Nuevas im√°genes de VM de Google Compute Engine para aprendizaje profundo</a></li>
<li><a href="../es418251/index.html">Visi√≥n por computadora: c√≥mo nos observa AI</a></li>
<li><a href="../es418253/index.html">La luna temprana podr√≠a tener agua, atm√≥sfera y vida.</a></li>
<li><a href="../es418255/index.html">C√≥mo los intercambios de tr√°fico revenden autosurfing y de d√≥nde provienen millones de bots en l√≠nea</a></li>
<li><a href="../es418257/index.html">Github.com se niega a usar jQuery y cambia a JavaScript puro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>