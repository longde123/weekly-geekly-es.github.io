<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏾 🍌 🏽 Bagaimana Python membantu menggantikan konsultan keuangan 🎬 👩‍💼 🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk melanjutkan artikel tentang bahaya diversifikasi berlebihan, kami akan membuat alat pemilihan stok yang berguna. Setelah itu, kami akan membuat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana Python membantu menggantikan konsultan keuangan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419979/"> Untuk melanjutkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang bahaya diversifikasi berlebihan, kami akan membuat alat pemilihan stok yang berguna.  Setelah itu, kami akan membuat penyeimbangan ulang sederhana dan menambahkan kondisi unik dari indikator teknis, yang seringkali kurang dalam layanan populer.  Dan kemudian membandingkan pengembalian aset individu dan portofolio berbeda. <br><br>  Dalam semua ini kami menggunakan Panda dan meminimalkan jumlah siklus.  Kelompokkan deret waktu dan gambarkan grafiknya.  Mari berkenalan dengan multi-indeks dan perilaku mereka.  Dan semua ini di Jupyter dengan Python 3.6. <br><a name="habracut"></a><br><blockquote>  Jika Anda ingin melakukan sesuatu dengan baik, lakukan sendiri. <br>  Ferdinand Porsche </blockquote><br>  Alat yang dijelaskan akan memungkinkan Anda untuk memilih aset yang optimal untuk portofolio dan mengecualikan alat yang dikenakan oleh konsultan.  Tetapi kita hanya akan melihat gambaran besarnya - tanpa memperhitungkan likuiditas akun, waktu untuk merekrut posisi, komisi broker dan biaya satu saham.  Secara umum, dengan penyeimbangan ulang bulanan atau tahunan dari broker besar itu akan menjadi biaya yang tidak signifikan.  Namun, sebelum menerapkan, strategi yang dipilih harus tetap diperiksa di backtester yang digerakkan oleh peristiwa, misalnya, Quantopian (QP), untuk menghilangkan potensi kesalahan. <br><br>  Kenapa tidak segera di QP?  Waktu  Di sana, tes paling sederhana berlangsung sekitar 5 menit.  Dan solusi saat ini akan memungkinkan Anda untuk memeriksa ratusan strategi berbeda dengan kondisi unik dalam satu menit. <br><br><h2>  Memuat data mentah </h2><br>  Untuk memuat data, ambil metode yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini.  Saya menggunakan PostgreSQL untuk menyimpan harga harian, tetapi sekarang penuh dengan sumber gratis dari mana Anda dapat membuat DataFrame yang diperlukan. <br><br>  Kode untuk mengunduh riwayat harga dari database tersedia di repositori.  Tautan akan berada di akhir artikel. <br><br><h2>  Struktur DataFrame </h2><br>  Ketika bekerja dengan riwayat harga, untuk pengelompokan yang nyaman dan akses ke semua data, solusi terbaik adalah dengan menggunakan multi-indeks (MultiIndex) dengan tanggal dan ticker. <br><br><pre><code class="python hljs">df = df.set_index([<span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-string"><span class="hljs-string">'symbol'</span></span>], drop=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>).sort_index() df.tail(len(df.index.levels[<span class="hljs-number"><span class="hljs-number">1</span></span>]) * <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e63/f7d/80a/e63f7d80a7d25c5099c940b03cd38e33.png" alt="gambar"><br><br>  Dengan menggunakan multi-indeks, kita dapat dengan mudah mengakses seluruh riwayat harga untuk semua aset dan dapat mengelompokkan array secara terpisah berdasarkan tanggal dan aset.  Kami juga bisa mendapatkan riwayat harga untuk satu aset. <br><br>  Berikut adalah contoh bagaimana Anda dapat dengan mudah mengelompokkan riwayat berdasarkan minggu, bulan, dan tahun.  Dan untuk menunjukkan semua ini pada grafik oleh pasukan Pandas: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      agg_rules = { 'dt': 'last', 'symbol': 'last', 'open': 'first', 'high': 'max', 'low': 'min', 'close': 'last', 'volume': 'sum', 'adj': 'last' } level_values = df.index.get_level_values #  fig = plt.figure(figsize=(15, 3), facecolor='white') df.groupby([pd.Grouper(freq='W', level=0)] + [level_values(i) for i in [1]]).agg( agg_rules).set_index(['dt', 'symbol'], drop=False ).close.unstack(1).plot(ax=fig.add_subplot(131), title="Weekly") df.groupby([pd.Grouper(freq='M', level=0)] + [level_values(i) for i in [1]]).agg( agg_rules).set_index(['dt', 'symbol'], drop=False ).close.unstack(1).plot(ax=fig.add_subplot(132), title="Monthly") df.groupby([pd.Grouper(freq='Y', level=0)] + [level_values(i) for i in [1]]).agg( agg_rules).set_index(['dt', 'symbol'], drop=False ).close.unstack(1).plot(ax=fig.add_subplot(133), title="Yearly") plt.show()</span></span></code> </pre> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f7/af2/5da/6f7af25dae49fd088111cc457143ae34.png" alt="gambar"><br><br>  Untuk menampilkan area dengan legenda grafik dengan benar, kami mentransfer level indeks dengan ticker ke level kedua di atas kolom menggunakan perintah Series (). Unstack (1).  Dengan DataFrame (), angka seperti itu tidak akan berfungsi, tetapi solusinya ada di bawah. <br><br>  Ketika dikelompokkan berdasarkan periode standar, Pandas menggunakan tanggal kalender terbaru dari grup dalam indeks, yang sering berbeda dari tanggal sebenarnya.  Untuk memperbaikinya, perbarui indeks. <br><br><pre> <code class="python hljs">monthly = df.groupby([pd.Grouper(freq=<span class="hljs-string"><span class="hljs-string">'M'</span></span>, level=<span class="hljs-number"><span class="hljs-number">0</span></span>), level_values(<span class="hljs-number"><span class="hljs-number">1</span></span>)]).agg(agg_rules) \ .set_index([<span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-string"><span class="hljs-string">'symbol'</span></span>], drop=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre> <br>  Contoh memperoleh riwayat harga aset tertentu (kami mengambil semua tanggal, ticker QQQ, dan semua kolom): <br><br><pre> <code class="python hljs">monthly.loc[(slice(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>), [<span class="hljs-string"><span class="hljs-string">'QQQ'</span></span>]), :] <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre> <br><h2>  Volatilitas aset bulanan </h2><br>  Sekarang kita dapat melihat beberapa baris pada grafik perubahan harga setiap aset untuk periode yang menarik bagi kita.  Untuk melakukan ini, kami mendapatkan persentase perubahan harga dengan mengelompokkan kerangka data berdasarkan tingkat multi-indeks dengan ticker aset. <br><br><pre> <code class="python hljs">monthly = df.groupby([pd.Grouper(freq=<span class="hljs-string"><span class="hljs-string">'M'</span></span>, level=<span class="hljs-number"><span class="hljs-number">0</span></span>), level_values(<span class="hljs-number"><span class="hljs-number">1</span></span>)]).agg( agg_rules).set_index([<span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-string"><span class="hljs-string">'symbol'</span></span>], drop=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-comment"><span class="hljs-comment">#     .   . monthly['pct_close'] = monthly.groupby(level=1)['close'].pct_change().fillna(0) #  ax = monthly.pct_close.unstack(1).plot(title="Monthly", figsize=(15, 4)) ax.axhline(0, color='k', linestyle='--', lw=0.5) plt.show()</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/284/7b8/23b/2847b823be4247ecf47418120b78cb15.png" alt="gambar"><br><br><h2>  Bandingkan pengembalian aset </h2><br>  Sekarang kita akan menggunakan metode jendela Series (). Rolling () dan menampilkan pengembalian aset untuk periode tertentu: <br><br><div class="spoiler">  <b class="spoiler_title">Kode python</b> <div class="spoiler_text"><pre> <code class="python hljs">rolling_prod = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.rolling(len(x), min_periods=<span class="hljs-number"><span class="hljs-number">1</span></span>).apply(np.prod) <span class="hljs-comment"><span class="hljs-comment">#   monthly = df.groupby([pd.Grouper(freq='M', level=0), level_values(1)]).agg( agg_rules).set_index(['dt', 'symbol'], drop=False) #     .   .   1. monthly['pct_close'] = monthly.groupby(level=1)['close'].pct_change().fillna(0) + 1 #  DataFrame    2007  fltr = monthly.dt &gt;= '2007-01-01' test = monthly[fltr].copy().set_index(['dt', 'symbol'], drop=False) #  dataframe    test.loc[test.index.levels[0][0], 'pct_close'] = 1 #    1 #    test['performance'] = test.groupby(level=1)['pct_close'].transform(rolling_prod) - 1 #  ax = test.performance.unstack(1).plot(title="Performance (Monthly) from 2007-01-01", figsize=(15, 4)) ax.axhline(0, color='k', linestyle='--', lw=0.5) plt.show() #       test.tail(len(test.index.levels[1])).sort_values('performance', ascending=False)</span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/getpro/habr/post_images/3a0/07d/83c/3a007d83c19b3635f969351d3b288818.png" alt="gambar"><br><br><h2>  Metode penyeimbangan ulang portofolio </h2><br>  Jadi kami mendapat yang paling enak.  Dalam contoh, kita akan melihat hasil portofolio dalam alokasi modal untuk saham yang telah ditentukan antara beberapa aset.  Dan juga menambahkan kondisi unik di mana kita akan meninggalkan beberapa aset pada saat distribusi modal.  Jika tidak ada aset yang sesuai, maka kami mengasumsikan bahwa broker memiliki modal dalam cache. <br><br>  Untuk menggunakan metode Pandas untuk penyeimbangan kembali, kita perlu menyimpan pembagian distribusi dan kondisi penyeimbangan kembali dalam DataFrame dengan data yang dikelompokkan.  Sekarang pertimbangkan fungsi penyeimbangan ulang yang akan kami sampaikan ke metode DataFrame (). Terapkan (): <br><br><div class="spoiler">  <b class="spoiler_title">Kode python</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rebalance_simple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     data = x.unstack(1) return (data.pct_close * data['size']).sum() / data['size'].sum() def rebalance_sma(x): #   ,   SMA50 &gt; SMA200 data = x.unstack(1) fltr = data['sma50'] &gt; data['sma200'] if not data[fltr]['size'].sum(): return 1 #   ,    return (data[fltr].pct_close * data[fltr]['size']).sum() / data[fltr]['size'].sum() def rebalance_rsi(x): #   ,   RSI100 &gt; 50 data = x.unstack(1) fltr = data['rsi100'] &gt; 50 if not data[fltr]['size'].sum(): return 1 #   ,    return (data[fltr].pct_close * data[fltr]['size']).sum() / data[fltr]['size'].sum() def rebalance_custom(x, df=None): #         data = x.unstack(1) for s in data.index: if data['dt'][s]: fltr_dt = df['dt'] &lt; data['rebalance_dt'][s] #   values = df[fltr_dt].loc[(slice(None), [s]), 'close'].values data.loc[s, 'custom'] = 0 #    if len(values) &gt; len(values[np.isnan(values)]): #  RSI  100  data.loc[s, 'custom'] = talib.RSI(values, timeperiod=100)[-1] fltr = data['custom'] &gt; 50 if not data[fltr]['size'].sum(): return 1 #   ,    return (data[fltr].pct_close * data[fltr]['size']).sum() / data[fltr]['size'].sum() def drawdown(chg, is_max=False): #    total = len(chg.index) rolling_max = chg.rolling(total, min_periods=1).max() daily_drawdown = chg/rolling_max - 1.0 if is_max: return daily_drawdown.rolling(total, min_periods=1).min() return daily_drawdown</span></span></code> </pre> <br></div></div><br>  Dalam rangka: <br><br><ul><li>  rebalance_simple adalah fungsi paling sederhana yang akan mendistribusikan profitabilitas setiap aset dalam saham. </li><li>  rebalance_sma adalah fungsi yang mendistribusikan modal di antara aset yang rata-rata bergeraknya 50 hari lebih tinggi dari 200 hari pada saat rebalancing. </li><li>  rebalance_rsi - fungsi yang mendistribusikan modal di antara aset yang nilai indikator RSI untuk 100 hari di atas 50. </li><li>  rebalance_custom adalah fungsi paling lambat dan paling universal, di mana kami akan menghitung nilai indikator dari riwayat harga aset harian pada saat rebalancing.  Di sini Anda dapat menggunakan kondisi dan data apa pun.  Bahkan unduh setiap waktu dari sumber eksternal.  Tetapi Anda tidak dapat melakukannya tanpa siklus. </li><li>  drawdown - fungsi tambahan, menunjukkan drawdown maksimum dalam portofolio. </li></ul><br>  Dalam fungsi penyeimbangan kembali, kita membutuhkan larik semua data untuk tanggal menurut aset.  Metode DataFrame (). Apply (), dimana kami akan menghitung hasil dari portofolio, akan meneruskan array ke fungsi kami, di mana kolom akan menjadi indeks baris.  Dan jika kita membuat multi-indeks, di mana tickers akan menjadi level nol, maka multi-indeks akan datang kepada kita.  Kami dapat memperluas multi-indeks ini menjadi array dua dimensi dan mendapatkan data aset terkait pada setiap baris. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa8/2d1/d1c/fa82d1d1ca7cfca3f8f554e46f8e433a.png" alt="gambar"><br><br><h2>  Penyeimbangan ulang portofolio </h2><br>  Sekarang cukup untuk menyiapkan kondisi yang diperlukan dan membuat perhitungan untuk setiap portofolio dalam siklus.  Pertama-tama, kami menghitung indikator pada riwayat harga harian: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    1  ,      df['sma50'] = df.groupby(level=1)['close'].transform(lambda x: talib.SMA(x.values, timeperiod=50)).shift(1) df['sma200'] = df.groupby(level=1)['close'].transform(lambda x: talib.SMA(x.values, timeperiod=200)).shift(1) df['rsi100'] = df.groupby(level=1)['close'].transform(lambda x: talib.RSI(x.values, timeperiod=100)).shift(1)</span></span></code> </pre> <br>  Sekarang kita akan mengelompokkan cerita untuk periode penyeimbangan yang diinginkan menggunakan metode yang dijelaskan di atas.  Pada saat yang sama, kami akan mengambil nilai indikator di awal periode untuk mengecualikan melihat ke masa depan. <br><br>  Kami menggambarkan struktur portofolio dan menunjukkan penyeimbangan kembali yang diinginkan.  Kami akan menghitung portofolio dalam satu siklus, karena kami perlu menentukan bagian dan kondisi unik: <br><br><div class="spoiler">  <b class="spoiler_title">Kode python</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  :  ,  ,  portfolios = [ {'symbols': [('SPY', 0.8), ('AGG', 0.2)], 'func': rebalance_sma, 'name': 'Portfolio 80/20 SMA50x200'}, {'symbols': [('SPY', 0.8), ('AGG', 0.2)], 'func': rebalance_rsi, 'name': 'Portfolio 80/20 RSI100&gt;50'}, {'symbols': [('SPY', 0.8), ('AGG', 0.2)], 'func': partial(rebalance_custom, df=df), 'name': 'Portfolio 80/20 Custom'}, {'symbols': [('SPY', 0.8), ('AGG', 0.2)], 'func': rebalance_simple, 'name': 'Portfolio 80/20'}, {'symbols': [('SPY', 0.4), ('AGG', 0.6)], 'func': rebalance_simple, 'name': 'Portfolio 40/60'}, {'symbols': [('SPY', 0.2), ('AGG', 0.8)], 'func': rebalance_simple, 'name': 'Portfolio 20/80'}, {'symbols': [('DIA', 0.2), ('QQQ', 0.3), ('SPY', 0.2), ('IWM', 0.2), ('AGG', 0.1)], 'func': rebalance_simple, 'name': 'Portfolio DIA &amp; QQQ &amp; SPY &amp; IWM &amp; AGG'}, ] for p in portfolios: #    rebalance['size'] = 0. for s, pct in p['symbols']: #       rebalance.loc[(slice(None), [s]), 'size'] = pct #            rebalance_perf = rebalance.stack().unstack([1, 2]).apply(p['func'], axis=1) #    p['performance'] = (rebalance_perf.rolling(len(rebalance_perf), min_periods=1).apply(np.prod) - 1) #    p['drawdown'] = drawdown(p['performance'] + 1, is_max=True)</span></span></code> </pre> <br></div></div><br>  Kali ini kita perlu melakukan trik dengan indeks kolom dan baris untuk mendapatkan multi-indeks yang diinginkan dalam fungsi penyeimbangan kembali.  Kami akan mencapai ini dengan memanggil metode DataFrame (). Stack (). Unstack ([1, 2]) secara berurutan.  Kode ini akan mentransfer kolom ke multi-indeks huruf kecil, dan kemudian mengembalikan multi-indeks dengan ticker dan kolom dalam urutan yang diinginkan. <br><br><h2>  Tas kerja yang sudah jadi untuk bagan </h2><br>  Sekarang tinggal menggambar semuanya.  Untuk melakukan ini, jalankan siklus portofolio lagi, yang menampilkan data pada grafik.  Pada akhirnya kami akan menggambar SPY sebagai patokan untuk perbandingan. <br><br><div class="spoiler">  <b class="spoiler_title">Kode python</b> <div class="spoiler_text"><pre> <code class="python hljs">fig = plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), facecolor=<span class="hljs-string"><span class="hljs-string">'white'</span></span>) ax_perf = fig.add_subplot(<span class="hljs-number"><span class="hljs-number">121</span></span>) ax_dd = fig.add_subplot(<span class="hljs-number"><span class="hljs-number">122</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> portfolios: p[<span class="hljs-string"><span class="hljs-string">'performance'</span></span>].rename(p[<span class="hljs-string"><span class="hljs-string">'name'</span></span>]).plot(ax=ax_perf, legend=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, title=<span class="hljs-string"><span class="hljs-string">'Performance'</span></span>) p[<span class="hljs-string"><span class="hljs-string">'drawdown'</span></span>].rename(p[<span class="hljs-string"><span class="hljs-string">'name'</span></span>]).plot(ax=ax_dd, legend=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, title=<span class="hljs-string"><span class="hljs-string">'Max drawdown'</span></span>) <span class="hljs-comment"><span class="hljs-comment">#       print(f"{p['name']}: {p['performance'][-1]*100:.2f}% / {p['drawdown'][-1]*100:.2f}%") # SPY,   rebalance.loc[(slice(None), ['SPY']), :].set_index('dt', drop=False).performance. \ rename('SPY').plot(ax=ax_perf, legend=True) drawdown(rebalance.loc[(slice(None), ['SPY']), :].set_index('dt', drop=False).performance + 1, is_max=True).rename('SPY').plot(ax=ax_dd, legend=True) ax_perf.axhline(0, color='k', linestyle='--', lw=0.5) ax_dd.axhline(0, color='k', linestyle='--', lw=0.5) plt.show()</span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/getpro/habr/post_images/c68/2e2/870/c682e287032885dea4b266758934f7e5.png" alt="gambar"><br><br><h2>  Kesimpulan </h2><br>  Kode yang dipertimbangkan memungkinkan Anda untuk memilih berbagai struktur portofolio dan kondisi penyeimbangan kembali.  Dengan bantuannya, Anda dapat dengan cepat memeriksa apakah, misalnya, ada baiknya memegang emas (GLD) atau pasar berkembang (EEM) dalam portofolio.  Cobalah sendiri, tambahkan kondisi Anda sendiri untuk indikator atau pilih parameter yang sudah dijelaskan.  (Tapi ingat kesalahan penyintas dan bahwa pemasangan data masa lalu mungkin tidak sesuai dengan harapan di masa depan.) Dan kemudian memutuskan kepada siapa Anda mempercayai portofolio Anda - Python atau konsultan keuangan? <br><br>  Repositori: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rebalance.portfolio</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419979/">https://habr.com/ru/post/id419979/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419969/index.html">Penyembunyian di Ruby. Juga sembunyikan kelas dari Top-Level</a></li>
<li><a href="../id419971/index.html">Laboratorium roket memperbaiki, memperluas, dan mempercepat</a></li>
<li><a href="../id419973/index.html">Acara digital di Moskow dari 13 hingga 19 Agustus</a></li>
<li><a href="../id419975/index.html">Bagaimana kami lari dari perusahaan Windows</a></li>
<li><a href="../id419977/index.html">Peneliti: Tidak semua autopilot Level 2 bekerja dengan baik, tetapi kemajuan terbukti</a></li>
<li><a href="../id419981/index.html">Langit malam atau mencari perseid</a></li>
<li><a href="../id419983/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 326 (6 - 12 Agustus 2018)</a></li>
<li><a href="../id419985/index.html">Klats, klats: kisah Cherry, yang menjadi terkenal karena sakelar keyboard</a></li>
<li><a href="../id419987/index.html">Apa tetes darah akan kirim: trigonometri kejahatan</a></li>
<li><a href="../id419989/index.html">Selandia Baru melarang kantong plastik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>