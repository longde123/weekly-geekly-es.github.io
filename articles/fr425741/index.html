<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔬 👵🏼 💽 Docotic.Pdf: Quels problèmes PVS-Studio détecte-t-il dans un projet mature? 👧🏿 🐍 👩🏿‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La qualité est importante pour nous. Et nous avons entendu parler de PVS-Studio. Tout cela a conduit à vouloir vérifier Docotic.Pdf et à découvrir quo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docotic.Pdf: Quels problèmes PVS-Studio détecte-t-il dans un projet mature?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425741/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/fj/-u/ttfj-uhwy2ogamewgz6zit48lni.png" alt="Docotic.Pdf et PVS-studio"></div><br>  La qualité est importante pour nous.  Et nous avons entendu parler de PVS-Studio.  Tout cela a conduit à vouloir vérifier Docotic.Pdf et à découvrir quoi d'autre pourrait être amélioré. <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docotic.Pdf</a> est une bibliothèque polyvalente pour travailler avec des fichiers PDF.  Il est écrit en C #, il n'y a pas de code dangereux, pas de dépendances externes autres que le runtime .NET.  Il fonctionne à la fois sous .NET 4+ et sous .NET Standard 2+. <br><br>  La bibliothèque est en développement depuis un peu plus de 10 ans et compte 110 000 lignes de code sans prendre en compte les tests, les exemples et autres.  Pour l'analyse statique, nous utilisons constamment l'analyse de code et StyleCop.  Plusieurs milliers de tests automatisés nous protègent des régressions.  Nos clients de différents pays et de différentes industries font confiance à la qualité de la bibliothèque. <br><br>  Quels problèmes détectera PVS-Studio? <br><br><h3>  Installation et première impression </h3><br>  J'ai téléchargé la version d'essai sur le site Web de PVS-Studio.  Agréablement surpris par la petite taille de l'installateur.  Installé avec les paramètres par défaut: moteurs d'analyse, un environnement PVS-Studio séparé, intégration dans Visual Studio 2017. <br><br>  Après l'installation, rien n'a commencé et deux raccourcis avec les mêmes icônes ont été ajoutés au menu Démarrer: autonome et PVS-Studio.  Pendant un moment, j'ai pensé par où commencer.  Lancement autonome et a été désagréablement surpris par l'interface.  L'échelle de 200% définie pour mon Windows est prise en charge de manière tordue.  Une partie du texte est trop petite, une partie du texte ne tient pas dans l'espace prévu à cet effet.  Le nom, la licorne et la liste des actions sont rognés pour n'importe quelle taille de fenêtre.  Même en plein écran. <br><br><img src="https://habrastorage.org/webt/ll/3k/c5/ll3kc5bovj5wkbvtldfz9zhzpzk.png"><br><br>  Bon, d'accord, j'ai décidé d'ouvrir mon dossier de projet.  Du coup, le menu Fichier n'a pas trouvé une telle opportunité.  Là, on m'a seulement proposé d'ouvrir des fichiers individuels.  Merci, j'ai pensé, je préfère essayer une autre option.  Lancement de PVS-Studio - ils m'ont montré une fenêtre avec du texte flou.  L'échelle de 200% s'est de nouveau fait sentir.  Le texte a rapporté: <s>recherchez-moi dans Three Crowns,</s> recherchez le menu PVS-Studio dans Visual Studio.  Ok, a ouvert le Studio. <br><br>  Solution ouverte.  En effet, il existe un menu PVS-Studio, et il a la possibilité de vérifier le «Projet en cours».  Il a réalisé le projet dont j'avais besoin et a lancé un chèque.  Une fenêtre est apparue dans le Studio avec les résultats de l'analyse.  Une fenêtre est apparue en arrière-plan avec la progression de l'analyse, mais je ne l'ai pas immédiatement trouvée.  Au début, on avait le sentiment que le contrôle n'avait pas commencé ou s'était terminé immédiatement. <br><br><h3>  Résultat du premier contrôle </h3><br>  L'analyseur a vérifié tous les 1253 fichiers de projet en environ 9 minutes et 30 secondes.  À la fin de la vérification, le compteur de fichiers n'a pas changé aussi rapidement qu'au début.  Il existe peut-être une dépendance non linéaire de la durée d'analyse sur le nombre de fichiers analysés. <br><br>  Des informations sur 81 avertissements élevés, 109 moyens et 175 faibles sont apparues dans la fenêtre des résultats.  Si vous calculez la fréquence, vous obtenez 0,06 avertissements élevés / fichier, 0,09 avertissements moyens / fichier et 0,14 avertissements bas / fichier.  Ou <br>  0,74 Avertissements élevés pour mille lignes de code, 0,99 Avertissements moyens pour mille lignes de code et 1,59 Avertissements faibles pour mille lignes de code. <br><br>  Ici, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cet article</a> , il est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">indiqué</a> que dans CruiseControl.NET, avec ses 256 mille lignes de code, l'analyseur a trouvé 15 avertissements High, 151 Medium et 32 ​​Low. <br><br>  Il s'avère qu'en termes de pourcentage pour Docotic.Pdf, plus d'avertissements ont été émis dans chacun des groupes. <br><br><h3>  Que trouve-t-on? </h3><br>  J'ai décidé d'ignorer les avertissements Low à ce stade. <br><br>  J'ai trié les avertissements par la colonne Code et il s'est avéré que le détenteur absolu d'enregistrement pour la fréquence était <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3022</a> "L'expression est toujours vraie / fausse" et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3063</a> "Une partie de l'expression conditionnelle est toujours vraie / fausse si elle est évaluée".  À mon avis, il s'agit d'une chose.  Au total, ces deux avertissements donnent 92 cas sur 190. Fréquence relative = 48%. <br><br>  La logique de la division en Élevé et Moyen n'est pas entièrement claire.  Je m'attendais à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3072</a> "La classe" A "contenant les membres IDisposable <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'implémente</a> pas elle-même IDisposable" et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3073</a> "Tous les membres IDisposable ne sont pas correctement éliminés.  Appelez «Dispose» lorsque vous disposez de la classe «A» »dans le groupe High, par exemple.  Mais c'est du goût, bien sûr. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Surpris</a> que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3095</a> «L'objet a été utilisé avant d'être vérifié par rapport à null.  Vérifiez les lignes: N1, N2 ”est marqué deux fois comme élevé et une fois comme moyen.  Bug? <br><br><img src="https://habrastorage.org/webt/kz/dk/e8/kzdke88cvkewlgqplmw4xlp55ym.png"><br><br><h3>  Faire confiance mais vérifier </h3><br>  Il est temps de vérifier le caractère raisonnable des avertissements.  Y a-t-il de vraies erreurs trouvées?  Y a-t-il des avertissements incorrects? <br><br>  J'ai divisé les avertissements trouvés dans les groupes ci-dessous. <br><br><h4>  Avertissements importants </h4><br>  Leur correction a augmenté la stabilité, résolu les problèmes de fuites de mémoire, etc.  Vraies erreurs / imperfections. <br><br>  16 d'entre eux ont été émis, ce qui représente environ 8% de tous les avertissements. <br><br>  Je vais donner quelques exemples. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3019</a> "Il est possible qu'une variable incorrecte soit comparée à null après la conversion de type à l'aide du mot clé" as ".  Vérifiez les variables 'couleur', 'indexées' » <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCompatible</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ColorImpl color</span></span></span><span class="hljs-function">)</span></span> { IndexedColorImpl indexed = color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IndexedColorImpl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> indexed.ColorSpace.Equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Comme vous pouvez le voir, au lieu d'être indexée, la couleur variable est comparée à null.  Ceci est incorrect et peut conduire à NRE. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080</a> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Déréférence</a> nulle possible.  Pensez à inspecter 'cstr_index.tile_index' » <br><br>  Un petit fragment pour illustrer: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cstr_index.tile_index == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cstr_index.tile_index[<span class="hljs-number"><span class="hljs-number">0</span></span>].tp_index == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. } }</span></span></code> </pre><br>  Évidemment, la première condition impliquait! = Null.  Dans le formulaire actuel, le code lancera NRE à chaque appel. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3083</a> “L'appel non sécurisé de l'événement 'OnProgress', NullReferenceException est possible.  Pensez à affecter un événement à une variable locale avant de l'invoquer. » <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Updated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OnProgress != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) OnProgress(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventArgs()); }</code> </pre><br>  Un avertissement a aidé à corriger une exception potentielle.  Pourquoi cela peut-il survenir?  Stackoverflow a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bonne explication</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3106</a> «L'index est peut-être hors limites.  L'index «0» pointe au-delà de la limite «v» » <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;FontStringPair&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; text.Length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;FontStringPair&gt;(); createPairs(text[i].ToString(CultureInfo.InvariantCulture)); result.Add(v[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre><br>  L'erreur est que le résultat de createPairs est ignoré et à la place une liste vide est accessible.  Apparemment, createPairs a initialement accepté la liste comme paramètre, mais une erreur a été commise lors du changement de méthode. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3117</a> 'Le paramètre constructeur' validateType 'n'est pas utilisé <br><br>  Un avertissement a été émis pour un code similaire à celui-ci <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDocument document, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> validateType = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">document, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span> { m_provider = document; }</code> </pre><br>  L'avertissement lui-même ne semble pas important.  Mais le problème est plus grave qu'il n'y paraît à première vue.  Lors de l'ajout du paramètre optionnel validateType, ils ont oublié de corriger l'appel au constructeur de la classe de base. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3127</a> „Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable "plage" doit être utilisée à la place de "domaine" " <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillTransferFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PdfStreamImpl function</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// .. PdfArrayImpl domain = new PdfArrayImpl(); domain.AddReal(0); domain.AddReal(1); function.Add(Field.Domain, domain); PdfArrayImpl range = new PdfArrayImpl(); range.AddReal(0); range.AddReal(1); function.Add(Field.Range, domain); // .... }</span></span></code> </pre><br>  Un avertissement ne sera peut-être pas émis si les parties du code sont légèrement différentes.  Mais dans ce cas, une erreur a été détectée lors de l'utilisation du copier-coller. <br><br><h4>  Avertissements théoriques / formels </h4><br>  Ils sont corrects, mais leur correction ne corrige aucune erreur spécifique et n'affecte pas la lisibilité du code.  Ou ils indiquent des endroits où il pourrait y avoir une erreur, mais cela n'existe pas.  Par exemple, l'ordre des paramètres est intentionnellement modifié.  Pour de tels avertissements, vous n'avez rien à changer dans le programme. <br><br>  De ce nombre, 57 ont été émis, ce qui représente environ 30% de tous les avertissements.  Je vais donner des exemples de cas qui méritent attention. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3013</a> "Il est étrange que le corps de la fonction 'BeginText' soit entièrement équivalent au corps de la fonction 'EndText' (166, ligne 171)" <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { m_state.ResetTextParameters(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { m_state.ResetTextParameters(); }</code> </pre><br>  Les deux fonctions corporelles sont en fait les mêmes.  Mais c'est vrai.  Et est-ce vraiment si étrange que les corps de fonctions d'une même ligne coïncident? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3106</a> „Valeur d'index négative possible.  La valeur de l'indice «c1» pourrait atteindre -1 » <br><br><pre> <code class="cs hljs">freq[<span class="hljs-number"><span class="hljs-number">256</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// .... c1 = -1; v = 1000000000L; for (i = 0; i &lt;= 256; i++) { if (freq[i] != 0 &amp;&amp; freq[i] &lt;= v) { v = freq[i]; c1 = i; } } // .... freq[c1] += freq[c2];</span></span></code> </pre><br>  Je suis d'accord, j'ai donné un morceau de l'algorithme pas si clair.  Mais, à mon avis, dans ce cas, l'analyseur s'inquiète en vain. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3107</a> «Expression identique de« neighsum »à gauche et à droite de l'affectation composée» <br><br>  L'avertissement est provoqué par un code assez courant: <br><br><pre> <code class="cs hljs">neighsum += neighsum;</code> </pre><br>  Oui, il peut être réécrit par multiplication.  Mais il n'y a pas d'erreur. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3109</a> „La sous-expression 'l_cblk.data_current_size' est présente des deux côtés de l'opérateur.  L'expression est incorrecte ou elle peut être simplifiée. " <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Check possible overflow on size */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((l_cblk.data_current_size + l_seg.newlen) &lt; l_cblk.data_current_size) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Le commentaire du code clarifie l'intention.  Encore une fausse alarme. <br><br><h4>  Avertissements justifiés </h4><br>  Leur correction a eu un effet positif sur la lisibilité du code.  Autrement dit, il a réduit les conditions inutiles, les contrôles, etc.  L'effet sur le fonctionnement du code n'est pas évident. <br><br>  De ce nombre, 103 ont été émis, ce qui représente environ 54% de tous les avertissements. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3008</a> „La variable 'l_mct_deco_data' reçoit deux fois de suite des valeurs.  C'est peut-être une erreur » <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_nb_mct_records == m_nb_max_mct_records) { ResizeMctRecords(); l_mct_deco_data = (OPJ_INT32)m_nb_mct_records; } l_mct_deco_data = (OPJ_INT32)m_nb_mct_records;</code> </pre><br>  Analyseur de droits: affectation à l'intérieur s'il n'est pas nécessaire. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3009</a> "Il est étrange que cette méthode renvoie toujours une seule et même valeur" <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opj_dwt_decode_tile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">opj_tcd_tilecomp_t tilec, OPJ_UINT32 numres</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numres == <span class="hljs-number"><span class="hljs-number">1U</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... return true; }</span></span></code> </pre><br>  Sur les conseils de l'analyseur, la méthode a été modifiée et ne renvoie plus rien. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3022</a> "Expression '! Ajouter' est toujours vrai" <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PdfDictionaryImpl controlDict, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">add</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... if (add) { // .. return; } if (!add) { // ... } // ... }</span></span></code> </pre><br>  En effet, cela ne sert à rien dans le second si.  La condition sera toujours vraie. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3029</a> "L'expression conditionnelle des instructions 'if' situées côte à côte est identique" <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stroke) extGState.OpacityStroke = opacity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stroke) state.AddReal(Field.CA, opacity);</code> </pre><br>  On ne sait pas d'où vient ce code.  Mais maintenant, nous l'avons corrigé. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3031</a> „Un contrôle excessif peut être simplifié.  Le '||'  l'opérateur est entouré d'expressions opposées " <br><br>  Ceci est une condition de cauchemar: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(cp.m_enc.m_tp_on != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ((!opj_codec_t.OPJ_IS_CINEMA(cp.rsiz) &amp;&amp; (t2_mode == J2K_T2_MODE.FINAL_PASS)) || opj_codec_t.OPJ_IS_CINEMA(cp.rsiz)))) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Après les changements, c'est devenu beaucoup mieux <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(cp.m_enc.m_tp_on != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (opj_codec_t.OPJ_IS_CINEMA(cp.rsiz) || t2_mode == J2K_T2_MODE.FINAL_PASS))) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3063</a> «Une partie de l'expression conditionnelle est toujours vraie si elle est évaluée: x! = Null» <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3022</a> "L'expression 'x! = Null' est toujours vraie" <br><br>  Ici, j'ai inclus des avertissements selon lesquels la vérification de null n'a pas de sens.  Le bien-fondé de le faire est une question controversée.  Ci-dessous, j'ai décrit plus en détail l'essence du problème. <br><br><h4>  Avertissements sans fondement </h4><br>  Faux positifs  En raison d'erreurs dans la mise en œuvre d'un test particulier ou d'une sorte de défaut de l'analyseur. <br><br>  Parmi ceux-ci, 14 ont été émis, ce qui représente environ 7% de tous les avertissements. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3081</a> «Le compteur« i »n'est pas utilisé dans une boucle imbriquée.  Envisagez d'inspecter l'utilisation du compteur "j" " <br><br>  Une version légèrement simplifiée du code pour lequel cet avertissement a été émis: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; initialGlyphsCount - <span class="hljs-number"><span class="hljs-number">1</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; initialGlyphsCount - i - <span class="hljs-number"><span class="hljs-number">1</span></span>; ++j) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  Évidemment, i est utilisé dans une boucle imbriquée. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3125</a> "L'objet a été utilisé après avoir été vérifié par rapport à null" <br><br>  Code pour lequel un avertissement est émis: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare_SecondGreater</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cmapEncodingRecord er1, cmapEncodingRecord er2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (er1 == er2) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (er1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; er2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (er1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; er2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> er1.CompareTo(er2); }</code> </pre><br>  er1 ne peut pas être nul lorsque CompareTo () est appelé. <br><br>  Un autre code pour lequel cet avertissement est émis: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">realloc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] table, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] newTable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[newSize][]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> existingSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (table != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) existingSize = table.Length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; existingSize; i++) newTable[i] = table[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = existingSize; i &lt; newSize; i++) newTable[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; table = newTable; }</code> </pre><br>  la table ne peut pas être nulle dans une boucle. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3134</a> „Décalage de [32..255] bits est supérieur à la taille du type d'expression 'UInt32' '(uint) 1'“ <br><br>  Un morceau de code pour lequel cet avertissement est émis: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> bitPos = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(numBits &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> mask = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bitPos;</code> </pre><br>  On peut voir que bitPos peut avoir une valeur de la plage [0..31], mais l'analyseur pense qu'il peut avoir une valeur de la plage [0..31], ce qui est incorrect. <br><br>  Je ne donnerai pas d'autres cas similaires, car ils sont équivalents. <br><br><h4>  Réflexions supplémentaires sur certains chèques </h4><br>  Il ne m'a pas semblé souhaitable d'avertir que 'x! = Null' est toujours vrai dans les cas où x est le résultat de l'appel d'une méthode.  Un exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(...); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(...); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentOutOfRangeException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(x)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... X x = GetX(..); if (x != null) { // ... } }</span></span></code> </pre><br>  Oui, formellement, l'analyseur a raison: x ne sera toujours pas nul, car GetX retournera une instance à part entière ou lèvera une exception.  Mais le code améliorera-t-il la suppression du chèque par null?  Et si GetX change plus tard?  La méthode doit-elle connaître l'implémentation de GetX? <br><br>  Au sein de l'équipe, les opinions étaient partagées.  Il a été suggéré que la méthode actuelle a un contrat par lequel elle ne devrait pas retourner null.  Et cela n'a aucun sens d'écrire du code redondant «pour l'avenir» à chaque appel.  Et si le contrat change, le code d'appel doit être mis à jour. <br><br>  À l'appui de cette opinion, le jugement suivant a été rendu: la vérification de null revient à encapsuler chaque appel dans try / catch au cas où la méthode commencerait à lever des exceptions à l'avenir. <br><br>  En conséquence, selon le principe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YAGNI</a> , ils ont décidé de ne pas conserver les chèques et les ont supprimés.  Tous les avertissements ont été transférés de théorique / formel à justifié. <br><br>  Je me ferai un plaisir de lire votre avis dans les commentaires. <br><br><h3>  Conclusions </h3><br>  L'analyse statique est une bonne chose.  PVS-Studio vous permet de trouver de vraies erreurs. <br><br>  Oui, il y a des avertissements déraisonnables / incorrects.  Mais PVS-Studio a toujours trouvé de vraies erreurs dans un projet qui utilise déjà l'analyse de code.  Notre produit est assez bien couvert par les tests, il est d'une manière ou d'une autre testé par nos clients, mais les <s>robots le font mieux. L'</s> analyse statique est toujours bénéfique. <br><br>  Enfin, quelques statistiques. <br><br><h4>  3 principaux avertissements déraisonnables </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3081</a> „Le compteur 'X' n'est pas utilisé dans une boucle imbriquée.  Envisagez d'inspecter l'utilisation du compteur "Y" " <br>  1 sur 1 trouvé déraisonnable <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3125</a> „L'objet a été utilisé après avoir été vérifié par rapport à null.  Vérifier les lignes: N1, N2 “ <br>  9 sur 10 sont déclarés non fondés <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3134</a> "Le décalage de N bits est supérieur à la taille du type" <br>  4 sur 5 jugés non fondés <br><br><h4>  3 principaux avertissements importants </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3083</a> «L'appel d'événement à risque, NullReferenceException est possible.  Envisagez d'affecter un événement à une variable locale avant de l'invoquer " <br>  5 sur 5 ont été jugés importants. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3020</a> „Une rupture / poursuite / retour / goto inconditionnel dans une boucle“ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Déréférence</a> nulle possible" <br>  2 sur 2 ont été reconnus comme importants. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3019</a> „Il est possible qu'une variable incorrecte soit comparée à null après la conversion de type en utilisant le mot-clé 'as'“ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3127</a> „Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable "X" devrait être utilisée à la place de "Y" " <br>  1 sur 1 a été jugé important. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425741/">https://habr.com/ru/post/fr425741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425727/index.html">Jusqu'à la prochaine fois</a></li>
<li><a href="../fr425729/index.html">Hackathon Pro Welcome: comment a été le premier organisme de bienfaisance SmartMail Hack</a></li>
<li><a href="../fr425731/index.html">Les secrets de l'informatique GPU impossible</a></li>
<li><a href="../fr425737/index.html">Cartes sur la table: comment choisir un fournisseur de cartes pour une application mobile</a></li>
<li><a href="../fr425739/index.html">Microsoft annonce Project xCloud - un service de streaming de jeu de pointe</a></li>
<li><a href="../fr425743/index.html">Psychothérapie Mars dans la maison de Saturne et injections intracérébrales de psilocybine homéopathique</a></li>
<li><a href="../fr425747/index.html">Qu'est-il arrivé à «Timur et son équipe» ou à propos du Partenariat des techniciens militants</a></li>
<li><a href="../fr425749/index.html">Le Web est en jeu. Rejoignez-nous et combattez pour elle</a></li>
<li><a href="../fr425751/index.html">Une prothèse en polymère imitant la structure osseuse a été implantée avec succès pour la première fois</a></li>
<li><a href="../fr425753/index.html">Google+ RIP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>