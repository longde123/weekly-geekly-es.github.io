<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕋 🐂 👨🏽‍🎓 Keterbatasan game 8-bit dan rekreasi tepatnya di Unity ⛴️ 🍍 ⏺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Game retro dengan mekanik sederhana dan grafik piksel dapat membangkitkan kenangan hangat dari pemain berpengalaman, dan pada saat yang sama cukup mud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Keterbatasan game 8-bit dan rekreasi tepatnya di Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462843/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/d1d/acb/2a7d1dacbe9050c41e0fe50ca79e789e.png" alt="gambar"></div><br>  Game retro dengan mekanik sederhana dan grafik piksel dapat membangkitkan kenangan hangat dari pemain berpengalaman, dan pada saat yang sama cukup mudah diakses oleh audiens yang lebih muda.  Saat ini, banyak permainan yang disebut retro, tetapi usaha dan perencanaan diperlukan untuk menciptakan gaya nostalgia.  Itu sebabnya kami mengundang orang-orang dari Mega Cat Studios untuk membantu kami mendiskusikan topik ini.  Dalam posting ini, kami akan membahas semua yang Anda butuhkan untuk membuat grafik gaya permainan NES yang otentik, termasuk opsi Unity penting, struktur grafik, dan palet warna. <br><br><h2>  Buat seni bergaya NES yang otentik </h2><br>  Untuk memulai, kami akan membahas dasar-dasar pembuatan grafik untuk game yang memenuhi batasan Sistem Hiburan Nintendo klasik.  Generasi konsol ini memberlakukan batasan serius pada artis yang ingin mereproduksi grafis otentiknya.  Ini adalah batasan pada palet yang digunakan dan pada ukuran dan jumlah objek di layar.  Selain itu, penting untuk mempertimbangkan bahwa resolusi konsol ini adalah 256 × 240 piksel. <br><br><h3>  Palet </h3><br>  Saat membuat grafik yang kompatibel dengan NES, artis harus mempertimbangkan banyak batasan.  Pertama, batasan terpenting adalah bagaimana palet warna digunakan dalam gambar.  NES unik karena semua warna palet yang mungkin "kabel" ke konsol.  NES memilih warna mana yang akan digunakan dalam gambar dengan mengirimkan set nilai ke NES GPU, setelah itu GPU mengembalikan warna yang cocok dengan nilai-nilai tersebut.  Berikut ini adalah gambar palet warna NES: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10e/4f9/0fd/10e4f90fdf5bb0ac7832dd5f4ab7d4a9.png"></div><br>  Warna-warna ini tidak dapat diubah karena mereka adalah bagian dari konsol itu sendiri.  Semua game NES menggunakan kombinasi warna-warna ini yang membentuk gambar. <br><a name="habracut"></a><br><h3>  Sub palet </h3><br>  Untuk membuat kombinasi yang digunakan dalam gim, dibuat sub-palet yang dilampirkan ke sprite dalam game atau gambar latar belakang.  NES membagi palet menjadi sub-palet yang dapat ditugaskan untuk sprite dan latar belakang.  Setiap sub-palet berisi satu warna umum, yang digunakan di semua sub-palet, dan tiga warna unik.  Ia dapat memuat empat sub-palet untuk latar belakang dan empat sub-palet untuk sprite.  Dalam kasus sprite, warna keseluruhan pada awal setiap sub-palet dianggap transparan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/59a/330/33759a330bb3449bdf5a33c8ad1f671f.png"></div><br>  Berikut ini adalah contoh dari serangkaian sub-palet yang digunakan dalam game.  Bagian atas menunjukkan sub-palet latar belakang, bagian bawah menunjukkan sub-palet sprite.  Dalam contoh ini, hitam adalah warna umum yang digunakan di semua sub-palet.  Karena warna keseluruhan dianggap transparan dalam sprite, warna hitam kedua diperlukan dalam sub-palet untuk sprite, yang digunakan sebagai warna yang terlihat. <br><br><h3>  Menugaskan Sub-Palet </h3><br>  Pembatasan penggunaan palet menjadi lebih ketat ketika artis beralih ke bagaimana palet digunakan dalam permainan.  Untuk menjelaskan ini, Anda perlu berbicara lebih banyak tentang bagaimana konsol retro menyimpan dan menampilkan gambar.  Grafik dari setiap konsol retro disimpan di dalam game sebagai ubin 8 × 8 piksel.  Berkat ini, seniman dapat menghemat ruang dengan menggunakan kembali ubin untuk objek yang berbeda.  (Misalnya, bagian jalan dapat digunakan kembali dengan membuat tebing atau bangunan dari mereka).  Penting juga bahwa informasi warna tidak disimpan dengan grafik.  Semua ubin disimpan dalam palet monokrom.  Berkat ini, ketika ubin ditampilkan dalam game, Anda dapat menetapkan sub-palet padanya dan secara bersamaan menampilkannya di layar dengan sub-palet yang berbeda.  Ini penting saat membuat ulang grafis konsol retro pada platform modern, karena ini memengaruhi cara kami menetapkan palet ke grafis. <br><br>  NES menetapkan palet ke sprite dan latar belakang secara berbeda.  Dia menugaskan palet sprite taylovo.  Ini berarti bahwa dengan setiap ubin 8 × 8 dalam sprite, satu dari empat sub-palet sprite dapat dikaitkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/e7a/d58/d0ae7ad5802681f0f3fd700f52307279.png" width="1200" height="600"></div><br>  Karakter ninja ini menggunakan dua sub-palet untuk meningkatkan kedalaman warna.  Di sebelah kanan Anda dapat melihat bahwa ubin itu dibagi menjadi 8 × 8 ubin yang terpisah.  Dalam bentuk yang terbagi, terlihat bahwa pirus cahaya dan merah tua yang digunakan dalam pedang dan ikat kepala unik untuk ubin ini, dan kontur ungu dan hitam gelap digunakan dalam tiga ubin yang tersisa. <br><br>  Latar belakang tunduk pada batasan yang jauh lebih ketat.  Latar belakang palet ditugaskan untuk 16 × 16 fragmen.  Binding sub-palet latar belakang seluruh layar disebut Tabel Atribut (tabel atribut).  Justru karena tabel ini sebagian besar gambar retro aktif menggunakan segmen ubin berulang.  Segmen tersebut biasanya terdiri dari 16 × 16 ubin, itulah sebabnya mereka ditempatkan di tabel atribut.  Terlepas dari kenyataan bahwa ini disebabkan oleh keterbatasan perangkat keras, ubin latar 16x16 seperti itu menjadi ciri khas grafis retro dan sekarang mutlak diperlukan untuk rekonstruksinya dalam permainan modern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/fb6/dfb/f7dfb6dfb062288789f2d76c2055758f.png" width="1200" height="600"></div><br>  <i>Berikut adalah contoh latar belakang kota yang indah dalam gaya RPG, dibuat dengan mempertimbangkan batasan-batasan ini.</i>  <i>Gambar di sebelah kanan menunjukkan bahwa itu dibagi menjadi blok 16 × 16 piksel, dan palet ditetapkan untuk setiap blok.</i>  <i>Untuk menghemat ruang, elemen-elemen seperti genteng, rumput, dan batu bata di jembatan dibuat dari bagian yang berulang dari balok-balok ini.</i>  <i>Ubin atap bangunan kecil menggunakan ubin yang sama, tetapi mereka diberi sub-palet yang berbeda, memberikan penampilan yang unik.</i> <br><br><h2>  Hamparan sprite </h2><br>  Meskipun seniman dapat menggunakan sub-palet yang berbeda untuk setiap ubin sprite 8 × 8, mereka mungkin memiliki situasi di mana perlu untuk memberikan kedalaman warna yang lebih besar pada sprite.  Dalam hal ini, Anda dapat menggunakan overlay sprite.  Sprite overlay adalah pembagian sprite menjadi dua sprite terpisah dan menempatkan mereka di atas satu sama lain.  Hal ini memungkinkan seniman untuk menghindari kondisi menggunakan satu sub-palet per 8 × 8 ubin.  Berkat ini, seniman sebenarnya bisa menggandakan jumlah warna yang dapat digunakan dalam satu area 8 × 8.  Satu-satunya kelemahan serius dari pendekatan ini adalah keterbatasan rendering sprite.  NES hanya mampu menampilkan 64 8 × 8 ubin sprite sekaligus, dan hanya delapan ubin sprite dalam satu garis horizontal.  Jika batas ini tercapai, semua ubin lainnya tidak akan ditampilkan di layar.  Itulah sebabnya di banyak game untuk NES dengan sejumlah besar sprite di layar, mereka mulai berkedip-kedip.  Dalam hal ini, satu-satunya cara untuk menampilkan semua sprite adalah dengan menampilkannya dalam bingkai bergantian.  Pembatasan tersebut harus diperhitungkan ketika melapiskan lapisan sprite, karena ini menggandakan tidak hanya jumlah warna, tetapi juga jumlah ubin sprite dalam satu garis horizontal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/386/5be/239/3865be2393a5aabf1aa3fa534ee3f7d4.png" width="1600" height="503"></div><br>  <i>Berikut adalah contoh Layering Sprite dalam aksi.</i>  <i>Versi tricolor asli dari sprite bajak laut hantu ditampilkan di sebelah kiri.</i>  <i>Artis membaginya menjadi dua bagian - tubuh / topi dan wajah / tangan, dan kemudian menetapkan mereka palet yang berbeda.</i>  <i>Di sebelah kanan adalah hasil superposisi dari dua elemen satu sama lain.</i> <br><br>  Untuk menyiasati keterbatasan tabel atribut, Anda bisa mengimplementasikan lapisan sprite menggunakan latar belakang.  Trik ini biasanya digunakan untuk gambar statis, seperti layar plot dan potret karakter, yang memberi mereka kedalaman warna yang jauh lebih besar.  Untuk mewujudkan ini, artis harus menggambar bagian dari gambar sebagai latar belakang, dan kemudian menerapkan sprite di atasnya untuk mengisi bagian yang tersisa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edd/d4f/9aa/eddd4f9aadcc18eb50358c94dea42022.png" width="1407" height="600"></div><br>  <i>Dalam potret bajak laut hantu, lapisan sprite juga digunakan, memberikan kedalaman yang lebih besar.</i>  <i>Tengkorak hijaunya ditampilkan di layar sebagai sprite, dan kerah dan topinya adalah bagian dari latar belakang.</i>  <i>Hal ini memungkinkan seniman untuk menggunakan lebih banyak warna di segmen 16 × 16 untuk sepenuhnya menghindari keterbatasan tabel atribut.</i> <br><br><h2>  Bank Grafik </h2><br>  Untuk menjelaskan batasan penting NES lainnya, pertama-tama kita harus kembali ke fakta bahwa grafik disimpan dalam ubin.  Ubin grafis disimpan pada halaman 256 ubin, dan ubin dari halaman ini tidak dapat dimuat ke VRAM di tempat yang berbeda, sehingga menjadi sulit untuk menggabungkan dan menggabungkan ubin dari halaman yang berbeda.  Konsol NES VRAM mampu menampilkan 512 ubin seperti itu secara bersamaan.  Selain itu, ia membagi ubin menjadi dua untuk sprite dan latar belakang.  Ini berarti bahwa pada saat yang sama konsol hanya dapat menampilkan 256 ubin sprite dan 256 ubin latar belakang.  Jika seorang seniman ingin menampilkan berbagai macam sprite dan elemen latar belakang, pembatasan seperti itu sangat menghalangi dirinya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/257/f33/d7c/257f33d7c769a4ed014dd36c4c7d4f7e.png" width="513" height="256"></div><br>  <i>Berikut ini adalah representasi grafis dari latar belakang dan ubin sprite dari game yang dimuat ke VRAM.</i>  <i>Konsol menyimpan latar belakang dan sprite pada halaman terpisah.</i> <br><br>  Untuk mengatasi batasan ini, NES menggunakan fitur yang memungkinkan seorang artis untuk membagi setiap halaman menjadi halaman parsial yang disebut bank.  Oleh karena itu, meskipun NES tidak dapat memuat petak individual dari berbagai titik data grafik, NES mampu memuat bagian halaman yang berbeda pada waktu yang berbeda.  Di sebagian besar permainan, bank tersebut berukuran 1 KB dan 2 KB.  Bank 1 KB setara dengan satu halaman keempat, atau 64 ubin, dan bank 2 KB setara dengan setengah halaman, atau 128 ubin.  Artis harus memutuskan apakah dia ingin memesan setiap jenis bank untuk elemen sprite atau latar belakang, karena itu perlu untuk menggunakan kedua jenis.  Ini berarti bahwa tidak mungkin memiliki 1 KB bank untuk sprite dan latar belakang.  Satu halaman harus menggunakan 1 bank KB, dan yang lainnya 2 KB.  Sebagai aturan, sebagian besar permainan menggunakan 1 KB bank untuk sprite, dan 2 KB untuk latar belakang, karena ubin latar belakang biasanya lebih statis dan memerlukan lebih sedikit variabilitas dan penggantian sambil jalan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fc/bb1/484/0fcbb14842a7d9fce566d032a6ab4664.png" width="513" height="256"></div><br>  <i>Gambar kalengan yang kita lihat di atas.</i>  <i>Sisi kiri menunjukkan latar belakang yang menggunakan 2 bank KB, yaitu dibagi menjadi dua, dan sisi kanan menunjukkan sprite yang dibagi menjadi 1 bank KB.</i>  <i>Setiap bank dapat diganti secara bebas dengan cepat.</i> <br><br>  Kegunaan bank 1K untuk sprite cukup penting.  Jika sprite karakter memiliki sejumlah besar animasi yang tidak sesuai pada satu halaman, dan pada saat yang sama diperlukan untuk memuat sprite lain, maka tindakan individu dapat diunduh ke 1 bank KB, dan kemudian diganti dengan mereka tergantung pada apa yang terjadi di layar.  Ini juga meningkatkan variabilitas sprite yang dapat digunakan di satu area permainan.  Misalnya, jika seorang pemain harus memenuhi enam jenis musuh di tingkat permainan, tetapi hanya pemain dan tiga jenis sprite lain yang ditempatkan pada halaman sprite, maka ketika satu jenis musuh menghilang dari layar, permainan dapat mengganti salah satu bank musuh dengan jenis musuh baru. <br><br>  Salah satu dari beberapa kelemahan serius menggunakan bank pada 1 KB untuk sprite dan 2 KB untuk latar belakang adalah cara konsol NES memproses animasi latar belakang.  Untuk menghidupkan elemen latar belakang gim untuk NES, seorang artis harus membuat bank duplikat elemen latar belakang yang sama.  Setiap bank duplikat baru akan berisi bingkai animasi berikutnya untuk masing-masing elemen animasi.  Bank-bank ini saling menggantikan, menciptakan animasi.  Jika seorang artis menggunakan bank berukuran setengah halaman untuk latar belakang, maka menyimpan semua bank duplikat ini mungkin membutuhkan banyak ruang.  Salah satu cara mengatasi batasan ini adalah menempatkan semua elemen latar belakang animasi untuk seluruh permainan dalam satu bank.  Tapi kemudian artis dihadapkan pada batasan lain: ia hanya memiliki 128 ubin yang tersisa untuk elemen statis dari setiap latar belakang.  Setiap artis sendiri memutuskan metode penyimpanan mana yang terbaik untuknya. <br><br><h2>  Trik Lapisan </h2><br>  Banyak permainan pada zaman itu menggunakan trik untuk menciptakan efek seperti pengguliran latar belakang paralaks, tetapi juga menimbulkan tantangan bagi para seniman dan desainer.  Kemudian konsol 16-bit memiliki dukungan untuk banyak lapisan latar belakang, tetapi NES tidak memiliki fitur ini.  Semua latar belakang adalah gambar datar tunggal.  Untuk menciptakan rasa kedalaman dan pelapisan, berbagai trik program digunakan.  Misalnya, untuk membuat pengguliran paralaks, pengembang dapat mengatur register yang dilaporkan ketika garis horizontal tertentu (disebut garis pindai) digambar di layar. <br><br>  Kemudian mereka dapat menggunakan register ini untuk mengontrol kecepatan dan arah menggulir layar.  Berkat ini, Anda dapat membuat garis horizontal latar belakang, yang bergerak dengan kecepatan berbeda dari latar belakang lainnya.  Bagi para seniman dan desainer, triknya adalah untuk mengingat bahwa latar belakang masih merupakan satu gambar datar.  Jika sebuah platform atau elemen lain yang harus "di depan" dari latar belakang yang bergerak lambat ditempatkan di area ini, maka itu juga akan menggulir lebih lambat dari bagian gambar lainnya.  Ini berarti bahwa desainer harus mengatur elemen latar belakang di tempat kejadian sehingga efeknya tidak terdistorsi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acc/36f/7c2/acc36f7c2bab225e5b5f27c283dd68bf.png" width="512" height="448"></div><br>  <i>Dalam contoh ini, area yang disorot dengan warna merah untuk mensimulasikan kedalaman dapat dibuat untuk menggulir lebih lambat daripada latar belakang lainnya.</i>  <i>Antarmuka di bagian atas layar tidak menggulir, meskipun juga merupakan bagian dari gambar latar datar.</i> <br><br>  Ada satu trik lagi, berkat para seniman yang dapat "menggerakkan" salah satu elemen latar belakang ke depan.  Di NES, pengembang dapat membuat prioritas sprite kurang dari nol.  Jika ini dilakukan, sprite akan ditampilkan di bawah semua piksel buram latar belakang.  Prioritas sprite juga dapat diubah dan diaktifkan dengan cepat, yang mana elemen-elemen individu dapat, jika perlu, mengubah prioritas sprite. <br><br><h2>  Alur kerja yang menyatu untuk nuansa retro terbaik </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer"><strong>Unduh proyek contoh dan mulailah bekerja bersama kami!</strong></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">Mega Cat Studios</a> dari Pittsburgh, PA, telah mengubah penciptaan game retro menjadi bentuk seni.  Bahkan, beberapa gim mereka bahkan dapat dibeli dengan kartrid dan dimainkan di konsol retro seperti Sega Genesis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a93/80b/8a0/a9380b8a014bf276ad8196fb84cb4cd0.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f22/0f2/b85/f220f2b85387769849b6aa8267659804.gif" width="690" height="388"></div><br>  <i>Krisis Medusa Kecil dan Kopi</i> <br><br>  Perubahan terbaru dalam alur kerja Unity telah mengubah mesin menjadi lingkungan yang sangat cocok untuk membuat game retro.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">2D Tilemap telah</a> ditingkatkan dan sekarang mendukung kartu ubin dari ubin persegi panjang, heksagonal, dan isometrik!  Selain itu, Anda dapat menggunakan komponen Pixel Perfect Camera baru untuk mencapai gerakan holistik piksel demi piksel dan efek grafis.  Anda bahkan dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener noreferrer">tumpukan pasca pemrosesan</a> untuk menambahkan semua jenis efek retro layar yang indah.  Namun, sebelum melakukan semua ini, Anda harus mengimpor dan mengonfigurasi aset dengan benar. <br><br><h2>  Persiapan aset sprite </h2><br>  Agar aset menjadi jelas dan pixelated, mereka harus terlebih dahulu dikonfigurasikan dengan benar.  Pilih setiap aset yang Anda gunakan di jendela Proyek, dan kemudian ubah parameter berikut di inspektur: <br><br><ul><li>  Ubah mode filter ke "Point" </li><li>  Kompresi berubah menjadi "Tidak Ada" </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/d21/a9b/727d21a9bc405de801852b22ac9cb612.png"></div><br>  Mode penyaringan lainnya menghasilkan sedikit kekaburan gambar, yang melanggar gaya piksel jernih yang kita perjuangkan.  Saat menggunakan Kompresi, data gambar dikompresi, menghasilkan sedikit keakuratan.  Ini penting untuk dipertimbangkan, karena beberapa piksel dapat berubah warna karena kompresi, berpotensi mengubah seluruh palet warna. <br><br>  Semakin kecil ukuran dan jumlah warna dalam sprite, semakin banyak kompresi yang akan memengaruhinya.  Berikut adalah contoh membandingkan kompresi normal (default) dan kurangnya kompresi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b82/2f0/b63/b822f0b63afa445828adbaf9d8095290.png" width="650" height="324"></div><br>  <i>Kompresi normal / Gambar tanpa kompresi - terlihat persis sama dengan aslinya</i> <br><br>  Aspek lain yang perlu dipertimbangkan adalah parameter Ukuran Maks dari gambar di Inspektur.  Jika gambar sprite lebih besar pada sumbu apa pun daripada properti Ukuran Max (secara default adalah 2048), maka gambar tersebut akan secara otomatis disesuaikan dengan ukuran maksimum.  Ini biasanya mengakibatkan hilangnya kualitas dan gambar mulai terlihat buram.  Karena beberapa platform tidak dapat mendukung tekstur yang lebih besar dari 2048 di sepanjang sumbu apa pun, yang terbaik adalah tetap berada dalam kisaran itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/503/968/7cb/5039687cbe1e4e34c623abe9ff91f5f8.png" width="650" height="324"></div><br>  <i>Ukuran maks adalah 2048 / Dan sekarang ukuran maks adalah 4096</i> <br><br>  Gambar di atas menunjukkan sprite dari sprite sheet (sprite sheet) yang memiliki ukuran sumbu tunggal 2208 dengan ukuran maksimum 2048. Seperti yang Anda lihat, dengan meningkatkan properti Ukuran Max ke 4096, kami dapat memastikan ukuran gambar yang benar tanpa kehilangan kualitas. <br><br>  Terakhir, saat menyiapkan sprite atau sprite sheet, Anda harus mengatur parameter mode unit pivot ke Piksel alih-alih Normal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3de/9fb/7ed/3de9fb7ed5bc8fbee3860d62ecdb31f8.png"></div><br>  Karena ini, titik pivot gambar akan ditentukan berdasarkan piksel, dan tidak dalam interval yang mulus dari 0 hingga 1 di sepanjang setiap sumbu gambar.  Jika titik jangkar dari sprite tidak selaras dengan pixel, maka kita akan kehilangan lokasi sprite karena ketepatan pixel.  Poin jangkar untuk sprite dapat diatur dalam Editor Sprite, yang terbuka di Inspektur ketika aset sprite dipilih. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/875/577/1dc/8755771dcb7cfec8e19b4e66a1bc7151.png"></div><br><h2>  Menginstal Paket Pixel Perfect 2D </h2><br>  Setelah menyiapkan aset, kita dapat membuat piksel kamera sempurna.  Hasil piksel-akurat akan terlihat jelas dan diucapkan.  Tanda-tanda pixel art yang tidak akurat menjadi blur (distorsi) dan rectangularity dari beberapa pixel. <br><br>  Paket 2D Pixel Perfect dapat diimpor menggunakan Package Manager mesin Unity.  Klik pada menu Window di toolbar dan kemudian pilih Package Manager.  Di jendela baru, klik Lanjut dan pilih kotak centang Tampilkan paket pratinjau.  Pilih 2D Pixel Perfect dari daftar di sebelah kiri, lalu klik Install di sudut kanan atas jendela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/2e2/f13/2c82e2f13a4d262ae24a269a316b3283.png"></div><br>  Itu saja.  Anda sekarang siap untuk memulai dengan komponen kamera pixel-akurat. <br><br><h2>  Akurasi Pixel Tinggi </h2><br>  Komponen Pixel Perfect Camera ditambahkan ke komponen Camera mesin Unity dan melengkapinya.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menambahkannya, buka kamera utama dan tambahkan komponen Pixel Perfect Camera ke dalamnya. </font><font style="vertical-align: inherit;">Jika komponen Pixel Perfect Camera tidak ada dalam menu, maka ikuti langkah-langkah di atas untuk mengimpornya ke proyek.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43a/181/ee6/43a181ee66528de132ae3cc3391cf699.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang mari kita periksa opsi yang tersedia. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/90d/9f4/dc890d9f4960a724e5368e5ee954894c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, saya sarankan menyalakan "Jalankan Dalam Mode Edit" dan mengatur rasio aspek ke "Aspek Gratis" di jendela Game sehingga Anda dapat dengan bebas mengubah jendela game. </font><font style="vertical-align: inherit;">Komponen akan menampilkan pesan yang berguna di jendela permainan, yang menunjukkan apakah tampilan tersebut akurat piksel dalam resolusi saat ini.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/548/fae/889/548fae8890f6f4d1a6ddf9ba3b7bb8dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang Anda bisa melihat setiap parameter dan melihat bagaimana mereka memengaruhi penampilan game. </font></font><br><br><ul><li> <b>Assets Pixels Per Unit</b> —      ,        .     ,       ,        (pixels per unit, PPU),        .          ,     16  16 ,     PPU 16 —           1.      PPU. </li><li> <b>Reference Resolution</b> —    .      .    -,      . , Sega Genesis   320×224.     Sega Genesis     320×224. ,    16:9   320×180  398×224 (      ). </li><li> <b>Upscale Render Texture</b> —                 .         ,   ,     -     .  «Upscale Render Texture»         . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/288/eec/3d9288eec3429b321dbabda98d541e37.png" width="650" height="195"></div><br> <i>1.  ( ) 2.  Upscale Render Texture (   45 ,   ,        ) 3.  Upscale Render Texture (  45 ,   ,     ,         .)</i> <br><br><ul><li> <b>Pixel Snapping</b> (     Upscale Render Texture) —       (sprite renderer)        ,        PPU. ,          transform .    -      ,     -    . <br><ul><li>  Contoh: </li></ul></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/491/d2f/9ff491d2f7a076c35ea64ae165fd164d.png" width="1280" height="1000"></div><br> <i> Pixel Snapping .     (0, 0),    —  (1.075, 0).    . ,       .  Pixel Snapping .    —   (0, 0),    (1.075, 0).      .</i> <br><br><ul><li> <strong>Crop Frame (X  Y)</strong> —       ,      ,    ,      . </li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stretch Fill</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - selalu tersedia jika Anda mengaktifkan x dan y untuk Crop Frame. </font><font style="vertical-align: inherit;">Opsi ini menyebabkan kamera untuk skala jendela permainan agar sesuai dengan layar sambil mempertahankan rasio aspek. </font><font style="vertical-align: inherit;">Karena penskalaan dilakukan tidak hanya untuk kelipatan bilangan bulat dari resolusi referensi, dalam semua kasus lainnya, akurasi piksel akan hilang. </font><font style="vertical-align: inherit;">Namun, keuntungan dari parameter ini adalah bahwa meskipun hilangnya akurasi piksel dalam banyak resolusi, tidak akan ada bilah hitam di tepinya dan layar akan sepenuhnya penuh. </font><font style="vertical-align: inherit;">Meskipun peregangan sering menyebabkan kekaburan, peringatan normal tidak ditampilkan.</font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/034/ad1/859034ad1cc5f30911ff04808bea27c1.png" width="312" height="302"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karakter dan latar belakang, isian stretch blurry</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rekomendasi Kamera Perfect Pixel </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika Anda membutuhkan tampilan yang akurat piksel dengan snap ke grid, maka saya sarankan yang berikut: </font></font><br><br><ul><li>   ,         ( 320×180). </li><li>    Upscale Render Texture <br><ul><li>   ,     ,   90, 180  270       ,      . </li><li> Upscale Render Texture       - ;     .        ,    Pixel Perfect Camera  Run in Edit Mode  ,       .     -     ,       - . </li></ul></li><li>    Pixel Snapping <ul><li>        .       ,     . </li></ul></li><li>  Crop Frame X / Y,   Upscale Render Texture <ul><li>      -   upscale render texture,   X / Y  -      ,          . </li></ul></li><li>  Stretch Fill </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyarankan pengaturan kamera sehingga dioptimalkan untuk rasio layar 16: 9, termasuk resolusi referensi, jika memungkinkan. Pada saat penulisan, sebagian besar pemain bermain di monitor dengan rasio aspek 16: 9 dan resolusi 1920 × 1080. Misalnya, resolusi referensi 320 × 180 memiliki rasio 16: 9, dan oleh karena itu, dengan resolusi 1920 × 1080 dan resolusi lain yang merupakan kelipatan 320 × 180, misalnya, 1280 × 720, tidak akan ada batas hitam di tepi layar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bilah alat Unity, Anda dapat pergi ke Edit&gt; Pengaturan Proyek&gt; Player dan batasi rasio aspek yang didukung oleh permainan. Jika Anda menemukan bahwa konfigurasi tertentu terlihat bagus dalam rasio yang Anda butuhkan, tetapi tidak cocok dengan rasio individu, maka di sini Anda dapat mematikan rasio ini. Namun, perlu diingat bahwa tidak semua pengguna memiliki layar yang kompatibel dengan keterbatasan Anda, jadi ini tidak disarankan. Alih-alih, gunakan pemangkasan agar pengguna tersebut menampilkan batas hitam dan permainan tidak dimulai pada resolusi yang tidak cocok dengan layar mereka.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika Anda mencoba membuat proyek yang otentik untuk konsol retro, Anda perlu mempertimbangkan banyak aspek teknis yang tidak dipikirkan siapa pun dalam pengembangan modern. </font><font style="vertical-align: inherit;">Karena sifat rendering gambar dan jejak memori yang rendah dari mesin yang lebih tua, desainer harus berpikir kreatif dan menghindari batasan perangkat keras. </font><font style="vertical-align: inherit;">Di era modern, kita perlu tahu tentang keterbatasan dan teknik ini untuk secara akurat menciptakan kembali tampilan dan desain game pada era itu. </font><font style="vertical-align: inherit;">Dalam posting berikutnya, kita akan melihat batasan desain era game 16-bit, serta alur kerja Unity yang diperlukan untuk menciptakan kembali gaya nyata dari "TV lama".</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462843/">https://habr.com/ru/post/id462843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462827/index.html">Kehidupan dan Sukses Larry Ellison, Pendiri Oracle</a></li>
<li><a href="../id462831/index.html">Naik Gelombang Web 3.0</a></li>
<li><a href="../id462833/index.html">Buku "Pemodelan prediktif dalam praktik"</a></li>
<li><a href="../id462835/index.html">Tata letak dan gaya auto kesatuan: saluran dan alat baru kami untuk UI</a></li>
<li><a href="../id462837/index.html">Pengujian Kotak Hitam</a></li>
<li><a href="../id462845/index.html">Pijat untuk otak Anda: bicara tentang ASMR</a></li>
<li><a href="../id462847/index.html">Webinar Hewlett Packard Enterprise pada Agustus-Oktober 2019</a></li>
<li><a href="../id462849/index.html">Sesuatu tentang inode</a></li>
<li><a href="../id462851/index.html">Kami membuat layanan cloud untuk mengelola persediaan (Angular + Firebase)</a></li>
<li><a href="../id462853/index.html">Memperbarui statistik pada replika sekunder dari Grup yang Tersedia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>