<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßó üë®üèæ‚Äçüî¨ üëò Statisches Abonnement unter Verwendung der Observer-Vorlage unter Verwendung von C ++ und des Cortex M4-Mikrocontrollers üßÄ ü§æüèø üåò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gute Gesundheit an alle! 


 Am Vorabend des neuen Jahres m√∂chte ich weiterhin √ºber die Verwendung von C ++ auf Mikrocontrollern sprechen. Dieses Mal ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Statisches Abonnement unter Verwendung der Observer-Vorlage unter Verwendung von C ++ und des Cortex M4-Mikrocontrollers</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481606/"><p><img src="https://habrastorage.org/webt/kq/jo/qx/kqjoqxpr1itcdx-_kq4luowkpqe.jpeg"></p><br><p>  Gute Gesundheit an alle! </p><br><p>  Am Vorabend des neuen Jahres m√∂chte ich weiterhin √ºber die Verwendung von C ++ auf Mikrocontrollern sprechen. Dieses Mal werde ich versuchen, √ºber die Verwendung der Observer-Vorlage zu sprechen (im Folgenden nenne ich sie Publisher-Subscriber oder nur Subscriber, so ein Wortspiel) sowie √ºber die Implementierung eines statischen Abonnements f√ºr C ++ 17 und die Vorteile dieses Ansatzes in einigen Anwendungen. </p><a name="habracut"></a><br><h2 id="vvedenie">  Einleitung </h2><br><p> Template Subscriber ist eine der h√§ufigsten Vorlagen, die in der Softwareentwicklung verwendet werden.  Damit f√ºhren sie beispielsweise die Verarbeitung von Tastenklicks in Windows Form durch.  Wie auch immer, an jedem Ort, an dem Sie auf √Ñnderungen der Systemparameter reagieren m√ºssen, sei es auf √Ñnderungen in Dateien oder auf die Aktualisierung des Messwerts vom Sensor, ist es Zeit <del>  ohne nachzudenken </del>  Verwenden Sie die Abonnentenvorlage. </p><br><p>  Der Vorteil der Vorlage besteht darin, dass wir das Wissen des Herausgebers und Abonnenten freisetzen, ohne an bestimmte Objekte gebunden zu sein.  Wir k√∂nnen jeden f√ºr jeden signieren, ohne die Implementierung der Publisher- und Subscriber-Objekte zu beeintr√§chtigen. </p><br><h2 id="nachalnye-usloviya">  Anfangsbedingungen </h2><br><p>  Bevor wir uns mit der Vorlage vertraut machen, stimmen wir zun√§chst zu, dass wir zuverl√§ssige Software entwickeln m√∂chten, in der: </p><br><ul><li>  Verwenden Sie keine dynamische Speicherzuordnung </li><li>  Minimieren Sie die Arbeit mit Zeigern </li><li>  Wir verwenden so viele Konstanten wie m√∂glich, damit niemand so viel wie m√∂glich √§ndern kann </li><li>  Gleichzeitig verwenden wir jedoch so wenig Konstanten wie m√∂glich, die sich im RAM befinden </li></ul><br><p>  Betrachten wir nun die Standardimplementierung der Subscriber-Vorlage. </p><br><h2 id="standartnaya-realizaciya">  Standardimplementierung </h2><br><p>  Angenommen, wir haben eine Schaltfl√§che, und wenn Sie auf die Schaltfl√§che klicken, m√ºssen wir die LEDs blinken lassen, aber wie viele davon sind bisher unbekannt, und in der Tat m√ºssen Sie m√∂glicherweise nicht mit LEDs blinken, sondern mit einem Scheinwerfer auf dem Schiff, um Nachrichten im Morsecode zu √ºbertragen.  Es ist wichtig, dass wir nicht wissen, wer abonniert wird.  Leider habe ich keinen Scheinwerfer zur Hand, so dass alle Beispiele im Artikel der Einfachheit halber und zum besseren Verst√§ndnis mit LEDs gemacht werden. </p><br><p>  Wenn Sie also die Taste dr√ºcken, m√ºssen Sie die LED √ºber diese Bet√§tigung benachrichtigen.  Nachdem Sie das Dr√ºcken gelernt haben, sollte die LED in den entgegengesetzten Zustand wechseln. <br>  Die Standardimplementierung in UML lautet wie folgt ... </p><br><p><img src="https://habrastorage.org/webt/zu/8g/ro/zu8gro30gxgngc8w36oesxy9w2i.png"></p><br><p> Hier ist die <code>ButtonController</code> Klasse daf√ºr verantwortlich, die Schaltfl√§che <code>ButtonController</code> und die Abonnenten √ºber den Klick zu benachrichtigen. In diesem Fall ist <code>Led</code> der Abonnent.  Diese beiden Klassen werden √ºber die <code>IPublisher</code> und <code>ISubsriber</code> und keine der Klassen kennt die andere.  Somit kann jedes Objekt, das von der <code>ISubscriber</code> Schnittstelle erbt, ein Ereignis von <code>ButtonController</code> . </p><br><p>  Da die dynamische Speicherzuweisung verboten ist, habe ich ein Array von 3 Elementen f√ºr die Subskription deklariert.  Das hei√üt  Maximal k√∂nnen 3 Abonnenten sein.  In erster N√§herung k√∂nnte die Methode zur Benachrichtigung von Abonnenten der <code>ButttonsController</code> Klasse daher aussehen </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> :</span></span> IPublisher { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          HandleEvent() for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } } ;</span></span></code> </pre> <br><p>  Alles Salz befindet sich in der <code>Notify()</code> -Methode der <code>Publisher</code> Klasse.  Bei dieser Methode gehen wir die Liste der Abonnenten durch und rufen <code>HandleEvent()</code> f√ºr jeden von ihnen auf. Dies ist cool, da jeder Abonnent diese Methode auf seine eigene Weise implementiert und dies dort tun kann <del>  alle </del>  Was auch immer Ihr Herz begehrt (in der Tat m√ºssen Sie vorsichtig sein, sonst wei√ü der Teufel, was der Abonnent dort tut, Sie k√∂nnen seine Methode zum Beispiel durch eine Unterbrechung aufrufen und Sie m√ºssen wachsam sein, um zu verhindern, dass Abonnenten lange und schlechte Dinge tun) </p><br><p>  In unserem Fall darf die LED alles tun, also schaltet sie ihren Zustand um: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Led</span></span></span><span class="hljs-class">:</span></span> ISubscriber { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Port::ODR::Toggle(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,    ,  Toggle() ; } };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndige Implementierung aller Klassen</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; struct ISubscriber { virtual void HandleEvent() = 0; } ; struct IPublisher { virtual void Notify() const = 0; virtual void Subscribe(ISubscriber* subscriber) = 0; } ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led: ISubscriber { static void Toggle() { Port::ODR::Toggle(1 &lt;&lt; pinNum); } void HandleEvent() override { Toggle() ; } }; struct ButtonController : IPublisher { void Run() { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const override { for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } void Subscribe(ISubscriber* subscriber) override { if (index &lt; pSubscribers.size()) { pSubscribers[index] = subscriber ; index ++ ; } //   3   ...   } private: std::array&lt;ISubscriber*, 3&gt; pSubscribers ; std::size_t index = 0U ; } ;</span></span></code> </pre></div></div><br><p>  Wie kann ein Abonnement im Code aussehen?  Und so: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static Led&lt;GPIOC,9&gt; Led3 ; ButtonController buttonController ; //  3  buttonController.Subscribe(&amp;Led1) ; buttonController.Subscribe(&amp;Led2) ; buttonController.Subscribe(&amp;Led3) ; //       buttonController.Run() ; }</span></span></code> </pre> <br><p>  Die gute Nachricht ist, dass wir jedes Objekt signieren k√∂nnen und der Zeitpunkt seiner Erstellung f√ºr uns keine Rolle spielt.  Es kann ein globales Objekt sein, statisch oder lokal.  Einerseits ist das gut, andererseits, warum m√ºssen wir die Laufzeit in diesem Code abonnieren.  Tats√§chlich ist hier die Adresse der Objekte <code>Led1</code> , <code>Led2</code> , <code>Led3</code> in der <code>Led3</code> bekannt.  Warum k√∂nnen Sie sich also bei der Kompilierung nicht anmelden und eine Reihe von Zeigern auf Abonnenten im ROM behalten? </p><br><p>  Dar√ºber hinaus besteht die Gefahr potenzieller Fehler. Wie viele haben sich beispielsweise gefragt, was beim Aufrufen der <code>Subsribe()</code> Methode passieren w√ºrde, wenn sie von mehreren Threads aus aufgerufen w√ºrde?  Wir sind auf 3 Abonnenten beschr√§nkt. Was passiert, wenn wir 4 LEDs signieren? </p><br><p>  In den meisten F√§llen ben√∂tigen wir dieses Abonnement einmal im Leben w√§hrend der Initialisierung. Wir speichern lediglich Zeiger auf Abonnenten und das wars.  Der Zeiger beh√§lt die Adresse dieser Abonnenten ein Leben lang.  Und der Tag ist unvermeidlich, an dem es ruiniert werden kann <del>  aufgrund von Supernova-Ausbruch </del>  (nat√ºrlich, wenn wir einen l√§ngeren Zeitraum in Betracht ziehen).  In jedem Fall ist die Wahrscheinlichkeit eines RAM-Ausfalls jedoch viel h√∂her als die des ROM, und es wird nicht empfohlen, permanente Daten im RAM zu speichern. </p><br><p>  Nun, die schlechte Nachricht ist, dass eine solche Architekturl√∂sung sowohl im ROM als auch im RAM oooooochen viel Platz beansprucht.  Nur f√ºr den Fall, wir schreiben, wie viel ROM und RAM diese L√∂sung ben√∂tigt: </p><br><div class="scrollable-table"><table><thead><tr><th>  Modul </th><th>  Ro-Code </th><th>  ro Daten </th><th>  RW-Daten </th></tr></thead><tbody><tr><td>  main.o </td><td>  488 </td><td>  64 </td><td>  21 </td></tr></tbody></table></div><br><p>  Das hei√üt  Insgesamt 552 Bytes im ROM und 21 Bytes im RAM - sagen wir nicht so viel, um eine Taste zu dr√ºcken und drei LEDs zu blinken. </p><br><p>  Um sich vor solchen Problemen zu sch√ºtzen und den Verbrauch von Controller-Ressourcen zu reduzieren, sollten Sie die Option mit einem statischen Abonnement in Betracht ziehen. </p><br><h2 id="staticheskaya-podpiska">  Statisches Abonnement </h2><br><p>  Um das Abonnement statisch zu machen, k√∂nnen Sie verschiedene Ans√§tze verwenden.  Ich werde sie so benennen: </p><br><ul><li>  Der traditionelle Ansatz ist derselbe, verwendet jedoch den Konstruktor constexpr und legt die Liste der Abonnenten fest. </li><li><del>  Unkonventionell </del>  Vorlagen verwenden - √úbertragen Sie die Liste der Abonnenten √ºber die Vorlagenparameter.  (hier ist eine Vorlage eine Definition aus dem Bereich der Metaprogrammierung, keine Entwurfsmuster) </li></ul><br><h3 id="tradicionnyy-podhod-k-staticheskoy-podpiske">  Der traditionelle Ansatz f√ºr statische Abonnements </h3><br><p>  Lassen Sie uns versuchen, in der Kompilierungsphase zu abonnieren.  Dazu optimieren wir unsere Architektur ein wenig: </p><br><p><img src="https://habrastorage.org/webt/lr/_k/gy/lr_kgyobfgkebxpz9gfyqiod34u.png"></p><br><p>  Das Bild unterscheidet sich nicht wesentlich vom Original, es gibt jedoch einige Unterschiede: Die Methode <code>Subscribe()</code> wurde entfernt, und das Abonnement wird jetzt direkt im Konstruktor ausgef√ºhrt.  Der Konstruktor muss eine variable Anzahl von Argumenten akzeptieren, und um in der Kompilierungsphase statisch signieren zu k√∂nnen, ist er <code>constexpr</code> .  Darin wird ein Array von Abonnenten initialisiert, und diese Initialisierung kann zur Kompilierungszeit durchgef√ºhrt werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> :</span></span> IPublisher { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*... args)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pSubscribers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;ISubscriber <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt; result = {args...} ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index = <span class="hljs-number"><span class="hljs-number">0U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it: result) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index &lt; size) { pSubscribers[index] = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;ISubscriber*&gt;(it); } index ++ ; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = <span class="hljs-number"><span class="hljs-number">3U</span></span>; ISubscriber* pSubscribers[size] ; } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndiger Code f√ºr eine solche Implementierung</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISubscriber</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; } ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPublisher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led: ISubscriber { constexpr Led() { } static void Toggle() { Port::ODR::Toggle(1&lt;&lt;pinNum); } void HandleEvent() const override { Toggle() ; } }; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; struct ButtonController : IPublisher { template&lt;typename... Args&gt; constexpr ButtonController(Args const*... args): pSubscribers() { std::initializer_list&lt;ISubscriber const*&gt; result = {args...} ; std::size_t index = 0U; for(auto it: result) { if (index &lt; size) { pSubscribers[index] = const_cast&lt;ISubscriber*&gt;(it); } index ++ ; } } void Run() const { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const override { for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } private: static constexpr std::size_t size = 3U; ISubscriber* pSubscribers[size] ; } ;</span></span></code> </pre></div></div><br><p>  Jetzt kann das Abonnement zur Kompilierungszeit erfolgen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static constexpr Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static constexpr Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static constexpr Led&lt;GPIOC,9&gt; Led3 ; static constexpr ButtonController buttonController(&amp;Led1, &amp;Led2, &amp;Led3) ; buttonController.Run() ; return 0 ; } ;</span></span></code> </pre> <br><p>  Hier befindet sich das <code>buttonController</code> Objekt zusammen mit einer Reihe von Zeigern auf Abonnenten vollst√§ndig im ROM: </p><br><blockquote>  main :: buttonController 0x800'1f04 0x10 Daten main.o [1] </blockquote><p>  Alles scheint nichts zu sein, au√üer dass wir wieder auf nur 3 Abonnenten beschr√§nkt sind.  Und die Publisher-Klasse muss √ºber einen Constexpr-Konstruktor verf√ºgen und im Allgemeinen vollst√§ndig konstant sein, um einen Zeiger auf Abonnenten im ROM zu gew√§hrleisten. Andernfalls wird unser Objekt mit allen Inhalten auch bei bekannten Abonnentenadressen wieder in den RAM verschoben. </p><br><p>  Von den anderen Nachteilen - da virtuelle Funktionen immer noch verwendet werden, werden die virtuellen Funktionstabellen St√ºck f√ºr St√ºck in unserem ROM gespeichert.  Und die Ressource ist zwar erschwinglich, aber nicht unendlich.  In den meisten Anwendungen ist es m√∂glich, darauf zu h√§mmern und einen gr√∂√üeren Mikrocontroller zu verwenden. Es kommt jedoch h√§ufig vor, dass jedes Byte z√§hlt, insbesondere bei Produkten, die von Hunderttausenden hergestellt werden, z. B. physischen Sensoren. </p><br><p>  Mal sehen, wie es mit dem Speicher in dieser L√∂sung aussieht: </p><br><div class="scrollable-table"><table><thead><tr><th>  Modul </th><th>  Ro-Code </th><th>  ro Daten </th><th>  RW-Daten </th></tr></thead><tbody><tr><td>  main.o </td><td>  172 </td><td>  76 </td><td>  0 </td></tr></tbody></table></div><br><p>  Und obwohl das Ergebnis ‚Äûumwerfend‚Äú ist: Der gesamte RAM-Verbrauch betr√§gt 0 Byte und der ROM-Speicher 248 Byte, was der H√§lfte der ersten L√∂sung entspricht, besteht nach Ansicht des Herstellers noch Verbesserungspotenzial.  Von diesen 248 Bytes belegen ungef√§hr 50 nur die virtuellen Methodentabellen. </p><br><p>  <u>Ein kleiner Exkurs:</u> <br>  Ein Schritt in der ROM-Gr√∂√üe von 256 kByte f√ºr moderne Mikrocontroller ist die Norm (beispielsweise hat der TI Cortex M4-Mikrocontroller 256 kByte ROM und die n√§chste Version ist bereits 512 kByte).  Und es wird nicht sehr gut sein, wenn wir aufgrund von 50 zus√§tzlichen Bytes einen Controller mit einem 256-kByte-ROM nehmen m√ºssen, der gr√∂√üer und teurer ist. Daher k√∂nnen durch den Verzicht auf virtuelle Funktionen bis zu 50 Cent eingespart werden (der Unterschied zwischen dem Mikrocontroller in einem 256- und 512-kByte-ROM betr√§gt ungef√§hr 50-60 Cent). </p><br><p>  Das klingt f√ºr einen Mikrocontroller l√§cherlich, aber bei einer Charge von 400.000 Ger√§ten pro Jahr k√∂nnen Sie 200.000 US-Dollar sparen.  Schon gar nicht so lustig, aber was f√ºr eine Ratte.  Sie k√∂nnen das Angebot mit einem Diplom und einer Geschenkkarte f√ºr 3.000 Rubel belohnen. Es besteht absolut kein Zweifel an der Richtigkeit, virtuelle Funktionen abzulehnen und zus√§tzliche 50 Bytes im ROM zu sparen. </p><br><h3 id="netradicionnyy-podhod">  Unkonventioneller Ansatz </h3><br><p>  Lassen Sie uns sehen, wie Sie dasselbe ohne virtuelle Funktionen tun und etwas mehr ROM sparen k√∂nnen. </p><br><p>  Lassen Sie uns zuerst herausfinden, wie es sein k√∂nnte: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static Led&lt;GPIOC,9&gt; Led3 ; //   ButtonController&lt;Led1, Led2, Led3&gt; buttonController ; buttonController.Run() ; return 0 ; }</span></span></code> </pre> <br><p>  Unsere Aufgabe ist es, die beiden Objekte Publisher ( <code>ButtonController</code> ) und Subscriber ( <code>Led</code> ) voneinander zu entkoppeln, damit sie sich nicht kennen, <code>ButtonController</code> aber gleichzeitig <code>Led</code> benachrichtigen kann. </p><br><p>  Sie k√∂nnen die <code>ButtonController</code> Klasse <code>ButtonController</code> irgendeine Weise deklarieren. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;&amp; subscriber1, Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">8</span></span>&gt;&amp; subscriber2, Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;&amp; subscriber3&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ subscriber1.HandleEvent() ; subscriber2.HandleEvent() ; subscriber3.HandleEvent() ; } ... } ;</code> </pre> <br><p>  Sie verstehen jedoch, dass wir hier an bestimmte Typen gebunden sind und die Definition der <code>BbuttonController</code> Klasse jedes Mal in einem neuen Projekt neu <code>BbuttonController</code> .  Und ich m√∂chte <code>ButtonController</code> einfach ohne <code>ButtonController</code> in das neue Projekt aufnehmen und verwenden. </p><br><p>  C ++ 17 rettet Sie, indem Sie den Typ nicht angeben k√∂nnen, sondern den Compiler bitten, den Typ f√ºr Sie abzuleiten - genau das brauchen Sie.  Wir k√∂nnen, genau wie beim traditionellen Ansatz, das Wissen des Herausgebers und des Abonnenten freisetzen, w√§hrend die Anzahl der Abonnenten praktisch unbegrenzt ist. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; } ... } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">So funktioniert die Funktion pass (..)</b> <div class="spoiler_text"><p>  Die <code>Notify()</code> -Methode ruft die <code>pass()</code> -Funktion auf und erweitert die Vorlagenparameter mit einer variablen Anzahl von Argumenten </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; }</code> </pre> <br><p>  Die Implementierung der <code>pass()</code> -Funktion ist einfach nicht vorstellbar, es ist nur eine Funktion, die eine variable Anzahl von Argumenten akzeptiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ } } ;</code> </pre> <br><p>  Wie erweitert sich die Funktion <code>HandleEvent()</code> in mehrere Aufrufe f√ºr jeden der Teilnehmer? </p><br><p>  Da die Funktion <code>pass()</code> mehrere Argumente eines beliebigen Typs <code>bool</code> , k√∂nnen Sie mehrere Argumente des Typs <code>bool</code> Sie k√∂nnen beispielsweise die Funktion <code>pass(true, true, true)</code> aufrufen.  In diesem Fall wird nat√ºrlich nichts passieren, aber wir brauchen nicht. </p><br><p>  In der Zeile <code>(subscribers.HandleEvent() , true)</code> wird der Operator "," (Komma) verwendet, der beide Operanden (von links nach rechts) ausf√ºhrt und den Wert des zweiten Operators zur√ºckgibt, d. H. <code>subscribers.HandleEvent()</code> wird zuerst ausgef√ºhrt und dann <code>true</code> die Funktion <code>true</code> <code>pass()</code> wird auf <code>true</code> . </p><br><p>  Nun, "..." ist ein Standardeintrag zum Erweitern einer variablen Anzahl von Argumenten.  F√ºr unseren Fall k√∂nnen die Aktionen des Compilers sehr schematisch wie folgt beschrieben werden: </p><br><pre> <code class="cpp hljs">pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; -&gt; pass((Led1.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led2.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led1.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, (Led2.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led2.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led3.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) ;</code> </pre> </div></div><br><p>  Anstelle von Links k√∂nnen Sie Zeiger verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> ... } ;</code> </pre> <br><p>  <strong>Erg√§nzung:</strong> Eigentlich danke an <a href="https://habr.com/ru/users/vamireh/" class="user_link">Vamireh,</a> der <a href="https://habr.com/ru/post/481606/">darauf hingewiesen hat,</a> dass all diese T√§nze mit sind <del>  Tamburin </del>  <code>pass</code> Funktion in C ++ 17 ist nicht erforderlich.  Da der Operator "," das Komma im Fold-Ausdruck (der im C ++ 17-Standard eingef√ºhrt wurde) unterst√ºtzt, wird der Code weiter vereinfacht: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ((subscribers.HandleEvent()), ...) ; } } ;</code> </pre> <br><p>  Generell sieht es architektonisch sehr einfach aus: </p><br><p><img src="https://habrastorage.org/webt/hx/di/jj/hxdijj1xdfvncxtdsr04a1qp_ve.png"></p><br><p>  Ich habe hier eine weitere LCD-Klasse hinzugef√ºgt, aber nur zum Beispiel, um zu zeigen, dass es jetzt nicht mehr auf den Typ und die Anzahl der Abonnenten ankommt. Hauptsache, es w√ºrde die <code>HandleEvent()</code> -Methode implementieren. </p><br><p>  Und der gesamte Code im Allgemeinen ist jetzt auch einfacher: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led { static void Toggle() { Port::ODR::Toggle(1&lt;&lt;pinNum); } void HandleEvent() const { Toggle() ; } }; template &lt;auto&amp; ... subscribers&gt; struct ButtonController { void Run() const { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const { ((subscribers.HandleEvent()), ...) ; } } ; int main() { //  Led1    5  GPIOC static constexpr Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static constexpr Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static constexpr Led&lt;GPIOC,9&gt; Led3 ; static constexpr ButtonController&lt;Led1, Led2, Led3&gt; buttonController ; buttonController.Run() ; return 0 ; }</span></span></code> </pre> <br><p>  Der Aufruf <code>Notify()</code> in der Methode <code>Run()</code> wird zu einem einfachen sequenziellen Aufruf </p><br><pre> <code class="cpp hljs">Led1.HandleEvent() ; Led2.HandleEvent() ; Led3.HandleEvent() ;</code> </pre> <br><p>  Was ist mit der Erinnerung hier? </p><br><div class="scrollable-table"><table><thead><tr><th>  Modul </th><th>  Ro-Code </th><th>  ro Daten </th><th>  RW-Daten </th></tr></thead><tbody><tr><td>  main.o </td><td>  186 </td><td>  4 </td><td>  0 </td></tr></tbody></table></div><br><p>  ROM insgesamt 190 Bytes und 0 Bytes RAM.  Jetzt ist die Bestellung fast 3-mal kleiner als die Standardversion, w√§hrend es genau das Gleiche leistet. </p><br><p>  Wenn Sie also die Adressen der Abonnenten bereits in der Anmeldung bekannt haben und die am Anfang des Artikels definierten Bedingungen einhalten </p><br><div class="spoiler">  <b class="spoiler_title">Bedingungen am Anfang des Artikels</b> <div class="spoiler_text"><ul><li>  Verwenden Sie keine dynamische Speicherzuordnung </li><li>  Minimieren Sie die Arbeit mit Zeigern </li><li>  Wir verwenden so viele Konstanten wie m√∂glich, damit niemand so viel wie m√∂glich √§ndern kann </li><li>  Gleichzeitig verwenden wir jedoch so wenig Konstanten wie m√∂glich, die sich im RAM befinden </li></ul></div></div><br><p>  Mit Vertrauen k√∂nnen Sie eine solche Implementierung der Publisher-Subscriber-Vorlage verwenden, um Codezeilen zu reduzieren und Ressourcen zu sparen. Dort k√∂nnen Sie nicht nur eine Geschenkkarte, sondern auch einen Bonus f√ºr das Jahr anfordern. </p><br><p>  Das <a href="https://yadi.sk/d/_nF8mwnX0tXkKA" rel="nofollow">Testbeispiel unter IAR 8.40.2 liegt hier</a> </p><br><p>  Alles mit dem Kommen!  Und viel Gl√ºck im neuen Jahr! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481606/">https://habr.com/ru/post/de481606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481594/index.html">Entwicklung eines ‚Äûeinfachen Spannungsgenerators‚Äú nach GOST R IEC 61508 (IEC 61508)</a></li>
<li><a href="../de481596/index.html">Analysieren der ELK 7.5-Einstellungen f√ºr die Mikrotik-Protokollanalyse</a></li>
<li><a href="../de481598/index.html">Ein kleiner Beitrag zum Kampf gegen die Avalonia UI-Zoo-Plattformen</a></li>
<li><a href="../de481600/index.html">Bonsai Family Wiki Engine: 2019 Ergebnisse</a></li>
<li><a href="../de481604/index.html">Wie hart Tscheljabinsk Entwickler Spiele f√ºr Google Play und soziale Netzwerke machen</a></li>
<li><a href="../de481610/index.html">PostgreSQL Antipatterns: Aktualisierung einer gro√üen Tabelle unter Last</a></li>
<li><a href="../de481612/index.html">Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfl√§che f√ºr weniger Plattformen</a></li>
<li><a href="../de481616/index.html">Geod√§tische Kuppel. √úber das Ger√§t und meine Erfahrungen mit Berechnungen</a></li>
<li><a href="../de481618/index.html">MVP in Unity oder wie man das Leben vereinfacht</a></li>
<li><a href="../de481620/index.html">Juniper SRX und Cisco ASA: N√§chste Serie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>