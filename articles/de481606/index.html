<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗 👨🏾‍🔬 👘 Statisches Abonnement unter Verwendung der Observer-Vorlage unter Verwendung von C ++ und des Cortex M4-Mikrocontrollers 🧀 🤾🏿 🌘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gute Gesundheit an alle! 


 Am Vorabend des neuen Jahres möchte ich weiterhin über die Verwendung von C ++ auf Mikrocontrollern sprechen. Dieses Mal ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Statisches Abonnement unter Verwendung der Observer-Vorlage unter Verwendung von C ++ und des Cortex M4-Mikrocontrollers</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481606/"><p><img src="https://habrastorage.org/webt/kq/jo/qx/kqjoqxpr1itcdx-_kq4luowkpqe.jpeg"></p><br><p>  Gute Gesundheit an alle! </p><br><p>  Am Vorabend des neuen Jahres möchte ich weiterhin über die Verwendung von C ++ auf Mikrocontrollern sprechen. Dieses Mal werde ich versuchen, über die Verwendung der Observer-Vorlage zu sprechen (im Folgenden nenne ich sie Publisher-Subscriber oder nur Subscriber, so ein Wortspiel) sowie über die Implementierung eines statischen Abonnements für C ++ 17 und die Vorteile dieses Ansatzes in einigen Anwendungen. </p><a name="habracut"></a><br><h2 id="vvedenie">  Einleitung </h2><br><p> Template Subscriber ist eine der häufigsten Vorlagen, die in der Softwareentwicklung verwendet werden.  Damit führen sie beispielsweise die Verarbeitung von Tastenklicks in Windows Form durch.  Wie auch immer, an jedem Ort, an dem Sie auf Änderungen der Systemparameter reagieren müssen, sei es auf Änderungen in Dateien oder auf die Aktualisierung des Messwerts vom Sensor, ist es Zeit <del>  ohne nachzudenken </del>  Verwenden Sie die Abonnentenvorlage. </p><br><p>  Der Vorteil der Vorlage besteht darin, dass wir das Wissen des Herausgebers und Abonnenten freisetzen, ohne an bestimmte Objekte gebunden zu sein.  Wir können jeden für jeden signieren, ohne die Implementierung der Publisher- und Subscriber-Objekte zu beeinträchtigen. </p><br><h2 id="nachalnye-usloviya">  Anfangsbedingungen </h2><br><p>  Bevor wir uns mit der Vorlage vertraut machen, stimmen wir zunächst zu, dass wir zuverlässige Software entwickeln möchten, in der: </p><br><ul><li>  Verwenden Sie keine dynamische Speicherzuordnung </li><li>  Minimieren Sie die Arbeit mit Zeigern </li><li>  Wir verwenden so viele Konstanten wie möglich, damit niemand so viel wie möglich ändern kann </li><li>  Gleichzeitig verwenden wir jedoch so wenig Konstanten wie möglich, die sich im RAM befinden </li></ul><br><p>  Betrachten wir nun die Standardimplementierung der Subscriber-Vorlage. </p><br><h2 id="standartnaya-realizaciya">  Standardimplementierung </h2><br><p>  Angenommen, wir haben eine Schaltfläche, und wenn Sie auf die Schaltfläche klicken, müssen wir die LEDs blinken lassen, aber wie viele davon sind bisher unbekannt, und in der Tat müssen Sie möglicherweise nicht mit LEDs blinken, sondern mit einem Scheinwerfer auf dem Schiff, um Nachrichten im Morsecode zu übertragen.  Es ist wichtig, dass wir nicht wissen, wer abonniert wird.  Leider habe ich keinen Scheinwerfer zur Hand, so dass alle Beispiele im Artikel der Einfachheit halber und zum besseren Verständnis mit LEDs gemacht werden. </p><br><p>  Wenn Sie also die Taste drücken, müssen Sie die LED über diese Betätigung benachrichtigen.  Nachdem Sie das Drücken gelernt haben, sollte die LED in den entgegengesetzten Zustand wechseln. <br>  Die Standardimplementierung in UML lautet wie folgt ... </p><br><p><img src="https://habrastorage.org/webt/zu/8g/ro/zu8gro30gxgngc8w36oesxy9w2i.png"></p><br><p> Hier ist die <code>ButtonController</code> Klasse dafür verantwortlich, die Schaltfläche <code>ButtonController</code> und die Abonnenten über den Klick zu benachrichtigen. In diesem Fall ist <code>Led</code> der Abonnent.  Diese beiden Klassen werden über die <code>IPublisher</code> und <code>ISubsriber</code> und keine der Klassen kennt die andere.  Somit kann jedes Objekt, das von der <code>ISubscriber</code> Schnittstelle erbt, ein Ereignis von <code>ButtonController</code> . </p><br><p>  Da die dynamische Speicherzuweisung verboten ist, habe ich ein Array von 3 Elementen für die Subskription deklariert.  Das heißt  Maximal können 3 Abonnenten sein.  In erster Näherung könnte die Methode zur Benachrichtigung von Abonnenten der <code>ButttonsController</code> Klasse daher aussehen </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> :</span></span> IPublisher { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          HandleEvent() for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } } ;</span></span></code> </pre> <br><p>  Alles Salz befindet sich in der <code>Notify()</code> -Methode der <code>Publisher</code> Klasse.  Bei dieser Methode gehen wir die Liste der Abonnenten durch und rufen <code>HandleEvent()</code> für jeden von ihnen auf. Dies ist cool, da jeder Abonnent diese Methode auf seine eigene Weise implementiert und dies dort tun kann <del>  alle </del>  Was auch immer Ihr Herz begehrt (in der Tat müssen Sie vorsichtig sein, sonst weiß der Teufel, was der Abonnent dort tut, Sie können seine Methode zum Beispiel durch eine Unterbrechung aufrufen und Sie müssen wachsam sein, um zu verhindern, dass Abonnenten lange und schlechte Dinge tun) </p><br><p>  In unserem Fall darf die LED alles tun, also schaltet sie ihren Zustand um: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Led</span></span></span><span class="hljs-class">:</span></span> ISubscriber { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Port::ODR::Toggle(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,    ,  Toggle() ; } };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Vollständige Implementierung aller Klassen</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; struct ISubscriber { virtual void HandleEvent() = 0; } ; struct IPublisher { virtual void Notify() const = 0; virtual void Subscribe(ISubscriber* subscriber) = 0; } ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led: ISubscriber { static void Toggle() { Port::ODR::Toggle(1 &lt;&lt; pinNum); } void HandleEvent() override { Toggle() ; } }; struct ButtonController : IPublisher { void Run() { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const override { for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } void Subscribe(ISubscriber* subscriber) override { if (index &lt; pSubscribers.size()) { pSubscribers[index] = subscriber ; index ++ ; } //   3   ...   } private: std::array&lt;ISubscriber*, 3&gt; pSubscribers ; std::size_t index = 0U ; } ;</span></span></code> </pre></div></div><br><p>  Wie kann ein Abonnement im Code aussehen?  Und so: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static Led&lt;GPIOC,9&gt; Led3 ; ButtonController buttonController ; //  3  buttonController.Subscribe(&amp;Led1) ; buttonController.Subscribe(&amp;Led2) ; buttonController.Subscribe(&amp;Led3) ; //       buttonController.Run() ; }</span></span></code> </pre> <br><p>  Die gute Nachricht ist, dass wir jedes Objekt signieren können und der Zeitpunkt seiner Erstellung für uns keine Rolle spielt.  Es kann ein globales Objekt sein, statisch oder lokal.  Einerseits ist das gut, andererseits, warum müssen wir die Laufzeit in diesem Code abonnieren.  Tatsächlich ist hier die Adresse der Objekte <code>Led1</code> , <code>Led2</code> , <code>Led3</code> in der <code>Led3</code> bekannt.  Warum können Sie sich also bei der Kompilierung nicht anmelden und eine Reihe von Zeigern auf Abonnenten im ROM behalten? </p><br><p>  Darüber hinaus besteht die Gefahr potenzieller Fehler. Wie viele haben sich beispielsweise gefragt, was beim Aufrufen der <code>Subsribe()</code> Methode passieren würde, wenn sie von mehreren Threads aus aufgerufen würde?  Wir sind auf 3 Abonnenten beschränkt. Was passiert, wenn wir 4 LEDs signieren? </p><br><p>  In den meisten Fällen benötigen wir dieses Abonnement einmal im Leben während der Initialisierung. Wir speichern lediglich Zeiger auf Abonnenten und das wars.  Der Zeiger behält die Adresse dieser Abonnenten ein Leben lang.  Und der Tag ist unvermeidlich, an dem es ruiniert werden kann <del>  aufgrund von Supernova-Ausbruch </del>  (natürlich, wenn wir einen längeren Zeitraum in Betracht ziehen).  In jedem Fall ist die Wahrscheinlichkeit eines RAM-Ausfalls jedoch viel höher als die des ROM, und es wird nicht empfohlen, permanente Daten im RAM zu speichern. </p><br><p>  Nun, die schlechte Nachricht ist, dass eine solche Architekturlösung sowohl im ROM als auch im RAM oooooochen viel Platz beansprucht.  Nur für den Fall, wir schreiben, wie viel ROM und RAM diese Lösung benötigt: </p><br><div class="scrollable-table"><table><thead><tr><th>  Modul </th><th>  Ro-Code </th><th>  ro Daten </th><th>  RW-Daten </th></tr></thead><tbody><tr><td>  main.o </td><td>  488 </td><td>  64 </td><td>  21 </td></tr></tbody></table></div><br><p>  Das heißt  Insgesamt 552 Bytes im ROM und 21 Bytes im RAM - sagen wir nicht so viel, um eine Taste zu drücken und drei LEDs zu blinken. </p><br><p>  Um sich vor solchen Problemen zu schützen und den Verbrauch von Controller-Ressourcen zu reduzieren, sollten Sie die Option mit einem statischen Abonnement in Betracht ziehen. </p><br><h2 id="staticheskaya-podpiska">  Statisches Abonnement </h2><br><p>  Um das Abonnement statisch zu machen, können Sie verschiedene Ansätze verwenden.  Ich werde sie so benennen: </p><br><ul><li>  Der traditionelle Ansatz ist derselbe, verwendet jedoch den Konstruktor constexpr und legt die Liste der Abonnenten fest. </li><li><del>  Unkonventionell </del>  Vorlagen verwenden - Übertragen Sie die Liste der Abonnenten über die Vorlagenparameter.  (hier ist eine Vorlage eine Definition aus dem Bereich der Metaprogrammierung, keine Entwurfsmuster) </li></ul><br><h3 id="tradicionnyy-podhod-k-staticheskoy-podpiske">  Der traditionelle Ansatz für statische Abonnements </h3><br><p>  Lassen Sie uns versuchen, in der Kompilierungsphase zu abonnieren.  Dazu optimieren wir unsere Architektur ein wenig: </p><br><p><img src="https://habrastorage.org/webt/lr/_k/gy/lr_kgyobfgkebxpz9gfyqiod34u.png"></p><br><p>  Das Bild unterscheidet sich nicht wesentlich vom Original, es gibt jedoch einige Unterschiede: Die Methode <code>Subscribe()</code> wurde entfernt, und das Abonnement wird jetzt direkt im Konstruktor ausgeführt.  Der Konstruktor muss eine variable Anzahl von Argumenten akzeptieren, und um in der Kompilierungsphase statisch signieren zu können, ist er <code>constexpr</code> .  Darin wird ein Array von Abonnenten initialisiert, und diese Initialisierung kann zur Kompilierungszeit durchgeführt werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> :</span></span> IPublisher { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">*... args)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pSubscribers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;ISubscriber <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt; result = {args...} ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index = <span class="hljs-number"><span class="hljs-number">0U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it: result) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index &lt; size) { pSubscribers[index] = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;ISubscriber*&gt;(it); } index ++ ; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = <span class="hljs-number"><span class="hljs-number">3U</span></span>; ISubscriber* pSubscribers[size] ; } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Vollständiger Code für eine solche Implementierung</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISubscriber</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; } ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPublisher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led: ISubscriber { constexpr Led() { } static void Toggle() { Port::ODR::Toggle(1&lt;&lt;pinNum); } void HandleEvent() const override { Toggle() ; } }; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; struct ButtonController : IPublisher { template&lt;typename... Args&gt; constexpr ButtonController(Args const*... args): pSubscribers() { std::initializer_list&lt;ISubscriber const*&gt; result = {args...} ; std::size_t index = 0U; for(auto it: result) { if (index &lt; size) { pSubscribers[index] = const_cast&lt;ISubscriber*&gt;(it); } index ++ ; } } void Run() const { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const override { for(auto it: pSubscribers) { if (it != nullptr) { it-&gt;HandleEvent() ; } } } private: static constexpr std::size_t size = 3U; ISubscriber* pSubscribers[size] ; } ;</span></span></code> </pre></div></div><br><p>  Jetzt kann das Abonnement zur Kompilierungszeit erfolgen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static constexpr Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static constexpr Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static constexpr Led&lt;GPIOC,9&gt; Led3 ; static constexpr ButtonController buttonController(&amp;Led1, &amp;Led2, &amp;Led3) ; buttonController.Run() ; return 0 ; } ;</span></span></code> </pre> <br><p>  Hier befindet sich das <code>buttonController</code> Objekt zusammen mit einer Reihe von Zeigern auf Abonnenten vollständig im ROM: </p><br><blockquote>  main :: buttonController 0x800'1f04 0x10 Daten main.o [1] </blockquote><p>  Alles scheint nichts zu sein, außer dass wir wieder auf nur 3 Abonnenten beschränkt sind.  Und die Publisher-Klasse muss über einen Constexpr-Konstruktor verfügen und im Allgemeinen vollständig konstant sein, um einen Zeiger auf Abonnenten im ROM zu gewährleisten. Andernfalls wird unser Objekt mit allen Inhalten auch bei bekannten Abonnentenadressen wieder in den RAM verschoben. </p><br><p>  Von den anderen Nachteilen - da virtuelle Funktionen immer noch verwendet werden, werden die virtuellen Funktionstabellen Stück für Stück in unserem ROM gespeichert.  Und die Ressource ist zwar erschwinglich, aber nicht unendlich.  In den meisten Anwendungen ist es möglich, darauf zu hämmern und einen größeren Mikrocontroller zu verwenden. Es kommt jedoch häufig vor, dass jedes Byte zählt, insbesondere bei Produkten, die von Hunderttausenden hergestellt werden, z. B. physischen Sensoren. </p><br><p>  Mal sehen, wie es mit dem Speicher in dieser Lösung aussieht: </p><br><div class="scrollable-table"><table><thead><tr><th>  Modul </th><th>  Ro-Code </th><th>  ro Daten </th><th>  RW-Daten </th></tr></thead><tbody><tr><td>  main.o </td><td>  172 </td><td>  76 </td><td>  0 </td></tr></tbody></table></div><br><p>  Und obwohl das Ergebnis „umwerfend“ ist: Der gesamte RAM-Verbrauch beträgt 0 Byte und der ROM-Speicher 248 Byte, was der Hälfte der ersten Lösung entspricht, besteht nach Ansicht des Herstellers noch Verbesserungspotenzial.  Von diesen 248 Bytes belegen ungefähr 50 nur die virtuellen Methodentabellen. </p><br><p>  <u>Ein kleiner Exkurs:</u> <br>  Ein Schritt in der ROM-Größe von 256 kByte für moderne Mikrocontroller ist die Norm (beispielsweise hat der TI Cortex M4-Mikrocontroller 256 kByte ROM und die nächste Version ist bereits 512 kByte).  Und es wird nicht sehr gut sein, wenn wir aufgrund von 50 zusätzlichen Bytes einen Controller mit einem 256-kByte-ROM nehmen müssen, der größer und teurer ist. Daher können durch den Verzicht auf virtuelle Funktionen bis zu 50 Cent eingespart werden (der Unterschied zwischen dem Mikrocontroller in einem 256- und 512-kByte-ROM beträgt ungefähr 50-60 Cent). </p><br><p>  Das klingt für einen Mikrocontroller lächerlich, aber bei einer Charge von 400.000 Geräten pro Jahr können Sie 200.000 US-Dollar sparen.  Schon gar nicht so lustig, aber was für eine Ratte.  Sie können das Angebot mit einem Diplom und einer Geschenkkarte für 3.000 Rubel belohnen. Es besteht absolut kein Zweifel an der Richtigkeit, virtuelle Funktionen abzulehnen und zusätzliche 50 Bytes im ROM zu sparen. </p><br><h3 id="netradicionnyy-podhod">  Unkonventioneller Ansatz </h3><br><p>  Lassen Sie uns sehen, wie Sie dasselbe ohne virtuelle Funktionen tun und etwas mehr ROM sparen können. </p><br><p>  Lassen Sie uns zuerst herausfinden, wie es sein könnte: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Led1    5  GPIOC static Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static Led&lt;GPIOC,9&gt; Led3 ; //   ButtonController&lt;Led1, Led2, Led3&gt; buttonController ; buttonController.Run() ; return 0 ; }</span></span></code> </pre> <br><p>  Unsere Aufgabe ist es, die beiden Objekte Publisher ( <code>ButtonController</code> ) und Subscriber ( <code>Led</code> ) voneinander zu entkoppeln, damit sie sich nicht kennen, <code>ButtonController</code> aber gleichzeitig <code>Led</code> benachrichtigen kann. </p><br><p>  Sie können die <code>ButtonController</code> Klasse <code>ButtonController</code> irgendeine Weise deklarieren. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;&amp; subscriber1, Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">8</span></span>&gt;&amp; subscriber2, Led&lt;GPIOC,<span class="hljs-number"><span class="hljs-number">9</span></span>&gt;&amp; subscriber3&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ subscriber1.HandleEvent() ; subscriber2.HandleEvent() ; subscriber3.HandleEvent() ; } ... } ;</code> </pre> <br><p>  Sie verstehen jedoch, dass wir hier an bestimmte Typen gebunden sind und die Definition der <code>BbuttonController</code> Klasse jedes Mal in einem neuen Projekt neu <code>BbuttonController</code> .  Und ich möchte <code>ButtonController</code> einfach ohne <code>ButtonController</code> in das neue Projekt aufnehmen und verwenden. </p><br><p>  C ++ 17 rettet Sie, indem Sie den Typ nicht angeben können, sondern den Compiler bitten, den Typ für Sie abzuleiten - genau das brauchen Sie.  Wir können, genau wie beim traditionellen Ansatz, das Wissen des Herausgebers und des Abonnenten freisetzen, während die Anzahl der Abonnenten praktisch unbegrenzt ist. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; } ... } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">So funktioniert die Funktion pass (..)</b> <div class="spoiler_text"><p>  Die <code>Notify()</code> -Methode ruft die <code>pass()</code> -Funktion auf und erweitert die Vorlagenparameter mit einer variablen Anzahl von Argumenten </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; }</code> </pre> <br><p>  Die Implementierung der <code>pass()</code> -Funktion ist einfach nicht vorstellbar, es ist nur eine Funktion, die eine variable Anzahl von Argumenten akzeptiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ } } ;</code> </pre> <br><p>  Wie erweitert sich die Funktion <code>HandleEvent()</code> in mehrere Aufrufe für jeden der Teilnehmer? </p><br><p>  Da die Funktion <code>pass()</code> mehrere Argumente eines beliebigen Typs <code>bool</code> , können Sie mehrere Argumente des Typs <code>bool</code> Sie können beispielsweise die Funktion <code>pass(true, true, true)</code> aufrufen.  In diesem Fall wird natürlich nichts passieren, aber wir brauchen nicht. </p><br><p>  In der Zeile <code>(subscribers.HandleEvent() , true)</code> wird der Operator "," (Komma) verwendet, der beide Operanden (von links nach rechts) ausführt und den Wert des zweiten Operators zurückgibt, d. H. <code>subscribers.HandleEvent()</code> wird zuerst ausgeführt und dann <code>true</code> die Funktion <code>true</code> <code>pass()</code> wird auf <code>true</code> . </p><br><p>  Nun, "..." ist ein Standardeintrag zum Erweitern einer variablen Anzahl von Argumenten.  Für unseren Fall können die Aktionen des Compilers sehr schematisch wie folgt beschrieben werden: </p><br><pre> <code class="cpp hljs">pass((subscribers.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)...) ; -&gt; pass((Led1.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led2.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led1.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, (Led2.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>), (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led2.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, (Led3.HandleEvent() , <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ; -&gt; Led3.HandleEvent() ; -&gt; pass(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) ;</code> </pre> </div></div><br><p>  Anstelle von Links können Sie Zeiger verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> ... } ;</code> </pre> <br><p>  <strong>Ergänzung:</strong> Eigentlich danke an <a href="https://habr.com/ru/users/vamireh/" class="user_link">Vamireh,</a> der <a href="https://habr.com/ru/post/481606/">darauf hingewiesen hat,</a> dass all diese Tänze mit sind <del>  Tamburin </del>  <code>pass</code> Funktion in C ++ 17 ist nicht erforderlich.  Da der Operator "," das Komma im Fold-Ausdruck (der im C ++ 17-Standard eingeführt wurde) unterstützt, wird der Code weiter vereinfacht: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; ... subscribers&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ButtonController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; ;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UserButton::IsPressed()) { Notify() ; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ((subscribers.HandleEvent()), ...) ; } } ;</code> </pre> <br><p>  Generell sieht es architektonisch sehr einfach aus: </p><br><p><img src="https://habrastorage.org/webt/hx/di/jj/hxdijj1xdfvncxtdsr04a1qp_ve.png"></p><br><p>  Ich habe hier eine weitere LCD-Klasse hinzugefügt, aber nur zum Beispiel, um zu zeigen, dass es jetzt nicht mehr auf den Typ und die Anzahl der Abonnenten ankommt. Hauptsache, es würde die <code>HandleEvent()</code> -Methode implementieren. </p><br><p>  Und der gesamte Code im Allgemeinen ist jetzt auch einfacher: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Port::IDR::Read() &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; pinNum)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { while ((Port::IDR::Read() &amp; (1 &lt;&lt; pinNum)) == 0) //     { }; result = true; } return result; } } ; //     GPIOC.13 using UserButton = Button&lt;GPIOC, 13&gt; ; template &lt;typename Port, std::uint32_t pinNum&gt; struct Led { static void Toggle() { Port::ODR::Toggle(1&lt;&lt;pinNum); } void HandleEvent() const { Toggle() ; } }; template &lt;auto&amp; ... subscribers&gt; struct ButtonController { void Run() const { for(; ;) { if (UserButton::IsPressed()) { Notify() ; } } } void Notify() const { ((subscribers.HandleEvent()), ...) ; } } ; int main() { //  Led1    5  GPIOC static constexpr Led&lt;GPIOC,5&gt; Led1 ; //  Led2    8  GPIOC static constexpr Led&lt;GPIOC,8&gt; Led2 ; //  Led3    9  GPIOC static constexpr Led&lt;GPIOC,9&gt; Led3 ; static constexpr ButtonController&lt;Led1, Led2, Led3&gt; buttonController ; buttonController.Run() ; return 0 ; }</span></span></code> </pre> <br><p>  Der Aufruf <code>Notify()</code> in der Methode <code>Run()</code> wird zu einem einfachen sequenziellen Aufruf </p><br><pre> <code class="cpp hljs">Led1.HandleEvent() ; Led2.HandleEvent() ; Led3.HandleEvent() ;</code> </pre> <br><p>  Was ist mit der Erinnerung hier? </p><br><div class="scrollable-table"><table><thead><tr><th>  Modul </th><th>  Ro-Code </th><th>  ro Daten </th><th>  RW-Daten </th></tr></thead><tbody><tr><td>  main.o </td><td>  186 </td><td>  4 </td><td>  0 </td></tr></tbody></table></div><br><p>  ROM insgesamt 190 Bytes und 0 Bytes RAM.  Jetzt ist die Bestellung fast 3-mal kleiner als die Standardversion, während es genau das Gleiche leistet. </p><br><p>  Wenn Sie also die Adressen der Abonnenten bereits in der Anmeldung bekannt haben und die am Anfang des Artikels definierten Bedingungen einhalten </p><br><div class="spoiler">  <b class="spoiler_title">Bedingungen am Anfang des Artikels</b> <div class="spoiler_text"><ul><li>  Verwenden Sie keine dynamische Speicherzuordnung </li><li>  Minimieren Sie die Arbeit mit Zeigern </li><li>  Wir verwenden so viele Konstanten wie möglich, damit niemand so viel wie möglich ändern kann </li><li>  Gleichzeitig verwenden wir jedoch so wenig Konstanten wie möglich, die sich im RAM befinden </li></ul></div></div><br><p>  Mit Vertrauen können Sie eine solche Implementierung der Publisher-Subscriber-Vorlage verwenden, um Codezeilen zu reduzieren und Ressourcen zu sparen. Dort können Sie nicht nur eine Geschenkkarte, sondern auch einen Bonus für das Jahr anfordern. </p><br><p>  Das <a href="https://yadi.sk/d/_nF8mwnX0tXkKA" rel="nofollow">Testbeispiel unter IAR 8.40.2 liegt hier</a> </p><br><p>  Alles mit dem Kommen!  Und viel Glück im neuen Jahr! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481606/">https://habr.com/ru/post/de481606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481594/index.html">Entwicklung eines „einfachen Spannungsgenerators“ nach GOST R IEC 61508 (IEC 61508)</a></li>
<li><a href="../de481596/index.html">Analysieren der ELK 7.5-Einstellungen für die Mikrotik-Protokollanalyse</a></li>
<li><a href="../de481598/index.html">Ein kleiner Beitrag zum Kampf gegen die Avalonia UI-Zoo-Plattformen</a></li>
<li><a href="../de481600/index.html">Bonsai Family Wiki Engine: 2019 Ergebnisse</a></li>
<li><a href="../de481604/index.html">Wie hart Tscheljabinsk Entwickler Spiele für Google Play und soziale Netzwerke machen</a></li>
<li><a href="../de481610/index.html">PostgreSQL Antipatterns: Aktualisierung einer großen Tabelle unter Last</a></li>
<li><a href="../de481612/index.html">Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfläche für weniger Plattformen</a></li>
<li><a href="../de481616/index.html">Geodätische Kuppel. Über das Gerät und meine Erfahrungen mit Berechnungen</a></li>
<li><a href="../de481618/index.html">MVP in Unity oder wie man das Leben vereinfacht</a></li>
<li><a href="../de481620/index.html">Juniper SRX und Cisco ASA: Nächste Serie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>