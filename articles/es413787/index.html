<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñãÔ∏è üçç üí™üèª Angular: ngx-translate. Mejorando la infraestructura con Webpack üèÜ üôÇ üë©üèΩ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen dia 


 Es hora de hackear la vida ngx-translate. Inicialmente, plane√© 3 partes, pero debido a que la segunda parte en realidad no es muy informa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular: ngx-translate. Mejorando la infraestructura con Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413787/"><p>  Buen dia </p><br><p>  Es hora de hackear la vida ngx-translate.  Inicialmente, plane√© 3 partes, pero debido a que la segunda parte en realidad no es muy informativa, tratar√© de resumir la segunda parte lo m√°s brevemente posible. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> </p><br><p> Considere <code>AppTranslateLoader</code> para reemplazar <code>TranslateHttpLoader</code> .  Nuestro <code>AppTranslateLoader</code> prestar√° atenci√≥n en primer lugar al idioma del navegador y contendr√° la l√≥gica de respaldo, importar√° localizaciones de MomentJs y cargar√° a trav√©s de APP_INITIALIZER.  Adem√°s, como resultado de combinar 2 partes de hacks de vida, en el camino profundizaremos en la creaci√≥n de una infraestructura de localizaci√≥n conveniente y flexible en el proyecto. </p><br><p>  El objetivo principal no es <code>AppTranslateLoader</code> (porque es bastante simple y no dif√≠cil de hacer), sino la creaci√≥n de infraestructura. </p><br><p>  Trat√© de escribir lo m√°s accesible posible, pero debido a que el art√≠culo tiene muchas cosas que se pueden describir con m√°s detalle, tomar√° mucho tiempo y no ser√° interesante para aquellos que ya saben c√≥mo hacerlo.  Por lo tanto, el art√≠culo no fue muy amigable para los principiantes.  Por otro lado, al final hay un enlace para expandir prodg. </p><a name="habracut"></a><br><p>  Antes de comenzar, quiero se√±alar que adem√°s de descargar idiomas a trav√©s de http, es posible escribir un cargador de tal manera que cargue los idiomas necesarios en nuestro paquete en la etapa de ensamblaje.  Por lo tanto, no necesita agregar ning√∫n cargador a trav√©s de http, pero, por otro lado, con este enfoque, deber√° reconstruir la aplicaci√≥n cada vez que cambiemos nuestros archivos con localizaciones y, adem√°s, esto puede aumentar considerablemente el tama√±o del paquete .js. </p><br><pre> <code class="hljs pgsql">// webpack-translate-loader.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TranslateLoader } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@ngx-translate/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> WebpackTranslateLoader implements TranslateLoader { getTranslation(lang: string): Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.fromPromise(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(`../assets/i18n/${lang}.json`)); } }</code> </pre> <br><p>  Si el IDE jura en el <code>System</code> debe agregarlo a typings.d.ts: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>; interface <span class="hljs-keyword"><span class="hljs-keyword">System</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(request: string): Promise&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;; }</code> </pre> <br><p>  Ahora podemos usar <code>WebpackTranslateLoader</code> en app.module: </p><br><pre> <code class="hljs powershell">@NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], imports: [ <span class="hljs-type"><span class="hljs-type">TranslateModule.forRoot</span></span>({ <span class="hljs-type"><span class="hljs-type">loader</span></span>: { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TranslateLoader</span></span>, <span class="hljs-type"><span class="hljs-type">useClass</span></span>: <span class="hljs-type"><span class="hljs-type">WebpackTranslateLoader</span></span> } }) ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <cut></cut><br><h4 id="apptranslateloader">  AppTranslateLoader </h4><br><p>  Entonces, comencemos a escribir nuestro <code>AppTranslateLoader</code> .  Para empezar, quiero identificar varios problemas que deber√°n encontrarse utilizando el est√°ndar <code>TranslateHttpLoader</code> : </p><br><ul><li><p>  <strong>Traducir parpadeo.</strong>  <code>TranslateHttpLoader</code> no sabe c√≥mo ejecutar como parte del proceso de inicializaci√≥n de la aplicaci√≥n y podemos entrar en una situaci√≥n en la que despu√©s de la inicializaci√≥n vemos que tenemos el lugar para las etiquetas correctas en la aplicaci√≥n: las teclas (MY_BUTTON_KEY es el lugar de Mi bot√≥n), que despu√©s de un momento cambia al texto correcto. </p><br></li><li><p>  <strong>Fechas</strong>  Ser√≠a bueno tener un servicio que cambie la localizaci√≥n de fechas.  Cuando se trata de localizar texto, lo m√°s probable es que tenga que ocuparse de localizar fechas, horas, etc.  Puede usar momentJs o la soluci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">i18n</a> integrada en Angular.  Ambas soluciones son buenas y tienen tuber√≠as Angular 2+ para formatear en vistas. </p><br></li><li>  <strong>Almacenamiento en cach√©.</strong>  usando <code>TranslateHttpLoader</code> , debe configurar su servidor FE para almacenar correctamente sus paquetes json.  De lo contrario, los usuarios ver√°n versiones antiguas de localizaci√≥n, peor a√∫n ver√°n claves de localizaci√≥n (si se agregaron nuevas despu√©s del almacenamiento en cach√© del usuario).  No quiero molestarme cada vez que despliegue en un nuevo servidor con el momento de configurar el almacenamiento en cach√©.  As√≠ que haremos que Webpack haga todo por nosotros de la misma manera que lo hace con los paquetes .js. </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Borrador de AppTranslateLoader</a> </p><cut></cut><br><h5 id="resheniya-problem">  Soluciones a problemas: </h5><br><h6 id="1-problema-translate-flickering---ispolzovat-apptranslateloaderv-ramkah-app_initializer">  1. problema de parpadeo de traducci√≥n: use <code>AppTranslateLoader</code> como parte de <code>APP_INITIALIZER</code> </h6><br><p>  APP_INITIALIZER tambi√©n particip√≥ activamente en un art√≠culo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">token de actualizaci√≥n</a> , si no tiene buen gusto sobre el inicializador. Le aconsejo que lea el art√≠culo a pesar de que se trata de token de actualizaci√≥n.  De hecho, la decisi√≥n de usar initializer es muy obvia (para aquellos que tienen un initializer), pero aun as√≠ espero que haya personas que sean √∫tiles: </p><br><pre> <code class="hljs powershell">//app.module.ts export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translationLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loader: AppTranslateLoader)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; loader.loadTranslation(); } @NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], providers: [ { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">APP_INITIALIZER</span></span>, <span class="hljs-type"><span class="hljs-type">useFactory</span></span>: <span class="hljs-type"><span class="hljs-type">translationLoader</span></span>, <span class="hljs-type"><span class="hljs-type">deps</span></span>: [<span class="hljs-type"><span class="hljs-type">AppTranslateLoader</span></span>], <span class="hljs-type"><span class="hljs-type">multi</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> } ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br><h6 id="2-problema-dat-prosto-budem-pereklyuchat-yazyk-v-momentjs-vmeste-c-ngx-tranlate">  2. El problema de las fechas.  Simplemente cambiaremos el idioma en el momento Js junto con ngx-tranlate. </h6><br><p>  Aqu√≠ todo es simple: despu√©s de cargar json con localizaci√≥n, simplemente cambiamos la localizaci√≥n a momentJs (o i18n). </p><br><p>  Tambi√©n vale la pena se√±alar que momentJs, como i18n, puede importar localizaciones por separado, momentJs tambi√©n puede importar un paquete, pero el paquete completo de localizaciones toma ~ 260 KB, y solo necesita 2 de ellas. </p><br><p>  En este caso, puede importar solo 2 de ellos directamente en el archivo donde <code>AppTranslateLoader</code> declara <code>AppTranslateLoader</code> . </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>;</code> </pre> <br><p>  Ahora las localizaciones en-gb y ru estar√°n en el paquete de aplicaciones js.  En <code>AppTranslateLoader</code> puede agregar un controlador de idioma reci√©n cargado: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> Class AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . }</code> </pre> <br><p>  !!!  este controlador tiene un inconveniente: si en nuestro proyecto solo se proporciona la localizaci√≥n en para ngx-translate, pero, por ejemplo, en el momento o la necesidad de usar en o en-gb, la l√≥gica del controlador tendr√° que expandirse, o la localizaci√≥n de en-gb tambi√©n debe proporcionarse en ngx-translate. </p><br><p>  !!!  por el momento con // TODO: podemos escribir un complemento de paquete web, consideraremos un par de complementos m√°s adelante, pero todav√≠a no lo tengo. </p><br><p>  Usted pregunta, ¬øpor qu√© es imposible cargar localizaciones de fechas y horas, as√≠ como localizaciones de texto en la interfaz (din√°micamente, a trav√©s de HTTP)?  Esto se debe a que las localizaciones de fechas contienen su propia l√≥gica y, por lo tanto, se presentan como c√≥digo <a href="">JavaScript</a> . </p><br><p>  Pero a pesar de esto, hay una manera de cargar tales localizaciones escribiendo un peque√±o c√≥digo 'sucio'.  No uso este c√≥digo en producci√≥n, pero la segunda localizaci√≥n dentro de mi paquete no me molesta.  Pero si tiene muchas localizaciones, desea cargarlas de forma din√°mica y no muy segura, tenga en cuenta: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadAngularCulture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angularLocaleText = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(`assets/angular-locales/${locale}.js`).toPromise(); <span class="hljs-comment"><span class="hljs-comment">// extracting the part of the js code before the data, // and i didn't need the plural so i just replace plural by null. const startPos = angularLocaleText.indexOf('export default '); angularLocaleText = 'return ' + angularLocaleText.substring(startPos + 15).replace('plural', null); // The trick is here : to read cldr data, i use a function const f = new Function(angularLocaleText); const angularLocale = f(); // console.log(angularLocale); // And now, just registrer the object you just created with the function registerLocaleData(angularLocale); }</span></span></code> </pre> <br><p>  La √∫ltima vez que prob√© este m√©todo en Angular 4. Lo m√°s probable es que est√© funcionando ahora. </p><br><p>  Desafortunadamente, un truco de vida tan sucio no funcionar√° en el caso de c momentJs (solo localizaci√≥n angular).  Al menos no pude encontrar una manera de hacer esto, pero si eres un programador de hackers muy barbudo, me alegrar√° ver la soluci√≥n en los comentarios. </p><br><h6 id="3-keshirovanie-podobno-sborke-js-bandla-mozhno-dobavit-k-imeni-json-bandla-hesh">  3. Almacenamiento en cach√©.  Similar a la construcci√≥n de un paquete .js, puede agregar un hash al nombre del paquete .json. </h6><br><p>  Todo depende de c√≥mo recopile exactamente todos los json'es en un archivo, tal vez solo tenga todo en un archivo.  En Internet, puede encontrar varios m√≥dulos npm que pueden recopilar peque√±os json en un archivo.  No encontr√© a aquellos que pueden adjuntar a un hash y recopilar todo en un archivo.  Webpack en s√≠ tampoco puede manejar json como lo requieren los detalles de ngx-translate.  Por lo tanto, escribiremos nuestro complemento webpack. </p><br><p>  En resumen: necesitamos recopilar todos los json en el proyecto de acuerdo con un patr√≥n espec√≠fico, mientras que necesitamos agruparlos por nombre (en, ru, de, etc.) porque, por ejemplo, en.json puede estar en diferentes carpetas.  Luego, para cada archivo recopilado, debe adjuntar un hash. </p><br><p>  Hay un problema aqu√≠.  ¬øC√≥mo reconoce <code>AppTranslateLoader</code> los nombres de los archivos si cada localizaci√≥n tiene su propio nombre?  Por ejemplo, incluyendo el paquete en index.html, podemos incluir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HtmlWebpackPlugin</a> y pedirle que agregue una etiqueta de script con el nombre del paquete por s√≠ mismo. </p><br><p>  Para resolver este problema para las localizaciones .json, nuestro complemento webpack crear√° config.json, que contendr√° la asociaci√≥n del c√≥digo de idioma con el nombre del archivo hash: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"en.some_hash.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru.some_hash.json"</span></span> }</code> </pre> <br><p>  config.json tambi√©n ser√° almacenado en cach√© por el navegador, pero tomar√° un poco de tiempo y simplemente podemos especificar un par√°metro de queryString aleatorio cuando GET est√° cubierto con este archivo (cargando constantemente de nuevo).  O asigne una ID aleatoria a config.json (describir√© este m√©todo, el primero se puede encontrar en Google). </p><br><p>  Tambi√©n quiero simplificar un poco la infraestructura y la atomicidad de las localizaciones.  json con localizaci√≥n se ubicar√° en la carpeta con su componente.  Y para evitar claves duplicadas, la estructura del paquete json se construir√° en funci√≥n de la ruta a un archivo json espec√≠fico.  Por ejemplo, tenemos dos en.json, uno se encuentra en la ruta <code>src/app/article-component</code> y el otro <code>src/app/comment-component</code> .  En la salida, quiero obtener este json: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"article-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Article title"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"comment-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Comment title"</span></span> } }</code> </pre> <br><p>  Podemos descartar la parte de la ruta que no necesitamos, para que las claves sean lo m√°s cortas posible en las vistas. </p><br><p>  !!!  Hay un inconveniente: cuando coloca el componente en otra carpeta, la clave de localizaci√≥n cambiar√°. </p><br><p>  M√°s adelante consideraremos otro truco de vida que nos permitir√° indicar en el componente solo el √∫ltimo campo clave, independientemente de d√≥nde y qu√© tan profundo est√© nuestro proyecto en el proyecto, y en consecuencia podemos transferirlo a su gusto y cambiarle el nombre a su gusto. </p><br><p>  B√°sicamente, quiero lograr la encapsulaci√≥n e incluso una pizca de polimorfismo de localizaciones ngx-translate.  Me gusta el concepto de encapsular vistas en Angular - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Angular View Encapsulation</a> , o m√°s bien el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Shadow DOM</a> .  S√≠, esto aumenta el tama√±o de la aplicaci√≥n en su conjunto, pero dir√© de antemano que despu√©s de que ngx-translate se haya encapsulado m√°s, trabajar con archivos de localizaci√≥n se ha vuelto mucho m√°s agradable.  Los componentes comenzaron a preocuparse solo por sus localizaciones, adem√°s, ser√° posible redefinir las localizaciones en el componente secundario dependiendo de las localizaciones en el componente primario.  Adem√°s, ahora puede transferir componentes de un proyecto a otro, y ya estar√°n localizados.  Pero como en otros lugares, hay matices, m√°s sobre eso m√°s adelante. </p><br><p>  As√≠ que pasemos a nuestro complemento.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Qu√© es y c√≥mo</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fusionar el complemento de localizaciones</a> . <br>  El c√≥digo fuente para el cargador y el complemento se puede encontrar en el enlace de ejemplo en la parte inferior del art√≠culo (carpeta ./build-utils). </p><br><p>  El complemento hace todo lo que est√° escrito arriba y acepta las siguientes opciones: </p><br><ul><li>  omitir  nombres en la ruta de localizaci√≥n que deben ignorarse (este es exactamente el momento en el que quiero eliminar las partes adicionales de la ruta al archivo) </li><li>  fileInput.  regular para recuperar archivos de localizaci√≥n en prodge (como prueba en paquete web) </li><li>  rootDir.  d√≥nde comenzar a buscar archivos por el patr√≥n fileInput </li><li>  outputDir.  donde se crear√°n el archivo de configuraci√≥n y las localizaciones en la carpeta dist </li><li>  configName.  bajo qu√© nombre se crear√° el archivo de configuraci√≥n. </li></ul><br><p>  En mi proyecto, el complemento est√° conectado de esta manera: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// build-utils.js // part of METADATA { // ... translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config.${Math.random().toString(36).substr(2, 9)}.json`, } //webpack.common.js new MergeLocalizationPlugin({ fileInput: [`**/${METADATA.translationsFolder}/*.json`, 'app-translations/**/*.json'], rootDir: 'src', omit: new RegExp(`app-translations|${METADATA.translationsFolder}|^app`, 'g'), outputDir: METADATA.translationsOutputDir, configName: METADATA.translationsConfig }),</span></span></code> </pre> <br><p>  Dentro de los componentes que necesitan localizaci√≥n hay una carpeta <code>@translations</code> , que contiene en.json, ru, etc. </p><br><p>  Como resultado, al voltear, todo se recopilar√° en un archivo, teniendo en cuenta la ruta a la carpeta <code>@translations</code> .  El paquete de localizaci√≥n estar√° en dist / langs /, y la configuraci√≥n se denominar√° como config. $ {Some-random} .json. </p><br><p>  A continuaci√≥n, nos aseguraremos de que el paquete de localizaci√≥n deseado est√© cargado en la aplicaci√≥n.  Hay un punto fr√°gil: solo el paquete web conoce la ruta a las localizaciones y el nombre del archivo de configuraci√≥n, tengamos esto en cuenta para que los datos m√°s recientes ingresen a AppTranslateLoader y no haya necesidad de cambiar los nombres en dos lugares. </p><br><pre> <code class="hljs powershell">// some inmports // ... // momentJs import * as moment from <span class="hljs-string"><span class="hljs-string">'moment'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>; @Injectable() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppTranslateLoader</span></span></span></span> { //            public additionalStorageKey: string = <span class="hljs-string"><span class="hljs-string">''</span></span>; private translationsDir: string; private translationsConfig: string; private selectedLang: string; private fallbackLang: string; private loadedLang: string; private config: { [<span class="hljs-type"><span class="hljs-type">key</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>]: string; } = null; private loadSubs = new Subscription(); private configSubs = new Subscription(); private loadSubj = new Subject(); private get storageKey(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.additionalStorageKey ? `APP_LANG_<span class="hljs-variable"><span class="hljs-variable">$</span></span>{this.additionalStorageKey}` : <span class="hljs-string"><span class="hljs-string">'APP_LANG'</span></span>; } constructor(private http: HttpClient, private translate: TranslateService) { //   webpack       //     . this.translationsDir = `${process.env.TRANSLATE_OUTPUT}`; this.translationsConfig = `${process.env.TRANSLATE_CONFIG}`; this.fallbackLang = <span class="hljs-string"><span class="hljs-string">'en'</span></span>; const storedLang = this.getUsedLanguage(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (storedLang) { this.selectedLang = storedLang; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { this.selectedLang = translate.getBrowserLang() || this.fallbackLang; } } }</code> </pre> <br><p>  <code>process.env.TRANSLATE_OUTPUT</code> simplemente no funcionar√°, necesitamos declarar otro complemento en webpack (DefinePlugin o EnvironmentPlugin): </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// METADATA declaration const METADATA = { translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config. ${Math.random().toString(36).substr(2, 9)}.json`, }; // complex webpack config... // webpack plugins... new DefinePlugin({ 'process.env.TRANSLATE_OUTPUT': JSON.stringify(METADATA.translationsOutputDir), 'process.env.TRANSLATE_CONFIG': JSON.stringify(METADATA.translationsConfig), }),</span></span></code> </pre> <br><p>  Ahora podemos cambiar la ruta a las localizaciones y el nombre de la configuraci√≥n en un solo lugar. <br>  De manera predeterminada, desde la venta angular generada en el ensamblaje de paquete web ( <code>ng eject</code> eject), no puede especificar <code>process.env.someValue</code> desde el c√≥digo (incluso si usa DefinePlugin), el compilador puede jurar.  Para que esto funcione, debe cumplir las condiciones 2a: </p><br><ul><li>  en main.ts agregue la primera l√≠nea <code>/// &lt;reference types="node"/&gt;</code> </li><li>  package.json debe tener <code>@types/node</code> - <code>npm install --save-dev @types/node</code> . </li></ul><br><p>  Procedemos directamente al proceso de arranque. <br>  Si tiene la intenci√≥n de usar APP_INITIALIZER, aseg√∫rese de devolver Promise, not Observable.  Nuestra tarea es escribir una cadena de consulta: </p><br><ul><li>  Primero debe descargar config.json (solo si no est√° cargado). </li><li>  intenta cargar el idioma, que es el idioma del navegador del usuario </li><li>  Proporcione l√≥gica de respaldo con el idioma de descarga predeterminado. </li></ul><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> imports @Injectable() AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fields ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,         <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subscription    unsubscribe    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   private loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); private configSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       -   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subject       private loadSubj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> constructor ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Promise! public loadTranslation(lang: string = <span class="hljs-string"><span class="hljs-string">''</span></span>): Promise&lt;any&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lang) { lang = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang; } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lang === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsConfig}</span></span>`) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config: any)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config = config; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.asObservable().toPromise(); } private loadAndUseLang(lang: string) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[lang] || </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.fallbackLang]}</span></span>`) .subscribe(res =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.setTranslation(lang, res); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(lang).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(lang); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  ngx-translate   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  http   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); } private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . } private onLoadLangError(langKey: string, error: any) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) .subscribe( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(err)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (langKey !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      fallback  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(error); } }</code> </pre> <br><p>  Listo </p><br><p>  Ahora volvamos al problema de mover componentes a otras carpetas, encapsulaci√≥n y semejanza del polimorfismo. </p><br><p>  De hecho, ya tenemos alg√∫n tipo de encapsulaci√≥n.  Las localizaciones se insertan en carpetas al lado de los componentes, todas las rutas de teclas son √∫nicas, pero a√∫n podemos localizar las teclas del componente some-component1 dentro de some-component2 y ser√° dif√≠cil hacer un seguimiento de todo, lo resolveremos m√°s adelante. </p><br><pre> <code class="hljs powershell">&lt;some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span> [<span class="hljs-type"><span class="hljs-type">someLabel</span></span>]=<span class="hljs-string"><span class="hljs-string">"'components.some-component2.some_key' | tanslate"</span></span>&gt;&lt;/some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span>&gt; // components.some<span class="hljs-literal"><span class="hljs-literal">-component2</span></span> -    </code> </pre> <br><p>  En cuanto al movimiento de componentes: <br>  Ahora, la clave que usaremos en la vista est√° r√≠gidamente vinculada a la ruta relativa al archivo de localizaci√≥n y depende de la infraestructura espec√≠fica del proyecto. </p><br><p>  Dar√© un caso bastante triste de esta situaci√≥n: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">translate</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"+lazy-module.components.article-component.article_title"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Pero, ¬øqu√© sucede si cambio el nombre de la carpeta del componente a postcomponente? <br>  Ser√° bastante dif√≠cil ingresar esta clave en todos los lugares necesarios.  Por supuesto, nadie cancel√≥ copiar-pegar y buscar-reemplazar, pero escribir esto sin las indicaciones del IDE tambi√©n es estresante. </p><br><p>  Para resolver estos problemas, prestemos atenci√≥n a lo que est√° haciendo webpack al respecto.  Webpack tiene un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cargador</a> , hay muchos cargadores disponibles que operan en rutas de archivos: por ejemplo, rutas de recursos en css - gracias a webpack podemos especificar rutas relativas a la imagen de fondo: url (../ relative.png), y as√≠ ¬°El resto de las rutas de archivo en el proyecto est√°n en todas partes! </p><br><p>  Quien haya realizado sus compilaciones de paquetes web sabe que el cargador recibe un archivo en la entrada que coincide con un cierto patr√≥n.  La tarea del cargador en s√≠ es transformar de alguna manera este archivo de entrada y devolverlo, para otros cambios por parte de otros cargadores. </p><br><p>  Por lo tanto, necesitamos escribir nuestro cargador.  La pregunta es qu√© tipo de archivos cambiaremos: ¬øvistas o componentes?  Por un lado, las vistas pueden estar directamente en el componente y por separado.  Las vistas pueden ser lo suficientemente grandes y dif√≠ciles de analizar, imagine si tenemos una vista donde 100 directivas de traducci√≥n (no en un bucle): </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'./some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; ... &lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"100"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'../another_key_!'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre><br><p>  a trav√©s del cargador podemos sustituir la ruta clave a las localizaciones de componentes cerca de cada tuber√≠a o directiva. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'app.some-component.some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; <span class="hljs-comment"><span class="hljs-comment">// app.some-component. -   loader'</span></span></code> </pre> <br><p>  podemos agregar un campo a un componente que proporciona localizaci√≥n: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-some'</span></span></span><span class="hljs-meta">, template: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'&lt;div&gt;{{(localization + '</span></span></span><span class="hljs-meta">key</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">') | tanslate}}&lt;/div&gt;'</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ localization = <span class="hljs-string"><span class="hljs-string">'./'</span></span> }</code> </pre> <br><p>  Tambi√©n es malo: debe componer una clave de localizaci√≥n en todas partes. </p><br><p>  Dado que las opciones m√°s obvias se ven mal, intente usar un decorador y guarde algunos metadatos en el prototipo del componente (como lo hace Angular). </p><br><p><img src="https://habrastorage.org/webt/gu/_4/vp/gu_4vpfjn_3ujxoh3tragj7wi2s.png" alt="imagen"></p><br><p>  <strong>anotaciones</strong> - metadatos para decoradores angulares <br>  __app_annotations__ - metadatos que almacenaremos para nosotros mismos </p><br><p>  La ruta a la carpeta de localizaci√≥n relativa al componente se puede escribir en el decorador, el mismo decorador se puede ampliar con otras opciones excepto la ruta. </p><br><pre> <code class="hljs powershell">//translate.service.ts const app_annotations_key = <span class="hljs-string"><span class="hljs-string">'__app_annotations__'</span></span>; export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Localization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: string)</span></span></span></span> { // tslint:<span class="hljs-built_in"><span class="hljs-built_in">disable-next</span></span><span class="hljs-literal"><span class="hljs-literal">-line</span></span>:only<span class="hljs-literal"><span class="hljs-literal">-arrow</span></span><span class="hljs-literal"><span class="hljs-literal">-functions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target: Function)</span></span></span></span> { const metaKey = app_annotations_key; Object.defineProperty(target, metaKey, { value: { //         path. path, name: <span class="hljs-string"><span class="hljs-string">'Translate'</span></span> } } as PropertyDescriptor); }; } //some.component.ts @Component({...}) @Localization({ path: <span class="hljs-string"><span class="hljs-string">'./'</span></span>, otherOptions: {...} }); export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span></span> { }</code> </pre> <br><p>      webpack,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">loader</a>           ,      -    .          ,     (      styleUrls)      . loader,     npm .    . </p><br><p>        ,   -.       ,          -. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'just_key'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre> <br><p>          .    ,      ,      ,           .    ‚Äî Injector, .   ,       Injector,     ''  ,  translate       .      Injector,       (    ),         'get'. </p><br><p><img src="https://habrastorage.org/webt/jl/vw/0x/jlvw0xsep9o3valmkhc3uxblvdm.png" alt="imagen"></p><br><p>  ,  parent  ,     ,    Injector'a  ,      ,     ,   ,   ,        . </p><br><p>  ,     API,   forwarRef() (    Angular reactive forms,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">control</a> ).  ,      .         . </p><br><pre> <code class="hljs powershell">// translate.service.ts export const TRANSLATE_TOKEN = new InjectionToken(<span class="hljs-string"><span class="hljs-string">'MyTranslateToken'</span></span>); // app.component.ts @Component({ selector: <span class="hljs-string"><span class="hljs-string">'app-root'</span></span>, templateUrl: <span class="hljs-string"><span class="hljs-string">'./app.component.html'</span></span>, styleUrls: [<span class="hljs-string"><span class="hljs-string">'./app.component.css'</span></span>], providers: [{<span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TRANSLATE_TOKEN</span></span>, <span class="hljs-type"><span class="hljs-type">useExisting</span></span>: <span class="hljs-type"><span class="hljs-type">forwardRef</span></span>(() =&gt; <span class="hljs-type"><span class="hljs-type">AppComponent</span></span>)}] }) @Localization(<span class="hljs-string"><span class="hljs-string">'./'</span></span>) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span></span> { title = <span class="hljs-string"><span class="hljs-string">'app'</span></span>; }</code> </pre> <br><p>        , ,         ,   forwardRef(). </p><br><p>  ,     Injector     forwardRef()        ,             .       ,        '' .     ,   ,   . </p><br><pre> <code class="hljs pgsql">// my-translate.directive.ts @Directive({ // tslint:<span class="hljs-keyword"><span class="hljs-keyword">disable</span></span>-next-<span class="hljs-type"><span class="hljs-type">line</span></span>:directive-selector selector: <span class="hljs-string"><span class="hljs-string">'[myTranslate]'</span></span> }) export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyTranslateDirective extends TranslateDirective { @<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> myTranslate(e: string) { this.translate = e; } private keyPath: string; constructor(private _translateService: TranslateService, private _element: ElementRef, _chRef: ChangeDetectorRef, //    forwardRef() @Inject(TRANSLATE_TOKEN) @Optional() protected cmp: <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>) { super(_translateService, _element, _chRef); //    const prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.getPrototypeOf(cmp || {}).constructor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prototype[app_annotations_key]) { //      this.keyPath = prototype[app_annotations_key].path; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> updateValue(key: string, node: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, translations: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.keyPath) { //     ,   //   key = `${this.keyPath.replace(/\//, <span class="hljs-string"><span class="hljs-string">'.'</span></span>)}.${key}`; } super.updateValue(key, node, translations); } }</code> </pre> <br><p>      . </p><br><p>  -      : </p><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{'just_this_component_key' | myTranslate}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">myTranslate</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"just_this_component_key"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>    translate , .      ,       ,          -    : </p><br><pre> <code class="hljs pgsql">//en.bundle.json { "global_key": "Global key" "app-component": { "just_key": "Just key" } } //<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.html &lt;div translate="global_key"&gt;&lt;/div&gt;</code> </pre> <br><p> Research and improve! </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">full example</a> </p><br><p>       : </p><br><ol><li>     FE     node.js   stacktrace.js. </li><li>  Jest  Angular . </li><li> Web worker )      , ,  Angular  . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413787/">https://habr.com/ru/post/es413787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413775/index.html">Los ataques adversos en Machines Can See 2018</a></li>
<li><a href="../es413777/index.html">Lectura de fin de semana: IaaS Materiales introductorios, seguridad de la informaci√≥n y eventos regulatorios de TI</a></li>
<li><a href="../es413779/index.html">Temporizadores y multitarea en Arduino</a></li>
<li><a href="../es413781/index.html">C√≥mo los sabuesos publicitarios siguen tu rastro en Internet</a></li>
<li><a href="../es413783/index.html">¬øC√≥mo mueren las estrellas m√°s masivas: supernova, hipernova o colapso directo?</a></li>
<li><a href="../es413789/index.html">En Florida, no revisaron a los compradores de armas en la base del FBI durante un a√±o porque olvidaron la contrase√±a</a></li>
<li><a href="../es413791/index.html">Mec√°nica Cu√°ntica de C√°lculos en JS</a></li>
<li><a href="../es413793/index.html">Casetes de audio en la cultura pop: por qu√© el formato de grabaci√≥n de sonido obsoleto se considera nuevamente de moda</a></li>
<li><a href="../es413795/index.html">Por qu√© la industria del entretenimiento se est√° mudando a IaaS: estudio de caso</a></li>
<li><a href="../es413797/index.html">EA present√≥ la nueva parte de C&C en E3. Y es f√≠sicamente doloroso mirarlo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>