<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游녫游 游낻 游뗼 칈ndices en PostgreSQL - 5 (GiST) 拘勇 游꾹 游댐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En los art칤culos anteriores, discutimos el motor de indexaci칩n PostgreSQL, la interfaz de los m칠todos de acceso y dos m칠todos de acceso: 칤ndice hash y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>칈ndices en PostgreSQL - 5 (GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444742/">  En los art칤culos anteriores, discutimos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de indexaci칩n</a> PostgreSQL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la interfaz de los m칠todos de acceso</a> y dos m칠todos de acceso: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">칤ndice hash</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">치rbol B.</a>  En este art칤culo, describiremos los 칤ndices GiST. <br><br><h1>  Gist </h1><br>  GiST es una abreviatura de "치rbol de b칰squeda generalizada".  Este es un 치rbol de b칰squeda equilibrado, al igual que "b-tree" discutido anteriormente. <br><br>  Cual es la diferencia  El 칤ndice "Btree" est치 estrictamente conectado a la sem치ntica de comparaci칩n: todo lo que es capaz de hacer es el soporte de operadores "mayores", "menores" e "iguales" (춰pero muy capaces!) Sin embargo, las bases de datos modernas almacenan tipos de datos para los cuales estos operadores simplemente no tiene sentido: geodatos, documentos de texto, im치genes, ... <br><br>  El m칠todo de 칤ndice GiST nos ayuda en estos tipos de datos.  Permite definir una regla para distribuir datos de un tipo arbitrario en un 치rbol equilibrado y un m칠todo para utilizar esta representaci칩n para el acceso de alg칰n operador.  Por ejemplo, el 칤ndice GiST puede "acomodar" el 치rbol R para datos espaciales con soporte de operadores de posici칩n relativa (ubicados a la izquierda, a la derecha, contiene, etc.) o el 치rbol RD para conjuntos con soporte de operadores de intersecci칩n o inclusi칩n. <br><br>  Gracias a la extensibilidad, se puede crear un m칠todo totalmente nuevo desde cero en PostgreSQL: para este fin, se debe implementar una interfaz con el motor de indexaci칩n.  Pero esto requiere una premeditaci칩n no solo de la l칩gica de indexaci칩n, sino tambi칠n de la asignaci칩n de estructuras de datos a p치ginas, la implementaci칩n eficiente de bloqueos y el soporte de un registro de escritura anticipada.  Todo esto supone altas habilidades de desarrollo y un gran esfuerzo humano.  GiST simplifica la tarea al hacerse cargo de los problemas de bajo nivel y ofrecer su propia interfaz: varias funciones que no pertenecen a las t칠cnicas, sino al dominio de la aplicaci칩n.  En este sentido, podemos considerar GiST como un marco para construir nuevos m칠todos de acceso. <br><a name="habracut"></a><br><h2>  Estructura </h2><br>  GiST es un 치rbol de altura equilibrada que consta de p치ginas de nodos.  Los nodos consisten en filas de 칤ndice. <br><br>  Cada fila de un nodo hoja (fila hoja), en general, contiene alg칰n <em>predicado</em> (expresi칩n booleana) y una referencia a una fila de tabla (TID).  Los datos indexados (clave) deben cumplir con este predicado. <br><br>  Cada fila de un nodo interno (fila interna) tambi칠n contiene un <em>predicado</em> y una referencia a un nodo secundario, y todos los datos indexados del sub치rbol secundario deben cumplir con este predicado.  En otras palabras, el predicado de una fila interna <em>incluye</em> los predicados de todas las filas secundarias.  Este rasgo importante del 칤ndice GiST reemplaza la simple ordenaci칩n del 치rbol B. <br><br>  La b칰squeda en el 치rbol GiST utiliza una <em>funci칩n de coherencia</em> especializada ("coherente"), una de las funciones definidas por la interfaz e implementada a su manera para cada familia de operadores admitida. <br><br>  Se llama a la funci칩n de coherencia para una fila de 칤ndice y determina si el predicado de esta fila es coherente con el predicado de b칰squeda (especificado como " <em>expresi칩n de operador de campo indexado</em> ").  Para una fila interna, esta funci칩n realmente determina si es necesario descender al sub치rbol correspondiente, y para una fila de hoja, la funci칩n determina si los datos indexados cumplen con el predicado. <br><br>  La b칰squeda comienza con un nodo ra칤z, como una b칰squeda de 치rbol normal.  La funci칩n de coherencia permite averiguar en qu칠 nodos secundarios tiene sentido ingresar (puede haber varios) y cu치les no.  El algoritmo se repite para cada nodo secundario encontrado.  Y si el nodo es hoja, la fila seleccionada por la funci칩n de coherencia se devuelve como uno de los resultados. <br><br>  La b칰squeda es profunda primero: el algoritmo primero intenta alcanzar un nodo hoja.  Esto permite devolver los primeros resultados pronto siempre que sea posible (lo que podr칤a ser importante si el usuario est치 interesado en solo varios resultados en lugar de en todos). <br><br>  Observemos una vez m치s que la funci칩n de coherencia no necesita tener nada que ver con operadores "mayores", "menores" o "iguales".  La sem치ntica de la funci칩n de consistencia puede ser bastante diferente y, por lo tanto, no se supone que el 칤ndice devuelva valores en un cierto orden. <br><br>  No discutiremos los algoritmos de inserci칩n y eliminaci칩n de valores en GiST: algunas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones de interfaz</a> m치s realizan estas operaciones.  Sin embargo, hay un punto importante.  Cuando se inserta un nuevo valor en el 칤ndice, la posici칩n para este valor en el 치rbol se selecciona de modo que los predicados de sus filas principales se extiendan lo menos posible (idealmente, no se extienden en absoluto).  Pero cuando se elimina un valor, el predicado de la fila principal ya no se reduce.  Esto solo sucede en casos como estos: una p치gina se divide en dos (cuando la p치gina no tiene suficiente espacio para la inserci칩n de una nueva fila de 칤ndice) o el 칤ndice se recrea desde cero (con el comando REINDEX o VACUUM FULL).  Por lo tanto, la eficiencia del 칤ndice GiST para los datos que cambian con frecuencia puede degradarse con el tiempo. <br><br>  Adem치s, consideraremos algunos ejemplos de 칤ndices para varios tipos de datos y propiedades 칰tiles de GiST: <br><br><ul><li>  Puntos (y otras entidades geom칠tricas) y b칰squeda de vecinos m치s cercanos. </li><li>  Intervalos y restricciones de exclusi칩n. </li><li>  B칰squeda de texto completo. </li></ul><br><h2>  R-tree para puntos </h2><br>  Ilustraremos lo anterior con un ejemplo de un 칤ndice para puntos en un plano (tambi칠n podemos construir 칤ndices similares para otras entidades geom칠tricas).  Un 치rbol B normal no se adapta a este tipo de datos ya que no se definen operadores de comparaci칩n para los puntos. <br><br>  La idea de R-tree es dividir el plano en rect치ngulos que en total cubran todos los puntos que se indexan.  Una fila de 칤ndice almacena un rect치ngulo, y el predicado se puede definir as칤: "el punto buscado se encuentra dentro del rect치ngulo dado". <br><br>  La ra칤z del 치rbol R contendr치 varios rect치ngulos m치s grandes (posiblemente intersectados).  Los nodos secundarios contendr치n rect치ngulos de menor tama침o que est치n incrustados en el primario y en total cubren todos los puntos subyacentes. <br><br>  En teor칤a, los nodos hoja deben contener puntos que se indexan, pero el tipo de datos debe ser el mismo en todas las filas de 칤ndice y, por lo tanto, nuevamente los rect치ngulos se almacenan, pero se "colapsan" en puntos. <br><br>  Para visualizar dicha estructura, proporcionamos im치genes para tres niveles del 치rbol R.  Los puntos son coordenadas de aeropuertos (similares a los de la tabla "aeropuertos" de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">base de datos de demostraci칩n</a> , pero se proporcionan m치s datos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">openflights.org</a> ). <br><br><img src="https://habrastorage.org/web/492/fd0/a28/492fd0a2883b4ee39d75618f8f501e50.png"><br>  <em>Nivel uno: dos grandes rect치ngulos que se cruzan son visibles.</em> <br><br><img src="https://habrastorage.org/web/e42/78d/843/e4278d8439a3485e88128182f741b696.png"><br>  <em>Nivel dos: los rect치ngulos grandes se dividen en 치reas m치s peque침as.</em> <br><br><img src="https://habrastorage.org/web/60e/c9d/99b/60ec9d99b4fe46c88bed2a9cc65dd0f5.png"><br>  <em>Nivel tres: cada rect치ngulo contiene tantos puntos como para caber en una p치gina de 칤ndice.</em> <br><br>  Ahora consideremos un ejemplo muy simple de "un nivel": <br><br><img src="https://habrastorage.org/web/d89/478/666/d894786665774a76943e72338aec874c.png"><br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(p);</code> </pre> <br>  Con esta divisi칩n, la estructura del 칤ndice tendr치 el siguiente aspecto: <br><br><img src="https://habrastorage.org/web/caf/919/8a5/caf9198a538d46f48985d42a301a0b2d.png"><br><br>  El 칤ndice creado se puede usar para acelerar la siguiente consulta, por ejemplo: "buscar todos los puntos contenidos en el rect치ngulo dado".  Esta condici칩n se puede formalizar de la siguiente manera: <code>p &lt;@ box '(2,1),(6,3)'</code> (operador <code>&lt;@</code> de la familia "points_ops" significa "contenido en"): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using points_p_idx on points Index Cond: (p &lt;@ '(7,4),(2,1)'::box) (2 rows)</code> </pre><br>  La funci칩n de coherencia del operador (" <em>campo indexado</em> &lt;@ <em>expresi칩n</em> ", donde <em>el campo indexado</em> es un punto y la <em>expresi칩n</em> es un rect치ngulo) se define de la siguiente manera.  Para una fila interna, devuelve "s칤" si su rect치ngulo se cruza con el rect치ngulo definido por la <em>expresi칩n</em> .  Para una fila de hojas, la funci칩n devuelve "s칤" si su punto (rect치ngulo "colapsado") est치 contenido en el rect치ngulo definido por la expresi칩n. <br><br><img src="https://habrastorage.org/web/226/f28/493/226f28493e15430193a69781e1600b9f.png"><br><br>  La b칰squeda comienza con el nodo ra칤z.  El rect치ngulo (2,1) - (7,4) se cruza con (1,1) - (6,3), pero no se cruza con (5,5) - (8,8), por lo tanto, no es necesario para descender al segundo sub치rbol. <br><br><img src="https://habrastorage.org/web/d52/792/511/d527925110fb46deadb382762561a621.png"><br><br>  Al llegar a un nodo hoja, pasamos por los tres puntos contenidos all칤 y devolvemos dos de ellos como resultado: (3.2) y (6.3). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (3,2) (6,3) (2 rows)</code> </pre><br><h3>  Internos </h3><br>  Desafortunadamente, la "inspecci칩n de p치gina" habitual no permite buscar en el 칤ndice GiST.  Pero hay otra forma disponible: extensi칩n "gevel".  No se incluye en la entrega est치ndar, por lo tanto, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las instrucciones de instalaci칩n</a> . <br><br>  Si todo se hace correctamente, tres funciones estar치n disponibles para usted.  Primero, podemos obtener algunas estad칤sticas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_stat(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_stat ------------------------------------------ Number of levels: 4 + Number of pages: 690 + Number of leaf pages: 625 + Number of tuples: 7873 + Number of invalid tuples: 0 + Number of leaf tuples: 7184 + Total size of tuples: 354692 bytes + Total size of leaf tuples: 323596 bytes + Total size of index: 5652480 bytes+ (1 row)</code> </pre><br>  Est치 claro que el tama침o del 칤ndice en las coordenadas del aeropuerto es de 690 p치ginas y que el 칤ndice consta de cuatro niveles: la ra칤z y dos niveles internos se muestran en las figuras anteriores, y el cuarto nivel es hoja. <br><br>  En realidad, el 칤ndice de ocho mil puntos ser치 significativamente m치s peque침o: aqu칤 se cre칩 con un factor de relleno del 10% para mayor claridad. <br><br>  En segundo lugar, podemos generar el 치rbol de 칤ndice: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_tree(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_tree ----------------------------------------------------------------------------------------- 0(l:0) blk: 0 numTuple: 5 free: 7928b(2.84%) rightlink:4294967295 (InvalidBlockNumber) + 1(l:1) blk: 335 numTuple: 15 free: 7488b(8.24%) rightlink:220 (OK) + 1(l:2) blk: 128 numTuple: 9 free: 7752b(5.00%) rightlink:49 (OK) + 1(l:3) blk: 57 numTuple: 12 free: 7620b(6.62%) rightlink:35 (OK) + 2(l:3) blk: 62 numTuple: 9 free: 7752b(5.00%) rightlink:57 (OK) + 3(l:3) blk: 72 numTuple: 7 free: 7840b(3.92%) rightlink:23 (OK) + 4(l:3) blk: 115 numTuple: 17 free: 7400b(9.31%) rightlink:33 (OK) + ...</code> </pre><br>  Y tercero, podemos generar los datos almacenados en filas de 칤ndice.  Tenga en cuenta el siguiente matiz: el resultado de la funci칩n debe convertirse al tipo de datos necesario.  En nuestra situaci칩n, este tipo es "caja" (un rect치ngulo delimitador).  Por ejemplo, observe cinco filas en el nivel superior: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">box</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------------------------------- 1 | (47.663586,80.803207),(-39.2938003540039,-90) 1 | (179.951004028,15.6700000762939),(15.2428998947144,-77.9634017944336) 1 | (177.740997314453,73.5178070068359),(15.0664,10.57970047) 1 | (-77.3191986083984,79.9946975708),(-179.876998901,-43.810001373291) 1 | (-39.864200592041,82.5177993774),(-81.254096984863,-64.2382965088) (5 rows)</code> </pre><br>  En realidad, las cifras proporcionadas anteriormente se crearon solo a partir de estos datos. <br><br><h2>  Operadores para buscar y ordenar </h2><br>  Los operadores discutidos hasta ahora (como <code>&lt;@</code> en el predicado <code>p &lt;@ box '(2,1),(7,4)'</code> ) pueden llamarse operadores de b칰squeda ya que especifican condiciones de b칰squeda en una consulta. <br><br>  Tambi칠n hay otro tipo de operador: operadores de pedidos.  Se utilizan para especificaciones del orden de clasificaci칩n en la cl치usula ORDER BY en lugar de especificaciones convencionales de nombres de columna.  El siguiente es un ejemplo de dicha consulta: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (5,5) (7,8) (2 rows)</code> </pre><br>  <code>p &lt;-&gt; point '(4,7)'</code> aqu칤 es una expresi칩n que usa un operador de orden <code>&lt;-&gt;</code> , que denota la distancia de un argumento al otro.  El significado de la consulta es devolver dos puntos m치s cercanos al punto (4.7).  Una b칰squeda como esta se conoce como k-NN - k-b칰squeda de vecinos m치s cercanos. <br><br>  Para admitir consultas de este tipo, un m칠todo de acceso debe definir una <em>funci칩n de distancia</em> adicional, y el operador de pedido debe incluirse en la clase de operador apropiada (por ejemplo, clase "points_ops" para puntos).  La consulta a continuaci칩n muestra los operadores, junto con sus tipos ("s" - buscar y "o" - ordenar): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------+-------------+-------------- &lt;&lt;(point,point) | s | 1 strictly left &gt;&gt;(point,point) | s | 5 strictly right ~=(point,point) | s | 6 coincides &lt;^(point,point) | s | 10 strictly below &gt;^(point,point) | s | 11 strictly above &lt;-&gt;(point,point) | o | 15 distance &lt;@(point,box) | s | 28 contained in rectangle &lt;@(point,polygon) | s | 48 contained in polygon &lt;@(point,circle) | s | 68 contained in circle (9 rows)</code> </pre><br>  Tambi칠n se muestran los n칰meros de estrategias, con sus significados explicados.  Est치 claro que hay muchas m치s estrategias que para "btree", solo algunas de ellas son compatibles con puntos.  Se pueden definir diferentes estrategias para otros tipos de datos. <br><br>  La funci칩n de distancia se llama para un elemento de 칤ndice y debe calcular la distancia (teniendo en cuenta la sem치ntica del operador) desde el valor definido por la expresi칩n (" <em>expresi칩n de operador de ordenaci칩n de campo indexado</em> ") hasta el elemento dado.  Para un elemento hoja, esta es solo la distancia al valor indexado.  Para un elemento interno, la funci칩n debe devolver el m칤nimo de las distancias a los elementos secundarios de la hoja.  Dado que recorrer todas las filas secundarias ser칤a bastante costoso, se permite que la funci칩n subestime de manera optimista la distancia, pero a expensas de reducir la eficiencia de b칰squeda.  Sin embargo, la funci칩n nunca puede sobreestimar la distancia, ya que esto interrumpir치 el trabajo del 칤ndice. <br><br>  La funci칩n de distancia puede devolver valores de cualquier tipo ordenable (para ordenar valores, PostgreSQL usar치 sem치ntica de comparaci칩n de la familia de operadores apropiada del m칠todo de acceso "btree", como se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describi칩 anteriormente</a> ). <br><br>  Para los puntos en un plano, la distancia se interpreta en un sentido muy habitual: el valor de <code>(x1,y1) &lt;-&gt; (x2,y2)</code> es igual a la ra칤z cuadrada de la suma de los cuadrados de las diferencias de las abscisas y las ordenadas.  La distancia desde un punto a un rect치ngulo delimitador se considera la distancia m칤nima desde el punto a este rect치ngulo o cero si el punto se encuentra dentro del rect치ngulo.  Es f치cil calcular este valor sin caminar a trav칠s de puntos secundarios, y el valor no es mayor que la distancia a cualquier punto secundario. <br><br>  Consideremos el algoritmo de b칰squeda para la consulta anterior. <br><br><img src="https://habrastorage.org/web/84b/56a/075/84b56a075dbd42d6b5d8cc8cb10c4b01.png"><br><br>  La b칰squeda comienza con el nodo ra칤z.  El nodo contiene dos rect치ngulos delimitadores.  La distancia a (1,1) - (6,3) es 4.0 y a (5,5) - (8,8) es 1.0. <br><br>  Los nodos secundarios se recorren en el orden de aumentar la distancia.  De esta manera, primero descendemos al nodo hijo m치s cercano y calculamos las distancias a los puntos (mostraremos los n칰meros en la figura para visibilidad): <br><br><img src="https://habrastorage.org/web/491/959/f07/491959f070754781b794e0dff01d5aec.png"><br><br>  Esta informaci칩n es suficiente para devolver los dos primeros puntos, (5,5) y (7,8).  Como somos conscientes de que la distancia a los puntos que se encuentran dentro del rect치ngulo (1,1) - (6,3) es 4.0 o mayor, no necesitamos descender al primer nodo secundario. <br><br>  Pero, 쯫 si necesit치ramos encontrar los primeros <em>tres</em> puntos? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="pgsql hljs"> p <span class="hljs-comment"><span class="hljs-comment">------- (5,5) (7,8) (8,6) (3 rows)</span></span></code> </pre><br>  Aunque el segundo nodo secundario contiene todos estos puntos, no podemos devolver (8,6) sin mirar el primer nodo secundario ya que este nodo puede contener puntos m치s cercanos (desde 4.0 &lt;4.1). <br><br><img src="https://habrastorage.org/web/9bb/43a/775/9bb43a775fc445769e37af8bb50daae0.png"><br><br>  Para las filas internas, este ejemplo aclara los requisitos para la funci칩n de distancia.  Al seleccionar una distancia m치s peque침a (4.0 en lugar de 4.5 real) para la segunda fila, redujimos la eficiencia (el algoritmo comenz칩 a examinar innecesariamente un nodo adicional), pero no rompi칩 la correcci칩n del algoritmo. <br><br>  Hasta hace poco, GiST era el 칰nico m칠todo de acceso capaz de tratar con operadores de pedidos.  Pero la situaci칩n ha cambiado: el m칠todo de acceso RUM (que se discutir치 m치s adelante) ya se ha unido a este grupo de m칠todos, y no es improbable que el viejo 치rbol B se una a ellos: se est치 implementando un parche desarrollado por Nikita Glukhov, nuestro colega. discutido por la comunidad. <br><blockquote>  A partir de marzo de 2019, se agreg칩 compatibilidad con k-NN para SP-GiST en el pr칩ximo PostgreSQL 12 (tambi칠n creado por Nikita).  El parche para B-tree todav칤a est치 en progreso. <br></blockquote><br><h2>  R-치rbol para intervalos </h2><br>  Otro ejemplo del uso del m칠todo de acceso GiST es la indexaci칩n de intervalos, por ejemplo, intervalos de tiempo (tipo "tsrange").  La diferencia es que los nodos internos contendr치n intervalos delimitadores en lugar de rect치ngulos delimitadores. <br><br>  Consideremos un ejemplo simple.  Alquilaremos una caba침a y almacenaremos los intervalos de reserva en una tabla: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations(during <span class="hljs-type"><span class="hljs-type">tsrange</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2016-12-30, 2017-01-09)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-02-23, 2017-02-27)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-04-29, 2017-05-02)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during);</code> </pre><br>  El 칤ndice se puede utilizar para acelerar la siguiente consulta, por ejemplo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> during ----------------------------------------------- ["2016-12-30 00:00:00","2017-01-08 00:00:00") ["2017-02-23 00:00:00","2017-02-26 00:00:00") (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Index Only Scan using reservations_during_idx on reservations Index Cond: (during &amp;&amp; '["2017-01-01 00:00:00","2017-04-01 00:00:00")'::tsrange) (2 rows)</code> </pre><br>  <code>&amp;&amp;</code> operador <code>&amp;&amp;</code> para intervalos denota intersecci칩n;  por lo tanto, la consulta debe devolver todos los intervalos que se cruzan con el dado.  Para dicho operador, la funci칩n de coherencia determina si el intervalo dado se cruza con un valor en una fila interna o de hoja. <br><br>  Tenga en cuenta que esto no se trata de obtener intervalos en un cierto orden, aunque los operadores de comparaci칩n se definen para intervalos.  Podemos usar el 칤ndice "btree" para intervalos, pero en este caso, tendremos que prescindir de operaciones como estas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'range_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------------+-------------+-------------- @&gt;(anyrange,anyelement) | s | 16 contains element &lt;&lt;(anyrange,anyrange) | s | 1 strictly left &amp;&lt;(anyrange,anyrange) | s | 2 not beyond right boundary &amp;&amp;(anyrange,anyrange) | s | 3 intersects &amp;&gt;(anyrange,anyrange) | s | 4 not beyond left boundary &gt;&gt;(anyrange,anyrange) | s | 5 strictly right -|-(anyrange,anyrange) | s | 6 adjacent @&gt;(anyrange,anyrange) | s | 7 contains interval &lt;@(anyrange,anyrange) | s | 8 contained in interval =(anyrange,anyrange) | s | 18 equals (10 rows)</code> </pre><br>  (Excepto la igualdad, que est치 contenida en la clase de operador para el m칠todo de acceso "btree"). <br><br><h3>  Internos </h3><br>  Podemos mirar dentro usando la misma extensi칩n "gevel".  Solo necesitamos recordar cambiar el tipo de datos en la llamada a gist_print: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'reservations_during_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">tsrange</span></span>);</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------- 1 | ["2016-12-30 00:00:00","2017-01-09 00:00:00") 1 | ["2017-02-23 00:00:00","2017-02-27 00:00:00") 1 | ["2017-04-29 00:00:00","2017-05-02 00:00:00") (3 rows)</code> </pre><br><h2>  Restricci칩n de exclusi칩n </h2><br>  El 칤ndice GiST se puede usar para admitir restricciones de exclusi칩n (EXCLUDE). <br><br>  La restricci칩n de exclusi칩n asegura que los campos dados de cualquiera de las dos filas de la tabla no se "correspondan" entre s칤 en t칠rminos de algunos operadores.  Si se elige el operador "igual", obtenemos exactamente la restricci칩n 칰nica: los campos dados de dos filas no son iguales entre s칤. <br><br>  La restricci칩n de exclusi칩n es compatible con el 칤ndice, as칤 como la restricci칩n 칰nica.  Podemos elegir cualquier operador para que: <br><br><ol><li>  Es compatible con el m칠todo de 칤ndice: propiedad "can_exclude" (por ejemplo, "btree", GiST o SP-GiST, pero no GIN). </li><li>  Es conmutativo, es decir, se cumple la condici칩n: un operador b = b operador a. </li></ol><br>  Esta es una lista de estrategias adecuadas y ejemplos de operadores (los operadores, como recordamos, pueden tener diferentes nombres y estar disponibles no para todos los tipos de datos): <br><br><ul><li>  Para "btree": <br><ul><li>  "Igual" <code>=</code> </li></ul></li><li>  Para GiST y SP-GiST: <br><ul><li>  "Intersecci칩n" <code>&amp;&amp;</code> </li><li>  "Coincidencia" <code>~=</code> </li><li>  Adyacencia <code>-|-</code> </li></ul></li></ul><br>  Tenga en cuenta que podemos usar el operador de igualdad en una restricci칩n de exclusi칩n, pero no es pr치ctico: una restricci칩n 칰nica ser치 m치s eficiente.  Eso es exactamente por qu칠 no tocamos las restricciones de exclusi칩n cuando discutimos los 치rboles B. <br><br>  Proporcionemos un ejemplo del uso de una restricci칩n de exclusi칩n.  Es razonable no permitir reservas para intervalos de intersecci칩n. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;);</code> </pre><br>  Una vez que creamos la restricci칩n de exclusi칩n, podemos agregar filas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-06-10, 2017-06-13)'</span></span>);</code> </pre><br>  Pero un intento de insertar un intervalo de intersecci칩n en la tabla dar치 como resultado un error: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_excl" DETAIL: Key (during)=(["2017-05-15 00:00:00","2017-06-15 00:00:00")) conflicts with existing key (during)=(["2017-06-10 00:00:00","2017-06-13 00:00:00")).</code> </pre><br><h3>  Extensi칩n "Btree_gist" </h3><br>  Vamos a complicar el problema.  Ampliamos nuestro humilde negocio, y vamos a alquilar varias casas de campo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> house_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Necesitamos cambiar la restricci칩n de exclusi칩n para que se tengan en cuenta los n칰meros de las casas.  Sin embargo, GiST no admite la operaci칩n de igualdad para n칰meros enteros: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> reservations_during_excl; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type integer has no default operator class for access method "gist" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  En este caso, la extensi칩n " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">btree_gist</a> " ayudar치, lo que agrega el soporte GiST de las operaciones inherentes a los B-trees.  GiST, eventualmente, puede soportar cualquier operador, entonces 쯣or qu칠 no deber칤amos ense침arlo a soportar operadores "mayores", "menores" e "iguales"? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gist; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><br>  Ahora todav칤a no podemos reservar la primera caba침a para las mismas fechas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_house_no_excl"</code> </pre><br>  Sin embargo, podemos reservar el segundo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Pero tenga en cuenta que aunque GiST de alguna manera puede admitir operadores "mayores", "menores" e "iguales", B-tree todav칤a lo hace mejor.  Por lo tanto, vale la pena usar esta t칠cnica solo si se necesita esencialmente el 칤ndice GiST, como en nuestro ejemplo. <br><br><h2>  RD-tree para b칰squeda de texto completo </h2><br><h3>  Acerca de la b칰squeda de texto completo </h3><br>  Comencemos con una introducci칩n minimalista a la b칰squeda de texto completo de PostgreSQL (si est치 al tanto, puede omitir esta secci칩n). <br><br>  La tarea de la b칰squeda de texto completo es seleccionar del conjunto de documentos aquellos documentos que <em>coinciden con</em> la consulta de b칰squeda.  (Si hay muchos documentos coincidentes, es importante encontrar <em>la mejor coincidencia</em> , pero no diremos nada al respecto en este momento). <br><br>  Para fines de b칰squeda, un documento se convierte en un tipo especializado "tsvector", que contiene <em>lexemas</em> y sus posiciones en el documento.  Los lexemas son palabras convertidas a la forma adecuada para la b칰squeda.  Por ejemplo, las palabras generalmente se convierten en min칰sculas y las terminaciones variables se cortan: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector ----------------------------------------- 'crook':4,10 'man':5 'mile':11 'walk':8 (1 row)</code> </pre><br>  Tambi칠n podemos ver que algunas palabras (llamadas <em>palabras de detenci칩n</em> ) se descartan por completo ("all칤", "era", "a", "y", "칠l"), ya que presumiblemente ocurren con demasiada frecuencia para buscarlas para que tengan sentido.  Todas estas conversiones ciertamente pueden configurarse, pero esa es otra historia. <br><br>  Una consulta de b칰squeda se representa con otro tipo: "tsquery".  Aproximadamente, una consulta consta de uno o varios lexemas unidos por conectivos: "y" &amp;, "o" |, "no"! .. Tambi칠n podemos usar par칠ntesis para aclarar la prioridad de la operaci칩n. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsquery ---------------------------- 'man' &amp; ( 'walk' | 'run' ) (1 row)</code> </pre><br>  Solo se utiliza un operador de coincidencia <code>@@</code> para la b칰squeda de texto completo. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (going | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- f (1 row)</code> </pre><br>  Esta informaci칩n es suficiente por ahora.  Nos sumergiremos un poco m치s en la b칰squeda de texto completo en el pr칩ximo art칤culo que presenta el 칤ndice GIN. <br><br><h3>  RD-치rboles </h3><br>  Para una b칰squeda r치pida de texto completo, en primer lugar, la tabla debe almacenar una columna de tipo "tsvector" (para evitar realizar una conversi칩n costosa cada vez que se busca) y, en segundo lugar, se debe construir un 칤ndice en esta columna.  Uno de los posibles m칠todos de acceso para esto es GiST. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(doc_tsv); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc);</code> </pre><br>  Sin duda, es conveniente confiar un disparador al 칰ltimo paso (conversi칩n del documento a "tsvector"). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------------------------------------------------- doc | Can a sheet slitter slit sheets? doc_tsv | 'sheet':3,6 'slit':5 'slitter':4 -[ RECORD 2 ]---------------------------------------------------- doc | How many sheets could a sheet slitter slit? doc_tsv | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 -[ RECORD 3 ]---------------------------------------------------- doc | I slit a sheet, a sheet I slit. doc_tsv | 'sheet':4,6 'slit':2,8 -[ RECORD 4 ]---------------------------------------------------- doc | Upon a slitted sheet I sit. doc_tsv | 'sheet':4 'sit':6 'slit':3 'upon':1 -[ RECORD 5 ]---------------------------------------------------- doc | Whoever slit the sheets is a good sheet slitter. doc_tsv | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 -[ RECORD 6 ]---------------------------------------------------- doc | I am a sheet slitter. doc_tsv | 'sheet':4 'slitter':5 -[ RECORD 7 ]---------------------------------------------------- doc | I slit sheets. doc_tsv | 'sheet':3 'slit':2 -[ RECORD 8 ]---------------------------------------------------- doc | I am the sleekest sheet slitter that ever slit sheets. doc_tsv | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 -[ RECORD 9 ]---------------------------------------------------- doc | She slits the sheet she sits on. doc_tsv | 'sheet':4 'sit':6 'slit':2</code> </pre><br>  쮺칩mo debe estructurarse el 칤ndice?  El uso de R-tree directamente no es una opci칩n, ya que no est치 claro c칩mo definir un "rect치ngulo delimitador" para los documentos.  Pero podemos aplicar alguna modificaci칩n de este enfoque para conjuntos, un llamado 치rbol RD (RD significa "Mu침eca Rusa").  Se entiende que un conjunto es un conjunto de lexemas en este caso, pero en general, un conjunto puede ser cualquiera. <br><br>  Una idea de los 치rboles RD es reemplazar un rect치ngulo delimitador con un conjunto delimitador, es decir, un conjunto que contenga todos los elementos de los conjuntos secundarios. <br><br>  Surge una pregunta importante sobre c칩mo representar conjuntos en filas de 칤ndice.  La forma m치s directa es enumerar todos los elementos del conjunto.  Esto podr칤a verse de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/cp/ul/cx/cpulcxgydwxo8fl0ul0bdlsn3ws.png"><br><br>  Entonces, por ejemplo, para el acceso por condici칩n <code>doc_tsv @@ to_tsquery('sit')</code> podr칤amos descender solo a los nodos que contienen el lexema "sit": <br><br><img src="https://habrastorage.org/webt/h9/2g/4j/h92g4jpzw_7wj-x3katxlwrw3ac.png"><br><br>  Esta representaci칩n tiene problemas evidentes.  El n칰mero de lexemas en un documento puede ser bastante grande, por lo que las filas de 칤ndice tendr치n un gran tama침o y entrar치n en TOAST, lo que har치 que el 칤ndice sea mucho menos eficiente.  Incluso si cada documento tiene pocos lexemas 칰nicos, la uni칩n de conjuntos puede ser muy grande: cuanto mayor sea la ra칤z, mayores ser치n las filas de 칤ndice. <br><br>  A veces se usa una representaci칩n como esta, pero para otros tipos de datos.  Y la b칰squeda de texto completo utiliza otra soluci칩n m치s compacta: el denominado <em>치rbol de firmas</em> .  Su idea es bastante familiar para todos los que trataron con el filtro Bloom. <br><br>  Cada lexema se puede representar con su <em>firma</em> : una cadena de bits de cierta longitud donde todos los bits menos uno son cero.  La posici칩n de este bit est치 determinada por el valor de la funci칩n hash del lexema (discutimos los aspectos internos de las funciones hash <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anteriormente</a> ). <br><br>  La firma del documento es el OR bit a bit de las firmas de todos los lexemas del documento. <br><br>  Asumamos las siguientes firmas de lexemas: <br><br><pre> podr칤a 1,000,000
 siempre 0001000
 bien 0000010
 mani 0000100
 hoja 0000100
 0100000 m치s elegante
 sentarse 0010000
 hendidura 0001000
 cortadora 0000001
 sobre 0000010
 quien sea 0010000
</pre><br>  Entonces las firmas de los documentos son as칤: <br><br><pre> 쯇uede una cortadora de hojas cortar hojas?  0001101
 쮺u치ntas hojas podr칤a cortar una cortadora de hojas?  1001101
 Cort칠 una hoja, una hoja que cort칠.  0001100
 Sobre una s치bana cortada me siento.  0011110
 Quien cort칩 las s치banas es una buena cortadora de s치banas.  0011111
 Soy una cortadora de s치banas.  0000101
 Cort칠 s치banas.  0001100
 Soy la cortadora de s치banas m치s elegante que jam치s haya cortado las s치banas.  0101101
 Ella corta la s치bana en la que se sienta.  0011100
</pre><br>  El 치rbol de 칤ndice se puede representar de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/ou/f9/gz/ouf9gz7l7wgmgmgzi5gik7nrg50.png"><br><br>  Las ventajas de este enfoque son evidentes: las filas de 칤ndice tienen tama침os peque침os iguales, y dicho 칤ndice es compacto.  Pero un inconveniente tambi칠n es claro: la precisi칩n se sacrifica a la compacidad. <br><br>  Consideremos la misma condici칩n <code>doc_tsv @@ to_tsquery('sit')</code> .  Y calculemos la firma de la consulta de b칰squeda de la misma manera que para el documento: 0010000 en este caso.  La funci칩n de coherencia debe devolver todos los nodos secundarios cuyas firmas contienen al menos un bit de la firma de consulta: <br><br><img src="https://habrastorage.org/webt/qi/qm/l4/qiqml4l5yu8_qiyvidk-3j8iqhs.png"><br><br>  Compare con la figura anterior: podemos ver que el 치rbol se volvi칩 amarillo, lo que significa que se producen falsos positivos y se pasan nodos excesivos durante la b칰squeda.  Aqu칤 recogimos el lexema "quienquiera", cuya firma desafortunadamente era la misma que la firma del lexema "sentarse".  Es importante que no se puedan producir falsos negativos en el patr칩n, es decir, estamos seguros de no perder los valores necesarios. <br><br>  Adem치s, puede suceder que diferentes documentos tambi칠n obtengan las mismas firmas: en nuestro ejemplo, los documentos desafortunados son "He cortado una hoja, he cortado una hoja" y "He cortado hojas" (ambos tienen la firma de 0001100).  Y si una fila de 칤ndice de hoja no almacena el valor de "tsvector", el 칤ndice mismo dar치 falsos positivos.  Por supuesto, en este caso, el m칠todo le pedir치 al motor de indexaci칩n que vuelva a verificar el resultado con la tabla, para que el usuario no vea estos falsos positivos.  Pero la eficiencia de la b칰squeda puede verse comprometida. <br><br>  En realidad, una firma es de 124 bytes en la implementaci칩n actual en lugar de 7 bits en las figuras, por lo que es mucho menos probable que ocurran los problemas anteriores que en el ejemplo.  Pero en realidad, tambi칠n se indexan muchos m치s documentos.  Para reducir de alguna manera el n칰mero de falsos positivos del m칠todo de 칤ndice, la implementaci칩n se vuelve un poco complicada: el "tsvector" indexado se almacena en una fila de 칤ndice de hoja, pero solo si su tama침o no es grande (un poco menos de 1/16 de una p치gina, que es aproximadamente medio kilobyte para p치ginas de 8 KB). <br><br><h3>  Ejemplo </h3><br>  Para ver c칩mo funciona la indexaci칩n en los datos reales, tomemos el archivo del correo electr칩nico "pgsql-hackers".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La versi칩n utilizada en el ejemplo</a> contiene 356125 mensajes con la fecha de env칤o, asunto, autor y texto: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------------------------------------------------------------ id | 1572389 parent_id | 1562808 sent | 1997-06-24 11:31:09 subject | Re: [HACKERS] Array bug is still there.... author | "Thomas G. Lockhart" &lt;Thomas.Lockhart@jpl.nasa.gov&gt; body_plain | Andrew Martin wrote: + | &gt; Just run the regression tests on 6.1 and as I suspected the array bug + | &gt; is still there. The regression test passes because the expected output+ | &gt; has been fixed to the *wrong* output. + | + | OK, I think I understand the current array behavior, which is apparently+ | different than the behavior for v1.0x. + ...</code> </pre><br>  Agregar y completar la columna de tipo "tsvector" y construir el 칤ndice.  Aqu칤 uniremos tres valores en un vector (asunto, autor y texto del mensaje) para mostrar que el documento no necesita ser un solo campo, sino que puede constar de partes arbitrarias totalmente diferentes. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(subject||<span class="hljs-string"><span class="hljs-string">' '</span></span>||author||<span class="hljs-string"><span class="hljs-string">' '</span></span>||body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  Como podemos ver, un cierto n칰mero de palabras se descartaron debido al tama침o demasiado grande.  Pero el 칤ndice finalmente se crea y puede admitir consultas de b칰squeda: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'magic &amp; value'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------- Index Scan using mail_messages_tsv_idx on mail_messages (actual time=0.998..416.335 rows=898 loops=1) Index Cond: (tsv @@ to_tsquery('magic &amp; value'::text)) Rows Removed by Index Recheck: 7859 Planning time: 0.203 ms Execution time: 416.492 ms (5 rows)</code> </pre><br>  Podemos ver que junto con 898 filas que coinciden con la condici칩n, el m칠todo de acceso devolvi칩 7859 filas m치s que se filtraron al volver a verificar con la tabla.  Esto demuestra un impacto negativo de la p칠rdida de precisi칩n en la eficiencia. <br><br><h3>  Internos </h3><br>  Para analizar el contenido del 칤ndice, usaremos nuevamente la extensi칩n "gevel": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a gtsvector) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+------------------------------- 1 | 992 true bits, 0 false bits 2 | 988 true bits, 4 false bits 3 | 573 true bits, 419 false bits 4 | 65 unique words 4 | 107 unique words 4 | 64 unique words 4 | 42 unique words ...</code> </pre><br>  Los valores del tipo especializado "gtsvector" que se almacenan en filas de 칤ndice son en realidad la firma m치s, tal vez, la fuente "tsvector".  Si el vector est치 disponible, la salida contiene el n칰mero de lexemas (palabras 칰nicas), de lo contrario, el n칰mero de bits verdaderos y falsos en la firma. <br><br>  Est치 claro que en el nodo ra칤z, la firma degener칩 en "todos", es decir, un nivel de 칤ndice se volvi칩 absolutamente in칰til (y uno m치s se volvi칩 casi in칰til, con solo cuatro bits falsos). <br><br><h2>  Propiedades </h2><br>  Veamos las propiedades del m칠todo de acceso GiST (las consultas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se proporcionaron anteriormente</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gist | can_order | f gist | can_unique | f gist | can_multi_col | t gist | can_exclude | t</code> </pre><br>  La ordenaci칩n de valores y la restricci칩n 칰nica no son compatibles.  Como hemos visto, el 칤ndice puede construirse en varias columnas y usarse en restricciones de exclusi칩n. <br><br>  Las siguientes propiedades de capa de 칤ndice est치n disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  Y las propiedades m치s interesantes son las de la capa de columna.  Algunas de las propiedades son independientes de las clases de operador: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f search_array | f search_nulls | t</code> </pre><br>  (La ordenaci칩n no es compatible; el 칤ndice no se puede utilizar para buscar una matriz; se admiten NULL). <br><br>  Pero las dos propiedades restantes, "distancia_orderable" y "retornable", depender치n de la clase de operador utilizada.  Por ejemplo, para los puntos obtendremos: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | t returnable | t</code> </pre><br>  La primera propiedad indica que el operador de distancia est치 disponible para buscar vecinos m치s cercanos.  Y el segundo dice que el 칤ndice puede usarse para escaneo de solo 칤ndice.  Aunque las filas de 칤ndice de hoja almacenan rect치ngulos en lugar de puntos, el m칠todo de acceso puede devolver lo que se necesita. <br><br>  Las siguientes son las propiedades de los intervalos: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | t</code> </pre><br>  Para intervalos, la funci칩n de distancia no est치 definida y, por lo tanto, no es posible buscar vecinos m치s cercanos. <br><br>  Y para la b칰squeda de texto completo, obtenemos: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | f</code> </pre><br>  Se ha perdido la compatibilidad con el escaneo de solo 칤ndice ya que las filas de la hoja pueden contener solo la firma sin los datos en s칤.  Sin embargo, esta es una p칠rdida menor ya que a nadie le interesa el valor del tipo "tsvector" de todos modos: este valor se utiliza para seleccionar filas, mientras que es el texto fuente que debe mostrarse, pero de todos modos falta en el 칤ndice. <br><br><h2>  Otros tipos de datos </h2><br>  Finalmente, mencionaremos algunos tipos m치s que actualmente son compatibles con el m칠todo de acceso GiST, adem치s de los tipos geom칠tricos ya discutidos (por ejemplo, puntos), intervalos y tipos de b칰squeda de texto completo. <br><br>  De los tipos est치ndar, este es el tipo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inet</a> " para las direcciones IP.  Todo lo dem치s se agrega a trav칠s de extensiones: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cube</a> proporciona el tipo de datos "cube" para cubos multidimensionales.  Para este tipo, al igual que para los tipos geom칠tricos en un plano, se define la clase de operador GiST: R-tree, que admite la b칰squeda de vecinos m치s cercanos. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seg</a> proporciona el tipo de datos "seg" para intervalos con l칤mites especificados con cierta precisi칩n y agrega compatibilidad con el 칤ndice GiST para este tipo de datos (R-tree). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intarray</a> ampl칤a la funcionalidad de las matrices de enteros y agrega compatibilidad con GiST para ellas.  Se implementan dos clases de operador: "gist__int_ops" (치rbol RD con una representaci칩n completa de las claves en las filas de 칤ndice) y "gist__bigint_ops" (치rbol RD de firma).  La primera clase se puede utilizar para matrices peque침as y la segunda, para tama침os m치s grandes. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ltree</a> agrega el tipo de datos "ltree" para estructuras en forma de 치rbol y el soporte GiST para este tipo de datos (치rbol RD). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_trgm</a> agrega una clase de operador especializada "gist_trgm_ops" para el uso de trigramas en la b칰squeda de texto completo.  Pero esto se discutir치 m치s a fondo, junto con el 칤ndice GIN. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444742/">https://habr.com/ru/post/444742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444728/index.html">Mientras escrib칤a y publicaba un libro sobre la Universidad Estatal de Mosc칰, o 12 errores cr칤ticos</a></li>
<li><a href="../444730/index.html">Por qu칠 la tecnolog칤a sin servidor es una revoluci칩n en la gesti칩n de productos</a></li>
<li><a href="../444732/index.html">Optimizaci칩n del rendimiento apache2</a></li>
<li><a href="../444734/index.html">Habraseminar: historias reales sobre marketing de contenidos</a></li>
<li><a href="../444738/index.html">Pixel art: del borrador al activo del juego</a></li>
<li><a href="../444744/index.html">Enviar correo usando PHP</a></li>
<li><a href="../444746/index.html">Te invitamos a MskDotNet Meetup # 34 en Raiffeisenbank upd Broadcast</a></li>
<li><a href="../444748/index.html">3 cualidades clave de un gerente de producto exitoso: Yuri Golikov, VP de Ingenier칤a Wrike</a></li>
<li><a href="../444752/index.html">La historia de SXSW: c칩mo comenz칩 todo</a></li>
<li><a href="../444756/index.html">DARPA desarrollar치 un motor nuclear de cohete</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>