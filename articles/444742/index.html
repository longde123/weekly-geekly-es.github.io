<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëêüèæ üêà üôâ √çndices en PostgreSQL - 5 (GiST) ‚¨ÜÔ∏è üéÇ üîë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En los art√≠culos anteriores, discutimos el motor de indexaci√≥n PostgreSQL, la interfaz de los m√©todos de acceso y dos m√©todos de acceso: √≠ndice hash y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices en PostgreSQL - 5 (GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444742/">  En los art√≠culos anteriores, discutimos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor de indexaci√≥n</a> PostgreSQL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la interfaz de los m√©todos de acceso</a> y dos m√©todos de acceso: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√≠ndice hash</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rbol B.</a>  En este art√≠culo, describiremos los √≠ndices GiST. <br><br><h1>  Gist </h1><br>  GiST es una abreviatura de "√°rbol de b√∫squeda generalizada".  Este es un √°rbol de b√∫squeda equilibrado, al igual que "b-tree" discutido anteriormente. <br><br>  Cual es la diferencia  El √≠ndice "Btree" est√° estrictamente conectado a la sem√°ntica de comparaci√≥n: todo lo que es capaz de hacer es el soporte de operadores "mayores", "menores" e "iguales" (¬°pero muy capaces!) Sin embargo, las bases de datos modernas almacenan tipos de datos para los cuales estos operadores simplemente no tiene sentido: geodatos, documentos de texto, im√°genes, ... <br><br>  El m√©todo de √≠ndice GiST nos ayuda en estos tipos de datos.  Permite definir una regla para distribuir datos de un tipo arbitrario en un √°rbol equilibrado y un m√©todo para utilizar esta representaci√≥n para el acceso de alg√∫n operador.  Por ejemplo, el √≠ndice GiST puede "acomodar" el √°rbol R para datos espaciales con soporte de operadores de posici√≥n relativa (ubicados a la izquierda, a la derecha, contiene, etc.) o el √°rbol RD para conjuntos con soporte de operadores de intersecci√≥n o inclusi√≥n. <br><br>  Gracias a la extensibilidad, se puede crear un m√©todo totalmente nuevo desde cero en PostgreSQL: para este fin, se debe implementar una interfaz con el motor de indexaci√≥n.  Pero esto requiere una premeditaci√≥n no solo de la l√≥gica de indexaci√≥n, sino tambi√©n de la asignaci√≥n de estructuras de datos a p√°ginas, la implementaci√≥n eficiente de bloqueos y el soporte de un registro de escritura anticipada.  Todo esto supone altas habilidades de desarrollo y un gran esfuerzo humano.  GiST simplifica la tarea al hacerse cargo de los problemas de bajo nivel y ofrecer su propia interfaz: varias funciones que no pertenecen a las t√©cnicas, sino al dominio de la aplicaci√≥n.  En este sentido, podemos considerar GiST como un marco para construir nuevos m√©todos de acceso. <br><a name="habracut"></a><br><h2>  Estructura </h2><br>  GiST es un √°rbol de altura equilibrada que consta de p√°ginas de nodos.  Los nodos consisten en filas de √≠ndice. <br><br>  Cada fila de un nodo hoja (fila hoja), en general, contiene alg√∫n <em>predicado</em> (expresi√≥n booleana) y una referencia a una fila de tabla (TID).  Los datos indexados (clave) deben cumplir con este predicado. <br><br>  Cada fila de un nodo interno (fila interna) tambi√©n contiene un <em>predicado</em> y una referencia a un nodo secundario, y todos los datos indexados del sub√°rbol secundario deben cumplir con este predicado.  En otras palabras, el predicado de una fila interna <em>incluye</em> los predicados de todas las filas secundarias.  Este rasgo importante del √≠ndice GiST reemplaza la simple ordenaci√≥n del √°rbol B. <br><br>  La b√∫squeda en el √°rbol GiST utiliza una <em>funci√≥n de coherencia</em> especializada ("coherente"), una de las funciones definidas por la interfaz e implementada a su manera para cada familia de operadores admitida. <br><br>  Se llama a la funci√≥n de coherencia para una fila de √≠ndice y determina si el predicado de esta fila es coherente con el predicado de b√∫squeda (especificado como " <em>expresi√≥n de operador de campo indexado</em> ").  Para una fila interna, esta funci√≥n realmente determina si es necesario descender al sub√°rbol correspondiente, y para una fila de hoja, la funci√≥n determina si los datos indexados cumplen con el predicado. <br><br>  La b√∫squeda comienza con un nodo ra√≠z, como una b√∫squeda de √°rbol normal.  La funci√≥n de coherencia permite averiguar en qu√© nodos secundarios tiene sentido ingresar (puede haber varios) y cu√°les no.  El algoritmo se repite para cada nodo secundario encontrado.  Y si el nodo es hoja, la fila seleccionada por la funci√≥n de coherencia se devuelve como uno de los resultados. <br><br>  La b√∫squeda es profunda primero: el algoritmo primero intenta alcanzar un nodo hoja.  Esto permite devolver los primeros resultados pronto siempre que sea posible (lo que podr√≠a ser importante si el usuario est√° interesado en solo varios resultados en lugar de en todos). <br><br>  Observemos una vez m√°s que la funci√≥n de coherencia no necesita tener nada que ver con operadores "mayores", "menores" o "iguales".  La sem√°ntica de la funci√≥n de consistencia puede ser bastante diferente y, por lo tanto, no se supone que el √≠ndice devuelva valores en un cierto orden. <br><br>  No discutiremos los algoritmos de inserci√≥n y eliminaci√≥n de valores en GiST: algunas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones de interfaz</a> m√°s realizan estas operaciones.  Sin embargo, hay un punto importante.  Cuando se inserta un nuevo valor en el √≠ndice, la posici√≥n para este valor en el √°rbol se selecciona de modo que los predicados de sus filas principales se extiendan lo menos posible (idealmente, no se extienden en absoluto).  Pero cuando se elimina un valor, el predicado de la fila principal ya no se reduce.  Esto solo sucede en casos como estos: una p√°gina se divide en dos (cuando la p√°gina no tiene suficiente espacio para la inserci√≥n de una nueva fila de √≠ndice) o el √≠ndice se recrea desde cero (con el comando REINDEX o VACUUM FULL).  Por lo tanto, la eficiencia del √≠ndice GiST para los datos que cambian con frecuencia puede degradarse con el tiempo. <br><br>  Adem√°s, consideraremos algunos ejemplos de √≠ndices para varios tipos de datos y propiedades √∫tiles de GiST: <br><br><ul><li>  Puntos (y otras entidades geom√©tricas) y b√∫squeda de vecinos m√°s cercanos. </li><li>  Intervalos y restricciones de exclusi√≥n. </li><li>  B√∫squeda de texto completo. </li></ul><br><h2>  R-tree para puntos </h2><br>  Ilustraremos lo anterior con un ejemplo de un √≠ndice para puntos en un plano (tambi√©n podemos construir √≠ndices similares para otras entidades geom√©tricas).  Un √°rbol B normal no se adapta a este tipo de datos ya que no se definen operadores de comparaci√≥n para los puntos. <br><br>  La idea de R-tree es dividir el plano en rect√°ngulos que en total cubran todos los puntos que se indexan.  Una fila de √≠ndice almacena un rect√°ngulo, y el predicado se puede definir as√≠: "el punto buscado se encuentra dentro del rect√°ngulo dado". <br><br>  La ra√≠z del √°rbol R contendr√° varios rect√°ngulos m√°s grandes (posiblemente intersectados).  Los nodos secundarios contendr√°n rect√°ngulos de menor tama√±o que est√°n incrustados en el primario y en total cubren todos los puntos subyacentes. <br><br>  En teor√≠a, los nodos hoja deben contener puntos que se indexan, pero el tipo de datos debe ser el mismo en todas las filas de √≠ndice y, por lo tanto, nuevamente los rect√°ngulos se almacenan, pero se "colapsan" en puntos. <br><br>  Para visualizar dicha estructura, proporcionamos im√°genes para tres niveles del √°rbol R.  Los puntos son coordenadas de aeropuertos (similares a los de la tabla "aeropuertos" de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">base de datos de demostraci√≥n</a> , pero se proporcionan m√°s datos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">openflights.org</a> ). <br><br><img src="https://habrastorage.org/web/492/fd0/a28/492fd0a2883b4ee39d75618f8f501e50.png"><br>  <em>Nivel uno: dos grandes rect√°ngulos que se cruzan son visibles.</em> <br><br><img src="https://habrastorage.org/web/e42/78d/843/e4278d8439a3485e88128182f741b696.png"><br>  <em>Nivel dos: los rect√°ngulos grandes se dividen en √°reas m√°s peque√±as.</em> <br><br><img src="https://habrastorage.org/web/60e/c9d/99b/60ec9d99b4fe46c88bed2a9cc65dd0f5.png"><br>  <em>Nivel tres: cada rect√°ngulo contiene tantos puntos como para caber en una p√°gina de √≠ndice.</em> <br><br>  Ahora consideremos un ejemplo muy simple de "un nivel": <br><br><img src="https://habrastorage.org/web/d89/478/666/d894786665774a76943e72338aec874c.png"><br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(p);</code> </pre> <br>  Con esta divisi√≥n, la estructura del √≠ndice tendr√° el siguiente aspecto: <br><br><img src="https://habrastorage.org/web/caf/919/8a5/caf9198a538d46f48985d42a301a0b2d.png"><br><br>  El √≠ndice creado se puede usar para acelerar la siguiente consulta, por ejemplo: "buscar todos los puntos contenidos en el rect√°ngulo dado".  Esta condici√≥n se puede formalizar de la siguiente manera: <code>p &lt;@ box '(2,1),(6,3)'</code> (operador <code>&lt;@</code> de la familia "points_ops" significa "contenido en"): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using points_p_idx on points Index Cond: (p &lt;@ '(7,4),(2,1)'::box) (2 rows)</code> </pre><br>  La funci√≥n de coherencia del operador (" <em>campo indexado</em> &lt;@ <em>expresi√≥n</em> ", donde <em>el campo indexado</em> es un punto y la <em>expresi√≥n</em> es un rect√°ngulo) se define de la siguiente manera.  Para una fila interna, devuelve "s√≠" si su rect√°ngulo se cruza con el rect√°ngulo definido por la <em>expresi√≥n</em> .  Para una fila de hojas, la funci√≥n devuelve "s√≠" si su punto (rect√°ngulo "colapsado") est√° contenido en el rect√°ngulo definido por la expresi√≥n. <br><br><img src="https://habrastorage.org/web/226/f28/493/226f28493e15430193a69781e1600b9f.png"><br><br>  La b√∫squeda comienza con el nodo ra√≠z.  El rect√°ngulo (2,1) - (7,4) se cruza con (1,1) - (6,3), pero no se cruza con (5,5) - (8,8), por lo tanto, no es necesario para descender al segundo sub√°rbol. <br><br><img src="https://habrastorage.org/web/d52/792/511/d527925110fb46deadb382762561a621.png"><br><br>  Al llegar a un nodo hoja, pasamos por los tres puntos contenidos all√≠ y devolvemos dos de ellos como resultado: (3.2) y (6.3). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (3,2) (6,3) (2 rows)</code> </pre><br><h3>  Internos </h3><br>  Desafortunadamente, la "inspecci√≥n de p√°gina" habitual no permite buscar en el √≠ndice GiST.  Pero hay otra forma disponible: extensi√≥n "gevel".  No se incluye en la entrega est√°ndar, por lo tanto, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las instrucciones de instalaci√≥n</a> . <br><br>  Si todo se hace correctamente, tres funciones estar√°n disponibles para usted.  Primero, podemos obtener algunas estad√≠sticas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_stat(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_stat ------------------------------------------ Number of levels: 4 + Number of pages: 690 + Number of leaf pages: 625 + Number of tuples: 7873 + Number of invalid tuples: 0 + Number of leaf tuples: 7184 + Total size of tuples: 354692 bytes + Total size of leaf tuples: 323596 bytes + Total size of index: 5652480 bytes+ (1 row)</code> </pre><br>  Est√° claro que el tama√±o del √≠ndice en las coordenadas del aeropuerto es de 690 p√°ginas y que el √≠ndice consta de cuatro niveles: la ra√≠z y dos niveles internos se muestran en las figuras anteriores, y el cuarto nivel es hoja. <br><br>  En realidad, el √≠ndice de ocho mil puntos ser√° significativamente m√°s peque√±o: aqu√≠ se cre√≥ con un factor de relleno del 10% para mayor claridad. <br><br>  En segundo lugar, podemos generar el √°rbol de √≠ndice: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_tree(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_tree ----------------------------------------------------------------------------------------- 0(l:0) blk: 0 numTuple: 5 free: 7928b(2.84%) rightlink:4294967295 (InvalidBlockNumber) + 1(l:1) blk: 335 numTuple: 15 free: 7488b(8.24%) rightlink:220 (OK) + 1(l:2) blk: 128 numTuple: 9 free: 7752b(5.00%) rightlink:49 (OK) + 1(l:3) blk: 57 numTuple: 12 free: 7620b(6.62%) rightlink:35 (OK) + 2(l:3) blk: 62 numTuple: 9 free: 7752b(5.00%) rightlink:57 (OK) + 3(l:3) blk: 72 numTuple: 7 free: 7840b(3.92%) rightlink:23 (OK) + 4(l:3) blk: 115 numTuple: 17 free: 7400b(9.31%) rightlink:33 (OK) + ...</code> </pre><br>  Y tercero, podemos generar los datos almacenados en filas de √≠ndice.  Tenga en cuenta el siguiente matiz: el resultado de la funci√≥n debe convertirse al tipo de datos necesario.  En nuestra situaci√≥n, este tipo es "caja" (un rect√°ngulo delimitador).  Por ejemplo, observe cinco filas en el nivel superior: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">box</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------------------------------- 1 | (47.663586,80.803207),(-39.2938003540039,-90) 1 | (179.951004028,15.6700000762939),(15.2428998947144,-77.9634017944336) 1 | (177.740997314453,73.5178070068359),(15.0664,10.57970047) 1 | (-77.3191986083984,79.9946975708),(-179.876998901,-43.810001373291) 1 | (-39.864200592041,82.5177993774),(-81.254096984863,-64.2382965088) (5 rows)</code> </pre><br>  En realidad, las cifras proporcionadas anteriormente se crearon solo a partir de estos datos. <br><br><h2>  Operadores para buscar y ordenar </h2><br>  Los operadores discutidos hasta ahora (como <code>&lt;@</code> en el predicado <code>p &lt;@ box '(2,1),(7,4)'</code> ) pueden llamarse operadores de b√∫squeda ya que especifican condiciones de b√∫squeda en una consulta. <br><br>  Tambi√©n hay otro tipo de operador: operadores de pedidos.  Se utilizan para especificaciones del orden de clasificaci√≥n en la cl√°usula ORDER BY en lugar de especificaciones convencionales de nombres de columna.  El siguiente es un ejemplo de dicha consulta: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (5,5) (7,8) (2 rows)</code> </pre><br>  <code>p &lt;-&gt; point '(4,7)'</code> aqu√≠ es una expresi√≥n que usa un operador de orden <code>&lt;-&gt;</code> , que denota la distancia de un argumento al otro.  El significado de la consulta es devolver dos puntos m√°s cercanos al punto (4.7).  Una b√∫squeda como esta se conoce como k-NN - k-b√∫squeda de vecinos m√°s cercanos. <br><br>  Para admitir consultas de este tipo, un m√©todo de acceso debe definir una <em>funci√≥n de distancia</em> adicional, y el operador de pedido debe incluirse en la clase de operador apropiada (por ejemplo, clase "points_ops" para puntos).  La consulta a continuaci√≥n muestra los operadores, junto con sus tipos ("s" - buscar y "o" - ordenar): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------+-------------+-------------- &lt;&lt;(point,point) | s | 1 strictly left &gt;&gt;(point,point) | s | 5 strictly right ~=(point,point) | s | 6 coincides &lt;^(point,point) | s | 10 strictly below &gt;^(point,point) | s | 11 strictly above &lt;-&gt;(point,point) | o | 15 distance &lt;@(point,box) | s | 28 contained in rectangle &lt;@(point,polygon) | s | 48 contained in polygon &lt;@(point,circle) | s | 68 contained in circle (9 rows)</code> </pre><br>  Tambi√©n se muestran los n√∫meros de estrategias, con sus significados explicados.  Est√° claro que hay muchas m√°s estrategias que para "btree", solo algunas de ellas son compatibles con puntos.  Se pueden definir diferentes estrategias para otros tipos de datos. <br><br>  La funci√≥n de distancia se llama para un elemento de √≠ndice y debe calcular la distancia (teniendo en cuenta la sem√°ntica del operador) desde el valor definido por la expresi√≥n (" <em>expresi√≥n de operador de ordenaci√≥n de campo indexado</em> ") hasta el elemento dado.  Para un elemento hoja, esta es solo la distancia al valor indexado.  Para un elemento interno, la funci√≥n debe devolver el m√≠nimo de las distancias a los elementos secundarios de la hoja.  Dado que recorrer todas las filas secundarias ser√≠a bastante costoso, se permite que la funci√≥n subestime de manera optimista la distancia, pero a expensas de reducir la eficiencia de b√∫squeda.  Sin embargo, la funci√≥n nunca puede sobreestimar la distancia, ya que esto interrumpir√° el trabajo del √≠ndice. <br><br>  La funci√≥n de distancia puede devolver valores de cualquier tipo ordenable (para ordenar valores, PostgreSQL usar√° sem√°ntica de comparaci√≥n de la familia de operadores apropiada del m√©todo de acceso "btree", como se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describi√≥ anteriormente</a> ). <br><br>  Para los puntos en un plano, la distancia se interpreta en un sentido muy habitual: el valor de <code>(x1,y1) &lt;-&gt; (x2,y2)</code> es igual a la ra√≠z cuadrada de la suma de los cuadrados de las diferencias de las abscisas y las ordenadas.  La distancia desde un punto a un rect√°ngulo delimitador se considera la distancia m√≠nima desde el punto a este rect√°ngulo o cero si el punto se encuentra dentro del rect√°ngulo.  Es f√°cil calcular este valor sin caminar a trav√©s de puntos secundarios, y el valor no es mayor que la distancia a cualquier punto secundario. <br><br>  Consideremos el algoritmo de b√∫squeda para la consulta anterior. <br><br><img src="https://habrastorage.org/web/84b/56a/075/84b56a075dbd42d6b5d8cc8cb10c4b01.png"><br><br>  La b√∫squeda comienza con el nodo ra√≠z.  El nodo contiene dos rect√°ngulos delimitadores.  La distancia a (1,1) - (6,3) es 4.0 y a (5,5) - (8,8) es 1.0. <br><br>  Los nodos secundarios se recorren en el orden de aumentar la distancia.  De esta manera, primero descendemos al nodo hijo m√°s cercano y calculamos las distancias a los puntos (mostraremos los n√∫meros en la figura para visibilidad): <br><br><img src="https://habrastorage.org/web/491/959/f07/491959f070754781b794e0dff01d5aec.png"><br><br>  Esta informaci√≥n es suficiente para devolver los dos primeros puntos, (5,5) y (7,8).  Como somos conscientes de que la distancia a los puntos que se encuentran dentro del rect√°ngulo (1,1) - (6,3) es 4.0 o mayor, no necesitamos descender al primer nodo secundario. <br><br>  Pero, ¬øy si necesit√°ramos encontrar los primeros <em>tres</em> puntos? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="pgsql hljs"> p <span class="hljs-comment"><span class="hljs-comment">------- (5,5) (7,8) (8,6) (3 rows)</span></span></code> </pre><br>  Aunque el segundo nodo secundario contiene todos estos puntos, no podemos devolver (8,6) sin mirar el primer nodo secundario ya que este nodo puede contener puntos m√°s cercanos (desde 4.0 &lt;4.1). <br><br><img src="https://habrastorage.org/web/9bb/43a/775/9bb43a775fc445769e37af8bb50daae0.png"><br><br>  Para las filas internas, este ejemplo aclara los requisitos para la funci√≥n de distancia.  Al seleccionar una distancia m√°s peque√±a (4.0 en lugar de 4.5 real) para la segunda fila, redujimos la eficiencia (el algoritmo comenz√≥ a examinar innecesariamente un nodo adicional), pero no rompi√≥ la correcci√≥n del algoritmo. <br><br>  Hasta hace poco, GiST era el √∫nico m√©todo de acceso capaz de tratar con operadores de pedidos.  Pero la situaci√≥n ha cambiado: el m√©todo de acceso RUM (que se discutir√° m√°s adelante) ya se ha unido a este grupo de m√©todos, y no es improbable que el viejo √°rbol B se una a ellos: se est√° implementando un parche desarrollado por Nikita Glukhov, nuestro colega. discutido por la comunidad. <br><blockquote>  A partir de marzo de 2019, se agreg√≥ compatibilidad con k-NN para SP-GiST en el pr√≥ximo PostgreSQL 12 (tambi√©n creado por Nikita).  El parche para B-tree todav√≠a est√° en progreso. <br></blockquote><br><h2>  R-√°rbol para intervalos </h2><br>  Otro ejemplo del uso del m√©todo de acceso GiST es la indexaci√≥n de intervalos, por ejemplo, intervalos de tiempo (tipo "tsrange").  La diferencia es que los nodos internos contendr√°n intervalos delimitadores en lugar de rect√°ngulos delimitadores. <br><br>  Consideremos un ejemplo simple.  Alquilaremos una caba√±a y almacenaremos los intervalos de reserva en una tabla: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations(during <span class="hljs-type"><span class="hljs-type">tsrange</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2016-12-30, 2017-01-09)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-02-23, 2017-02-27)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-04-29, 2017-05-02)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during);</code> </pre><br>  El √≠ndice se puede utilizar para acelerar la siguiente consulta, por ejemplo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> during ----------------------------------------------- ["2016-12-30 00:00:00","2017-01-08 00:00:00") ["2017-02-23 00:00:00","2017-02-26 00:00:00") (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Index Only Scan using reservations_during_idx on reservations Index Cond: (during &amp;&amp; '["2017-01-01 00:00:00","2017-04-01 00:00:00")'::tsrange) (2 rows)</code> </pre><br>  <code>&amp;&amp;</code> operador <code>&amp;&amp;</code> para intervalos denota intersecci√≥n;  por lo tanto, la consulta debe devolver todos los intervalos que se cruzan con el dado.  Para dicho operador, la funci√≥n de coherencia determina si el intervalo dado se cruza con un valor en una fila interna o de hoja. <br><br>  Tenga en cuenta que esto no se trata de obtener intervalos en un cierto orden, aunque los operadores de comparaci√≥n se definen para intervalos.  Podemos usar el √≠ndice "btree" para intervalos, pero en este caso, tendremos que prescindir de operaciones como estas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'range_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------------+-------------+-------------- @&gt;(anyrange,anyelement) | s | 16 contains element &lt;&lt;(anyrange,anyrange) | s | 1 strictly left &amp;&lt;(anyrange,anyrange) | s | 2 not beyond right boundary &amp;&amp;(anyrange,anyrange) | s | 3 intersects &amp;&gt;(anyrange,anyrange) | s | 4 not beyond left boundary &gt;&gt;(anyrange,anyrange) | s | 5 strictly right -|-(anyrange,anyrange) | s | 6 adjacent @&gt;(anyrange,anyrange) | s | 7 contains interval &lt;@(anyrange,anyrange) | s | 8 contained in interval =(anyrange,anyrange) | s | 18 equals (10 rows)</code> </pre><br>  (Excepto la igualdad, que est√° contenida en la clase de operador para el m√©todo de acceso "btree"). <br><br><h3>  Internos </h3><br>  Podemos mirar dentro usando la misma extensi√≥n "gevel".  Solo necesitamos recordar cambiar el tipo de datos en la llamada a gist_print: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'reservations_during_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">tsrange</span></span>);</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------- 1 | ["2016-12-30 00:00:00","2017-01-09 00:00:00") 1 | ["2017-02-23 00:00:00","2017-02-27 00:00:00") 1 | ["2017-04-29 00:00:00","2017-05-02 00:00:00") (3 rows)</code> </pre><br><h2>  Restricci√≥n de exclusi√≥n </h2><br>  El √≠ndice GiST se puede usar para admitir restricciones de exclusi√≥n (EXCLUDE). <br><br>  La restricci√≥n de exclusi√≥n asegura que los campos dados de cualquiera de las dos filas de la tabla no se "correspondan" entre s√≠ en t√©rminos de algunos operadores.  Si se elige el operador "igual", obtenemos exactamente la restricci√≥n √∫nica: los campos dados de dos filas no son iguales entre s√≠. <br><br>  La restricci√≥n de exclusi√≥n es compatible con el √≠ndice, as√≠ como la restricci√≥n √∫nica.  Podemos elegir cualquier operador para que: <br><br><ol><li>  Es compatible con el m√©todo de √≠ndice: propiedad "can_exclude" (por ejemplo, "btree", GiST o SP-GiST, pero no GIN). </li><li>  Es conmutativo, es decir, se cumple la condici√≥n: un operador b = b operador a. </li></ol><br>  Esta es una lista de estrategias adecuadas y ejemplos de operadores (los operadores, como recordamos, pueden tener diferentes nombres y estar disponibles no para todos los tipos de datos): <br><br><ul><li>  Para "btree": <br><ul><li>  "Igual" <code>=</code> </li></ul></li><li>  Para GiST y SP-GiST: <br><ul><li>  "Intersecci√≥n" <code>&amp;&amp;</code> </li><li>  "Coincidencia" <code>~=</code> </li><li>  Adyacencia <code>-|-</code> </li></ul></li></ul><br>  Tenga en cuenta que podemos usar el operador de igualdad en una restricci√≥n de exclusi√≥n, pero no es pr√°ctico: una restricci√≥n √∫nica ser√° m√°s eficiente.  Eso es exactamente por qu√© no tocamos las restricciones de exclusi√≥n cuando discutimos los √°rboles B. <br><br>  Proporcionemos un ejemplo del uso de una restricci√≥n de exclusi√≥n.  Es razonable no permitir reservas para intervalos de intersecci√≥n. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;);</code> </pre><br>  Una vez que creamos la restricci√≥n de exclusi√≥n, podemos agregar filas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-06-10, 2017-06-13)'</span></span>);</code> </pre><br>  Pero un intento de insertar un intervalo de intersecci√≥n en la tabla dar√° como resultado un error: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_excl" DETAIL: Key (during)=(["2017-05-15 00:00:00","2017-06-15 00:00:00")) conflicts with existing key (during)=(["2017-06-10 00:00:00","2017-06-13 00:00:00")).</code> </pre><br><h3>  Extensi√≥n "Btree_gist" </h3><br>  Vamos a complicar el problema.  Ampliamos nuestro humilde negocio, y vamos a alquilar varias casas de campo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> house_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Necesitamos cambiar la restricci√≥n de exclusi√≥n para que se tengan en cuenta los n√∫meros de las casas.  Sin embargo, GiST no admite la operaci√≥n de igualdad para n√∫meros enteros: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> reservations_during_excl; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type integer has no default operator class for access method "gist" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  En este caso, la extensi√≥n " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">btree_gist</a> " ayudar√°, lo que agrega el soporte GiST de las operaciones inherentes a los B-trees.  GiST, eventualmente, puede soportar cualquier operador, entonces ¬øpor qu√© no deber√≠amos ense√±arlo a soportar operadores "mayores", "menores" e "iguales"? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gist; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><br>  Ahora todav√≠a no podemos reservar la primera caba√±a para las mismas fechas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_house_no_excl"</code> </pre><br>  Sin embargo, podemos reservar el segundo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Pero tenga en cuenta que aunque GiST de alguna manera puede admitir operadores "mayores", "menores" e "iguales", B-tree todav√≠a lo hace mejor.  Por lo tanto, vale la pena usar esta t√©cnica solo si se necesita esencialmente el √≠ndice GiST, como en nuestro ejemplo. <br><br><h2>  RD-tree para b√∫squeda de texto completo </h2><br><h3>  Acerca de la b√∫squeda de texto completo </h3><br>  Comencemos con una introducci√≥n minimalista a la b√∫squeda de texto completo de PostgreSQL (si est√° al tanto, puede omitir esta secci√≥n). <br><br>  La tarea de la b√∫squeda de texto completo es seleccionar del conjunto de documentos aquellos documentos que <em>coinciden con</em> la consulta de b√∫squeda.  (Si hay muchos documentos coincidentes, es importante encontrar <em>la mejor coincidencia</em> , pero no diremos nada al respecto en este momento). <br><br>  Para fines de b√∫squeda, un documento se convierte en un tipo especializado "tsvector", que contiene <em>lexemas</em> y sus posiciones en el documento.  Los lexemas son palabras convertidas a la forma adecuada para la b√∫squeda.  Por ejemplo, las palabras generalmente se convierten en min√∫sculas y las terminaciones variables se cortan: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector ----------------------------------------- 'crook':4,10 'man':5 'mile':11 'walk':8 (1 row)</code> </pre><br>  Tambi√©n podemos ver que algunas palabras (llamadas <em>palabras de detenci√≥n</em> ) se descartan por completo ("all√≠", "era", "a", "y", "√©l"), ya que presumiblemente ocurren con demasiada frecuencia para buscarlas para que tengan sentido.  Todas estas conversiones ciertamente pueden configurarse, pero esa es otra historia. <br><br>  Una consulta de b√∫squeda se representa con otro tipo: "tsquery".  Aproximadamente, una consulta consta de uno o varios lexemas unidos por conectivos: "y" &amp;, "o" |, "no"! .. Tambi√©n podemos usar par√©ntesis para aclarar la prioridad de la operaci√≥n. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsquery ---------------------------- 'man' &amp; ( 'walk' | 'run' ) (1 row)</code> </pre><br>  Solo se utiliza un operador de coincidencia <code>@@</code> para la b√∫squeda de texto completo. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (going | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- f (1 row)</code> </pre><br>  Esta informaci√≥n es suficiente por ahora.  Nos sumergiremos un poco m√°s en la b√∫squeda de texto completo en el pr√≥ximo art√≠culo que presenta el √≠ndice GIN. <br><br><h3>  RD-√°rboles </h3><br>  Para una b√∫squeda r√°pida de texto completo, en primer lugar, la tabla debe almacenar una columna de tipo "tsvector" (para evitar realizar una conversi√≥n costosa cada vez que se busca) y, en segundo lugar, se debe construir un √≠ndice en esta columna.  Uno de los posibles m√©todos de acceso para esto es GiST. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(doc_tsv); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc);</code> </pre><br>  Sin duda, es conveniente confiar un disparador al √∫ltimo paso (conversi√≥n del documento a "tsvector"). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------------------------------------------------- doc | Can a sheet slitter slit sheets? doc_tsv | 'sheet':3,6 'slit':5 'slitter':4 -[ RECORD 2 ]---------------------------------------------------- doc | How many sheets could a sheet slitter slit? doc_tsv | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 -[ RECORD 3 ]---------------------------------------------------- doc | I slit a sheet, a sheet I slit. doc_tsv | 'sheet':4,6 'slit':2,8 -[ RECORD 4 ]---------------------------------------------------- doc | Upon a slitted sheet I sit. doc_tsv | 'sheet':4 'sit':6 'slit':3 'upon':1 -[ RECORD 5 ]---------------------------------------------------- doc | Whoever slit the sheets is a good sheet slitter. doc_tsv | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 -[ RECORD 6 ]---------------------------------------------------- doc | I am a sheet slitter. doc_tsv | 'sheet':4 'slitter':5 -[ RECORD 7 ]---------------------------------------------------- doc | I slit sheets. doc_tsv | 'sheet':3 'slit':2 -[ RECORD 8 ]---------------------------------------------------- doc | I am the sleekest sheet slitter that ever slit sheets. doc_tsv | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 -[ RECORD 9 ]---------------------------------------------------- doc | She slits the sheet she sits on. doc_tsv | 'sheet':4 'sit':6 'slit':2</code> </pre><br>  ¬øC√≥mo debe estructurarse el √≠ndice?  El uso de R-tree directamente no es una opci√≥n, ya que no est√° claro c√≥mo definir un "rect√°ngulo delimitador" para los documentos.  Pero podemos aplicar alguna modificaci√≥n de este enfoque para conjuntos, un llamado √°rbol RD (RD significa "Mu√±eca Rusa").  Se entiende que un conjunto es un conjunto de lexemas en este caso, pero en general, un conjunto puede ser cualquiera. <br><br>  Una idea de los √°rboles RD es reemplazar un rect√°ngulo delimitador con un conjunto delimitador, es decir, un conjunto que contenga todos los elementos de los conjuntos secundarios. <br><br>  Surge una pregunta importante sobre c√≥mo representar conjuntos en filas de √≠ndice.  La forma m√°s directa es enumerar todos los elementos del conjunto.  Esto podr√≠a verse de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/cp/ul/cx/cpulcxgydwxo8fl0ul0bdlsn3ws.png"><br><br>  Entonces, por ejemplo, para el acceso por condici√≥n <code>doc_tsv @@ to_tsquery('sit')</code> podr√≠amos descender solo a los nodos que contienen el lexema "sit": <br><br><img src="https://habrastorage.org/webt/h9/2g/4j/h92g4jpzw_7wj-x3katxlwrw3ac.png"><br><br>  Esta representaci√≥n tiene problemas evidentes.  El n√∫mero de lexemas en un documento puede ser bastante grande, por lo que las filas de √≠ndice tendr√°n un gran tama√±o y entrar√°n en TOAST, lo que har√° que el √≠ndice sea mucho menos eficiente.  Incluso si cada documento tiene pocos lexemas √∫nicos, la uni√≥n de conjuntos puede ser muy grande: cuanto mayor sea la ra√≠z, mayores ser√°n las filas de √≠ndice. <br><br>  A veces se usa una representaci√≥n como esta, pero para otros tipos de datos.  Y la b√∫squeda de texto completo utiliza otra soluci√≥n m√°s compacta: el denominado <em>√°rbol de firmas</em> .  Su idea es bastante familiar para todos los que trataron con el filtro Bloom. <br><br>  Cada lexema se puede representar con su <em>firma</em> : una cadena de bits de cierta longitud donde todos los bits menos uno son cero.  La posici√≥n de este bit est√° determinada por el valor de la funci√≥n hash del lexema (discutimos los aspectos internos de las funciones hash <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anteriormente</a> ). <br><br>  La firma del documento es el OR bit a bit de las firmas de todos los lexemas del documento. <br><br>  Asumamos las siguientes firmas de lexemas: <br><br><pre> podr√≠a 1,000,000
 siempre 0001000
 bien 0000010
 mani 0000100
 hoja 0000100
 0100000 m√°s elegante
 sentarse 0010000
 hendidura 0001000
 cortadora 0000001
 sobre 0000010
 quien sea 0010000
</pre><br>  Entonces las firmas de los documentos son as√≠: <br><br><pre> ¬øPuede una cortadora de hojas cortar hojas?  0001101
 ¬øCu√°ntas hojas podr√≠a cortar una cortadora de hojas?  1001101
 Cort√© una hoja, una hoja que cort√©.  0001100
 Sobre una s√°bana cortada me siento.  0011110
 Quien cort√≥ las s√°banas es una buena cortadora de s√°banas.  0011111
 Soy una cortadora de s√°banas.  0000101
 Cort√© s√°banas.  0001100
 Soy la cortadora de s√°banas m√°s elegante que jam√°s haya cortado las s√°banas.  0101101
 Ella corta la s√°bana en la que se sienta.  0011100
</pre><br>  El √°rbol de √≠ndice se puede representar de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/ou/f9/gz/ouf9gz7l7wgmgmgzi5gik7nrg50.png"><br><br>  Las ventajas de este enfoque son evidentes: las filas de √≠ndice tienen tama√±os peque√±os iguales, y dicho √≠ndice es compacto.  Pero un inconveniente tambi√©n es claro: la precisi√≥n se sacrifica a la compacidad. <br><br>  Consideremos la misma condici√≥n <code>doc_tsv @@ to_tsquery('sit')</code> .  Y calculemos la firma de la consulta de b√∫squeda de la misma manera que para el documento: 0010000 en este caso.  La funci√≥n de coherencia debe devolver todos los nodos secundarios cuyas firmas contienen al menos un bit de la firma de consulta: <br><br><img src="https://habrastorage.org/webt/qi/qm/l4/qiqml4l5yu8_qiyvidk-3j8iqhs.png"><br><br>  Compare con la figura anterior: podemos ver que el √°rbol se volvi√≥ amarillo, lo que significa que se producen falsos positivos y se pasan nodos excesivos durante la b√∫squeda.  Aqu√≠ recogimos el lexema "quienquiera", cuya firma desafortunadamente era la misma que la firma del lexema "sentarse".  Es importante que no se puedan producir falsos negativos en el patr√≥n, es decir, estamos seguros de no perder los valores necesarios. <br><br>  Adem√°s, puede suceder que diferentes documentos tambi√©n obtengan las mismas firmas: en nuestro ejemplo, los documentos desafortunados son "He cortado una hoja, he cortado una hoja" y "He cortado hojas" (ambos tienen la firma de 0001100).  Y si una fila de √≠ndice de hoja no almacena el valor de "tsvector", el √≠ndice mismo dar√° falsos positivos.  Por supuesto, en este caso, el m√©todo le pedir√° al motor de indexaci√≥n que vuelva a verificar el resultado con la tabla, para que el usuario no vea estos falsos positivos.  Pero la eficiencia de la b√∫squeda puede verse comprometida. <br><br>  En realidad, una firma es de 124 bytes en la implementaci√≥n actual en lugar de 7 bits en las figuras, por lo que es mucho menos probable que ocurran los problemas anteriores que en el ejemplo.  Pero en realidad, tambi√©n se indexan muchos m√°s documentos.  Para reducir de alguna manera el n√∫mero de falsos positivos del m√©todo de √≠ndice, la implementaci√≥n se vuelve un poco complicada: el "tsvector" indexado se almacena en una fila de √≠ndice de hoja, pero solo si su tama√±o no es grande (un poco menos de 1/16 de una p√°gina, que es aproximadamente medio kilobyte para p√°ginas de 8 KB). <br><br><h3>  Ejemplo </h3><br>  Para ver c√≥mo funciona la indexaci√≥n en los datos reales, tomemos el archivo del correo electr√≥nico "pgsql-hackers".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La versi√≥n utilizada en el ejemplo</a> contiene 356125 mensajes con la fecha de env√≠o, asunto, autor y texto: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------------------------------------------------------------ id | 1572389 parent_id | 1562808 sent | 1997-06-24 11:31:09 subject | Re: [HACKERS] Array bug is still there.... author | "Thomas G. Lockhart" &lt;Thomas.Lockhart@jpl.nasa.gov&gt; body_plain | Andrew Martin wrote: + | &gt; Just run the regression tests on 6.1 and as I suspected the array bug + | &gt; is still there. The regression test passes because the expected output+ | &gt; has been fixed to the *wrong* output. + | + | OK, I think I understand the current array behavior, which is apparently+ | different than the behavior for v1.0x. + ...</code> </pre><br>  Agregar y completar la columna de tipo "tsvector" y construir el √≠ndice.  Aqu√≠ uniremos tres valores en un vector (asunto, autor y texto del mensaje) para mostrar que el documento no necesita ser un solo campo, sino que puede constar de partes arbitrarias totalmente diferentes. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(subject||<span class="hljs-string"><span class="hljs-string">' '</span></span>||author||<span class="hljs-string"><span class="hljs-string">' '</span></span>||body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  Como podemos ver, un cierto n√∫mero de palabras se descartaron debido al tama√±o demasiado grande.  Pero el √≠ndice finalmente se crea y puede admitir consultas de b√∫squeda: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'magic &amp; value'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------- Index Scan using mail_messages_tsv_idx on mail_messages (actual time=0.998..416.335 rows=898 loops=1) Index Cond: (tsv @@ to_tsquery('magic &amp; value'::text)) Rows Removed by Index Recheck: 7859 Planning time: 0.203 ms Execution time: 416.492 ms (5 rows)</code> </pre><br>  Podemos ver que junto con 898 filas que coinciden con la condici√≥n, el m√©todo de acceso devolvi√≥ 7859 filas m√°s que se filtraron al volver a verificar con la tabla.  Esto demuestra un impacto negativo de la p√©rdida de precisi√≥n en la eficiencia. <br><br><h3>  Internos </h3><br>  Para analizar el contenido del √≠ndice, usaremos nuevamente la extensi√≥n "gevel": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a gtsvector) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+------------------------------- 1 | 992 true bits, 0 false bits 2 | 988 true bits, 4 false bits 3 | 573 true bits, 419 false bits 4 | 65 unique words 4 | 107 unique words 4 | 64 unique words 4 | 42 unique words ...</code> </pre><br>  Los valores del tipo especializado "gtsvector" que se almacenan en filas de √≠ndice son en realidad la firma m√°s, tal vez, la fuente "tsvector".  Si el vector est√° disponible, la salida contiene el n√∫mero de lexemas (palabras √∫nicas), de lo contrario, el n√∫mero de bits verdaderos y falsos en la firma. <br><br>  Est√° claro que en el nodo ra√≠z, la firma degener√≥ en "todos", es decir, un nivel de √≠ndice se volvi√≥ absolutamente in√∫til (y uno m√°s se volvi√≥ casi in√∫til, con solo cuatro bits falsos). <br><br><h2>  Propiedades </h2><br>  Veamos las propiedades del m√©todo de acceso GiST (las consultas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se proporcionaron anteriormente</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gist | can_order | f gist | can_unique | f gist | can_multi_col | t gist | can_exclude | t</code> </pre><br>  La ordenaci√≥n de valores y la restricci√≥n √∫nica no son compatibles.  Como hemos visto, el √≠ndice puede construirse en varias columnas y usarse en restricciones de exclusi√≥n. <br><br>  Las siguientes propiedades de capa de √≠ndice est√°n disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  Y las propiedades m√°s interesantes son las de la capa de columna.  Algunas de las propiedades son independientes de las clases de operador: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f search_array | f search_nulls | t</code> </pre><br>  (La ordenaci√≥n no es compatible; el √≠ndice no se puede utilizar para buscar una matriz; se admiten NULL). <br><br>  Pero las dos propiedades restantes, "distancia_orderable" y "retornable", depender√°n de la clase de operador utilizada.  Por ejemplo, para los puntos obtendremos: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | t returnable | t</code> </pre><br>  La primera propiedad indica que el operador de distancia est√° disponible para buscar vecinos m√°s cercanos.  Y el segundo dice que el √≠ndice puede usarse para escaneo de solo √≠ndice.  Aunque las filas de √≠ndice de hoja almacenan rect√°ngulos en lugar de puntos, el m√©todo de acceso puede devolver lo que se necesita. <br><br>  Las siguientes son las propiedades de los intervalos: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | t</code> </pre><br>  Para intervalos, la funci√≥n de distancia no est√° definida y, por lo tanto, no es posible buscar vecinos m√°s cercanos. <br><br>  Y para la b√∫squeda de texto completo, obtenemos: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | f</code> </pre><br>  Se ha perdido la compatibilidad con el escaneo de solo √≠ndice ya que las filas de la hoja pueden contener solo la firma sin los datos en s√≠.  Sin embargo, esta es una p√©rdida menor ya que a nadie le interesa el valor del tipo "tsvector" de todos modos: este valor se utiliza para seleccionar filas, mientras que es el texto fuente que debe mostrarse, pero de todos modos falta en el √≠ndice. <br><br><h2>  Otros tipos de datos </h2><br>  Finalmente, mencionaremos algunos tipos m√°s que actualmente son compatibles con el m√©todo de acceso GiST, adem√°s de los tipos geom√©tricos ya discutidos (por ejemplo, puntos), intervalos y tipos de b√∫squeda de texto completo. <br><br>  De los tipos est√°ndar, este es el tipo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inet</a> " para las direcciones IP.  Todo lo dem√°s se agrega a trav√©s de extensiones: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cube</a> proporciona el tipo de datos "cube" para cubos multidimensionales.  Para este tipo, al igual que para los tipos geom√©tricos en un plano, se define la clase de operador GiST: R-tree, que admite la b√∫squeda de vecinos m√°s cercanos. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seg</a> proporciona el tipo de datos "seg" para intervalos con l√≠mites especificados con cierta precisi√≥n y agrega compatibilidad con el √≠ndice GiST para este tipo de datos (R-tree). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intarray</a> ampl√≠a la funcionalidad de las matrices de enteros y agrega compatibilidad con GiST para ellas.  Se implementan dos clases de operador: "gist__int_ops" (√°rbol RD con una representaci√≥n completa de las claves en las filas de √≠ndice) y "gist__bigint_ops" (√°rbol RD de firma).  La primera clase se puede utilizar para matrices peque√±as y la segunda, para tama√±os m√°s grandes. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ltree</a> agrega el tipo de datos "ltree" para estructuras en forma de √°rbol y el soporte GiST para este tipo de datos (√°rbol RD). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pg_trgm</a> agrega una clase de operador especializada "gist_trgm_ops" para el uso de trigramas en la b√∫squeda de texto completo.  Pero esto se discutir√° m√°s a fondo, junto con el √≠ndice GIN. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444742/">https://habr.com/ru/post/444742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444728/index.html">Mientras escrib√≠a y publicaba un libro sobre la Universidad Estatal de Mosc√∫, o 12 errores cr√≠ticos</a></li>
<li><a href="../444730/index.html">Por qu√© la tecnolog√≠a sin servidor es una revoluci√≥n en la gesti√≥n de productos</a></li>
<li><a href="../444732/index.html">Optimizaci√≥n del rendimiento apache2</a></li>
<li><a href="../444734/index.html">Habraseminar: historias reales sobre marketing de contenidos</a></li>
<li><a href="../444738/index.html">Pixel art: del borrador al activo del juego</a></li>
<li><a href="../444744/index.html">Enviar correo usando PHP</a></li>
<li><a href="../444746/index.html">Te invitamos a MskDotNet Meetup # 34 en Raiffeisenbank upd Broadcast</a></li>
<li><a href="../444748/index.html">3 cualidades clave de un gerente de producto exitoso: Yuri Golikov, VP de Ingenier√≠a Wrike</a></li>
<li><a href="../444752/index.html">La historia de SXSW: c√≥mo comenz√≥ todo</a></li>
<li><a href="../444756/index.html">DARPA desarrollar√° un motor nuclear de cohete</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>