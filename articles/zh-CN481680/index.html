<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📔 🤜🏿 🚨 在dap上编写TodoMVC。 第二部分 🚶🏽 🧝 🚘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是本教程的第二部分，也是最后一部分，在该部分中，我们使用简约的反应式ds js框架编写TodoMVC客户端。 

 第一部分的摘要：我们从服务器收到了JSON格式的待办事项列表，并从中建立了HTML列表，添加了针对每种情况编辑名称和完成标志的功能，并实现了有关这些编辑的服务器通知。 

 它仍然有...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在dap上编写TodoMVC。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481680/">这是本教程的第二部分，也是最后一部分，在该部分中，我们使用简约的反应式<a href="https://dap.js.org/" rel="nofollow">ds</a> js框架编写TodoMVC客户端。 <br><br>  <a href="https://habr.com/en/post/480912/">第一部分的</a>摘要：我们从服务器收到了JSON格式的待办事项列表，并从中建立了HTML列表，添加了针对每种情况编辑名称和完成标志的功能，并实现了有关这些编辑的服务器通知。 <br><br> 它仍然有待实现：删除任意案件，添加新案件，根据完成情况大规模安装/重置和过滤案件以及删除所有已完成案件的功能。 这就是我们要做的。 在本文中，我们将介绍客户端的最终版本。 <br><br><a name="habracut"></a><br><br> 我们上一次确定的选择权可以在<a href="https://dap.js.org/samples/tutorial/7-3.html" rel="nofollow">这里得到解决</a> 。 <br><br> 这是他的代码： <br><br><pre><code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'#header'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'H1'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ,<span class="hljs-string"><span class="hljs-string">'INPUT#new-todo placeholder="What needs to be done?" autofocus'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ) ,<span class="hljs-string"><span class="hljs-string">'#main'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'#toggle-all type=checkbox'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ,<span class="hljs-string"><span class="hljs-string">'UL#todo-list'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"*@ todos:query"</span></span> ,<span class="hljs-string"><span class="hljs-string">'LI'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$completed=.completed $editing= $patch=; a!"</span></span> ,<span class="hljs-string"><span class="hljs-string">'INPUT.toggle type=checkbox'</span></span> .d(<span class="hljs-string"><span class="hljs-string">"#.checked=.completed"</span></span>) .ui(<span class="hljs-string"><span class="hljs-string">"$patch=($completed=#.checked)"</span></span>) ,<span class="hljs-string"><span class="hljs-string">'LABEL.view'</span></span> .d(<span class="hljs-string"><span class="hljs-string">"? $editing:!; ! .title"</span></span>) .e(<span class="hljs-string"><span class="hljs-string">"dblclick"</span></span>,<span class="hljs-string"><span class="hljs-string">"$editing=`yes"</span></span>) ,<span class="hljs-string"><span class="hljs-string">'INPUT.edit'</span></span> .d(<span class="hljs-string"><span class="hljs-string">"? $editing; !! .title@value"</span></span>) .ui(<span class="hljs-string"><span class="hljs-string">"$patch=(.title=#.value)"</span></span>) .e(<span class="hljs-string"><span class="hljs-string">"blur"</span></span>,<span class="hljs-string"><span class="hljs-string">"$editing="</span></span>) ,<span class="hljs-string"><span class="hljs-string">'BUTTON.destroy'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ) .a(<span class="hljs-string"><span class="hljs-string">"!? $completed $editing"</span></span>) .u(<span class="hljs-string"><span class="hljs-string">"? $patch; (@method`PATCH .url:dehttp headers $patch@):query $patch="</span></span>) ) ) ,<span class="hljs-string"><span class="hljs-string">'#footer'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'#todo-count'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ,<span class="hljs-string"><span class="hljs-string">'UL#filters'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'LI'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ) ,<span class="hljs-string"><span class="hljs-string">'#clear-completed'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>) ) ) .DICT({ <span class="hljs-attr"><span class="hljs-attr">todos</span></span> : <span class="hljs-string"><span class="hljs-string">"//todo-backend-express.herokuapp.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: {<span class="hljs-string"><span class="hljs-string">"Content-type"</span></span>:<span class="hljs-string"><span class="hljs-string">"application/json"</span></span>} }) .FUNC({ <span class="hljs-attr"><span class="hljs-attr">convert</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">dehttp</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">=&gt;</span></span>url.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^https?\:/</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>) } }) .RENDER()</code> </pre> <br><br> 现在这里只有五十行，但是到本文结尾，将有两倍-多达100行。到服务器的HTTP请求将很多，所以请打开开发人员工具（在Chrome中，您记得Ctrl + Shift + I）-首先，“网络”选项卡很有趣，其次是“控制台”。 另外，请不要忘记查看每个页面版本的代码-在Chrome中为Ctrl +U。 <br><br> 在这里，我必须做些题外话。 如果您没有阅读本教程的<a href="https://habr.com/en/post/480912/">第一部分</a> ，我仍然建议您从头开始。 如果您阅读了它，但什么都不懂，最好再读一遍。 正如我对前两篇文章的评论所显示的那样，准备不足的读者并不总是会立即理解dap的语法和原理。 不建议另一篇文章阅读给那些对si语法不满意的人。 <br><br><img src="https://habrastorage.org/webt/wj/-n/br/wj-nbrh5eflirkcich69glgnooo.jpeg"><br><br> 本教程的第二部分将比第一部分更加复杂和有趣。  <i>[待办事项：让<a href="https://habr.com/en/users/token/" class="user_link">令牌</a>找到一个在互联网上爆炸大脑图片的男生]</i> 。 <br><br> 在您的允许下，我将继续在第1部分中为各章编号。 在那里，我们数到了7。 <br><br><h2>  8.制作状态变量的待办事项列表 </h2><br> 要从列表中删除案例，有一个按钮<code>BUTTON.destroy</code> 。 删除包括向服务器发送DELETE请求，并实际上删除所有内容的相应<code>UL#todo-list &gt; LI</code>元素<code>UL#todo-list &gt; LI</code> 。 发送DELETE请求后，一切都变得清晰了： <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'BUTTON.destroy'</span></span>.ui(<span class="hljs-string"><span class="hljs-string">"(@method`DELETE .url:dehttp):query"</span></span>)</code> </pre><br><br> 但是，通过从屏幕上删除元素，可以进行选择。 可以简单地引入另一个状态变量，例如<code>$deleted</code> ，并使用CSS隐藏该元素，包括<code>deleted</code> CSS类。 <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'LI'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$completed=.completed $editing= $patch= $deleted=; a!"</span></span> <span class="hljs-comment"><span class="hljs-comment">//  $deleted   "" ... ,'BUTTON.destroy'.d("(@method`DELETE .url:dehttp):query $deleted=`yes") //  $deleted -     ) .a("!? $completed $editing $deleted") //   CSS  .deleted{display:none}</span></span></code> </pre><br><br> 它会工作。 但这会作弊。 此外，在此行的更下方，我们将具有活动和已完成案例的过滤器和计数器（ <code>#footer</code> ）。 因此，最好诚实地，“物理地”立即从待办事项列表中删除对象。 也就是说，我们需要具有修改数组本身的能力，这是我们最初从服务器收到的，这意味着该数组也必须成为状态变量。 我们称她<code>$todos</code> 。 <br><br>  <code>$todos</code>变量的范围是选择将访问此变量的所有元素的公共祖先。 它将由<code>#header</code>的<code>INPUT#new-todo</code>和<code>#footer</code>计数器以及实际上是<code>UL#todo-list</code> 。 它们全部的共同祖先是模板的根元素<code>#todoapp</code> 。 因此，在其d规则中，我们将定义变量<code>$todos</code> 。 在同一位置，我们立即将数据从服务器上传到该服务器。 为了建立<code>UL#todo-list</code> ，我们现在也可以从中得到： <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$todos=todos:query"</span></span> <span class="hljs-comment"><span class="hljs-comment">//   $todos      ... ,'UL#todo-list'.d("*@ $todos" //     $todos</span></span></code> </pre><br><br>  <b>这很重要。</b> 如果在测试过程中突然未加载待办事项列表，则很可能有人将它们全部删除了（这是一台公共服务器，任何事情都可能在那发生）。 <br> 在这种情况下，请转到<a href="https://dap.js.org/samples/tutorial/16.html" rel="nofollow">功能完整的示例</a>并创建一些案例进行试验。 <br><br>  <a href="https://dap.js.org/samples/tutorial/8-1.html" rel="nofollow">我们看</a> 。 在这里， <code>$todos</code>在<code>#todoapp</code>元素的d规则中<i>声明</i> ，并立即<i>用</i>必要的数据<i>初始化</i> 。 一切似乎正常，但是出现了一个令人不快的功能。 如果服务器长时间响应请求（Chrome可以让您模拟这种情况：在开发人员工具的“网络”标签上，您可以选择模拟慢速网络的不同模式），那么直到请求完成之前，我们的新版本应用程序看起来都有些令人遗憾-除了CSS文物。 这样的图片绝对不会给用户增加热情。 尽管以前的版本没有受到此影响-在页面上接收到数据之前，只缺少列表本身，但是其他元素立即出现，而无需等待数据。 <br><br> 就是这个 您还记得<code>:query</code>转换器是异步的。 这种异步性表现为以下事实：在请求完成之前，只有当前规则的执行被阻止，也就是说，实际上需要请求的数据（逻辑上）的元素的生成。 其他元素的生成不会被阻止。 因此，当<code>UL#todo-list</code>访问服务器时，只有服务器被阻止，而<code>#header</code>和<code>#footer</code>却没有被阻止，它们是立即绘制的。 现在，整个<code>#todoapp</code>正在等待请求完成。 <br><br><h2>  9.延迟的数据加载 </h2><br> 为了纠正这种情况并避免阻塞无关的元素，我们将推迟数据的初始加载，直到所有内容都绘制完成为止。 为此，我们不会立即将数据加载到<code>$todos</code>变量中，而是首先简单地使用“ nothing”将其初始化 <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$todos="</span></span> <span class="hljs-comment"><span class="hljs-comment">//   $todos    ""</span></span></code> </pre><br><br> 因此，她不会阻止任何操作，整个模板都可以使用-尽管目前只有一个空的“待办事项列表”。 但是现在，在无聊的初始屏幕上，您可以通过将待办事项列表上载到<code>$todos</code>来安全地对其进行<i>修改</i> 。 为此，将此后代添加到<code>#todoapp</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'loader'</span></span> .u(<span class="hljs-string"><span class="hljs-string">"$todos=todos:query"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  $todos,       .d("u") //   (u-)   </span></span></code> </pre><br><br> 该元素的U规则看起来与我们拒绝的阻止规则完全相同，但是存在一个根本区别。 <br> 让我提醒您，d规则（从<i>down</i> ）是在<i>从上到下</i> ，从父级到后代构建模板时执行的元素生成规则。 和u-rules（来自<i>up</i> ）是响应规则，用于响应从下到<i>上</i> ，从子级到父级弹出的事件。 <br> 因此，如果<b>在d-rule中将</b>某物（包括“ nothing”）分配<b>给</b>变量<b>，则</b>意味着在该元素及其后代的范围内对其进行了<i>声明和初始化</i> （嵌套范围在dap中实现，如JS中一样） ）  <b>上规则中的</b>分配表示对作用域中先前声明<i>的</i>变量的<i>修改</i> 。  d规则中变量的声明和初始化允许父级将构造所需的信息传递给层次结构的后代，而修改则允许父级将对此信息的更新传递给该父级，从而对依赖于此信息的所有元素进行适当的重组。 <br><br>  <code>loader</code>元素是<code>#todoapp</code>的后代，在其u规则中<b>会修改</b> <code>$todos</code>变量，将服务器中的数据加载到其中，这将导致该变量的所有使用者元素（仅它们，这很重要！）的自动再生。 变量的使用者是其d规则包含此变量作为右值的元素，即 那些在构建时<b>读取</b>此变量（考虑范围）的人。 <br><br> 现在，我们有一个<code>$todos</code>变量的使用者-非常<code>UL#todo-list</code> ，因此，它将在加载数据后重新构建。 <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'UL#todo-list'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"*@ $todos"</span></span> <span class="hljs-comment"><span class="hljs-comment">//  ,   $todos</span></span></code> </pre><br><br> 因此， <a href="https://dap.js.org/samples/tutorial/9.html" rel="nofollow">现在</a>我们有一个待办事项列表是<code>#todoapp</code>的状态变量，而不会阻止模板的初始呈现。 <br><br><h2>  10.删除和添加待办事项 </h2><br> 现在我们可以<code>$todos</code>各种方式修改<code>$todos</code> 。 让我们从删除项目开始。 我们已经有一个跨<code>BUTTON.destroy</code>的按钮，到目前为止，它只是发送服务器删除请求 <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'BUTTON.destroy'</span></span>.ui(<span class="hljs-string"><span class="hljs-string">"(@method`DELETE .url:dehttp):query"</span></span>)</code> </pre><br><br> 必须确保也从<code>$todos</code>变量中删除了相应的对象-由于这将是一个修改，因此作为该变量的使用者的<code>UL#todo-list</code>将被自动重建，但没有删除的元素。 <br><br>  dap本身不提供任何特殊的数据处理方法。 操纵可以完美地用JS函数编写，并且dap规则只是向它们传递数据并获取结果。 我们编写了一个JS函数，以在不知道对象编号的情况下从数组中删除对象。 例如，这： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remove = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr,tgt</span></span></span><span class="hljs-function">)=&gt;</span></span> arr.filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function"> =&gt;</span></span> obj!=tgt );</code> </pre><br><br> 您可能可以写出更有效的内容，但现在还不行。 我们的应用程序不太可能必须处理数百万个项目的待办事项列表。 重要的是该函数返回一个新的数组对象，而不仅仅是从元素中删除该元素。 <br><br> 为了使该功能可从dap规则访问，您需要将其添加到<code>.FUNC</code>部分，但在此之前确定我们要如何调用它。 在这种情况下，最简单的选择是从转换器中调用它，该转换器接受<code>{ todos, tgt }</code>对象并返回过滤后的数组 <br><br><pre> <code class="javascript hljs">.FUNC({ <span class="hljs-attr"><span class="hljs-attr">convert</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">dehttp</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function"> =&gt;</span></span> url.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^https?\:/</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-comment"><span class="hljs-comment">//        remove: x =&gt; remove(x.todos,x.tgt) //     } })</span></span></code> </pre><br><br> 但是没有什么阻止您直接在<code>.FUNC</code>内部定义此函数的（我已经说过<code>.FUNC</code>实际上是普通的JS方法，并且其参数是普通的JS对象？） <br><br><pre> <code class="javascript hljs">.FUNC({ <span class="hljs-attr"><span class="hljs-attr">convert</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">dehttp</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function"> =&gt;</span></span> url.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^https?\:/</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">remove</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.todos.filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo!=x.tgt ) } })</code> </pre><br><br> 现在我们可以从dap规则访问此转换器 <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'BUTTON.destroy'</span></span> .ui(<span class="hljs-string"><span class="hljs-string">"$todos=($todos $@tgt):remove (@method`DELETE .url:dehttp):query"</span></span>)</code> </pre><br><br> 在这里，我们首先形成一个对象，该对象以JS表示法匹配<code>{ todos, tgt:$ }</code> ，并将其传递给<code>.FUNC</code>描述的<code>:remove</code>转换器，然后将过滤后的结果返回给<code>$todos</code> ，从而对其进行修改。  <code>$</code>是元素的<i>数据上下文，该</i>元素是构建模板的<code>$todos</code>数组中的业务对象。  <code>@</code>符号后，指示参数的别名。 如果不存在<code>@</code> ，则使用参数自己的名称。 这类似于最近的ES6创新- <a href="http://es6-features.org/" rel="nofollow">属性速记</a> 。 <br><br> 同样，我们使用<code>INPUT#new-todo</code>元素和POST请求将新案例添加到列表中 <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'INPUT#new-todo placeholder="What needs to be done?" autofocus'</span></span> .ui(<span class="hljs-string"><span class="hljs-string">"$=(#.value@title) (@method`POST todos@url headers $):query $todos=($todos $@tgt):insert #.value="</span></span>) ... .FUNC({ <span class="hljs-attr"><span class="hljs-attr">convert</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">dehttp</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function"> =&gt;</span></span> url.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^https?\:/</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">remove</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.todos.filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> todo!=x.tgt ), <span class="hljs-comment"><span class="hljs-comment">//     insert: x =&gt; x.todos.concat( [x.tgt] ) //     } })</span></span></code> </pre><br><br>  <code>INPUT#new-todo</code>元素对标准UI事件的反应规则（对于<code>INPUT</code>元素，将<code>change</code>事件视为标准dap）包括：从此元素的<code>value</code>属性读取用户输入，以该值作为<code>.title</code>字段形成本地<code>$</code>上下文，发送<code>$</code>上下文使用POST方法连接到服务器，通过添加上下文<code>$</code>作为新元素来修改<code>$todos</code>数组，最后清除<code>INPUT</code>元素的<code>value</code>属性。 <br><br> 在这里，一个年轻的读者可能会问：如果可以使用常规的<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push" rel="nofollow"><code>push()</code></a>完成操作，为什么在向数组添加元素时使用<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" rel="nofollow"><code>concat()</code></a> <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/push" rel="nofollow"><code>push()</code></a> ？ 经验丰富的读者会立即了解问题所在，并在评论中写下答案。 <br><br> 我们看看<a href="https://dap.js.org/samples/tutorial/10-1.html" rel="nofollow">发生</a>了什么，正常添加和删除案例，相应的请求已正确发送到服务器（您一直保持“网络”选项卡处于打开状态，对吗？）。 但是，如果我们想更改新添加的案例的名称或状态该怎么办？ 问题是要通知服务器这些更改，我们需要<code>.url</code> ，它将服务器分配给该业务。 创建业务时， <code>.url</code>分别不知道其<code>.url</code> ，因此无法形成正确的PATCH更改请求。 <br><br> 实际上，有关该案例的所有必要信息都包含在服务器对POST请求的响应中，不仅从用户输入而是从服务器的响应中创建一个新的业务对象，然后将此对象添加到<code>$todos</code> （提供了所有内容），这将是更正确的选择服务器信息，包括<code>.url</code>字段 <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'INPUT#new-todo placeholder="What needs to be done?" autofocus'</span></span> .ui(<span class="hljs-string"><span class="hljs-string">"$todos=($todos (@method`POST todos@url headers (#.value@title)):query@tgt ):insert #.value="</span></span>)</code> </pre><br><br> 我们看起来-好的，现在一切都在正确进行中。 向服务器发送有关编辑新创建案例的通知很正确。 <br><br> 可能有人会停下来，但是...但是，如果仔细观察，您仍然会注意到在输入新案件的名称与它出现在列表之间的时间之间存在一点延迟。 如果您打开模拟慢速网络，则该延迟清晰可见。 您可能已经猜到了，这是对服务器的请求：首先，我们从服务器请求一个新案例的数据，只有在接收到它们之后，我们才修改<code>$todos</code> 。 下一步，我们将尝试纠正这种情况，但是首先，我将把您的注意力转移到另一个有趣的地方。 如果我们稍微回溯到<a href="https://dap.js.org/samples/tutorial/10-1.html" rel="nofollow">以前的版本</a> ，请注意：尽管请求也存在，但新案例会立即添加到列表中，而无需等待请求结束 <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//    , :query   .ui("$=(#.value@title) (@method`POST todos@url headers $):query $todos=($todos $@tgt):insert #.value=")</span></span></code> </pre><br><br> 这是在dap中计算异步转换器的另一个功能：如果不使用异步转换器的结果（即，它没有分配给任何东西），那么您将无法等待其完成-规则不会被阻止。 这通常很有用：您可能已经注意到，从列表中删除案例时，它们会立即从屏幕上消失，而无需等待DELETE请求的结果。 如果您连续快速删除多个案例并在“网络”面板中跟踪请求，则这一点尤其明显。 <br><br> 但是，由于我们使用POST请求的结果-将其分配给<code>$</code>上下文-我们必须等待它完成。 因此，您需要在执行POST请求之前找到另一种修改<code>$todos</code>方法。 解决方案：仍然，首先创建一个新的业务对象，然后立即将其添加到<code>$todos</code> ，让列表绘制，直到渲染之后，如果该业务<code>.url</code> （即刚刚创建的业务），则执行POST请求，然后将其结果强加给这种情况的数据上下文。 <br><br> 因此，首先我们将一个仅包含<code>.title</code>的空白添加到<code>.title</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'INPUT#new-todo placeholder="What needs to be done?" autofocus'</span></span> .ui(<span class="hljs-string"><span class="hljs-string">"$todos=($todos (#.value@title)@tgt):insert #.value="</span></span>)</code> </pre><br><br>  <code>UL#todo-list &gt; LI</code>元素生成规则已包含<code>a!</code> 在第一次绘制元素后开始一个规则。 在那里，我们可以在没有<code>.url</code>的情况下添加POST请求的启动。 要将其他字段注入上下文，dap具有<code>&amp;</code>运算符 <br><br><pre> <code class="javascript hljs"> .a(<span class="hljs-string"><span class="hljs-string">"!? $completed $editing; ? .url:!; &amp; (@method`POST todos@url headers $):query"</span></span>)</code> </pre><br><br>  <a href="https://dap.js.org/samples/tutorial/10-3.html" rel="nofollow">我们看</a> 。 另一件事！ 即使网络速度较慢，待办事项列表也会立即更新，并且在绘制更新后的列表后，服务器通知和丢失数据的加载会在后台进行。 <br><br><h2>  11.大家好！ </h2><br> 在<code>#header</code>元素中，有一个按钮用于批量安装/重置列表中所有情况的完成标志。 为了将值大规模分配给数组元素的字段，我们只需编写另一个转换器<code>:assign</code> <code>$todos</code> ，然后通过单击<code>INPUT#toggle-all</code>将其应用于<code>$todos</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'INPUT#toggle-all type=checkbox'</span></span> .ui(<span class="hljs-string"><span class="hljs-string">"$todos=($todos (#.checked@completed)@src):assign"</span></span>) ... assign: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.todos &amp;&amp; x.todos.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(todo,x.src))</code> </pre><br><br> 在这种情况下，我们只对<code>.completed</code>字段感兴趣，但是很容易看到，使用这种转换器，您可以大量更改数组元素的任何字段的值。 <br> 好的，在<code>$todos</code>数组中， <code>$todos</code>切换，现在我们需要将所做的更改通知服务器。 在原始示例中，这是通过针对每种情况发送PATCH请求来完成的-这不是一种非常有效的策略，但它不再取决于我们。 好的，对于每种情况，我们都会发送PATCH请求 <br><br><pre> <code class="javascript hljs"> .ui(<span class="hljs-string"><span class="hljs-string">"*@ $todos=($todos (#.checked@completed)@src):assign; (@method`PATCH .url:dehttp headers (.completed)):query"</span></span>)</code> </pre><br><br>  <a href="https://dap.js.org/samples/tutorial/11.html" rel="nofollow">我们看一下</a> ：单击一个普通的daw会使所有单个daw对齐，并且服务器会通过适当的PATCH请求得到通知。 规范 <br><br><h2>  12.根据完成情况过滤案例 </h2><br> 除了实际的待办事项清单，应用程序还应该能够按完成标志过滤案例，并显示已完成和未完成任务的计数器。 当然，对于过滤，我们将使用JS本身提供的相同<a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="nofollow"><code>filter()</code></a>方法非常简单。 <br><br> 但是首先，您需要确保每个案例的<code>.completed</code>字段始终为true，并且当您单击案例的单个行时，将连同<code>$completed</code>变量一起更新。 以前，这对我们而言并不重要，但现在已经变得重要。 <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'INPUT.toggle type=checkbox'</span></span> .d(<span class="hljs-string"><span class="hljs-string">"#.checked=.completed"</span></span>) .ui(<span class="hljs-string"><span class="hljs-string">"$patch=(.completed=$completed=#.checked) $recount=()"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  .completed       </span></span></code> </pre><br><br> 这里的重点是每个案例的数据上下文都是案例对象本身，位于<code>$todos</code>数组中。 不是单个副本或相关构造，而是对象本身。 并且所有对<code>.title</code> ， <code>.title</code> <code>.completed</code>字段的调用<code>.completed</code>  <code>url</code> （包括读写）直接应用于此对象。 因此，为了使<code>$todos</code>数组过滤正常工作，我们需要确保不仅在屏幕上的daw中，而且还在<code>.completed</code>对象的<code>.completed</code>字段中反映<code>.completed</code>的<code>.completed</code> 。 <br><br> 为了仅显示列表中具有必要完整性标志的情况，我们将根据所选过滤器简单过滤<code>$todos</code> 。 您猜到，所选过滤器是应用程序的另一个状态变量，我们将其称为： <code>$filter</code> 。 要根据选定的<code>$filter</code>器过滤<code>$todos</code> <code>$filter</code>让我们<code>$todos</code>缩略图并添加另一个转换器，形式为<i>{list，filter} =&gt; filtered list</i> ，我们将从“关联数组”（即普通JS）中获取名称和过滤功能。对象） <code>todoFilters</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todoFilters={ <span class="hljs-string"><span class="hljs-string">"All"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Active"</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> !todo.completed, <span class="hljs-string"><span class="hljs-string">"Completed"</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todo</span></span></span><span class="hljs-function"> =&gt;</span></span> !!todo.completed }; <span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$todos= $filter="</span></span> <span class="hljs-comment"><span class="hljs-comment">//   $filter ... ,'UL#todo-list'.d("* ($todos $filter):filter" ... ,'UL#filters'.d("* filter" //  filter      .DICT ,'LI' .d("! .filter") .ui("$filter=.") //    "$filter=.filter" ) ... .DICT({ ... filter: Object.keys(todoFilters) //["All","Active","Completed"] }) .FUNC({ convert:{ ... filter: x =&gt;{ const a = x.todos, f = x.filter &amp;&amp; todoFilters[x.filter]; return a&amp;&amp;f ? a.filter(f) : a; } } })</span></span></code> </pre><br><br>  <a href="https://dap.js.org/samples/tutorial/12-1.html" rel="nofollow">我们检查</a> 。 过滤器正常工作。 筛选器的名称显示在一起是有细微差别的，因为 在这里，我们从原始的DOM结构中稍微走了一步，然后脱离了CSS。 但是，稍后我们将返回到此。 <br><br><h2>  13.完成和进行中案件的柜台。 </h2><br> 要显示完成案例和活动案例的计数器，只需使用适当的过滤器过滤<code>$todos</code>并显示结果数组的长度 <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'#footer'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$active=($todos @filter`Active):filter $completed=($todos @filter`Completed):filter"</span></span> ,<span class="hljs-string"><span class="hljs-string">'#todo-count'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"! (active $active.length)format"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  length    active ... ,'#clear-completed'.d("! (completed $completed.length)format") ) ... .DICT({ ... active: "{length} items left", completed: "Clear completed items ({length})" })</span></span></code> </pre><br><br> 在<a href="https://dap.js.org/samples/tutorial/13-1.html" rel="nofollow">这种形式下，</a>计数器会在启动时显示正确的值，但不会响应事务完成时的后续更改（单击DAWS时）。 事实是，点击寒鸦，改变每种情况的状态，不会改变<code>$todos</code>的状态-数组元素的修改不是数组本身的修改。 因此，我们需要有关需要重新注册案件的其他信号。 这样的信号可以是一个附加的状态变量，每次需要重新计数时都会对其进行修改。 称之为<code>$recount</code> 。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在d规则中声明一个共同祖先，当单击daws时将对其进行更新，并将</font></font><code>#footer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该</font><font style="vertical-align: inherit;">元素设为</font><font style="vertical-align: inherit;">消费者-为此，请在其d规则中提及此变量</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"$todos= $filter= $recount="</span></span> <span class="hljs-comment"><span class="hljs-comment">//  $recount     ... ,'INPUT.toggle type=checkbox' .d("#.checked=.completed") .ui("$patch=(.completed=$completed=#.checked) $recount=()") //  $recount    ... ,'#footer'.d("$active=($todos @filter`Active):filter $completed=($todos @filter`Completed):filter $recount" //  $recount</span></span></code> </pre><br><br> <a href="https://dap.js.org/samples/tutorial/13-2.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切正常，计数器已正确更新。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.删除所有已完成的案件。 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TodoMVC中案例的批量删除作为非原始的批量修改实现-通过多个请求。</font><font style="vertical-align: inherit;">好吧，让我们感叹一下，耸耸肩，然后按DELETE请求执行每个完成的案例-现在我们已经全部拥有了</font></font><code>$completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，</font></font><code>$todos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在删除完案后，应该已经</font></font><code>$active</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'#clear-completed'</span></span> .d(<span class="hljs-string"><span class="hljs-string">"! (completed $completed.length)format"</span></span>) .ui(<span class="hljs-string"><span class="hljs-string">"$todos=$active; *@ $completed; (@method`DELETE .url:dehttp):query"</span></span>)</code> </pre><br><br> <a href="https://dap.js.org/samples/tutorial/14.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们看</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：我们创建了一些不必要的事务，用daws标记它们并删除。</font><font style="vertical-align: inherit;">“网络”选项卡将显示这种对批处理方法的恐惧。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.地址栏中的状态 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回筛选器的选择。</font><font style="vertical-align: inherit;">在原始示例中，选定的过滤器将显示在＃后面的地址栏中。</font><font style="vertical-align: inherit;">手动或在导航过程中更改地址栏中的＃片段时，所选过滤器也会更改。</font><font style="vertical-align: inherit;">这使您可以使用已选择的待办事项过滤器通过URL转到应用程序页面。</font><font style="vertical-align: inherit;">例如，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在</font><font style="vertical-align: inherit;">一个元素</font><font style="vertical-align: inherit;">（或其任何后代）</font><font style="vertical-align: inherit;">的a-rule </font><font style="vertical-align: inherit;">中使用</font></font><code>location.hash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符</font></font><code>urlhash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行</font><font style="vertical-align: inherit;">写入，该</font><font style="vertical-align: inherit;">运算符</font></font><code>#todoapp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将在每次更新时执行</font></font><code>$filter</code> <br><br><pre> <code class="javascript hljs">.a(<span class="hljs-string"><span class="hljs-string">"urlhash $filter"</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，您可以使用</font></font><code>$filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地址栏中</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">初始化变量，</font><font style="vertical-align: inherit;">然后</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">返回当前状态</font><font style="vertical-align: inherit;">（不带＃）</font><font style="vertical-align: inherit;">的伪转换器</font><font style="vertical-align: inherit;">通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashchange</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件</font><font style="vertical-align: inherit;">进行</font><font style="vertical-align: inherit;">更新。</font></font><code>:urlhash</code><font style="vertical-align: inherit;"></font><code>location.hash</code><font style="vertical-align: inherit;"></font><br><br><pre> <code class="javascript hljs">.d(<span class="hljs-string"><span class="hljs-string">"$todos= $filter=:urlhash $recount="</span></span> .e(<span class="hljs-string"><span class="hljs-string">"hashchange"</span></span>,<span class="hljs-string"><span class="hljs-string">"$filter=:urlhash"</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当地址栏中的＃片段发生更改时，浏览器</font><font style="vertical-align: inherit;">会</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引发hashchange</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然而，由于某种原因，只</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>document.body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能听此事件。</font><font style="vertical-align: inherit;">要从某个元素跟踪此事件</font></font><code>#todoapp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您必须在其d规则</font></font><code>listen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">添加一个运算符，以</font><font style="vertical-align: inherit;">对该元素进行签名以中继来自该对象的事件</font></font><code>window</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'#todoapp'</span></span> .a(<span class="hljs-string"><span class="hljs-string">"urlhash $filter"</span></span>) .e(<span class="hljs-string"><span class="hljs-string">"hashchange"</span></span>,<span class="hljs-string"><span class="hljs-string">"$filter=:urlhash"</span></span>) .d(<span class="hljs-string"><span class="hljs-string">"$todos= $filter=:urlhash $recount=; listen @hashchange"</span></span></code> </pre><br><br> <a href="https://dap.js.org/samples/tutorial/15-1.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们看一下</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：切换过滤器，跟踪地址栏中的更改，通过</font></font><a href="https://dap.js.org/samples/tutorial/15-1.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#Active</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://dap.js.org/samples/tutorial/15-1.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#All</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://dap.js.org/samples/tutorial/15-1.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#Completed</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一切正常。</font><font style="vertical-align: inherit;">但是回到原来。</font><font style="vertical-align: inherit;">似乎在这里实现了过滤器的选择-通过单击链接。</font><font style="vertical-align: inherit;">尽管不是很实用，但是为了完整起见，我们将做同样的事情。</font></font><br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'UL#filters'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"* filter"</span></span> ,<span class="hljs-string"><span class="hljs-string">'LI'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span> ,<span class="hljs-string"><span class="hljs-string">'A'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"!! (`# .filter)concat@href .filter@"</span></span>) ) )</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使选定的过滤器脱颖而出，请添加条件样式化运算符</font></font><code>!?</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>selected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font></font><code>.filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上下文</font><font style="vertical-align: inherit;">字段</font><font style="vertical-align: inherit;">中的值等于变量的值，则该</font><font style="vertical-align: inherit;">操作符</font><font style="vertical-align: inherit;">将向元素添加CSS类</font></font><code>$filter</code> <br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'A'</span></span>.d(<span class="hljs-string"><span class="hljs-string">"!! (`# .filter)concat@href .filter@; !? (.filter $filter)eq@selected"</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按照</font></font><a href="https://dap.js.org/samples/tutorial/15-2.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种形式，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的dap应用程序</font><a href="https://dap.js.org/samples/tutorial/15-2.html" rel="nofollow"><font style="vertical-align: inherit;">的</font></a><font style="vertical-align: inherit;">功能已经（据我所知）与</font></font><a href="https://todo-backend-express.herokuapp.com/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原始功能</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全一致</font><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16.一些画龙点睛 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我真的不喜欢原始形状的光标形状不会更改活动元素，因此我们将</font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种样式</font><font style="vertical-align: inherit;">添加到</font><font style="vertical-align: inherit;">HTML文档中</font></font><br><br><pre> <code class="javascript hljs"> [ui=click]{<span class="hljs-attr"><span class="hljs-attr">cursor</span></span>:pointer}</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，至少我们会看到您可以单击的位置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哦，是的！</font><font style="vertical-align: inherit;">仍然需要用大写字母写“待办事项”。</font><font style="vertical-align: inherit;">但是在这里，也许我会允许自己最终展现一点想象力和创造力，而我不仅会写“待办事项”，还会写“ dap待办事项”</font></font><br><br><pre> <code class="javascript hljs"> ,<span class="hljs-string"><span class="hljs-string">'H1'</span></span>.d(<span class="hljs-string"><span class="hljs-string">""</span></span>,<span class="hljs-string"><span class="hljs-string">"dap todos"</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哇 </font><font style="vertical-align: inherit;">现在</font></font><a href="https://dap.js.org/samples/tutorial/16.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的应用程序</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以被认为是完整的，并且可以举行本教程（如果您老实地读了这些内容）。</font></font><br><br><h2> 总结 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 也许，在阅读时，您会感觉到dap程序是通过反复试验编写的-它们全都是“让我们看看发生了什么”，“它似乎有用，但有细微差别”等。 </font></font>实际上并非如此。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在编写代码时，所有这些细微差别都非常明显且可预测。</font><font style="vertical-align: inherit;">但是我认为通过这些细微差别的例子来说明为什么这个或那个决定出现在规则中，为什么这样做是这样，而不是其他方式，这将是有用的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如他们所说，问问题。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481680/">https://habr.com/ru/post/zh-CN481680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481670/index.html">使用AWS Cloud Adoption Framework创建行动计划</a></li>
<li><a href="../zh-CN481672/index.html">浏览器中的元胞自动机</a></li>
<li><a href="../zh-CN481674/index.html">汽车销售渠道还是如何不合并客户，甚至与拒绝您服务的客户合作？</a></li>
<li><a href="../zh-CN481676/index.html">安全周52：智能扬声器和IP摄像机的安全性</a></li>
<li><a href="../zh-CN481678/index.html">假日前回顾：N6IIT01播放器和YB04电枢耳机-来自华南的Hi-Fi</a></li>
<li><a href="../zh-CN481684/index.html">来自Powerbank的笔记本电脑？</a></li>
<li><a href="../zh-CN481688/index.html">为什么要学习Java以及如何有效地学习Java。 Yandex报告</a></li>
<li><a href="../zh-CN481692/index.html">使用英特尔处理器跟踪来跟踪系统管理模式代码</a></li>
<li><a href="../zh-CN481694/index.html">我在PostgreSQL中进行分区的方式</a></li>
<li><a href="../zh-CN481696/index.html">Ruleguard：Go的动态检查</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>