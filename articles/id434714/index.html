<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐒 🖖🏽 🎅🏾 Sinkronisasi Permintaan Klien di Musim Semi 👨‍👨‍👦 👧🏿 😁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini saya menyarankan Anda untuk menganalisis satu tugas praktis tentang ras permintaan klien yang saya temui di MaximTelecom ketika mengembangkan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sinkronisasi Permintaan Klien di Musim Semi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/maximatelecom/blog/434714/">  Hari ini saya menyarankan Anda untuk menganalisis satu tugas praktis tentang ras permintaan klien yang saya temui di MaximTelecom ketika mengembangkan back-end untuk aplikasi seluler kami MT_FREE. <br><br>  Saat startup, aplikasi klien secara tidak sinkron mengirim "paket" permintaan ke API.  Aplikasi memiliki pengidentifikasi clientId, yang memungkinkan untuk membedakan permintaan dari satu klien dengan yang lain.  Untuk setiap permintaan di server, kode formulir dijalankan: <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      Client client = clientRepository.findByClientId(clientId); //      if(client == null){ client = clientRepository.save(new Client(clientId)); } //   </span></span></code> </pre> <br>  di mana entitas Klien memiliki bidang clientId, yang harus unik dan memiliki batasan unik dalam database untuk ini.  Karena di Musim Semi setiap permintaan akan mengeksekusi kode ini di utas terpisah, bahkan jika ini adalah permintaan dari aplikasi klien yang sama, kesalahan formulir akan muncul: <br><blockquote>  pelanggaran integritas integritas: kendala unik atau pelanggaran indeks;  Tabel UK_BFJDOY2DPUSSYLQ7G1S3S1TN8: CLIENT </blockquote><br>  Kesalahan terjadi karena alasan yang jelas: 2 atau lebih utas dengan clientId yang sama menerima klien == entitas nol dan mulai membuatnya, setelah itu mereka mendapatkan kesalahan saat melakukan. <br><br><h3>  Tantangan: </h3><br>  Adalah perlu untuk menyinkronkan permintaan dari satu clientId sehingga hanya permintaan pertama yang menyelesaikan pembuatan entitas Klien, dan sisanya akan diblokir pada saat pembuatan dan menerima objek yang sudah dibuat. <br><a name="habracut"></a><br><h3>  Solusi 1 </h3><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   synchronized (this){ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } }</span></span></code> </pre><br>  Solusi ini berfungsi, tetapi sangat mahal, karena semua permintaan (utas) yang perlu dibuat diblokir, bahkan jika mereka menciptakan Klien dengan clientId yang berbeda dan tidak saling bersaing. <br><br>  Harap perhatikan bahwa kombinasi sinkronisasi dengan anotasi @Transaksional <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> Client </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String clientId)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      Client client = clientRepository.findByClientId(clientId); //      if(client == null){ client = clientRepository.save(new Client(clientId)); } return client; }</span></span></code> </pre><br>  kesalahan yang sama akan terjadi lagi.  Alasannya adalah monitor (yang disinkronkan) dibebaskan terlebih dahulu dan utas berikutnya memasuki area yang disinkronkan, dan hanya setelah itu transaksi dilakukan oleh utas pertama pada objek proxy.  Untuk mengatasi masalah ini sederhana - Anda perlu monitor dilepaskan setelah komit, oleh karena itu, disinkronkan harus disebut di atas: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>){ client = clientService.getOrCreateUser(clientId); }</code> </pre><br><h3>  Keputusan 2 </h3><br>  Saya benar-benar ingin menggunakan desain formulir: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (clientId)</code> </pre> <br>  tetapi masalahnya adalah objek clientId baru akan dibuat untuk setiap permintaan, bahkan jika nilainya setara, oleh karena itu, sinkronisasi tidak dapat dilakukan dengan cara ini.  Untuk menyelesaikan masalah dengan objek clientId yang berbeda, Anda perlu menggunakan kumpulan: <br><br><pre> <code class="java hljs">Client client = clientRepository.findByClientId(clientId); <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   synchronized (clientId.intern()){ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } }</span></span></code> </pre><br>  Solusi ini menggunakan kumpulan string java, masing-masing, permintaan dengan clientId yang setara, dengan memanggil clientId.intern (), akan menerima objek yang sama.  Sayangnya, dalam praktiknya, solusi ini tidak berlaku, karena tidak mungkin untuk mengelola "membusuk" clientId, yang cepat atau lambat akan mengarah ke OutOfMemory. <br><br><h3>  Keputusan 3 </h3><br>  Untuk menggunakan ReentrantLock, Anda memerlukan kumpulan formulir: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ConcurrentMap&lt;String, ReentrantLock&gt; locks;</code> </pre> <br>  dan kemudian: <br><br><pre> <code class="java hljs">Client client = clientRepository.findByClientId(clientId); <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   ReentrantLock lock = locks.computeIfAbsent(clientId, (k) -&gt; new ReentrantLock()); lock.lock(); try{ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } finally { //   lock.unlock(); } }</span></span></code> </pre><br>  Satu-satunya masalah adalah manajemen "basi" clientId, dapat diselesaikan dengan menggunakan implementasi ConcurrentMap yang tidak standar, yang sudah mendukung kedaluwarsa, misalnya, ambil jambu Cache: <br><br><pre> <code class="java hljs">locks = CacheBuilder.newBuilder() .concurrencyLevel(<span class="hljs-number"><span class="hljs-number">4</span></span>) .expireAfterWrite(Duration.ofMinutes(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .&lt;String, ReentrantLock&gt;build().asMap();</code> </pre><br><h3>  Keputusan 4 </h3><br>  Solusi di atas menyinkronkan permintaan dalam satu instance.  Apa yang harus dilakukan jika layanan Anda berputar pada N node dan permintaan dapat langsung berbeda?  Untuk situasi ini, menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redisson</a> sempurna sebagai solusi: <br><br><pre> <code class="java hljs"> Client client = clientRepository.findByClientId(clientId); <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   RLock lock = redissonClient.getFairLock(clientId); lock.lock(); try{ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } finally { //   lock.unlock(); } }</span></span></code> </pre><br>  Perpustakaan memecahkan masalah kunci terdistribusi menggunakan redis sebagai repositori. <br><br><h2>  Kesimpulan </h2><br>  Keputusan mana untuk menerapkan tentu tergantung pada skala masalah: solusi 1-3 cukup cocok untuk layanan kecil satu contoh, solusi 4 ditujukan untuk layanan terdistribusi.  Perlu juga dicatat secara terpisah bahwa penyelesaian masalah ini menggunakan Redisson atau analog (misalnya, Zookeeper klasik), tentu saja, merupakan kasus khusus, karena mereka dirancang untuk berbagai tugas yang jauh lebih besar untuk sistem terdistribusi. <br><br>  Dalam kasus kami, kami memilih solusi 4, karena layanan kami didistribusikan dan integrasi Redisson adalah yang paling mudah dibandingkan dengan analog. <br><br>  Teman, sarankan di komentar opsi Anda untuk memecahkan masalah ini, saya akan sangat senang! <br>  Kode sumber untuk contoh tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br>  Omong-omong, kami terus memperluas staf pengembangan, lowongan yang relevan dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman karir</a> kami. <br><br><h3>  UPD 1. Solusi dari pembaca 1 </h3><br>  Solusi ini mengusulkan untuk tidak menyinkronkan permintaan, tetapi jika terjadi kesalahan pada formulir: <br><blockquote>  pelanggaran integritas integritas: kendala unik atau pelanggaran indeks;  Tabel UK_BFJDOY2DPUSSYLQ7G1S3S1TN8: CLIENT </blockquote><br>  harus diproses dan dipanggil kembali <br><pre> <code class="java hljs">client = clientRepository.findByClientId(clientId);</code> </pre><br>  atau melakukannya melalui pegas coba: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retryable</span></span>(value = { SQLException.class }, maxAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span>, backoff = <span class="hljs-meta"><span class="hljs-meta">@Backoff</span></span>(delay = <span class="hljs-number"><span class="hljs-number">1000</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Client </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String clientId)</span></span></span></span></code> </pre><br>  (terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Throwable</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> ) <br>  Dalam hal ini, akan ada pertanyaan "ekstra" ke basis data, tetapi dalam praktiknya penciptaan entitas Klien tidak akan sering terjadi, dan jika sinkronisasi hanya diperlukan untuk menyelesaikan masalah memasukkan ke dalam basis data, maka solusi ini dapat ditiadakan. <br><br><h3>  UPD 2. Solusi dari pembaca 2 </h3><br>  Solusi ini mengusulkan untuk melakukan sinkronisasi melalui sesi: <br><pre> <code class="java hljs">HttpSession session = request.getSession(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (session != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Object mutex = WebUtils.getSessionMutex(session); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (mutex) { ... } }</code> </pre><br>  Solusi ini akan berfungsi untuk layanan satu contoh, tetapi akan perlu untuk menyelesaikan masalah sehingga semua permintaan dari satu klien ke API dilakukan dalam sesi yang sama. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434714/">https://habr.com/ru/post/id434714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434704/index.html">Alasan penurunan biaya lalu lintas seluler di Rusia dan perkiraan untuk 2019</a></li>
<li><a href="../id434706/index.html">UDB. Apa ini Bagian 3. Datapath FIFO</a></li>
<li><a href="../id434708/index.html">HL 2018. Ringkasan laporan “Buat kata sandi hebat lagi! Cara mengalahkan brute force dan meninggalkan peretas tanpa apa-apa ”</a></li>
<li><a href="../id434710/index.html">RUVDS blog di Habr: tahun dalam tiga</a></li>
<li><a href="../id434712/index.html">Tes Turing Ketiga dalam bahasa Rusia</a></li>
<li><a href="../id434716/index.html">Pindah ke pusat data: Persiapan</a></li>
<li><a href="../id434718/index.html">Dua tahun kemudian, saya masih merindukan jack headphone</a></li>
<li><a href="../id434720/index.html">Sisi sebaliknya dari pengetahuan nol: pintu belakang di zk-SNARK yang tidak dapat dideteksi</a></li>
<li><a href="../id434722/index.html">Nyeri, pil, dan dua ambulans, atau Bagaimana kami semua naik ke posisi kelima IronStar 226 di Sochi</a></li>
<li><a href="../id434724/index.html">Petani Cina membuat streaming langsung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>