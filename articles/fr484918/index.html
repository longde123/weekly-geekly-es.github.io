<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∫ üôÄ üìΩÔ∏è Processus d'annotation incr√©mentielle pour acc√©l√©rer les constructions Gradle üîÆ üíú üöñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä partir des versions Gradle 4.7 et Kotlin 1.3.30, il est devenu possible d'obtenir un assemblage incr√©mentiel acc√©l√©r√© des projets gr√¢ce au bon fonct...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Processus d'annotation incr√©mentielle pour acc√©l√©rer les constructions Gradle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/484918/"><p><img src="https://habrastorage.org/webt/ne/dq/wg/nedqwgztbpmabplkbivfwi8gx9s.jpeg" alt="image"></p><br><p>  √Ä partir des versions Gradle 4.7 et Kotlin 1.3.30, il est devenu possible d'obtenir un assemblage incr√©mentiel acc√©l√©r√© des projets gr√¢ce au bon fonctionnement du traitement incr√©mentiel des annotations.  Dans cet article, nous comprenons comment la th√©orie de la compilation incr√©mentielle dans Gradle fonctionne en th√©orie, ce qui doit √™tre fait pour lib√©rer son plein potentiel (sans perdre la g√©n√©ration de code en m√™me temps), et quel type d'augmentation de la vitesse des assemblages incr√©mentiels peut √™tre r√©alis√© par l'activation du traitement incr√©mentiel des annotations dans la pratique. </p><a name="habracut"></a><br><h2 id="kak-rabotaet-inkrementalnaya-kompilyaciya">  Fonctionnement de la compilation incr√©mentielle </h2><br><p>  Les versions incr√©mentielles de Gradle sont impl√©ment√©es √† deux niveaux.  Le premier niveau consiste √† annuler le d√©marrage des modules de recompilation √† l'aide de l' <a href="https://docs.gradle.org/current/userguide/java_plugin.html">√©vitement de la compilation</a> .  La seconde est une compilation incr√©mentielle directe, d√©marrant le compilateur dans le cadre d'un module uniquement sur les fichiers qui ont chang√© ou qui d√©pendent directement des fichiers modifi√©s. </p><br><p>  Consid√©rons l'√©vitement de la compilation sur un exemple (extrait d'un <a href="https://blog.gradle.org/incremental-compiler-avoidance">article</a> de Gradle) d'un projet de trois modules: <strong>app</strong> , <strong>core</strong> et <strong>utils</strong> . </p><br><p>  La classe principale du module d' <strong>application</strong> (d√©pend du <strong>noyau</strong> ): </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ WordCount wc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordCount(); wc.collect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); System.out.println(<span class="hljs-string"><span class="hljs-string">"Word count: "</span></span> + wc.wordCount()); } }</code> </pre> <br><p>  Dans le module de <strong>base</strong> (d√©pend des <strong>utils</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordCount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... void collect(File source) { IOUtils.eachLine(source, WordCount::collectLine); } }</span></span></code> </pre> <br><p>  Dans le module <strong>utils</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eachLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Callable&lt;String&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (BufferedReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(file))) { <span class="hljs-comment"><span class="hljs-comment">// ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  L'ordre de la premi√®re compilation des modules est le suivant (conform√©ment √† l'ordre des d√©pendances): </p><br><p>  1) <strong>utils</strong> <br>  2) <strong>noyau</strong> <br>  3) l' <strong>application</strong> </p><br><p>  Consid√©rez maintenant ce qui se passe lorsque vous modifiez l'impl√©mentation interne de la classe IOUtils: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// IOUtils lives in project `utils` void eachLine(File file, Callable&lt;String&gt; action) { try { try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "utf-8") )) { // ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  Cette modification n'affecte pas le module ABI.  ABI (Application Binary Interface) est une repr√©sentation binaire de l'interface publique du module assembl√©.  Dans le cas o√π le changement ne concerne que l'impl√©mentation interne du module et n'affecte en rien son interface publique, Gradle utilisera l'√©vitement de la compilation et commencera la recompilation uniquement du module <strong>utils</strong> .  Si l'ABI du module <strong>utils</strong> est affect√© (par exemple, une m√©thode publique suppl√©mentaire appara√Æt ou la signature de la m√©thode existante change), alors la compilation du module <strong>principal</strong> d√©marrera √©galement, mais le module d' <strong>application</strong> d√©pendant du <strong>c≈ìur</strong> ne sera pas recompil√© de mani√®re transitoire si la d√©pendance en elle est connect√©e via l' <a href="https://medium.com/mindorks/implementation-vs-api-in-gradle-3-0-494c817a6fa">impl√©mentation</a> . </p><br><p><img src="https://habrastorage.org/webt/io/pv/b-/iopvb-pf4b-fzrwksogs3ydsuzk.png"><br>  <em>Illustration de l'√©vitement de la compilation au niveau du module de projet</em> </p><br><p>  Le deuxi√®me niveau d'incr√©ment est l'incr√©ment au niveau du lancement du compilateur pour les fichiers modifi√©s directement √† l'int√©rieur des modules individuels. </p><br><p>  Par exemple, ajoutez une nouvelle classe au module <strong>principal</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NGrams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NGrams lives in project `core` // ... void collect(String source, int ngramLength) { collectInternal(StringUtils.sanitize(source), ngramLength); } // ... }</span></span></code> </pre> <br><p>  Et en <strong>utils</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanitize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String dirtyString)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  Dans ce cas, dans les deux modules, seuls deux nouveaux fichiers doivent √™tre recompil√©s (sans affecter les WordCount et IOUtils existants et inchang√©s), car il n'y a pas de d√©pendances entre les nouvelles et les anciennes classes. </p><br><p>  Ainsi, le compilateur incr√©mentiel analyse uniquement les d√©pendances entre les classes et recompile: </p><br><ul><li>  classes contenant des modifications </li><li><p>  classes qui d√©pendent directement des classes changeantes </p><br><h2 id="inkrementalnyy-annotation-processing">  Traitement d'annotations incr√©mentielles </h2><br><p><img src="https://habrastorage.org/webt/qd/qy/c1/qdqyc14pw7rak4d89dgft7oylus.png" alt="entrez la description de l'image ici"></p><br></li></ul><br><p>  La g√©n√©ration de code √† l'aide d'APT et de KAPT r√©duit le temps n√©cessaire pour √©crire et d√©boguer du code passe-partout, mais le traitement des annotations peut augmenter consid√©rablement le temps de g√©n√©ration.  Pour aggraver les choses, pendant longtemps, le traitement des annotations a fondamentalement rompu les possibilit√©s de compilation incr√©mentielle dans Gradle. </p><br><p>  Chaque processeur d'annotations d'un projet indique au compilateur des informations sur la liste des annotations qu'il traite.  Mais du point de vue de l'assemblage, le traitement des annotations est une bo√Æte noire: Gradle ne sait pas ce que le processeur va faire, en particulier, quels fichiers il va g√©n√©rer et o√π.  Jusqu'√† Gradle 4.7, la compilation incr√©mentielle √©tait automatiquement d√©sactiv√©e sur les ensembles source o√π les processeurs d'annotation √©taient utilis√©s. </p><br><p>  Avec la <a href="https://docs.gradle.org/4.7/userguide/java_plugin.html">sortie de</a> Gradle 4.7, la compilation incr√©mentielle prend d√©sormais en charge le traitement des annotations, mais uniquement pour APT.  Dans KAPT, la prise en charge des annotations incr√©mentielles a √©t√© <a href="https://blog.jetbrains.com/kotlin/2019/04/kotlin-1-3-30-released/">introduite</a> avec Kotlin 1.3.30.  Il n√©cessite √©galement le <a href="https://docs.gradle.org/current/userguide/java_plugin.html">support</a> des biblioth√®ques qui fournissent des processeurs d'annotation.  Les d√©veloppeurs de processeurs d'annotations ont la possibilit√© de d√©finir explicitement la cat√©gorie de processeurs, informant ainsi Gradle des informations n√©cessaires au fonctionnement de la compilation incr√©mentielle. </p><br><h2 id="kategorii-processorov-annotaciy">  Cat√©gories de processeurs d'annotation </h2><br><p>  Gradle prend en charge deux cat√©gories de processeurs: </p><br><p>  <strong>Isolement</strong> - ces processeurs doivent prendre toutes les d√©cisions pour la g√©n√©ration de code en se basant uniquement sur les informations d' <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">AST</a> associ√©es √† un √©l√©ment d'une annotation particuli√®re.  Il s'agit de la cat√©gorie la plus rapide de processeurs d'annotation, car Gradle peut ne pas red√©marrer le processeur et utiliser les fichiers qu'il a pr√©c√©demment g√©n√©r√©s s'il n'y a eu aucune modification dans le fichier source. </p><br><p>  <strong>Agr√©gation</strong> - utilis√©e pour les processeurs qui prennent des d√©cisions sur la base de plusieurs entr√©es (par exemple, l'analyse des annotations dans plusieurs fichiers √† la fois ou sur la base de l'√©tude de l'AST, qui est accessible de mani√®re transitoire √† partir d'un √©l√©ment annot√©).  √Ä chaque fois, Gradle d√©marrera le processeur pour les fichiers qui utilisent des annotations du processeur d'agr√©gation, mais ne recompilera pas les fichiers qu'il g√©n√®re s'il n'y a aucune modification. </p><br><p>  Pour de nombreuses biblioth√®ques populaires bas√©es sur la g√©n√©ration de code, la prise en charge de la compilation incr√©mentielle est d√©j√† impl√©ment√©e dans les derni√®res versions.  Consultez la liste des biblioth√®ques qui le prennent en charge <a href="https://docs.gradle.org/current/userguide/java_plugin.html">ici</a> . </p><br><h2 id="nash-opyt-vnedreniya-incremental-annotation-processing">  Notre exp√©rience dans la mise en ≈ìuvre du traitement d'annotations incr√©mentielles </h2><br><p>  D√©sormais, pour les projets qui partent de z√©ro et utilisent les derni√®res versions des biblioth√®ques et des plugins Gradle, les builds incr√©mentiels sont plus susceptibles d'√™tre actifs par d√©faut.  Mais la plus grande part de l'augmentation de la productivit√© de l'assemblage peut √™tre obtenue gr√¢ce √† l'incr√©mentalit√© du traitement des annotations sur les projets de grande taille et de longue dur√©e.  Dans ce cas, une mise √† jour massive de la version peut √™tre requise.  Est-ce que cela en vaut la peine dans la pratique?  Voyons voir! </p><br><p>  Donc, pour que le traitement incr√©mentiel des annotations fonctionne, nous avons besoin de: </p><br><ul><li>  Gradle 4.7+ </li><li>  Kotlin 1.3.30+ </li><li>  Tous les processeurs d'annotation de notre projet doivent avoir son support.  Ceci est tr√®s important, car si dans un seul module au moins un processeur ne prend pas en charge l'incr√©mentalit√©, Gradle le d√©sactivera pour l'ensemble du module.  Tous les fichiers du module seront √† nouveau compil√©s √† chaque fois!  L'une des options alternatives pour obtenir la prise en charge de la compilation incr√©mentielle sans mettre √† niveau les versions est la suppression de tout le code √† l'aide de processeurs d'annotation dans un module distinct.  Dans les modules qui n'ont pas de processeurs d'annotation, la compilation incr√©mentielle fonctionnera correctement </li></ul><br><p>  Afin de d√©tecter les processeurs qui ne remplissent pas la derni√®re condition, vous pouvez ex√©cuter l'assembly avec l'indicateur <em>-Pkapt.verbose = true</em> .  Si Gradle a √©t√© forc√© de d√©sactiver le traitement d'annotations incr√©mentielles pour un seul module, alors dans le journal de construction, nous verrons un message sur quels processeurs et dans quels modules cela se produit (voir le nom de la t√¢che): </p><br><pre> <code class="plaintext hljs">&gt; Task :common:kaptDebugKotlin w: [kapt] Incremental annotation processing requested, but support is disabled because the following processors are not incremental: toothpick.compiler.factory.FactoryProcessor (NON_INCREMENTAL), toothpick.compiler.memberinjector.MemberInjectorProcessor (NON_INCREMENTAL).</code> </pre> <br><p>  Sur notre projet de biblioth√®que avec des processeurs d'annotation non incr√©mentiels, il y en avait 3: </p><br><ul><li>  Cure-dent </li><li>  Pi√®ce </li><li>  PermissionsDispatcher </li></ul><br><p>  Heureusement, ces biblioth√®ques sont activement prises en charge et leurs derni√®res versions prennent d√©j√† en charge l'incr√©mentalit√©.  De plus, tous les processeurs d'annotation des derni√®res versions de ces biblioth√®ques ont une cat√©gorie optimale - isolement.  Dans le processus d'augmentation des versions, j'ai d√ª faire face √† une refactorisation en raison de changements dans l'API de la biblioth√®que Toothpick, qui ont affect√© presque tous nos modules.  Mais dans ce cas, nous avons eu de la chance, et il s'est av√©r√© que le refactoring √©tait enti√®rement automatique en utilisant les noms de remplacement automatique des m√©thodes de biblioth√®que publique utilis√©es. </p><br><p>  Notez que si vous utilisez la biblioth√®que Room, vous devrez passer explicitement l' <em>indicateur room.incremental: true</em> au processeur d'annotation.  <a href="https://developer.android.com/jetpack/androidx/releases/room">Un exemple</a> .  √Ä l'avenir, les d√©veloppeurs de Room <a href="https://developer.android.com/jetpack/androidx/releases/room">pr√©voient</a> d'activer ce drapeau par d√©faut. </p><br><p>  Pour les versions de Kotlin 1.3.30-1.3.50, vous devez activer <strong>explicitement la</strong> prise en charge du traitement incr√©mentiel des annotations via <em>kapt.incremental.apt = true</em> dans le fichier gradle.properties du projet.  √Ä partir de la version 1.3.50, cette option est d√©finie sur true par d√©faut. </p><br><h2 id="profayling-inkrementalnyh-sborok">  Profilage d'assemblage incr√©mentiel </h2><br><p>  Une fois les versions de toutes les d√©pendances n√©cessaires augment√©es, il est temps de tester la vitesse des g√©n√©rations incr√©mentielles.  Pour ce faire, nous avons utilis√© l'ensemble d'outils et de techniques suivant: </p><br><ul><li>  <a href="https://guides.gradle.org/creating-build-scans/">Scan de construction Gradle</a> </li><li>  <a href="https://github.com/gradle/gradle-profiler">gradle-profiler</a> </li><li>  Pour ex√©cuter des scripts avec un traitement d'annotation incr√©mentiel activ√© et d√©sactiv√©, la propri√©t√© <em>gradle kapt.incremental.apt = [true | false] a √©t√© utilis√©e</em> </li><li>  Pour des r√©sultats coh√©rents et informatifs, les assemblages ont √©t√© cr√©√©s dans un environnement CI s√©par√©.  L'incr√©mentalit√© de build a √©t√© reproduite √† l'aide de gradle-profiler </li></ul><br><p>  gradle-profiler permet de pr√©parer de mani√®re d√©clarative des <a href="https://github.com/gradle/gradle-profiler">scripts</a> pour des benchmarks de construction incr√©mentiels.  4 sc√©narios ont √©t√© compil√©s sur la base des conditions suivantes: </p><br><ul><li>  La modification d'un fichier affecte / n'affecte pas son ABI </li><li>  Prise en charge du traitement d'annotations incr√©mentielles activ√© / d√©sactiv√© </li></ul><br><p>  L'ex√©cution de chacun des sc√©narios est une s√©quence de: </p><br><ul><li>  Red√©marrer le d√©mon gradle </li><li>  Lancer des builds d'√©chauffement </li><li>  Ex√©cutez 10 assemblys incr√©mentiels, avant chacun desquels un fichier est modifi√© en ajoutant une nouvelle m√©thode (priv√©e pour les modifications non ABI et publique pour les modifications ABI) </li></ul><br><p>  Toutes les versions ont √©t√© r√©alis√©es avec Gradle 5.4.1.  Le fichier impliqu√© dans les modifications fait r√©f√©rence √† l'un des modules de base du projet (commun), dont 40 modules (y compris le noyau et la fonctionnalit√©) sont directement d√©pendants.  Ce fichier utilise l'annotation pour isoler le processeur. </p><br><p>  Il convient √©galement de noter que l'analyse comparative a √©t√© effectu√©e sur deux t√¢ches <em>gradle</em> : <em>ompileDebugSources</em> et <em>assembleDebug</em> .  Le premier ne d√©marre que la compilation des fichiers avec le code source, sans travailler avec les ressources et regrouper l'application dans un fichier .apk.  Sur la base du fait que la compilation incr√©mentielle affecte uniquement les fichiers .kt et .java, la t√¢che <em>compileDedugSource a</em> √©t√© choisie pour une analyse comparative plus isol√©e et plus rapide.  Dans des conditions de d√©veloppement r√©elles, lorsque vous red√©marrez l'application, Android Studio utilise la t√¢che <em>assembleDebug</em> , qui inclut la g√©n√©ration compl√®te de la version de d√©bogage de l'application. </p><br><h2 id="rezultaty-benchmarkov">  R√©sultats de r√©f√©rence </h2><br><p>  Dans tous les graphiques g√©n√©r√©s par gradle-profiler, l'axe vertical affiche le temps d'assemblage incr√©mentiel en millisecondes et l'axe horizontal indique le num√©ro de d√©but de l'assemblage. </p><br><h3 id="compiledebugsource-do-obnovleniya-processorov-annotaciy">  : compileDebugSource avant de mettre √† jour les processeurs d'annotation </h3><br><p><img src="https://habrastorage.org/webt/mn/cd/jj/mncdjjla37vj8ogbycy0szzpj-e.png" alt="entrez la description de l'image ici"><br>  Le temps d'ex√©cution moyen de chaque sc√©nario √©tait de 38 secondes avant de mettre √† jour les processeurs d'annotation vers des versions qui prennent en charge l'incr√©mentalit√©.  Dans ce cas, Gradle d√©sactive la prise en charge de la compilation incr√©mentielle, il n'y a donc pas de diff√©rence significative entre les scripts. </p><br><h3 id="compiledebugsource-posle-obnovleniya-processorov-annotaciy">  : compileDebugSource apr√®s la mise √† jour des processeurs d'annotation </h3><br><p><img src="https://habrastorage.org/webt/wk/fk/h1/wkfkh1e37r3jpagocxqbdi4twqk.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Sc√©nario </th><th>  Changement incr√©mentiel de l'ABI </th><th>  Changement ABI non incr√©mentiel </th><th>  Changement incr√©mentiel non ABI </th><th>  Changement non incr√©mentiel non abi </th></tr></thead><tbody><tr><td>  <strong>m√©chant</strong> </td><td>  23978 </td><td>  35370 </td><td>  23514 </td><td>  34602 </td></tr><tr><td>  <strong>m√©diane</strong> </td><td>  23879 </td><td>  35019 </td><td>  23424 </td><td>  34749 </td></tr><tr><td>  <strong>min</strong> </td><td>  22618 </td><td>  33969 </td><td>  22343 </td><td>  33292 </td></tr><tr><td>  <strong>max</strong> </td><td>  26820 </td><td>  38097 </td><td>  25651 </td><td>  35843 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  1193.29 </td><td>  1240.81 </td><td>  888,24 </td><td>  815,91 </td></tr></tbody></table></div><br><p>  La r√©duction m√©diane du temps d'assemblage due √† l'incr√©mentalit√© √©tait de 31% pour les changements ABI et de 32,5% pour les changements non ABI.  En valeur absolue, environ 10 secondes. </p><br><h3 id="assembledebug-posle-obnovleniya-processorov-annotaciy">  : assembleDebug apr√®s la mise √† jour des processeurs d'annotation </h3><br><p><img src="https://habrastorage.org/webt/fa/5h/qx/fa5hqxvowacrovlvmc12xard7_i.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Sc√©nario </th><th>  Changement incr√©mentiel de l'ABI </th><th>  Changement ABI non incr√©mentiel </th><th>  Changement incr√©mentiel non ABI </th><th>  Changement non incr√©mentiel non abi </th></tr></thead><tbody><tr><td>  <strong>m√©chant</strong> </td><td>  39902 </td><td>  49850 </td><td>  39005 </td><td>  52123 </td></tr><tr><td>  <strong>m√©diane</strong> </td><td>  38974 </td><td>  49691 </td><td>  38713 </td><td>  50336 </td></tr><tr><td>  <strong>min</strong> </td><td>  38563 </td><td>  48782 </td><td>  38233 </td><td>  48944 </td></tr><tr><td>  <strong>max</strong> </td><td>  48255 </td><td>  52364 </td><td>  41732 </td><td>  65941 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  2953.28 </td><td>  1011.20 </td><td>  1015,37 </td><td>  5039.11 </td></tr></tbody></table></div><br><p>  Pour g√©n√©rer la version de d√©bogage compl√®te de l'application sur notre projet, la diminution m√©diane du temps de g√©n√©ration en raison de l'incr√©ment √©tait de 21,5% pour les modifications ABI et de 23% pour les modifications non ABI.  En termes absolus, environ les m√™mes 10 secondes, car l'incr√©ment de compilation du code source n'affecte pas la vitesse d'assemblage des ressources. </p><br><h2 id="anatomiya-sborki-v-gradle-build-scan">  Build Scan Anatomy dans Gradle Build Scan </h2><br><p>  Pour une compr√©hension plus approfondie de la fa√ßon dont l'incr√©mentation a √©t√© obtenue lors de la compilation incr√©mentielle, nous comparons les analyses des assemblages incr√©mentiels et non incr√©mentiels. </p><br><p>  Dans le cas d'un incr√©ment KAPT d√©sactiv√©, la partie principale du temps de construction est la compilation du module d'application, qui ne peut pas √™tre mis en parall√®le avec d'autres t√¢ches.  Le calendrier pour KAPT non incr√©mentiel est le suivant: </p><br><p><img src="https://habrastorage.org/webt/r0/cw/_n/r0cw_n4xvp7olnharknhce--9fe.png" alt="entrez la description de l'image ici"></p><br><p>  Ex√©cution de la t√¢che: kaptDebugKotlin de notre module d'application prend environ 8 secondes dans ce cas. </p><br><p>  Chronologie du cas avec incr√©ment KAPT activ√©: </p><br><p><img src="https://habrastorage.org/webt/_u/xt/se/_uxtsee_4jt_g7oems5ggxbm3rg.png" alt="entrez la description de l'image ici"></p><br><p>  Maintenant, le module d'application a √©t√© recompil√© en moins d'une seconde.  Il convient de pr√™ter attention √† la disproportion visuelle des √©chelles des deux scans dans le picch ci-dessus.  Les t√¢ches qui semblent plus courtes dans la premi√®re image ne sont pas n√©cessairement plus longues dans la seconde, o√π elles semblent plus longues.  Mais il est tr√®s visible de voir combien la proportion de recompilation du module d'application a √©t√© r√©duite lorsque KAPT incr√©mentiel a √©t√© activ√©.  Dans notre cas, nous gagnons environ 8 secondes sur ce module et environ 2 secondes suppl√©mentaires sur les modules plus petits qui sont compil√©s en parall√®le. </p><br><p>  Dans le m√™me temps, le temps d'ex√©cution total de toutes les t√¢ches * kapt pour l'incr√©mentalit√© d√©sactiv√©e du traitement des annotations est de 1 minute et 36 secondes contre 55 secondes lorsqu'il est activ√©.  Autrement dit, sans tenir compte de l'assemblage parall√®le des modules, le gain est plus substantiel. </p><br><p>  Il convient √©galement de noter que les r√©sultats de r√©f√©rence ci-dessus ont √©t√© pr√©par√©s sur un environnement CI avec la possibilit√© d'ex√©cuter 24 threads parall√®les pour l'assemblage.  Dans un environnement √† 8 threads, le gain de l'activation du traitement d'annotations incr√©mentielles est d'environ 20-30 secondes sur notre projet. </p><br><h2 id="incremental-vs--parallel">  Incr√©mental vs (?) Parall√®le </h2><br><p>  Une autre fa√ßon d'acc√©l√©rer consid√©rablement l'assemblage (√† la fois incr√©mentiel et propre) consiste √† effectuer des t√¢ches gradles en parall√®le en divisant le projet en un grand nombre de modules √† couplage l√¢che.  D'une mani√®re ou d'une autre, la modularisation repr√©sente un potentiel d'acc√©l√©ration des assemblages beaucoup plus important que l'utilisation de KAPT incr√©mentiel.  Mais plus le projet est monolithique et plus la g√©n√©ration de code y est utilis√©e, plus le traitement incr√©mentiel des annotations sera important.  Il est plus facile d'obtenir l'effet d'une incr√©mentalit√© compl√®te des assemblages que de diviser une application en modules.  N√©anmoins, les deux approches ne se contredisent pas et se compl√®tent parfaitement. </p><br><h2 id="itog">  R√©sum√© </h2><br><ul><li>  L'inclusion du traitement incr√©mentiel des annotations sur notre projet nous a permis d'atteindre une augmentation de 20% de la vitesse de reconstruction locale </li><li>  Pour activer le traitement d'annotations incr√©mentielles, il sera utile d'√©tudier le journal complet des assemblys actuels et de rechercher des messages d'avertissement avec le texte "Traitement d'annotations incr√©mentielles demand√©, mais la prise en charge est d√©sactiv√©e car les processeurs suivants ne sont pas incr√©mentiels ...".  Il est n√©cessaire de mettre √† niveau les versions des biblioth√®ques vers des versions prenant en charge le traitement incr√©mentiel des annotations et de disposer des versions Gradle 4.7+, Kotlin 1.3.30+ </li></ul><br><h3 id="materialy-i-chto-pochitat-po-teme">  Mat√©riel et √©l√©ments √† lire sur le sujet </h3><br><ul><li>  <a href="https://docs.gradle.org/6.0.1/userguide/java_plugin.html">√Ä propos de la prise en charge du traitement des annotations incr√©mentielles au niveau du plug-in Java Gradle</a> </li><li>  <a href="https://medium.com/andrews-tech-blog/the-gradle-profiler-part-1-introduction-bdcbe70efe08">Article sur gradle-profiler</a> </li><li>  <a href="https://kotlinlang.org/docs/reference/kapt.html">Plus d'informations sur les fonctionnalit√©s KAPT</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DsQC9-Rj2yLI">Rapport sur Google I / O 2019 avec les astuces d'acc√©l√©ration de construction actuelles</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3D7ll-rkLCtyk">Un autre rapport sur Gradle Optimization sur Google I / O 2017, inclut du mat√©riel de construction incr√©mentiel et l'√©vitement de la compilation</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484918/">https://habr.com/ru/post/fr484918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484902/index.html">Sur les √©quations de degr√©s sup√©rieurs</a></li>
<li><a href="../fr484904/index.html">Une ann√©e sans Splunk - comment une entreprise am√©ricaine a chang√© le march√© de l'analyse des donn√©es machine en Russie et qu'elle a laiss√© derri√®re</a></li>
<li><a href="../fr484906/index.html">√âquipe distribu√©e et chef d'√©quipe √† distance</a></li>
<li><a href="../fr484908/index.html">HighLoad ++, Eugene Kuzovlev (EcommPay IT): que faire quand une minute d'arr√™t co√ªte 100 000 $</a></li>
<li><a href="../fr484910/index.html">Paul Graham: Haters</a></li>
<li><a href="../fr484920/index.html">Comment comprendre que vous √™tes op√©rateur de fraiseuse?</a></li>
<li><a href="../fr484930/index.html">Faisons du fastcode comme des professionnels</a></li>
<li><a href="../fr484932/index.html">La double nature des exigences logicielles</a></li>
<li><a href="../fr484934/index.html">Du d√©veloppement personnel √† Agile sur une √©chelle XXXL en deux jours chez TeamLead Conf</a></li>
<li><a href="../fr484936/index.html">Connaissances et comp√©tences dans l'√©quipe: trouver, voir, pomper</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>