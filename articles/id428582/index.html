<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🃏 ↗️ ⚾️ Sejarah OOP yang Terlupakan 🆗 🌞 👡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebagian besar paradigma pemrograman yang kita gunakan saat ini pertama kali dipelajari secara matematis pada 1930-an menggunakan ide-ide kalkulus lam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sejarah OOP yang Terlupakan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428582/"> Sebagian besar paradigma pemrograman yang kita gunakan saat ini pertama kali dipelajari secara matematis pada 1930-an menggunakan ide-ide kalkulus lambda dan mesin Turing, yang merupakan varian dari model komputasi universal (ini adalah sistem formal yang dapat melakukan perhitungan tujuan umum).  Tesis Church-Turing menunjukkan bahwa kalkulus lambda dan mesin Turing secara fungsional setara.  Yaitu, kita berbicara tentang fakta bahwa segala sesuatu yang dapat dihitung menggunakan mesin Turing juga dapat dihitung menggunakan lambda calculus, dan sebaliknya. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/hq/so/jp/hqsojpds8ed1zxx9g7lelnfknbu.jpeg"></a> <br><a name="habracut"></a><br>  Ada kesalahpahaman umum bahwa mesin Turing dapat menghitung semua yang dapat dihitung.  Ada kelas masalah (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah berhenti</a> ) yang dapat dihitung menggunakan mesin Turing hanya untuk beberapa kasus.  Ketika kata "computably" digunakan dalam teks ini, itu berarti "computably oleh mesin Turing". <br><br>  Kalkulus Lambda menunjukkan pendekatan penerapan fungsi untuk perhitungan secara top-down.  Mesin Turing tape adalah pendekatan imperatif (langkah-demi-langkah) untuk komputasi, yang diterapkan berdasarkan bottom-up. <br><br>  Bahasa pemrograman tingkat rendah, seperti kode mesin atau assembler, muncul pada 1940-an, dan, pada akhir 1950-an, bahasa tingkat tinggi populer pertama muncul yang menerapkan pendekatan fungsional dan imperatif.  Jadi, dialek bahasa Lisp masih banyak digunakan, di antaranya Clojure, Skema, AutoLisp dan sebagainya.  Pada tahun lima puluhan, bahasa seperti FORTRAN dan COBOL muncul.  Mereka adalah contoh dari bahasa tingkat tinggi yang sangat penting yang masih hidup.  Meskipun harus dicatat bahwa bahasa keluarga C, di sebagian besar wilayah, menggantikan COBOL dan FORTRAN. <br><br>  Akar pemrograman imperatif dan fungsional terletak pada matematika formal komputasi, mereka muncul di depan komputer digital.  Pemrograman Berorientasi Objek (OOP) datang kemudian, itu berasal dari revolusi pemrograman struktural yang terjadi pada tahun enam puluhan dan tujuh puluhan abad terakhir. <br><br>  Objek pertama yang saya tahu digunakan oleh Ivan Sutherland dalam aplikasi yang ditakdirkan Sketchpad, dibuat antara 1961 dan 1962, yang ia gambarkan dalam karya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> pada 1963.  Objek adalah karakter grafis yang ditampilkan pada layar osiloskop (mungkin ini adalah pertama kalinya dalam sejarah menggunakan monitor komputer grafis) yang mendukung warisan melalui delegasi dinamis, yang disebut Ivan Sutherland sebagai "tuan" dalam karyanya.  Objek apa pun bisa menjadi objek master, instance tambahan objek itu disebut "kejadian".  Ini membuat sistem Sketchpad menjadi pemilik yang pertama dari bahasa pemrograman terkenal yang menerapkan pewarisan prototipe. <br><br>  Bahasa pemrograman pertama, umumnya dikenal sebagai "berorientasi objek," adalah bahasa Simula, yang spesifikasinya dikembangkan pada tahun 1965.  Seperti Sketchpad, Silmula disediakan untuk bekerja dengan objek, tetapi juga termasuk kelas, pewarisan berbasis kelas, subkelas, dan metode virtual. <br><br>  <i><font color="#999999">Metode virtual adalah metode yang didefinisikan dalam kelas yang dirancang untuk didefinisikan ulang oleh subclass.</font></i>  <i><font color="#999999">Metode virtual memungkinkan program untuk memanggil metode yang mungkin tidak ada pada saat kode dikompilasi, dengan menggunakan pengiriman dinamis untuk menentukan metode tertentu yang harus dipanggil selama eksekusi program.</font></i>  <i><font color="#999999">JavaScript memiliki tipe dinamis dan menggunakan rantai delegasi untuk menentukan metode mana yang harus dipanggil. Akibatnya, bahasa ini tidak perlu memperkenalkan konsep metode virtual kepada pemrogram.</font></i>  <i><font color="#999999">Dengan kata lain, semua metode dalam JavaScript menggunakan pengiriman pada saat run-time, akibatnya, metode dalam JavaScript tidak perlu dinyatakan "virtual" untuk mendukung fitur ini.</font></i> <br><br><h2>  <font color="#3AC1EF">Opini ayah OOP tentang OOP</font> </h2><br>  <i><font color="#999999">"Saya menciptakan istilah" berorientasi objek, "dan saya dapat mengatakan bahwa saya tidak bermaksud C ++."</font></i>  <i><font color="#999999">Alan Kay, Konferensi OOPSLA, 1997.</font></i> <br><br>  Alan Kay menciptakan istilah "pemrograman berorientasi objek", mengacu pada bahasa pemrograman Smalltalk (1972).  Bahasa ini dikembangkan oleh Alan Kay, Dan Ingles dan karyawan lain dari Xerox PARC Research Center sebagai bagian dari proyek perangkat Dynabook.  Smalltalk lebih berorientasi objek daripada Simula.  Dalam Smalltalk, semuanya adalah objek, termasuk kelas, bilangan bulat, dan blok (penutup).  Implementasi awal bahasa, Smalltalk-72, tidak memiliki kemampuan untuk subkelas.  Fitur ini muncul di Smalltalk-76. <br><br>  Sementara Smalltalk mendukung kelas-kelas, dan, sebagai akibatnya, subclassing, Smalltalk tidak menempatkan ide-ide ini di garis depan.  Itu adalah bahasa fungsional yang dipengaruhi Lisp seperti halnya Simula.  Menurut Alan Kay, memperlakukan kelas sebagai mekanisme penggunaan kembali kode adalah sebuah kesalahan.  Industri pemrograman menaruh perhatian besar pada penciptaan subclass, mengalihkan dari manfaat nyata pemrograman berorientasi objek. <br><br>  JavaScript dan Smalltalk memiliki banyak kesamaan.  Saya akan mengatakan bahwa JavaScript adalah pembalasan Smalltalk di dunia karena salah paham konsep OOP.  Kedua bahasa ini mendukung fitur berikut: <br><br><ul><li>  Benda </li><li>  Fungsi dan penutupan kelas satu. </li><li>  Tipe dinamis. </li><li>  Mengikat terlambat (fungsi dan metode dapat diganti selama eksekusi program). </li><li>  OOP tanpa sistem pewarisan berbasis kelas. </li></ul><br>  <i><font color="#999999">"Saya menyesal telah menemukan istilah" objek "sejak lama untuk fenomena ini, karena penggunaannya mengarah pada fakta bahwa banyak orang memberikan kepentingan utama pada sebuah ide yang tidak sepenting yang utama.</font></i>  <i><font color="#999999">Ide utamanya adalah perpesanan. ”</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">korespondensi</a> email 2003, Alan Kay mengklarifikasi apa yang ada dalam pikirannya ketika dia menyebut Smalltalk "bahasa berorientasi objek." <br><br>  <i><font color="#999999">"Bagi saya, OOP hanya berarti pengiriman pesan, penyimpanan lokal, dan perlindungan, dan status persembunyian, dan sangat terlambat mengikat."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Dengan kata lain, sesuai dengan ide-ide Alan Kay, bahan OOP yang paling penting adalah sebagai berikut: <br><br><ul><li>  Olahpesan </li><li>  Enkapsulasi. </li><li>  Tautan dinamis. </li></ul><br>  Penting untuk dicatat bahwa Alan Kay, orang yang menemukan istilah "OOP" dan membawanya ke massa, tidak menganggap warisan dan polimorfisme sebagai komponen terpenting dari OOP. <br><br><h2>  <font color="#3AC1EF">Inti dari OOP</font> </h2><br>  Kombinasi perpesanan dan enkapsulasi memiliki beberapa tujuan penting: <br><br><ul><li>  Menghindari keadaan yang dapat diubah bersama dari suatu objek dengan mengenkapsulasi keadaan dan mengisolasi objek lain dari perubahan lokal di negaranya.  Satu-satunya cara untuk mempengaruhi keadaan objek lain adalah memintanya (alih-alih memberinya perintah) untuk berubah dengan mengiriminya pesan.  Perubahan status dipantau di tingkat lokal, seluler, status tidak tersedia untuk objek lain. </li><li>  Pemisahan objek dari satu sama lain.  Pengirim pesan secara longgar digabungkan ke penerima melalui API perpesanan. </li><li>  Adaptasi dan resistensi terhadap perubahan selama pelaksanaan program melalui ikatan yang terlambat.  Beradaptasi dengan perubahan selama eksekusi program menawarkan banyak keuntungan signifikan, yang menurut Alan Kay sangat penting bagi OOP. </li></ul><br>  Sumber inspirasi untuk Alan Kay, yang mengungkapkan ide-ide ini, adalah pengetahuannya tentang biologi, dan apa yang ia ketahui tentang ARPANET (ini adalah versi awal dari Internet).  Yaitu, kita berbicara tentang sel biologis dan tentang komputer individu yang terhubung ke jaringan.  Bahkan kemudian, Alan Kay membayangkan bagaimana program berjalan pada komputer besar yang terdistribusi (Internet), sementara komputer individu bertindak sebagai sel biologis, bekerja secara independen dengan keadaan terisolasi mereka sendiri dan bertukar data dengan komputer lain dengan mengirim pesan. <br><br>  <i><font color="#999999">"Saya menyadari bahwa metafora untuk sebuah sel atau komputer akan membantu menyingkirkan data [...]."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Mengatakan "tolong singkirkan data", Alan Kay, tentu saja, sadar akan masalah yang disebabkan oleh keadaan yang bisa berubah bersama, dan konektivitas yang kuat yang disebabkan oleh berbagi data.  Hari ini, topik ini banyak didengar.  Tetapi pada akhir 1960-an, programmer ARPANET tidak senang dengan kebutuhan untuk memilih representasi model data untuk program mereka sebelum mengembangkan program.  Pengembang ingin melepaskan diri dari praktik ini, karena, sebelumnya mengarahkan diri mereka ke dalam kerangka kerja yang ditentukan oleh penyajian data, lebih sulit untuk mengubah sesuatu di masa depan. <br><br>  Masalahnya adalah berbagai cara penyajian data yang diperlukan, untuk akses ke mereka, kode yang berbeda dan sintaks yang berbeda dalam bahasa pemrograman yang digunakan di beberapa titik waktu.  Holy Grail di sini akan menjadi cara universal untuk mengakses dan mengelola data.  Jika semua data akan terlihat sama untuk program, ini akan menyelesaikan banyak masalah pengembang mengenai pengembangan dan pemeliharaan program. <br>  Alan Kay mencoba "menyingkirkan" gagasan itu, yang menurutnya data dan program adalah, dalam arti tertentu, entitas independen.  Mereka tidak dianggap seperti itu dalam Daftar atau dalam Smalltalk.  Tidak ada pemisahan antara apa yang dapat dilakukan dengan data (dengan nilai, variabel, struktur data, dan sebagainya) dan konstruksi perangkat lunak seperti fungsi.  Fungsinya adalah "warga negara kelas satu," dan program diizinkan untuk berubah selama eksekusi mereka.  Dengan kata lain, Smalltalk tidak memiliki hubungan istimewa dan istimewa dengan data. <br><br>  Alan Kay, apalagi, menganggap objek sebagai struktur aljabar, yang memberikan jaminan pasti, secara matematis terbukti dari perilaku mereka. <br><br>  <i><font color="#999999">"Latar belakang matematis saya memungkinkan saya untuk memahami bahwa setiap objek dapat memiliki beberapa model aljabar yang terkait dengannya, bahwa mungkin ada seluruh kelompok model yang serupa, dan bahwa mereka bisa sangat, sangat berguna."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Terbukti memang demikian, dan ini menjadi dasar bagi objek, seperti janji dan lensa, apalagi, teori kategori dipengaruhi oleh keduanya. <br>  Sifat aljabar bagaimana Alan Kay melihat objek akan memungkinkan objek memberikan verifikasi formal, perilaku deterministik, dan meningkatkan kemampuan uji, karena model aljabar, pada dasarnya, operasi yang mematuhi beberapa aturan dalam bentuk persamaan. <br><br>  Dalam jargon programmer, "model aljabar" adalah abstraksi yang dibuat dari fungsi (operasi) yang disertai dengan aturan tertentu, ditegakkan oleh unit test yang harus dilewati oleh fungsi-fungsi ini (aksioma, persamaan). <br><br>  Ide-ide ini telah dilupakan selama beberapa dekade di sebagian besar bahasa berorientasi objek dari keluarga C, termasuk C ++, Java, C #, dan sebagainya.  Tetapi ide-ide ini memulai pencarian untuk perjalanan pulang, dalam versi terbaru dari bahasa berorientasi objek yang paling banyak digunakan. <br><br>  Pada kesempatan ini, seseorang dapat mengatakan bahwa dunia pemrograman menemukan kembali manfaat pemrograman fungsional, dan memberikan argumen rasional dalam konteks bahasa berorientasi objek. <br><br>  Seperti JavaScript dan Smalltalk sebelumnya, sebagian besar bahasa berorientasi objek modern menjadi lebih dan lebih "multi-paradigma".  Tidak ada alasan untuk memilih antara pemrograman fungsional dan OOP.  Ketika kita melihat esensi historis dari masing-masing pendekatan ini, mereka terlihat tidak hanya sebagai kompatibel, tetapi juga sebagai ide yang saling melengkapi. <br><br>  Apa, sesuai dengan pemikiran Alan Kay, yang paling penting dalam PLO? <br><br><ul><li>  Enkapsulasi. </li><li>  Olahpesan </li><li>  Pengikatan dinamis (kemampuan program untuk mengembangkan dan beradaptasi dengan perubahan selama pelaksanaannya). </li></ul><br>  Apa yang bisa diabaikan dalam OOP? <br><br><ul><li>  Kelas. </li><li>  Warisan berbasis kelas. </li><li>  Hubungan khusus dengan objek, fungsi atau data. </li><li> Kata kunci <code>new</code> . </li><li>  Polimorfisme. </li><li>  Pengetikan statis. </li><li>  Sikap terhadap kelas sebagai "tipe". </li></ul><br>  Jika Anda mengenal Java atau C #, Anda mungkin berpikir bahwa pengetikan statis atau polimorfisme adalah unsur terpenting OOP, tetapi Alan Kay lebih suka berurusan dengan pola perilaku universal dalam bentuk aljabar.  Berikut adalah contoh yang ditulis dalam Haskell: <br><br><pre> <code class="hljs erlang-repl">fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  Ini adalah tanda tangan dari functor <code>map</code> universal, yang bekerja dengan tipe <code>a</code> dan <code>b</code> tidak terdefinisi, menerapkan fungsi dari <code>a</code> ke <code>b</code> dalam konteks functor <code>a</code> untuk membuat functor <code>b</code> .  "Functor" adalah kata dari jargon matematika, yang artinya direduksi menjadi "mendukung operasi tampilan".  Jika Anda terbiasa dengan metode <code>[].map()</code> dalam JavaScript, maka Anda sudah tahu apa artinya ini. <br><br>  Berikut adalah beberapa contoh JavaScript: <br><br><pre> <code class="hljs powershell">// isEven = Number =&gt; Boolean const isEven = n =&gt; n % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span>; const nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; //  map   `a =&gt; b`    `a` ( `this`) //     `b` //    `a`   `Number`,   `b`  `Boolean` const results = nums.map(isEven); console.log(results); // [<span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>]</code> </pre> <br>  Metode <code>.map()</code> bersifat universal, dalam arti bahwa <code>a</code> dan <code>b</code> dapat dari jenis apa pun, dan metode ini mengatasi situasi yang sama tanpa masalah, karena array adalah struktur data yang menerapkan hukum aljabar dari functors.  Tipe untuk <code>.map()</code> tidak masalah, karena metode ini tidak mencoba untuk bekerja dengan nilai yang terkait secara langsung.  Sebagai gantinya, ia menggunakan fungsi yang mengharapkan dan mengembalikan nilai dari tipe yang sesuai yang benar dari sudut pandang aplikasi. <br><br><pre> <code class="hljs pgsql">// matches = a =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span> //  `a`    ,   const matches = control =&gt; input =&gt; input === control; const strings = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>]; const results = strings.map(matches(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>)); console.log(results); // [<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>]</code> </pre> <br>  Hubungan tipe universal bisa sulit untuk diekspresikan dengan benar dan sepenuhnya dalam bahasa seperti TypeScript, tetapi sangat mudah dilakukan dalam sistem tipe Hindley-Milner yang digunakan dalam Haskell, yang mendukung tipe yang lebih tinggi (tipe tipe). <br><br>  Sebagian besar sistem tipe memberlakukan pembatasan yang terlalu kuat untuk memungkinkan kebebasan berekspresi ide-ide dinamis dan fungsional, seperti komposisi fungsi, komposisi objek bebas, ekspansi objek selama eksekusi program, penggunaan kombinator, lensa, dan sebagainya.  Dengan kata lain?  tipe statis sering membuatnya sulit untuk menulis perangkat lunak menggunakan metode build. <br><br>  Jika sistem tipe Anda memiliki terlalu banyak batasan (seperti dalam TypeScript atau Java), maka, untuk mencapai tujuan yang sama, Anda harus menulis kode yang lebih kompleks daripada saat menggunakan bahasa dengan pendekatan yang lebih bebas untuk mengetik.  Ini tidak berarti bahwa menggunakan tipe statis adalah ide yang tidak menguntungkan, atau bahwa semua implementasi tipe statis memiliki batasan yang sama.  Sebagai contoh, saya mengalami lebih sedikit masalah dalam bekerja dengan sistem tipe Haskell. <br><br>  Jika Anda adalah penggemar tipe statis dan tidak menentang pembatasan, saya berharap Anda tujuh kaki di bawah lunas.  Tetapi jika Anda menemukan bahwa beberapa ide yang diungkapkan di sini sulit untuk diterapkan karena fakta bahwa tidak mudah untuk mengetik fungsi yang diperoleh dengan menyusun fungsi lain dan struktur aljabar komposit, maka salahkan sistem tipe dan bukan idenya.  Pengemudi menyukai fasilitas yang diberikan bingkai-SUV, tetapi tidak ada yang mengeluh bahwa mereka tidak bisa terbang.  Untuk terbang, Anda membutuhkan kendaraan yang memiliki derajat kebebasan lebih tinggi. <br><br>  Jika batasan membuat kode Anda lebih sederhana - hebat!  Tetapi jika kendala memaksa Anda untuk menulis kode yang lebih kompleks, maka mungkin ada sesuatu yang salah dengan kendala ini. <br><br><h2>  <font color="#3AC1EF">Apa itu "objek"?</font> </h2><br>  Kata "objek", dari waktu ke waktu, telah memperoleh banyak konotasi makna sekunder.  Apa yang kita sebut "objek" dalam JavaScript hanyalah tipe data komposit, tanpa sedikit pun petunjuk tentang pemrograman berbasis kelas, atau ide penyampaian pesan Alan Kay. <br><br>  Dalam JavaScript, objek-objek ini dapat mendukung, dan seringkali mendukung, enkapsulasi, menyampaikan pesan, pemisahan perilaku melalui metode, bahkan polimorfisme menggunakan subclass (meskipun menggunakan rantai delegasi daripada pengiriman berbasis tipe). <br><br>  Alan Kay ingin menyingkirkan perbedaan antara program dan datanya.  JavaScript, sampai batas tertentu, mencapai tujuan ini dengan menempatkan metode objek di tempat yang sama dengan properti yang menyimpan data.  Properti apa pun, misalnya, dapat diberi fungsi apa pun.  Anda dapat membangun perilaku objek secara dinamis dan mengubah konten semantik objek selama eksekusi program. <br><br>  Objek hanya struktur data komposit, dan tidak perlu sesuatu yang istimewa untuk dianggap objek.  Namun, pemrograman menggunakan objek tidak mengarah pada fakta bahwa kode tersebut ternyata "berorientasi objek", seperti halnya menggunakan fungsi tidak membuat kode "fungsional". <br><br><h2>  <font color="#3AC1EF">OOP bukan lagi OOP nyata</font> </h2><br>  Karena konsep "objek" dalam bahasa pemrograman modern memiliki makna jauh lebih sedikit daripada yang dimaksudkan oleh Alan Kay, saya menggunakan kata "komponen" alih-alih kata "objek" untuk menggambarkan aturan OOP ini.  Banyak objek yang secara langsung dimiliki dan dikendalikan oleh beberapa kode JavaScript pihak ketiga, tetapi komponen harus merangkum keadaan mereka sendiri dan mengendalikannya. <br><br>  Inilah OOP yang sebenarnya: <br><br><ul><li>  Pemrograman menggunakan komponen (Alan Kay menyebutnya "objek"). </li><li>  Keadaan komponen harus dienkapsulasi. </li><li>  Untuk komunikasi antar entitas, olahpesan digunakan. </li><li>  Komponen dapat ditambahkan, dimodifikasi, dan diganti pada saat runtime. </li></ul><br>  Sebagian besar perilaku objek dapat didefinisikan secara universal menggunakan struktur data aljabar.  Tidak perlu warisan.  Komponen dapat menggunakan kembali perilaku dari fungsi publik dan mengimpor modul, tanpa harus mempublikasikan datanya. <br><br>  Memanipulasi objek dalam JavaScript atau menggunakan warisan berbasis kelas tidak berarti seseorang terlibat dalam pemrograman OOP.  Tetapi penggunaan komponen dengan cara seperti itu - berarti.  Tetapi sangat sulit untuk menyingkirkan ide-ide mapan tentang istilah, jadi mungkin kita harus meninggalkan istilah "OOP" dan memanggil apa "komponen" di atas digunakan sebagai "Pemrograman Berorientasi Pesan (MOP)"?  Kami akan menggunakan istilah "MOP" di bawah ini untuk berbicara tentang pemrograman berorientasi pesan. <br><br>  Secara kebetulan, kata bahasa Inggris "pel" diterjemahkan sebagai "pel", dan, seperti yang Anda tahu, mereka digunakan untuk memulihkan ketertiban. <br><br><h2>  <font color="#3AC1EF">Seperti apa bentuk pel yang baik?</font> </h2><br>  Sebagian besar program modern memiliki antarmuka pengguna (User Interface, UI) yang bertanggung jawab untuk berinteraksi dengan pengguna, beberapa kode yang mengelola keadaan aplikasi (data pengguna), dan kode yang berfungsi dengan sistem atau bertanggung jawab untuk bertukar data dengan jaringan. <br><br>  Untuk mendukung operasi masing-masing sistem ini, proses yang berumur panjang, seperti pendengar acara, mungkin diperlukan.  Di sini Anda akan memerlukan keadaan aplikasi - untuk menyimpan sesuatu seperti informasi tentang koneksi jaringan, tentang keadaan hubungan dengan kontrol antarmuka dan tentang aplikasi itu sendiri. <br><br>  MOP yang baik berarti bahwa, alih-alih semua sistem tersebut memiliki akses ke status satu sama lain dan dapat mengontrolnya secara langsung, mereka berinteraksi satu sama lain melalui pesan.  Ketika pengguna mengklik tombol "Simpan", pesan <code>"SAVE"</code> dapat dikirim.  Komponen aplikasi manajemen negara dapat menafsirkan pesan ini dan mengarahkannya ke pawang yang bertanggung jawab untuk memperbarui dari negara (seperti fungsi reducer murni).  Mungkin setelah memperbarui negara, komponen yang bertanggung jawab untuk mengelola negara mengirimkan pesan <code>"STATE_UPDATED"</code> komponen antarmuka pengguna, yang, pada gilirannya, menginterpretasikan keadaan, memutuskan bagian antarmuka mana yang perlu diperbarui, dan meneruskan negara yang diperbarui ke subkomponen yang bertanggung jawab untuk bekerja dengan elemen antarmuka spesifik. <br><br>  Sementara itu, komponen yang bertanggung jawab untuk koneksi jaringan dapat memonitor koneksi pengguna ke komputer lain di jaringan, mendengarkan pesan, dan mengirim tampilan keadaan yang diperbarui untuk menyimpannya di mesin jarak jauh.  Komponen seperti itu bertanggung jawab untuk bekerja dengan mekanisme jaringan, mengetahui apakah koneksi berfungsi atau tidak, dan sebagainya. <br><br>  Sistem aplikasi yang serupa seharusnya tidak mengetahui detail bagian-bagian lainnya.  Mereka seharusnya hanya peduli untuk menyelesaikan masalah mereka sendiri.  Komponen sistem dapat dibongkar dan dirakit sebagai konstruktor.  Mereka menerapkan antarmuka standar, yang berarti bahwa mereka dapat berinteraksi satu sama lain.  Selama persyaratan yang terkenal untuk antarmuka komponen terpenuhi, komponen tersebut dapat diganti oleh yang lain, dengan antarmuka yang sama, tetapi melakukan hal yang sama secara berbeda, atau melakukan, menerima pesan yang sama, sesuatu yang sama sekali berbeda.  Anda dapat mengubah satu komponen ke komponen lain bahkan selama eksekusi program - ini tidak akan merusak pekerjaannya. <br><br>  Komponen sistem perangkat lunak bahkan tidak harus berada di komputer yang sama.  Sistem dapat didesentralisasi.  Penyimpanan jaringan dapat menempatkan data dalam sistem penyimpanan data terdesentralisasi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IPFS</a> , sebagai akibatnya, pengguna tidak tergantung pada kesehatan mesin tertentu, yang menjamin keamanan datanya.  Dengan pendekatan ini, data disimpan dan dilindungi dari pengganggu. <br><br>  PLO, sebagian, berada di bawah pengaruh ide-ide ARPANET, dan salah satu tujuan proyek ini adalah untuk menciptakan jaringan terdesentralisasi yang tahan terhadap serangan seperti serangan nuklir. <br><br>  Sistem MOP yang baik dapat ditandai dengan tingkat stabilitas yang sama menggunakan komponen yang mendukung hot swapping saat aplikasi sedang berjalan.  Ini akan dapat terus berfungsi jika pengguna bekerja dengan itu dari ponsel dan berada di luar jangkauan jaringan karena fakta bahwa ia telah memasuki terowongan.  Jika badai mengganggu catu daya salah satu pusat data di mana servernya berada, itu juga akan terus berfungsi. <br><br>  Sudah saatnya bagi dunia perangkat lunak untuk membebaskan diri dari percobaan warisan berbasis kelas yang gagal dan mengadopsi prinsip-prinsip matematika dan ilmiah yang berada di garis depan OOP. <br><br>  Waktunya telah tiba bagi kita para pengembang untuk membuat program yang lebih fleksibel, stabil, dan indah menggunakan kombinasi harmonis antara MOP dan pemrograman fungsional. <br>  Omong-omong, akronim "MOP" sudah digunakan, menggambarkan "Pemrograman Berorientasi Pemantauan", tetapi konsep ini, tidak seperti OOP, akan hilang dengan tenang. <br><br>  Karena itu, jangan berkecil hati jika istilah "MOP" tidak terlihat seperti kata dari jargon programmer.  Rapikan OOP Anda dengan prinsip-prinsip MOP di atas. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428582/">https://habr.com/ru/post/id428582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428572/index.html">Komponen Orde Tinggi dalam Bereaksi</a></li>
<li><a href="../id428574/index.html">Bawa komunikasi korporat ke tingkat selanjutnya dengan Zextras Chat</a></li>
<li><a href="../id428576/index.html">[bookmark] versi PDF dari tutorial Node.js dan panduan JavaScript baru</a></li>
<li><a href="../id428578/index.html">Cara memulai dengan Hibernate Search</a></li>
<li><a href="../id428580/index.html">Panduan Komunikasi yang Baik</a></li>
<li><a href="../id428588/index.html">Intisari acara TI pada bulan November (bagian dua)</a></li>
<li><a href="../id428590/index.html">Interaksi mikro dan permintaan mikro di antarmuka</a></li>
<li><a href="../id428592/index.html">Berhentilah mempekerjakan "manajer yang efektif." Mereka tidak hanya tidak berguna, tetapi juga berbahaya</a></li>
<li><a href="../id428596/index.html">Elon Musk memecat manajer proyek internet satelit Starlink karena tidak memenuhi tenggat waktu</a></li>
<li><a href="../id428598/index.html">Jaringan saraf yang dalam untuk penilaian panggilan otomatis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>