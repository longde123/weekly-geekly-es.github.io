<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🎤 💹 😉 Composants agulaires en angulaire 😮 🔗 😋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque vous travaillez sur une bibliothèque de composants réutilisables, la question de l'API est particulièrement aiguë. D'une part, vous devez pren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Composants agulaires en angulaire</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/473108/"><p>  Lorsque vous travaillez sur une bibliothèque de composants réutilisables, la question de l'API est particulièrement aiguë.  D'une part, vous devez prendre une décision fiable et précise, d'autre part, pour satisfaire de nombreux cas particuliers.  Cela s'applique à l'utilisation des données et aux fonctionnalités externes de divers cas d'utilisation.  De plus, tout doit être facilement mis à jour et déployé sur les projets. </p><br><p>  Ces composants nécessitent une flexibilité sans précédent.  Dans le même temps, le cadre ne peut pas être rendu trop compliqué, car ils seront utilisés à la fois par les seniors et les juin.  La réduction de la duplication de code est l'une des tâches de la bibliothèque de composants.  Par conséquent, la configuration ne peut pas être transformée en code de copie. </p><br><p><img src="https://habrastorage.org/webt/pc/0n/84/pc0n84gqkevxlhxdkfw7xhyay_i.png" alt="Bruce Lee"></p><a name="habracut"></a><br><h2 id="data-agnostic-komponenty">  Composants agnostiques aux données </h2><br><p>  Disons que nous créons un bouton avec un menu déroulant.  Quelle sera son API?  Bien sûr, il a besoin de certains <i>éléments</i> en entrée - un tableau d'éléments de menu.  Très probablement, la première version de l'interface sera comme ceci: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">MenuItem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> text: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span></span>; }</code> </pre> <br><p>  Assez rapidement, <code>disabled: boolean</code> ajoutera à cela.  Ensuite, les concepteurs viendront dessiner un menu avec des icônes.  Et les gars du projet voisin, ils dessineront des icônes d'autre part.  Et l'interface se développe, il est nécessaire de couvrir de plus en plus de cas particuliers, et à partir de l'abondance de drapeaux, le composant commence à ressembler à l'Assemblée des Nations Unies. </p><br><p><img src="https://habrastorage.org/webt/_i/yl/6a/_iyl6asyyxmlupg18qiudynytnk.jpeg"></p><br><p>  Les génériques viennent à la rescousse.  Si vous organisez le composant de sorte qu'il ne se soucie pas du modèle de données, tous ces problèmes disparaîtront.  Au lieu d'appeler <code>item.onClick</code> sur un clic, le menu émettra simplement l'élément cliqué.  Que faire ensuite est une tâche pour les utilisateurs de la bibliothèque.  Même s'ils appellent le même <code>item.onClick</code> . </p><br><p>  Dans le cas d'un état <code>disabled</code> , par exemple, le problème est résolu à l'aide de gestionnaires spéciaux.  La méthode <code>disabledItemHandler: (item: T) =&gt; boolean</code> est transmise au composant <code>disabledItemHandler: (item: T) =&gt; boolean</code> , à travers lequel chaque élément est exécuté.  Le résultat indique si cet élément est verrouillé. </p><br><p><img src="https://habrastorage.org/webt/zg/xf/nc/zgxfnc8ssnfx9uw6y355gcymmdc.png"></p><br><p>  Si vous faites un <em>ComboBox</em> , une interface peut vous venir à l'esprit qui stocke une chaîne pour l'affichage et une vraie valeur arbitraire qui est utilisée dans le code.  Cette idée est claire.  Après tout, lorsque l'utilisateur tape le texte, la <em>zone de liste déroulante</em> doit filtrer les options en fonction de la ligne entrée. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ComboBoxItem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> text: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: any; }</code> </pre> <br><p>  Mais ici aussi, les limites d'une telle approche apparaîtront - dès qu'un design apparaîtra dans lequel la ligne ne suffira pas.  De plus, le formulaire contiendra un wrapper au lieu de la valeur réelle, la recherche n'est pas toujours effectuée exclusivement par la représentation sous forme de chaîne (par exemple, nous pouvons entrer un numéro de téléphone, mais le nom de la personne doit être affiché).  Et le nombre d'interfaces augmentera avec l'arrivée d'autres composants, même si le modèle de données sous eux est le même. </p><br><p>  Les génériques et les gestionnaires seront également utiles ici.  Donnons la fonction <code>(item: T) =&gt; string</code> composant <code>stringify</code> .  La valeur par défaut est <code>item =&gt; String(item)</code> .  Ainsi, vous pouvez même utiliser des classes comme options en y définissant la <code>toString()</code> .  Comme mentionné ci-dessus, il est nécessaire de filtrer les options non seulement par représentation de chaîne.  C'est également un bon cas pour utiliser des gestionnaires.  Vous pouvez fournir un composant avec une fonction qui reçoit une chaîne de recherche et un élément en entrée.  Il renverra <code>boolean</code> - cela dira si l'article convient à la demande. </p><br><blockquote>  Un autre exemple courant d'utilisation d'une interface est un identifiant unique, qui correspond à des copies d'objets JavaScript.  Lorsque nous avons reçu la valeur du formulaire immédiatement et que les options de sélection sont entrées dans une demande distincte du serveur - ils n'auront qu'une copie de l'élément actuel.  Cette tâche est gérée par un gestionnaire qui reçoit deux éléments en entrée et renvoie leur égalité.  La comparaison par défaut est normale <code>===</code> . </blockquote><p>  Le composant d'affichage d'onglet, en fait, n'a pas besoin de savoir sous quelle forme l'onglet lui a été transmis: au moins avec du texte, au moins avec un objet avec des champs supplémentaires, même avec comment.  La connaissance du format n'est pas nécessaire pour l'implémentation, mais beaucoup font le lien vers un format spécifique.  L'absence de liens signifie que les composants n'entraîneront pas de changements de rupture pendant le raffinement, ne forceront pas les utilisateurs à adapter leurs données pour eux et permettront de combiner des composants atomiques les uns avec les autres comme des cubes lego. </p><br><p>  Le même choix d'éléments convient à la fois au menu contextuel et à la zone de liste déroulante, les composants simples, à sélection multiple et à sélection multiple sont facilement inclus dans des conceptions plus complexes.  Cependant, vous devez pouvoir afficher en quelque sorte des données arbitraires. </p><br><p><img src="https://habrastorage.org/webt/cu/zh/sf/cuzhsfzxk1srcnv-vt5dun9muh8.png"><br>  <em>Les listes peuvent contenir des avatars, différentes couleurs, icônes, le nombre de messages non lus et bien plus encore.</em> </p><br><blockquote>  Pour ce faire, les composants doivent fonctionner avec l'apparence d'une manière similaire aux génériques. </blockquote><br><h2 id="design-agnostic-komponenty">  Composants indépendants de la conception </h2><br><p>  Angular fournit des outils puissants pour définir l'apparence. </p><br><p>  Par exemple, considérez un <em>ComboBox</em> , car il peut sembler très divers.  Bien sûr, un certain niveau de restrictions sera fixé dans le composant, car il doit obéir à la conception globale de l'application.  Sa taille, ses couleurs par défaut, son rembourrage - tout cela devrait fonctionner par lui-même.  Nous ne voulons pas forcer les utilisateurs à penser à tout ce qui concerne l'apparence. </p><br><p><img src="https://habrastorage.org/webt/ah/rj/v7/ahrjv7_hlb0ta2fnsshusxssukw.png"></p><br><p>  Les données arbitraires sont comme l'eau: elles n'ont pas de forme, elles ne portent rien de spécifique en elles-mêmes.  Notre tâche est de leur offrir la possibilité de définir un «navire».  En ce sens, le développement d'un composant abstrait de l'apparence est le suivant: </p><br><p><img src="https://habrastorage.org/webt/1f/ve/hl/1fvehlcg_sv4heypbphk72juuzs.png"></p><br><p>  Le composant est une sorte d'étagère de la taille requise, et un modèle personnalisé est utilisé pour afficher le contenu, qui est «mis dessus».  Une méthode standard, telle que la sortie d'une représentation sous forme de chaîne, est initialement définie dans le composant, et l'utilisateur peut transférer des options plus complexes de l'extérieur.  Jetons un coup d'œil aux possibilités qu'Angular a pour cela. </p><br><ol><li><p>  L'interpolation de lignes est la manière la plus simple de modifier l'apparence.  Mais une ligne invariable ne convient pas pour afficher les éléments de menu, car elle ne sait rien de chaque élément - et ils auront tous la même apparence.  <strong>Une chaîne statique est privée de contexte</strong> .  Mais il est tout à fait approprié pour définir le texte "Nothing Found" si la liste des options est vide. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>{{content}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br></li><li><p>  Nous avons déjà parlé de la représentation sous forme de chaîne de données arbitraires.  Le résultat est également une chaîne, mais est déterminé par la valeur d'entrée.  Dans cette situation, le contexte sera un élément de liste.  Il s'agit d'une option plus flexible, bien qu'elle ne permette pas de styliser le résultat - la chaîne n'est pas interpolée en HTML - et plus encore elle ne permettra pas l'utilisation de directives ou de composants. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>{{content(context)}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br></li><li><p>  Angular fournit <code>ng-template</code> et la directive structurelle <code>*ngTemplateOutlet</code> pour <code>*ngTemplateOutlet</code> .  Avec leur aide, nous pouvons définir un élément HTML qui attend que certaines données soient saisies et les transmettre au composant.  Là, il sera instancié avec un contexte spécifique.  Nous lui transmettrons notre élément sans nous soucier du modèle.  L'élaboration du bon modèle pour vos objets est la tâche du développeur-consommateur de notre composant. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngTemplateOutlet</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content; context: context"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Un modèle est un outil très puissant, mais il doit être défini dans un composant existant.  Cela complique grandement sa réutilisation.  Parfois, la même apparence est requise dans différentes parties de l'application et même dans différentes applications.  Dans ma pratique, c'est, par exemple, l'apparence de la sélection de compte avec l'affichage du nom, de la devise et du solde. <br><img src="https://habrastorage.org/webt/ub/qx/4q/ubqx4q9n5_igvvckb9p-2yx2zjm.png"></p><br></li><li><p>  La façon la plus complexe de personnaliser l'apparence qui résout ce problème est les composants dynamiques.  Dans Angular, la directive <code>*ngComponentOutlet</code> existe depuis longtemps pour les créer de manière déclarative.  Il ne permet pas le transfert de contexte, mais ce problème est résolu par l'implémentation de dépendances.  Nous pouvons créer un jeton pour le contexte et l'ajouter à l' <code>Injector</code> avec lequel le composant est créé. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngComponentOutlet</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content; injector: injector"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Il convient de noter que le contexte peut être non seulement l'élément que nous voulons afficher, mais également les circonstances dans lesquelles il se trouve: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">let-item</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">let-focused</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"focused"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- ... --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Par exemple, dans le cas du retrait d'un compte, l'état de mise au point de l'élément se reflète dans l'apparence - l'arrière-plan de l'icône passe du gris au blanc.  De manière générale, il est judicieux de transférer dans le contexte les conditions susceptibles d'affecter l'affichage du modèle.  Ce point est peut-être la seule interface de limitation de cette approche. </p><br></li></ol><br><p><img src="https://habrastorage.org/webt/0r/_b/ny/0r_bnyldkla9a93ovsesmivwvqg.png"></p><br><h2 id="universalnyy-outlet">  Prise universelle </h2><br><p>  Les outils décrits ci-dessus sont disponibles en angulaire à partir de la cinquième version.  Mais nous voulons passer facilement d'une option à une autre.  Pour ce faire, nous assemblerons un composant qui accepte le contenu et le contexte en entrée et implémente la manière appropriée d'insérer automatiquement ce contenu.  En général, il nous suffit d'apprendre à distinguer les types <code>string</code> , <code>number</code> , <code>(context: T) =&gt; string | number</code>  <code>(context: T) =&gt; string | number</code> , <code>TemplateRef&lt;T&gt;</code> et <code>Type&lt;any&gt;</code> (mais il y a quelques nuances ici, dont nous discuterons ci-dessous). </p><br><p>  Le modèle de composant ressemblera à ceci: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngSwitch</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"type"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngSwitchCase</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"'primitive'"</span></span></span><span class="hljs-tag">&gt;</span></span>{{content}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngSwitchCase</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"'function'"</span></span></span><span class="hljs-tag">&gt;</span></span>{{content(context)}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngSwitchCase</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"'template'"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngTemplateOutlet</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content; context: context"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngSwitchCase</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"'component'"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngComponentOutlet</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content; injector: injector"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Le code obtiendra un getter de type pour sélectionner la méthode appropriée.  Il est à noter qu'en général on ne peut pas distinguer un composant d'une fonction.  Lorsque vous utilisez des modules paresseux, nous avons besoin d'un <code>Injector</code> qui connaît l'existence du composant.  Pour ce faire, nous allons créer une classe wrapper.  Cela permettra également de le déterminer par <code>instanceof</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentContent</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( readonly component: Type&lt;T&gt;, private readonly injector: Injector | null = null, ) {} }</code> </pre> <br><p>  Ajoutez une méthode pour créer un injecteur avec le contexte passé: </p><br><pre> <code class="javascript hljs">createInjectorWithContext(injector: Injector, <span class="hljs-attr"><span class="hljs-attr">context</span></span>: C): Injector { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Injector.create({ <span class="hljs-attr"><span class="hljs-attr">parent</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.injector || injector, <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">provide</span></span>: CONTEXT, <span class="hljs-attr"><span class="hljs-attr">useValue</span></span>: context, }, ], }); }</code> </pre> <br><p>  Quant aux modèles, dans la plupart des cas, vous pouvez les utiliser tels quels.  Mais nous devons garder à l'esprit que le modèle est soumis à la vérification des changements à la place de sa définition.  Si vous le transférez dans la <em>vue</em> , qui est parallèle ou supérieure dans l'arborescence à partir du lieu de définition, les modifications qui peuvent y être déclenchées ne seront pas récupérées dans la <em>vue d'</em> origine. </p><br><p>  Pour corriger cette situation, nous utiliserons non seulement un modèle, mais une directive qui aura également <code>ChangeDetectorRef</code> son lieu de définition.  De cette façon, nous pouvons commencer à vérifier les modifications si nécessaire. </p><br><h2 id="polimorfnye-shablony">  Modèles polymorphes </h2><br><p>  En pratique, il peut être utile de contrôler le comportement du modèle en fonction du type de contenu qui y est entré. </p><br><p>  Par exemple, nous voulons donner la possibilité de transférer un modèle vers un composant pour quelque chose de spécial.  Dans le même temps, dans la plupart des cas, vous avez juste besoin d'une icône.  Dans une telle situation, vous pouvez configurer le comportement par défaut et l'utiliser quand une primitive ou une fonction est entrée dans l'entrée.  Parfois, même le type de primitive est important: par exemple, si vous avez un composant de badge pour afficher le nombre de messages non lus sur un onglet, mais que vous souhaitez mettre en évidence les pages qui nécessitent une attention particulière avec une icône spéciale. </p><br><p><img src="https://habrastorage.org/webt/sr/ag/gk/sraggknu2ikgpz5tezg5o4zgsdc.png"></p><br><p>  Pour ce faire, vous devez ajouter une dernière chose: passer un modèle pour afficher les primitives.  Ajoutez <code>@ContentChild</code> au composant, ce qui prend <code>TemplateRef</code> du contenu.  Si une est trouvée et qu'une fonction, une chaîne ou un nombre est passé au contenu, nous pouvons l'instancier avec la primitive comme contexte: </p><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngSwitchCase</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"'interpolation'"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngIf</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"!template; else child"</span></span></span><span class="hljs-tag">&gt;</span></span>{{primitive}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag"> #</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">child</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngTemplateOutlet</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"template; context: { $implicit: primitive }"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Maintenant, nous pouvons styliser l'interpolation ou même transmettre le résultat à un composant pour l'affichage: </p><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content-outlet</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content"</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">context</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"context"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">let-primitive</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"primitive"</span></span></span><span class="hljs-tag">&gt;</span></span>{{primitive}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content-outlet</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Il est temps de mettre notre code en pratique. </p><br><h2 id="ispolzovanie">  Utiliser </h2><br><p>  Pour des exemples, nous décrivons deux composants: les onglets et <em>ComboBox</em> .  Le modèle d'onglet se composera simplement d'une sortie de contenu pour chaque onglet, où l'objet transmis par l'utilisateur sera le contexte: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content-outlet</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngFor</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"let tab of tabs"</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class.disabled</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"disabledItemHandler(tab)"</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content"</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">context</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"getContext(tab)"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"onClick(tab)"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content-outlet</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Vous devez définir des styles par défaut: par exemple, la taille de la police, le soulignement sous l'onglet actuel, la couleur.  Mais nous laisserons une apparence concrète au contenu.  Le code du composant ressemblera à ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TabsComponent</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ @Input() tabs: ReadonlyArray&lt;T&gt; = []; @Input() content: Content = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{$implicit}</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>($implicit); @Input() disabledItemHandler: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tab: T</span></span></span><span class="hljs-function">) =&gt;</span></span> boolean = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; @Input() activeTab: T | <span class="hljs-literal"><span class="hljs-literal">null</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; @Output() activeTabChange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter&lt;T&gt;(); getContext($implicit: T): IContextWithActive&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { $implicit, <span class="hljs-attr"><span class="hljs-attr">active</span></span>: $implicit === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.activeTab, }; } onClick(tab: T) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.activeTab = tab; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.activeTabChange.emit(tab); } }</code> </pre> <br><p>  Nous avons obtenu un composant qui peut fonctionner avec un tableau arbitraire, en l'affichant sous forme d'onglets.  Vous pouvez simplement y passer des chaînes et obtenir le look de base: </p><br><p><img src="https://habrastorage.org/webt/vs/r8/yp/vsr8yp5h-bhqkel8nyjwns_fwyk.png"></p><br><p>  Et vous pouvez transférer des objets et un modèle pour les afficher et personnaliser l'apparence selon vos besoins, ajouter du HTML, des icônes, des indicateurs: </p><br><p><img src="https://habrastorage.org/webt/px/jm/gg/pxjmggknrn2tlx1kp6lgxhfpoik.png"></p><br><p>  Dans le cas de <em>ComboBox,</em> nous allons d'abord faire deux composants de base dont il se compose: un champ de saisie avec une icône et un menu.  Ce dernier n'a pas de sens pour peindre en détail - il est très similaire aux onglets, uniquement verticalement et a d'autres styles de base.  Et le champ de saisie peut être implémenté comme suit: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> #</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">input</span></span></span><span class="hljs-tag"> [(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngModel</span></span></span><span class="hljs-tag">)]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content-outlet</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mousedown</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"onMouseDown($event, input)"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">let-icon</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">innerHTML</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content-outlet</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Si vous faites l' <em>entrée</em> absolument positionnée, elle bloquera la sortie et tous les clics y seront.  Ceci est pratique pour un champ de saisie simple avec une icône décorative, comme une icône de loupe.  Dans l'exemple ci-dessus, l'approche du modèle polymorphe est appliquée - la chaîne transmise sera utilisée comme <code>innerHTML</code> pour insérer l'icône SVG.  Si, par exemple, nous devons montrer l'avatar de l'utilisateur saisi, nous pouvons y transférer le modèle. </p><br><p>  <em>ComboBox a</em> également besoin d'une icône, mais elle doit être interactive.  Pour l'empêcher de rompre le focus, ajoutez le gestionnaire <code>onMouseDown</code> à la prise: </p><br><pre> <code class="javascript hljs">onMouseDown(event: MouseEvent, <span class="hljs-attr"><span class="hljs-attr">input</span></span>: HTMLInputElement) { event.preventDefault(); input.focus(); }</code> </pre> <br><p>  Passer le modèle en tant que contenu nous permettra de l'augmenter plus haut via CSS simplement en faisant l'icône <em>position: relative</em> .  Ensuite, vous pouvez vous abonner à des clics sur elle dans le <em>ComboBox</em> lui-même: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-input</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">app-input</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag"> #</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">icon</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2000/svg"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"24"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"24"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">viewBox</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0 0 24 24"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon"</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class.icon_opened</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"opened"</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"onClick()"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">polyline</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">points</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"7,10 12,15 17,10"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"none"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stroke</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"currentColor"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stroke-linecap</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"round"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stroke-linejoin</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"round"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">stroke-width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Grâce à une telle organisation, nous obtenons le comportement souhaité: </p><br><p><img src="https://habrastorage.org/webt/ty/i2/d9/tyi2d9hy6ayosztbibp-1ye0cdg.gif"></p><br><p>  Le code composant, comme dans le cas des onglets, dispense de la connaissance du modèle de données.  Cela ressemble à ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComboBoxComponent</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ @Input() items: ReadonlyArray&lt;T&gt; = []; @Input() content: Content = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{$implicit}</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>($implicit); @Input() stringify = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item: T</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(item); @Input() value: T | <span class="hljs-literal"><span class="hljs-literal">null</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; @Output() valueChange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter&lt;T | <span class="hljs-literal"><span class="hljs-literal">null</span></span>&gt;(); stringValue = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">//          get filteredItems(): ReadonlyArray&lt;T&gt; { return this.items.filter(item =&gt; this.stringify(item).includes(this.stringValue), ); } }</span></span></code> </pre> <br><p>  Ce code simple vous permet d'utiliser n'importe quel objet dans <em>ComboBox</em> et de personnaliser leur affichage de manière très flexible.  Après quelques améliorations qui ne sont pas liées au concept décrit, il est prêt à l'emploi.  L'apparence peut être personnalisée pour tous les goûts: </p><br><p><img src="https://habrastorage.org/webt/78/-l/xr/78-lxrmsic1iiltn-qx0dekwf2s.gif"></p><br><h2 id="vyvod">  Conclusion </h2><br><p>  La création de composants agnostiques élimine la nécessité de prendre en compte chaque cas particulier.  Dans le même temps, les utilisateurs obtiennent un outil simple pour configurer le composant pour une situation spécifique.  Ces solutions sont faciles à réutiliser.  L'indépendance par rapport au modèle de données rend le code universel, fiable et extensible.  Dans le même temps, nous avons écrit moins de lignes et utilisé principalement les outils angulaires intégrés. </p><br><p>  En utilisant l'approche décrite, vous remarquerez rapidement à quel point il est pratique de penser en termes de contenu plutôt qu'en termes de lignes ou de motifs spécifiques.  Affichage des messages d'erreur de validation, des info-bulles, des fenêtres modales - cette approche est bonne non seulement pour personnaliser l'apparence, mais aussi pour transférer le contenu dans son ensemble.  Esquisser des dispositions et tester la logique est facile!  Par exemple, pour afficher la fenêtre contextuelle, l'utilisateur n'a pas besoin de créer un composant ou même un modèle, vous pouvez simplement passer la chaîne de stub et y revenir plus tard. </p><br><p>  Chez Tinkoff.ru, nous avons depuis longtemps appliqué avec succès l'approche décrite et l'avons déplacée vers une petite bibliothèque open source (1 KB gzip) appelée <strong><em>ng-polymorpheus</em></strong> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">paquet npm</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Démo interactive et sandbox</a> </p><br><blockquote>  Avez-vous aussi quelque chose que vous vouliez mettre en open source, mais êtes-vous effrayé par les corvées associées?  Essayez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Angular Open-source Library Starter</a> , que nous avons conçu pour nos projets.  Il a déjà configuré CI, vérifie les validations, les linters, la génération de CHANGELOG, la couverture des tests et tout ça. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473108/">https://habr.com/ru/post/fr473108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473086/index.html">Comment les logiciels malveillants échappent aux sandbox avec Visual Basic</a></li>
<li><a href="../fr473088/index.html">Le mythe de la liquidité sur le marché du pétrole et de l'or des utilisateurs du sous-sol</a></li>
<li><a href="../fr473090/index.html">PocketBook 632 et 632 Aqua Review - Petits lecteurs phares de 6 pouces avec encre E</a></li>
<li><a href="../fr473092/index.html">AMA avec Habr, # 13: nouvelles importantes pour les utilisateurs et les entreprises</a></li>
<li><a href="../fr473096/index.html">Structures de données avancées. Première partie: graphique acyclique directionnel</a></li>
<li><a href="../fr473114/index.html">Laravel: nous analysons les concepts de base. Troisième partie: la finale</a></li>
<li><a href="../fr473118/index.html">Le logiciel Siemens Digital Industries redéfinit la conception électrique</a></li>
<li><a href="../fr473120/index.html">Le développeur veut aller au démarrage. Que faire à l'employeur?</a></li>
<li><a href="../fr473124/index.html">Comment nous utilisons les chaînes de Markov pour évaluer les solutions et trouver des bogues. Avec le script Python</a></li>
<li><a href="../fr473128/index.html">FutureVSReal - à # X5TechFutureNight</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>