<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∫ üë®üèΩ‚Äç‚öñÔ∏è üë©üèº‚Äç‚úàÔ∏è Caract√©ristiques du filtrage des fen√™tres sur FPGA üì† ü§æüèæ üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! Cet article se concentrera sur une partie importante du traitement num√©rique du signal - le filtrage du signal de fen√™tre, en particul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caract√©ristiques du filtrage des fen√™tres sur FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427361/"> Bonjour √† tous!  Cet article se concentrera sur une partie importante du traitement num√©rique du signal - le filtrage du signal de fen√™tre, en particulier sur les FPGA.  L'article montrera comment concevoir des fen√™tres classiques de longueur standard et des fen√™tres "longues" de 64K √† 16M + √©chantillons.  Le langage de d√©veloppement principal est le VHDL, la base de l'√©l√©ment est les derniers cristaux FPGA Xilinx des derni√®res familles: ce sont Ultrascale, Ultrascale +, 7-series.  L'article montrera l'impl√©mentation de CORDIC - le noyau de base pour configurer les fonctions de fen√™tre de n'importe quelle dur√©e, ainsi que les fonctions de fen√™tre de base.  L'article d√©crit la m√©thode de conception utilisant des langages de haut niveau C / C ++ dans Vivado HLS.  Comme d'habitude, √† la fin de l'article, vous trouverez un lien vers les codes sources du projet. <br><br>  KDPV: un sch√©ma typique de transmission de signal via des n≈ìuds DSP pour des t√¢ches d'analyse de spectre. <br><br><img src="https://habrastorage.org/webt/hq/5j/_l/hq5j_lnsfr_k8oaex-cesewdeyi.png"><br><a name="habracut"></a><br><h3>  Pr√©sentation </h3><br>  Gr√¢ce au cours ¬´Traitement num√©rique du signal¬ª, de nombreuses personnes savent que pour une forme d'onde sinuso√Ødale infinie dans le temps, son spectre est une fonction delta √† la fr√©quence du signal.  En pratique, le spectre d'un signal harmonique limit√© dans le temps r√©el est √©quivalent √† la fonction <b>~ sin (x) / x</b> , et la largeur du lobe principal d√©pend de la dur√©e de l'intervalle d'analyse du signal <b>T.</b>  La limite de temps n'est rien d'autre que la multiplication du signal par une enveloppe rectangulaire.  Il est connu du cours DSP que la multiplication des signaux dans le domaine temporel est une convolution de leurs spectres dans le domaine fr√©quentiel (et vice versa), par cons√©quent, le spectre de l'enveloppe rectangulaire limit√©e du signal harmonique est √©quivalent √† ~ sinc (x).  Cela est √©galement d√ª au fait que nous ne pouvons pas int√©grer le signal sur un intervalle de temps infini, et la transform√©e de Fourier sous forme discr√®te, exprim√©e par une somme finie, est limit√©e par le nombre d'√©chantillons.  En r√®gle g√©n√©rale, la longueur de la FFT dans les appareils de traitement num√©rique FPGA modernes prend des valeurs <b>NFFT</b> de 8 √† plusieurs millions de points.  En d'autres termes, le spectre du signal d'entr√©e est calcul√© sur l'intervalle <b>T</b> , qui dans de nombreux cas est √©gal √† <b>NFFT</b> .  En limitant le signal √† l'intervalle <b>T</b> , on impose ainsi une ¬´fen√™tre¬ª rectangulaire d'une dur√©e de <b>T</b> √©chantillons.  Par cons√©quent, le spectre r√©sultant est le spectre du signal harmonique multipli√© et de l'enveloppe rectangulaire.  Dans les t√¢ches DSP, des fen√™tres de formes diverses ont √©t√© invent√©es depuis longtemps, qui, superpos√©es √† un signal dans le domaine temporel, peuvent am√©liorer ses caract√©ristiques spectrales.  Un grand nombre de fen√™tres diff√©rentes est principalement d√ª √† l'une des principales caract√©ristiques de toute superposition de fen√™tres.  Cette caract√©ristique s'exprime dans la relation entre le niveau des lobes lat√©raux et la largeur du lobe central.  Un sch√©ma bien connu: plus la suppression des lobes lat√©raux est forte, plus le lobe principal est large et vice versa. <br><br>  L'une des applications des fonctions de fen√™tre: d√©tection de signaux faibles sur fond de plus forts en supprimant le niveau des lobes lat√©raux.  Les principales fonctions de la fen√™tre dans les t√¢ches DSP sont une fen√™tre triangulaire, sinuso√Ødale, Lanczos, Hann, Hamming, Blackman, Harris, Blackman-Harris, une fen√™tre √† toit plat, Natall, Gauss, une fen√™tre Kaiser et bien d'autres.  La plupart d'entre eux sont exprim√©s √† travers une s√©rie finie en additionnant des signaux harmoniques avec des poids sp√©cifiques.  Les fen√™tres de forme complexe sont calcul√©es en prenant un exposant (fen√™tre gaussienne) ou une fonction de Bessel modifi√©e (fen√™tre de Kaiser), et ne seront pas prises en compte dans cet article.  Vous pouvez en savoir plus sur les fonctions des fen√™tres dans la litt√©rature, que je donnerai traditionnellement √† la fin de l'article. <br><br>  La figure suivante montre les fonctions de fen√™tre typiques et leurs caract√©ristiques spectrales construites √† l'aide des outils de CAO Matlab. <br><br><img src="https://habrastorage.org/webt/nf/dw/pm/nfdwpmdfjlxbkjx4thfjo3d3wrq.png"><br><br><h3>  Impl√©mentation </h3><br>  Au d√©but de l'article, j'ai ins√©r√© KDPV, qui montre en termes g√©n√©raux un diagramme structurel de la multiplication des donn√©es d'entr√©e par une fonction de fen√™tre.  De toute √©vidence, la fa√ßon la plus simple d'impl√©menter le stockage d'une fonction de fen√™tre dans le FPGA est de l'√©crire en m√©moire (bloc <i>RAMB</i> ou distribu√© <i>distribu√©</i> - cela n'a pas beaucoup d'importance), puis de r√©cup√©rer cycliquement les donn√©es lorsque les √©chantillons d'entr√©e du signal arrivent.  En r√®gle g√©n√©rale, dans les FPGA modernes, la quantit√© de m√©moire interne permet de stocker des fonctions de fen√™tre de tailles relativement petites, qui sont ensuite multipli√©es par les signaux d'entr√©e entrants.  Par petite, je veux dire des fonctions de fen√™tre jusqu'√† 64 Ko d'√©chantillons. <br><br>  Mais que faire si la fonction de fen√™tre est trop longue?  Par exemple, 1M de lectures.  Il est facile de calculer que pour une telle fonction de fen√™tre pr√©sent√©e dans une grille de bits 32 bits, NRAMB = 1024 * 1024 * 32/32768 = 1024 cellules de m√©moire de bloc des cristaux FPGA Xilinx de type RAMB36K sont n√©cessaires.  Et pour 16 millions d'√©chantillons?  16 mille cellules m√©moire!  Pas un seul FPGA moderne n'a autant de m√©moire.  Pour de nombreux FPGA, c'est trop, et dans d'autres cas, c'est une utilisation inutile des ressources FPGA (et, bien s√ªr, de l'argent du client). <br><br>  √Ä cet √©gard, vous devez trouver une m√©thode pour g√©n√©rer des √©chantillons de fonction de fen√™tre directement sur le FPGA √† la vol√©e, sans √©crire les coefficients du p√©riph√©rique distant dans la m√©moire de bloc.  Heureusement, les choses de base ont longtemps √©t√© invent√©es pour nous.  En utilisant un algorithme tel que <b>CORDIC</b> (la m√©thode <i>num√©rique par num√©rique</i> ), il est possible de concevoir de nombreuses fonctions de fen√™tre dont les formules sont exprim√©es en termes de signaux harmoniques (Blackman-Harris, Hann, Hamming, Nattal, etc.) <br><br><h3>  CORDIC </h3><br>  CORDIC est une m√©thode it√©rative simple et pratique pour calculer la rotation d'un syst√®me de coordonn√©es, qui vous permet de calculer des fonctions complexes en effectuant des op√©rations d'addition et de d√©calage primitives.  En utilisant l'algorithme CORDIC, on peut calculer les valeurs des signaux harmoniques sin (x), cos (x), trouver la phase - atan (x) et atan2 (x, y), les fonctions trigonom√©triques hyperboliques, faire pivoter le vecteur, extraire la racine du nombre, etc. <br><br>  Au d√©but, je voulais prendre le noyau CORDIC fini et r√©duire la quantit√© de travail, mais j'ai une longue aversion pour les noyaux Xilinx.  Apr√®s avoir √©tudi√© les r√©f√©rentiels sur le github, j'ai r√©alis√© que tous les c≈ìurs pr√©sent√©s ne conviennent pas pour un certain nombre de raisons (mal document√©s et illisibles, non universels, con√ßus pour une t√¢che sp√©cifique ou une base d'√©l√©ments, <s>√©crits en verilog</s> , etc.).  Ensuite, j'ai demand√© au camarade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Lazifo</a> de faire ce travail pour moi.  Bien s√ªr, il s'en est occup√©, car la mise en ≈ìuvre de CORDIC est l'une des t√¢ches les plus simples dans le domaine des DSP.  Mais comme je suis impatient, parall√®lement √† son travail, j'ai √©crit <s>mon v√©lo avec</s> mon <s>propre</s> noyau param√©tr√©.  Les principales caract√©ristiques sont la profondeur de bits configurable des signaux de sortie <b>DATA_WIDTH</b> et la phase d'entr√©e normalis√©e <b>PHASE_WIDTH</b> de -1 √† 1, et la pr√©cision des calculs de <b>PRECISION</b> .  Le c≈ìur CORDIC est ex√©cut√© selon le circuit parall√®le du pipeline - √† chaque cycle d'horloge, le c≈ìur est pr√™t √† effectuer des calculs et √† recevoir des √©chantillons d'entr√©e.  Le noyau passe N cycles pour calculer l'√©chantillon de sortie, dont le nombre d√©pend de la capacit√© des √©chantillons de sortie (plus la capacit√© est grande, plus il y a d'it√©rations pour calculer la valeur de sortie).  Tous les calculs se font en parall√®le.  Ainsi, CORDIC est le noyau de base pour cr√©er des fonctions de fen√™tre. <br><br><h3>  Fonctions de fen√™tre </h3><br>  Dans le cadre de cet article, je ne r√©alise que les fonctions de fen√™tre qui s'expriment √† travers des signaux harmoniques (Hann, Hamming, Blackman-Harris de divers ordres, etc.).  Que faut-il pour cela?  En termes g√©n√©raux, la formule de construction d'une fen√™tre ressemble √† une s√©rie de longueur finie. <br><br><img src="https://habrastorage.org/webt/it/ih/tg/itihtgetk0lxnpoavnivrrot0ou.png"><br><br>  Un certain ensemble de coefficients <b>a <sub>k</sub></b> et de membres de la s√©rie d√©termine le nom de la fen√™tre.  La fen√™tre Blackman-Harris la plus populaire et la plus utilis√©e est d'ordre diff√©rent (de 3 √† 11).  Voici un tableau des coefficients pour les fen√™tres Blackman-Harris: <br><br><img src="https://habrastorage.org/webt/fy/ss/_4/fyss_4cniul5oacholwxdvxfhli.jpeg"><br><br>  En principe, l'ensemble de fen√™tres Blackman-Harris est applicable √† de nombreux probl√®mes d'analyse spectrale, et il n'est pas n√©cessaire d'essayer d'utiliser des fen√™tres complexes telles que Gauss ou Kaiser.  Les fen√™tres nattales ou √† toit plat ne sont qu'une vari√©t√© de fen√™tres avec des poids diff√©rents, mais les m√™mes principes de base que Blackman-Harris.  On sait que plus il y a de membres de la s√©rie, plus la suppression du niveau des lobes lat√©raux est forte (sous r√©serve d'un choix raisonnable de la profondeur de bits de la fonction fen√™tre).  En fonction de la t√¢che, le d√©veloppeur n'a qu'√† choisir le type de fen√™tres utilis√©es. <br><br><h3>  Impl√©mentation FPGA - approche traditionnelle </h3><br>  Tous les noyaux des fonctions de fen√™tre sont con√ßus en utilisant l'approche classique pour d√©crire les circuits num√©riques dans les FPGA et sont √©crits en langage VHDL.  Voici une liste des composants fabriqu√©s: <br><br><ul><li>  <i>bh_win_7term</i> - Blackman-Harris 7 order, une fen√™tre avec suppression maximale des √©chafaudages lat√©raux. </li><li>  <i>bh_win_5term</i> - <i>Commande</i> Blackman-Harris 5, comprend une fen√™tre avec un dessus plat. </li><li>  <i>bh_win_4term</i> - Blackman-Harris 4 commandes, comprend les fen√™tres Nattal et Blackman-Nattal. </li><li>  <i>bh_win_3term</i> - Blackman-Harris 3 commandes, </li><li>  <i>hamming_win</i> - <i>Fen√™tres</i> Hamming et Hann. </li></ul><br>  Le code source du composant de fen√™tre Blackman-Harris est de 3 ordres de grandeur: <br><br><pre><code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">entity</span></span> bh_win_3term <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span> ( TD : <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>:=<span class="hljs-number"><span class="hljs-number">0.5</span></span>ns; <span class="hljs-comment"><span class="hljs-comment">--! Time delay PHI_WIDTH : integer:=10; --! Signal period = 2^PHI_WIDTH DAT_WIDTH : integer:=16; --! Output data width XSERIES : string:="ULTRA" --! for 6/7 series: "7SERIES"; for ULTRASCALE: "ULTRA"; ); port ( RESET : in std_logic; --! Global reset CLK : in std_logic; --! System clock AA0 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A0 AA1 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A1 AA2 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A2 ENABLE : in std_logic; --! Clock enable DT_WIN : out std_logic_vector(DAT_WIDTH-1 downto 0); --! Output DT_VLD : out std_logic --! Output data valid ); end bh_win_3term;</span></span></code> </pre> <br>  Dans certains cas, j'ai utilis√© la biblioth√®que <i>UNISIM</i> pour incorporer les <b>n≈ìuds DSP48E1 et DSP48E2</b> dans le projet, ce qui <b>me</b> permet finalement d'augmenter la vitesse des calculs en raison du pipelining √† l'int√©rieur de ces blocs, mais comme l'a montr√© la pratique, il est plus rapide et plus facile de donner libre cours et d'√©crire quelque chose comme <b>P = A * B + C</b> et sp√©cifiez les directives suivantes dans le code: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> USE_DSP <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> &lt;signal_name&gt;: <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">"YES"</span></span>;</code> </pre> <br>  Cela fonctionne bien et d√©finit de mani√®re rigide le type d'√©l√©ment sur lequel la fonction math√©matique est impl√©ment√©e pour le synth√©tiseur. <br><br><h3>  Vivado hls </h3><br>  De plus, j'ai impl√©ment√© tous les c≈ìurs √† l'aide des outils <b>Vivado HLS</b> .  Je vais √©num√©rer les principaux <b>avantages de</b> Vivado HLS: haute vitesse de conception ( <i>time-to-market</i> ) dans les langages de haut niveau C ou C ++, mod√©lisation rapide des n≈ìuds d√©velopp√©s en raison de l'absence d'un concept de fr√©quence d'horloge, configuration flexible des solutions (en termes de ressources et de performances) en introduisant pragmas et directives dans le projet, ainsi qu'un seuil d'entr√©e bas pour les d√©veloppeurs dans les langages de haut niveau.  Le principal inconv√©nient est le co√ªt sous-optimal des ressources FPGA par rapport √† l'approche classique.  De plus, il n'est pas possible d'atteindre les vitesses fournies par les anciennes m√©thodes RTL classiques (VHDL, Verilog, SV).  Eh bien, le plus gros <b>inconv√©nient</b> est de danser avec un tambourin, mais cela est caract√©ristique de tous les CAD de Xilinx.  (Remarque: dans le d√©bogueur Vivado HLS et dans le mod√®le C ++ r√©el, des r√©sultats souvent diff√©rents ont √©t√© obtenus, car Vivado HLS fonctionne de mani√®re tordue en utilisant les avantages de <i>la pr√©cision arbitraire</i> ). <br><br>  L'image suivante montre le journal du noyau CORDIC synth√©tis√© dans Vivado HLS.  Il est assez informatif et affiche de nombreuses informations utiles: la quantit√© de ressources utilis√©es, l'interface utilisateur du noyau, les boucles et leurs propri√©t√©s, le retard dans le calcul, l'intervalle de calcul de la valeur de sortie (important lors de la conception de circuits s√©rie et parall√®les): <br><br><img src="https://habrastorage.org/webt/oe/e3/zh/oee3zhonsadxnqugfhd8geg7hca.png"><br><br>  Vous pouvez √©galement voir comment calculer les donn√©es dans divers composants (fonctions).  On peut voir qu'√† la phase z√©ro, les donn√©es de phase sont lues et aux √©tapes 7 et 8, le r√©sultat du n≈ìud CORDIC est affich√©. <br><img src="https://habrastorage.org/webt/kw/nf/j7/kwnfj7uftmtnnv6iaxoecjvji1g.png"><br><br>  Le r√©sultat de Vivado HLS: un noyau RTL synth√©tis√© cr√©√© √† partir de code C.  Le journal montre que dans l'analyse de temps, le noyau r√©ussit toutes les restrictions: <br><br><img src="https://habrastorage.org/webt/83/tb/hw/83tbhwy9j5jqkgn2tdz697dz-na.png"><br><br>  Un autre gros avantage de Vivado HLS est que pour v√©rifier le r√©sultat, elle fait elle-m√™me un banc d'essai du code RTL synth√©tis√© bas√© sur le mod√®le qui a √©t√© utilis√© pour v√©rifier le code C.  Cela peut √™tre un test primitif, mais je pense qu'il est tr√®s cool et assez pratique pour comparer le fonctionnement de l'algorithme en C et en HDL.  Ci-dessous, une capture d'√©cran de Vivado montrant une simulation du mod√®le de fonction de noyau d'une fonction de fen√™tre obtenue par Vivado HLS: <br><br><img src="https://habrastorage.org/webt/6q/zw/3m/6qzw3mcmm6xixm-wh9kpumqpzx8.png"><br><br>  Ainsi, pour toutes les fonctions de fen√™tre, des r√©sultats similaires ont √©t√© obtenus, quelle que soit la m√©thode de conception - en VHDL ou en C ++.  Cependant, dans le premier cas, une plus grande fr√©quence de fonctionnement et un plus petit nombre de ressources sont atteints, et dans le second cas, la vitesse de conception maximale est atteinte.  Les deux approches ont droit √† la vie. <br><br>  J'ai calcul√© pr√©cis√©ment combien de temps je consacrerais au d√©veloppement en utilisant diff√©rentes m√©thodes.  J'ai impl√©ment√© un projet C ++ dans Vivado HLS ~ 12 fois plus rapidement qu'en VHDL. <br><br><h3>  Comparaison des approches </h3><br>  Comparez le code source pour HDL et C ++ pour le noyau CORDIC.  L'algorithme, comme cela a √©t√© dit pr√©c√©demment, est bas√© sur les op√©rations d'addition, de soustraction et de d√©calage.  Sur VHDL, cela ressemble √† ceci: il y a trois vecteurs de donn√©es - l'un est responsable de la rotation de l'angle, et les deux autres d√©terminent la longueur du vecteur le long des axes X et Y, ce qui √©quivaut √† sin et cos (voir l'image du wiki): <br><br><img src="https://habrastorage.org/webt/ab/3w/hv/ab3whvtkvcgl-ycqnkz3mjzr0lk.png"><br><br>  En calculant it√©rativement la valeur Z, les valeurs X et Y sont calcul√©es en parall√®le. Le processus de recherche cyclique des valeurs de sortie sur HDL: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> ROM_LUT : rom_array := ( x<span class="hljs-string"><span class="hljs-string">"400000000000"</span></span>, x<span class="hljs-string"><span class="hljs-string">"25C80A3B3BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"13F670B6BDC7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0A2223A83BBB"</span></span>, x<span class="hljs-string"><span class="hljs-string">"05161A861CB1"</span></span>, x<span class="hljs-string"><span class="hljs-string">"028BAFC2B209"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0145EC3CB850"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00A2F8AA23A9"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00517CA68DA2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0028BE5D7661"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00145F300123"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000A2F982950"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000517CC19C0"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00028BE60D83"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000145F306D6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000A2F9836D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000517CC1B7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000028BE60DC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000145F306E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000A2F9837"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000517CC1B"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000028BE60E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000145F307"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000A2F983"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000517CC2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000028BE61"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000145F30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000A2F98"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000517CC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000028BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000145F3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000A2FA"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000517D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000028BE"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000145F"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000A30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000518"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000028C"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000146"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000000A3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000051"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000029"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000014"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000000A"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000005"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000003"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000001"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000000"</span></span> ); pr_crd: <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(clk, reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reset = <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">---- Reset sine / cosine / angle vector ---- sigX &lt;= (others =&gt; (others =&gt; '0')); sigY &lt;= (others =&gt; (others =&gt; '0')); sigZ &lt;= (others =&gt; (others =&gt; '0')); elsif rising_edge(clk) then sigX(0) &lt;= init_x; sigY(0) &lt;= init_y; sigZ(0) &lt;= init_z; ---- calculate sine &amp; cosine ---- lpXY: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigX(ii+1) &lt;= sigX(ii) + sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) - sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); else sigX(ii+1) &lt;= sigX(ii) - sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) + sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); end if; end loop; ---- calculate phase ---- lpZ: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigZ(ii+1) &lt;= sigZ(ii) + ROM_TABLE(ii); else sigZ(ii+1) &lt;= sigZ(ii) - ROM_TABLE(ii); end if; end loop; end if; end process;</span></span></code> </pre><br>  En C ++, dans Vivado HLS, le code est presque identique, mais l'enregistrement est plusieurs fois plus court: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Unrolled loop // int k; stg: for (k = 0; k &lt; NWIDTH; k++) { #pragma HLS UNROLL if (z[k] &lt; 0) { x[k+1] = x[k] + (y[k] &gt;&gt; k); y[k+1] = y[k] - (x[k] &gt;&gt; k); z[k+1] = z[k] + lut_angle[k]; } else { x[k+1] = x[k] - (y[k] &gt;&gt; k); y[k+1] = y[k] + (x[k] &gt;&gt; k); z[k+1] = z[k] - lut_angle[k]; } }</span></span></code> </pre><br><br>  Apparemment, le m√™me cycle avec d√©calage et ajouts est utilis√©.  Cependant, par d√©faut, toutes les boucles dans Vivado HLS sont ¬´r√©duites¬ª et ex√©cut√©es s√©quentiellement, comme pr√©vu pour le langage C ++.  L'introduction du <b>pragma HLS UNROLL</b> ou <b>HLS PIPELINE</b> convertit les calculs s√©rie en parall√®le.  Cela conduit √† une augmentation des ressources FPGA, cependant, il vous permet de calculer et de soumettre de nouvelles valeurs au c≈ìur √† chaque cycle d'horloge. <br><br>  Les r√©sultats de la synth√®se du projet en VHDL et C ++ sont pr√©sent√©s dans la figure ci-dessous.  Comme vous pouvez le voir, logiquement, la diff√©rence est deux fois en faveur de l'approche traditionnelle.  Pour d'autres ressources FPGA, l'√©cart est insignifiant.  Je n'ai pas approfondi l'optimisation du projet en C ++, mais sans ambigu√Øt√© en d√©finissant diverses directives ou en modifiant partiellement le code, le nombre de ressources utilis√©es peut √™tre r√©duit.  Dans les deux cas, les synchronisations ont converg√© pour une fr√©quence centrale donn√©e de ~ 350 MHz. <br><img src="https://habrastorage.org/webt/lp/id/ic/lpidicvwz-edguptklqfahlo0ya.png"><br><br><h3>  Caract√©ristiques d'impl√©mentation </h3><br>  √âtant donn√© que les calculs sont effectu√©s dans un format √† virgule fixe, les fonctions de fen√™tre ont un certain nombre de fonctionnalit√©s qui doivent √™tre prises en compte lors de la conception de syst√®mes DSP sur FPGA.  Par exemple, plus la profondeur de bits des donn√©es de fonction de fen√™tre est grande, meilleure est la pr√©cision de la superposition de fen√™tre.  D'un autre c√¥t√©, avec une profondeur de bits insuffisante de la fonction de fen√™tre, des distorsions seront introduites dans la forme d'onde r√©sultante, ce qui affectera la qualit√© des caract√©ristiques spectrales.  Par exemple, une fonction de fen√™tre doit avoir au moins 20 bits lorsqu'elle est multipli√©e par un signal d'une dur√©e de 2 ^ 20 = 1M d'√©chantillons. <br><br><h3>  Conclusion </h3><br>  Cet article montre une fa√ßon de concevoir des fonctions de fen√™tre sans utiliser de m√©moire externe ou de m√©moire de bloc FPGA.  La m√©thode d'utilisation exclusive des ressources logiques des FPGA (et dans certains cas des blocs DSP) est donn√©e.  En utilisant l'algorithme CORDIC, il est possible d'obtenir des fonctions de fen√™tre de n'importe quelle profondeur de bit (dans des limites raisonnables), de n'importe quelle longueur et ordre, et donc d'avoir un ensemble de pratiquement toutes les caract√©ristiques spectrales de la fen√™tre. <br><br>  Dans le cadre de l'une des √©tudes, j'ai r√©ussi √† obtenir un noyau fonctionnant de mani√®re stable de la fonction de fen√™tre Blackman-Harris de 5 et 7 ordres de grandeur sur des √©chantillons de 1 M √† une fr√©quence de ~ 375 MHz, et √©galement √† cr√©er un g√©n√©rateur de coefficients rotatifs pour une FFT bas√©e sur CORDIC √† une fr√©quence de ~ 400 MHz.  Cristal FPGA utilis√©: Kintex Ultrascale + (xcku11p-ffva1156-2-e). <br><br>  Lien vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le projet <b>github</b> ici</a> .  Le projet contient un mod√®le math√©matique dans Matlab, des codes sources pour les fonctions de fen√™tre et CORDIC en VHDL, ainsi que des mod√®les des fonctions de fen√™tre r√©pertori√©es en C ++ pour Vivado HLS. <br><br><h3>  Articles utiles </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctions de la fen√™tre DSPLib</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Certaines fonctions de la fen√™tre DSPlib</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wiki de filtrage de fen√™tre √©tendu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article wiki sur CORDIC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vivado HLS Userguide</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'article sur l'analyse spectrale sur le Habr</a> </li></ul><br>  Je conseille √©galement un livre tr√®s populaire sur DSP - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ayficher E., Jervis B. Digital signal processing.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Approche pratique</a> <br><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427361/">https://habr.com/ru/post/fr427361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427351/index.html">Semaine de s√©curit√© 40: vuln√©rabilit√©s dans CMS Drupal et plus</a></li>
<li><a href="../fr427353/index.html">Spectacle de drones: comment nous avons coordonn√© un essaim d'h√©licopt√®res danseurs</a></li>
<li><a href="../fr427355/index.html">Compilation CJM, comp√©tences cl√©s du directeur artistique et compr√©hension des utilisateurs</a></li>
<li><a href="../fr427357/index.html">√âcriture de shaders dans Unity. GrabPass, PerRendererData</a></li>
<li><a href="../fr427359/index.html">Comment ECS, C # Job System et SRP changent d'architecture</a></li>
<li><a href="../fr427363/index.html">Impl√©mentation de LoRaWAN dans une entreprise agricole. Tout sur la construction, le lancement et les solutions</a></li>
<li><a href="../fr427365/index.html">Rapport de RedSlerm sur la surveillance (Monit, Zabbix)</a></li>
<li><a href="../fr427367/index.html">Conf√©rence BLACK HAT USA. Comment un pirate hollywoodien utilise des cam√©ras de surveillance. Partie 1</a></li>
<li><a href="../fr427369/index.html">Conf√©rence BLACK HAT USA. Comment un pirate hollywoodien utilise des cam√©ras de surveillance. 2e partie</a></li>
<li><a href="../fr427371/index.html">Cours vid√©o "Fondamentaux du travail avec les notations BPMN." Gratuit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>