<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍❤️‍💋‍👨 👨🏾‍🌾 😗 Konektivitas rendah, arsitektur, dan organisasi tim 🚄 📊 👨‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan artikel disiapkan khusus untuk siswa kursus Praktek dan Alat DevOps . 



 Artikel ini membahas hubungan antara struktur kode dan struktur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konektivitas rendah, arsitektur, dan organisasi tim</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/475980/">  <i>Terjemahan artikel disiapkan khusus untuk siswa kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktek dan Alat DevOps</a> .</i> <br><br><img src="https://habrastorage.org/webt/7w/ik/zi/7wikzim_t6aovrjziyxtoiklmta.png"><br><hr><br>  Artikel ini membahas hubungan antara struktur kode dan struktur organisasi dalam pengembangan perangkat lunak.  Saya membahas mengapa perangkat lunak dan tim tidak dapat mengukur dengan mudah, pelajaran apa yang dapat kita lihat di alam dan Internet, dan menunjukkan bagaimana kita dapat mengurangi konektivitas perangkat lunak dan tim untuk mengatasi masalah penskalaan. <br><a name="habracut"></a><br>  Artikel ini didasarkan pada pengalaman saya selama 20 tahun dalam menciptakan sistem perangkat lunak besar dan pada kesan buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Percepat: Ilmu Perangkat Lunak Lean dan DevOps: Membangun dan Memperbesar Organisasi Teknologi Berkinerja Tinggi"</a> (Nicole Forsgren, Jez Humble dan Gene Kim), yang bukti penelitian untuk mendukung sebagian besar klaim saya di sini.  Buku ini sangat disarankan untuk dibaca. <br><br><img src="https://habrastorage.org/webt/tw/l1/_q/twl1_qravregb6hyfvoyc9uhjpm.jpeg"><br><br><h3>  Perangkat lunak dan perintah tidak berskala </h3><br>  Seringkali rilis pertama, mungkin ditulis oleh satu atau dua orang, ternyata sangat sederhana.  Mungkin memiliki fungsi terbatas, tetapi ditulis dengan cepat dan memenuhi persyaratan pelanggan.  Interaksi dengan pelanggan pada tahap ini sangat baik, karena pelanggan biasanya berhubungan langsung dengan pengembang.  Setiap bug diperbaiki dengan cepat, dan fitur baru dapat ditambahkan tanpa rasa sakit.  Setelah beberapa saat, langkahnya melambat.  Versi 2.0 membutuhkan waktu yang lebih lama dari yang diharapkan.  Lebih sulit untuk memperbaiki bug, dan fitur baru diberikan, itu tidak begitu sederhana.  Jawaban alami untuk ini adalah menambahkan pengembang baru ke tim.  Meskipun tampaknya setiap karyawan tambahan yang ditambahkan ke tim mengurangi produktivitas.  Ada perasaan bahwa ketika kompleksitas perangkat lunak tumbuh, ia berhenti berkembang.  Dalam kasus ekstrim, organisasi mungkin menemukan bahwa mereka menggunakan program dengan dukungan yang sangat mahal yang hampir tidak mungkin untuk melakukan perubahan.  Masalahnya adalah Anda tidak perlu membuat "kesalahan" untuk mewujudkannya.  Sangat umum sehingga dapat dikatakan bahwa ini adalah properti “alami” dari perangkat lunak. <br><br>  Mengapa ini terjadi?  Ada dua alasan: yang terkait dengan kode dan tim.  Baik kode dan perintah tidak skala dengan baik. <br><br>  Ketika basis kode bertambah, semakin sulit bagi satu orang untuk memahaminya.  Ada batasan kognitif tetap seseorang.  Dan, meskipun, satu orang dapat mengingat rincian sistem kecil, tetapi hanya sampai itu menjadi lebih dari jangkauan kognitifnya.  Begitu sebuah tim tumbuh menjadi lima orang atau lebih, hampir mustahil bagi satu orang untuk menyadari bagaimana semua bagian dari sistem bekerja.  Dan ketika tidak ada yang mengerti keseluruhan sistem, ketakutan muncul.  Dalam sistem yang besar dan berpasangan ketat, sangat sulit untuk memahami efek dari setiap perubahan yang signifikan, karena hasilnya tidak terlokalisasi.  Untuk meminimalkan dampak perubahan, pengembang mulai menggunakan solusi dan duplikasi kode alih-alih mengidentifikasi fitur umum, membuat abstraksi dan generalisasi.  Ini semakin memperumit sistem, memperkuat tren negatif ini.  Pengembang tidak lagi merasa bertanggung jawab atas kode yang tidak mereka pahami dan enggan melakukan refactoring.  Utang teknis tumbuh.  Ini juga membuat pekerjaan menjadi tidak menyenangkan dan tidak memuaskan dan merangsang "bakat menguras" ketika pengembang terbaik pergi yang dapat dengan mudah menemukan pekerjaan di tempat lain. <br><br>  Tim juga tidak berskala.  Seiring pertumbuhan tim, komunikasi menjadi lebih kompleks.  Formula sederhana mulai digunakan: <br><br> <code>c = n(n-1)/2</code> <br> <br>  <i>(di mana n adalah jumlah orang, dan c adalah jumlah koneksi yang mungkin antara anggota tim)</i> <br><br><div class="scrollable-table"><table><tbody><tr><td>  jumlah anggota tim </td><td>  jumlah koneksi yang memungkinkan </td></tr><tr><td>  1 </td><td>  0 </td></tr><tr><td>  2 </td><td>  1 </td></tr><tr><td>  5 </td><td>  10 </td></tr><tr><td>  10 </td><td>  45 </td></tr><tr><td>  100 </td><td>  4950 </td></tr></tbody></table></div><br><br>  Ketika timnya tumbuh, kebutuhannya akan komunikasi dan koordinasi tumbuh secara eksponensial.  Jika tim tertentu terlampaui, sangat sulit bagi satu tim untuk tetap menjadi struktur yang tidak terpisahkan, dan kecenderungan sosial manusia yang alami untuk membaginya menjadi kelompok-kelompok yang lebih kecil akan mengarah pada pembentukan subkelompok informal, bahkan jika manajemen tidak mengambil bagian di dalamnya.  Komunikasi dengan kolega menjadi lebih sulit dan secara alami akan digantikan oleh pemimpin baru dan komunikasi top-down.  Anggota tim ditransformasikan dari rekan kerja dalam sistem menjadi pekerja produksi reguler.  Motivasi menderita, tidak ada rasa memiliki karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">efek difusi tanggung jawab</a> . <br><br>  Manajemen sering melakukan intervensi pada tahap ini dan secara formal mendekati pembentukan tim baru dan struktur manajemen.  Tetapi, tidak masalah secara formal atau informal, sulit bagi organisasi besar untuk mempertahankan motivasi dan minat. <br><br>  Biasanya pengembang yang tidak berpengalaman dan manajemen yang buruk menyalahkan patologi penskalaan ini.  Tapi ini tidak adil.  Masalah penskalaan adalah properti “alami” dari perangkat lunak yang tumbuh dan berkembang.  Inilah yang selalu terjadi jika Anda tidak menemukan masalah pada tahap awal, tidak memahami titik penyimpangan, dan tidak berusaha untuk memecahkan masalah.  Tim pengembangan perangkat lunak terus-menerus diciptakan, jumlah perangkat lunak di dunia terus berkembang, dan sebagian besar perangkat lunak relatif kecil.  Oleh karena itu, cukup sering, produk yang sukses dan berkembang dibuat oleh tim yang tidak memiliki pengalaman dalam pengembangan skala besar.  Dan itu tidak realistis untuk mengharapkan pengembang untuk mengenali titik belok dan memahami apa yang harus dilakukan ketika masalah skala mulai terwujud. <br><br><h3>  Pelajaran Penskalaan Alam </h3><br>  Baru-baru ini saya membaca buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Skala” Geoffrey Barat yang luar biasa</a> .  Ini berbicara tentang matematika skala dalam sistem biologis dan sosial ekonomi.  Tesisnya adalah bahwa semua sistem besar yang kompleks mematuhi hukum dasar skala.  Ini adalah bacaan yang menarik dan saya sangat merekomendasikannya.  Dalam artikel ini, saya ingin fokus pada sudut pandangnya bahwa banyak sistem biologis dan skala sosial mengejutkan dengan sangat baik.  Lihatlah tubuh mamalia.  Semua mamalia memiliki jenis sel yang sama, struktur tulang, sistem saraf dan peredaran darah.  Namun, perbedaan ukuran antara mouse dan paus biru adalah sekitar 10 ^ 7.  Bagaimana alam menggunakan bahan dan struktur yang sama untuk organisme dengan ukuran yang berbeda?  Jawabannya tampaknya bahwa evolusi telah menemukan struktur bercabang fraktal.  Lihatlah pohon itu.  Setiap bagiannya terlihat seperti pohon kecil.  Hal yang sama berlaku untuk sistem peredaran darah dan sistem saraf mamalia, mereka adalah jaringan fraktal bercabang di mana sebagian kecil paru-paru atau pembuluh darah Anda tampak seperti versi yang lebih kecil dari keseluruhan. <br><br><img src="https://habrastorage.org/webt/fn/h8/fh/fnh8fhg3914dqtibtecvi6fvn8k.jpeg"><br><br>  Bisakah kita mengambil ide-ide ini dari alam dan menerapkannya pada perangkat lunak?  Saya pikir kita bisa belajar pelajaran penting.  Jika kita dapat membangun sistem besar yang terdiri dari bagian-bagian kecil yang kelihatannya seperti sistem lengkap, akan mungkin untuk mengandung patologi yang mempengaruhi sebagian besar program saat mereka tumbuh dan berkembang. <br><br>  Apakah ada sistem perangkat lunak yang berhasil menskalakan berdasarkan beberapa urutan besarnya?  Jawabannya jelas - Internet, sistem perangkat lunak global dengan jutaan node.  Subnet benar-benar terlihat dan berfungsi seperti versi yang lebih kecil dari seluruh Internet. <br><br><h3>  Tanda-tanda perangkat lunak yang digabungkan secara longgar </h3><br>  Kemampuan untuk menyorot komponen yang digabungkan secara individu dalam sistem besar adalah metode utama untuk penskalaan yang sukses.  Internet, pada kenyataannya, adalah contoh dari arsitektur yang digabungkan secara longgar.  Ini berarti bahwa setiap node, layanan atau aplikasi di jaringan memiliki sifat-sifat berikut: <br><br><ul><li>  Protokol komunikasi yang umum digunakan. </li><li>  Data ditransfer menggunakan kontrak yang jelas dengan node lain. </li><li>  Komunikasi tidak memerlukan pengetahuan tentang teknologi implementasi spesifik. </li><li>  Versi dan penerapannya independen. </li></ul><br>  Internet scalable karena merupakan jaringan node yang berkomunikasi melalui seperangkat protokol yang terdefinisi dengan baik.  Node berinteraksi hanya dengan protokol, detail implementasi yang tidak boleh diketahui untuk berinteraksi node.  Internet global tidak digunakan sebagai satu sistem.  Setiap node memiliki versi dan prosedur penyebaran di dalamnya.  Masing-masing node muncul dan menghilang secara independen satu sama lain.  Ketundukan pada protokol internet adalah satu-satunya hal yang sangat penting bagi keseluruhan sistem.  Siapa yang membuat setiap situs, ketika dibuat atau dihapus, versi apa yang dimilikinya, teknologi dan platform spesifik apa yang digunakannya, semua ini tidak ada hubungannya dengan Internet secara keseluruhan.  Inilah yang kami maksud dengan perangkat lunak yang digabungkan secara longgar. <br><br><h3>  Tanda-tanda organisasi yang digabungkan secara longgar </h3><br>  Kami dapat mengukur tim dengan mengikuti prinsip yang sama: <br><br><ul><li>  Setiap sub-tim harus terlihat seperti organisasi pengembangan perangkat lunak kecil. </li><li>  Proses internal dan komunikasi tim tidak boleh melampaui tim. </li><li>  Teknologi dan proses yang digunakan untuk mengimplementasikan perangkat lunak tidak boleh didiskusikan di luar tim. </li><li>  Tim harus berkomunikasi satu sama lain hanya pada masalah eksternal: protokol umum, fungsionalitas, tingkat layanan, dan sumber daya. </li></ul><br>  Tim pengembangan kecil lebih efektif daripada yang besar, jadi Anda perlu memecah tim besar menjadi kelompok yang lebih kecil.  Pelajaran dari alam dan Internet adalah bahwa subkelompok harus terlihat seperti organisasi pengembangan perangkat lunak kecil.  Seberapa kecil mereka?  Idealnya, dari satu hingga lima orang. <br><br>  Yang penting adalah bahwa setiap tim terlihat seperti organisasi pengembangan perangkat lunak kecil yang independen.  Cara lain untuk mengatur tim kurang efektif.  Seringkali ada godaan untuk membagi tim besar menjadi beberapa fungsi.  Oleh karena itu, kami memiliki tim arsitek, tim pengembangan, tim DBA, tim penguji, tim penempatan, dan tim pendukung, tetapi ini tidak menyelesaikan masalah penskalaan yang kita bicarakan di atas.  Semua tim harus berpartisipasi dalam pengembangan fitur dan sering iteratif jika Anda ingin menghindari manajemen proyek dengan gaya air terjun. <br><br>  Hambatan komunikasi antara tim fungsional ini menjadi hambatan utama untuk pengiriman yang efisien dan tepat waktu.  Tim terhubung erat karena mereka perlu berbagi detail internal penting untuk bekerja bersama.  Selain itu, minat tim yang berbeda tidak sesuai: pengembang biasanya menerima penghargaan untuk fitur baru, penguji kualitas, dukungan untuk stabilitas.  Kepentingan yang berbeda ini dapat menyebabkan konflik dan hasil yang buruk.  Mengapa pengembang harus khawatir tentang log jika mereka tidak pernah membacanya?  Mengapa penguji harus peduli dengan pengiriman jika mereka bertanggung jawab atas kualitas? <br><br>  Sebagai gantinya, kita harus mengatur tim untuk layanan yang digabungkan secara longgar yang mendukung fungsi bisnis, atau untuk sekelompok fungsi logis.  Setiap sub-perintah harus merancang, kode, menguji, menyebarkan dan memelihara perangkat lunaknya sendiri.  Kemungkinan besar, anggota tim semacam itu akan menjadi spesialis dari profil yang luas, dan bukan spesialis yang sempit, karena dalam tim kecil akan diperlukan untuk memisahkan peran-peran ini.  Mereka harus fokus pada otomatisasi proses semaksimal mungkin: pengujian otomatis, penerapan, pemantauan.  Tim harus memilih alat mereka sendiri dan merancang arsitektur untuk sistem mereka.  Meskipun protokol yang digunakan untuk interaksi layanan harus ditentukan di tingkat organisasi, pilihan alat yang digunakan untuk mengimplementasikannya harus didelegasikan kepada tim.  Dan itu sangat cocok dengan model DevOps. <br><br>  Tingkat kemandirian suatu tim adalah cerminan dari tingkat keterhubungan seluruh organisasi.  Idealnya, organisasi harus menjaga fungsionalitas perangkat lunak dan, pada akhirnya, nilai bisnis yang disediakan oleh tim, serta biaya sumber daya tim. <br><br>  Dalam hal ini, arsitek perangkat lunak memainkan peran penting.  Seharusnya tidak fokus pada alat dan teknologi spesifik yang digunakan tim, atau mengganggu detail arsitektur internal layanan.  Sebaliknya, ia harus fokus pada protokol dan interaksi antara berbagai layanan dan kesehatan sistem secara keseluruhan. <br><br><h3>  Hukum Terbalik Conway: Struktur Organisasi Harus Memodelkan Arsitektur Target </h3><br>  Bagaimana koherensi perangkat lunak yang lemah dan koherensi tim yang lemah cocok bersama?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hukum Conway</a> menyatakan: <br><blockquote>  <i>"Organisasi yang merancang sistem terbatas pada desain yang meniru struktur komunikasi organisasi ini."</i> </blockquote><br>  Ini didasarkan pada pengamatan bahwa arsitektur sistem perangkat lunak akan mencerminkan struktur organisasi yang menciptakannya.  Kami dapat "meretas" hukum Conway dengan membaliknya.  Atur tim kami untuk mencerminkan arsitektur yang kami inginkan.  Dengan mengingat hal ini, kita harus menyelaraskan tim yang digabungkan secara longgar dengan komponen perangkat lunak yang digabungkan secara longgar.  Tetapi haruskah itu hubungan satu-ke-satu?  Saya pikir, idealnya, ya.  Meskipun tampaknya baik jika tim kecil bekerja pada beberapa layanan yang digabungkan secara longgar.  Saya akan mengatakan bahwa titik belok untuk penskalaan lebih besar untuk tim daripada perangkat lunak, sehingga gaya organisasi ini tampaknya dapat diterima.  Penting agar komponen perangkat lunak tetap terpisah, dengan versi dan penyebarannya sendiri, bahkan jika beberapa di antaranya dikembangkan oleh satu tim.  Kami ingin dapat membagi tim jika terlalu besar, dengan transfer layanan yang dikembangkan ke tim yang berbeda.  Tetapi kami tidak dapat melakukan ini jika layanan digabungkan dengan erat atau berbagi proses, versi, atau penyebaran. <br><br>  Kita harus menghindari pekerjaan beberapa tim pada komponen yang sama.  Ini adalah pola anti.  Dan, dalam arti tertentu, bahkan lebih buruk daripada pekerjaan satu tim besar dengan satu basis kode besar, karena hambatan komunikasi antara tim menyebabkan perasaan yang lebih kuat yaitu kurangnya kepemilikan dan kontrol. <br><br><img src="https://habrastorage.org/webt/mj/z9/nl/mjz9nlpipokz7va4jnxhkeoygfk.png"><br><br>  Interaksi antara tim yang digabungkan secara longgar membuat perangkat lunak yang digabungkan secara longgar diminimalkan.  Ambil contoh Internet lagi.  Seringkali Anda dapat menggunakan API yang disediakan oleh perusahaan lain tanpa komunikasi langsung dengannya (jika prosesnya sederhana dan ada dokumentasi).  Ketika tim berinteraksi, pengembangan tim internal dan proses implementasi tidak boleh didiskusikan.  Sebagai gantinya, fungsionalitas, tingkat layanan, dan sumber daya harus didiskusikan. <br><br>  Mengelola tim yang digabungkan secara longgar membuat perangkat lunak yang digabungkan secara longgar harus lebih mudah daripada alternatif.  Organisasi besar harus fokus pada penyediaan tujuan dan persyaratan yang jelas bagi tim dalam hal fungsionalitas dan tingkat layanan.  Persyaratan sumber daya harus berasal dari tim, meskipun mereka dapat digunakan oleh organisasi untuk mengukur laba atas investasi. <br><br><h3>  Tim yang digabungkan secara longgar mengembangkan perangkat lunak yang digabungkan secara longgar </h3><br>  Konektivitas yang lemah dalam perangkat lunak dan antar tim adalah kunci untuk membangun organisasi yang sangat efektif.  Dan pengalaman saya menegaskan hal ini.  Saya bekerja di organisasi di mana tim dibagi berdasarkan fungsi, tingkat perangkat lunak, atau bahkan di mana ada pemisahan pelanggan.  Saya juga bekerja di tim kacau besar pada basis kode tunggal.  Tetapi dalam semua kasus ini, ada masalah dengan penskalaan, yang disebutkan di atas.  Pengalaman yang paling menyenangkan selalu ketika tim saya adalah unit penuh, secara independen terlibat dalam pembuatan, pengujian dan penyebaran layanan independen.  Tapi kamu tidak perlu mengandalkan kisah hidupku.  Accelerate (dijelaskan di atas) memiliki bukti penelitian untuk mendukung pandangan ini. <br><br>  <i><b>Jika Anda telah membaca materi ini sampai akhir, kami sarankan Anda menonton rekaman webinar terbuka dengan topik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"One Day in the Life of DevOps"</a> .</b></i> <i><br></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475980/">https://habr.com/ru/post/id475980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475958/index.html">Kisah tentang bagaimana gadis itu berkumpul di IT</a></li>
<li><a href="../id475960/index.html">AHURATUS Smart Home Voice Assistant</a></li>
<li><a href="../id475968/index.html">Berita menarik Vue 3</a></li>
<li><a href="../id475974/index.html">Bagaimana kami membuat hackathon di kereta dan apa yang terjadi</a></li>
<li><a href="../id475978/index.html">Untuk apa markas kereta itu?</a></li>
<li><a href="../id475982/index.html">Cara belajar bahasa asing</a></li>
<li><a href="../id475986/index.html">Ikhtisar PocketBook 740 Pro Reader: 7,8 inci, perlindungan audio dan IPX8</a></li>
<li><a href="../id475988/index.html">Pembaruan Pembuat Model ML.NET</a></li>
<li><a href="../id475990/index.html">Membangun Aplikasi Cloud Modern menggunakan Pulumi dan .NET Core</a></li>
<li><a href="../id475992/index.html">Menulis plugin VLC untuk belajar bahasa Inggris</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>