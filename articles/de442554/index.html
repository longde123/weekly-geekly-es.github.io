<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê± üê± üëÇüèø Was ist striktes Aliasing und warum sollten wir uns darum k√ºmmern? Teil 1 ‚ôëÔ∏è üç† üëºüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(ODER streiten tippen, vages Verhalten und Ausrichtung, oh mein Gott!) 

 Hallo allerseits, in ein paar Wochen starten wir einen neuen Thread im Kurs ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist striktes Aliasing und warum sollten wir uns darum k√ºmmern? Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/442554/">  <i><b>(ODER streiten tippen, vages Verhalten und Ausrichtung, oh mein Gott!)</b></i> <br><br>  Hallo allerseits, in ein paar Wochen starten wir einen neuen Thread im Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"C ++ Developer"</a> .  Diese Veranstaltung ist unserem heutigen Material gewidmet. <br><br>  Was ist striktes Aliasing?  Zuerst beschreiben wir, was Aliasing ist, und dann finden wir heraus, wof√ºr Strenge ist. <br><br>  In C und C ++ h√§ngt Aliasing davon ab, auf welche Arten von Ausdr√ºcken wir auf gespeicherte Werte zugreifen d√ºrfen.  Sowohl in C als auch in C ++ definiert der Standard, welche Namensausdr√ºcke f√ºr welche Typen g√ºltig sind.  Der Compiler und der Optimierer d√ºrfen davon ausgehen, dass wir die Aliasing-Regeln strikt befolgen, daher ist der Begriff die strikte Aliasing-Regel.  Wenn wir versuchen, mit einem ung√ºltigen Typ auf einen Wert zuzugreifen, wird dieser als undefiniertes Verhalten (UB) klassifiziert.  Wenn wir unsicheres Verhalten haben, werden alle Wetten abgeschlossen und die Ergebnisse unseres Programms sind nicht mehr zuverl√§ssig. <br><br>  Leider erhalten wir bei strengen Aliasing-Verst√∂√üen h√§ufig die erwarteten Ergebnisse, sodass die M√∂glichkeit besteht, dass eine zuk√ºnftige Version des Compilers mit neuer Optimierung den von uns als g√ºltig erachteten Code verletzt.  Dies ist unerw√ºnscht. Es lohnt sich, die strengen Regeln des Aliasing zu verstehen und zu vermeiden, dass sie verletzt werden. <br><br><img src="https://habrastorage.org/webt/96/gf/6g/96gf6g_yzuptz3qryqe_m3xtecm.png"><br><br>  Um besser zu verstehen, warum wir uns dar√ºber Sorgen machen sollten, werden wir die Probleme diskutieren, die bei Verst√∂√üen gegen die strengen Aliasing-Regeln auftreten, Typ Punning, wie es h√§ufig in strengen Aliasing-Regeln verwendet wird, sowie das korrekte Erstellen eines Wortspiels zusammen mit Einige m√∂gliche Hilfen mit C ++ 20, um das Wortspiel zu vereinfachen und die Fehlerwahrscheinlichkeit zu verringern.  Wir werden die Diskussion zusammenfassen, indem wir einige Methoden zum Erkennen von Verst√∂√üen gegen strenge Aliasing-Regeln betrachten. <a name="habracut"></a><br><br>  <b>Vorl√§ufige Beispiele</b> <br><br>  Schauen wir uns einige Beispiele an, und dann k√∂nnen wir diskutieren, was genau in den Standards angegeben ist, einige zus√§tzliche Beispiele betrachten und dann herausfinden, wie striktes Aliasing vermieden und Verst√∂√üe identifiziert werden k√∂nnen, die wir verpasst haben.  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> , das Sie nicht √ºberraschen sollte: <br><br><pre><code class="bash hljs">int x = 10; int *ip = &amp;x; std::cout &lt;&lt; *ip &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; *ip = 12; std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br>  Wir haben int *, das auf den von int belegten Speicher zeigt, und dies ist ein g√ºltiges Aliasing.  Der Optimierer sollte davon ausgehen, dass Zuweisungen √ºber IP den von x belegten Wert aktualisieren k√∂nnen. <br><br>  Das folgende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> zeigt Aliasing, das zu undefiniertem Verhalten f√ºhrt: <br><br><pre> <code class="bash hljs">int foo( <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *f, int *i ) { *i = 1; *f = 0.f; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> *i; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { int x = 0; std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; // Expect 0 x = foo(reinterpret_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*&gt;(&amp;x), &amp;x); std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; // Expect 0? }</code> </pre> <br>  In der foo-Funktion nehmen wir int * und float *.  In diesem Beispiel rufen wir foo auf und setzen beide Parameter so, dass sie auf denselben Speicherort verweisen, der in diesem Beispiel ein int enth√§lt.  Beachten Sie, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reinterpret_cast</a> den Compiler anweist, den Ausdruck so zu behandeln, als h√§tte er den vom Vorlagenparameter angegebenen Typ.  In diesem Fall weisen wir ihn an, den &amp; x-Ausdruck so zu verarbeiten, als w√§re er vom Typ float *.  Wir k√∂nnen naiv erwarten, dass das Ergebnis des zweiten Couts 0 ist, aber wenn die Optimierung mit -O2 und gcc aktiviert ist und clang das folgende Ergebnis erh√§lt: <br>  0 <br>  1 <br><br>  Das mag unerwartet sein, aber v√∂llig richtig, da wir undefiniertes Verhalten verursacht haben.  Float kann kein g√ºltiger Alias ‚Äã‚Äãeines int-Objekts sein.  Daher kann der Optimierer annehmen, dass die w√§hrend der Dereferenzierung i gespeicherte Konstante 1 der R√ºckgabewert ist, da das Speichern durch f das int-Objekt nicht korrekt beeinflussen kann.  Das Verbinden des Codes im Compiler Explorer zeigt, dass genau dies geschieht ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel</a> ): <br><br><pre> <code class="bash hljs">foo(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*, int*): <span class="hljs-comment"><span class="hljs-comment"># @foo(float*, int*) mov dword ptr [rsi], 1 mov dword ptr [rdi], 0 mov eax, 1 ret</span></span></code> </pre> <br>  Ein Optimierer, der die typbasierte Alias-Analyse (TBAA) verwendet, geht davon aus, dass 1 zur√ºckgegeben wird, und verschiebt den konstanten Wert direkt in das eax-Register, in dem der R√ºckgabewert gespeichert ist.  TBAA verwendet Sprachregeln, welche Typen f√ºr Aliasing zul√§ssig sind, um das Laden und Speichern zu optimieren.  In diesem Fall wei√ü TBAA, dass float kein Alias ‚Äã‚Äãvon int sein kann, und optimiert das Laden zu Tode. <br><br>  <b>Nun zur Referenz</b> <br><br>  Was genau sagt der Standard dar√ºber aus, was wir d√ºrfen und was nicht?  Die Standardsprache ist nicht einfach, daher werde ich versuchen, f√ºr jedes Element Codebeispiele bereitzustellen, die die Bedeutung demonstrieren. <br><br>  Was sagt der C11-Standard? <br><br>  Der C11-Standard schreibt im Abschnitt ‚Äû6.5 Ausdr√ºcke‚Äú von Absatz 7 Folgendes vor: <br><br>  Das Objekt muss √ºber einen eigenen gespeicherten Wert verf√ºgen, auf den nur mit dem Ausdruck lvalue zugegriffen werden kann, der einen der folgenden Typen aufweist: 88) - ein Typ, der mit dem effektiven Typ des Objekts kompatibel ist; <br><br><pre> <code class="bash hljs">int x = 1; int *p = &amp;x; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *p); //* p   lvalue-  int,    int</code> </pre> <br>  - eine qualifizierte Version eines Typs, der mit dem aktuellen Objekttyp kompatibel ist; <br><br><pre> <code class="bash hljs">int x = 1; const int *p = &amp;x; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *p); // * p   lvalue-  const int,    int</code> </pre><br>  - ein Typ, der ein Typ mit oder ohne Vorzeichen ist, der einem qualifizierten Objekttyp entspricht; <br><br><pre> <code class="bash hljs">int x = 1; unsigned int *p = (unsigned int*)&amp;x; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%u\n"</span></span>, *p ); // *p   lvalue-  unsigned int,     </code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In Fu√ünote 12 finden Sie die Erweiterung gcc / clang</a> , mit der Sie unsigned int * int * zuweisen k√∂nnen, auch wenn es sich nicht um kompatible Typen handelt. <br><br>  - ein Typ, der ein Typ mit oder ohne Vorzeichen ist, der einer qualifizierten Version des aktuellen Objekttyps entspricht; <br><br><pre> <code class="bash hljs">int x = 1; const unsigned int *p = (const unsigned int*)&amp;x; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%u\n"</span></span>, *p ); // *p   lvalue-  const unsigned int,     ,       </code> </pre> <br>  - ein aggregierter oder kombinierter Typ, der einen der oben genannten Typen unter seinen Mitgliedern enth√§lt (einschlie√ülich rekursiv eines Mitglieds einer subaggregierten oder enthaltenen Assoziation), oder <br><br><pre> <code class="bash hljs">struct foo { int x; }; void foobar( struct foo *fp, int *ip );// struct foo -  ,   int   ,       *ip // foo f; foobar( &amp;f, &amp;f.x );</code> </pre> <br>  - Zeichentyp. <br><br><pre> <code class="bash hljs">int x = 65; char *p = (char *)&amp;x; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%c\n"</span></span>, *p ); // * p   lvalue-  char,    . //    -    .</code> </pre> <br>  <b>Was C ++ 17 Standardentwurf sagt</b> <br><br>  Der C ++ 17-Projektstandard in Abschnitt 11 [basic.lval] besagt: Wenn ein Programm versucht, √ºber einen anderen Wert als einen der folgenden Typen auf einen gespeicherten Wert eines Objekts zuzugreifen, ist das Verhalten undefiniert: 63 (11.1) ist ein dynamischer Objekttyp. <br><br><pre> <code class="bash hljs">void *p = malloc( sizeof(int) ); //   ,       int *ip = new (p) int{0}; // placement new      int std::cout &lt;&lt; *ip &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; // * ip   glvalue-  int,      </code> </pre> <br>  (11.2) - cv-qualifizierte (cv - const und volatile) Version des dynamischen Typs eines Objekts, <br><br><pre> <code class="bash hljs">int x = 1; const int *cip = &amp;x; std::cout &lt;&lt; *cip &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; // * cip    glvalue  const int,   cv-    x</code> </pre> <br>  (11.3) - ein Typ, der dem dynamischen Typ eines Objekts √§hnlich ist (wie in 7.5 definiert), <br><br> <code>//     </code> <br> <br>  (11.4) - ein Typ, der ein Typ mit oder ohne Vorzeichen ist, der dem dynamischen Typ eines Objekts entspricht; <br> <code>// si  ui     ,     </code> <br> <code>//   godbolt (https://godbolt.org/g/KowGXB) ,    .</code> <br> <br><pre> <code class="bash hljs">signed int foo( signed int &amp;si, unsigned int &amp;ui ) { si = 1; ui = 2; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> si; }</code> </pre> <br>  (11.5) - ein Typ, der ein Typ mit oder ohne Vorzeichen ist, der der cv-qualifizierten Version des dynamischen Typs eines Objekts entspricht; <br><br><pre> <code class="bash hljs">signed int foo( const signed int &amp;si1, int &amp;si2); //  ,    </code> </pre> <br>  (11.6) - ein aggregierter oder kombinierter Typ, der einen der oben genannten Typen unter seinen Elementen oder nicht statischen Datenelementen enth√§lt (einschlie√ülich rekursiv eines Elements oder nicht statischen Datenelements eines Unteraggregats oder mit Assoziationen), <br><br><pre> <code class="bash hljs">struct foo { int x; };</code> </pre> <br> <code>//  Compiler Explorer (https://godbolt.org/g/z2wJTC)    </code> <br> <br><pre> <code class="bash hljs">int foobar( foo &amp;fp, int &amp;ip ) { fp.x = 1; ip = 2; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> fp.x; } foo f; foobar( f, fx );</code> </pre><br>  (11.7) - ein Typ, der (m√∂glicherweise lebenslaufqualifiziert) ein Basisklassentyp eines dynamischen Objekttyps ist, <br><br><pre> <code class="bash hljs">struct foo { int x ; }; struct bar : public foo {}; int foobar( foo &amp;f, bar &amp;b ) { fx = 1; bx = 2; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> fx; }</code> </pre><br>  (11.8) - Geben Sie char, unsigned char oder std :: byte ein. <br><br><pre> <code class="bash hljs">int foo( std::byte &amp;b, uint32_t &amp;ui ) { b = static_cast&lt;std::byte&gt;(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); ui = 0xFFFFFFFF; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> std::to_integer&lt;int&gt;( b ); // b   glvalue-  std::byte,      uint32_t }</code> </pre> <br>  Es ist erw√§hnenswert, dass <code>signed char</code> Zeichen nicht in der obigen Liste enthalten ist. Dies ist ein sp√ºrbarer Unterschied zu C, das √ºber die Art des Zeichens spricht. <br><br>  <b>Subtile Unterschiede</b> <br><br>  Obwohl wir sehen k√∂nnen, dass C und C ++ √§hnliche Aussagen zum Aliasing machen, gibt es einige Unterschiede, die wir beachten sollten.  C ++ hat kein C-Konzept eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">g√ºltigen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kompatiblen</a> Typs, und C hat kein C ++ - Konzept eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dynamischen</a> oder √§hnlichen Typs.  Obwohl beide Ausdr√ºcke lvalue und rvalue haben, hat C ++ auch Ausdr√ºcke glvalue, prvalue und xvalue.  Diese Unterschiede liegen weitgehend au√üerhalb des Geltungsbereichs dieses Artikels. Ein interessantes Beispiel ist jedoch, wie ein Objekt aus dem von malloc verwendeten Speicher erstellt wird.  In C k√∂nnen wir einen g√ºltigen Typ festlegen, z. B. das Schreiben √ºber lvalue oder memcpy in den Speicher. <br><br><pre> <code class="bash hljs">//     C,    C ++ void *p = malloc(sizeof(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.0f; memcpy( p, &amp;f, sizeof(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>)); //   *p - <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>  C //  <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = p; *fp = 1.0f; //   *p - <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>  C</code> </pre><br>  Keine dieser Methoden ist in C ++ ausreichend, was die Platzierung neuer erfordert: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = new (p) <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>{1.0f} ; //   *p  <span class="hljs-built_in"><span class="hljs-built_in">float</span></span></code> </pre><br>  <b>Sind int8_t und uint8_t Zeichentypen?</b> <br><br>  Theoretisch sollten weder int8_t noch uint8_t Zeichentypen sein, aber in der Praxis werden sie auf diese Weise implementiert.  Dies ist wichtig, denn wenn es sich wirklich um Zeichentypen handelt, handelt es sich auch um Aliase wie Zeichentypen.  Wenn Sie sich dessen nicht bewusst sind, kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies zu unerwarteten</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungseinbu√üen f√ºhren</a> .  Wir sehen, dass <code>glibc typedef</code> <code>int8_t</code> und <code>uint8_t</code> f√ºr <code>signed char</code> <code>int8_t</code> bzw. <code>uint8_t</code> <code>signed char</code> <code>glibc typedef</code> . <br><br>  Dies w√§re schwer zu √§ndern, da es f√ºr C ++ eine ABI-L√ºcke w√§re.  Dies w√ºrde die Namensverzerrung √§ndern und jede API unter Verwendung eines dieser Typen in ihrer Schnittstelle besch√§digen. <br><br>  Das Ende des ersten Teils.  Und wir werden in ein paar Tagen √ºber das Wortspiel f√ºr Eingabe und Ausrichtung sprechen. <br><br>  Schreiben Sie Ihre Kommentare und verpassen Sie nicht das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offene Webinar</a> , das am 6. M√§rz vom Leiter der Technologieentwicklung bei Rambler &amp; Co, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dmitry Shebordaev</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abgehalten wird</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442554/">https://habr.com/ru/post/de442554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442534/index.html">Sprint Review: Schei√üe bis gro√üartig</a></li>
<li><a href="../de442536/index.html">Anschlie√üen externer Postf√§cher an Zimbra</a></li>
<li><a href="../de442542/index.html">SmartMail Conf: Erste Mail.ru Mail-Konferenz zum maschinellen Lernen</a></li>
<li><a href="../de442546/index.html">Indizes in PostgreSQL - 2</a></li>
<li><a href="../de442548/index.html">Ameisenh√ºgel oder Festung? Ich baue ein Haus zum Preis einer Wohnung. 4 Teil. Komfort oder Bedarf an Ger√§ten zu Hause?</a></li>
<li><a href="../de442556/index.html">Eine andere Geschichte des Fernen</a></li>
<li><a href="../de442558/index.html">‚ÄûWenn ein Produkt nicht ben√∂tigt wird, egal wie Sie es verpacken, macht es keinen Sinn‚Äú: Wie Technologieunternehmen an Schnittstellen arbeiten</a></li>
<li><a href="../de442560/index.html">Mash: Multithreading, Coroutinen, Async & Wait</a></li>
<li><a href="../de442562/index.html">So k√ºhlen Sie Ger√§te in einem Rechenzentrum - drei neue Technologien</a></li>
<li><a href="../de442566/index.html">Wie auf dem Mond: Reverse Engineering eines Hybrid-Operationsverst√§rkermoduls</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>