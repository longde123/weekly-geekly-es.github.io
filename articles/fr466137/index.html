<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå¶Ô∏è üë¶üèª üëÜüèø Pipelines System.IO. - un outil peu connu des amateurs de hautes performances ü§î üë®üèæ üç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour lecteur. Beaucoup de temps s'est √©coul√© depuis la sortie de .NET Core 2.1. Et des innovations int√©ressantes comme Span et Memory sont d√©j√† lar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pipelines System.IO. - un outil peu connu des amateurs de hautes performances</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466137/">  Bonjour lecteur.  Beaucoup de temps s'est √©coul√© depuis la sortie de .NET Core 2.1.  Et des innovations int√©ressantes comme Span et Memory sont d√©j√† largement connues, vous pouvez les lire, les voir et en entendre beaucoup parler.  Cependant, malheureusement, la biblioth√®que appel√©e System.IO. Pipeslines n'a pas re√ßu la m√™me attention.  Presque tout ce qu'il y a sur ce sujet est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le seul article</a> qui a √©t√© traduit et copi√© sur de nombreuses ressources.  Il devrait y avoir plus d'informations sur cette technologie pour la voir sous diff√©rents angles. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  Pr√©sentation </h2><br>  Ainsi, cette biblioth√®que vise √† acc√©l√©rer le traitement des donn√©es en streaming.  Il a √©t√© initialement cr√©√© et utilis√© par l'√©quipe de d√©veloppement de Kestrel (un serveur Web multiplateforme pour ASP.NET Core), mais il est actuellement disponible pour les mortels via un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package nuget</a> . <br><br>  Avant de nous plonger dans le sujet, nous pouvons imaginer le m√©canisme de biblioth√®que comme un analogue am√©lior√© de MemoryStream.  Le probl√®me avec le MemoryStream d'origine est un nombre excessif de copies, ce qui est √©vident si vous vous souvenez qu'un tableau d'octets priv√© est utilis√© dans MemoryStream comme tampon.  Par exemple, dans les m√©thodes de <a href="">lecture</a> et d' <a href="">√©criture</a> , vous pouvez clairement voir la copie des donn√©es.  Ainsi, pour l'objet que nous voulons √©crire dans le flux, une copie sera cr√©√©e dans le tampon interne, et lors de la lecture, une copie de la copie interne sera retourn√©e au consommateur.  Cela ne ressemble pas √† l'utilisation la plus rationnelle de la m√©moire. <br><br>  System.IO.Pipelines n'a pas pour objectif de remplacer tous les flux, c'est un outil suppl√©mentaire dans l'arsenal d'un d√©veloppeur √©crivant du code performant.  Je vous sugg√®re de vous familiariser avec les m√©thodes et classes de base, de voir leurs d√©tails d'impl√©mentation et d'analyser des exemples de base. <br><br>  Commen√ßons par les √©l√©ments internes et les d√©tails de l'impl√©mentation, en regardant en m√™me temps de simples fragments de code.  Apr√®s cela, il deviendra clair comment cela fonctionne et comment il doit √™tre utilis√©.  Lorsque vous travaillez avec System.IO.Pipelines, il convient de se rappeler que le concept de base est que toutes les op√©rations de lecture-√©criture doivent avoir lieu sans allocations suppl√©mentaires.  Mais certaines m√©thodes s√©duisantes √† premi√®re vue contredisent cette r√®gle.  En cons√©quence, le code que vous essayez d'acc√©l√©rer si fort commence √† allouer de la m√©moire pour les nouvelles et nouvelles donn√©es, en chargeant le garbage collector. <br><br>  Les composants internes de la biblioth√®que utilisent les possibilit√©s les plus larges des derni√®res versions du langage et du runtime - √©tendue, m√©moire, pools d'objets, ValueTask et ainsi de suite.  Il vaut la peine d'y chercher au moins un excellent exemple d'utilisation de ces fonctionnalit√©s en production. <br><br>  √Ä un moment donn√©, certains d√©veloppeurs n'√©taient pas satisfaits de l'impl√©mentation de flux en C #, car une classe √©tait utilis√©e √† la fois pour la lecture et l'√©criture.  Mais comme on dit, vous ne pouvez pas jeter des m√©thodes hors d'une classe.  M√™me si le flux ne prend pas en charge la lecture / √©criture / recherche, les propri√©t√©s CanRead, CanWrite et CanSeek sont utilis√©es.  Cela ressemble √† une petite b√©quille.  Mais maintenant, les choses deviennent diff√©rentes. <br><br>  Pour travailler avec des pipelines, 2 classes sont utilis√©es: <a href="">PipeWriter</a> et <a href="">PipeReader</a> .  Ces classes contiennent environ 50 lignes de code et sont des pseudo-fa√ßades (pas la plus classique de ses incarnations, car elles cachent une seule classe, pas beaucoup) pour la classe <a href="">Pipe</a> , qui contient toute la logique de base pour travailler avec des donn√©es.  Cette classe contient 5 membres publics: 2 constructeurs, 2 propri√©t√©s get-only - Reader et Writer, la m√©thode Reset (), qui r√©initialise les champs internes √† leur √©tat initial afin que la classe puisse √™tre r√©utilis√©e.  Les autres m√©thodes de travail sont internes et appel√©es √† l'aide de pseudo-fa√ßades. <br><br><h2>  Commen√ßons par la classe pipe </h2><br>  L'instance de classe occupe 320 octets, ce qui est beaucoup (presque un tiers de kilo-octet, 2 de ces objets ne pouvaient pas tenir dans la m√©moire de Manchester Mark I).  L'allocation d'une grande quantit√© de ses instances est donc une mauvaise id√©e.  De plus, l'objet est destin√© √† une utilisation √† long terme.  L'utilisation de pools cr√©e √©galement un argument pour cette d√©claration.  Les objets utilis√©s dans le pool vivront pour toujours (pour l'impl√©mentation du pool par d√©faut). <br>  Notez que la classe est marqu√©e comme scell√©e et qu'elle est thread-safe - de nombreuses sections du code sont une section critique et sont entour√©es de verrous. <br><br>  Pour commencer √† utiliser cette classe, vous devez cr√©er une instance de la classe Pipe et obtenir les objets PipeReader et PipeWriter en utilisant les propri√©t√©s mentionn√©es. <br><br><div class="spoiler">  <b class="spoiler_title">Initialisation simple</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Consid√©rez les m√©thodes de travail avec les tuyaux: <br>  √âcriture avec PipeWriter - WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Complete, CancelPendingFlush, OnReaderCompleted. <br><br>  Lecture avec PipeReader - AdvanceTo, ReadAsync, TryRead, Complete, CancelPendingRead, OnWriterCompleted. <br><br>  Comme indiqu√© dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mentionn√©</a> , la classe utilise une liste de tampons li√©s individuellement.  Mais, √©videmment, ils ne sont pas transf√©r√©s entre PipeReader et PipeWriter - toute la logique est dans une classe.  Cette liste est utilis√©e √† la fois pour la lecture et l'√©criture.  De plus, les donn√©es retourn√©es sont stock√©es dans cette liste (donc aucune copie n'est effectu√©e). <br><br>  En outre, il existe des objets indiquant le d√©but des donn√©es √† lire (ReadHead et index), la fin des donn√©es √† lire (ReadTail et index) et le d√©but de l'espace √† √©crire (WriteHead et le nombre d'octets mis en m√©moire tampon √©crits).  Ici, ReadHead, ReadTail et WriteHead sont des membres (segments) sp√©cifiques de la liste interne de segments, et l'index indique une position sp√©cifique dans le segment.  Ainsi, l'enregistrement peut commencer au milieu d'un segment, capturer un segment entier suivant et se terminer au milieu du troisi√®me.  Ces pointeurs sont d√©plac√©s de diff√©rentes mani√®res. <br><br><h2>  Premiers pas avec les m√©thodes PipeWriter </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (source ReadOnlyMemory &lt;byte&gt;, CancellationToken cancelToken)</a> </h3><br>  Cela est mentionn√© comme une m√©thode attrayante √† premi√®re vue.  Il a une signature tr√®s appropri√©e et √† la mode - accepte ReadOnlyMemory, asynchrone.  Et beaucoup peuvent √™tre tent√©s, surtout en se souvenant que la port√©e et la m√©moire sont si rapides et cool.  Mais ne vous flattez pas.  Tout ce que cette m√©thode fait est de copier le ReadOnlyMemory qui lui est pass√© dans la liste interne.  Et par ¬´copier¬ª, on entend un appel √† la m√©thode CopyTo (), et non pas copier uniquement l'objet lui-m√™me.  Toutes les donn√©es que nous voulons enregistrer seront copi√©es, chargeant ainsi la m√©moire.  Cette m√©thode ne doit √™tre mentionn√©e que pour s'assurer qu'il vaut mieux ne pas l'utiliser.  Eh bien, et peut-√™tre pour certaines situations rares, ce comportement est appropri√©. <br>  Le corps de la m√©thode est une section critique dont l'acc√®s est synchronis√© via un moniteur. <br><br>  Ensuite, la question peut se poser, comment √©crire quelque chose, sinon par la m√©thode la plus √©vidente et la seule appropri√©e <br><br><h3>  # 2 <a href="">M√©moire &lt;octet&gt; GetMemory (int sizeHint)</a> </h3><br>  La m√©thode prend un param√®tre d'un type entier.  Dans celui-ci, nous devons indiquer combien d'octets nous voulons √©crire dans le pipeline (quelle taille de tampon nous voulons).  Cette m√©thode v√©rifie s'il y a suffisamment d'espace pour √©crire dans le fragment de m√©moire actuel stock√© dans _writingHeadMemory.  Si cela est suffisant, _writingHeadMemory est renvoy√© en tant que m√©moire.  Sinon, pour les donn√©es √©crites dans le tampon, mais pour lesquelles la m√©thode FlushAsync n'a pas √©t√© appel√©e, elle est appel√©e et un autre BufferSegment est allou√©, qui est connect√© au pr√©c√©dent (voici notre liste interne).  Si _writingHeadMemory est null, il est initialis√© avec un nouveau BufferSegment.  Et l'allocation du tampon est une section critique et se fait sous le verrou. <br><br>  Je sugg√®re de regarder un tel exemple.  √Ä premi√®re vue, il peut sembler que le compilateur (ou runtime) a s√©duit le d√©mon. <br><br><div class="spoiler">  <b class="spoiler_title">Devilry</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048 or 4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Mais tout dans cet exemple est compr√©hensible et simple. <br>  Lors de la cr√©ation d'une instance Pipe, nous pouvons lui passer l'objet <a href="">PipeOptions</a> dans le constructeur avec des options de cr√©ation. <br><br>  PipeOptions a un champ de taille de segment minimum par d√©faut.  Il n'y a pas si longtemps, c'√©tait 2048, mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce commit</a> a mis √† jour cette valeur √† 4096. Au moment de la r√©daction de cet article, la version 4096 √©tait en version pr√©liminaire nuget-package, la derni√®re version avait une valeur de 2048. Cela explique la comportement du premier exemple.  Si vous √™tes critique quant √† l'utilisation d'une taille plus petite pour le tampon par d√©faut, vous pouvez le sp√©cifier dans une instance du type PipeOptions. <br><br>  Mais dans le deuxi√®me exemple, o√π la taille minimale est sp√©cifi√©e, la longueur ne correspond pas de toute fa√ßon.  Et cela se produit car la cr√©ation d'un nouveau BufferSegment se produit √† l'aide de pools.  L'une des options de PipeOptions est le pool de m√©moire.  Apr√®s cela, le pool sp√©cifi√© sera utilis√© pour cr√©er un nouveau segment.  Si vous n'avez pas sp√©cifi√© de pool de m√©moire, le ArrayPool par d√©faut sera utilis√©, qui, comme vous le savez, a plusieurs compartiments pour diff√©rentes tailles de tableaux (chacun suivant est 2 fois plus grand que le pr√©c√©dent) et quand il est demand√© pour un certain taille, il recherche un compartiment avec des tableaux de taille appropri√©e (c'est-√†-dire, le plus grand ou √©gal le plus proche).  Par cons√©quent, le nouveau tampon sera presque certainement plus volumineux que vous l'aviez demand√©.  La taille minimale d'un tableau dans le groupe de tableaux par d√©faut (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) est de 16. Mais ne vous inqui√©tez pas, il s'agit d'un pool de tableaux.  Par cons√©quent, dans la grande majorit√© des cas, la matrice n'exerce pas de pression sur le ramasse-miettes et sera r√©utilis√©e ult√©rieurement. <br><br><h3>  # 2.5 <a href="">Span &lt;byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Il fonctionne de la m√™me fa√ßon, offrant une √©tendue de la m√©moire. <br><br>  Ainsi GetMemory () ou GetSpan () sont les principales m√©thodes d'√©criture.  Ils nous donnent un objet sur lequel nous pouvons √©crire.  Pour ce faire, nous n'avons pas besoin d'allouer de m√©moire pour de nouveaux tableaux de valeurs, nous pouvons √©crire directement dans le canal.  Laquelle utiliser d√©pendra principalement de l'API que vous utilisez et de la m√©thode d'asynchronie.  Cependant, au vu de ce qui pr√©c√®de, une question se pose.  Comment le lecteur saura-t-il combien nous avons √©crit?  Si nous avons toujours utilis√© une impl√©mentation sp√©cifique du pool, qui donne un tableau de la m√™me taille que celle demand√©e, alors le lecteur pourrait lire la totalit√© du tampon √† la fois.  Cependant, comme nous l'avons d√©j√† dit, on nous alloue un tampon avec une forte probabilit√© d'une taille plus grande.  Cela conduit √† la m√©thode suivante requise pour le fonctionnement. <br><br><h3>  # 3 <a href="">void Advance (int octets)</a> </h3><br>  Une m√©thode terriblement simple.  Il prend le nombre d'octets √©crits comme argument.  Ils incr√©mentent les compteurs internes - _unflushedBytes et _writingHeadBytesBuffered, dont les noms parlent d'eux-m√™mes.  Il tronque √©galement (tranches) _writingHeadMemory exactement au nombre d'octets √©crits (√† l'aide de la m√©thode Slice).  Par cons√©quent, apr√®s avoir appel√© cette m√©thode, vous devez demander un nouveau bloc de m√©moire sous forme de m√©moire ou d'√©tendue, vous ne pouvez pas √©crire sur le pr√©c√©dent.  Et le corps entier de la m√©thode est une section critique et s'ex√©cute sous un verrou. <br><br>  Il semble qu'apr√®s cela, le lecteur puisse recevoir des donn√©es.  Mais une √©tape suppl√©mentaire est n√©cessaire. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (CancellationToken cancelToken)</a> </h3><br>  La m√©thode est appel√©e apr√®s avoir √©crit les donn√©es n√©cessaires dans la m√©moire re√ßue (GetMemory) et indiqu√© combien nous y avons √©crit (Advance).  La m√©thode renvoie ValueTask, mais elle n'est pas asynchrone (contrairement √† son descendant StreamPipeWriter).  ValueTask est un type sp√©cial (structure en lecture seule) utilis√© dans le cas o√π la plupart des appels ne seront pas asynchrones, c'est-√†-dire que toutes les donn√©es n√©cessaires seront disponibles au moment de son appel et que la m√©thode se terminera de mani√®re synchrone.  √Ä l'int√©rieur de lui-m√™me, il contient des donn√©es ou une t√¢che (au cas o√π cela ne fonctionnerait pas de mani√®re synchrone).  Cela d√©pend de la propri√©t√© _writerAwaitable.IsCompleted.  Si nous recherchons ce qui change l'√©tat de ce _writerAwaitable, nous verrons que cela se produit si la quantit√© de donn√©es non consomm√©es (ce n'est pas exactement la m√™me chose que les donn√©es non examin√©es seront expliqu√©es plus tard) d√©passe un certain seuil (_pauseWriterThreshold).  La valeur par d√©faut est 16 tailles de segment.  Si vous le souhaitez, la valeur peut √™tre modifi√©e dans PipeOptions.  En outre, cette m√©thode d√©marre la continuation de la m√©thode ReadAsync, si une a √©t√© bloqu√©e. <br><br>  Renvoie un FlushResult contenant 2 propri√©t√©s - IsCanceled et IsCompleted.  IsCanceled indique si le vidage a √©t√© annul√© (appel CancelPendingFlush ()).  IsCompleted indique si le PipeReader s'est termin√© (en appelant les m√©thodes Complete () ou CompleteAsync ()). <br>  La partie principale de la m√©thode est effectu√©e sous la serrure. <br><br>  D'autres m√©thodes de PipeWriter ne sont pas int√©ressantes du point de vue de la mise en ≈ìuvre et sont utilis√©es beaucoup moins souvent, par cons√©quent, seule une br√®ve description sera donn√©e. <br><br><h3>  # 5 void Complete (Exception exception = null) ou ValueTask CompleteAsync (Exception exception = null) </h3><br>  Marque le tuyau ferm√© pour √©criture.  Une exception sera lev√©e lors de la tentative d'utilisation des m√©thodes d'√©criture une fois l'op√©ration termin√©e.  Si PipeReader est d√©j√† termin√©, l'instance de tuyau enti√®re est √©galement termin√©e.  La plupart du travail se fait sous la serrure. <br><br><h3>  # 6 void CancelPendingFlush () </h3><br>  Comme son nom l'indique, il annule l'op√©ration FlushAsync () en cours.  Il y a une serrure. <br><br><h3>  # 7 void OnReaderCompleted (Action &lt;Exception, objet&gt; rappel, √©tat de l'objet) </h3><br>  Ex√©cute le d√©l√©gu√© pass√© lorsque le lecteur a termin√©.  Il y a aussi une serrure. <br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation,</a> il est actuellement √©crit que cette m√©thode peut ne pas √™tre appel√©e sur certaines impl√©mentations PipeWriter et sera supprim√©e √† l'avenir.  Par cons√©quent, vous ne devez pas lier la logique √† ces m√©thodes. <br><br><h2>  Il est temps pour PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (jeton CancellationToken)</a> </h3><br>  Ici, comme dans FlushAsync (), ValueTask est retourn√©, ce qui indique que la m√©thode est principalement synchrone, mais pas toujours.  D√©pend de l'√©tat de _readerAwaitable.  Comme avec FlushAsync, vous devez trouver quand _readerAwaitable est d√©fini sur incomplet.  Cela se produit lorsque PipeReader a tout lu dans la liste interne (ou qu'il contient des donn√©es marqu√©es comme examin√©es et que vous avez besoin de plus de donn√©es pour continuer).  Ce qui, en fait, est √©vident.  En cons√©quence, nous pouvons conclure qu'il est souhaitable d'affiner Pipe √† votre travail, de d√©finir toutes ses options de mani√®re r√©fl√©chie, sur la base de statistiques identifi√©es empiriquement.  Une configuration appropri√©e r√©duira les chances d'une branche d'ex√©cution asynchrone et permettra un traitement plus efficace des donn√©es.  Presque tout le code de la m√©thode enti√®re est entour√© d'un verrou. <br><br>  Renvoie un myst√©rieux <a href="">ReadResult</a> .  En fait, c'est juste un tampon + drapeaux indiquant l'√©tat de l'op√©ration (IsCanceled - si ReadAsync a √©t√© annul√© et IsCompleted indiquant si le PipeWriter a √©t√© ferm√©).  IsCompleted est une valeur indiquant si les m√©thodes PipeWriter Complete () ou CompleteAsync () ont √©t√© appel√©es.  Si ces m√©thodes ont √©t√© appel√©es avec une exception pass√©e, elles seront lev√©es lors de la tentative de lecture. <br><br>  Et encore une fois, le tampon a un type myst√©rieux - <a href="">ReadOnlySequence</a> .  Ceci, √† son tour, est l'objet du contenu des segments <a href="">(ReadOnlySequenceSegment)</a> des index de d√©but et de fin + d√©but et fin √† l'int√©rieur des segments correspondants.  Ce qui ressemble en fait √† la structure de la classe Pipe elle-m√™me.  Soit dit en passant, BufferSegment est h√©rit√© de ReadOnlySequenceSegment, qui indique que BufferSegment est utilis√© dans cette s√©quence.  Gr√¢ce √† cela, vous pouvez simplement vous d√©barrasser des allocations de m√©moire inutiles pour le transfert de donn√©es de l'√©crivain au lecteur. <br>  ReadOnlySpan peut √™tre obtenu √† partir du tampon pour un traitement ult√©rieur.  Pour terminer l'image, vous pouvez v√©rifier si le tampon contient un seul ReadOnlySpan.  S'il contient, nous n'avons pas besoin d'it√©rer sur la collection d'un √©l√©ment et nous pouvons l'obtenir en utilisant la propri√©t√© First.  Sinon, il est n√©cessaire de parcourir tous les segments du tampon et de traiter ReadOnlySpan de chacun. <br><br>  Sujet de discussion - dans la classe ReadOnlySequence, les types de r√©f√©rence nullables sont activement utilis√©s et il y a goto (pas pour l'imbrication en boucle profonde et pas dans le code g√©n√©r√©) - en particulier <a href="">ici</a> . <br><br>  Apr√®s le traitement, vous devez signaler √† l'instance Pipe que nous lisons les donn√©es. <br><br><h3>  # 2 <a href="">bool TryRead (r√©sultat ReadResult)</a> </h3><br>  Version synchrone.  Vous permet d'obtenir le r√©sultat s'il existe.  Sinon, contrairement √† ReadAsync, il ne bloque pas et renvoie false.  Le code de cette m√©thode se trouve √©galement dans la serrure. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition consomm√©, SequencePosition examin√©)</a> </h3><br>  Dans cette m√©thode, vous pouvez sp√©cifier le nombre d'octets que nous examinons et consommons.  Les donn√©es examin√©es mais non consomm√©es seront renvoy√©es lors de la prochaine lecture.  Cette fonctionnalit√© peut sembler √©trange √† premi√®re vue, mais lors du traitement d'un flux d'octets, il est rarement n√©cessaire de traiter chaque octet individuellement.  Habituellement, les donn√©es sont √©chang√©es √† l'aide de messages.  Il peut arriver que le lecteur, lors de la lecture, re√ßoive un message entier et une partie du second.  Le tout doit √™tre trait√©, et une partie du second doit √™tre laiss√©e pour l'avenir afin qu'elle accompagne la partie restante.  La m√©thode AdvanceTo prend une SequencePosition, qui est en fait un segment + index.  Lors du traitement de tout ce que ReadAsync a lu, vous pouvez sp√©cifier buffer.End.  Sinon, vous devez cr√©er explicitement une position, en indiquant le segment et l'index auxquels le traitement a √©t√© arr√™t√©.  La serrure est sous le capot. <br>  De plus, si la quantit√© d'informations non consomm√©es est inf√©rieure au seuil sp√©cifi√© (_resumeWriterThreshold), il d√©marre la poursuite de PipeWriter s'il √©tait bloqu√©.  Par d√©faut, ce seuil est de 8 volumes de segment (la moiti√© du seuil de blocage). <br><br><h3>  # 4 void Complete (Exception exception = null) </h3><br>  Termine le PipeReader.  Si le PipeWriter est termin√© √† ce stade, alors toute l'instance de Pipe se termine.  Verrouillez √† l'int√©rieur. <br><br><h3>  # 5 void CancelPendingRead () </h3><br>  Vous permet d'annuler la lecture actuellement en attente.  Verrouiller <br><br><h3>  # 6 void OnWriterCompleted (Action &lt;Exception, objet&gt; rappel, √©tat de l'objet) </h3><br>  Vous permet de sp√©cifier le d√©l√©gu√© √† ex√©cuter √† la fin du PipeWriter. <br>  Comme la m√©thode similaire de PipeWriter, dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> il y a la m√™me balise qui sera supprim√©e.  La serrure est sous le capot. <br><br><h2>  Exemple </h2><br>  La liste ci-dessous montre un exemple de travail avec des tuyaux. <br>  Depuis l'introduction de .NET Core Span and Memory, de nombreuses classes pour travailler avec des donn√©es ont √©t√© compl√©t√©es par des surcharges utilisant ces types.  Le sch√©ma d'interaction g√©n√©ral sera donc √† peu pr√®s le m√™me.  Dans mon exemple, j'ai utilis√© des pipelines pour travailler avec des tuyaux (j'aime des mots similaires) - des objets OS pour la communication interprocessus.  L'API des canaux vient d'√™tre d√©velopp√©e en cons√©quence pour lire les donn√©es dans Span et Memory.  La version asynchrone utilise la m√©moire, car la m√©thode asynchrone sera convertie en m√©thode de mod√®le √† l'aide d'une machine √† √©tats finis g√©n√©r√©e automatiquement, dans laquelle toutes les variables locales et les param√®tres de m√©thode sont stock√©s, et puisque Span est une structure en lecture seule ref, elle ne peut pas √™tre plac√©e dans le tas, respectivement, en utilisant Span dans une m√©thode asynchrone est impossible.  Mais il existe √©galement une version synchrone de la m√©thode qui vous permet d'utiliser Span.  Dans mon exemple, j'ai essay√© les deux et il s'est av√©r√© que la version synchrone dans cette situation se montre mieux.  Lorsque vous l'utilisez, moins de r√©cup√©ration de place se produit et le traitement des donn√©es est plus rapide.  Mais c'√©tait uniquement parce qu'il y avait beaucoup de donn√©es dans le tuyau (les donn√©es √©taient toujours disponibles).  Dans la situation o√π il est plut√¥t probable qu'il n'y aura pas de donn√©es au moment de la demande pour le prochain lot, vous devez utiliser la version asynchrone afin de ne pas forcer le processeur au repos. <br>  L'exemple contient des commentaires qui expliquent certains points.  J'attire votre attention sur le fait que malgr√© le fait que les fragments du programme responsable de la lecture du pipe et du traitement soient s√©par√©s, lors de l'√©criture dans un fichier, les donn√©es sont lues exactement de l'endroit o√π elles sont √©crites lors de la lecture du tuyau. <br><br><div class="spoiler">  <b class="spoiler_title">Des ann√©es d'√©volution pour une fonction puissante - principale asynchrone</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pipepatawriter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ when working with the asynchronous method, use Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ asynchronous reading from a named pipe in Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ there can be any operation to obtain data - from reading from a file to random generation. //int readBytes = await _namedPipe.ReadAsync(buffer, token); // synchronous reading from the named pipe to the requested from PipeWriter Span // there can be any operation to obtain data - from reading from a file to random generation. int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); // if there was nothing in the channel, release the thread for half a second and try again // in other cases we can break the loop, it's just example if (readBytes == 0) { await Task.Delay(500, token); continue; } // specify the amount of bytes read from the pipe _pipeWriter.Advance(readBytes); // flush data to make them available PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); // if PipeReader has been completed, it no longer needs to write data // PS this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeWriter to complete the entire instance of pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Processeur de donn√©es</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">// reading data from a pipe instance ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; // We perform calculations with the data obtained. await _bytesProcessor.ProcessBytesAsync(buffer, token); // indicate to which position the data was processed. In this case, everything is written to the file. // in situations where not all data has been processed, you need to create a position manually using the buffer and index // in this situation, IBytesProcessor.ProcessBytesAsync can be supplemented by returning this position _pipeReader.AdvanceTo(buffer.End); // if PipeWriter has been completed, reading is no longer necessary // this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeReader to complete the entire instance of pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bytesprocessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Let's imagine that in this class there is a normal constructor and IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466137/">https://habr.com/ru/post/fr466137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466121/index.html">G√©n√©ration de son sur des microcontr√¥leurs AVR utilisant une m√©thode de table d'onde avec prise en charge de la polyphonie</a></li>
<li><a href="../fr466123/index.html">Croissance. Poids. Trois voisins</a></li>
<li><a href="../fr466127/index.html">Centrale nucl√©aire de Kola ou debout au r√©acteur</a></li>
<li><a href="../fr466129/index.html">Efficacit√© du transport sur l'essence, les batteries et l'hydrog√®ne</a></li>
<li><a href="../fr466135/index.html">Megapack: comment les d√©veloppeurs de Factorio ont r√©ussi √† r√©soudre le probl√®me avec le mode multijoueur √† 200 joueurs</a></li>
<li><a href="../fr466139/index.html">Technologie appliqu√©e sur les ruines de la fi√®vre de la blockchain ou les avantages pratiques de l'allocation des ressources</a></li>
<li><a href="../fr466143/index.html">Comment avons-nous fait du code en carton ou la version Scratch du jeu de plateau Golem Battle</a></li>
<li><a href="../fr466147/index.html">Gestionnaire d'affichage de donn√©es r√©actif. Pr√©sentation</a></li>
<li><a href="../fr466149/index.html">Cr√©ation d'un symbole de connecteur avec du texte ¬´dynamique¬ª dans OrCAD</a></li>
<li><a href="../fr466151/index.html">Enqu√™te: programmes √©tranges dans le registre des logiciels nationaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>