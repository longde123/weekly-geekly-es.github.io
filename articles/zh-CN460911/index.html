<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👦 ⚛️ 💌 做善事，做坏事：用Go编写邪恶代码，第2部分 ⏭️ 👩🏾‍⚕️ 🤺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Go程序员的坏提示 



 在出版物的第一部分，我解释了如何成为“恶意” Go程序员。 邪恶有多种形式，但是在编程中，它在于理解和维护代码的故意困难。 邪恶的程序会忽略语言的基本手段，而倾向于使用能带来短期利益以换取长期问题的技术。 简要提醒一下，Go的邪恶“做法”包括： 



- 命名和组织不...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>做善事，做坏事：用Go编写邪恶代码，第2部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460911/">  <i><b>Go程序员的坏提示</b></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8cc/265/872/8cc265872daa29a415c830378896ad61.png" alt="图片"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在出版物的第一部分，</a>我解释了如何成为“恶意” Go程序员。 邪恶有多种形式，但是在编程中，它在于理解和维护代码的故意困难。 邪恶的程序会忽略语言的基本手段，而倾向于使用能带来短期利益以换取长期问题的技术。 简要提醒一下，Go的邪恶“做法”包括： <br><br><ul><li> 命名和组织不佳的包裹 </li><li> 接口组织不正确 </li><li> 将指针传递给函数中的变量以填充其值 </li><li> 使用恐慌代替错误 </li><li> 使用初始化函数和空导入来配置依赖项 </li><li> 使用初始化功能下载配置文件 </li><li> 使用框架而不是库 </li></ul><br><h3> 邪恶大球 </h3><br> 如果我们将所有邪恶的作法放在一起会怎样？ 我们将拥有一个框架，该框架将使用许多配置文件，使用指针填写结构字段，定义用于描述已发布类型的接口，在出现问题时依靠“魔术”代码和恐慌。 <br><br> 而我做到了。 如果访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/evil-go</a> ，您将看到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fall</a> ，这是一个DI框架，可让您实施所需的任何“邪恶”实践。 我用一个遵循相同原理的小型Outboy网络框架焊接了Fall。 <br><br> 您可能会问他们有多邪恶？ 让我们看看。 我建议使用提供http端点的简单Go程序（使用最佳实践编写）。 然后使用Fall和Outboy重写它。 <br><a name="habracut"></a><br><h3> 最佳实务 </h3><br> 我们的程序位于一个名为greet的程序包中，该程序包使用所有基本功能来实现我们的端点。 既然这是一个示例，我们将使用内存中的DAO，其中包含三个将返回的值的字段。 我们还将提供一种方法，根据输入的不同，该方法将替换对数据库的调用并返回所需的问候语。 <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> greet <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Dao <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DefaultMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BobMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sdi Dao)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreetingForName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> name { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdi.BobMessage, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Julia"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdi.JuliaMessage, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdi.DefaultMessage, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br> 接下来是业务逻辑。 为了实现它，我们定义了一个用于存储输出数据的结构，一个用来描述在数据搜索级别上正在寻找什么业务逻辑的GreetingFinder接口以及一个用于将业务逻辑本身与GreetingFinder字段一起存储的结构。 实际的逻辑很简单-它仅调用GreetingFinder并处理可能发生的任何错误。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Response <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Message <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetingFinder <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GreetingForName(name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Service <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { GreetingFinder GreetingFinder } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ssi Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Response, error)</span></span></span></span> { msg, err := ssi.GreetingFinder.GreetingForName(name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response{}, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response{Message: msg}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br> 然后是Web层，为此，我们定义了Greeter接口，该接口提供了我们需要的所有业务逻辑，以及包含使用Greeter配置的http处理程序的结构。 然后，我们创建一个方法来实现http.Handler接口，该接口拆分http请求，调用greeter（焊接），处理错误并返回结果。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Greeter <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Greeting(name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (Response, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Controller <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Greeter Greeter } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mc Controller)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServeHTTP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span> { result, err := mc.Greeter.Greeting( req.URL.Query().Get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { rw.WriteHeader(http.StatusInternalServerError) rw.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(err.Error())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } rw.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(result.Message)) }</code> </pre> <br> 问候包到此结束。 接下来，我们将看到一个“好的” Go开发人员将如何编写main来使用该程序包。 在主程序包中，我们定义了一个名为Config的结构，其中包含我们需要运行的属性。 然后main函数执行3件事。 <br><br><ul><li> 首先，它调用loadProperties函数，该函数使用一个简单的库（ <a href="">https://github.com/evil-go/good-sample/blob/master/config/config.go</a> ）从配置文件加载属性并将其放置在我们的配置副本中。 如果配置下载失败，则主功能报告错误并退出。 </li><li> 其次，main函数将greet包中的组件绑定在一起，从config中显式分配它们的值并建立依赖关系。 </li><li> 第三，它调用一个小型服务器库（ <a href="">https://github.com/evil-go/good-sample/blob/master/server/server.go</a> ），并将地址，HTTP方法和http.Handler传递给端点请求处理。 库调用将启动Web服务。 这是我们的整个应用程序。 </li></ul><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DefaultMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BobMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { c, err := loadProperties() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } dao := greet.Dao{ DefaultMessage: c.DefaultMessage, BobMessage: c.BobMessage, JuliaMessage: c.JuliaMessage, } svc := greet.Service{GreetingFinder: dao} controller := greet.Controller{Greeter: svc} err = server.Start(server.Endpoint{c.Path, http.MethodGet, controller}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br> 这个例子很简短，但是它展示了Go的编写过程。 有些事情是模棱两可的，但总的来说很清楚发生了什么。 我们粘合专门为协同工作而设置的小型库。 什么都没有隐藏； 任何人都可以使用此代码，了解其各个部分如何连接在一起，并在必要时将它们重做为新的。 <br><br><h3> 黑点 </h3><br> 现在，我们将考虑Fall和Outboy的版本。 我们要做的第一件事是将greet包分成几个包，每个包都包含一个应用程序层。 这是DAO包。 它导入了我们的DI框架Fall，并且由于我们“邪恶”并相反地定义了与接口的关系，因此我们将定义一个名为GreetDao的接口。 请注意-我们已删除了所有指向错误的链接； 如果出了什么问题，我们会感到恐慌。 在这一点上，我们已经有不良的包装，不良的界面和不良的错误。 伟大的开始！ <br><br> 我们从一个很好的例子中稍微重命名了我们的结构。 现在，字段具有struct标签； 它们用于使Fall在字段中设置注册值。 我们的包装还具有初始化功能，通过该功能我们可以积累“邪恶力量”。 在包初始化函数中，我们两次调用Fall： <br><br><ul><li> 一次注册提供结构标签值的配置文件。 </li><li> 另一个是注册指向结构实例的指针。  Fall将能够为我们填写这些字段，并使DAO可供其他代码使用。 </li></ul><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> dao <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetDao <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GreetingForName(name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> greetDaoImpl <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DefaultMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"message.default"`</span></span> BobMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"message.bob"`</span></span> JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"message.julia"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gdi greetDaoImpl)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreetingForName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> name { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gdi.BobMessage <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Julia"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gdi.JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gdi.DefaultMessage } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.RegisterPropertiesFile(<span class="hljs-string"><span class="hljs-string">"dao.properties"</span></span>) fall.Register(&amp;greetDaoImpl{}) }</code> </pre> <br> 让我们看一下服务包。 它导入DAO包，因为它需要访问在那里定义的接口。 服务包还会导入模型包，我们尚未考虑过-我们将在其中存储数据类型。 我们导入了Fall，因为它像所有“好的”框架一样，渗透到了所有地方。 我们还定义了一个服务接口来提供对Web层的访问。 同样，没有错误处理。 <br><br> 现在，我们的服务实现具有带有导线的结构标签。 当结构在Fall中注册时，标记为wire的字段会自动连接其依赖性。 在我们的小示例中，很清楚将为该字段分配什么。 但是在更大的程序中，您只会知道实现了GreetDao接口的某个位置，并且该接口已在Fall中注册。 您无法控制依赖行为。 <br><br> 接下来是我们的服务方法，已对其进行了稍微修改，以从模型包中获取GreetResponse结构，并删除了任何错误处理。 最后，我们在包中有一个init函数，用于在Fall中注册一个服务实例。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/dao"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/model"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetService <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Greeting(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) model.GreetResponse } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> greetServiceImpl <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Dao dao.GreetDao <span class="hljs-string"><span class="hljs-string">`wire:""`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ssi greetServiceImpl)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">model</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreetResponse</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.GreetResponse{Message: ssi.Dao.GreetingForName(name)} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.Register(&amp;greetServiceImpl{}) }</code> </pre> <br> 现在让我们看一下模型包。 尤其是没有什么值得一看的。 可以看出，模型与创建模型的代码是分离的，只是将代码划分为多个层。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> model <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetResponse <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Message <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br> 在网络软件包中，我们有一个网络界面。 在这里，我们导入了Fall和Outboy，还导入了Web软件包所依赖的服务软件包。 由于框架只有在幕后集成时才能很好地协同工作，因此Fall具有特殊的代码来确保框架和Outboy能够一起工作。 我们还正在更改结构，使其成为我们的Web应用程序的控制器。 她有两个领域： <br><br><ul><li> 第一个通过Fall连接到服务包中GreetService接口的实现。 </li><li> 第二个是我们唯一的Web端点的路径。 从该程序包的init函数中注册的配置文件中为其分配值。 </li></ul><br> 我们的http处理程序已重命名为GetHello，现在没有错误处理。 我们还有Init方法（带有大写字母），不应与init函数混淆。 初始化是一种魔术方法，在填充所有字段之后，将为Fall中注册的结构调用此方法。 在Init中，我们调用Outboy在使用Fall设置的路径中注册控制器及其端点。 查看代码，您将看到路径和处理程序，但未指定HTTP方法。 在Outboy中，方法名称用于确定处理程序响应的HTTP方法。 由于我们的方法称为GetHello，因此它会响应GET请求。 如果您不知道这些规则，您将无法理解他的要求。 是的，这很恶毒吗？ <br><br> 最后，我们调用init函数以在Fall中注册配置文件和控制器。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> web <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/outboy"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/service"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetController <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Service service.GreetService <span class="hljs-string"><span class="hljs-string">`wire:""`</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"controller.path.hello"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mc GreetController)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span> { result := mc.Service.Greeting(req.URL.Query().Get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) rw.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(result.Message)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mc GreetController)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { outboy.Register(mc, <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"GetHello"</span></span>: mc.Path, }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.RegisterPropertiesFile(<span class="hljs-string"><span class="hljs-string">"web.properties"</span></span>) fall.Register(&amp;GreetController{}) }</code> </pre> <br> 它仅是为了显示我们如何运行该程序。 在主程序包中，我们使用空导入来注册Outboy和Web程序包。 并且主要函数调用fall.Start（）以启动整个应用程序。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/web"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/outboy"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.Start() }</code> </pre> <br><h3> 皮被破坏 </h3><br> 这是一个使用我们所有邪恶的Go工具编写的完整程序。 这是一场噩梦。 她神奇地隐藏了程序的各个部分是如何组合在一起的，这使她很难理解她的工作。 <br><br> 但是，您必须承认，使用Fall和Outboy编写代码具有一定的吸引力。 对于一个很小的程序，您甚至可以说这是一种改进。 看看配置有多容易！ 我几乎不需要代码就可以连接依赖项！ 我使用该方法的名称注册了该方法的处理程序！ 而且没有任何错误处理，一切看起来都很干净！ <br><br> 邪恶就是这样运作的。 乍一看，它确实很有吸引力。 但是随着程序的变化和增长，所有这些魔力只会开始干扰，使对正在发生的事情的理解变得复杂。 只有当您完全沉迷于邪恶时，您才会回头并意识到自己被困住了。 <br><br> 对于Java开发人员，这似乎很熟悉。 这些技术可以在许多流行的Java框架中找到。 如前所述，从1996年的1.0.2开始，我从事Java已有20多年的历史。 在许多情况下，Java开发人员是第一个在Internet时代编写大型企业软件时遇到问题的人。 我记得servlet，EJB，Spring和Hibernate刚刚出现的时代。  Java开发人员当时做出的决定是有道理的。 但是这些年来，这些技术显示出了自己的年龄。 诸如Go这样的较新语言旨在消除使用较旧技术时发现的痛点。 但是，随着Java开发人员开始学习Go并用它编写代码，他们应该记住，尝试从Java复制模式会产生不好的结果。 <br><br>  Go专为认真的编程而设计-适用于跨越数百个开发人员和数十个团队的项目。 但是对于Go来说，您需要以最有效的方式使用它。 我们可以选择邪恶或善良。 如果选择邪恶，我们可以鼓励年轻的Go开发人员在了解Go之前先改变他们的风格和技术。 或者我们可以选择好。 作为Go开发人员，我们的工作之一是教育年轻的Gopher（地鼠），以帮助他们理解构成我们最佳实践的原则。 <br><br> 遵循善良道路的唯一弊端是，您必须寻找另一种表达内心邪恶的方式。  <i>也许尝试以30公里/小时的速度在联邦高速公路上行驶？</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460911/">https://habr.com/ru/post/zh-CN460911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460899/index.html">7月26日，Deworkacy-Rostelecom的DocOps</a></li>
<li><a href="../zh-CN460901/index.html">为什么高级开发人员找不到工作</a></li>
<li><a href="../zh-CN460905/index.html">企业家最少的SEO知识</a></li>
<li><a href="../zh-CN460907/index.html">使用Liquibase在Spring Boot应用程序中管理数据库结构。 第二部分</a></li>
<li><a href="../zh-CN460909/index.html">2050年我们会吃什么</a></li>
<li><a href="../zh-CN460913/index.html">奥布宁斯克物理与能源研究所博物馆图片展</a></li>
<li><a href="../zh-CN460915/index.html">便捷的数据库管理系统</a></li>
<li><a href="../zh-CN460923/index.html">Yandex测试任务</a></li>
<li><a href="../zh-CN460925/index.html">切尔诺贝利的真正RC机器人在线游戏。 第二部分</a></li>
<li><a href="../zh-CN460929/index.html">Atlassian合流：可在python中扩展</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>