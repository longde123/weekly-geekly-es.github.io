<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏽 👏🏻 🚫 肉山重生时间可视化 🤷🏽 💃🏼 👦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文使用与Dota 2游戏相关的DirectX 9 for x64示例讨论图形API函数的拦截。 

 将详细描述如何渗透游戏过程，如何改变执行流程，并给出对所实现逻辑的简要描述。 最后，我们将讨论引擎提供的其他渲染功能。 



 免责声明：作者对您对本文中获得的知识的使用或使用它们所造成的损害不...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>肉山重生时间可视化</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446516/"> 本文使用与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dota 2</a>游戏相关的DirectX 9 for x64示例讨论图形API函数的拦截。 <br><br> 将详细描述如何渗透游戏过程，如何改变执行流程，并给出对所实现逻辑的简要描述。 最后，我们将讨论引擎提供的其他渲染功能。 <br><br><img src="https://habrastorage.org/webt/b0/rp/kn/b0rpknk7iobhh3darfcrte8ncmo.jpeg"><br><br><blockquote>  <b>免责声明：作者对您对本文中获得的知识的使用或使用它们所造成的损害不承担任何责任。</b>  <b>此处提供的所有信息仅用于教育目的。</b>  <b>特别是对于开发MOBA来帮助他们应对作弊者的公司。</b>  <b>而且，当然，本文的作者是一个机器人切换器，一个骗子，他一直都是。</b> </blockquote><a name="habracut"></a> 最后一句话值得解释-我是为了公平竞争。 我仅将作弊用作体育运动的兴趣，提高反向技巧，研究反作弊的工作，并且仅在评分比赛中使用。 <br><br><h2>  1.简介 </h2><br> 本文计划作为系列文章的第一篇，并给出了如何将图形API用于自己的目的的想法，并介绍了理解下一部分所需的功能。 我计划将第二篇文章专门用于搜索指向Source 2中实体列表的指针（也以Dota 2为例），并将其与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Source2Gen</a>结合使用以编写“其他”逻辑（类似<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这样的</a>东西很可能会显示“ map hack”（检查）注意引号，可以在视频中看到有争议的东西，或者第一篇文章的自动化）。 第三篇文章的计划形式是编写驱动程序，与之通信（IOCTL），使用它绕过VAC保护（与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>类似）。 <br><br><h2>  2.为什么我需要它 </h2><br> 我需要使用图形API直观地调试我的机器人，这是我为Dota 2编写的（实时可视化信息非常方便）。 我是一名研究生，并且从事3D头的重建以及使用图像和深度相机进行变形的工作-这个主题很有趣，但不是我最喜欢的一个。 自从第五年（从硕士课程开始）以来，我已经了解了一件事-是的，我已经很好地研究了这一领域，我很容易用方法和途径来研究文章并加以实施。 但这就是全部，我本人只能优化下一个学习到的算法，将其与已经研究和实施的算法进行比较，并决定是否在特定任务中使用它。 优化到此结束，不可能提出新的东西，这对研究生院非常重要（这项研究的新颖性）。 我开始思考-虽然有时间，但是您可以找到一个新的话题。 您已经需要很好地理解该主题（在当前级别上），或者可以快速将其拉起。 <br><br> 同时，我从事游戏开发人员的工作，这可能是程序员可以做的最有趣的事情（个人观点），并且对AI机器人这一主题非常感兴趣。 那时，我很了解两个主题-然后我建立了一个动态导航网格（客户端-服务器）并研究了动态射击者的网络部分。 带有动态导航器的主题无法立即解决-我是在工作时间做到这一点的，我必须征得管理层的许可才能在文凭课程中使用，此外，新颖性主题是开放的-我也按条款对方法进行了很好的研究和实施，但是这不是什么新鲜事。 动态射击游戏的网络部分的主题（我计划将其用于虚拟现实中的交互）再次分解了我在工作时间所做的事实以及新颖性，您可以阅读Pixonic的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一系列文章</a> ，作者本人说，该主题有趣的是，只有30年前发明的方法并没有太大变化。 <br><br> 大约在这个时候，OpenAI发布了他们的机器人。 当然不是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5乘5了</a> ，但是太棒了！ 我无法想出一个机器人的想法，首先我开始思考如何将其用作论文，新颖性以及如何将其呈现给领导者。 有了这方面的新颖性，一切都变得更好了-当然有可能针对前两个主题提出一些建议，但是很明显，该机器人使我思考，坚持，发展和寻找更强大的想法。 因此，我决定制作一个1对1机器人（像OpenAI一样在中间进行一场战斗），将其呈现给领导者，告诉它有多酷，有多少种不同的方法，数学方法，最重要的是，新方法。 <br><br> 该机器人在第一阶段需要的最必要的事情是了解其所处的环境-我打算从游戏的记忆中了解世界的状态，并在第一阶段中寻找指向实体列表的指针，并与Dog2 Source2Gen的创造力进行整合-这个东西产生了Source2引擎的结构，它从电路中获取。 出现方案的主要思想和前提条件是客户端和服务器之间的状态复制，但是显然，开发人员真的很喜欢这个思想，他们将其广泛分发，我建议您在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>阅读。 <br><br> 我有过反向工程经验：我为《寂静风暴》作弊，制作了密钥生成器（最有趣的是《黑与白》）-可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">DrMefistO</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">那里</a>读到什么密钥生成，在Cabal Online中进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">连击</a> （由于该游戏受到Game Guard的保护，所以一切都变得复杂，使其免受ring0（在内核模式下处于驱动程序下）的保护，隐藏了进程（这至少使其难以渗透）-可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读更多详细信息。 <br> 因此，我在这方面进行了开发，该机器人在计划的时间内可以访问环境。 令人惊奇的是，replicate堡服务器通过增量复制了多少信息给客户端，例如，客户端具有有关代理之间的任何传送者，健康状况及其变化的信息（除了Roshan，他没有复制）-所有这些都在战争迷雾中。 尽管遇到了一些困难，但这是我将在下一篇文章中讨论的内容。 <br> 如果您有一个疑问，为什么我不使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dota Bot Scripting</a> ，我将以文档摘录回答： <br><blockquote> 该API受到限制，以使脚本无法作弊-无法查询FoW中的单元，无法将命令发布给脚本无法控制的单元，等等。 </blockquote> 本系列文章针对的是对逆向工程主题感兴趣的初学者。 <br><br><h2>  3.我为什么要写这个 </h2><br> 结果，我在ml的bot的实现中遇到了许多问题，我花了足够的时间意识到在培训结束前的两年，我无法超越当前主题的知识和经验。 在Dota 2中，我从Dota Auto Chess风俗发布后就不再玩游戏了，我现在将空闲时间花在Apex Legend的文凭和反向课程上（在我看来，其结构与Dota 2非常相似）。 因此，所做工作的唯一好处是发表了有关该主题的技术文章。 <br><br><h2>  4. Dota 2 </h2><br> 我打算在一个真实的游戏Dota 2中展示这些原理。该游戏使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">防</a>作弊的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Valve Anti Cheat</a> 。 我真的很喜欢Valve公司：很棒的产品，导演，对球员的态度，Steam，Source Engine 2，... VAC。  VAC在用户模式（ring3）下工作，它不会扫描所有内容，并且与其他反作弊方法相比是无害的（esea所做的一切（特别是其反作弊行为都使使用此平台的所有愿望消失了））。 我确信VAC的工作方式非常谨慎-它不会从内核模式进行监视，不会禁止硬件（仅是一​​个帐户），不会在屏幕截图中插入水印-由于Valve对播放器的态度，它们不会为您安装完整的防病毒软件Game Guard，BattlEye，Warden和其他人，因为这一切都被黑了，而且还花费了游戏可能占用的处理器资源（即使这是定期进行的），因此存在误报（尤其是笔记本电脑上的玩家）。 在PUBG，Apex，Fortnite中是否不存在墙壁黑客，瞄准机器人，速度黑客，ESP？ <br><br> 实际上是关于Dota 2的游戏。游戏以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">40Hz</a> （25毫秒）的频率运行，客户端会插值游戏状态，不使用输入预测-如果您有滞后，则游戏-重要的是，甚至游戏，受控单位也不会完全冻结。 游戏机制服务器通过RUDP（可靠的UDP）与客户端交换加密的消息，客户端基本上发送输入（如果您托管大厅，则可以发送命令），服务器发送游戏世界和团队的副本。 导航在3D网格上进行，每个单元格都有其自己的通畅类型。 运动是通过导航和物理方法进行的（不可能通过振动筛，kogi clokverka等的裂缝）。 <br><br> 世界上所有实体的状态都以最原始的形式存在于内存中，没有加密-您可以使用作弊引擎来研究游戏的内存。 混淆不适用于字符串和代码。 <br><br><div class="spoiler">  <b class="spoiler_title">可从图形API获得DirectX9，DirectX11，Vulkan，OpenGL。</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/xc/xq/kl/xcxqkl2qpwy3gved7_jblzsqumo.png"><br></div></div><br><h2>  5.问题陈述 </h2><br> 在Dota 2游戏中，有一个中立的“远古时代”，杀死它可以得到很好的回报：经验，金钱，击退技能和物品冷却时间的能力，宙斯盾（第二生命），他的名字叫Roshan。 获得《宙斯盾》可以从根本上扭转游戏局面，或者让更强大的一方获得更大的优势，玩家试图记住/记录他的死亡时间，以便计划何时聚在一起攻击他，或者为了保护他而在附近。 通知Roshan死亡的所有十个玩家，无论Roshan是否被隐藏在战争迷雾中。 重生时间为强制性的八分钟，此后Roshan可能会在三分钟的间隔内随机出现。 <br><br>  <i>任务如下</i> ：向玩家提供Roshan当前状态的信息（“存活​​”，“ ressurect_base-复活基准时间”，“ ressurect_extra-复活额外时间”）。 <br><br> <a href=""><img src="https://habrastorage.org/webt/qf/ef/3s/qfef3s2h4a6l_pfageiblxwqhd8.png"></a> <br>  <i>图1-过渡期间状态与动作之间的过渡条件</i> <br><br> 对于Roshan死亡的情况，请显示在此状态下停留的结束时间。 从活动状态到ressurect_base的转换必须由播放器在手动模式下通过按钮完成。 如果在ressurect_extra状态下检测到Roshan /死亡（例如，一个敌方团队偷偷潜入窝中并杀死了他），也可以使用按钮手动进行到live / ressurect_base状态的转换。  Roshan的状态（以及处于恢复状态的结束时间）应以文本形式显示，必要的输入（杀死和中断ressurect_extra状态）应带有一个按钮。 <br><br><img src="https://habrastorage.org/webt/cb/xw/ne/cbxwneudadwlvbx4ch2gwumlona.png"><br>  <i>图2-界面元素-标签，按钮和画布</i> <br><br> 这是我能完成的唯一任务，因此我不需要处理游戏的记忆，并且至少对玩家有一定的价值-即使要得出任何基本特征，例如健康，法力和实体位置，您也需要事先找到它们帮助游戏中的作弊引擎，需要在相当长的时间内进行额外<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a> ，或者在Source2Gen的帮助下进行解释，这将在下一篇文章中进行介绍。 问题的陈述迫使玩家跟随Roshan，将很多动作转移给他，这很不方便-但在第二部分中将需要依靠。 <br><br> 我们将编写我们的Injection.dll，它将包含基于MVC的业务逻辑并在Dota 2流程中实现它。Dll将使用我们的Silk_way.lib库，该库将包含陷阱逻辑以更改执行流，记录器，内存扫描器和数据结构。 <br><br><h2>  6.喷油器 </h2><br> 创建一个空的C ++项目，调用NativeInjector。 主要代码在Inject函数中。 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; dllPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; processName)</span></span></span><span class="hljs-function"> </span></span>{ DWORD processId = GetProcessIdentificator(processName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (processId == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> invalid_argument(<span class="hljs-string"><span class="hljs-string">"Process dont existed"</span></span>); HANDLE hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, processId); HMODULE hModule = GetModuleHandle(<span class="hljs-string"><span class="hljs-string">"kernel32.dll"</span></span>); FARPROC address = GetProcAddress(hModule, <span class="hljs-string"><span class="hljs-string">"LoadLibraryA"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> payloadSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) * dllPath.length() + <span class="hljs-number"><span class="hljs-number">1</span></span>; LPVOID allocAddress = VirtualAllocEx( hProcess, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, payloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); SIZE_T written; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writeResult = WriteProcessMemory(hProcess, allocAddress, dllPath.c_str(), payloadSize, &amp; written); DWORD treadId; CreateRemoteThread(hProcess, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, (LPTHREAD_START_ROUTINE) address, allocAddress, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp; treadId); CloseHandle(hProcess); }</code> </pre> <br> 该函数获取进程的路径和名称，并使用GetProcessIdentificator通过进程的名称搜索其ID。 <br><br><div class="spoiler">  <b class="spoiler_title">函数GetProcessIdentificator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">DWORD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProcessIdentificator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; processName)</span></span></span><span class="hljs-function"> </span></span>{ PROCESSENTRY32 processEntry; processEntry.dwSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(PROCESSENTRY32); HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); DWORD processId = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Process32First(snapshot, &amp; processEntry)) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Process32Next(snapshot, &amp; processEntry)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_stricmp(processEntry.szExeFile, processName.c_str())) { processId = processEntry.th32ProcessID; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } CloseHandle(snapshot); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> processId; }</code> </pre> <br></div></div><br> 简而言之，GetProcessIdentificator运行所有正在运行的进程，并查找具有适当名称的进程。 <br><br><img src="https://habrastorage.org/webt/du/za/p1/duzap1ptnhys_gyk_e1zrjm436e.png"><br>  <i>图3-流程的初始状态</i> <br><br> 接下来，通过创建远程流直接实现该库。 <br><br><div class="spoiler">  <b class="spoiler_title">进样功能的详细说明</b> <div class="spoiler_text"> 根据找到的ID，使用具有创建线程，接收进程信息，写入和读取功能的权限的OpenProcess函数打开该进程。  GetModuleHandle函数检索kernel32库模块，这样做是为了获取GetProcAddress函数包含在其中的LoadLibraryA函数的地址。  LoadLibrary的目的是将我们的injection.dll加载到指定的进程中。 也就是说，我们需要从我们感兴趣的进程（“ Dota2.exe”）中调用LoadLibrary，为此，我们使用CreateRemoteThread远程创建一个新线程。 作为指向新线程启动的函数的指针，我们传递了LoadLibraryA函数的地址。 如果查看LoadLibraryA函数的签名，则它需要将已加载库的路径作为参数-HMODULE LoadLibraryA（LPCSTR lpLibFileName）。 我们按以下方式传递此参数：在start函数的地址获取指向其参数的指针之后，在参数中创建CreateRemoteThread，通过使用WriteProcessMemory函数将值写入进程内存（使用VirtualAllocEx分配内存之后），我们形成指向lpLibFileName的指针。 <br></div></div><br><img src="https://habrastorage.org/webt/wx/8r/5v/wx8r5viycrlhjarivk-02dgh124.png"><br>  <i>图4-创建远程流</i> <br><br> 确保最后使用CloseHandle函数关闭进程处理程序，也可以释放分配的内存。 我们的注射器已经准备就绪，正在等待我们使用silk_way.lib库在Injection.dll中编写业务逻辑。 <br><br><img src="https://habrastorage.org/webt/no/8c/tr/no8ctrxtn_vz31nad0uj25tb8zs.png"><br>  <i>图5-完成库的实现</i> <br><br> 为了更好地理解该原理，您可以观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视频</a> 。 最后，我要说的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，在</a>过程的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主线程中</a>直接执行代码是一种更安全的方法。 <br><br><h2>  7.丝绸之路 </h2><br> 让我们开始实现Silk_way.lib，这是一个静态库，其中包含数据结构，记录器，内存扫描器和陷阱。 实际上，我只花了我一小部分的工作，这是最容易解释的事情，虽然与其他部分并不太紧密，但同时可以解决问题。 <br><br><h3>  7.1。 数据结构。 </h3><br> 简要介绍一下数据结构：向量-经典列表，插入和删除时间O（N），搜索O（N），内存O（N）； 队列-循环队列，插入和删除的时间为O（1），无搜索，内存为O（N）；  RBTree-红黑树，插入和删除时间O（logN），搜索O（logN），内存O（N）。 我更喜欢用于在C＃和Python（标准C ++库使用的红黑树）中实现字典的哈希。 原因是散列比树更难以正确实现（大约每半年我会发现并尝试各种散列），并且散列通常占用更多内存（尽管它工作得更快）。 这些结构用于在业务逻辑和陷阱中创建集合。 <br><br> 我尝试不使用标准库中的结构，而是由我自己实现，在我们的情况下，这并不重要，但是重要的是，如果您的dll被调试或组装清晰（这很可能是出于商业目的，我们对此表示谴责） ） 我建议您自己编写所有结构，这会给您带来更多机会。 <br> 例如，如果您制作游戏并且不希望“学童”使用作弊引擎对其进行扫描，则可以为原始类型制作包装并将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">加密后的</a>值存储在内存中。 实际上，这不是救赎，但它可以淘汰一些尝试阅读和更改游戏记忆的人。 <br><br><h3>  7.2。 记录仪 </h3><br> 实现输出到控制台并写入文件。 介面 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ILogger</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: ILogger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * _path) { path = path; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ILogger() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * format, ...)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * path; };</code> </pre> <br> 输出到文件的实现： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemoryLogger</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ILogger { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MemoryLogger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * _path): ILogger(_path) { fopen_s( &amp; fptr, _path, <span class="hljs-string"><span class="hljs-string">"w+"</span></span>); } ~MemoryLogger() { fclose(fptr); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * format, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>[MAX_LOG_SIZE]; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>[MAX_LOG_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; va_list args; va_start(args, format); vsprintf_s(<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>, MAX_LOG_SIZE, format, args); va_end(args); <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(fptr, <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: FILE * fptr; };</code> </pre> <br> 输出到控制台的实现是相同的。 如果要使用日志记录，则必须定义ILogger *接口，声明必要的记录器，以所需的格式调用Log函数，例如： <br><br><pre> <code class="cpp hljs">ILogger* logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryLogger(filename); logger-&gt;Log(<span class="hljs-string"><span class="hljs-string">"(%llu)%s: %d\n"</span></span>, GetCurrentThreadId(), <span class="hljs-string"><span class="hljs-string">"EnumerateThread result"</span></span>, result);</code> </pre> <br><h3>  7.3。 扫描仪 </h3><br> 扫描仪会进行以下操作：显示由传输的指针指向的内存值，并将其与内存中的样本进行比较。 与模式的功能比较将在以后考虑。 <br><br> 介面 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IScanner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IScanner() {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IScanner() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * title, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * memPointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br> 头文件的实现： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileScanner</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IScanner { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FileScanner(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* _path) : IScanner() { fopen_s(&amp;fptr, _path, <span class="hljs-string"><span class="hljs-string">"w+"</span></span>); } ~FileScanner() { fclose(fptr); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* title, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* memPointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: FILE* fptr; };</code> </pre> <br> 源文件实现： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FileScanner::PrintMemory(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* title, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* memPointer, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(fptr, <span class="hljs-string"><span class="hljs-string">"%s:\n"</span></span>, title); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(fptr, <span class="hljs-string"><span class="hljs-string">"%x "</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(*(memPointer + i))); <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(fptr, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>, title); }</code> </pre> <br> 要使用它，您需要定义IScanner *接口，声明所需的扫描仪并调用PrintMemory函数，您可以在其中设置标题，指针和长度，例如： <br><br><pre> <code class="cpp hljs">IScanner* scan = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleScanner(); scan-&gt;PrintMemory(<span class="hljs-string"><span class="hljs-string">"source orig"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)source, <span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br><h3>  7.4。 陷阱 </h3><br>  silk_way.lib库中最有趣的部分。 挂钩用于更改程序执行的流程。 创建一个名为Sandbox的可执行项目。 <br><br><div class="spoiler">  <b class="spoiler_title">Device类将是我们用来调查陷阱操作的虚拟对象。</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unknown</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: Unknown() {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~Unknown() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueryInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Device</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Unknown { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Device() : Unknown() {} ~Device() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueryInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Present</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Present()"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndScene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EndScene()"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Dispose()"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; };</code> </pre> <br></div></div><br>  Device类是从IUnknown接口继承的，我们的任务是拦截Device的任何实例的Present和EndScene函数的调用，并在接收器中调用原始函数。 我们不知道在代码中在哪个线程中何处以及为何调用这些函数。 <br><br> 查看Present和EndScene函数，我们看到它们是虚拟的。 需要虚拟函数来覆盖父类的行为。 虚拟函数和非虚拟函数都是指向其中写入操作码和参数值的内存的指针。 由于继承人和父母之间的虚拟功能不同，因此它们具有不同的指针（它们是完全不同的功能），并存储在虚拟方法表（VMT）中。 该表存储在内存中，并且是指向类指针的指针，我们在Device中找到它： <br><br><pre> <code class="cpp hljs">Device* device = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Device(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vmt = **(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>**)&amp;device;</code> </pre> <br>  VMT存储指向虚拟函数的指针，如果我们要从Device继承，则继承人将包含其VMT。  VMT按等于指针大小的步长顺序存储函数指针（对于x86，它是4个字节，对于x64，它是8个字节），对应于在类中定义函数的顺序。 找到位于第三和第四位的Present和EndScene函数的指针： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pPresent)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pEndScene)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span></span>; pPresent ptrPresent = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; pEndScene ptrEndScene = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//declare Device and find pointer vmt ptrPresent = (pPresent)(*(unsigned long long*)(vmt + 8 * 3)); ptrEndScene = (pEndScene)(*(unsigned long long*)(vmt + 8 * 4)); }</span></span></code> </pre> <br> 同样重要的是，指向类方法的指针必须包含第一个参数，作为对类实例的引用。 在C ++，C＃中，这对我们是隐藏的，编译器知道这一点-在Python中，self是由class方法中的第一个参数明确表示的。 有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>的调用约定的更多信息，您需要查找此调用。 <br><br> 考虑指令e9 ff 3a fd ff-这里的e9是一个操作码（带有JMP助记符），它告诉处理器将指针更改为指令（对于x86为EIP，对于x64为RIP），从当前地址跳转到FFFD3AFF（4294785791）。 还值得注意的是，在内存中存储的数字“反之亦然”。 函数有一个序言和一个结尾，并存储在.code节中。 让我们看看使用扫描器使用指向Present函数的指针存储的内容： <br><br><pre> <code class="cpp hljs">IScanner* scan = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleScanner(); scan-&gt;PrintMemory(<span class="hljs-string"><span class="hljs-string">"Present"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)ptrPresent, <span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br> 在控制台中，我们看到： <br><br><pre> <code class="plaintext hljs">Present: 48 89 4c 24 8 48 83 ec 28 48 8d 15 40 4a 0 0 48 8b d 71 47 0 0 e8 64 10 0 0 48 8d</code> </pre> <br> 要了解这些代码的集合，可以查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">表格</a> ，或使用可用的反汇编程序。 我们将使用现成的反汇编程序<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-hde</a> （黑客反汇编程序引擎）。 您也可以查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">distorm</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">顶点</a>以进行比较。 将指向函数的指针传递给任何反汇编程序，它将说明其使用的操作码，参数的值，等等。 <br><br><h4>  7.4.1操作码挂钩 </h4><br> 现在我们准备直接进入陷阱。 我们将研究操作码挂钩和硬件断点。 我建议实施和探索的最<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">常见陷阱</a> 。 <br><br> 可能最常用和最简单的陷阱是Opcode Hook（在列出陷阱的文章中，它称为字节修补）-请注意，如果误用它，它很容易被反作弊识别（无需了解反作弊的工作原理，而无需知道扫描的内存区域和部分。当前时刻和其他禁令将不会放慢脚步等待）。 如果熟练使用，这是一个很好的陷阱，快速且易于理解。 <br> 如果在阅读文章时您正在同时播放代码并处于Debug模式，请切换到Release-这很重要。 <br><br> 因此，让我提醒您，我们需要拦截Present和EndScene函数的执行。 <br> 我们实现拦截器-我们要转移控制的函数： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PresentHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"PresentHook"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSceneHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EndSceneHook"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br> 让我们考虑一下我们需要的抽象。 我们需要一个接口，使我们能够设置陷阱，删除陷阱并提供有关它的信息。 有关陷阱的信息应包含指向被拦截函数，接收器函数和跳板的指针（事实上，我们拦截该函数并不意味着不再需要它，我们还希望能够使用它-跳板将有助于调用原始的被拦截函数）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push, 1) struct HookRecord { HookRecord() { reservationLen = 0; sourceReservation = new void*[RESERV_SIZE](); } ~HookRecord() { reservationLen = 0; delete[] sourceReservation; } void* source; void* destination; void* pTrampoline; int reservationLen; void* sourceReservation; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(pop) class IHook { protected: IHook() {} public: virtual ~IHook() {} virtual void SetExceptionHandler( PVECTORED_EXCEPTION_HANDLER pVecExcHandler) = 0; virtual int SetHook(void* source, void* destination) = 0; virtual int UnsetHook(void* source) = 0; virtual silk_data::Vector</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;HookRecord*&gt;* GetInfo() = 0; virtual HookRecord* GetRecordBySource(void* source) = 0; };</span></span></span></span></code> </pre> <br>  IHook界面为我们提供了此类功能。 我们希望当Device类的任何实例调用Present和EndScene函数时（即RIP指针都指向这些地址），我们的PresentHook和EndSceneHook函数将相应执行。 <br><br> 直观地想象一下，当控件进入拦截函数时，拦截函数，接收器和跳板如何位于内存（.code节）中： <br><br><img src="https://habrastorage.org/webt/rc/sz/dw/rcszdw_mh77t0jlxithbmseq5i8.png"><br>  <i>图6-内存的初始状态，执行进入被拦截的函数</i> <br><br> 现在我们希望RIP（红色箭头）从源到目标的起点。 怎么做？ 如上所述，源存储器包含操作码，当执行到达源代码时，处理器将执行该操作码。 本质上，我们需要从一个部分跳到另一部分，重定向RIP指针。 您可能已经猜到了，有一个操作码可让您将控制权从当前地址转移到所需地址，此JMP助记符称为。 <br><br> 您可以直接跳转到所需的地址，也可以相对于当前地址跳转，分别在板ff和e9中可以找到这些跳转。 为这些说明创建结构： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push, 1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 32-bit relative jump. typedef struct { unsigned char opcode; unsigned int delta; } JMP_REL; // 64-bit absolute jump. typedef struct { unsigned char opcode1; unsigned char opcode2; unsigned int dummy; unsigned long long address; } JMP_ABS; #pragma pack(pop)</span></span></span></span></code> </pre> <br> 相对跳转指令较短，但是有一个限制-unsigned int表示您可以在4,294,967,295之内跳转，这对于x64而言还不够。 <br> 因此，目标接收者的目标函数地址很容易超过该值并且在unsigned int之外，这对于x64进程来说是很有可能的（对于x86，一切都简单得多，您可以将自己限制在实现操作码挂钩的相对相对位置上）。 直接跳转需要14个字节，为了进行比较，相对跳转只有5个字节（我们打包了结构，请注意#pragma pack（push，1））。 <br><br> 我们需要将源处的值重写为这些跳指令之一。 <br> 在捕获函数之前，应先进行研究-最简单的方法是使用调试器（稍后将向您展示如何使用x64dbg进行调试）或使用反汇编器。 对于Present，我们已经从其开始输出了30个字节，指令48 89 4c 24 8占用5个字节。 <br> 让我们实现一个相对跳转。 由于指令的长度，我更喜欢此选项。 这个想法是这样的：我们替换原始函数的前5个字节，保留更改后的字节，并用相对跳转到指令地址的相对替换来替换，该地址位于unsigned int内。 <br><br><img src="https://habrastorage.org/webt/sp/vm/gs/spvmgsf5iymwkeyncackpgaldty.png"><br>  <i>图7-源函数的源5个字节被相对跳转替换</i> <br><br> 是什么让我们跳到了分配的内存（紫色区域），我们如何通过这种动作使自己更接近将控制权转移到目的地？ 在我们分配的内存中，有一个直接跳转，它将把RIP移到目的地。 <br><br><img src="https://habrastorage.org/webt/nl/-c/u2/nl-cu2sfhlsg-7nvfdmkzmlz8fq.png"><br>  <i>图8-将RIP切换到接收器功能</i> <br><br> 还需要弄清楚如何调用捕获的函数。 我们需要执行阻塞的指令，并从源代码的原始部分开始执行。 我们进行如下操作-将损坏的指令保存到蹦床的开头，记住有多少字节被损坏，然后直接跳转到source + destroyLen，转到“健康”指令。 <br><br> 执行相对跳转删除的已保存指令： <br><br><img src="https://habrastorage.org/webt/ea/yt/yc/eaytyckn1czk5ud3iid3fagbey0.png"><br>  <i>图9-使用跳板调用拦截的函数</i> <br><br> 进一步执行不影响混搭的指令： <br><br><img src="https://habrastorage.org/webt/mh/7f/-w/mh7f-wck4tzh20cj7jefie3yl3q.png"><br>  <i>图10-继续执行所拦截函数的指令</i> <br><br><div class="spoiler">  <b class="spoiler_title">实现上述想法的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OpcodeHook::SetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* destination) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HookRecord(); record-&gt;source = source; record-&gt;destination = destination; info-&gt;PushBack(record); JMP_ABS pattern = {<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>, <span class="hljs-comment"><span class="hljs-comment">// JMP[RIP + 6] empty 0x0000000000000000 }; // absolute address pattern.address = (ULONG_PTR)source; int currentLen = 0; int redLine = sizeof(JMP_REL); while (currentLen &lt; redLine) { hde64s context; const void* pSource = (void*)((unsigned char*)source + currentLen); hde64_disasm(pSource, &amp;context); memcpy((unsigned char*)record-&gt;sourceReservation + currentLen, pSource, context.len); record-&gt;reservationLen += context.len; currentLen += context.len; } int trampolineMemorySize = 2 * sizeof(JMP_ABS) + record-&gt;reservationLen; record-&gt;pTrampoline = AllocateMemory(source, trampolineMemorySize); pattern.address = (unsigned long long)(unsigned char*)source + record-&gt;reservationLen; memcpy((unsigned char*)record-&gt;pTrampoline, record-&gt;sourceReservation, record-&gt;reservationLen); int offset = record-&gt;reservationLen; memcpy((unsigned char*)record-&gt;pTrampoline + offset, &amp;pattern, sizeof(JMP_ABS)); pattern.address = (ULONG_PTR)destination; ULONG_PTR relay = (ULONG_PTR)record-&gt;pTrampoline + sizeof(pattern) + record-&gt;reservationLen; memcpy((void*)relay, &amp;pattern, sizeof(pattern)); DWORD oldProtect = 0; VirtualProtect(source, sizeof(JMP_REL), PAGE_EXECUTE_READWRITE, &amp;oldProtect); JMP_REL* pJmpRelPattern = (JMP_REL*)source; pJmpRelPattern-&gt;opcode = 0xE9; pJmpRelPattern-&gt;delta = (unsigned int)((LPBYTE)relay - ((LPBYTE)source + sizeof(JMP_REL))); VirtualProtect(source, sizeof(JMP_REL), oldProtect, &amp;oldProtect); return SUCCESS_CODE; }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">功能说明SetHook</b> <div class="spoiler_text"> 将创建一条记录，该记录存储有关陷阱的信息，然后将记录添加到集合中。 从源地址的开头开始对指令进行爬网，直到可以完全输入相对的跳转指令（5个字节），然后将阻塞的指令复制到保留区中，并记住它们的长度。 <br><blockquote> 非常重要的一点是，我们需要为跳板和中继分配内存，在其中我们将存储用于将流从源重定向到目标的指令，并且该内存的地址应在相对跳转可以跳转到的范围内（无符号） int）。 </blockquote><br> 此功能实现了AllocateMemory功能。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* OpcodeHook::AllocateMemory(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* origin, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MEMORY_RANGE = <span class="hljs-number"><span class="hljs-number">0x40000000</span></span>; SYSTEM_INFO sysInfo; GetSystemInfo(&amp;sysInfo); ULONG_PTR minAddr = (ULONG_PTR)sysInfo.lpMinimumApplicationAddress; ULONG_PTR maxAddr = (ULONG_PTR)sysInfo.lpMaximumApplicationAddress; ULONG_PTR castedOrigin = (ULONG_PTR)origin; ULONG_PTR minDesired = castedOrigin - MEMORY_RANGE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minDesired &gt; minAddr &amp;&amp; minDesired &lt; castedOrigin) minAddr = minDesired; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> test = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ULONG_PTR); ULONG_PTR maxDesired = castedOrigin + MEMORY_RANGE - size; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxDesired &lt; maxAddr &amp;&amp; maxDesired &gt; castedOrigin) maxAddr = maxDesired; DWORD granularity = sysInfo.dwAllocationGranularity; ULONG_PTR freeMemory = <span class="hljs-number"><span class="hljs-number">0</span></span>; ULONG_PTR ptr = castedOrigin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ptr &gt;= minAddr) { ptr = FindPrev(ptr, minAddr, granularity, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; LPVOID pAlloc = VirtualAlloc((LPVOID)ptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pAlloc != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pAlloc; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ptr &lt; maxAddr) { ptr = FindNext(ptr, maxAddr, granularity, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; LPVOID pAlloc = VirtualAlloc((LPVOID)ptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pAlloc != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pAlloc; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br> 这个想法很简单-我们将从内存开始，从某个地址（在本例中为指向源的指针）开始向上和向下移动，直到找到合适的自由大小。 <br><br> 返回SetHook函数。 将已磨损的字节从源复制到分配的内存中，然后立即直接插入到源+损坏的跳转中，以继续执行未损坏的指令。 <br><br> 接下来是中继指针的安装，它负责通过直接跳转到接收器地址来将执行线程重定向到目标。 最后，我们更改了源-我们将写权限设置为函数所在的内存位置，并将前5个字节替换为导致中继地址的相对跳转。 <br></div></div><br> 我们设置了一个陷阱，但它也需要能够清洁。 中断-不是构建，想法很简单-我们将返回源的破旧字节，从集合中删除有关陷阱的记录，并释放分配的内存： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OpcodeHook::UnsetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = GetRecordBySource(source); DWORD oldProtect = <span class="hljs-number"><span class="hljs-number">0</span></span>; VirtualProtect(source, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(JMP_REL), PAGE_EXECUTE_READWRITE, &amp;oldProtect); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(source, record-&gt;sourceReservation, record-&gt;reservationLen); VirtualProtect(source, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(JMP_REL), oldProtect, &amp;oldProtect); info-&gt;Erase(record); FreeMemory(record); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS_CODE; }</code> </pre> <br> 测试工作。 立即更改我们的接收器，以便它们可以使用跳板调用拦截的函数： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PresentHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(ptrPresent); pPresent pTrampoline = (pPresent)record-&gt;pTrampoline; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = pTrampoline(device); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"PresentHook"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSceneHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(ptrEndScene); pEndScene pTrampoline = (pEndScene)record-&gt;pTrampoline; pTrampoline(device, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EndSceneHook"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们测试是否正确执行了所有操作，内存是否在流动，是否正确执行了所有操作。</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { Device* device = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Device(); device-&gt;i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vmt = **(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>**)&amp;device; ptrPresent = (pPresent)(*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(vmt + <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span>)); ptrEndScene = (pEndScene)(*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(vmt + <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>)); IScanner* scan = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleScanner(); scan-&gt;PrintMemory(<span class="hljs-string"><span class="hljs-string">"Present"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)ptrPresent, <span class="hljs-number"><span class="hljs-number">30</span></span>); hook = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpcodeHook(); hook-&gt;SetHook(ptrPresent, &amp;PresentHook); hook-&gt;SetHook(ptrEndScene, &amp;EndSceneHook); device-&gt;Present(); device-&gt;EndScene(<span class="hljs-number"><span class="hljs-number">7</span></span>); device-&gt;Present(); device-&gt;EndScene(<span class="hljs-number"><span class="hljs-number">7</span></span>); device-&gt;i = <span class="hljs-number"><span class="hljs-number">5</span></span>; ptrPresent(device); ptrEndScene(device, <span class="hljs-number"><span class="hljs-number">9</span></span>); hook-&gt;UnsetHook(ptrPresent); hook-&gt;UnsetHook(ptrEndScene); ptrPresent(device); ptrEndScene(device, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> hook; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> device; } }</code> </pre> <br></div></div><br> 可以用<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您还可以检入x64dgb。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还记得吗，起初我要求您从事发布版本？</font><font style="vertical-align: inherit;">现在去调试并运行程序。</font><font style="vertical-align: inherit;">程序崩溃...陷阱被触发，但是尝试调用跳板会引发异常，该异常表示我们调用跳板的地址根本无法执行。</font><font style="vertical-align: inherit;">我们错过了什么？</font><font style="vertical-align: inherit;">调试版本有什么问题？</font><font style="vertical-align: inherit;">我们开始看一下Present函数的操作码：</font></font><br><br><pre> <code class="plaintext hljs">Present: e9 f4 36 0 0 e9 df 8d 0 0 e9 aa b0 0 0 e9 75 3e 0 0 e9 80 38 0 0 e9 da 81 0 0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在x64dbg中运行时，可以看到以下内容。</font><i><font style="vertical-align: inherit;">图11-调试构建指令</font></i><font style="vertical-align: inherit;">在Debug中，操作码已更改，现在编译器添加了相对跳转e9 f4 360。所有函数都包装在跳转中，包括main和mainCRTStartup的入口点。好吧，好吧，另一个操作码，必须将其复制到跳板上，当调用跳板时，应调用此相对跳转，然后直接跳转到源的未损坏部分。</font><font style="vertical-align: inherit;">在这里可以清楚地看到，一切都按照我们已经实现的完成，只有相对跳转和相对跳转，从不同地址，源和蹦床的执行使RIP暴露于完全不同的值。</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/sq/ql/ea/sqqlealqgipytxtvqo65agm9ky8.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以我的拙劣经验，相对跳转案例的实现涵盖了99％的使用率。还有更多的操作码应单独处理。请记住，在对函数设置陷阱之前，您不应该太懒惰并研究它。我不会打扰您，也不会在100％版本中添加功能（再次，以我的拙劣经验），如果您需要它或感兴趣的话，您可以看到此类库的排列方式以及它们专门检查的其他情况-这样做很容易如果您知道这是什么。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相对跳转确实很常见，因此我建议实现它。</font><font style="vertical-align: inherit;">相对跳转由e9操作码和您需要跳转到相对于当前地址的值组成。</font><font style="vertical-align: inherit;">因此，您只需找出要跳到的位置，然后直接从跳板跳到那里即可。</font><font style="vertical-align: inherit;">即使我们在那里遇到了新的相对跳转，也已经来自正确的地址。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑到相对跳转的陷阱安装的实现</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OpcodeHook::SetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* destination) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HookRecord(); record-&gt;source = source; record-&gt;destination = destination; info-&gt;PushBack(record); JMP_ABS pattern = {<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>, <span class="hljs-comment"><span class="hljs-comment">// JMP[RIP + 6] empty 0x0000000000000000 }; // address pattern.address = (ULONG_PTR)source; int currentLen = 0; bool isJmpOpcode = false; int redLine = sizeof(JMP_REL); while (currentLen &lt; redLine &amp;&amp; !isJmpOpcode) { hde64s context; const void* pSource = (void*)((unsigned char*)source + currentLen); hde64_disasm(pSource, &amp;context); if (context.opcode == 0xE9) { ULONG_PTR ripPtr = (ULONG_PTR)pSource + context.len + (INT32)context.imm.imm32; pattern.address = ripPtr; isJmpOpcode = true; } memcpy((unsigned char*)record-&gt;sourceReservation + currentLen, pSource, context.len); record-&gt;reservationLen += context.len; currentLen += context.len; } int trampolineMemorySize = isJmpOpcode ? 2 * sizeof(JMP_ABS) : 2 * sizeof(JMP_ABS) + record-&gt;reservationLen; record-&gt;pTrampoline = AllocateMemory(source, trampolineMemorySize); if (!isJmpOpcode) { pattern.address = (unsigned long long)(unsigned char*)source + record-&gt;reservationLen; memcpy((unsigned char*)record-&gt;pTrampoline, record-&gt;sourceReservation, record-&gt;reservationLen); } int offset = isJmpOpcode ? 0 : record-&gt;reservationLen; memcpy((unsigned char*)record-&gt;pTrampoline + offset, &amp;pattern, sizeof(JMP_ABS)); pattern.address = (ULONG_PTR)destination; ULONG_PTR relay = (ULONG_PTR)record-&gt;pTrampoline + sizeof(pattern) + record-&gt;reservationLen; memcpy((void*)relay, &amp;pattern, sizeof(pattern)); DWORD oldProtect = 0; VirtualProtect(source, sizeof(JMP_REL), PAGE_EXECUTE_READWRITE, &amp;oldProtect); JMP_REL* pJmpRelPattern = (JMP_REL*)source; pJmpRelPattern-&gt;opcode = 0xE9; pJmpRelPattern-&gt;delta = (unsigned int)((LPBYTE)relay - ((LPBYTE)source + sizeof(JMP_REL))); VirtualProtect(source, sizeof(JMP_REL), oldProtect, &amp;oldProtect); return SUCCESS_CODE; }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果反汇编程序返回该命令的操作码为e9的信息，我们将计算要跳转到的地址（ULONG_PTR ripPtr =（ULONG_PTR）pSource + context.len +（INT32）context.imm.imm32），并将该地址写入跳板作为直接跳转参数的值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我还注意到，在多线程环境中，当安装/卸下钩子时，其中一个线程可以开始执行我们捕获的功能时，可能会出现这种情况-结果，该进程将崩溃。硬件断点中将介绍部分处理方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您需要经过验证的工具，则希望确保陷阱能够正常工作，没有自己的想法，也不想研究功能序言-使用现成的解决方案，例如，Microsoft提供了自己的Detour库。</font><font style="vertical-align: inherit;">由于多种原因，我不使用此类库并使用自制的解决方案，因此我无法提供任何建议，我只能命名研究的库以发现新内容并使用它：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PolyHook</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MinHook</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EasyHook</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（尤其是如果您需要在C＃中使用钩子）。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4.2。</font><font style="vertical-align: inherit;">硬件断点</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opcode Hook是一个简单快速的陷阱，但不是最有效的。反作弊可以很容易地跟踪内存中的变化，但是可以将操作码挂钩用于反作弊本身或拦截它所使用的系统调用（例如NtSetInformationThread）。硬件断点是一个不会更改进程内存的陷阱。我在论坛上看到线程询问VAC是否遵循此陷阱-答案通常是混杂的。就个人而言，VAC并没有禁止我使用它们，也没有重置寄存器（不到六个月前，也许有所改变）。</font></font><br><blockquote>    ,   ,  VAC   DR      /,  -      ,    .    HWBP  ,  -  ,     ,   ,        DR0-DR7    . </blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWBP使用特殊的处理器寄存器来中断线程执行。如果流上下文包含以某种方式设置的DR0-DR7寄存器，并且RIP转到DR0-DR3中存储的四个地址之一，则将引发异常，可以通过异常的类型和上下文的状态来捕获该异常，确定控制将异常抛出到哪个地址并得出结论-是否有陷阱。这种方法的一个重大局限性是您一次只能使用四个函数，并分别为每个线程设置它们，如果设置了陷阱并创建了一个新函数/重新创建了旧线程，这会导致陷阱，这将带来不便。这不是一个特殊的障碍，并且由对BaseThreadInitThunk函数的拦截来控制；对使用4个陷阱的限制并没有真正使我个人感到困扰。如果挂钩数量对您来说很关键，请查看PageGuard方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，任务是相同的-我们在沙盒（Sandbox项目）中，有必要拦截Device Present和EndScene类的方法，以在其中调用原始方法。</font><font style="vertical-align: inherit;">我们已经有现成的陷阱接口-IHook，让我们处理“铁”断点的工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原理是这样的：有四个可以写入地址的“工作中” DR0-DR3寄存器，当尝试在指定地址进行写入，读取或执行时，取决于DR7控制寄存器的设置，将发生EXCEPTION_SINGLE_STEP类型的异常，必须在先前注册的处理程序中进行处理。 。</font><font style="vertical-align: inherit;">您可以同时使用SEH处理程序和VEH-我们将使用后者，因为它具有更高的优先级。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们意识到这个想法：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HardwareBPHook::SetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* destination, HANDLE* hThread, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* reg) { CONTEXT context; ZeroMemory(&amp;context, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(context)); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_GET_CONTEXT; *(&amp;context.Dr0 + *reg) = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)source; context.Dr7 |= <span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * (*reg)); context.Dr7 |= HW_EXECUTE &lt;&lt; ((*reg) * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span>); context.Dr7 |= HW_LENGTH &lt;&lt; ((*reg) * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">18</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!SetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_SET_CONTEXT; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS_CODE; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码中会发生什么</font></font></b> <div class="spoiler_text">      ,          ,    DR7.     . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于DR6和DR7是什么以及PageGuard方法的更多详细信息，我可以建议Gray Hat Python：面向黑客和逆向工程师的Python编程。简而言之，DR7启用/禁用“工作”寄存器的使用-即使任何DR0-DR3寄存器包含一个地址，但在DR7中，相应寄存器的标志被禁用，断点也将不起作用。 DR7还使用需要引发异常的地址来设置工作类型-是否读取了地址，是否进行了记录还是使用了地址来执行指令（我们对最后一个选项感兴趣）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清除陷阱也非常简单，可以通过DR7控制寄存器完成。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HardwareBPHook::UnsetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source, HANDLE* hThread) { CONTEXT context; ZeroMemory(&amp;context, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(context)); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_GET_CONTEXT; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; DEBUG_REG_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)source == *(&amp;context.Dr0 + i)) { info-&gt;GetItem(i)-&gt;source = <span class="hljs-number"><span class="hljs-number">0</span></span>; *(&amp;context.Dr0 + i) = <span class="hljs-number"><span class="hljs-number">0</span></span>; context.Dr7 &amp;= ~(<span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * i)); context.Dr7 &amp;= ~(<span class="hljs-number"><span class="hljs-number">3</span></span> &lt;&lt; (i * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span>)); context.Dr7 &amp;= ~(<span class="hljs-number"><span class="hljs-number">3</span></span> &lt;&lt; (i * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">18</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!SetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_SET_CONTEXT; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS_CODE; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它仍然需要处理线程-应该为那些调用拦截函数的线程设置陷阱。</font><font style="vertical-align: inherit;">我们不会为此而烦恼。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们为进程的所有线程设置了陷阱。</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HardwareBPHook::SetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* destination) { THREADENTRY32 te32; HANDLE hThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hThread == INVALID_HANDLE_VALUE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_ENUM_THREAD_START; te32.dwSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(THREADENTRY32); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Thread32First(hThread, &amp;te32)) { CloseHandle(hThread); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_ENUM_THREAD_START; } DWORD dwOwnerPID = GetCurrentProcessId(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isRegDefined = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> freeReg = <span class="hljs-number"><span class="hljs-number">-1</span></span>; Freeze(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (te32.th32OwnerProcessID == dwOwnerPID) { HANDLE openThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isRegDefined) { CONTEXT context; ZeroMemory(&amp;context, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(context)); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetThreadContext(openThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_GET_CONTEXT; freeReg = GetFreeReg(&amp;context.Dr7); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (freeReg == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_GET_FREE_REG; isRegDefined = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } SetHook(source, destination, &amp;openThread, &amp;freeReg); CloseHandle(openThread); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Thread32Next(hThread, &amp;te32)); CloseHandle(hThread); Unfreeze(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = info-&gt;GetItem(freeReg); record-&gt;source = source; record-&gt;destination = destination; record-&gt;pTrampoline = source; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS_CODE; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面的代码绕过所有可见的进程并搜索当前进程。</font><font style="vertical-align: inherit;">在为下一个线程找到的过程中，我们获取流处理程序，找到四个空闲寄存器之一并设置一个陷阱。</font><font style="vertical-align: inherit;">值得关注的是Freeze和Unfreeze函数-这就是Opcode Hook谈到的多线程-它们完全停止了该进程的线程的执行（当前线程除外），因此当线程之一进入被拦截的函数时不会出现任何情况。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保护线程不调用钩子函数</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IHook::Freeze() { THREADENTRY32 te32; HANDLE hThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hThread == INVALID_HANDLE_VALUE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_ENUM_THREAD_START; te32.dwSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(THREADENTRY32); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Thread32First(hThread, &amp;te32)) { CloseHandle(hThread); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_ENUM_THREAD_START; } DWORD dwOwnerPID = GetCurrentProcessId(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (te32.th32OwnerProcessID == dwOwnerPID &amp;&amp; te32.th32ThreadID != GetCurrentThreadId()) { HANDLE openThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openThread != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { SuspendThread(openThread); CloseHandle(openThread); } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Thread32Next(hThread, &amp;te32)); CloseHandle(hThread); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS_CODE; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IHook::Unfreeze() { <span class="hljs-comment"><span class="hljs-comment">// equal { HANDLE openThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); if (openThread != NULL) { ResumeThread(openThread); CloseHandle(openThread); } } // equal return 0; }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在清除陷阱的功能中需要实现类似的功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍然需要添加VEH异常处理程序。</font><font style="vertical-align: inherit;">添加和删​​除是通过任意流的AddVectoredExceptionHandler和RemoveVectoredExceptionHandler函数完成的。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> HardwareBPHook::SetExceptionHandler(PVECTORED_EXCEPTION_HANDLER pVecExcHandler) { pException = AddVectoredExceptionHandler(<span class="hljs-number"><span class="hljs-number">1</span></span>, pVecExcHandler); } ~HardwareBPHook() { info-&gt;Clear(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> info; RemoveVectoredExceptionHandler(pException); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理程序必须检查异常的类型（需要EXCEPTION_SINGLE_STEP），检查发生异常的地址与寄存器中的内容的对应关系，如果找到了这样的地址，则将RIP指针重新排列为接收者的地址。</font><font style="vertical-align: inherit;">堆栈的状态得以保留，以便在进一步执行接收器时，堆栈上的所有参数将保持不变。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在沙箱中实现了所描述的处理程序：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">LONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnExceptionHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( EXCEPTION_POINTERS* exceptionPointers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ExceptionRecord-&gt;ExceptionCode != EXCEPTION_SINGLE_STEP) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_CONTINUE_EXECUTION; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; DEBUG_REG_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ContextRecord-&gt;Rip == (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;source) { exceptionPointers-&gt;ContextRecord-&gt;Rip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;destination; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_CONTINUE_EXECUTION; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理论上，一切就绪，我们运行程序，等待与OpcodeHook完全相同的工作。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会发生这种情况，我们的程序会冻结-更确切地说，它会不断进入PresentHook，并在应调用跳板的那一刻再次调用该函数。事实是，“铁”断点并没有消失，因为当您调用跳板（在“铁”断点的情况下，它指示原始功能）时，我们再次报警相同的地址并引发异常。解决方案如下：在特定线程的处理程序中找到断点后，我们将其删除，并在适当的时候再次设置该断点。更新的位置将选择接收器功能结束的时间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是按以下方式实现的-在处理程序中，除了删除断点外，还添加了一个待处理命令，其含义是更新指定流中的断点。</font><font style="vertical-align: inherit;">该命令在接收器功能的末尾运行。</font></font><br><br><pre> <code class="cpp hljs">IDeferredCommands* hookCommands; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PresentHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(ptrPresent); pPresent pTrampoline = (pPresent)record-&gt;pTrampoline; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = pTrampoline(device); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"PresentHook"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; hookCommands-&gt;Run(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSceneHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(ptrEndScene); pEndScene pTrampoline = (pEndScene)record-&gt;pTrampoline; pTrampoline(device, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EndSceneHook"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; hookCommands-&gt;Run(); } <span class="hljs-function"><span class="hljs-function">LONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnExceptionHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EXCEPTION_POINTERS* exceptionPointers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ExceptionRecord-&gt;ExceptionCode != EXCEPTION_SINGLE_STEP) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_CONTINUE_EXECUTION; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; DEBUG_REG_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ContextRecord-&gt;Rip == (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;source) { exceptionPointers-&gt;ContextRecord-&gt;Dr7 &amp;= ~(<span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * i)); exceptionPointers-&gt;ContextRecord-&gt;Rip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;destination; IDeferredCommand* cmd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SetD7Command(hook, GetCurrentThreadId(), i); hookCommands-&gt;Enqueue(cmd); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_CONTINUE_EXECUTION; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待执行命令</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> silk_way { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDeferredCommand</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IDeferredCommand(silk_way::IHook* _hook) { hook = _hook; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IDeferredCommand() { hook = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: silk_way::IHook* hook; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetD7Command</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDeferredCommand { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SetD7Command(silk_way::IHook* _hook, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> _threadId, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _reg) : IDeferredCommand(_hook) { threadId = _threadId; reg = _reg; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, threadId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hThread != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res = SetD7(&amp;hThread); CloseHandle(hThread); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetD7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE* hThread)</span></span></span><span class="hljs-function"> </span></span>{ CONTEXT context; ZeroMemory(&amp;context, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(context)); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; *(&amp;context.Dr0 + reg) = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)hook-&gt;GetInfo()-&gt;GetItem(reg)-&gt;source; context.Dr7 |= <span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * reg); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!SetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> threadId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reg; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDeferredCommands</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> silk_data::Queue&lt;IDeferredCommand*&gt;, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDeferredCommand { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IDeferredCommands() : Queue(), IDeferredCommand(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IDeferredCommands() {} }; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形象地想象“铁”断点的工作。</font></font><br><br><img src="https://habrastorage.org/webt/jv/p-/zz/jvp-zzjqnzwyp2ykl_99ujnhw0y.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图12-初始状态</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们设置一个陷阱，添加一个VEH处理程序，等待控件到达源函数：</font></font><br><br><img src="https://habrastorage.org/webt/5q/-e/eu/5q-eeucl59ysseiioktygfzl9bc.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图13-准备拦截</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><i><font style="vertical-align: inherit;">阶段</font></i><font style="vertical-align: inherit;">引发异常，调用处理程序将RIP重定向到接收方并重置断点：</font></font><br><br><img src="https://habrastorage.org/webt/te/rv/iw/terviwiealxn6xn1xvylzvfuhfe.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图14-重定向执行线程在函数接收器上</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于此主题，可以完成陷阱，静态库Silk_way.lib已准备就绪。</font><font style="vertical-align: inherit;">根据我自己的经验，我可以说我经常使用OpcodeHook，VMT Hook，强制异常Hook（可能是最“痔疮”陷阱），HardwareBreakpoint和PageGuard（在执行时间不是很关键的时候，一次拦截）。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.逻辑架构 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑的基础以MVC（模型视图控制器）的形式表示。所有核心实体都从ISilkObject接口继承。</font></font><br><br><h3>  8.1。 型号 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在库中开发机器人时，我首先实现了ECS（您可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解有关此方法的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">信息</font></a><font style="vertical-align: inherit;">）。当我意识到用真正的玩家启动机器人是一项艰巨的任务时，我编写了一个模拟，其中测试了ml库（使用三维网格进行导航（Dota 2仅使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3D网格</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行导航），并对主体块使用简化的2D物理）。当对模拟的需求消失了，我弄清楚了如何记录日志以及在战斗中收集什么信息后，不再需要ECS，模型开始包含一个组件字典（代表诸如SkyForge的家伙，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“头像和暴民</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），实际上包含来自Source2Gen的结构的包装。</font><font style="vertical-align: inherit;">对于本文，我没有为了简化材料而转移此实现。</font><font style="vertical-align: inherit;">该模型包含Schema，在其中存储其描述（此点已简化，并且在本实现中不是根据方案创建模型，方案仅描述了它（存储可以硬编码的预定义值）-可以与将游戏内容存储在xml / json中进行比较）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示意图设备可以用以下方式表示：</font><i><font style="vertical-align: inherit;">图15-</font></i><font style="vertical-align: inherit;">代码</font><i><font style="vertical-align: inherit;">中的模型</font></i><font style="vertical-align: inherit;">实现的</font><i><font style="vertical-align: inherit;">示意图</font></i><font style="vertical-align: inherit;">：</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/ci/of/ip/ciofipyg9fa-rcm0bavzy4ninb0.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SILK_OBJ</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IModel</span></span></span><span class="hljs-class">) {</span></span> ACCESSOR(IIdentity, Id) ACCESSOR(S, Schema) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IModel(IIdentity * id, ISchema * schema) { Id = id; Schema = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;S*&gt;(schema); components = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> silk_data::RBTree&lt;SILK_STRING*, IComponent&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringCompareStrategy()); } ~IModel() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> Id; Schema = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; components-&gt;Clear(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> components; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Get</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SILK_STRING</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T*)components-&gt;Find(key); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: silk_data::RBTree&lt;SILK_STRING*, IComponent&gt;* components; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该方案包括对特定模型的描述，并包含该模型可以使用的上下文。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IModelSchema</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseSchema { ACCESSOR(ModelContext, Context) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IModelSchema(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* type, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* name, IContext* context) : BaseSchema(type, name) { Context = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;ModelContext*&gt;(context); } ~IModelSchema() { Context = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelContext</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SilkContext { ACCESSOR(ILogger, Logger) ACCESSOR(IChrono, Clock) ACCESSOR(GigaFactory, Factory) ACCESSOR(IGameModel*, Model) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ModelContext(SILK_GUID* guid, ILogger* logger, IChrono* clock, GigaFactory* factory, IGameModel** model) : SilkContext(guid) { Logger = logger; Clock = clock; Factory = factory; Model = model; } ~ModelContext() { Logger = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; Clock = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; Factory = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; Model = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } };</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模型的收集和计划的收集</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IModelCollection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> silk_data::Vector&lt;T*&gt;, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IModel&lt;S&gt; { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IModelCollection(IIdentity* id, ISchema* schema) : Vector(), IModel(id, schema) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> factory = Schema-&gt;GetContext()-&gt;GetFactory(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> guid = Schema-&gt;GetContext()-&gt;GetGuid(); foreach (Schema-&gt;Length()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> itemSchema = Schema-&gt;GetItem(i); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item = factory-&gt;Build&lt;T&gt;(itemSchema-&gt;GetType()-&gt;GetValue(), guid-&gt;Get(), itemSchema); PushBack(item); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~IModelCollection() { Clear(); } <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* name)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Length()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetItem(i)-&gt;GetSchema()-&gt;CheckName(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetItem(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } };</code> </pre> <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，例如，存储Roshan状态的模型的接口和实现看起来像</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">DEFINE_IMODEL(IRoshanStatusModel, IRoshanStatusSchema) { VIRTUAL_COMPONENT(IStatesModel, States) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IRoshanStatusModel(IIdentity * id, ISchema * schema) : IModel(id, schema) {} }; DEFINE_MODEL(RoshanStatusModel, IRoshanStatusModel) { COMPONENT(IStatesModel, States) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : RoshanStatusModel(IIdentity * id, ISchema* schema) : IRoshanStatusModel( id, schema) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> factory = Schema-&gt;GetContext()-&gt;GetFactory(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> guid = Schema -&gt; GetContext() -&gt; GetGuid(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> statesSchema = Schema -&gt; GetStates(); States = factory-&gt;Build&lt;IStatesModel&gt;( statesSchema-&gt;GetType()-&gt;GetValue(), guid-&gt;Get(), statesSchema); } ~RoshanStatusModel() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> States; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> currentStateSchema = States-&gt;GetCurrent()-&gt;GetSchema(); Schema-&gt;GetContext()-&gt;GetLogger()-&gt;Log(<span class="hljs-string"><span class="hljs-string">"RESOLVE\n"</span></span>); foreach (currentStateSchema-&gt;GetTransitions()-&gt;Length()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> transition = currentStateSchema-&gt;GetTransitions()-&gt;GetItem(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transition-&gt;GetRequirement()-&gt;Check()) { transition-&gt;GetAction()-&gt;Make(); States-&gt;SetCurrent(States-&gt;GetByName( transition-&gt;GetTo()-&gt;GetValue())); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } };</code> </pre> <br></div></div><br><h3>  8.2。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 查看，查看状态和控制器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presentation，Presentation State和Controller没什么好说的，其实现与Models类似。</font><font style="vertical-align: inherit;">它们还包括架构和上下文。</font><font style="vertical-align: inherit;">为了解决View的问题，实现了Canvas，ViewCollection，Label和Button，对于后两个，还实现了与Roshan所处的状态相对应的状态。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示意图</font></font></b> <div class="spoiler_text"> <a href=""><img src="https://habrastorage.org/webt/an/l2/_n/anl2_n7qxsihaoohxu4oa-kq2jm.png"></a> <br> <i> 16 —   </i> <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视图状态的示意图</font></font></b> <div class="spoiler_text"> <a href=""><img src="https://habrastorage.org/webt/zi/mz/pi/zimzpip_arq-gwgl87-lwriknmq.png"></a> <br> <i> 17 —    </i> <br></div></div><br><h3>  8.3。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 工厂 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用工厂创建对象。</font><font style="vertical-align: inherit;">工厂将接口类型用作键，并使用typeid（T）.raw_name（）将其转换为字符串。</font><font style="vertical-align: inherit;">通常，这样做不好，为什么以及如何以及如何在Andrei Alexandrescu的《现代C ++设计：通用编程》中正确阅读。</font><font style="vertical-align: inherit;">工厂实施：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SilkFactory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SilkFactory() { items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> silk_data::RBTree&lt;SILK_STRING*, IImplementator&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringCompareStrategy()); } ~SilkFactory() { items-&gt;Clear(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> items; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISILK_WAY_OBJECT</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Build</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(type); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> impl = items-&gt;Find(key)-&gt;payload; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> impl-&gt;Build(args...); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* type, IImplementator* impl)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(type); items-&gt;Insert(*items-&gt;MakeNode(key, impl)); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: silk_data::RBTree&lt;SILK_STRING*, IImplementator&gt;* items; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GigaFactory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: GigaFactory() { items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> silk_data::RBTree&lt;SILK_STRING*, SilkFactory&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringCompareStrategy()); } ~GigaFactory() { items-&gt;Clear(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> items; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Build</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">concreteType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(T).raw_name()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> factory = items-&gt;Find(key)-&gt;payload; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T*)factory-&gt;Build(concreteType, args...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SilkFactory</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(T).raw_name()); items-&gt;Insert(*items-&gt;MakeNode(key, factory)); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: silk_data::RBTree&lt;SILK_STRING*, SilkFactory&gt;* items; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在使用工厂构建对象之前，需要注册。 </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">型号注册示例</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ModelRegistrator::Register( GigaFactory* factory) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requirement = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TrueRequirement&gt;); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"false"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;FalseRequirement&gt;); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"roshan_killed"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;RoshanKilledRequirement&gt;); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"roshan_alive_manual"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;RoshanAliveManualRequirement&gt;); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TimeRequirement&gt;); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"roshan_state"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;RoshanStateRequirement&gt;); factory-&gt;Register&lt;IRequirement&gt;(requirement); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> action = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); action-&gt;Register(<span class="hljs-string"><span class="hljs-string">"action"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;EmptyAction&gt;); action-&gt;Register(<span class="hljs-string"><span class="hljs-string">"set_current_time"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;SetCurrentTimeAction&gt;); factory-&gt;Register&lt;IAction&gt;(action); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> transition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); transition-&gt;Register(<span class="hljs-string"><span class="hljs-string">"transition"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TransitionSchema&gt;); factory-&gt;Register&lt;ITransitionSchema&gt;(transition); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> transitions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); transitions-&gt;Register(<span class="hljs-string"><span class="hljs-string">"transitions"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TransitionsSchema&gt;); factory-&gt;Register&lt;ITransitionsSchema&gt;(transitions); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stateSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); stateSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"state"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;StateSchema&gt;); factory-&gt;Register&lt;IStateSchema&gt;(stateSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> statesSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); statesSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"states"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;StatesSchema&gt;); factory-&gt;Register&lt;IStatesSchema&gt;(statesSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> roshanStatusSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); roshanStatusSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"roshan_status"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;RoshanStatusSchema&gt;); factory-&gt;Register&lt;IRoshanStatusSchema&gt;(roshanStatusSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> triggerSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); triggerSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"trigger"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TriggerSchema&gt;); factory-&gt;Register&lt;ITriggerSchema&gt;(triggerSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> triggersSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); triggersSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"triggers"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TriggersSchema&gt;); factory-&gt;Register&lt;ITriggersSchema&gt;(triggersSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resourceSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); resourceSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"resource"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;ResourceSchema&gt;); factory-&gt;Register&lt;IResourceSchema&gt;(resourceSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resourcesSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); resourcesSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"resources"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;ResourcesSchema&gt;); factory-&gt;Register&lt;IResourcesSchema&gt;(resourcesSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> gameSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); gameSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"game"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;GameSchema&gt;); factory-&gt;Register&lt;IGameSchema&gt;(gameSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> gameModel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); gameModel-&gt;Register(<span class="hljs-string"><span class="hljs-string">"game"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;GameModel&gt;); factory-&gt;Register&lt;IGameModel&gt;(gameModel); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resources = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); resources-&gt;Register(<span class="hljs-string"><span class="hljs-string">"resources"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;ResourceCollection&gt;); factory-&gt;Register&lt;IResourceCollection&gt;(resources); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); resource-&gt;Register(<span class="hljs-string"><span class="hljs-string">"resource"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;Resource&gt;); factory-&gt;Register&lt;IResource&gt;(resource); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> triggers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); triggers-&gt;Register(<span class="hljs-string"><span class="hljs-string">"triggers"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;TriggerCollection&gt;); factory-&gt;Register&lt;ITriggerCollection&gt;(triggers); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> trigger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); trigger-&gt;Register(<span class="hljs-string"><span class="hljs-string">"trigger"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;Trigger&gt;); factory-&gt;Register&lt;ITrigger&gt;(trigger); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> roshanStatus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); roshanStatus-&gt;Register(<span class="hljs-string"><span class="hljs-string">"roshan_status"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;RoshanStatusModel&gt;); factory-&gt;Register&lt;IRoshanStatusModel&gt;(roshanStatus); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> states = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); states-&gt;Register(<span class="hljs-string"><span class="hljs-string">"states"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;StatesModel&gt;); factory-&gt;Register&lt;IStatesModel&gt;(states); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); state-&gt;Register(<span class="hljs-string"><span class="hljs-string">"state"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;StateModel&gt;); factory-&gt;Register&lt;IStateModel&gt;(state); }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该方案可以以任何方式填充-您可以使用json，也可以直接在代码中。 </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于在json中填充模型架构的选项</font></font></b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"game"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"roshan_status"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"states"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"alive"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"transitions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"alive"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_base"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"requirement"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"roshan_killed"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"set_current_time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resource"</span></span>: <span class="hljs-string"><span class="hljs-string">"roshan_killed_ts"</span></span> } } } ] }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_base"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"transitions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_base"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_extra"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"requirement"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resource"</span></span>: <span class="hljs-string"><span class="hljs-string">"roshan_killed_ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-number"><span class="hljs-number">480</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"action"</span></span> } } ] }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_extra"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"transitions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_extra"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-string"><span class="hljs-string">"alive"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"requirement"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resource"</span></span>: <span class="hljs-string"><span class="hljs-string">"roshan_killed_ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-number"><span class="hljs-number">660</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"action"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_extra"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-string"><span class="hljs-string">"alive"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"requirement"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"roshan_alive_manual"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"action"</span></span> } } ] } ] }, <span class="hljs-attr"><span class="hljs-attr">"triggers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"roshan_killed"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"roshan_alive_manual"</span></span>: {} }, <span class="hljs-attr"><span class="hljs-attr">"resources"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"roshan_killed_ts"</span></span>: {} } } }</code> </pre> <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于填充代码提交方案的选项</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GameController::InitViewSchema(ICanvasSchema** schema) { *schema = factory-&gt;Build&lt;ICanvasSchema&gt;(<span class="hljs-string"><span class="hljs-string">"canvas_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"canvas_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"canvas_d9"</span></span>, viewContext); IViewCollectionSchema* elements = factory-&gt;Build&lt;IViewCollectionSchema&gt;( <span class="hljs-string"><span class="hljs-string">"elements"</span></span>, <span class="hljs-string"><span class="hljs-string">"elements"</span></span>, <span class="hljs-string"><span class="hljs-string">"elements"</span></span>, viewContext); (*schema)-&gt;SetElements(elements); ILabelSchema* labelSchema = factory-&gt;Build&lt;ILabelSchema&gt;( <span class="hljs-string"><span class="hljs-string">"label_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"label_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"roshan_status_label"</span></span>, viewContext); labelSchema-&gt;SetRecLeft(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">30</span></span>)); labelSchema-&gt;SetRecTop(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">100</span></span>)); labelSchema-&gt;SetRecRight(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">230</span></span>)); labelSchema-&gt;SetRecDown(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">250</span></span>)); labelSchema-&gt;SetColorR(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); labelSchema-&gt;SetColorG(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); labelSchema-&gt;SetColorB(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); labelSchema-&gt;SetColorA(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); labelSchema-&gt;SetText(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(<span class="hljs-string"><span class="hljs-string">"Roshan status: alive\0"</span></span>)); elements-&gt;PushBack((IViewSchema*&amp;)labelSchema); IButtonSchema* buttonSchema = factory-&gt;Build&lt;IButtonSchema&gt;( <span class="hljs-string"><span class="hljs-string">"button_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"button_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"roshan_kill_button"</span></span>, viewContext); ILabelSchema* buttonLabelSchema = factory-&gt;Build&lt;ILabelSchema&gt;( <span class="hljs-string"><span class="hljs-string">"label_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"label_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"button_text"</span></span>, viewContext); buttonLabelSchema-&gt;SetRecLeft(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">30</span></span>)); buttonLabelSchema-&gt;SetRecTop(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">115</span></span>)); buttonLabelSchema-&gt;SetRecRight(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">110</span></span>)); buttonLabelSchema-&gt;SetRecDown(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">130</span></span>)); buttonLabelSchema-&gt;SetColorR(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); buttonLabelSchema-&gt;SetColorG(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); buttonLabelSchema-&gt;SetColorB(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); buttonLabelSchema-&gt;SetColorA(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); buttonLabelSchema-&gt;SetText(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(<span class="hljs-string"><span class="hljs-string">"Kill Roshan\0"</span></span>)); buttonSchema-&gt;SetLabel(buttonLabelSchema); buttonSchema-&gt;SetBorderColorR(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetBorderColorG(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetBorderColorB(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetBorderColorA(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">70</span></span>)); buttonSchema-&gt;SetFillColorR(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">255</span></span>)); buttonSchema-&gt;SetFillColorG(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">119</span></span>)); buttonSchema-&gt;SetFillColorB(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetFillColorA(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">150</span></span>)); buttonSchema-&gt;SetPushColorR(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetPushColorG(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetPushColorB(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetPushColorA(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">70</span></span>)); buttonSchema-&gt;SetBorder(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">5</span></span>)); elements-&gt;PushBack((IViewSchema*&amp;)buttonSchema); }</code> </pre> <br></div></div><br><h3>  8.4。 大事记 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该视图通过事件了解模型中的更改。</font><font style="vertical-align: inherit;">您可以获得有关类方法和普通函数的反馈。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VIRTUAL_EVENT(e) public: virtual IEvent* Get##e() = 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EVENT(e) private: IEvent* e; public: IEvent* Get##e() { return e; } const int MAX_EVENT_CALLBACKS = 1024; class IEventArgs {}; class ICallback { public: virtual void Invoke(IEventArgs* args) = 0; }; template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class A&gt; class Callback : public ICallback { typedef void (*f)(A*); public: Callback(f _pFunc) { ptr = _pFunc; } ~Callback() { delete ptr; } void Invoke(IEventArgs* args) { ptr((A*)args); } private: f ptr = nullptr; }; template &lt;typename T, class A&gt; class MemberCallback : public ICallback { typedef void (T::*f)(A*); public: MemberCallback(f _pFunc, T* _obj) { ptr = _pFunc; obj = _obj; } ~MemberCallback() { delete ptr; obj = nullptr; } void Invoke(IEventArgs* args) { (obj-&gt;*(ptr))((A*)args); } private: f ptr = nullptr; T* obj; }; class IEvent { public: virtual void Invoke(IEventArgs* args) = 0; virtual void Add(ICallback* callback) = 0; virtual bool Remove(ICallback* callback) = 0; virtual ~IEvent() {} };</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果对象要报告其中发生的事件，则需要为每个事件添加IEvent *。</font><font style="vertical-align: inherit;">对在此对象内发生的事件感兴趣的另一个对象应该创建ICallback *并将其传递给IEvent *（订阅该事件）。</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生在控制器中的示例订阅</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ statesChangedCallback = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemberCallback&lt;GameController, IEventArgs&gt;( &amp;GameController::OnStatesChanged, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Model-&gt;GetRoshanStatus()-&gt;GetStates()-&gt;GetCurrentChanged()-&gt;Add( statesChangedCallback); buttonClickedCallback = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemberCallback&lt;GameController, IEventArgs&gt;( &amp;GameController::OnKillRoshanClicked, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); killButton-&gt;GetClickedEvent()-&gt;Add(buttonClickedCallback); }</code> </pre> <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在类中声明事件的示例-每次敲钟（调用Tick方法），都会引发StruckEvent事件</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IChrono</span></span></span><span class="hljs-class"> {</span></span> VIRTUAL_EVENT(Struck) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStamp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDiffS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ts)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chrono</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IChrono { EVENT(Struck) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Chrono() { start = time(<span class="hljs-number"><span class="hljs-number">0</span></span>); Struck = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(); } ~Chrono() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> Struck; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cur = clock(); worked += cur - savepoint; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isStriking = savepoint &lt; cur; savepoint = cur; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isStriking) Struck-&gt;Invoke(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStamp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> start * CLOCKS_PER_SEC + worked; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDiffS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (GetStamp() - ts) / CLOCKS_PER_SEC; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> worked = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> start; <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> savepoint; };</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 基本基本类型（SILK_INT，SILT_FLOAT，SILK_STRING等）在Core.h中实现。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. DirectX 9 </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectX 9</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是Dota 2支持的图形API之一。设备是从IUnknown继承的类，并且包含虚函数。因此，在收到指向虚拟方法表的指针后，我们可以获取指向所需功能的指针。非虚拟类函数不包含在表中，而是位于.code段中，因为它们是唯一不能覆盖的函数。顺便说一下，在OpenGL和Vulkan中，拦截设备函数要容易得多，因为它们不是虚拟的，您可以使用GetProcAddress（）获取指针。 DirectX 11架构比9更复杂，但不多。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要拦截虚拟类方法（以及非虚拟类方法），我们需要此类的一个实例，任何实例。使用实例，我们获得虚拟方法的表并获得指向函数的必要指针。查找类实例的最简单方法是自己创建它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，我们需要使用Direct3DCreate9函数通过IDirect3D9接口创建一个对象，然后通过调用CreateDevice方法使用该对象创建设备。我们可以直接从DirectX库调用这些函数，但是为了合并材料，我们将通过指针对其进行调用。从d3d9.h中可以看出，Direct3DCreate9是一个常规函数，可以通过GetProcAddress获得指向它的指针（就像我们在NativeInjector中获得指向LoadLibrary的指针一样）。</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/nr/fq/ai/nrfqai6vps7fc9lx_crerpvsbhq.png"></a> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图18-d3d9.h中CreateDevice的描述</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建IDirect3D9的实例：</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> IDirect3D9* (WINAPI *SILK_Direct3DCreate9) (UINT SDKVersion); <span class="hljs-comment"><span class="hljs-comment">//IDirect3D9* pD3D = Direct3DCreate9(D3D_SDK_VERSION); SILK_Direct3DCreate9 Silk_Direct3DCreate9 = (SILK_Direct3DCreate9)GetProcAddress(GetModuleHandle("d3d9.dll"), "Direct3DCreate9"); IDirect3D9* pD3D = Silk_Direct3DCreate9(D3D_SDK_VERSION);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用IDirect3D9，我们可以通过调用pD3D-&gt; CreateDevice（...）创建设备。</font><font style="vertical-align: inherit;">为了从VMT获得指向必要功能的指针，我们需要找出确定这些方法的过程。</font><i><font style="vertical-align: inherit;">图19-索引搜索IDirect3D9接口的CreateDevice方法获取第</font></i><font style="vertical-align: inherit;"> 16个索引。</font><font style="vertical-align: inherit;">除了CreateDevice，我们还需要Release和GetAdapterDisplayMode方法。</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/ro/ap/ug/roapuggoav9xtztltqu8gs6zqiw.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们用代码实现设备的创建</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HRESULT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WINAPI *SILK_GetAdapterDisplayMode)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3D9* direct3D9, UINT Adapter, D3DDISPLAYMODE* pMode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HRESULT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WINAPI *SILK_CreateDevice)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3D9* direct3D9, UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DDevice9** ppReturnedDeviceInterface)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ULONG</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WINAPI *SILK_Release)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3D9* direct3D9)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RELEASE_INDEX = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GET_ADAPTER_DISPLAY_MODE_INDEX = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CREATE_DEVICE_INDEX = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSearchDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3D9** d3d, IDirect3DDevice9** device)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!d3d || !device) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; *d3d = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; *device = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">//IDirect3D9* pD3D = Direct3DCreate9(D3D_SDK_VERSION); SILK_Direct3DCreate9 Silk_Direct3DCreate9 = (SILK_Direct3DCreate9)GetProcAddress(GetModuleHandle("d3d9.dll"), "Direct3DCreate9"); IDirect3D9* pD3D = Silk_Direct3DCreate9(D3D_SDK_VERSION); if (!pD3D) return FALSE; D3DDISPLAYMODE displayMode; int pointerSize = sizeof(unsigned long long); unsigned long long vmt = **(unsigned long long **)&amp;pD3D; SILK_GetAdapterDisplayMode pGetAdapderDisplayMode = (SILK_GetAdapterDisplayMode)((*(unsigned long long *) (vmt + pointerSize * GET_ADAPTER_DISPLAY_MODE_INDEX))); pGetAdapderDisplayMode(pD3D, D3DADAPTER_DEFAULT, &amp;displayMode); //pD3D-&gt;GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &amp;displayMode); HWND hWindow = GetDesktopWindow(); D3DPRESENT_PARAMETERS pp; ZeroMemory(&amp;pp, sizeof(pp)); pp.Windowed = TRUE; pp.hDeviceWindow = hWindow; pp.BackBufferCount = 0; pp.BackBufferWidth = 0; pp.BackBufferHeight = 0; pp.BackBufferFormat = displayMode.Format; pp.SwapEffect = D3DSWAPEFFECT_DISCARD; IDirect3DDevice9* pDevice = NULL; SILK_CreateDevice pCreateDevice = (SILK_CreateDevice) ((*(unsigned long long *)(vmt + pointerSize * CREATE_DEVICE_INDEX))); if(SUCCEEDED(pCreateDevice(pD3D, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWindow, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_DISABLE_DRIVER_MANAGEMENT, &amp;pp, &amp;pDevice))) { //if (SUCCEEDED(pD3D-&gt;CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWindow, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_DISABLE_DRIVER_MANAGEMENT, &amp;pp, &amp;pDevice))) { if (pDevice != NULL) { *d3d = pD3D; *device = pDevice; } } BOOL result = (*d3d != NULL); if (result == FALSE) if (pD3D) { SILK_Release pRelease= (SILK_Release)((*(unsigned long long *)(vmt + pointerSize * RELEASE_INDEX))); pRelease(pD3D); //pD3D-&gt;Release(); } return result; }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好了，我们创建了DirectX 9设备，现在我们需要了解用于渲染场景的功能以及需要拦截的功能。我们需要回答以下问题：“ DirectX 9如何向我们展示场景？” </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Present</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能用于显示场景</font><font style="vertical-align: inherit;">。还值得介绍这样的概念，例如前缓冲区（用于存储屏幕上显示的内容（长期动作）的缓冲区），后缓冲区-包含准备显示并准备成为前缓冲区的内容，交换链-实际上是一组缓冲区从前向后翻转（DirectX 9只有1个交换链）。在调用Present之前，先调用了几个BeginScene和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EndScene</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">，您可以在其中修改后台缓冲区。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们截取两个函数（实际上，执行业务逻辑，对于我们来说一个就足够了）：EndScene和Present。</font><font style="vertical-align: inherit;">为此，请在IDirect3DDevice9类中</font><i><font style="vertical-align: inherit;">查看</font></i><font style="vertical-align: inherit;">这些函数的位置。</font><i><font style="vertical-align: inherit;">图20-声明IDirect3DDevice9接口声明</font></i><font style="vertical-align: inherit;">具有以下函数签名的指针：</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/xa/ev/tk/xaevtkzg4h4whv7aejsfp025yr0.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HRESULT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*VirtualOverloadPresent)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice, CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion)</span></span></span></span>; VirtualOverloadPresent oOverload = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HRESULT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*VirtualOverloadEndScene)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice)</span></span></span></span>; VirtualOverloadEndScene oOverloadEndScene = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PRESENT_INDEX = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> END_SCENE_INDEX = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将立即使用错误处理程序声明一个陷阱，因为HardwareBreakpoint实际上是我们唯一实施的不跟踪VAC的安全拦截选项（您也可以使用Opcode Hook进行测试，但您的帐户很可能会被禁飞）： </font></font><br><br><pre> <code class="cpp hljs">silk_way::IDeferredCommands* deferredCommands; silk_way::IHook* hook; <span class="hljs-function"><span class="hljs-function">LONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnExceptionHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EXCEPTION_POINTERS* exceptionPointers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ExceptionRecord-&gt;ExceptionCode != EXCEPTION_SINGLE_STEP) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_EXIT_UNWIND; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; silk_way::DEBUG_REG_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ContextRecord-&gt;Rip == (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;source) { exceptionPointers-&gt;ContextRecord-&gt;Dr7 &amp;= ~(<span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * i)); exceptionPointers-&gt;ContextRecord-&gt;Rip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;destination; silk_way::IDeferredCommand* cmd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> silk_way::SetD7Command(hook, GetCurrentThreadId(), i); deferredCommands-&gt;Enqueue(cmd); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_CONTINUE_EXECUTION; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 发出我们两个陷阱中任何一个的指定功能： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HookDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vmt = **(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> **)&amp;pDevice; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointerSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); VirtualOverloadPresent pointerPresent= (VirtualOverloadPresent) ((*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)(vmt + pointerSize * PRESENT_INDEX))); VirtualOverloadEndScene pointerEndScene = (VirtualOverloadEndScene) ((*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)(vmt + pointerSize * END_SCENE_INDEX))); oOverload = pointerPresent; oOverloadEndScene = pointerEndScene; deferredCommands = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> silk_way::DeferredCommands(); <span class="hljs-comment"><span class="hljs-comment">//hook = new silk_way::HardwareBPHook(); hook = new silk_way::OpcodeHook(); hook-&gt;SetExceptionHandler(OnExceptionHandler); hook-&gt;SetHook(pointerPresent, &amp;PresentHook); hook-&gt;SetHook(pointerEndScene, &amp;EndSceneHook); return TRUE; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 功能接收者： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HRESULT WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PresentHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice, CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion)</span></span></span><span class="hljs-function"> </span></span>{ Capture(pd3dDevice); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(oOverload); VirtualOverloadPresent pTrampoline = (VirtualOverloadPresent) record-&gt;pTrampoline; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = pTrampoline(pd3dDevice, pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion); deferredCommands-&gt;Run(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-function">HRESULT WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSceneHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (controller == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameController(); controller-&gt;SetDevice(pd3dDevice); } controller-&gt;Update(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(oOverloadEndScene); VirtualOverloadEndScene pTrampoline = (VirtualOverloadEndScene) record-&gt;pTrampoline; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = pTrampoline(pd3dDevice); deferredCommands-&gt;Run(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“当前”中，每个呼叫都使用“捕获”功能从视频卡缓冲区中截取屏幕截图（用于验证）</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">VOID WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Capture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice)</span></span></span><span class="hljs-function"> </span></span>{ IDirect3DSurface9 *renderTarget = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; IDirect3DSurface9 *destTarget = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; HRESULT res1 = pd3dDevice-&gt;GetRenderTarget(<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;renderTarget); D3DSURFACE_DESC descr; HRESULT res2 = renderTarget-&gt;GetDesc(&amp;descr); HRESULT res3 = pd3dDevice-&gt;CreateOffscreenPlainSurface( descr.Width, descr.Height, <span class="hljs-comment"><span class="hljs-comment">/*D3DFMT_A8R8G8B8*/</span></span>descr.Format, D3DPOOL_SYSTEMMEM, &amp;destTarget, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); HRESULT res4 = pd3dDevice-&gt;GetRenderTargetData(renderTarget, destTarget); D3DLOCKED_RECT lockedRect; ZeroMemory(&amp;lockedRect, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(lockedRect)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destTarget == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; HRESULT res5 = destTarget-&gt;LockRect(&amp;lockedRect, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, D3DLOCK_READONLY); HRESULT res7 = destTarget-&gt;UnlockRect(); HRESULT res6 = D3DXSaveSurfaceToFile(screenshootPath, D3DXIFF_BMP, destTarget, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); renderTarget-&gt;Release(); destTarget-&gt;Release(); }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EndScene创建一个业务逻辑控制器。</font><font style="vertical-align: inherit;">创建后，将调用控制器更新，其中所有逻辑都将更新。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我注意到，现在我们已经实现了DirectX 9的工作。如果我们想进行某种mod，作弊等操作，则必须支持所有四个API。</font><font style="vertical-align: inherit;">如果阿森纳已经拥有您喜欢的库，而UI则为空白，那么这是有道理的，否则您可以使用另一种方式-使用引擎渲染游戏的功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还值得一提的是，从EndScene（）调用逻辑更新不是最佳选择-您可以在流中找到对引擎函数或调用逻辑的定期调用。</font><font style="vertical-align: inherit;">但是，如果您对EndScene的调用感到满意，则最好使用锁步操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们已经实现了我们计划的一切。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试建议</font></font></b> <div class="spoiler_text">       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DirectX SDK</a> ,    ,  DirectX 9  DirectX 11.           DirectX 11,    -      SDK,     (  ,         )   ,     ,     DXUT,      ,      —   ,   FPS   . <br><br> <a href=""><img src="https://habrastorage.org/webt/o-/hq/zg/o-hqzgthdamhzrum5h8upaenqly.png"></a> <br> <i> 21 —     DirectX SDK   StateManager.exe</i> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在您可以在Steam中创建一个虚假帐户，并将注入的dll注入Dota 2进程中。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我马上要说，我不知道带有“铁”断点的当前情况是如何-使用Opcode Hook（我们目前使用的方式表格），您肯定会被禁止。我大约六个月前就这样做了-没有硬件断点的禁令，我不能说目前的情况。在准备本文之前，我考虑了两个问题，并对它们进行了Opcode Hook和HWBP的尝试，第一个进入禁令（大约2个星期过去了），第二个否决了（3个星期过去了）。但是仍然不能保证禁令不会在将来发生。如果您不小心从主帐户进行了介绍，或者忘记登录假帐户，则不要生气-然后请多保重并小心。</font></font></b> <br><br><div class="spoiler"> <b class="spoiler_title">    ( )</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d9/tw/44/d9tw44gqefmz8pvwr1c7y-ppbhq.png"><br> <i> 22 —  </i> <br></div></div><br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/nk/v4/za/nkv4zafl57fjog_vqnsf5k1q-va.png"><br> <i> 23 —    </i> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以1x1模式实施。</font><i><font style="vertical-align: inherit;">图24-向火柴中注入</font></i><font style="vertical-align: inherit;">还值得一提的是，还有另一种渲染方法-通过创建具有适当大小的第二个窗口进行表面渲染。不幸的是，我无法意识到在全屏模式下使用表面处理的可能性，但是本文中描述的方法允许您在全屏和窗口模式下实现渲染而没有任何问题。</font><font style="vertical-align: inherit;">我们的嵌入式UI仅包含文本标签和在纯DirectX 9上实现的按钮-这是解决任务所需的全部。您可以在纯API上或使用现成的库来实现复杂的表，精美的菜单和图表-通常，可以实现任何复杂的UI。当然，不仅是2D。</font></font><br> <a href=""><img src="https://habrastorage.org/webt/r2/6v/ix/r26vixlwxtaspaykchnffmpwexm.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.使用引擎功能 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为每个API实现相同的功能相当乏味；开发人员通过提供游戏直接使用的绘图，UI等功能，可以方便地进行包装。</font><font style="vertical-align: inherit;">Valve还提供了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dota 2 API </font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这样做是为了使C ++复杂的主持人和游戏设计师（甚至不是C ++本身，而是在引擎上下文中正确使用）变得更轻松。</font><font style="vertical-align: inherit;">这里有渲染功能和游戏逻辑-您可以规定单位的行为，例如，选择物品，使用技能等。</font><font style="vertical-align: inherit;">实际上，借助于此，可以编写自定义字母。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将对DoIncludeScript函数感兴趣，该函数允许您在Lua上运行脚本并在其中使用脚本API。我没有在项目中使用它，因为我没有看到它的值，而是直接使用C ++中的函数，因此看到了将其与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or_75</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一起使用的想法，</font><font style="vertical-align: inherit;">并决定将其包含在本文中。这将向您介绍第二部分的内容并节省其中的空间；您无需解释调试器的某些方面。</font></font><br><br> 让我们开始吧。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任务如下：您需要找到一个指向DoIncludeScript函数的指针，该函数需要脚本和处理程序的名称来进行研究。我们将使用Silk_way.lib库中的扫描器搜索功能。我们已经发现，函数是使用操作码表在内存中编码的-让我们检查一下此函数，并尝试确定其在内存中的存储模式。现在，扫描仪没有必要的功能，我们需要能够在过程存储器中搜索模板。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了加快搜索速度，我们不会在整个过程内存中搜索模式，而是在特定模块中搜索（我们的功能位于client.dll中，这将在调试器中看到，并将在下面进行讨论）。我们将通过枚举进程的所有模块来使用tlHelp32来搜索模块，为此，我们将为其创建一个函数以在当前GetModuleInfo进程中找到该模块。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetModuleInfo功能代码</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IScanner::GetModuleInfo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* name, MODULEENTRY32* entry) { HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE32 | TH32CS_SNAPMODULE, GetCurrentProcessId()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (snapshot == INVALID_HANDLE_VALUE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; entry-&gt;dwSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MODULEENTRY32); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Module32First(snapshot, entry)) { CloseHandle(snapshot); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_stricmp(entry-&gt;szModule, name)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Module32Next(snapshot, entry)); CloseHandle(snapshot); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该模式是一个具有字节值的字符串，跳过一个字节用符号“ ??”表示 </font><font style="vertical-align: inherit;">-例如，“ j9？</font><font style="vertical-align: inherit;">?? </font><font style="vertical-align: inherit;">?? </font><font style="vertical-align: inherit;">?? </font><font style="vertical-align: inherit;">48 03 08 ?? </font><font style="vertical-align: inherit;">f1 ff”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解析字符串，为方便起见，我们将模式从字符串表示形式转移到无符号char值列表，设置要跳过的字节标志。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* IScanner::Parse(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; len, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* strPattern, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* skipByteMask) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> strPatternLen = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(strPattern); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pattern = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[strPatternLen]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; strPatternLen; i++) pattern[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; strPatternLen; i += <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> code = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strPattern[i] == SKIP_SYMBOL) skipByteMask[len] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> code = Parse(strPattern[i]) * <span class="hljs-number"><span class="hljs-number">16</span></span> + Parse(strPattern[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]); i++; pattern[len++] = code; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pattern; } <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> IScanner::Parse(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> byte) { <span class="hljs-comment"><span class="hljs-comment">// some magic values if (byte &gt;= '0' &amp;&amp; byte &lt;= '9') return byte - '0'; else if (byte &gt;= 'a' &amp;&amp; byte &lt;= 'f') return byte - 'a' + 10; else if (byte &gt;= 'A' &amp;&amp; byte &lt;= 'F') return byte - 'A' + 10; return 0; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">搜索核心是在FindPattern函数中实现的，其中基于接收到的有关模块的信息，设置搜索的开始和结束地址。</font><font style="vertical-align: inherit;">VirtualQuery函数会请求有关要搜索的内存的信息，内存有很多要求-它必须很忙（在空闲内存中搜索会出错），该内存必须可读，可执行且不包含PageGuard标志：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pStart = moduleEntry.modBaseAddr; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pFinish = moduleEntry.modBaseAddr + moduleEntry.modBaseSize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* current = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)pStart; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; current &lt; pFinish &amp;&amp; j &lt; patternLen; current++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!VirtualQuery((LPCVOID)current, &amp;info, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(info))) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> protectMask = PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE | PAGE_EXECUTE_READ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.State == MEM_COMMIT &amp;&amp; info.Protect &amp; protectMask &amp;&amp; !(info.Protect &amp; PAGE_GUARD)) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> finish = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)pFinish &lt; (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)info.BaseAddress + info.RegionSize ? (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)pFinish : (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) info.BaseAddress + info.RegionSize; current = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)info.BaseAddress; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* rip = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> k = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)info.BaseAddress; k &lt; finish &amp;&amp; j &lt; patternLen; k++, current++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skipByteMask[j] || pattern[j] == *current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) rip = current; j++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pattern[<span class="hljs-number"><span class="hljs-number">0</span></span>] == *current) { rip = current; j = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == patternLen) { current = rip; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> current += sysInfo.dwPageSize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以在过程存储器中搜索所需的模板，但是还不知道要查找什么。在Fake帐户下运行Steam并打开您喜欢的调试器（让我们同意，在阅读x64dbg这篇文章时也很适合您-我没有IDA Pro的付费许可证），从... \ Steam \ steamapps \目录中运行dota2.exe常见的\ dota 2 beta \游戏\ bin \ win64。原则上，我没有注意到VAC对Cheat Engine和x64dbg并不冷漠，我不记得使用这些工具时帐户被禁止了。顺便说一下，调试器有一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScyllaHide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插件</font><font style="vertical-align: inherit;">，可以拦截NtCreateThreadEx，NtSetInformationThread等系统功能，隐藏其工作原理，您可以安装此插件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每个停靠点（会有10-15点），我们继续使用运行（F9）执行。游戏开始时，我们将看到菜单并可以开始研究。开始游戏后，在各行上进行搜索（搜索-&gt;所有模块-&gt;字符串引用），设置“ DoIncludeScript”过滤器。</font><i><font style="vertical-align: inherit;">图25-搜索游戏进程内存中的行</font></i><font style="vertical-align: inherit;">让我们双击第一个结果进入反汇编程序（“ CPU”选项卡）。这将是我们的起始地址，因为它位于client.dll中，其余结果位于server.dll和animationsystem.dll中。</font><font style="vertical-align: inherit;">我们从接收到的地址构造一个呼叫图。</font><i><font style="vertical-align: inherit;">图26-调用图</font></i><font style="vertical-align: inherit;">反编译后，我们找到使用DoIncludeScript的入口点-图的第四个节点。实际上，功能本身。</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/nl/t2/x7/nlt2x7qovaunasqqpd6hqojgclw.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/webt/om/os/zo/omoszo_tqtleqsulp5c97sp7iwo.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/webt/ja/pp/zo/jappzokowbi-si2zm8zchka3pjk.png"></a> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图27-DoIncludeScript</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Graph </font><i><font style="vertical-align: inherit;">函数</font></i><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">图28-来自DoIncludeScript的调用图</font></i><font style="vertical-align: inherit;">对该函数的反编译显示了以下代码及其调用位置（反编译是从该图完成的，而不是从反汇编程序完成的）。</font><i><font style="vertical-align: inherit;">图29-反编译对DoIncludeScript函数的调用让我们根据对DoIncludeScript函数</font></i><font style="vertical-align: inherit;">的调用的图27中的指令来组成一个模板。参数可以分别更改，我们要在搜索时跳过模板中的参数，用“ ??”表示。我得到以下信息：40 57 48 81 EC ?? ?? ?? ?? 48 83 3D ?? ?? ?? ?? ?? 48 8B F9 0F 84.为了编译模板，我们使用了图28中图形的第一个节点，其指令可以在图27中找到。</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/ji/q0/w9/jiq0w96b8mmvbuh7un7iyiffq_8.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/webt/pb/rl/8h/pbrl8hdsnnowxoyfq-lz1xbq3xg.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在Lua silk_way.lua上创建一个脚本，将其放在“ ... \ Steam \ steamapps \ common \ dota 2 beta \ game \ dota \ scripts \ vscripts”中。 </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"SILK_WAY START"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> first = Entities:First() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (first ~= <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> position = first:GetAbsOrigin() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> strInfo = <span class="hljs-string"><span class="hljs-string">"["</span></span> .. <span class="hljs-string"><span class="hljs-string">"pos:"</span></span> .. <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(position.x) .. <span class="hljs-string"><span class="hljs-string">","</span></span> .. <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(position.y) .. <span class="hljs-string"><span class="hljs-string">","</span></span> .. <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(position.z) .. <span class="hljs-string"><span class="hljs-string">"]"</span></span> DebugDrawText(position, strInfo, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-number"><span class="hljs-number">300.0</span></span>) first = Entities:Next(first) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"SILK_WAY FINISH"</span></span>) <span class="hljs-comment"><span class="hljs-comment">--[[ListenToGameEvent("dota_roshan_kill",roshan_kill,nil)]]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该脚本绕过所有实体，并根据其位置显示坐标。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用上面的文档和来自图29的反编译代码声明功能。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*fDoIncludeScript)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 函数调用。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HRESULT WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSceneHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (controller == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameController(); controller-&gt;SetDevice(pd3dDevice); fDoIncludeScript DoIncludeScript = (fDoIncludeScript) scanner-&gt;FindPattern(<span class="hljs-string"><span class="hljs-string">"client.dll"</span></span>, <span class="hljs-string"><span class="hljs-string">"40 57 48 81 EC ?? ?? ?? ?? 48 83 3D ?? ?? ?? ?? ?? 48 8B F9 0F 84"</span></span>); DoIncludeScript(<span class="hljs-string"><span class="hljs-string">"silk_way"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实施后，我们将看到有关游戏实体位置的信息。</font><i><font style="vertical-align: inherit;">图30-实现结果</font></i><font style="vertical-align: inherit;">现在我们可以运行脚本了。</font><font style="vertical-align: inherit;">但是它们是在Lua中执行的，并且说Roshan死的事件对我们来说是C ++代码所必需的（因为我们已经写了主要逻辑），我们该怎么办？</font><font style="vertical-align: inherit;">我们将必须使用Source SDK和Source2Gen以相同的方式（就像我们对DoIncludeScript所做的那样），必要的引擎功能和其他功能找到指向必要功能的指针。</font><font style="vertical-align: inherit;">但是在下一部分中，我们会找到更多关于实体列表的指针，并在逻辑上更接近于游戏机制，以提供更多信息。</font><font style="vertical-align: inherit;">如果您一次想要所有东西，可以尝试，我附上了</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">这个</font></a><font style="vertical-align: inherit;">，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">这个</font></a><font style="vertical-align: inherit;">，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">这个</font></a><font style="vertical-align: inherit;">和</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">这个</font></a><font style="vertical-align: inherit;">作为您的帮助</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/en/x2/4l/enx24lrbff5j_6l0v4ydxhecm84.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 链接。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11.结论 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我要感谢在反向领域分享最佳实践和知识并与他人分享经验的每个人。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只讲</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">祈祷者的《</font></a><font style="vertical-align: inherit;"> Dota 2》</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">，</font></a><font style="vertical-align: inherit;">我会花很多时间才能使用作弊引擎获得游戏的数据结构，而所做的成就可能会随着Valve的更新而中断。更新会破坏找到的静态指针，并偶尔更改实体的结构。在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or75，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我看到了DoIncludeScript函数的用法，并在它的帮助下，展示了一个使用游戏引擎输出文本的示例。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了简化演示文稿，我可能会漏掉一些东西，忽略我认为不值得关注的各种情况，反之亦然，然后增加解释的范围-如果细心的读者发现此类错误，我将很乐意纠正它们并听取评论。</font><font style="vertical-align: inherit;">可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到源代码</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感谢所有花时间阅读本文的人。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446516/">https://habr.com/ru/post/zh-CN446516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446506/index.html">迁移到云中时零售的五个关键问题</a></li>
<li><a href="../zh-CN446508/index.html">.NET核心工作者作为Windows服务</a></li>
<li><a href="../zh-CN446510/index.html">CLRium＃5：垃圾收集器。 最大的.NET工作坊</a></li>
<li><a href="../zh-CN446512/index.html">.NET核心工作者作为Windows服务</a></li>
<li><a href="../zh-CN446514/index.html">Gmail已有15岁</a></li>
<li><a href="../zh-CN446518/index.html">Web应用防火墙</a></li>
<li><a href="../zh-CN446520/index.html">一切如何开始：无人驾驶飞机的故事</a></li>
<li><a href="../zh-CN446522/index.html">Swift 5.1-有什么新功能？</a></li>
<li><a href="../zh-CN446530/index.html">图片中的Word2vec</a></li>
<li><a href="../zh-CN446532/index.html">Upwork收取写给潜在客户的权利的费用</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>