<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€âš–ï¸ ğŸ—£ï¸ ğŸŒ VShard - penskalaan horizontal di Tarantool ğŸšš ğŸ§—ğŸ¾ ğŸ¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nama saya Vladislav, saya berpartisipasi dalam pengembangan Tarantool - DBMS dan server aplikasi dalam satu botol. Dan hari ini saya akan memberi tahu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VShard - penskalaan horizontal di Tarantool</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/436916/"><img src="https://habrastorage.org/webt/4p/e8/fo/4pe8foryc_t_l5joliydwpislhm.png"><br><br>  Nama saya Vladislav, saya berpartisipasi dalam pengembangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool</a> - DBMS dan server aplikasi dalam satu botol.  Dan hari ini saya akan memberi tahu Anda bagaimana kami menerapkan penskalaan horizontal di Tarantool menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VShard</a> . <br><a name="habracut"></a><br>  Pertama, sedikit teori. <br><br>  Ada dua jenis penskalaan: horisontal dan vertikal.  Horisontal dibagi menjadi dua jenis: replikasi dan sharding.  Replikasi digunakan untuk skala komputasi, sharding digunakan untuk skala data. <br><br>  Sharding dibagi menjadi dua jenis: sharding oleh rentang dan sharding oleh hash. <br><br>  Saat beling dengan rentang, kami menghitung beberapa kunci beling dari setiap catatan di cluster.  Kunci beling ini diproyeksikan ke garis lurus, yang dibagi menjadi rentang yang kami tambahkan ke simpul fisik yang berbeda. <br><br>  Sharding dengan hash lebih sederhana: dari setiap record di cluster kami menganggap fungsi hash, kami menambahkan entri dengan nilai yang sama dari fungsi hash ke satu simpul fisik. <br><br>  Saya akan berbicara tentang penskalaan horizontal menggunakan hash sharding. <br><br><h1>  Implementasi sebelumnya </h1><br>  Modul penskalaan horizontal pertama yang kami miliki adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool Shard</a> .  Ini adalah sharding dengan hash yang sangat sederhana, yang mempertimbangkan kunci shard dari kunci utama semua entri dalam cluster. <br><br><pre><code class="plaintext hljs">function shard_function(primary_key) return guava(crc32(primary_key), shard_count) end</code> </pre> <br>  Tetapi kemudian muncul tugas bahwa Tarantool Shard tidak dapat menangani karena tiga alasan mendasar. <br><br>  Pertama, diperlukan <b>lokasi data terkait logis</b> .  Ketika kami memiliki data yang terhubung secara logis, kami selalu ingin menyimpannya di node fisik yang sama, tidak peduli bagaimana topologi cluster berubah atau balancing dilakukan.  Dan Tarantool Shard tidak menjamin ini.  Dia menganggap hash hanya dengan kunci primer, dan ketika menyeimbangkan kembali, bahkan catatan dengan hash yang sama dapat dipisahkan untuk beberapa waktu - transfernya bukan atom. <br><br>  Masalah kurangnya lokalitas data paling menghambat kami.  Saya akan memberi contoh.  Ada bank tempat klien membuka akun.  Data akun dan klien harus selalu disimpan bersama secara fisik sehingga dapat dibaca dalam satu permintaan, dipertukarkan dalam satu transaksi, misalnya, saat mentransfer uang dari akun.  Jika Anda menggunakan sharding klasik dengan Tarantool Shard, maka nilai fungsi shard akan berbeda untuk akun dan pelanggan.  Data mungkin pada node fisik yang berbeda.  Ini sangat menyulitkan pekerjaan membaca dan transaksional dengan klien seperti itu. <br><br><pre> <code class="plaintext hljs">format = {{'id', 'unsigned'}, {'email', 'string'}} box.schema.create_space('customer', {format = format}) format = {{'id', 'unsigned'}, {'customer_id', 'unsigned'}, {'balance', 'number'}} box.schema.create_space('account', {format = format})</code> </pre><br>  Pada contoh di atas, bidang <code>id</code> dapat dengan mudah tidak cocok dengan akun dan pelanggan.  Mereka terhubung melalui bidang akun <code>customer_id</code> dan <code>id</code> <code>customer_id</code> .  Bidang <code>id</code> sama akan memecah keunikan kunci utama akun.  Dan dengan cara lain Shard tidak mampu shard. <br><br>  Masalah selanjutnya adalah <b>resharding lambat</b> .  Ini adalah masalah klasik semua pecahan hash.  Intinya adalah ketika kita mengubah komposisi sebuah cluster, kita biasanya mengubah fungsi shard, karena biasanya tergantung pada jumlah node.  Dan ketika fungsi berubah, Anda harus memeriksa semua entri di cluster dan menghitung ulang fungsi shard lagi.  Mungkin mentransfer beberapa catatan.  Dan saat kami mentransfernya, kami tidak tahu apakah data yang dibutuhkan oleh permintaan masuk berikutnya sudah ditransfer, mungkin mereka sekarang sedang dalam proses mentransfer.  Oleh karena itu, selama pengulangan, perlu untuk setiap pembacaan untuk membuat permintaan untuk dua fungsi beling: yang lama dan yang baru.  Permintaan menjadi dua kali lebih lambat, dan bagi kami itu tidak dapat diterima. <br><br>  Fitur lain dari Tarantool Shard adalah bahwa ketika beberapa node dalam set replika gagal, itu menunjukkan <b>aksesibilitas baca yang buruk</b> . <br><br><h1>  Solusi baru </h1><br>  Untuk mengatasi tiga masalah yang dijelaskan, kami menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tarantool VShard</a> .  Perbedaan utamanya adalah tingkat penyimpanan data divirtualkan: penyimpanan virtual muncul di atas yang fisik, dan catatan didistribusikan di antara mereka.  Penyimpanan ini disebut bucket'ami.  Pengguna tidak perlu memikirkan apa dan di mana simpul fisik berada.  Bucket adalah unit data atom yang tidak dapat dibagi, seperti dalam sharding klasik satu tuple.  VShard selalu menyimpan seluruh bucket pada satu simpul fisik dan selama pengulangan pengiriman semua data satu ember secara atom.  Karena ini, lokalitas disediakan.  Kami hanya perlu memasukkan data dalam satu ember, dan kami selalu dapat yakin bahwa data ini akan bersama dengan setiap perubahan di cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42e/a4f/87b/42ea4f87b5c0f0b05bdf0e0c75b356fe.png"><br><br>  Bagaimana saya bisa memasukkan data dalam satu ember?  Dalam skema yang sebelumnya kami perkenalkan untuk klien bank, kami akan menambahkan <code>bucket id</code> ke tabel sesuai dengan bidang baru.  Jika data tertaut adalah sama, catatan akan berada di ember yang sama.  Keuntungannya adalah kita dapat menyimpan catatan ini dengan <code>bucket id</code> sama di ruang yang berbeda, dan bahkan di mesin yang berbeda.  <code>bucket id</code> disediakan tidak peduli bagaimana catatan ini disimpan. <br><br><pre> <code class="plaintext hljs">format = {{'id', 'unsigned'}, {'email', 'string'}, {'bucket_id', 'unsigned'}} box.schema.create_space('customer', {format = format}) format = {{'id', 'unsigned'}, {'customer_id', 'unsigned'}, {'balance', 'number'}, {'bucket_id', 'unsigned'}} box.schema.create_space('account', {format = format})</code> </pre><br>  Kenapa kita begitu bersemangat untuk ini?  Jika kita memiliki sharding klasik, maka data dapat merayapi semua penyimpanan fisik yang hanya kita miliki.  Dalam contoh dengan bank, saat meminta semua akun klien, Anda harus beralih ke semua node.  Ternyata kesulitan membaca O (N), di mana N adalah jumlah toko fisik.  Sangat lambat. <br><br>  Berkat bucket'am dan lokalitas berdasarkan <code>bucket id</code> kami selalu dapat membaca data dari satu node dalam satu permintaan, terlepas dari ukuran cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2bb/524/8b7/2bb5248b7757ea6249f47a3dca46a681.png"><br><br>  Anda perlu menghitung <code>bucket id</code> dan menetapkan nilai yang sama sendiri.  Bagi sebagian orang, ini merupakan keuntungan, bagi seseorang kerugian.  Saya menganggap itu keuntungan bahwa Anda dapat memilih fungsi untuk menghitung <code>bucket id</code> sendiri. <br><br>  Apa perbedaan utama antara sharding klasik dan sharding virtual dengan bucket? <br><br>  Dalam kasus pertama, ketika kita mengubah komposisi cluster, kita memiliki dua status: saat ini (lama) dan yang baru, di mana kita harus pergi.  Dalam proses transisi, Anda tidak hanya perlu mentransfer data, tetapi juga untuk menghitung ulang fungsi hash untuk semua catatan.  Ini sangat merepotkan, karena pada waktu tertentu kita tidak tahu data mana yang sudah ditransfer dan mana yang tidak.  Selain itu, ini bukan dapat diandalkan atau atomik, karena untuk transfer atom dari satu set catatan dengan nilai fungsi hash yang sama, perlu untuk menyimpan kondisi transfer secara terus-menerus jika perlu pemulihan.  Ada konflik, kesalahan, Anda harus memulai ulang prosedur berkali-kali. <br><br>  Sharding virtual jauh lebih sederhana.  Kami tidak memiliki dua status cluster yang dipilih, kami hanya memiliki status bucket.  Cluster menjadi lebih bermanuver, secara bertahap bergerak dari satu kondisi ke kondisi lainnya.  Dan sekarang ada lebih dari dua negara.  Berkat transisi yang lancar, Anda dapat mengubah saldo dengan cepat, menghapus penyimpanan yang baru ditambahkan.  Artinya, kemampuan mengontrol keseimbangan sangat meningkat, menjadi granular. <br><br><h1>  Gunakan </h1><br>  Katakanlah kita memilih fungsi untuk <code>bucket id</code> dan menuangkan begitu banyak data ke dalam cluster sehingga tidak ada lagi ruang.  Sekarang kami ingin menambahkan node, dan agar data dipindahkan ke mereka sendiri.  Di VShard, ini dilakukan sebagai berikut.  Pertama, luncurkan node dan Tarantools baru pada mereka, dan kemudian perbarui konfigurasi VShard.  Ini menggambarkan semua anggota cluster, semua replika, set replika, master, URI yang ditugaskan, dan banyak lagi.  Kami menambahkan node baru ke konfigurasi, dan menggunakan fungsi <code>VShard.storage.cfg</code> , <code>VShard.storage.cfg</code> menggunakannya pada semua node cluster. <br><br><pre> <code class="plaintext hljs">function create_user(email) local customer_id = next_id() local bucket_id = crc32(customer_id) box.space.customer:insert(customer_id, email, bucket_id) end function add_account(customer_id) local id = next_id() local bucket_id = crc32(customer_id) box.space.account:insert(id, customer_id, 0, bucket_id) end</code> </pre> <br>  Seperti yang Anda ingat, dalam sharding klasik dengan perubahan jumlah node, fungsi shard juga berubah.  Dalam VShard ini tidak terjadi, kami memiliki sejumlah penyimpanan virtual - bucket'ov.  Ini adalah konstanta yang Anda pilih saat memulai cluster.  Mungkin karena itu, skalabilitas terbatas, tetapi tidak juga.  Anda dapat memilih sejumlah besar bucket'ov, puluhan dan ratusan ribu.  Hal utama adalah bahwa harus ada setidaknya dua urutan besarnya lebih dari jumlah set replika maksimum yang pernah Anda miliki di cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/422/499/979/422499979e5b8c5728c3df2b967cf599.gif"><br><br>  Karena jumlah penyimpanan virtual tidak berubah - dan fungsi beling hanya bergantung pada nilai ini - kita dapat menambahkan penyimpanan fisik sebanyak yang diperlukan tanpa menghitung ulang fungsi beling. <br><br>  Bagaimana buket didistribusikan di antara toko fisik sendiri?  Ketika VShard.storage.cfg dipanggil pada salah satu node, proses rebalancing terbangun.  Ini adalah proses analitik yang menghitung keseimbangan sempurna dalam sebuah cluster.  Dia pergi ke semua node fisik, bertanya siapa yang memiliki berapa bucket'ov, dan membangun rute untuk pergerakan mereka untuk rata-rata distribusi.  Penyeimbang mengirimkan rute ke penyimpanan yang penuh sesak, dan mereka mulai mengirim ember.  Setelah beberapa waktu, gugus menjadi seimbang. <br><br>  Tetapi dalam proyek nyata, konsep keseimbangan sempurna mungkin berbeda.  Sebagai contoh, saya ingin menyimpan lebih sedikit data pada satu set replika daripada yang lain, karena ada lebih sedikit ruang hard disk.  VShard berpikir bahwa semuanya seimbang, dan sebenarnya penyimpanan saya hampir meluap.  Kami telah menyediakan mekanisme untuk menyesuaikan aturan keseimbangan menggunakan bobot.  Setiap set replika dan repositori dapat ditimbang.  Ketika penyeimbang memutuskan kepada siapa untuk mengirim berapa ember, dia memperhitungkan <b>hubungan</b> semua pasangan bobot. <br><br>  Misalnya, satu toko memiliki berat 100, dan yang lain memiliki 200. Kemudian toko pertama akan menyimpan dua kali lebih sedikit ember daripada yang kedua.  Harap dicatat bahwa saya sedang berbicara secara khusus tentang <b>rasio</b> bobot.  Makna absolut tidak berpengaruh.  Anda dapat memilih bobot berdasarkan distribusi cluster 100%: satu toko memiliki 30%, yang lain memiliki 70%.  Anda dapat menggunakan kapasitas penyimpanan dalam gigabytes sebagai dasar, atau Anda dapat mengukur bobot dalam jumlah bucket'ov.  Hal utama adalah mengamati sikap yang Anda butuhkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4e/889/298/b4e889298991781b8c3ee01f4c066a6e.png"><br><br>  Sistem semacam itu memiliki efek samping yang menarik: jika Anda menetapkan bobot nol untuk beberapa toko, maka penyeimbang akan memerintahkan toko untuk mendistribusikan semua embernya.  Setelah itu, Anda dapat menghapus seluruh set replika dari konfigurasi. <br><br><h1>  Transfer Ember Atom </h1><br>  Kami memiliki ember, menerima beberapa jenis permintaan baca dan tulis, dan kemudian penyeimbang meminta untuk mentransfernya ke penyimpanan lain.  Bucket berhenti menerima permintaan untuk merekam, jika tidak mereka akan memiliki waktu untuk memperbaruinya selama transfer, maka mereka akan memiliki waktu untuk memperbarui pembaruan portabel, kemudian pembaruan portabel, dan seterusnya hingga tak terbatas.  Oleh karena itu, catatan diblokir, dan Anda masih dapat membaca dari ember.  Pemindahan bongkahan ke tempat baru dimulai.  Setelah transfer selesai, ember akan kembali menerima permintaan.  Di tempat lama, itu juga masih terletak, tetapi sudah ditandai sebagai sampah dan kemudian pengumpul sampah akan menghapusnya sepotong demi sepotong. <br><br>  Setiap bucket dikaitkan dengan metadata yang disimpan secara fisik di disk.  Semua langkah di atas disimpan ke disk, dan apa pun yang terjadi dengan repositori, keadaan bucket akan secara otomatis dikembalikan. <br><br>  Anda mungkin memiliki pertanyaan: <br><br><ul><li>  <b>Apa yang akan terjadi pada permintaan yang bekerja dengan bucket ketika mereka mulai porting?</b> <br><br>  Ada dua jenis tautan dalam metadata setiap kotak: baca dan tulis.  Ketika pengguna membuat permintaan ke ember, ia menunjukkan bagaimana ia akan bekerja dengannya, hanya baca atau baca tulis.  Untuk setiap permintaan, penghitung referensi yang sesuai bertambah. <br><br>  Mengapa saya memerlukan penghitung referensi untuk membaca permintaan?  Katakanlah ember dipindahkan dengan diam-diam, dan di sini pemulung datang dan ingin menghapus ember ini.  Dia melihat bahwa jumlah tautan lebih besar dari nol, jadi Anda tidak dapat menghapusnya.  Dan ketika permintaan diproses, pemulung akan dapat menyelesaikan pekerjaannya. <br><br>  Penghitung referensi untuk permintaan penulisan memastikan bahwa ember bahkan tidak mulai terbawa ketika setidaknya satu permintaan penulisan bekerja dengannya.  Tetapi permintaan penulisan bisa datang terus-menerus, dan kemudian ember tidak akan pernah ditransfer.  Faktanya adalah bahwa jika penyeimbang telah menyatakan keinginan untuk mentransfernya, maka permintaan rekaman baru akan mulai diblokir, dan sistem saat ini akan menunggu penyelesaian beberapa waktu habis.  Jika permintaan tidak selesai dalam waktu yang ditentukan, sistem akan kembali menerima permintaan penulisan baru, menunda transfer bucket untuk beberapa waktu.  Dengan demikian, penyeimbang akan melakukan upaya transfer sampai berhasil. <br><br>  VShard memiliki API bucket_ref tingkat rendah jika Anda memiliki beberapa fitur tingkat tinggi.  Jika Anda benar-benar ingin melakukan sesuatu sendiri, cukup akses API ini dari kodenya. </li><li>  <b>Apakah mungkin untuk tidak memblokir catatan sama sekali?</b> <br><br>  Itu tidak mungkin.  Jika bucket berisi data penting yang membutuhkan akses tulis konstan, Anda harus memblokir transfernya sama sekali.  Ada fungsi <code>bucket_pin</code> untuk ini, itu menempel erat ember ke set replika saat ini, mencegah transfernya.  Dalam hal ini, bucket yang berdekatan dapat bergerak tanpa batasan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6a/848/fa7/b6a848fa775b0066ac6f69b73d97ed76.png"><br><br>  Ada alat yang bahkan lebih kuat daripada <code>bucket_pin</code> - replika set blocking.  Tidak lagi dilakukan dalam kode, tetapi melalui konfigurasi.  Blocking melarang perpindahan bucket'ov dari set'a replika ini dan penerimaan yang baru.  Dengan demikian, semua data akan selalu tersedia untuk direkam. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65b/744/39c/65b74439c5b5743eda1168bdb320f8f4.png"></li></ul><br><h1>  VShard.router </h1><br>  VShard terdiri dari dua submodul: VShard.storage dan VShard.router.  Mereka dapat dibuat dan diskalakan secara independen bahkan pada satu contoh.  Saat mengakses cluster, kami tidak tahu di mana bucket berada, dan VShard.router akan mencarinya dengan <code>bucket id</code> untuk kami. <br><br>  Mari kita lihat contoh bagaimana ini terlihat.  Kami kembali ke cluster perbankan dan akun klien.  Saya ingin dapat mengeluarkan semua akun klien tertentu dari cluster.  Untuk melakukan ini, saya menulis fungsi biasa untuk pencarian lokal: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f78/e2b/df2/f78e2bdf2d977fcb9fb320b031592171.png"><br><br>  Dia mencari semua akun pelanggan dengan id-nya.  Sekarang saya perlu memutuskan repositori mana yang akan memanggil fungsi ini.  Untuk melakukan ini, saya menghitung <code>bucket id</code> dari ID klien dalam permintaan saya dan meminta VShard.router untuk memanggil saya fungsi seperti itu di penyimpanan tempat bucket tinggal dengan <code>bucket id</code> dihasilkan.  Ada tabel routing dalam submodule, di mana lokasi ember di set replika ditentukan.  Dan VShard.router proksi permintaan saya. <br><br>  Tentu saja, itu mungkin terjadi bahwa saat ini dimulai pengerjaan ulang dan ember mulai bergerak.  Router di latar belakang secara bertahap memperbarui tabel dalam potongan besar: ia menanyakan repositori untuk tabel bucket mereka saat ini. <br><br>  Bahkan mungkin terjadi bahwa kita beralih ke bucket yang baru saja dipindahkan, dan router belum berhasil memperbarui tabel peruteannya.  Kemudian dia akan beralih ke repositori lama, dan itu akan memberi tahu router tempat untuk mencari ember, atau hanya menjawab bahwa itu tidak memiliki data yang diperlukan.  Kemudian router akan berkeliling semua penyimpanan untuk mencari ember yang diinginkan.  Dan semua ini transparan bagi kami, kami bahkan tidak akan melihat ada kesalahan dalam tabel routing. <br><br><h1>  Baca ketidakstabilan </h1><br>  Ingat masalah yang awalnya kami alami: <br><br><ul><li>  Tidak ada lokalitas data.  Kami memutuskan dengan menambahkan bucket'ov. </li><li>  Resharding memperlambat segalanya dan memperlambat.  Diimplementasikan ember'ami transfer data atom, menyingkirkan penghitungan fungsi beling. </li><li>  Bacaan tidak stabil. </li></ul><br>  Masalah terakhir diselesaikan oleh VShard.router menggunakan subsistem baca failover otomatis. <br><br>  Router secara berkala mem-ping penyimpanan yang ditentukan dalam konfigurasi.  Dan kemudian beberapa dari mereka berhenti ping.  Router memiliki koneksi cadangan panas untuk setiap replika, dan jika yang saat ini berhenti merespons, itu akan pergi ke yang lain.  Permintaan baca akan diproses secara normal, karena kita dapat membaca replika (tetapi tidak menulis).  Kita dapat mengatur prioritas replika dimana router harus memilih failover untuk dibaca.  Kami melakukan ini dengan zonasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c3/5bf/dbd/5c35bfdbddd67fe8217f06730673bd43.png"><br><br>  Kami menetapkan nomor zona untuk setiap replika dan setiap router dan mengatur tabel di mana kami menunjukkan jarak antara setiap pasangan zona.  Ketika router memutuskan ke mana harus mengirim permintaan baca, itu akan memilih replika di zona yang paling dekat dengan permintaannya. <br><br>  Bagaimana tampilannya dalam konfigurasi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/445/799/5ae/4457995ae5c7bc1761684cf7d4f3b2e4.png"><br><br>  Dalam kasus umum, Anda bisa merujuk ke replika yang sewenang-wenang, tetapi jika cluster besar dan kompleks, sangat terdistribusi, maka zonasi sangat berguna.  Rak server yang berbeda dapat menjadi zona, agar tidak memuat jaringan dengan lalu lintas.  Atau bisa juga titik-titik yang secara geografis jauh dari satu sama lain. <br><br>  Zonasi juga membantu dengan beragam kinerja replika.  Misalnya, dalam setiap set replika kami memiliki satu replika cadangan, yang seharusnya tidak menerima permintaan, tetapi hanya menyimpan salinan data.  Kemudian kita membuatnya di zona, yang akan sangat jauh dari semua router di tabel, dan mereka akan beralih ke itu dalam kasus yang paling ekstrem. <br><br><h1>  Merekam ketidakstabilan </h1><br>  Karena kita berbicara tentang read failover, bagaimana dengan write failover ketika mengubah wisaya?  Di sini, VShard tidak begitu cerah: pemilihan master baru tidak diterapkan di dalamnya, Anda harus melakukannya sendiri.  Ketika kita entah bagaimana memilihnya, perlu bahwa instance ini sekarang mengambil alih otoritas master.  Kami memperbarui konfigurasi dengan menentukan <code>master = false</code> untuk master lama, dan <code>master = true</code> untuk yang baru, menerapkannya melalui VShard.storage.cfg dan menggulungnya ke penyimpanan.  Maka semuanya terjadi secara otomatis.  Master lama berhenti menerima permintaan tulis dan mulai menyinkronkan dengan yang baru, karena mungkin ada data yang sudah diterapkan pada master lama, tetapi yang baru belum tiba.  Setelah itu, master baru memasuki peran dan mulai menerima permintaan, dan master lama menjadi replika.  Beginilah cara menulis failover bekerja di VShard. <br><br><pre> <code class="plaintext hljs">replicas = new_cfg.sharding[uud].replicas replicas[old_master_uuid].master = false replicas[new_master_uuid].master = true vshard.storage.cfg(new_cfg)</code> </pre> <br><h1>  Bagaimana sekarang mengikuti semua ragam acara ini? </h1><br>  Dalam kasus umum, dua pegangan sudah cukup - <code>VShard.storage.info</code> dan <code>VShard.router.info</code> . <br><br>  VShard.storage.info menampilkan informasi dalam beberapa bagian. <br><br><pre> <code class="plaintext hljs">vshard.storage.info() --- - replicasets: &lt;replicaset_2&gt;: uuid: &lt;replicaset_2&gt; master: uri: storage@127.0.0.1:3303 &lt;replicaset_1&gt;: uuid: &lt;replicaset_1&gt; master: missing bucket: receiving: 0 active: 0 total: 0 garbage: 0 pinned: 0 sending: 0 status: 2 replication: status: slave Alerts: - ['MISSING_MASTER', 'Master is not configured for ''replicaset &lt;replicaset_1&gt;']</code> </pre> <br>  Yang pertama adalah bagian replikasi.  Status set replika yang Anda terapkan fungsi ini ditampilkan: lag replikasi apa yang dimilikinya, dengan siapa ia memiliki koneksi dan dengan siapa itu tidak tersedia, siapa yang tersedia dan tidak tersedia, wizard mana yang dikonfigurasi untuk yang mana, dll. <br><br>  Di bagian Bucket, Anda dapat melihat secara real time berapa banyak bucket'ov saat ini pindah ke set replika saat ini, berapa banyak yang meninggalkannya, berapa banyak yang sedang mengerjakannya, berapa banyak yang ditandai sebagai sampah, berapa banyak yang terpasang. <br><br>  Bagian Alert adalah semacam campur aduk dari semua masalah yang VShard mampu menentukan secara independen: master tidak dikonfigurasi, tingkat redundansi tidak cukup, master ada di sana, dan semua replika telah gagal, dll. <br><br>  Dan bagian terakhir adalah cahaya yang menyala merah ketika segalanya menjadi sangat buruk.  Ini adalah angka dari nol hingga tiga, semakin banyak semakin buruk. <br><br>  VShard.router.info memiliki bagian yang sama, tetapi artinya sedikit berbeda. <br><br><pre> <code class="plaintext hljs">vshard.router.info() --- - replicasets: &lt;replicaset_2&gt;: replica: &amp;0 status: available uri: storage@127.0.0.1:3303 uuid: 1e02ae8a-afc0-4e91-ba34-843a356b8ed7 bucket: available_rw: 500 uuid: &lt;replicaset_2&gt; master: *0 &lt;replicaset_1&gt;: replica: &amp;1 status: available uri: storage@127.0.0.1:3301 uuid: 8a274925-a26d-47fc-9e1b-af88ce939412 bucket: available_rw: 400 uuid: &lt;replicaset_1&gt; master: *1 bucket: unreachable: 0 available_ro: 800 unknown: 200 available_rw: 700 status: 1 alerts: - ['UNKNOWN_BUCKETS', '200 buckets are not discovered']</code> </pre> <br>  Bagian pertama adalah replikasi.      ,    :    ,  replica set'  ,          ,   ,   replica set'  bucket'     ,     . <br><br>   Bucket    bucket',              ;    bucket'   ;  ,       replica set'. <br><br>   Alert,  ,   ,   failover,   bucket'. <br><br> ,         . <br><br><h1>     VShard? </h1><br>  â€”    bucket'.       <code>int32_max</code> ?     bucket'   â€”  30      16   .     bucket',     .           bucket',          bucket'.    ,          . <br><br>  â€”   -   <code>bucket id</code> .    ,    -   ,   bucket â€”           .      ,   bucket'   ,  VShard    bucket'.       -,      bucket'  bucket,  -.    . <br><br><h1>  Ringkasan </h1><br> Vshard : <br><br><ul><li>  ; </li><li>  ; </li><li>    ; </li><li>  read failover; </li><li>    bucket'. </li></ul><br> VShard   .  -    .  â€”  <b>   </b> .     ,       .           . <br><br>  â€” <b>lock-free  bucket'</b> .   ,       bucket'      .      ,     . <br><br>  â€” <b>  </b> .          : -    ,   ,    ?        . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436916/">https://habr.com/ru/post/id436916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436904/index.html">Ambang 32K untuk data dalam ROM mikrokontroler AVR</a></li>
<li><a href="../id436908/index.html">6 cara untuk menyembunyikan data di aplikasi Android</a></li>
<li><a href="../id436910/index.html">Kiat untuk membuat alur kerja khusus di GitLab CI</a></li>
<li><a href="../id436912/index.html">2019 Tren CRM: menyenangkan untuk dibaca, berbahaya untuk dipercaya</a></li>
<li><a href="../id436914/index.html">Masalah Pertumbuhan Startup - Pemantauan</a></li>
<li><a href="../id436918/index.html">Membuat Game untuk Game Boy, Bagian 2</a></li>
<li><a href="../id436920/index.html">Transpiler PAS2JS dari Pascal ke JavaScript: tidak kompatibel dengan Delphi dan solusi</a></li>
<li><a href="../id436922/index.html">Mengoptimalkan waktu startup Prometheus 2.6.0 dengan pprof</a></li>
<li><a href="../id436924/index.html">Beberapa kata tentang organisasi kompetisi robot</a></li>
<li><a href="../id436926/index.html">Pahlawan autentikasi dua faktor, atau cara "berjalan di posisi orang lain"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>