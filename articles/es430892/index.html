<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📥 🤷🏾 📈 La combinación del enfoque multiplataforma y nativo en el desarrollo de aplicaciones móviles. 🌈 💔 🤘🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para lanzar aplicaciones para una sola plataforma móvil no es relevante y debe ocuparse de desarrollar dos versiones a la vez, para iOS y Android. Y a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La combinación del enfoque multiplataforma y nativo en el desarrollo de aplicaciones móviles.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430892/">  Para lanzar aplicaciones para una sola plataforma móvil no es relevante y debe ocuparse de desarrollar dos versiones a la vez, para iOS y Android.  Y aquí puede elegir dos formas: trabajar en los lenguajes de programación "nativos" para cada sistema operativo o usar marcos multiplataforma. <br><br>  Al desarrollar uno de los proyectos en DD Planet, confié en la última opción.  Y en este artículo hablaré sobre la experiencia de desarrollar una aplicación multiplataforma, los problemas que encontramos y las soluciones encontradas. <br><a name="habracut"></a><br><h2>  Tres enfoques para desarrollar aplicaciones móviles multiplataforma </h2><br>  Para comenzar, considere qué enfoques se utilizan cuando necesita obtener dos aplicaciones a la vez: para iOS y Android. <br><br>  El primero es el más costoso, tanto en tiempo como en recursos: desarrollar una aplicación separada para cada plataforma.  La complejidad de este enfoque radica en el hecho de que cada uno de los sistemas operativos requiere su propio enfoque: esto se expresa tanto en el lenguaje en el que se está desarrollando (para Android - Java o Kotlin, para iOS - Objective-C o Swift), como en los métodos para describir la parte de la interfaz de usuario aplicaciones (axml y xib o archivos de guión gráfico, respectivamente). <br><br>  Este hecho solo nos lleva al hecho de que para este enfoque es necesario formar dos equipos de desarrollo.  Además, tendrá que duplicar la lógica para cada una de las plataformas: interacción con la API y la lógica de negocios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-j/pl/52/-jpl52-jwex193hykedjtv569to.png" alt="imagen"></div><br>  Pero, ¿qué pasa si aumenta el número de API utilizadas? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pt/kl/zc/ptklzcfkjzn5zxmgqjuyxkhvtyq.png" alt="imagen"></div><br>  Esto plantea la pregunta: ¿cómo reducir la cantidad requerida de recursos humanos?  Deshágase de la necesidad de duplicar el código para cada plataforma.  Hay un número suficiente de marcos y tecnologías que resuelven este problema. <br><br>  El uso de un marco multiplataforma (Xamarin.Forms, por ejemplo) hace posible escribir código en un lenguaje de programación y describir la lógica de datos y la lógica de IU una vez, en un solo lugar.  Por lo tanto, la necesidad de usar dos equipos de desarrollo desaparece.  Y como resultado de compilar el proyecto, obtenemos dos aplicaciones nativas en la salida.  Y este es el segundo enfoque. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sc/si/v4/scsiv4dfupwnvimrp1507onobfa.png" alt="imagen"></div><br>  Creo que muchos saben lo que es Xamarin, o al menos lo han escuchado, pero ¿cómo funciona?  Xamarin se basa en la implementación de código abierto de la plataforma .NET - Mono.  Mono incluye su propio compilador de C #, tiempo de ejecución, así como varias bibliotecas, incluida la implementación de WinForms y ASP.Net. <br><br>  El objetivo del proyecto es permitir que los programas escritos en C # se ejecuten en sistemas operativos que no sean Windows: sistemas Unix, Mac OS y otros.  El marco Xamarin en sí mismo, en esencia, es una biblioteca de clase que brinda a los desarrolladores acceso al SDK de la plataforma y a los compiladores para estos.  Xamarin.Forms, a su vez, le permite no solo escribir para ambas plataformas en el mismo idioma, sino también diseñar pantallas usando el marcado XAML, familiar para aquellos que ya tenían experiencia con las aplicaciones WPF.  Como resultado del ensamblaje del proyecto, obtenemos un aspecto casi idéntico en todas las plataformas, ya que en la etapa de compilación todos los controles XF se convierten a nativos para cada plataforma. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/ft/fs/w4ftfsahuvg63dn2ugjfugnp6_8.png" alt="imagen"></div><br>  El desarrollador se ve obligado a escribir código para cada plataforma solo si se necesita acceso a cualquier función de la plataforma (por ejemplo, un escáner de huellas digitales o nivel de batería) o si es necesario ajustar el comportamiento del control.  En algunos casos, al desarrollar una aplicación, puede ser necesario escribir código dependiente de la plataforma, pero incluso en este caso, nadie prohíbe llevar las funciones de la plataforma a la interfaz e interactuar con ella desde un proyecto común. <br><br>  Un lenguaje de programación, código pequeño, etc.  Todo suena hermoso pero, Xamarin.Forms no es una bala de plata, y toda su belleza se rompe en piedras de realidad.  Tan pronto como surge una situación cuando los controles XF incorporados ya no cumplen con los requisitos para ellos, la estructura de las pantallas y los controles se vuelve cada vez más complicada.  Para garantizar un trabajo cómodo con pantallas de un proyecto común, debe escribir más y más renders personalizados. <br><br>  Esto pasará al tercer enfoque, que usamos al desarrollar aplicaciones. <br><br>  Ya descubrimos que usar Xamarin Forms puede complicar el trabajo, en lugar de simplificarlo.  Por lo tanto, para implementar pantallas arquitectónicamente complejas, diseñar elementos y controles que sean fundamentalmente diferentes de los nativos, se encontró un compromiso y la posibilidad de combinar el primer y el segundo enfoque. <br><br>  Tenemos los mismos tres proyectos: un proyecto PCL común, pero sin Xamarin Forms, y dos proyectos Xamarin para Android y Xamarin para iOS.  Todavía existe la oportunidad de escribir todo en un idioma, lógica común entre dos proyectos, pero no hay limitaciones de un solo marcado XAML.  El componente UI está controlado por cada plataforma y utiliza herramientas nativas, en Android - AXML nativo, en iOS - archivos XIB.  Cada plataforma tiene la capacidad de cumplir con sus pautas, ya que la conexión entre Core y los proyectos de plataforma se organiza solo a nivel de datos. <br><br>  Para organizar tal relación, puede usar el patrón de diseño MVVM y su implementación bastante popular para Xamarin - MVVMCross.  Su uso le permite mantener un ViewModel común para cada pantalla, que describe la "lógica de negocios" completa del trabajo y confía su representación a la plataforma.  También permite que dos desarrolladores trabajen con la misma pantalla (uno con lógica, el otro con UI) y no interfieran entre sí.  Además de la implementación del patrón, obtenemos una cantidad suficiente de herramientas para el trabajo: la implementación de DI e IoC.  Para elevar la interacción con la plataforma al nivel de código común, un desarrollador solo necesita declarar una interfaz e implementarla en la plataforma.  Para cosas típicas, MvvmCross ya proporciona un conjunto de sus propios complementos.  En el equipo, utilizamos el complemento de mensajería para intercambiar mensajes entre la plataforma y el código común y el complemento para trabajar con archivos (seleccionar imágenes de la galería, etc.). <br><br><h2>  Resolvemos los problemas de diseño complejo y navegación multinivel. </h2><br>  Como se mencionó anteriormente, cuando se usan representaciones complejas en la pantalla, el marco puede complicar la vida más que facilitarla.  Pero, ¿qué se llama un elemento complejo?  Como me dedico principalmente al desarrollo de iOS, se considerará un ejemplo de esta plataforma.  Por ejemplo, una cosa tan trivial como un campo de entrada puede tener varios estados y suficiente lógica para cambiar y visualizar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/an/fw/vf/anfwvfodqmfoui_0u2i6k52g_s4.png" alt="imagen"></div><br>  En el curso de trabajar con la entrada del usuario, tal control de entrada se desarrolló aquí.  Puede elevar su nombre sobre el campo de entrada, trabajar con máscaras, establecer prefijos, postfijos, notificar cuando se presiona CapsLock, validar información en dos modos: prohibición de entrada y salida de información de error.  La lógica dentro del control toma aproximadamente ~ 1000 líneas.  Y, parecería: ¿qué puede ser complicado en el diseño del campo de entrada? <br><br>  Un ejemplo simple de un control complejo que vimos.  ¿Qué hay de las pantallas? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cz/dq/ul/czdqulhcq0x1trskfg4j9szemd0.png" alt="imagen"></div><br>  Para empezar, aclararé que, en la mayoría de los casos, una pantalla de aplicación es una clase: UIViewController, que describe su comportamiento.  Durante el desarrollo, se requería la creación de navegación multinivel.  El concepto de la aplicación desarrollada se reduce a administrar sus bienes inmuebles e interactuar con vecinos y organizaciones municipales.  Por lo tanto, se construyeron tres niveles de navegación: propiedad, nivel de presentación (hogar, ciudad, región) y tipo de contenido.  Todo el cambio se lleva a cabo en una pantalla. <br><br>  Esto se hizo para que el usuario, esté donde esté, entienda qué tipo de contenido ve.  Para organizar dicha navegación, la pantalla principal de la aplicación no consta de un solo controlador.  Visualmente, se puede dividir en 3 partes, pero ¿alguien puede tratar de adivinar cuántos controladores se usan aquí? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/od/9h/tzod9hfhgm2r4fcebdz0pbhg06y.png" alt="imagen"></div><br>  Quince controladores principales.  Y esto es solo por contenido. <br><br>  Aquí tal monstruo vive en la pantalla principal y se siente bastante bien.  Quince controladores para una pantalla son, por supuesto, muchos.  Esto afecta la velocidad de toda la aplicación y necesita optimizarla de alguna manera. <br><br>  Rechazamos la inicialización síncrona: todos los modelos de vista se inicializan en segundo plano y solo cuando es necesario.  Para reducir el tiempo de renderizado, también abandonamos los archivos xib para estas pantallas: el posicionamiento absoluto y las matemáticas son siempre más rápidos que calcular las dependencias entre elementos. <br><br>  Para realizar un seguimiento de tantos controladores, debe comprender: <br><br><ul><li>  En qué condición se encuentra cada uno de ellos; </li><li>  ¿Dónde está el usuario? </li><li>  Lo que espera ver cuando se mude a otro controlador. </li></ul><br>  Para hacer esto, escribí un procesador de navegación separado que almacena información sobre la ubicación del usuario, el tipo de contenido que está viendo, el historial de navegación, etc.  Él controla el orden y la necesidad de la inicialización. <br><br>  Dado que cada pestaña es un control deslizante del controlador (para crear una transición de deslizamiento sobre ellas), debe comprender: cada una de ellas puede estar en su propio estado (por ejemplo, "Noticias" está abierta en una y "Votación" en la otra).  Esto es seguido por el mismo procesador de navegación.  Incluso cambiando el nivel de presentación desde el hogar a la región, seguiremos con el mismo tipo de contenido. <br><br><h2>  Controlamos el flujo de datos en tiempo real. </h2><br>  Al trabajar con tantos datos en la aplicación, debe organizar la entrega de información relevante en todas las secciones en tiempo real.  Para resolver este problema, se pueden distinguir 3 métodos: <br><br><ol><li>  Acceda a la API por temporizadores o disparadores y vuelva a solicitar contenido relevante en las pantallas; </li><li>  Tener una conexión permanente con el servidor y recibir cambios en tiempo real; </li><li>  Recibe empuje con cambios de contenido. </li></ol><br>  Cada enfoque tiene sus pros y sus contras, por lo que es mejor usar los tres, eligiendo solo las fortalezas de cada uno.  Dividimos condicionalmente el contenido dentro de la aplicación en varios tipos: hot, regular y service.  Esto se hace para determinar el tiempo aceptable entre el evento y la notificación del usuario.  Por ejemplo, queremos ver un mensaje de chat inmediatamente después de que nos lo envíen; este es un contenido interesante.  Otra opción: encuesta de vecinos.  No hay diferencia cuando lo vemos, ahora o en un minuto, porque este es un contenido ordinario.  Las notificaciones pequeñas dentro de la aplicación (mensajes no leídos, comandos, etc.) son contenido de servicio que necesita entrega urgente, pero que no toma muchos datos. <br><br>  Resulta que: <br><br><ul><li>  Contenido activo: conexión permanente con la API; </li><li>  Contenido normal: solicitudes http a la API; </li><li>  Contenido del sistema: notificaciones push. </li></ul><br>  Lo más interesante es mantener una conexión constante.  Escribir su propio cliente para trabajar con sockets web es un paso en el agujero del conejo, por lo que debe buscar otras soluciones.  Como resultado, nos detuvimos en la biblioteca SignalR.  Veamos de qué se trata. <br><br>  ASP.Net SignalR es una biblioteca de Microsoft que simplifica la interacción cliente-servidor en tiempo real, proporcionando comunicación bidireccional entre el cliente y el servidor.  El servidor incluye una API completa para administrar la conexión, eventos de desconexión de conexión, un mecanismo para combinar clientes conectados en grupos y autorización. <br><br>  SignalR puede usar websockets, LongPolling y solicitudes http como transporte.  Puede especificar el tipo de transporte por la fuerza o confiar en la biblioteca: si se puede utilizar websocket, funcionará a través de websocket, si esto no es posible, se desactivará hasta que encuentre un transporte aceptable.  Este hecho resultó ser muy práctico, dado que está planeado usarlo en dispositivos móviles. <br><br>  Total, qué beneficio obtenemos: <br><br><ul><li>  Capacidad para intercambiar mensajes de cualquier tipo entre el cliente y el servidor; </li><li>  El mecanismo para cambiar automáticamente entre sockets web, agrupación larga y solicitudes Http; </li><li>  Información sobre el estado actual de la conexión; </li><li>  Una oportunidad para unir clientes en grupos; </li><li>  Métodos prácticos para manipular la lógica de enviar mensajes en un grupo; </li><li>  La capacidad de escalar el servidor. </li></ul><br>  Esto, por supuesto, no satisface todas las necesidades, pero notablemente hace la vida más fácil. <br><br>  Dentro del proyecto, se usa un contenedor en la biblioteca SignalR, lo que simplifica aún más el trabajo con él, a saber: <br><br><ul><li>  Supervisa el estado de la conexión, se vuelve a conectar de acuerdo con las condiciones especificadas y en caso de interrupción; </li><li>  Capaz de reemplazar o volver a abrir rápidamente la conexión, matando asincrónicamente la antigua y dándola al recolector de basura para que se rompa; como resultó, el método de conexión funciona diez veces más rápido que el método de cierre (Dispose or Stop), y esta es la única forma de cerrarla; </li><li>  Organiza una cola para enviar mensajes de modo que la reconexión o reapertura de la conexión no interrumpa el envío; </li><li>  Transfiere el control a los delegados apropiados en caso de errores imprevistos. </li></ul><br>  Cada uno de estos contenedores (los llamamos clientes) funciona en conjunto con el sistema de almacenamiento en caché y, en caso de desconexión, puede solicitar solo los datos que podrían haberse perdido durante este tiempo.  "Cada uno" porque varios compuestos activos se mantienen simultáneamente.  Dentro de la aplicación hay un mensajero completo, y se utiliza un cliente separado para atenderlo. <br><br>  El segundo cliente es responsable de recibir las notificaciones.  Como ya dije, el tipo habitual de contenido se obtiene a través de solicitudes http, en el futuro su actualización recae en este cliente, que informa todos los cambios importantes en él (por ejemplo, la votación ha pasado de un estado a otro, la publicación de nuevas noticias). <br><br><h2>  Visualice los datos en la aplicación. </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/01/ne/xn/01nexnxh3zdp2j3cizlcx2lxuhc.png" alt="imagen"></div><br>  Obtener datos es una cosa, mostrar es otra.  La actualización de datos en tiempo real tiene sus propias dificultades.  Como mínimo, debe decidir cómo presentar estas actualizaciones al usuario.  En la aplicación utilizamos tres tipos de notificaciones: <br><br><ol><li>  Notificación de contenido no leído; </li><li>  Actualización automática de datos en la pantalla; </li><li>  Oferta de contenido. </li></ol><br>  La forma más familiar y común de mostrar que en algún lugar hay contenido nuevo es resaltar el ícono de la sección.  Por lo tanto, casi todos los iconos tienen la capacidad de mostrar el notificador de contenido no leído como un punto rojo.  Cosas más interesantes son con actualizaciones automáticas. <br><br>  La actualización automática de datos solo es posible cuando el nuevo contenido no reorganiza la pantalla y no cambia el tamaño de los controles.  Por ejemplo, en la pantalla de la encuesta: la información sobre los votos solo cambiará el valor de la barra de progreso y los porcentajes.  Dichos cambios no implicarán ningún cambio de tamaño; pueden aplicarse instantáneamente sin problemas. <br><br>  Las dificultades surgen cuando necesita agregar contenido nuevo a las listas.  De hecho, todas las listas de la aplicación son ScrollView y tienen varias características: tamaño de ventana, tamaño de contenido y posición de desplazamiento.  Todos tienen un comienzo estático (parte superior de la pantalla con coordenadas 0; 0) y pueden expandirse hacia abajo.  Agregar nuevo contenido a la lista, al final, no presenta ningún problema, la lista durará.  Pero el nuevo contenido debería aparecer en la parte superior, y esta es la imagen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rh/ve/am/rhveamjeqsuityqnk3_io3njrxy.png" alt="imagen"></div><br>  Al estar en 3 elementos, estaremos en 2: el desplazamiento rebotará hacia arriba.  Y dado que el contenido nuevo puede llegar constantemente, el usuario no podrá desplazarse normalmente.  Podría decir: ¿por qué no calcular el tamaño del nuevo contenido y desplazar el desplazamiento hacia abajo a este valor?  Sí, se puede hacer.  Pero luego debe controlar manualmente la posición de desplazamiento, y si en ese momento el usuario se desplaza en cualquier dirección, su acción se interrumpirá.  Es por eso que tales pantallas no pueden actualizarse en tiempo real sin el consentimiento del usuario. <br><br>  La mejor solución en esta situación sería informar al usuario que mientras se desplazaba por el feed, alguien publicaba contenido nuevo.  En nuestro diseño, se ve como un círculo rojo en la esquina de la pantalla.  Al hacer clic en él, el usuario da su consentimiento condicional para que lo regresemos a la parte superior de la pantalla y muestre contenido nuevo. <br><br>  Con este enfoque, por supuesto, evitamos los problemas de "hacer malabarismos" con el contenido, pero aún tenían que resolverse.  Es decir, en la pantalla de chat, ya que durante la comunicación y la interacción con la pantalla, el contenido nuevo debe mostrarse en diferentes lugares. <br><br>  La diferencia entre el chat y las listas normales es que el contenido nuevo está en la parte inferior de la pantalla.  Como se trata de una "cola", puede agregar contenido allí sin mucha dificultad.  El usuario pasa el 90% del tiempo aquí, lo que significa que debe mantener constantemente la posición de desplazamiento y desplazarla hacia abajo al recibir y enviar mensajes.  En una conversación en vivo, tales acciones deben realizarse con bastante frecuencia. <br><br>  El segundo punto: cargar el historial mientras se desplaza hacia arriba.  Justo al cargar la historia, nos encontramos en una situación en la que es necesario colocar los mensajes por encima del nivel de revisión (lo que implicará un sesgo) para que el desplazamiento sea suave y continuo.  Y como ya sabemos, para no molestar al usuario, es imposible controlar manualmente la posición de desplazamiento. <br><br>  Y encontramos una solución: la entregamos.  El cambio de pantalla resolvió dos problemas a la vez: <br><br><ol><li>  La cola de la lista está en la parte superior, por lo que podemos agregar una historia sin interrupciones sin interferir con el desplazamiento del usuario; </li><li>  El último mensaje siempre está en la parte superior de la lista y no necesitamos desplazar la pantalla antes que él. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0n/hx/zf/0nhxzfnj9mhuofyu4bkr1epdtlw.png" alt="imagen"></div><br>  Esta solución también ayudó a acelerar el renderizado, eliminando operaciones innecesarias con el control de desplazamiento. <br><br>  Hablando de rendimiento.  En las primeras versiones de la pantalla, se detectaban reducciones notables al desplazarse por los mensajes.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que el contenido en el "dinero" es heterogéneo (texto, archivos, fotos), debe recalcular constantemente el tamaño de la celda, agregar y eliminar elementos en el dinero. </font><font style="vertical-align: inherit;">Por lo tanto, se requería la optimización de la burbuja. </font><font style="vertical-align: inherit;">Hicimos lo mismo que con la pantalla principal, renderizando parcialmente la masa con posicionamiento absoluto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al trabajar con listas en iOS, antes de dibujar una celda, debe saber su altura. </font><font style="vertical-align: inherit;">Por lo tanto, antes de agregar un nuevo mensaje a la lista, debe preparar toda la información necesaria para mostrar en una secuencia separada, calcular la altura de las celdas, procesar los datos del usuario y solo después de descubrir y almacenar en caché todo lo que se necesita, agregar la celda a la lista. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtenemos un desplazamiento suave y una transmisión de IU no sobrecargada.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para resumir: </font></font></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El desarrollo multiplataforma ahorra tiempo y dinero; </font></font></li><li>      ,    ,     ; </li><li>           ,      ; </li><li>           ; </li><li> SignalR –     -    ; </li><li>            ; </li><li>         ,    , ; </li><li>      ,   SignalR-,  ,  , , . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430892/">https://habr.com/ru/post/es430892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430882/index.html">Xiaomi Aqara Switch rehace de ZigBee a Z-Wave</a></li>
<li><a href="../es430884/index.html">Fábrica de impresión: por qué "LANIT-Integration" abrió su propia "imprenta"</a></li>
<li><a href="../es430886/index.html">Actualizar la biblioteca y el enemigo de SPPermission</a></li>
<li><a href="../es430888/index.html">¿Qué tan seguro es usar paquetes R para trabajar con la API de sistemas de publicidad?</a></li>
<li><a href="../es430890/index.html">Donde ágil es terrible, especialmente scrum</a></li>
<li><a href="../es430894/index.html">Situación: las marcas gastan cada vez más dinero en publicidad en podcasts: entendemos por qué</a></li>
<li><a href="../es430896/index.html">Linux Foundation ha establecido fondos para GraphQL y Ceph: por qué son necesarios y qué esperar de ellos</a></li>
<li><a href="../es430900/index.html">El primer láser de la historia: qué fue</a></li>
<li><a href="../es430902/index.html">Elfos en la memoria. Ejecutando ELF en Linux RAM</a></li>
<li><a href="../es430906/index.html">Mamá duerme tranquilamente por la noche: recolectamos OpenCV para Raspbian'a</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>