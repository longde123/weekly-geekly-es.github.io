<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò° ‚úùÔ∏è üöÖ Gu√≠a de JavaScript, Parte 8: Descripci√≥n general de las caracter√≠sticas de ES6 üö£üèº üßëüèø‚Äçü§ù‚Äçüßëüèº üìï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy, en la octava parte de la traducci√≥n del manual de JavaScript, revisaremos las caracter√≠sticas del lenguaje que apareci√≥ despu√©s del lanzamiento d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a de JavaScript, Parte 8: Descripci√≥n general de las caracter√≠sticas de ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431074/">  Hoy, en la octava parte de la traducci√≥n del manual de JavaScript, revisaremos las caracter√≠sticas del lenguaje que apareci√≥ despu√©s del lanzamiento del est√°ndar ES6.  De una forma u otra, nos hemos encontrado con muchas de estas oportunidades anteriormente, en alg√∫n lugar que nos ocupamos de ellas con m√°s detalle, en alg√∫n lugar que damos por sentado.  Esta secci√≥n de la gu√≠a est√° destinada, junto con la divulgaci√≥n de algunos temas que no hemos tocado anteriormente, a racionalizar el conocimiento de un desarrollador novato en el campo de JavaScript moderno. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: primer programa, caracter√≠sticas del lenguaje, est√°ndares</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2: estilo de c√≥digo y estructura del programa</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: variables, tipos de datos, expresiones, objetos.</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4: caracter√≠sticas</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5: matrices y bucles</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 6: excepciones, punto y coma, literales comod√≠n</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 7: modo estricto, esta palabra clave, eventos, m√≥dulos, c√°lculos matem√°ticos</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 8: Descripci√≥n general de las caracter√≠sticas de ES6</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 9: Descripci√≥n general de los est√°ndares ES7, ES8 y ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Sobre ES6</font> </h2><br>  El est√°ndar ES6, que ser√≠a m√°s correcto llamar ES2015 o ECMAScript 2015 (estos son sus nombres oficiales, aunque todos lo llaman ES6), apareci√≥ 4 a√±os despu√©s del lanzamiento del est√°ndar anterior: ES5.1.  Tom√≥ alrededor de diez a√±os desarrollar todo lo que se incluy√≥ en el est√°ndar ES5.1.  Hoy en d√≠a, todo lo que apareci√≥ en este est√°ndar se ha convertido en las herramientas habituales del desarrollador de JS.  Cabe se√±alar que ES6 realiz√≥ cambios importantes en el idioma (al tiempo que mantuvo la compatibilidad con versiones anteriores).  Para apreciar la magnitud de estos cambios, se puede observar que el tama√±o del documento que describe el est√°ndar ES5 es de aproximadamente 250 p√°ginas, y el est√°ndar ES6 se describe en un documento que ya tiene aproximadamente 600 p√°ginas. <br><br>  La lista de las innovaciones m√°s importantes del est√°ndar ES2015 puede incluir lo siguiente: <br><br><ul><li>  Funciones de flecha </li><li>  Promesas </li><li>  Generadores </li><li> Palabras clave <code>let</code> y <code>const</code> </li><li>  Clases </li><li>  M√≥dulos </li><li>  Soporte literal de plantilla </li><li>  Soporte para par√°metros de funci√≥n predeterminados </li><li>  Operador extendido </li><li>  Asignaci√≥n destructiva </li><li>  Mejora de los literales de objetos </li><li>  <code>for...of</code> bucle </li><li>  Soporte para estructuras de datos de <code>Map</code> y <code>Set</code> </li></ul><br>  Considera estas posibilidades. <br><br><h2>  <font color="#3AC1EF">Funciones de flecha</font> </h2><br>  Las funciones de flecha han cambiado la apariencia del c√≥digo JavaScript.  En t√©rminos de apariencia, su uso hace que las declaraciones de funciones sean m√°s cortas y f√°ciles.  Aqu√≠ est√° la declaraci√≥n de una funci√≥n regular. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Pero casi la misma funci√≥n de flecha (aunque no completamente similar a la anterior). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Si el cuerpo de la funci√≥n de flecha consta de una sola l√≠nea, cuyo resultado debe ser devuelto por esta funci√≥n, entonces se escribe a√∫n m√°s corto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething()</code> </pre> <br>  Si la funci√≥n de flecha solo toma un par√°metro, puede escribirlo de la siguiente manera. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething(param)</code> </pre> <br>  Cabe se√±alar que con el advenimiento de las funciones de flecha, las funciones ordinarias no han desaparecido, todav√≠a se pueden usar en el c√≥digo, funcionan de la misma manera que antes. <br><br><h2>  <font color="#3AC1EF">Caracter√≠sticas de esta palabra clave en las funciones de flecha</font> </h2><br>  Las funciones de flecha no tienen su propio valor; lo heredan del contexto de ejecuci√≥n. <br><br>  Esto soluciona el problema, para el cual, al usar funciones regulares, era necesario usar construcciones como <code>var that = this</code> para preservar el contexto.  Sin embargo, como se mostr√≥ en las partes anteriores del manual, este cambio afecta seriamente las caracter√≠sticas de trabajar con funciones de flecha y el alcance de su aplicaci√≥n. <br><br><h2>  <font color="#3AC1EF">Promesas</font> </h2><br>  Las promesas le permiten deshacerse del conocido problema llamado "infierno de devoluci√≥n de llamada", aunque su uso implica el uso de estructuras bastante complejas.  Este problema se resolvi√≥ en el est√°ndar ES2017 con el advenimiento de la construcci√≥n <code>async/await</code> , que se basa en promesas. <br><br>  Los desarrolladores de JavaScript usaron promesas antes del est√°ndar ES2015, usando varias bibliotecas para esto (por ejemplo, jQuery, q, deferred.js, voto).  Esto indica la importancia y relevancia de este mecanismo.  Diferentes bibliotecas lo implementan de diferentes maneras, la aparici√≥n de un est√°ndar en esta √°rea puede considerarse un hecho muy positivo. <br>  Aqu√≠ hay un c√≥digo escrito con funciones de devoluci√≥n de llamada (devoluciones de llamada). <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Usando promesas, esto puede reescribirse de la siguiente manera. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) wait().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait() }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Generadores</font> </h2><br>  Los generadores son funciones especiales que pueden pausar su propia ejecuci√≥n y reanudarla.  Esto permite ejecutar otro c√≥digo mientras el generador est√° inactivo. <br><br>  El generador decide por s√≠ solo que necesita pausar y permitir que otro c√≥digo, "esperando" su turno, se ejecute.  Al mismo tiempo, el generador tiene la oportunidad de continuar su ejecuci√≥n despu√©s de que se complete la operaci√≥n, cuyos resultados est√° esperando. <br><br>  Todo esto se hace gracias a una palabra clave simple y simple.  Cuando esta palabra clave se encuentra en el generador, su ejecuci√≥n se detiene. <br>  Un generador puede contener muchas l√≠neas con esta palabra clave, pausando su propia ejecuci√≥n varias veces.  Los generadores se declaran utilizando la construcci√≥n de <code>*function</code> .  Este asterisco antes de la <code>function</code> palabra no debe tomarse como algo as√≠ como un operador de referencia de puntero utilizado en lenguajes como C, C ++ o Go. <br><br>  Los generadores marcan la llegada de un nuevo paradigma de programaci√≥n de JavaScript.  En particular, permiten el intercambio de datos bidireccional entre el generador y otro c√≥digo, y permiten la creaci√≥n de bucles <code>while</code> de larga duraci√≥n que no "bloquean" el programa. <br><br>  Considere un ejemplo que ilustra las caracter√≠sticas de la operaci√≥n de generadores.  Aqu√≠ est√° el generador en s√≠. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doubleThat = <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (input / <span class="hljs-number"><span class="hljs-number">2</span></span>))   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> another = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (doubleThat)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (input * doubleThat * another) }</code> </pre> <br>  Con este comando lo inicializamos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calc = calculator(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br>  Luego pasamos a su iterador. <br><br><pre> <code class="javascript hljs">calc.next()</code> </pre> <br>  Este comando inicia un iterador, devuelve dicho objeto. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br>  Aqu√≠ sucede lo siguiente.  El c√≥digo ejecuta una funci√≥n utilizando el valor de <code>input</code> pasado al constructor del generador.  El c√≥digo del generador se ejecuta hasta que se encuentra la palabra clave de <code>yield</code> .  En este punto, devuelve el resultado de dividir la <code>input</code> por <code>2</code> , que, dado que la <code>input</code> es <code>10</code> , da el n√∫mero <code>5</code> .  Obtenemos este n√∫mero gracias al iterador y, junto con √©l, una indicaci√≥n de que el generador a√∫n no se ha completado (la propiedad <code>done</code> en el objeto devuelto por el iterador se establece en <code>false</code> ), es decir, la funci√≥n solo se ha suspendido. <br>  La pr√≥xima vez que se llama al iterador, pasamos el n√∫mero <code>7</code> al generador. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br>  En respuesta a esto, el iterador nos devuelve el siguiente objeto. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">14</span></span> }</code> </pre> <br>  Aqu√≠, el n√∫mero <code>7</code> se us√≥ para calcular el <code>doubleThat</code> valor. <br><br>  A primera vista, puede parecer que el c√≥digo de <code>input / 2</code> es algo as√≠ como un argumento para alguna funci√≥n, pero este es solo el valor devuelto en la primera iteraci√≥n.  Aqu√≠ omitimos este valor y usamos el nuevo valor de entrada <code>7</code> , multiplic√°ndolo por <code>2</code> .  Despu√©s de eso, llegamos a la segunda palabra clave de <code>yield</code> , como resultado, el valor obtenido en la segunda iteraci√≥n es <code>14</code> . <br><br>  En la pr√≥xima iteraci√≥n, que es la √∫ltima, pasamos el n√∫mero <code>100</code> al generador. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  En respuesta, obtenemos el siguiente objeto. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> value: <span class="hljs-number"><span class="hljs-number">14000</span></span> }</code> </pre> <br>  La iteraci√≥n se completa (la palabra clave de <code>yield</code> ya no se encuentra en el generador), el resultado de evaluar la expresi√≥n <code>(input * doubleThat * another)</code> devuelve en el objeto, es decir - <code>10 * 14 * 100</code> y una indicaci√≥n de la finalizaci√≥n del iterador ( <code>done: true</code> ). <br><br><h2>  <font color="#3AC1EF">Palabras clave let y const</font> </h2><br>  JavaScript siempre ha usado la palabra clave <code>var</code> para declarar variables.  Dichas variables tienen un alcance funcional.  Las palabras clave <code>let</code> y <code>const</code> , respectivamente, le permiten declarar variables y constantes que tienen un alcance de bloque. <br><br>  Esto significa que, por ejemplo, una variable declarada utilizando la palabra clave <code>let</code> en un bucle, dentro de un bloque <code>if</code> o dentro de un bloque de c√≥digo normal limitado por llaves, no ir√° m√°s all√° de este bloque.  Las variables declaradas con <code>var</code> no se mantienen en dichos bloques, y est√°n disponibles en la funci√≥n en el nivel en el que se declaran. <br><br>  La palabra clave <code>const</code> funciona igual que <code>let</code> , pero con ella se declaran las constantes que son inmutables. <br><br>  En el c√≥digo JS moderno, la palabra clave <code>var</code> rara vez se usa.  Dio paso a las palabras clave <code>let</code> y <code>const</code> .  Al mismo tiempo, lo que puede parecer inusual, la palabra clave <code>const</code> se usa ampliamente hoy en d√≠a, lo que indica la popularidad de las ideas de inmunidad de las entidades en la programaci√≥n moderna. <br><br><h2>  <font color="#3AC1EF">Clases</font> </h2><br>  Result√≥ que JavaScript era el √∫nico lenguaje extremadamente extendido que usaba el modelo de herencia prototipo.  Los programadores que cambiaron a JS desde lenguajes que implementan el mecanismo de herencia basado en clases se sintieron inc√≥modos en dicho entorno.  El est√°ndar ES2015 introdujo soporte de clase en JavaScript.  Esto es esencialmente "az√∫car sint√°ctico" alrededor de los mecanismos internos de JS que utilizan prototipos.  Sin embargo, esto afecta c√≥mo exactamente escriben las aplicaciones JS. <br><br>  Los mecanismos de herencia de JavaScript ahora parecen mecanismos similares en otros lenguajes orientados a objetos. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name } hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, I am '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name + <span class="hljs-string"><span class="hljs-string">'.'</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.hello() + <span class="hljs-string"><span class="hljs-string">' I am an actor.'</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomCruise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Actor(<span class="hljs-string"><span class="hljs-string">'Tom Cruise'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(tomCruise.hello())</code> </pre> <br>  Este programa muestra el texto <code>Hello, I am Tom Cruise. I am an actor</code> en la consola <code>Hello, I am Tom Cruise. I am an actor</code>  <code>Hello, I am Tom Cruise. I am an actor</code> <br>  En las clases JS, las variables de instancia no pueden declararse; deben inicializarse en los constructores. <br><br><h3>  <font color="#3AC1EF"> Constructor de clase</font> </h3><br>  Las clases tienen un m√©todo especial, <code>constructor</code> , que se llama cuando se crea una instancia de la clase usando la <code>new</code> palabra clave. <br><br><h3>  <font color="#3AC1EF">‚ñç Palabra clave super</font> </h3><br>  La palabra clave <code>super</code> permite acceder a la clase padre desde las clases descendientes. <br><br><h3>  <font color="#3AC1EF">‚ñç Getters y setters</font> </h3><br>  El captador de una propiedad se puede establecer de la siguiente manera. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ get fullName() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.firstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.lastName}</span></span></span><span class="hljs-string">`</span></span> } }</code> </pre> <br>  El setter se puede describir como se muestra a continuaci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ set age(years) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.theAge = years } }</code> </pre> <br>  Trabajan con getters y setters como si no fueran funciones, sino propiedades ordinarias de los objetos. <br><br><h2>  <font color="#3AC1EF">M√≥dulos</font> </h2><br>  Antes del est√°ndar ES2015, hab√≠a varios enfoques competitivos para trabajar con m√≥dulos.  En particular, estamos hablando de las tecnolog√≠as RequireJS y CommonJS.  Esta situaci√≥n condujo a un desacuerdo en la comunidad de desarrolladores de JS. <br><br>  Hoy en d√≠a, gracias a la estandarizaci√≥n de los m√≥dulos en ES2015, la situaci√≥n se est√° normalizando gradualmente. <br><br><h3>  <font color="#3AC1EF">‚ñç Importar m√≥dulos</font> </h3><br>  Los m√≥dulos se importan utilizando una construcci√≥n del formulario <code>import...from...</code>  Aqu√≠ hay algunos ejemplos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { React, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyLibrary <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Exportaci√≥n de m√≥dulos</font> </h3><br>  Los mecanismos internos del m√≥dulo est√°n cerrados desde el mundo exterior, pero desde el m√≥dulo puede exportar todo lo que puede ofrecer a otros m√≥dulos.  Esto se hace usando la palabra clave <code>export</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Literales de plantilla</font> </h3><br>  Los literales de plantilla son una nueva forma de describir cadenas en JavaScript.  As√≠ es como se ve. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aString = <span class="hljs-string"><span class="hljs-string">`A string`</span></span></code> </pre> <br>  Adem√°s, el uso de la sintaxis de los literales de plantilla le permite incrustar expresiones en cadenas e interpolarlas.  Esto se hace usando una construcci√≥n de la forma <code>${a_variable}</code> .  Aqu√≠ hay un ejemplo simple de su uso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">//something test</span></span></code> </pre> <br>  Aqu√≠ hay un ejemplo m√°s complicado, que ilustra la capacidad de evaluar cualquier expresi√≥n y sustituir sus resultados en una cadena. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str2 = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${foo() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span></code> </pre> <br>  Gracias al uso de literales de plantilla, se ha vuelto mucho m√°s f√°cil declarar cadenas de varias l√≠neas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str3 = <span class="hljs-string"><span class="hljs-string">`Hey this string is awesome!`</span></span></code> </pre> <br>  Compare esto con lo que ten√≠a que hacer para describir cadenas de varias l√≠neas al usar las funciones disponibles en el idioma anterior a ES2015. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">'One\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Two\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Three'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Par√°metros de funci√≥n predeterminados</font> </h2><br>  Ahora las funciones admiten los par√°metros utilizados de forma predeterminada, en el caso de que no se les pasen los argumentos correspondientes al llamar a las funciones. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, testing = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } foo()</code> </pre> <br><h2>  <font color="#3AC1EF">Operador extendido</font> </h2><br>  El operador de propagaci√≥n (operador de extensi√≥n) le permite "expandir" matrices, objetos o cadenas.  Este operador se parece a tres puntos ( <code>...</code> ).  Primero, consid√©relo con un ejemplo de matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br>  Aqu√≠ se explica c√≥mo crear una nueva matriz basada en esta matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [...a, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]</code> </pre> <br>  Aqu√≠ se explica c√≥mo crear una copia de la matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = [...a]</code> </pre> <br>  Este operador tambi√©n trabaja con objetos.  Por ejemplo, aqu√≠ se explica c√≥mo usarlo para clonar un objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newObj = { ...oldObj }</code> </pre> <br>  Aplicando el operador de propagaci√≥n a una cadena, puede convertirlo en una matriz, cada elemento del cual contiene un car√°cter de esta cadena. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayized = [...hey] <span class="hljs-comment"><span class="hljs-comment">// ['h', 'e', 'y']</span></span></code> </pre> <br>  Este operador, adem√°s de las variantes anteriores de su aplicaci√≥n, es conveniente para usar cuando se llaman funciones que esperan una lista normal de argumentos, pas√°ndoles una matriz con estos argumentos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) =&gt;</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] f(...a)</code> </pre> <br>  Anteriormente, esto se hac√≠a usando una construcci√≥n del formulario <code>f.apply(null, a)</code> , pero dicho c√≥digo es m√°s dif√≠cil de escribir y es menos legible. <br><br><h2>  <font color="#3AC1EF">Asignaci√≥n destructiva</font> </h2><br>  La t√©cnica de asignaci√≥n de desestructuraci√≥n permite, por ejemplo, tomar un objeto, extraer algunos valores de √©l y ponerlos en variables o constantes con nombre. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">'Cruise'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actor</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">54</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: name, age} = person</code> </pre> <br>  Aqu√≠, las <code>firstName</code> y <code>age</code> se recuperan del objeto.  La propiedad <code>age</code> se escribe en la constante declarada con el mismo nombre, y la propiedad <code>firstName</code> , despu√©s de la extracci√≥n, cae en el <code>name</code> constante. <br><br>  La asignaci√≥n destructiva tambi√©n es adecuada para trabajar con matrices. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, , , fifth] = a</code> </pre> <br>  Las constantes <code>first</code> , <code>second</code> y <code>fifth</code> obtienen los elementos primero, segundo y quinto de la matriz, respectivamente. <br><br><h2>  <font color="#3AC1EF">Mejora de los literales de objetos</font> </h2><br>  ES2015 ha ampliado enormemente la capacidad de describir objetos usando literales de objeto. <br><br><h3>  <font color="#3AC1EF">‚ñç Simplificaci√≥n de la inclusi√≥n de variables en objetos.</font> </h3><br>  Anteriormente, para asignar una variable a una propiedad de un objeto, era necesario usar la siguiente construcci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">something</span></span>: something }</code> </pre> <br>  Ahora se puede hacer lo mismo as√≠. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { something }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Prototipos</font> </h3><br>  El prototipo del objeto ahora se puede configurar utilizando la siguiente construcci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Palabra clave super</font> </h3><br>  Usando la palabra clave <code>super</code> , los objetos pueden acceder a los objetos prototipo.  Por ejemplo, para llamar a sus m√©todos que tienen los mismos nombres que los m√©todos de estos objetos mismos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'zoo'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject, test() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.test() + <span class="hljs-string"><span class="hljs-string">'x'</span></span> } } x.test() <span class="hljs-comment"><span class="hljs-comment">//zoox</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Nombres de propiedad calculados</font> </h3><br>  Los nombres de propiedades calculados se forman en la etapa de creaci√≥n de objetos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { [<span class="hljs-string"><span class="hljs-string">'a'</span></span> + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + <span class="hljs-string"><span class="hljs-string">'b'</span></span>]: <span class="hljs-string"><span class="hljs-string">'z'</span></span> } x.a_b <span class="hljs-comment"><span class="hljs-comment">//z</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Para ... de bucle</font> </h2><br>  En 2009, en el est√°ndar ES5, aparecieron bucles <code>forEach()</code> .  Este es un dise√±o √∫til, cuya desventaja es el hecho de que tales ciclos son muy inconvenientes para interrumpir.  El cl√°sico <code>for</code> bucle en situaciones en las que necesita interrumpir la ejecuci√≥n del bucle antes de su finalizaci√≥n normal es una opci√≥n mucho m√°s apropiada. <br><br>  En ES2015 ha aparecido un ciclo <code>for...of</code> que, por un lado, se distingue por su sintaxis concisa y conveniencia para cada <code>forEach</code> , y por otro lado, respalda la posibilidad de una salida anticipada del ciclo. <br><br>  Aqu√≠ hay un par de <code>for...of</code> ejemplos <code>for...of</code> bucles. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    for (const v of ['a', 'b', 'c']) { console.log(v); } //           entries() for (const [i, v] of ['a', 'b', 'c'].entries()) { console.log(i, v); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Mapear y establecer estructuras de datos</font> </h2><br>  ES2015 introdujo las estructuras de datos <code>Map</code> and <code>Set</code> (as√≠ como sus versiones "d√©biles" <code>WeakMap</code> y <code>WeakSet</code> , <code>WeakSet</code> uso mejora el rendimiento del "recolector de basura", el mecanismo responsable de administrar la memoria en los motores JS).  Estas son estructuras de datos muy populares que, antes de la aparici√≥n de su implementaci√≥n oficial, tuvieron que imitarse utilizando las herramientas de lenguaje disponibles. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Hoy revisamos las caracter√≠sticas del est√°ndar ES2015, que han influido mucho en el estado actual del idioma.  Nuestro pr√≥ximo tema ser√°n las caracter√≠sticas de los est√°ndares ES2016, ES2017 y ES2018. <br><br>  <b>Estimados lectores!</b>  ¬øQu√© innovaciones del est√°ndar ES6 encuentra m√°s √∫tiles? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431074/">https://habr.com/ru/post/es431074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431064/index.html">Manifiesto de programador r√≠gido</a></li>
<li><a href="../es431066/index.html">DEFCON 16. ¬øC√≥mo puedo contactarte? D√©jame enumerar las formas. Parte 2</a></li>
<li><a href="../es431068/index.html">El arte de la educaci√≥n: la ideolog√≠a de las m√°quinas tragamonedas</a></li>
<li><a href="../es431070/index.html">Hara comer? Estamos hablando de los h√°bitos alimenticios de un especialista en TI moderno.</a></li>
<li><a href="../es431072/index.html">Gu√≠a de JavaScript parte 7: modo estricto, esta palabra clave, eventos, m√≥dulos, matem√°ticas</a></li>
<li><a href="../es431076/index.html">Los frameworks Node.js m√°s populares de 2018</a></li>
<li><a href="../es431078/index.html">Gu√≠a de manejo de errores de JavaScript</a></li>
<li><a href="../es431080/index.html">C√≥mo organizar oficinas remotas y no perder un equipo en el espacio</a></li>
<li><a href="../es431082/index.html">Kotlin: buscando jefe de marketing</a></li>
<li><a href="../es431084/index.html">En cualquier situaci√≥n incomprensible - escriba guiones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>