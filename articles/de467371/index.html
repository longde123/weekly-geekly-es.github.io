<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐢 🍙 🏐 Google Job Interview Parsing: Beziehungen finden 🤛🏻 🕒 👩🏾‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Willkommen zum nächsten Artikel in einer Reihe von Rätseln, die ich bei Google-Interviews gefragt habe, bevor sie nach dem Leck verboten wurden. Seitd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Google Job Interview Parsing: Beziehungen finden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467371/"><img src="https://habrastorage.org/getpro/habr/post_images/915/39d/3b3/91539d3b3be71056861dc65e18921c88.png"><br><br>  Willkommen zum nächsten Artikel in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von</a> Rätseln, die ich bei Google-Interviews gefragt habe, bevor sie nach dem Leck verboten wurden.  Seitdem habe ich aufgehört, als Softwareentwickler bei Google zu arbeiten, und bin zum Entwicklungsleiter bei Reddit gewechselt, aber ich habe immer noch ein paar großartige Themen.  Bisher haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dynamische Programmierung</a> untersucht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und Matrizen zur Leistungsfähigkeit</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synonymie von Abfragen erhoben</a> .  Diesmal eine völlig neue Frage. <br><a name="habracut"></a><br>  Aber zuerst zwei Punkte.  Zunächst einmal war die Arbeit bei Reddit großartig.  In den letzten acht Monaten habe ich das neue Team für Anzeigenrelevanz aufgebaut und geleitet und ein neues Entwicklungsbüro in New York eingerichtet.  Egal wie lustig es auch sein mag, leider stellte ich fest, dass ich bis vor kurzem keine Zeit oder Energie mehr für einen Blog hatte.  Ich fürchte, ich habe diese Serie ein bisschen aufgegeben.  Entschuldigen sie für die Verzögerung. <br><br>  Zweitens, wenn Sie den Artikeln gefolgt sind, könnten Sie nach der letzten Ausgabe denken, dass ich anfangen würde, mich mit den synonymischen Optionen der Abfragen zu befassen.  Obwohl ich irgendwann darauf zurückkommen möchte, muss ich zugeben, dass ich aufgrund eines Arbeitswechsels das Interesse an diesem Problem verloren habe und mich bisher entschlossen habe, es zu verschieben.  Bleiben Sie jedoch in Kontakt!  Ich schulde mir etwas und beabsichtige, es zurückzugeben.  Nur ein bisschen später ... <br><br>  <i>Kurzer Haftungsausschluss: Obwohl das Befragen von Kandidaten eine meiner beruflichen Aufgaben ist, präsentiert dieser Blog meine persönlichen Beobachtungen, persönlichen Geschichten und persönlichen Meinungen.</i>  <i>Bitte nehmen Sie dies nicht für eine offizielle Erklärung von Google, Alphabet, Reddit oder einer anderen Person oder Organisation.</i> <br><br><h2>  Suchen Sie nach einer neuen Frage </h2><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel habe</a> ich eine meiner Lieblingsfragen beschrieben, die ich lange Zeit vor dem unvermeidlichen Leck verwendet habe.  Die vorherigen Fragen waren aus theoretischer Sicht faszinierend, aber ich wollte ein Problem auswählen, das für Google als Unternehmen etwas relevanter ist.  Als diese Frage verboten wurde, wollte ich unter Berücksichtigung der neuen Einschränkung einen Ersatz finden: um die Frage <i>einfacher</i> zu machen. <br><br>  Dies mag angesichts des berüchtigten Interviewprozesses bei Google etwas überraschend erscheinen.  Aber zu dieser Zeit machte ein einfacheres Problem Sinn.  Meine Argumentation bestand aus zwei Teilen.  Das erste ist pragmatisch: Die Kandidaten haben frühere Fragen trotz zahlreicher Hinweise und Vereinfachungen normalerweise nicht sehr gut gemeistert, und ich war mir nicht immer ganz sicher, warum.  Die zweite theoretische: Der Interviewprozess sollte die Kandidaten in die Kategorien „es lohnt sich, eingestellt zu werden“ und „es lohnt sich nicht, eingestellt zu werden“ einteilen, und ich war gespannt, ob dies mit der Frage etwas einfacher gemacht werden könnte. <br><br>  Bevor ich diese beiden Punkte klarstelle, möchte ich darauf hinweisen, was sie <i>nicht</i> bedeuten.  "Ich bin nicht immer sicher, warum eine Person Probleme hat" bedeutet nicht, dass die Fragen nutzlos sind und dass ich das Interview aus diesem Grund vereinfachen wollte.  Selbst die schwierigste Frage haben viele gut gemeistert.  Ich meine, wenn Kandidaten Probleme hatten, war es für mich schwer zu verstehen, was ihnen fehlte. <br><br>  Gute Interviews geben ein umfassendes Bild der Stärken und Schwächen des Kandidaten.  Es reicht nicht aus, wenn das Einstellungskomitee einfach sagt, dass es „gescheitert“ ist: Das Komitee bestimmt, ob der Kandidat unternehmensspezifische Eigenschaften hat, die er sucht.  Ebenso helfen die Worte „er ist cool“ dem Ausschuss nicht, sich für einen Kandidaten zu entscheiden, der in einigen Bereichen stark, in anderen jedoch zweifelhaft ist.  Ich habe festgestellt, dass komplexere Themen die Kandidaten zu oft in diese beiden Kategorien einteilen.  In diesem Licht bedeutet "Ich bin nicht immer sicher, warum eine Person Probleme hat", "die Unfähigkeit, in diesem Bereich voranzukommen, zeichnet an sich kein Bild der Fähigkeiten dieses Kandidaten." <br><br>  Die Einstufung von Kandidaten als „einstellungswürdig“ und „nicht einstellungswürdig“ <i>bedeutet nicht</i> , dass der Interviewprozess dumme Kandidaten von intelligenten trennen sollte.  Ich kann mich nicht an einen einzigen Kandidaten erinnern, der nicht klug, talentiert und motiviert war.  Viele kamen von exzellenten Universitäten, und der Rest war eindeutig äußerst motiviert.  Das Durchlaufen von Telefoninterviews ist bereits ein gutes Sieb, und selbst das Ablehnen in dieser Phase ist kein Zeichen für mangelnde Fähigkeiten. <br><br>  Ich <i>kann</i> mich <i>jedoch</i> an viele erinnern, die nicht ausreichend auf das Interview vorbereitet waren oder zu langsam arbeiteten oder zu viel Aufsicht benötigten, um das Problem zu lösen, oder auf unklare Weise kommunizierten oder ihre Ideen nicht in Code übersetzen konnten oder eine Position innehatten, die einfach nicht führen würde Sein Erfolg auf lange Sicht usw. Die Definition von „eine Einstellung wert“ ist vage und variiert je nach Unternehmen. Der Interviewprozess besteht darin, festzustellen, ob jeder Kandidat die Anforderungen eines bestimmten Unternehmens erfüllt. <br><br>  Ich habe viele reddit-Kommentare gelesen, in denen ich mich über zu komplexe Interviewfragen beschwert habe.  Ich war neugierig, ob es noch möglich ist, eine würdige / unwürdige Empfehlung für eine einfachere Aufgabe abzugeben.  Ich vermutete, dass dies ein nützliches Signal geben würde, ohne die Nerven des Kandidaten unnötig zu schreien.  Ich werde Ihnen am Ende des Artikels von meinen Schlussfolgerungen erzählen ... <br><br>  Mit diesen Gedanken suchte ich nach einer neuen Frage.  In einer idealen Welt ist diese Frage einfach genug, um sie in 45 Minuten zu lösen, aber mit zusätzlichen Fragen, damit leistungsfähigere Kandidaten ihre Fähigkeiten unter Beweis stellen.  Die Implementierung sollte auch kompakt sein, da viele Kandidaten immer noch an die Tafel schreiben.  Ein großes Plus, wenn das Thema irgendwie mit Google-Produkten zusammenhängt. <br><br>  Schließlich entschied ich mich für eine Frage, die ein wunderbarer Googler sorgfältig beschrieben und in unsere Fragendatenbank eingefügt hatte.  Jetzt habe ich mich mit ehemaligen Kollegen beraten und sichergestellt, dass die Frage noch verboten ist, so dass Sie beim Interview definitiv nicht gefragt werden.  Ich präsentiere es in der Form, in der es mir am effektivsten erscheint, mit einer Entschuldigung an den ursprünglichen Autor. <br><br><h2>  Frage </h2><br>  Sprechen Sie über Entfernungsmessungen.  <i>Hand</i> ist eine 4-Zoll-Maßeinheit, die im englischsprachigen Raum häufig zur Messung der Pferdehöhe verwendet wird.  <i>Ein Lichtjahr</i> ist eine weitere Maßeinheit, die der Entfernung entspricht, die ein Lichtteilchen (oder eine Welle?) In einer bestimmten Anzahl von Sekunden zurücklegt, ungefähr gleich einem Erdjahr.  Auf den ersten Blick haben sie wenig miteinander zu tun, außer dass sie zur Entfernungsmessung verwendet werden.  Es stellt sich jedoch heraus, dass Google sie ganz einfach konvertieren kann: <br><br><img src="https://habrastorage.org/webt/uu/8z/y-/uu8zy-po4rpuvr61dtewmyhjns0.png"><br><br>  Dies mag offensichtlich erscheinen: Am Ende messen beide die Entfernung, sodass klar ist, dass es eine Transformation gibt.  Aber wenn Sie darüber nachdenken, ist es etwas seltsam: Wie haben sie diese Conversion-Rate berechnet?  Es ist klar, dass niemand wirklich die Anzahl der Hände in einem Lichtjahr gezählt hat.  Eigentlich müssen Sie dies nicht direkt übernehmen.  Sie können einfach bekannte Konvertierungen verwenden: <br><br><ul><li>  <i>1 Hand</i> = <i>4 Zoll</i> <br></li><li>  <i>4 Zoll</i> = <i>0,33333 Fuß</i> <br></li><li>  <i>0,33333 ft</i> = <i>6,3125e - 5 Meilen</i> <br></li><li>  <i>6,3125e - 5 Meilen</i> = <i>1,0737e - 17 Lichtjahre</i> </li></ul><br>  Ziel der Aufgabe ist es, ein System zu entwickeln, das diese Transformation durchführt.  Insbesondere: <br><br><blockquote>  Am Eingang haben Sie eine Liste von Umrechnungsfaktoren (in der von Ihnen gewählten Sprache formatiert) in Form einer Reihe von anfänglichen Maßeinheiten, endgültigen Einheiten und Faktoren, zum Beispiel: <br><br><pre>  ft 12
 Fußhof 0,3333333
 usw. </pre><br>  Damit ORIGIN * MULTIPLIER = DESTINATION.  Entwickeln Sie einen Algorithmus, der zwei beliebige Einheitswerte verwendet und den Umrechnungsfaktor zwischen ihnen zurückgibt. </blockquote><br><h2>  Die Diskussion </h2><br>  Ich mag dieses Problem, weil es eine intuitive und offensichtliche Antwort hat: Konvertieren Sie einfach von einer Einheit zur anderen und dann zur nächsten, bis Sie das Ziel gefunden haben!  Ich kann mich nicht an einen einzelnen Kandidaten erinnern, der auf dieses Problem gestoßen ist und völlig verwirrt war, wie man es löst.  Dies passt gut zu der Anforderung eines „einfacheren“ Problems, da die vorherigen normalerweise lange Studien und Überlegungen erforderten, bevor zumindest ein grundlegender Lösungsansatz gefunden wurde. <br><br>  Trotzdem haben viele Kandidaten ihre Intuition als funktionierende Lösung ohne offensichtliche Hinweise nicht verwirklicht.  Einer der Vorteile dieser Frage besteht darin, dass sie die Fähigkeit des Kandidaten testet, das Problem so zu formulieren (Framing zu erstellen), dass es sich für Analyse und Codierung eignet.  Wie wir sehen werden, gibt es hier eine sehr interessante Erweiterung, die einen neuen konzeptionellen Sprung erfordert. <br><br>  Für den Kontext ist Framing der Vorgang des Übersetzens eines Problems mit einer nicht offensichtlichen Lösung in ein äquivalentes Problem, bei dem die Lösung auf natürliche Weise abgeleitet wird.  Wenn dies völlig abstrakt und uneinnehmbar klingt, tut es mir leid, aber es ist.  Ich werde erklären, was ich meine, wenn ich die erste Lösung für dieses Problem vorstelle.  Der erste Teil der Lösung wird eine Übung zur Entwicklung und Anwendung von algorithmischem Wissen sein.  Der zweite Teil wird eine Übung zur Manipulation dieses Wissens sein, um zu einer neuen und nicht offensichtlichen Optimierung zu gelangen. <br><br><h2>  Teil 0. Intuition </h2><br>  Bevor wir tiefer graben, wollen wir die „offensichtliche“ Lösung vollständig untersuchen.  Die meisten erforderlichen Konvertierungen sind einfach und unkompliziert.  Jeder Amerikaner, der außerhalb der USA gereist ist, weiß, dass der größte Teil der Welt die mysteriöse Einheit „Kilometer“ verwendet, um Entfernungen zu messen.  Zum Konvertieren müssen Sie nur die Anzahl der Meilen mit etwa 1,6 multiplizieren. <br><br>  Wir sind fast unser ganzes Leben lang auf solche Dinge gestoßen.  Für die meisten Einheiten gibt es bereits eine vorberechnete Umrechnung, sodass Sie sie nur in der entsprechenden Tabelle betrachten müssen.  Wenn es jedoch keine direkte Konvertierung gibt (z. B. von Händen zu Lichtjahren), ist es sinnvoll, einen Konvertierungspfad wie oben angegeben zu erstellen: <br><br><ul><li>  <i>1 Hand</i> = <i>4 Zoll</i> <br></li><li>  <i>4 Zoll</i> = <i>0,33333 Fuß</i> <br></li><li>  <i>0,33333 ft</i> = <i>6,3125e - 5 Meilen</i> <br></li><li>  <i>6,3125e - 5 Meilen</i> = <i>1,0737e - 17 Lichtjahre</i> </li></ul><br>  Es war sehr einfach, ich habe mir gerade eine solche Transformation mit meiner Fantasie und einer Standard-Transformationstabelle ausgedacht!  Es bleiben jedoch einige Fragen offen.  Gibt es einen kürzeren Weg?  Wie genau ist der Koeffizient?  Ist eine Konvertierung immer möglich?  Ist es möglich, es zu automatisieren?  Leider bricht hier der naive Ansatz zusammen. <br><br><h2>  Teil 1. Naive Entscheidung </h2><br>  Es ist schön, dass das Problem eine intuitive Lösung hat, aber tatsächlich ist diese Einfachheit ein Hindernis für die Lösung des Problems.  Es gibt nichts Schwierigeres, als zu versuchen, auf neue Weise zu verstehen, was Sie bereits verstehen - nicht zuletzt, weil Sie oft weniger wissen, als Sie denken.  Stellen Sie sich zur Veranschaulichung vor, Sie wären zu einem Interview gekommen - und Sie haben diese intuitive Methode im Kopf.  Es erlaubt jedoch nicht, eine Reihe wichtiger Probleme zu lösen. <br><br>  Was <i>ist</i> zum Beispiel, wenn <i>keine Konvertierung erfolgt</i> ?  Der offensichtliche Ansatz sagt nichts aus, ist es wirklich möglich, von einer Einheit zur anderen zu konvertieren.  Wenn sie mir tausend Umrechnungskurse geben, wird es für mich sehr schwierig sein festzustellen, ob dies im Prinzip möglich ist.  Wenn ich gebeten werde, eine Konvertierung zwischen unbekannten (oder erfundenen) Einheiten eines <i>Zeigers</i> und eines <i>Stoßes vorzunehmen</i> , habe ich keine Ahnung, wo ich anfangen soll.  Wie hilft hier ein intuitiver Ansatz? <br><br>  Ich muss zugeben, dass dies eine Art erfundenes Szenario ist, aber es gibt auch ein realistischeres.  Sie sehen, dass meine Erklärung des Problems nur Entfernungseinheiten enthält.  Dies geschieht absichtlich.  Was ist, wenn ich das System auffordere, von Zoll in Kilogramm umzurechnen?  Sowohl Sie als auch ich wissen, dass dies nicht möglich ist, weil sie unterschiedliche Typen messen, aber die Eingabe sagt nichts über den „Typ“ aus, den jede Einheit misst. <br><br>  Hier ermöglicht eine sorgfältige Formulierung der Frage starken Kandidaten, sich zu beweisen.  <i>Bevor</i> sie den Algorithmus entwickeln, denken sie über die Extremfälle des Systems nach.  Und eine solche Erklärung des Problems gibt ihnen absichtlich die Möglichkeit, mich zu fragen, ob wir verschiedene Einheiten übersetzen werden.  Dies ist kein so großes Problem, wenn es in einem frühen Stadium auftritt, aber es ist immer ein gutes Zeichen, wenn mich jemand im Voraus fragt: "Was soll das Programm zurückgeben, wenn eine Konvertierung nicht möglich ist?"  Wenn ich die Frage so stelle, bekomme ich eine Vorstellung von den Fähigkeiten des Kandidaten, bevor er mindestens eine Codezeile schreibt. <br><br>  <i>Diagrammansicht</i> <br><br>  Offensichtlich ist der naive Ansatz nicht geeignet, also müssen wir uns überlegen, wie wir eine solche Konvertierung durchführen können.  Die Antwort besteht darin, Einheiten als Grafik zu betrachten.  Dies ist der erste Sprung zum Verständnis, der zur Lösung dieses Problems erforderlich ist. <br><br>  Stellen Sie sich insbesondere vor, dass jede Einheit ein Knoten in einem Diagramm ist und es eine Kante von Knoten <code>A</code> zu Knoten <code>B</code> wenn <code>A</code> in <code>B</code> konvertiert werden kann: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc6/d25/89f/fc6d2589f8a9a411cec0d704e2ad644e.png"><br><br>  Die Kanten sind mit einer Conversion-Rate gekennzeichnet, mit der Sie <code>A</code> multiplizieren müssen, um <code>B</code> zu erhalten <code>B</code> <br><br>  Ich hatte fast immer erwartet, dass der Kandidat einen solchen Rahmen finden würde, und gab ihm selten ernsthafte Hinweise.  Ich kann dem Kandidaten vergeben, der die Lösung des Problems der Verwendung disjunkter Mengen nicht bemerkt oder mit der linearen Algebra nicht allzu vertraut ist, um eine Lösung zu realisieren, die sich darauf reduziert, die Potenz der Adjazenzmatrix wieder zu erhöhen, aber Grafiken werden in jedem Lehrplan oder Programmierkurs unterrichtet.  Wenn der Kandidat nicht über die entsprechenden Kenntnisse verfügt, handelt es sich um ein Signal „Keine Einstellung“. <br><br>  <i>Auf jeden Fall</i> <br><br>  Eine Diagrammdarstellung reduziert die Lösung des klassischen Problems der Diagrammsuche.  Insbesondere sind hier zwei Algorithmen nützlich: Wide Search (BFS) und Deep Search (DFS).  Bei der Suche in der Breite untersuchen wir die Knoten nach ihrem Abstand vom Ursprung: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d45/4cb/15b/d454cb15b85c4ea9ce32e87623ed4115.png"><br>  <i><font color="gray">Dunklerer Blues bedeutet spätere Generationen</font></i> <br><br>  Und bei der eingehenden Suche untersuchen wir die Knoten in der Reihenfolge, in der sie auftreten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/f4c/f1a/40bf4cf1ae3d89554505c031c4529559.png"><br><br>  <i><font color="gray">Dunklerer Blues bedeutet auch spätere Generationen.</font></i>  <i><font color="gray">Bitte beachten Sie, dass wir nicht alle Websites besuchen</font></i> <br><br>  Jeder der Algorithmen bestimmt leicht, ob eine Konvertierung von einer Einheit in eine andere erfolgt. Es reicht aus, einfach die Grafik zu durchsuchen.  Wir starten von der Quelleneinheit und suchen, bis wir die Zieleinheit finden.  Wenn Sie Ihr Ziel nicht finden können (als würden Sie versuchen, Zoll in Kilogramm umzurechnen), wissen wir, dass es keinen Weg gibt. <br><br>  Aber warte, etwas fehlt.  Wir wollen nicht nach einem Weg suchen, wir wollen eine Conversion-Rate finden!  Hier muss der Kandidat den Sprung machen: Es stellt sich heraus, dass Sie jeden Suchalgorithmus ändern können, um die Conversion-Rate zu berechnen, indem Sie einfach den zusätzlichen Status speichern, während Sie fortfahren.  Hier machen Illustrationen keinen Sinn mehr, also lasst uns direkt in den Code eintauchen. <br><br>  Zuerst müssen Sie die Datenstruktur des Diagramms bestimmen, damit wir Folgendes verwenden: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateGraph</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rates)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Initialize the graph from an iterable of (start, end, rate) tuples.'</span></span> self.graph = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> orig, dest, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rates: self.add_conversion(orig, dest, rate) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of the nodes neighboring the given node.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph[node].items() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of all the nodes in the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph.keys()</code> </pre> <br>  Dann fangen wir mit DFS an.  Es gibt viele Möglichkeiten, es zu implementieren, aber die bei weitem häufigste ist eine rekursive Lösung.  Beginnen wir damit: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__dfs_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end, rate_from_origin, visited)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: rate = __dfs_helper(rate_graph, unit, end, rate_from_origin * rate, visited) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __dfs_helper(rate_graph, node, end, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, set())</code> </pre> <br>  Kurz gesagt, dieser Algorithmus beginnt mit einem Knoten, iteriert über seine Nachbarn und besucht jeden sofort, wobei die Funktion rekursiv aufgerufen wird.  Jeder Funktionsaufruf auf dem Stapel speichert den Status seiner eigenen Iteration. Wenn also ein rekursiver Besuch zurückgegeben wird, setzt das übergeordnete Element die Iteration sofort fort.  Wir vermeiden es, dieselbe Site erneut zu besuchen, indem wir bei allen Anrufen eine Reihe von besuchten Sites verwalten.  Wir berechnen den Koeffizienten auch, indem wir jedem Knoten und der Quelle einen Umrechnungsfaktor zuweisen.  Wenn wir also auf den Zielknoten / -block stoßen, haben wir bereits den Konvertierungskoeffizienten aus dem Quellknoten erstellt und können ihn einfach zurückgeben. <br><br>  Dies ist eine großartige Implementierung, die jedoch zwei Hauptmängel aufweist.  Erstens ist es rekursiv.  Wenn sich herausstellt, dass der gewünschte Weg aus mehr als tausend Sprüngen besteht, fliegen wir mit einer Panne aus.  Dies ist natürlich unwahrscheinlich, aber wenn für einen langfristigen Dienst etwas inakzeptabel ist, ist dies ein Fehler.  Zweitens hat die Antwort, selbst wenn wir sie erfolgreich abschließen, einige unerwünschte Eigenschaften. <br><br>  Ich habe eigentlich schon am Anfang des Beitrags einen Hinweis gegeben.  Haben Sie bemerkt, wie Google die Conversion-Rate von <code>1.0739e-17</code> , aber meine manuelle Berechnung ergibt <code>1.0737e-17</code> ?  Es stellt sich heraus, dass all diese Gleitkomma-Multiplikationen dazu führen, dass man bereits daran denkt, den Fehler zu verbreiten.  Es gibt zu viele Nuancen für diesen Artikel, aber unter dem Strich müssen Sie die Gleitkomma-Multiplikation minimieren, um Fehler zu vermeiden, die sich ansammeln und Probleme verursachen. <br><br>  DFS ist ein großartiger Suchalgorithmus.  Wenn eine Lösung existiert, wird sie gefunden.  Aber ihm fehlt eine Schlüsseleigenschaft: Er findet nicht unbedingt den kürzesten Weg.  Dies ist für uns wichtig, da ein kürzerer Pfad weniger Sprünge und weniger Fehler aufgrund von Gleitkomma-Multiplikationen bedeutet.  Um das Problem zu lösen, wenden wir uns an BFS. <br><br><h2>  Teil 2. BFS-Lösung </h2><br>  Wenn ein Kandidat zu diesem Zeitpunkt eine rekursive DFS-Lösung erfolgreich implementiert und damit aufhört, gebe ich normalerweise zumindest eine schwache Empfehlung zur Einstellung dieses Kandidaten.  Er verstand das Problem, wählte den geeigneten Rahmen und implementierte eine funktionierende Lösung.  Dies ist eine naive Entscheidung, daher bestehe ich nicht darauf, ihn einzustellen, aber wenn er mit anderen Interviews gut zurechtkommt, werde ich nicht empfehlen, dies abzulehnen. <br><br>  Dies ist es wert, wiederholt zu werden: Schreiben Sie im Zweifelsfall eine naive Lösung!  Auch wenn es nicht ganz optimal ist, ist das Vorhandensein von Code auf der Platine bereits eine Errungenschaft, und oft kann die richtige Lösung auf ihrer Grundlage gefunden werden.  Ich werde anders sagen: Niemals für nichts arbeiten.  Höchstwahrscheinlich haben Sie an eine naive Lösung gedacht, wollten sie aber nicht anbieten, weil Sie wissen, dass sie nicht optimal ist.  Wenn Sie jetzt bereit sind, die beste Lösung zu finden, ist das in Ordnung. Wenn nicht, zeichnen Sie die erzielten Fortschritte auf, bevor Sie mit komplexeren Dingen fortfahren. <br><br>  Lassen Sie uns von nun an über die Verbesserungen des Algorithmus sprechen.  Die Hauptnachteile einer rekursiven DFS-Lösung bestehen darin, dass sie rekursiv ist und die Anzahl der Multiplikationen nicht minimiert.  Wie wir bald sehen werden, minimiert BFS die Anzahl der Multiplikationen und es ist auch sehr schwierig, sie rekursiv zu implementieren.  Leider müssen wir die rekursive DFA-Lösung aufgeben, da wir den Code zur Verbesserung vollständig neu schreiben müssen. <br><br>  Ohne weiteres präsentiere ich einen iterativen Ansatz basierend auf BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Diese Implementierung unterscheidet sich funktional stark von der vorherigen, aber wenn Sie genau hinschauen, funktioniert sie mit einer wesentlichen Änderung ungefähr gleich: Während rekursives DFS den Status der weiteren Route im Aufrufstapel speichert und den LIFO-Stapel effektiv implementiert, speichert die iterative Lösung ihn in der Warteschlange FIFO <br><br>  Dies impliziert die Eigenschaft "kürzester Weg / geringste Anzahl von Multiplikationen".  Wir besuchen Knoten in der Reihenfolge, in der sie auftreten, und auf diese Weise erhalten wir Generationen von Knoten.  Der erste Knoten fügt seine Nachbarn ein, und dann besuchen wir diese Nachbarn der Reihe nach und halten ihre Nachbarn die ganze Zeit fest und so weiter.  Die Eigenschaft des kürzesten Pfades ergibt sich aus der Tatsache, dass die Knoten in der Reihenfolge ihrer Entfernung von der Quelle besucht werden.  Wenn wir also auf ein Ziel stoßen, wissen wir, dass es keine frühere Generation gibt, die dazu führen könnte. <br><br>  In diesem Moment sind wir <i>fast</i> fertig.  Zuerst müssen Sie einige Fragen beantworten, und sie sind gezwungen, zur ursprünglichen Formulierung des Problems zurückzukehren. <br><br>  Erstens, das Trivialste, wenn die ursprüngliche Einheit nicht existiert?  Das heißt, wir können den Knoten mit dem angegebenen Namen nicht finden.  In der Praxis müssen Sie die Zeichenfolgen normalisieren, damit Pound, Pound und lb auf denselben "Pound" -Knoten (oder eine andere kanonische Darstellung) zeigen. Dies geht jedoch über den Rahmen unserer Frage hinaus. <br><br>  Zweitens, was ist, wenn zwischen den beiden Einheiten keine Umrechnung erfolgt?  Denken Sie daran, dass es in den Anfangsdaten nur Umrechnungen zwischen Einheiten gibt und es keine Hinweise darauf gibt, ob es möglich ist, eine andere von einer bestimmten Einheit zu erhalten.  Dies läuft darauf hinaus, dass Transformationen und Pfade direkt gleichwertig sind. Wenn also kein Pfad zwischen zwei Knoten vorhanden ist, gibt es keine Transformation.  In der Praxis erhalten Sie nicht verwandte Einheiteninseln: eine für Entfernungen, eine für Gewichte, eine für Währungen usw. <br><br>  Wenn Sie sich die obige Grafik genauer ansehen, stellt sich heraus, dass Sie mit dieser Lösung nicht zwischen Händen und Lichtjahren konvertieren können.  Die Richtung der Verbindungen zwischen Knoten bedeutet, dass es keinen Weg von Hand zu Lichtjahren gibt.  Dies ist jedoch recht einfach zu beheben, da die Transformationen umgekehrt werden können.  Wir können unseren Graphinitialisierungscode wie folgt ändern: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph. Note we insert its inverse also.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dest <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[dest] = {} self.graph[dest][orig] = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / rate</code> </pre> <br><h2>  Teil 3. Bewertung </h2><br>  Fertig!  Wenn der Kandidat diesen Punkt erreicht hat, werde ich ihn höchstwahrscheinlich zur Einstellung empfehlen.  Wenn Sie Informatik studiert oder einen Kurs in Algorithmen belegt haben, fragen Sie sich vielleicht: "Reicht das wirklich aus, um ein Interview mit diesem Typen zu bekommen?", Worauf ich antworten werde: "Im Wesentlichen ja." <br><br>  Bevor Sie entscheiden, dass die Frage zu einfach ist, schauen wir uns an, was ein Kandidat tun muss, um diesen Punkt zu erreichen: <br><br><ul><li>  Verstehe die Frage <br></li><li>  Erstellen Sie ein Netzwerk von Transformationen in Form eines Diagramms <br></li><li>  Verstehen Sie, dass die Koeffizienten mit den Kanten des Diagramms verglichen werden können <br></li><li>  Sehen Sie die Möglichkeit, Suchalgorithmen zu verwenden, um dies zu erreichen. <br></li><li>  Wählen Sie Ihren bevorzugten Algorithmus und ändern Sie ihn, um die Gewinnchancen zu verfolgen <br></li><li>  Wenn er DFS als naive Lösung implementiert hat, erkennen Sie seine Schwächen. <br></li><li>  Implementieren Sie BFS <br></li><li>  Um zurückzutreten und Extremfälle zu untersuchen: <br><ul><li>  Was ist, wenn wir nach einem Knoten gefragt werden, der nicht existiert? <br></li><li>  Was ist, wenn der Umrechnungsfaktor nicht vorhanden ist? </li></ul></li><li>  Erkennen Sie, dass inverse Transformationen möglich und wahrscheinlich notwendig sind </li></ul><br>  Diese Frage ist einfacher als die vorherigen, aber auch schwierig.  Wie bei allen vorherigen Fragen muss der Kandidat einen mentalen Sprung von einer abstrakt formulierten Frage zu einem Algorithmus oder einer Datenstruktur machen, die den Weg zu einer Lösung ebnet.  Das einzige ist, dass der endgültige Algorithmus weniger fortgeschritten ist als in anderen Fragen.  Außerhalb dieses algorithmischen Materials gelten die gleichen Anforderungen, insbesondere in Bezug auf Extremfälle und Korrektheit. <br><br>  "Aber warte!" Sie können fragen.  - Ist Google nicht besessen von der Komplexität der Laufzeit?  Sie haben nicht einmal nach der zeitlichen oder räumlichen Komplexität dieses Problems gefragt.  Ach was!"  Sie können auch fragen: "Warten Sie eine Minute, Sie gaben die Bewertung" sehr zu empfehlen zu mieten "?  Wie bekomme ich es? "  Beides sehr gute Fragen.  Dies bringt uns zu unserer letzten zusätzlichen Bonusrunde ... <br><br><h2>  Teil 4. Kann man es besser machen? </h2><br>  An dieser Stelle möchte ich dem Kandidaten zu einer guten Antwort gratulieren und klarstellen, dass alles weitere nur ein Bonus ist.  Wenn der Druck verschwindet, können wir anfangen zu schaffen. <br><br>  Was ist die Schwierigkeit, BFS auszuführen?  Im schlimmsten Fall müssen wir jeden einzelnen Knoten und jede einzelne Kante berücksichtigen, was eine lineare Komplexität <code>O(N+E)</code> ergibt.  Dies kommt zu der gleichen Komplexität der <code>O(N+E)</code> -Graphenkonstruktion hinzu.  Für eine Suchmaschine ist dies wahrscheinlich gut: Tausend Maßeinheiten reichen für die meisten vernünftigen Anwendungen aus, und eine Speichersuche für jede Abfrage ist keine Überlastung. <br><br>  Man kann es jedoch besser machen.  Überlegen Sie zur Motivation, wie dieser Code in die Suchzeichenfolge eingefügt wird.  Umrechnungen einiger nicht standardmäßiger Einheiten sind etwas häufiger, daher werden wir sie immer wieder berechnen.  Jedes Mal, wenn eine Suche durchgeführt wird, werden Zwischenwerte berechnet und so weiter. <br><br>  Es wird oft empfohlen, die Berechnungsergebnisse einfach zwischenzuspeichern.  Wenn eine Einheitenumrechnung berechnet wird, können wir immer nur eine Kante zwischen den beiden Umrechnungen hinzufügen.  Als Bonus erhalten wir die inverse Transformation und das kostenlos!  Bist du fertig <br><br>  Dies gibt uns zwar eine asymptotisch konstante Suchzeit, kostet jedoch die Speicherung zusätzlicher Kanten.  Dies wird tatsächlich ziemlich teuer: Im Laufe der Zeit werden wir uns um einen vollständigen Graphen bemühen, da alle Transformationspaare nach und nach berechnet und gespeichert werden.  Die Anzahl der möglichen Kanten im Diagramm ist das halbe Quadrat der Anzahl der Knoten. Für tausend Knoten benötigen wir also eine halbe Million Kanten.  Für zehntausend Knoten, ungefähr fünfzig Millionen usw. <br><br>  Über den Rahmen der Suchmaschine hinaus streben wir für eine Grafik von einer Million Knoten eine halbe Billion Kanten an.  Es ist einfach unangemessen, diesen Betrag zu speichern, und wir verbringen Zeit damit, Kanten in das Diagramm einzufügen.  Wir müssen es besser machen. <br><br>  Glücklicherweise gibt es eine Möglichkeit, eine konstante Zeit für die Suche nach Koeffizienten ohne quadratisches Raumwachstum zu erreichen.  Tatsächlich ist fast alles, was wir brauchen, direkt vor unserer Nase. <br><br><h2>  Teil 4. Konstante Zeit </h2><br>  Das vollständige Caching ist also tatsächlich nahe an der optimalen Lösung.  Bei diesem Ansatz erhalten wir (letztendlich) Kanten zwischen allen Knoten, dh unsere Transformation wird darauf reduziert, eine Kante zu finden.  Aber ist es wirklich notwendig, Conversions von jedem Knoten zu jedem Knoten zu speichern?  Was ist, wenn wir nur die Umrechnungsfaktoren von <i>einem</i> Knoten auf alle anderen speichern? <br><br>  Schauen Sie sich die BFS-Lösung noch einmal an: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Mal sehen, was hier passiert: Wir beginnen am Quellknoten und berechnen für jeden Knoten, auf den wir stoßen, den Umrechnungskoeffizienten von der Quelle zu diesem Knoten.  Sobald wir am Ziel ankommen, geben wir den Koeffizienten zwischen dem Start- und dem Endpunkt zurück und verwerfen die Zwischenkoeffizienten. <br><br>  Diese Zwischenverhältnisse sind entscheidend.  Aber was ist, wenn wir sie nicht wegwerfen?  Was ist, wenn wir sie stattdessen aufschreiben?  Alle komplexesten und unverständlichsten Suchvorgänge werden einfach: Um das Verhältnis von A zu B zu ermitteln, müssen Sie zuerst das Verhältnis von X zu B ermitteln und dann durch das Verhältnis von X zu A dividieren. Fertig!  Optisch sieht es so aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/284/a08/b6c/284a08b6cb6ef95af556422fa3c604f3.png"><br>  <i><font color="gray">Beachten Sie, dass zwischen zwei beliebigen Knoten nicht mehr als zwei Kanten liegen</font></i> <br><br>  Es stellt sich heraus, dass wir zur Berechnung dieser Tabelle die BFS-Lösung fast nicht ändern müssen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_conversions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conversions_bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, conversions)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() conversions[node] = (start, rate_from_origin) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: to_visit.append((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions conversions = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.get_nodes(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: conversions_bfs(graph, node, conversions) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions</code> </pre> <br>  Die Transformationsstruktur wird durch ein Wörterbuch der Einheit A in zwei Werten dargestellt: der Wurzel für die zugehörige Komponente der Einheit A und dem Umrechnungskoeffizienten zwischen der Wurzeleinheit und der Einheit A. Da wir bei jedem Besuch eine Einheit in dieses Wörterbuch einfügen, können wir den Schlüsselraum dieses Wörterbuchs als eine Reihe von Besuchen verwenden, anstatt ihn zu verwenden eine spezielle Reihe von Besuchen.  Beachten Sie, dass wir keinen endgültigen Knoten haben und stattdessen die Knoten durchlaufen, bis wir fertig sind. <br><br>  Außerhalb dieses BFS gibt es eine Hilfsfunktion, die über Knoten in einem Diagramm iteriert.  Immer wenn es auf einen Knoten außerhalb des Übersetzungswörterbuchs trifft, startet es BFS ab diesem Knoten.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somit ist garantiert, dass wir alle Knoten in ihre zugehörigen Komponenten zusammenfassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Beziehung zwischen den Einheiten finden müssen, verwenden wir einfach die gerade berechnete Transformationsstruktur:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(conversions, start, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Given a conversion structure, performs a constant-time conversion'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: start_root, start_rate = conversions[start] end_root, end_rate = conversions[end] <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_root != end_root: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end_rate / start_rate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Situation „Es gibt keine solche Einheit“ wird behandelt, indem beim Zugriff auf die Struktur von Transformationen auf eine Ausnahme gewartet wird. </font><font style="vertical-align: inherit;">Die Situation „Es gibt keine solchen Transformationen“ wird durch Vergleichen der Wurzeln zweier Größen behandelt: Wenn sie unterschiedliche Wurzeln haben, werden sie durch zwei verschiedene BFS-Aufrufe erkannt, dh sie befinden sich in zwei verschiedenen verbundenen Komponenten, und daher gibt es keinen Weg zwischen ihnen. </font><font style="vertical-align: inherit;">Schließlich führen wir die Konvertierung durch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So! </font><font style="vertical-align: inherit;">Die aktuelle Lösung weist eine Vorverarbeitungskomplexität auf</font></font><code>O(V+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nicht schlechter als frühere Lösungen), aber sie sucht auch mit konstanter Zeit. Theoretisch verdoppeln wir den Platzbedarf, aber meistens benötigen wir das ursprüngliche Diagramm nicht mehr, sodass wir es einfach löschen und nur dieses verwenden können. Darüber hinaus ist die räumliche Komplexität tatsächlich geringer als beim ursprünglichen Diagramm: Sie erfordert, </font></font><code>O(V+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weil alle Kanten und Eckpunkte gespeichert werden müssen, und diese Struktur erfordert nur, </font></font><code>O(V)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weil wir keine Kanten mehr benötigen.</font></font><br><br><h2>  Ergebnisse </h2><br>     ,   ,        ,  ,      -              .     -   ,         .   ,     . <br><br>         ( ,  , ,     ),          « ».    ,     :     ,       ,    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist sofort ein nützliches Signal. Ich kann verstehen, wenn eine Person keine fortgeschrittenen oder undurchsichtigen Datenstrukturen kennt, weil wir ehrlich sind, müssen Sie selten disjunkte Mengen implementieren. Grafiken sind jedoch eine grundlegende Datenstruktur und werden im Rahmen fast aller Einführungskurse zu diesem Thema vermittelt. Wenn der Kandidat Schwierigkeiten hat, sie zu verstehen, oder sie nicht einfach anwenden kann, wird es für ihn wahrscheinlich schwierig sein, bei Google erfolgreich zu sein (zumindest in meiner Zeit dort weiß ich heute nicht, wie).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits war die Wahl des Algorithmus keine besonders nützliche Signalquelle. Leute, die die Framing-Phase durchlaufen haben, sind normalerweise ohne Probleme zum Algorithmus gekommen. Ich vermute, dass dies auf die Tatsache zurückzuführen ist, dass Suchalgorithmen fast immer zusammen mit den Diagrammen selbst gelehrt werden. Wenn also jemand mit einem vertraut ist, kennt er den anderen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Implementierung war nicht einfach. Viele Leute hatten keine Probleme mit der rekursiven Implementierung von DFS, aber wie oben erwähnt, ist diese Implementierung nicht für die Produktion geeignet. Zu meiner Überraschung scheinen die iterativen Implementierungen von BFS und DFS den Menschen nicht sehr vertraut zu sein, und selbst nach offensichtlichen Hinweisen schwebten sie oft im Thema.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meiner Meinung nach hat mir jeder, der die Implementierungsphase durchlaufen hat, bereits die Empfehlung „Einstellung“ eingebracht, und die Diskussion über die konstante Vorlaufzeit ist einfach ein Bonus. </font><font style="vertical-align: inherit;">Obwohl wir uns die Lösung im Artikel ausführlich angesehen haben, ist in der Praxis eine mündliche Diskussion anstelle des Schreibens von Code in der Regel produktiver. </font><font style="vertical-align: inherit;">Nur sehr wenige Kandidaten konnten sofort eine Entscheidung treffen. </font><font style="vertical-align: inherit;">Ich musste oft wesentliche Hinweise geben, und selbst dann konnten viele Leute ihn nicht finden. </font><font style="vertical-align: inherit;">Dies ist normal: Wie erwartet ist es schwierig, eine sehr empfohlene Bewertung zu erhalten.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aber warte, das ist noch nicht alles! </font></font></h2><br>  ,    ,        ,     ,      .     : <br><br> -, :     ,   ,        .  ,     ,    .   ,         - ,  -               .     ,       ,            . <br><br> -,    ,        ,    .       —  :  —  ,    A  B   —    /   .            :  , ,    ,    ,     ,   .      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endlich ein echtes Juwel: Einige Einheiten werden als Kombination verschiedener Basiseinheiten ausgedrückt. Beispielsweise wird ein Watt im SI-System als kg • m² / s³ definiert. Die letzte Aufgabe besteht darin, dieses System zu erweitern, um die Konvertierung zwischen diesen Einheiten zu unterstützen, wobei nur die Definitionen der grundlegenden SI-Einheiten berücksichtigt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Fragen haben, können Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mich gerne über reddit kontaktieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Fazit </h2><br>        ,  ,      .      :     ,      ,       ,        . ,   ,  ,   ,     :            ,        .   ,      ,  ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, Sie fanden diesen Artikel hilfreich. </font><font style="vertical-align: inherit;">Ich verstehe, dass es mit Algorithmen möglicherweise nicht so viele Abenteuer gibt wie in einigen früheren Artikeln. </font><font style="vertical-align: inherit;">Bei den Interviews mit Entwicklern ist es üblich, Algorithmen ausführlich zu diskutieren. </font><font style="vertical-align: inherit;">Die Wahrheit ist jedoch, dass erhebliche Schwierigkeiten auftreten, wenn selbst eine einfache, bekannte Methode angewendet wird. </font><font style="vertical-align: inherit;">Der gesamte Code befindet sich im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository dieser Artikelserie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467371/">https://habr.com/ru/post/de467371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467359/index.html">PVS-Studio geht in die Cloud: Azure DevOps</a></li>
<li><a href="../de467361/index.html">Wir haben die Delegierung in JavaScript vergessen. Ereignisdelegation reagieren</a></li>
<li><a href="../de467363/index.html">Verwenden benutzerdefinierter Verlustfunktionen und Lernen von Qualitätsmetriken in Keras</a></li>
<li><a href="../de467365/index.html">Relais zur Überwachung der Wohnspannung</a></li>
<li><a href="../de467369/index.html">RubyRussia 2019. Mikhail Pronyakin: Ist Ruby sicher?</a></li>
<li><a href="../de467375/index.html">Customer Experience Management - was ist das?</a></li>
<li><a href="../de467377/index.html">Drei in Folge: Top 10 Berichte von Mobius 2019 Piter</a></li>
<li><a href="../de467381/index.html">Mehrstöckige LEDs, intelligente Lichter und Glühbirnen für 18 Rubel</a></li>
<li><a href="../de467383/index.html">"Der Manager muss weiter codieren": Interview mit Stephen Chin</a></li>
<li><a href="../de467385/index.html">Eine Auswahl psychologischer und atypischer technischer Fragen aus Java-Entwicklerinterviews</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>