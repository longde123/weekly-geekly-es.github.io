<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¢ üçô üèê Google Job Interview Parsing: Beziehungen finden ü§õüèª üïí üë©üèæ‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Willkommen zum n√§chsten Artikel in einer Reihe von R√§tseln, die ich bei Google-Interviews gefragt habe, bevor sie nach dem Leck verboten wurden. Seitd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Google Job Interview Parsing: Beziehungen finden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467371/"><img src="https://habrastorage.org/getpro/habr/post_images/915/39d/3b3/91539d3b3be71056861dc65e18921c88.png"><br><br>  Willkommen zum n√§chsten Artikel in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von</a> R√§tseln, die ich bei Google-Interviews gefragt habe, bevor sie nach dem Leck verboten wurden.  Seitdem habe ich aufgeh√∂rt, als Softwareentwickler bei Google zu arbeiten, und bin zum Entwicklungsleiter bei Reddit gewechselt, aber ich habe immer noch ein paar gro√üartige Themen.  Bisher haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dynamische Programmierung</a> untersucht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und Matrizen zur Leistungsf√§higkeit</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synonymie von Abfragen erhoben</a> .  Diesmal eine v√∂llig neue Frage. <br><a name="habracut"></a><br>  Aber zuerst zwei Punkte.  Zun√§chst einmal war die Arbeit bei Reddit gro√üartig.  In den letzten acht Monaten habe ich das neue Team f√ºr Anzeigenrelevanz aufgebaut und geleitet und ein neues Entwicklungsb√ºro in New York eingerichtet.  Egal wie lustig es auch sein mag, leider stellte ich fest, dass ich bis vor kurzem keine Zeit oder Energie mehr f√ºr einen Blog hatte.  Ich f√ºrchte, ich habe diese Serie ein bisschen aufgegeben.  Entschuldigen sie f√ºr die Verz√∂gerung. <br><br>  Zweitens, wenn Sie den Artikeln gefolgt sind, k√∂nnten Sie nach der letzten Ausgabe denken, dass ich anfangen w√ºrde, mich mit den synonymischen Optionen der Abfragen zu befassen.  Obwohl ich irgendwann darauf zur√ºckkommen m√∂chte, muss ich zugeben, dass ich aufgrund eines Arbeitswechsels das Interesse an diesem Problem verloren habe und mich bisher entschlossen habe, es zu verschieben.  Bleiben Sie jedoch in Kontakt!  Ich schulde mir etwas und beabsichtige, es zur√ºckzugeben.  Nur ein bisschen sp√§ter ... <br><br>  <i>Kurzer Haftungsausschluss: Obwohl das Befragen von Kandidaten eine meiner beruflichen Aufgaben ist, pr√§sentiert dieser Blog meine pers√∂nlichen Beobachtungen, pers√∂nlichen Geschichten und pers√∂nlichen Meinungen.</i>  <i>Bitte nehmen Sie dies nicht f√ºr eine offizielle Erkl√§rung von Google, Alphabet, Reddit oder einer anderen Person oder Organisation.</i> <br><br><h2>  Suchen Sie nach einer neuen Frage </h2><br>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel habe</a> ich eine meiner Lieblingsfragen beschrieben, die ich lange Zeit vor dem unvermeidlichen Leck verwendet habe.  Die vorherigen Fragen waren aus theoretischer Sicht faszinierend, aber ich wollte ein Problem ausw√§hlen, das f√ºr Google als Unternehmen etwas relevanter ist.  Als diese Frage verboten wurde, wollte ich unter Ber√ºcksichtigung der neuen Einschr√§nkung einen Ersatz finden: um die Frage <i>einfacher</i> zu machen. <br><br>  Dies mag angesichts des ber√ºchtigten Interviewprozesses bei Google etwas √ºberraschend erscheinen.  Aber zu dieser Zeit machte ein einfacheres Problem Sinn.  Meine Argumentation bestand aus zwei Teilen.  Das erste ist pragmatisch: Die Kandidaten haben fr√ºhere Fragen trotz zahlreicher Hinweise und Vereinfachungen normalerweise nicht sehr gut gemeistert, und ich war mir nicht immer ganz sicher, warum.  Die zweite theoretische: Der Interviewprozess sollte die Kandidaten in die Kategorien ‚Äûes lohnt sich, eingestellt zu werden‚Äú und ‚Äûes lohnt sich nicht, eingestellt zu werden‚Äú einteilen, und ich war gespannt, ob dies mit der Frage etwas einfacher gemacht werden k√∂nnte. <br><br>  Bevor ich diese beiden Punkte klarstelle, m√∂chte ich darauf hinweisen, was sie <i>nicht</i> bedeuten.  "Ich bin nicht immer sicher, warum eine Person Probleme hat" bedeutet nicht, dass die Fragen nutzlos sind und dass ich das Interview aus diesem Grund vereinfachen wollte.  Selbst die schwierigste Frage haben viele gut gemeistert.  Ich meine, wenn Kandidaten Probleme hatten, war es f√ºr mich schwer zu verstehen, was ihnen fehlte. <br><br>  Gute Interviews geben ein umfassendes Bild der St√§rken und Schw√§chen des Kandidaten.  Es reicht nicht aus, wenn das Einstellungskomitee einfach sagt, dass es ‚Äûgescheitert‚Äú ist: Das Komitee bestimmt, ob der Kandidat unternehmensspezifische Eigenschaften hat, die er sucht.  Ebenso helfen die Worte ‚Äûer ist cool‚Äú dem Ausschuss nicht, sich f√ºr einen Kandidaten zu entscheiden, der in einigen Bereichen stark, in anderen jedoch zweifelhaft ist.  Ich habe festgestellt, dass komplexere Themen die Kandidaten zu oft in diese beiden Kategorien einteilen.  In diesem Licht bedeutet "Ich bin nicht immer sicher, warum eine Person Probleme hat", "die Unf√§higkeit, in diesem Bereich voranzukommen, zeichnet an sich kein Bild der F√§higkeiten dieses Kandidaten." <br><br>  Die Einstufung von Kandidaten als ‚Äûeinstellungsw√ºrdig‚Äú und ‚Äûnicht einstellungsw√ºrdig‚Äú <i>bedeutet nicht</i> , dass der Interviewprozess dumme Kandidaten von intelligenten trennen sollte.  Ich kann mich nicht an einen einzigen Kandidaten erinnern, der nicht klug, talentiert und motiviert war.  Viele kamen von exzellenten Universit√§ten, und der Rest war eindeutig √§u√üerst motiviert.  Das Durchlaufen von Telefoninterviews ist bereits ein gutes Sieb, und selbst das Ablehnen in dieser Phase ist kein Zeichen f√ºr mangelnde F√§higkeiten. <br><br>  Ich <i>kann</i> mich <i>jedoch</i> an viele erinnern, die nicht ausreichend auf das Interview vorbereitet waren oder zu langsam arbeiteten oder zu viel Aufsicht ben√∂tigten, um das Problem zu l√∂sen, oder auf unklare Weise kommunizierten oder ihre Ideen nicht in Code √ºbersetzen konnten oder eine Position innehatten, die einfach nicht f√ºhren w√ºrde Sein Erfolg auf lange Sicht usw. Die Definition von ‚Äûeine Einstellung wert‚Äú ist vage und variiert je nach Unternehmen. Der Interviewprozess besteht darin, festzustellen, ob jeder Kandidat die Anforderungen eines bestimmten Unternehmens erf√ºllt. <br><br>  Ich habe viele reddit-Kommentare gelesen, in denen ich mich √ºber zu komplexe Interviewfragen beschwert habe.  Ich war neugierig, ob es noch m√∂glich ist, eine w√ºrdige / unw√ºrdige Empfehlung f√ºr eine einfachere Aufgabe abzugeben.  Ich vermutete, dass dies ein n√ºtzliches Signal geben w√ºrde, ohne die Nerven des Kandidaten unn√∂tig zu schreien.  Ich werde Ihnen am Ende des Artikels von meinen Schlussfolgerungen erz√§hlen ... <br><br>  Mit diesen Gedanken suchte ich nach einer neuen Frage.  In einer idealen Welt ist diese Frage einfach genug, um sie in 45 Minuten zu l√∂sen, aber mit zus√§tzlichen Fragen, damit leistungsf√§higere Kandidaten ihre F√§higkeiten unter Beweis stellen.  Die Implementierung sollte auch kompakt sein, da viele Kandidaten immer noch an die Tafel schreiben.  Ein gro√ües Plus, wenn das Thema irgendwie mit Google-Produkten zusammenh√§ngt. <br><br>  Schlie√ülich entschied ich mich f√ºr eine Frage, die ein wunderbarer Googler sorgf√§ltig beschrieben und in unsere Fragendatenbank eingef√ºgt hatte.  Jetzt habe ich mich mit ehemaligen Kollegen beraten und sichergestellt, dass die Frage noch verboten ist, so dass Sie beim Interview definitiv nicht gefragt werden.  Ich pr√§sentiere es in der Form, in der es mir am effektivsten erscheint, mit einer Entschuldigung an den urspr√ºnglichen Autor. <br><br><h2>  Frage </h2><br>  Sprechen Sie √ºber Entfernungsmessungen.  <i>Hand</i> ist eine 4-Zoll-Ma√üeinheit, die im englischsprachigen Raum h√§ufig zur Messung der Pferdeh√∂he verwendet wird.  <i>Ein Lichtjahr</i> ist eine weitere Ma√üeinheit, die der Entfernung entspricht, die ein Lichtteilchen (oder eine Welle?) In einer bestimmten Anzahl von Sekunden zur√ºcklegt, ungef√§hr gleich einem Erdjahr.  Auf den ersten Blick haben sie wenig miteinander zu tun, au√üer dass sie zur Entfernungsmessung verwendet werden.  Es stellt sich jedoch heraus, dass Google sie ganz einfach konvertieren kann: <br><br><img src="https://habrastorage.org/webt/uu/8z/y-/uu8zy-po4rpuvr61dtewmyhjns0.png"><br><br>  Dies mag offensichtlich erscheinen: Am Ende messen beide die Entfernung, sodass klar ist, dass es eine Transformation gibt.  Aber wenn Sie dar√ºber nachdenken, ist es etwas seltsam: Wie haben sie diese Conversion-Rate berechnet?  Es ist klar, dass niemand wirklich die Anzahl der H√§nde in einem Lichtjahr gez√§hlt hat.  Eigentlich m√ºssen Sie dies nicht direkt √ºbernehmen.  Sie k√∂nnen einfach bekannte Konvertierungen verwenden: <br><br><ul><li>  <i>1 Hand</i> = <i>4 Zoll</i> <br></li><li>  <i>4 Zoll</i> = <i>0,33333 Fu√ü</i> <br></li><li>  <i>0,33333 ft</i> = <i>6,3125e - 5 Meilen</i> <br></li><li>  <i>6,3125e - 5 Meilen</i> = <i>1,0737e - 17 Lichtjahre</i> </li></ul><br>  Ziel der Aufgabe ist es, ein System zu entwickeln, das diese Transformation durchf√ºhrt.  Insbesondere: <br><br><blockquote>  Am Eingang haben Sie eine Liste von Umrechnungsfaktoren (in der von Ihnen gew√§hlten Sprache formatiert) in Form einer Reihe von anf√§nglichen Ma√üeinheiten, endg√ºltigen Einheiten und Faktoren, zum Beispiel: <br><br><pre>  ft 12
 Fu√ühof 0,3333333
 usw. </pre><br>  Damit ORIGIN * MULTIPLIER = DESTINATION.  Entwickeln Sie einen Algorithmus, der zwei beliebige Einheitswerte verwendet und den Umrechnungsfaktor zwischen ihnen zur√ºckgibt. </blockquote><br><h2>  Die Diskussion </h2><br>  Ich mag dieses Problem, weil es eine intuitive und offensichtliche Antwort hat: Konvertieren Sie einfach von einer Einheit zur anderen und dann zur n√§chsten, bis Sie das Ziel gefunden haben!  Ich kann mich nicht an einen einzelnen Kandidaten erinnern, der auf dieses Problem gesto√üen ist und v√∂llig verwirrt war, wie man es l√∂st.  Dies passt gut zu der Anforderung eines ‚Äûeinfacheren‚Äú Problems, da die vorherigen normalerweise lange Studien und √úberlegungen erforderten, bevor zumindest ein grundlegender L√∂sungsansatz gefunden wurde. <br><br>  Trotzdem haben viele Kandidaten ihre Intuition als funktionierende L√∂sung ohne offensichtliche Hinweise nicht verwirklicht.  Einer der Vorteile dieser Frage besteht darin, dass sie die F√§higkeit des Kandidaten testet, das Problem so zu formulieren (Framing zu erstellen), dass es sich f√ºr Analyse und Codierung eignet.  Wie wir sehen werden, gibt es hier eine sehr interessante Erweiterung, die einen neuen konzeptionellen Sprung erfordert. <br><br>  F√ºr den Kontext ist Framing der Vorgang des √úbersetzens eines Problems mit einer nicht offensichtlichen L√∂sung in ein √§quivalentes Problem, bei dem die L√∂sung auf nat√ºrliche Weise abgeleitet wird.  Wenn dies v√∂llig abstrakt und uneinnehmbar klingt, tut es mir leid, aber es ist.  Ich werde erkl√§ren, was ich meine, wenn ich die erste L√∂sung f√ºr dieses Problem vorstelle.  Der erste Teil der L√∂sung wird eine √úbung zur Entwicklung und Anwendung von algorithmischem Wissen sein.  Der zweite Teil wird eine √úbung zur Manipulation dieses Wissens sein, um zu einer neuen und nicht offensichtlichen Optimierung zu gelangen. <br><br><h2>  Teil 0. Intuition </h2><br>  Bevor wir tiefer graben, wollen wir die ‚Äûoffensichtliche‚Äú L√∂sung vollst√§ndig untersuchen.  Die meisten erforderlichen Konvertierungen sind einfach und unkompliziert.  Jeder Amerikaner, der au√üerhalb der USA gereist ist, wei√ü, dass der gr√∂√üte Teil der Welt die mysteri√∂se Einheit ‚ÄûKilometer‚Äú verwendet, um Entfernungen zu messen.  Zum Konvertieren m√ºssen Sie nur die Anzahl der Meilen mit etwa 1,6 multiplizieren. <br><br>  Wir sind fast unser ganzes Leben lang auf solche Dinge gesto√üen.  F√ºr die meisten Einheiten gibt es bereits eine vorberechnete Umrechnung, sodass Sie sie nur in der entsprechenden Tabelle betrachten m√ºssen.  Wenn es jedoch keine direkte Konvertierung gibt (z. B. von H√§nden zu Lichtjahren), ist es sinnvoll, einen Konvertierungspfad wie oben angegeben zu erstellen: <br><br><ul><li>  <i>1 Hand</i> = <i>4 Zoll</i> <br></li><li>  <i>4 Zoll</i> = <i>0,33333 Fu√ü</i> <br></li><li>  <i>0,33333 ft</i> = <i>6,3125e - 5 Meilen</i> <br></li><li>  <i>6,3125e - 5 Meilen</i> = <i>1,0737e - 17 Lichtjahre</i> </li></ul><br>  Es war sehr einfach, ich habe mir gerade eine solche Transformation mit meiner Fantasie und einer Standard-Transformationstabelle ausgedacht!  Es bleiben jedoch einige Fragen offen.  Gibt es einen k√ºrzeren Weg?  Wie genau ist der Koeffizient?  Ist eine Konvertierung immer m√∂glich?  Ist es m√∂glich, es zu automatisieren?  Leider bricht hier der naive Ansatz zusammen. <br><br><h2>  Teil 1. Naive Entscheidung </h2><br>  Es ist sch√∂n, dass das Problem eine intuitive L√∂sung hat, aber tats√§chlich ist diese Einfachheit ein Hindernis f√ºr die L√∂sung des Problems.  Es gibt nichts Schwierigeres, als zu versuchen, auf neue Weise zu verstehen, was Sie bereits verstehen - nicht zuletzt, weil Sie oft weniger wissen, als Sie denken.  Stellen Sie sich zur Veranschaulichung vor, Sie w√§ren zu einem Interview gekommen - und Sie haben diese intuitive Methode im Kopf.  Es erlaubt jedoch nicht, eine Reihe wichtiger Probleme zu l√∂sen. <br><br>  Was <i>ist</i> zum Beispiel, wenn <i>keine Konvertierung erfolgt</i> ?  Der offensichtliche Ansatz sagt nichts aus, ist es wirklich m√∂glich, von einer Einheit zur anderen zu konvertieren.  Wenn sie mir tausend Umrechnungskurse geben, wird es f√ºr mich sehr schwierig sein festzustellen, ob dies im Prinzip m√∂glich ist.  Wenn ich gebeten werde, eine Konvertierung zwischen unbekannten (oder erfundenen) Einheiten eines <i>Zeigers</i> und eines <i>Sto√ües vorzunehmen</i> , habe ich keine Ahnung, wo ich anfangen soll.  Wie hilft hier ein intuitiver Ansatz? <br><br>  Ich muss zugeben, dass dies eine Art erfundenes Szenario ist, aber es gibt auch ein realistischeres.  Sie sehen, dass meine Erkl√§rung des Problems nur Entfernungseinheiten enth√§lt.  Dies geschieht absichtlich.  Was ist, wenn ich das System auffordere, von Zoll in Kilogramm umzurechnen?  Sowohl Sie als auch ich wissen, dass dies nicht m√∂glich ist, weil sie unterschiedliche Typen messen, aber die Eingabe sagt nichts √ºber den ‚ÄûTyp‚Äú aus, den jede Einheit misst. <br><br>  Hier erm√∂glicht eine sorgf√§ltige Formulierung der Frage starken Kandidaten, sich zu beweisen.  <i>Bevor</i> sie den Algorithmus entwickeln, denken sie √ºber die Extremf√§lle des Systems nach.  Und eine solche Erkl√§rung des Problems gibt ihnen absichtlich die M√∂glichkeit, mich zu fragen, ob wir verschiedene Einheiten √ºbersetzen werden.  Dies ist kein so gro√ües Problem, wenn es in einem fr√ºhen Stadium auftritt, aber es ist immer ein gutes Zeichen, wenn mich jemand im Voraus fragt: "Was soll das Programm zur√ºckgeben, wenn eine Konvertierung nicht m√∂glich ist?"  Wenn ich die Frage so stelle, bekomme ich eine Vorstellung von den F√§higkeiten des Kandidaten, bevor er mindestens eine Codezeile schreibt. <br><br>  <i>Diagrammansicht</i> <br><br>  Offensichtlich ist der naive Ansatz nicht geeignet, also m√ºssen wir uns √ºberlegen, wie wir eine solche Konvertierung durchf√ºhren k√∂nnen.  Die Antwort besteht darin, Einheiten als Grafik zu betrachten.  Dies ist der erste Sprung zum Verst√§ndnis, der zur L√∂sung dieses Problems erforderlich ist. <br><br>  Stellen Sie sich insbesondere vor, dass jede Einheit ein Knoten in einem Diagramm ist und es eine Kante von Knoten <code>A</code> zu Knoten <code>B</code> wenn <code>A</code> in <code>B</code> konvertiert werden kann: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc6/d25/89f/fc6d2589f8a9a411cec0d704e2ad644e.png"><br><br>  Die Kanten sind mit einer Conversion-Rate gekennzeichnet, mit der Sie <code>A</code> multiplizieren m√ºssen, um <code>B</code> zu erhalten <code>B</code> <br><br>  Ich hatte fast immer erwartet, dass der Kandidat einen solchen Rahmen finden w√ºrde, und gab ihm selten ernsthafte Hinweise.  Ich kann dem Kandidaten vergeben, der die L√∂sung des Problems der Verwendung disjunkter Mengen nicht bemerkt oder mit der linearen Algebra nicht allzu vertraut ist, um eine L√∂sung zu realisieren, die sich darauf reduziert, die Potenz der Adjazenzmatrix wieder zu erh√∂hen, aber Grafiken werden in jedem Lehrplan oder Programmierkurs unterrichtet.  Wenn der Kandidat nicht √ºber die entsprechenden Kenntnisse verf√ºgt, handelt es sich um ein Signal ‚ÄûKeine Einstellung‚Äú. <br><br>  <i>Auf jeden Fall</i> <br><br>  Eine Diagrammdarstellung reduziert die L√∂sung des klassischen Problems der Diagrammsuche.  Insbesondere sind hier zwei Algorithmen n√ºtzlich: Wide Search (BFS) und Deep Search (DFS).  Bei der Suche in der Breite untersuchen wir die Knoten nach ihrem Abstand vom Ursprung: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d45/4cb/15b/d454cb15b85c4ea9ce32e87623ed4115.png"><br>  <i><font color="gray">Dunklerer Blues bedeutet sp√§tere Generationen</font></i> <br><br>  Und bei der eingehenden Suche untersuchen wir die Knoten in der Reihenfolge, in der sie auftreten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/f4c/f1a/40bf4cf1ae3d89554505c031c4529559.png"><br><br>  <i><font color="gray">Dunklerer Blues bedeutet auch sp√§tere Generationen.</font></i>  <i><font color="gray">Bitte beachten Sie, dass wir nicht alle Websites besuchen</font></i> <br><br>  Jeder der Algorithmen bestimmt leicht, ob eine Konvertierung von einer Einheit in eine andere erfolgt. Es reicht aus, einfach die Grafik zu durchsuchen.  Wir starten von der Quelleneinheit und suchen, bis wir die Zieleinheit finden.  Wenn Sie Ihr Ziel nicht finden k√∂nnen (als w√ºrden Sie versuchen, Zoll in Kilogramm umzurechnen), wissen wir, dass es keinen Weg gibt. <br><br>  Aber warte, etwas fehlt.  Wir wollen nicht nach einem Weg suchen, wir wollen eine Conversion-Rate finden!  Hier muss der Kandidat den Sprung machen: Es stellt sich heraus, dass Sie jeden Suchalgorithmus √§ndern k√∂nnen, um die Conversion-Rate zu berechnen, indem Sie einfach den zus√§tzlichen Status speichern, w√§hrend Sie fortfahren.  Hier machen Illustrationen keinen Sinn mehr, also lasst uns direkt in den Code eintauchen. <br><br>  Zuerst m√ºssen Sie die Datenstruktur des Diagramms bestimmen, damit wir Folgendes verwenden: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateGraph</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rates)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Initialize the graph from an iterable of (start, end, rate) tuples.'</span></span> self.graph = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> orig, dest, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rates: self.add_conversion(orig, dest, rate) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of the nodes neighboring the given node.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph[node].items() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of all the nodes in the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph.keys()</code> </pre> <br>  Dann fangen wir mit DFS an.  Es gibt viele M√∂glichkeiten, es zu implementieren, aber die bei weitem h√§ufigste ist eine rekursive L√∂sung.  Beginnen wir damit: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__dfs_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end, rate_from_origin, visited)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: rate = __dfs_helper(rate_graph, unit, end, rate_from_origin * rate, visited) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __dfs_helper(rate_graph, node, end, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, set())</code> </pre> <br>  Kurz gesagt, dieser Algorithmus beginnt mit einem Knoten, iteriert √ºber seine Nachbarn und besucht jeden sofort, wobei die Funktion rekursiv aufgerufen wird.  Jeder Funktionsaufruf auf dem Stapel speichert den Status seiner eigenen Iteration. Wenn also ein rekursiver Besuch zur√ºckgegeben wird, setzt das √ºbergeordnete Element die Iteration sofort fort.  Wir vermeiden es, dieselbe Site erneut zu besuchen, indem wir bei allen Anrufen eine Reihe von besuchten Sites verwalten.  Wir berechnen den Koeffizienten auch, indem wir jedem Knoten und der Quelle einen Umrechnungsfaktor zuweisen.  Wenn wir also auf den Zielknoten / -block sto√üen, haben wir bereits den Konvertierungskoeffizienten aus dem Quellknoten erstellt und k√∂nnen ihn einfach zur√ºckgeben. <br><br>  Dies ist eine gro√üartige Implementierung, die jedoch zwei Hauptm√§ngel aufweist.  Erstens ist es rekursiv.  Wenn sich herausstellt, dass der gew√ºnschte Weg aus mehr als tausend Spr√ºngen besteht, fliegen wir mit einer Panne aus.  Dies ist nat√ºrlich unwahrscheinlich, aber wenn f√ºr einen langfristigen Dienst etwas inakzeptabel ist, ist dies ein Fehler.  Zweitens hat die Antwort, selbst wenn wir sie erfolgreich abschlie√üen, einige unerw√ºnschte Eigenschaften. <br><br>  Ich habe eigentlich schon am Anfang des Beitrags einen Hinweis gegeben.  Haben Sie bemerkt, wie Google die Conversion-Rate von <code>1.0739e-17</code> , aber meine manuelle Berechnung ergibt <code>1.0737e-17</code> ?  Es stellt sich heraus, dass all diese Gleitkomma-Multiplikationen dazu f√ºhren, dass man bereits daran denkt, den Fehler zu verbreiten.  Es gibt zu viele Nuancen f√ºr diesen Artikel, aber unter dem Strich m√ºssen Sie die Gleitkomma-Multiplikation minimieren, um Fehler zu vermeiden, die sich ansammeln und Probleme verursachen. <br><br>  DFS ist ein gro√üartiger Suchalgorithmus.  Wenn eine L√∂sung existiert, wird sie gefunden.  Aber ihm fehlt eine Schl√ºsseleigenschaft: Er findet nicht unbedingt den k√ºrzesten Weg.  Dies ist f√ºr uns wichtig, da ein k√ºrzerer Pfad weniger Spr√ºnge und weniger Fehler aufgrund von Gleitkomma-Multiplikationen bedeutet.  Um das Problem zu l√∂sen, wenden wir uns an BFS. <br><br><h2>  Teil 2. BFS-L√∂sung </h2><br>  Wenn ein Kandidat zu diesem Zeitpunkt eine rekursive DFS-L√∂sung erfolgreich implementiert und damit aufh√∂rt, gebe ich normalerweise zumindest eine schwache Empfehlung zur Einstellung dieses Kandidaten.  Er verstand das Problem, w√§hlte den geeigneten Rahmen und implementierte eine funktionierende L√∂sung.  Dies ist eine naive Entscheidung, daher bestehe ich nicht darauf, ihn einzustellen, aber wenn er mit anderen Interviews gut zurechtkommt, werde ich nicht empfehlen, dies abzulehnen. <br><br>  Dies ist es wert, wiederholt zu werden: Schreiben Sie im Zweifelsfall eine naive L√∂sung!  Auch wenn es nicht ganz optimal ist, ist das Vorhandensein von Code auf der Platine bereits eine Errungenschaft, und oft kann die richtige L√∂sung auf ihrer Grundlage gefunden werden.  Ich werde anders sagen: Niemals f√ºr nichts arbeiten.  H√∂chstwahrscheinlich haben Sie an eine naive L√∂sung gedacht, wollten sie aber nicht anbieten, weil Sie wissen, dass sie nicht optimal ist.  Wenn Sie jetzt bereit sind, die beste L√∂sung zu finden, ist das in Ordnung. Wenn nicht, zeichnen Sie die erzielten Fortschritte auf, bevor Sie mit komplexeren Dingen fortfahren. <br><br>  Lassen Sie uns von nun an √ºber die Verbesserungen des Algorithmus sprechen.  Die Hauptnachteile einer rekursiven DFS-L√∂sung bestehen darin, dass sie rekursiv ist und die Anzahl der Multiplikationen nicht minimiert.  Wie wir bald sehen werden, minimiert BFS die Anzahl der Multiplikationen und es ist auch sehr schwierig, sie rekursiv zu implementieren.  Leider m√ºssen wir die rekursive DFA-L√∂sung aufgeben, da wir den Code zur Verbesserung vollst√§ndig neu schreiben m√ºssen. <br><br>  Ohne weiteres pr√§sentiere ich einen iterativen Ansatz basierend auf BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Diese Implementierung unterscheidet sich funktional stark von der vorherigen, aber wenn Sie genau hinschauen, funktioniert sie mit einer wesentlichen √Ñnderung ungef√§hr gleich: W√§hrend rekursives DFS den Status der weiteren Route im Aufrufstapel speichert und den LIFO-Stapel effektiv implementiert, speichert die iterative L√∂sung ihn in der Warteschlange FIFO <br><br>  Dies impliziert die Eigenschaft "k√ºrzester Weg / geringste Anzahl von Multiplikationen".  Wir besuchen Knoten in der Reihenfolge, in der sie auftreten, und auf diese Weise erhalten wir Generationen von Knoten.  Der erste Knoten f√ºgt seine Nachbarn ein, und dann besuchen wir diese Nachbarn der Reihe nach und halten ihre Nachbarn die ganze Zeit fest und so weiter.  Die Eigenschaft des k√ºrzesten Pfades ergibt sich aus der Tatsache, dass die Knoten in der Reihenfolge ihrer Entfernung von der Quelle besucht werden.  Wenn wir also auf ein Ziel sto√üen, wissen wir, dass es keine fr√ºhere Generation gibt, die dazu f√ºhren k√∂nnte. <br><br>  In diesem Moment sind wir <i>fast</i> fertig.  Zuerst m√ºssen Sie einige Fragen beantworten, und sie sind gezwungen, zur urspr√ºnglichen Formulierung des Problems zur√ºckzukehren. <br><br>  Erstens, das Trivialste, wenn die urspr√ºngliche Einheit nicht existiert?  Das hei√üt, wir k√∂nnen den Knoten mit dem angegebenen Namen nicht finden.  In der Praxis m√ºssen Sie die Zeichenfolgen normalisieren, damit Pound, Pound und lb auf denselben "Pound" -Knoten (oder eine andere kanonische Darstellung) zeigen. Dies geht jedoch √ºber den Rahmen unserer Frage hinaus. <br><br>  Zweitens, was ist, wenn zwischen den beiden Einheiten keine Umrechnung erfolgt?  Denken Sie daran, dass es in den Anfangsdaten nur Umrechnungen zwischen Einheiten gibt und es keine Hinweise darauf gibt, ob es m√∂glich ist, eine andere von einer bestimmten Einheit zu erhalten.  Dies l√§uft darauf hinaus, dass Transformationen und Pfade direkt gleichwertig sind. Wenn also kein Pfad zwischen zwei Knoten vorhanden ist, gibt es keine Transformation.  In der Praxis erhalten Sie nicht verwandte Einheiteninseln: eine f√ºr Entfernungen, eine f√ºr Gewichte, eine f√ºr W√§hrungen usw. <br><br>  Wenn Sie sich die obige Grafik genauer ansehen, stellt sich heraus, dass Sie mit dieser L√∂sung nicht zwischen H√§nden und Lichtjahren konvertieren k√∂nnen.  Die Richtung der Verbindungen zwischen Knoten bedeutet, dass es keinen Weg von Hand zu Lichtjahren gibt.  Dies ist jedoch recht einfach zu beheben, da die Transformationen umgekehrt werden k√∂nnen.  Wir k√∂nnen unseren Graphinitialisierungscode wie folgt √§ndern: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph. Note we insert its inverse also.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dest <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[dest] = {} self.graph[dest][orig] = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / rate</code> </pre> <br><h2>  Teil 3. Bewertung </h2><br>  Fertig!  Wenn der Kandidat diesen Punkt erreicht hat, werde ich ihn h√∂chstwahrscheinlich zur Einstellung empfehlen.  Wenn Sie Informatik studiert oder einen Kurs in Algorithmen belegt haben, fragen Sie sich vielleicht: "Reicht das wirklich aus, um ein Interview mit diesem Typen zu bekommen?", Worauf ich antworten werde: "Im Wesentlichen ja." <br><br>  Bevor Sie entscheiden, dass die Frage zu einfach ist, schauen wir uns an, was ein Kandidat tun muss, um diesen Punkt zu erreichen: <br><br><ul><li>  Verstehe die Frage <br></li><li>  Erstellen Sie ein Netzwerk von Transformationen in Form eines Diagramms <br></li><li>  Verstehen Sie, dass die Koeffizienten mit den Kanten des Diagramms verglichen werden k√∂nnen <br></li><li>  Sehen Sie die M√∂glichkeit, Suchalgorithmen zu verwenden, um dies zu erreichen. <br></li><li>  W√§hlen Sie Ihren bevorzugten Algorithmus und √§ndern Sie ihn, um die Gewinnchancen zu verfolgen <br></li><li>  Wenn er DFS als naive L√∂sung implementiert hat, erkennen Sie seine Schw√§chen. <br></li><li>  Implementieren Sie BFS <br></li><li>  Um zur√ºckzutreten und Extremf√§lle zu untersuchen: <br><ul><li>  Was ist, wenn wir nach einem Knoten gefragt werden, der nicht existiert? <br></li><li>  Was ist, wenn der Umrechnungsfaktor nicht vorhanden ist? </li></ul></li><li>  Erkennen Sie, dass inverse Transformationen m√∂glich und wahrscheinlich notwendig sind </li></ul><br>  Diese Frage ist einfacher als die vorherigen, aber auch schwierig.  Wie bei allen vorherigen Fragen muss der Kandidat einen mentalen Sprung von einer abstrakt formulierten Frage zu einem Algorithmus oder einer Datenstruktur machen, die den Weg zu einer L√∂sung ebnet.  Das einzige ist, dass der endg√ºltige Algorithmus weniger fortgeschritten ist als in anderen Fragen.  Au√üerhalb dieses algorithmischen Materials gelten die gleichen Anforderungen, insbesondere in Bezug auf Extremf√§lle und Korrektheit. <br><br>  "Aber warte!" Sie k√∂nnen fragen.  - Ist Google nicht besessen von der Komplexit√§t der Laufzeit?  Sie haben nicht einmal nach der zeitlichen oder r√§umlichen Komplexit√§t dieses Problems gefragt.  Ach was!"  Sie k√∂nnen auch fragen: "Warten Sie eine Minute, Sie gaben die Bewertung" sehr zu empfehlen zu mieten "?  Wie bekomme ich es? "  Beides sehr gute Fragen.  Dies bringt uns zu unserer letzten zus√§tzlichen Bonusrunde ... <br><br><h2>  Teil 4. Kann man es besser machen? </h2><br>  An dieser Stelle m√∂chte ich dem Kandidaten zu einer guten Antwort gratulieren und klarstellen, dass alles weitere nur ein Bonus ist.  Wenn der Druck verschwindet, k√∂nnen wir anfangen zu schaffen. <br><br>  Was ist die Schwierigkeit, BFS auszuf√ºhren?  Im schlimmsten Fall m√ºssen wir jeden einzelnen Knoten und jede einzelne Kante ber√ºcksichtigen, was eine lineare Komplexit√§t <code>O(N+E)</code> ergibt.  Dies kommt zu der gleichen Komplexit√§t der <code>O(N+E)</code> -Graphenkonstruktion hinzu.  F√ºr eine Suchmaschine ist dies wahrscheinlich gut: Tausend Ma√üeinheiten reichen f√ºr die meisten vern√ºnftigen Anwendungen aus, und eine Speichersuche f√ºr jede Abfrage ist keine √úberlastung. <br><br>  Man kann es jedoch besser machen.  √úberlegen Sie zur Motivation, wie dieser Code in die Suchzeichenfolge eingef√ºgt wird.  Umrechnungen einiger nicht standardm√§√üiger Einheiten sind etwas h√§ufiger, daher werden wir sie immer wieder berechnen.  Jedes Mal, wenn eine Suche durchgef√ºhrt wird, werden Zwischenwerte berechnet und so weiter. <br><br>  Es wird oft empfohlen, die Berechnungsergebnisse einfach zwischenzuspeichern.  Wenn eine Einheitenumrechnung berechnet wird, k√∂nnen wir immer nur eine Kante zwischen den beiden Umrechnungen hinzuf√ºgen.  Als Bonus erhalten wir die inverse Transformation und das kostenlos!  Bist du fertig <br><br>  Dies gibt uns zwar eine asymptotisch konstante Suchzeit, kostet jedoch die Speicherung zus√§tzlicher Kanten.  Dies wird tats√§chlich ziemlich teuer: Im Laufe der Zeit werden wir uns um einen vollst√§ndigen Graphen bem√ºhen, da alle Transformationspaare nach und nach berechnet und gespeichert werden.  Die Anzahl der m√∂glichen Kanten im Diagramm ist das halbe Quadrat der Anzahl der Knoten. F√ºr tausend Knoten ben√∂tigen wir also eine halbe Million Kanten.  F√ºr zehntausend Knoten, ungef√§hr f√ºnfzig Millionen usw. <br><br>  √úber den Rahmen der Suchmaschine hinaus streben wir f√ºr eine Grafik von einer Million Knoten eine halbe Billion Kanten an.  Es ist einfach unangemessen, diesen Betrag zu speichern, und wir verbringen Zeit damit, Kanten in das Diagramm einzuf√ºgen.  Wir m√ºssen es besser machen. <br><br>  Gl√ºcklicherweise gibt es eine M√∂glichkeit, eine konstante Zeit f√ºr die Suche nach Koeffizienten ohne quadratisches Raumwachstum zu erreichen.  Tats√§chlich ist fast alles, was wir brauchen, direkt vor unserer Nase. <br><br><h2>  Teil 4. Konstante Zeit </h2><br>  Das vollst√§ndige Caching ist also tats√§chlich nahe an der optimalen L√∂sung.  Bei diesem Ansatz erhalten wir (letztendlich) Kanten zwischen allen Knoten, dh unsere Transformation wird darauf reduziert, eine Kante zu finden.  Aber ist es wirklich notwendig, Conversions von jedem Knoten zu jedem Knoten zu speichern?  Was ist, wenn wir nur die Umrechnungsfaktoren von <i>einem</i> Knoten auf alle anderen speichern? <br><br>  Schauen Sie sich die BFS-L√∂sung noch einmal an: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Mal sehen, was hier passiert: Wir beginnen am Quellknoten und berechnen f√ºr jeden Knoten, auf den wir sto√üen, den Umrechnungskoeffizienten von der Quelle zu diesem Knoten.  Sobald wir am Ziel ankommen, geben wir den Koeffizienten zwischen dem Start- und dem Endpunkt zur√ºck und verwerfen die Zwischenkoeffizienten. <br><br>  Diese Zwischenverh√§ltnisse sind entscheidend.  Aber was ist, wenn wir sie nicht wegwerfen?  Was ist, wenn wir sie stattdessen aufschreiben?  Alle komplexesten und unverst√§ndlichsten Suchvorg√§nge werden einfach: Um das Verh√§ltnis von A zu B zu ermitteln, m√ºssen Sie zuerst das Verh√§ltnis von X zu B ermitteln und dann durch das Verh√§ltnis von X zu A dividieren. Fertig!  Optisch sieht es so aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/284/a08/b6c/284a08b6cb6ef95af556422fa3c604f3.png"><br>  <i><font color="gray">Beachten Sie, dass zwischen zwei beliebigen Knoten nicht mehr als zwei Kanten liegen</font></i> <br><br>  Es stellt sich heraus, dass wir zur Berechnung dieser Tabelle die BFS-L√∂sung fast nicht √§ndern m√ºssen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_conversions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conversions_bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, conversions)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() conversions[node] = (start, rate_from_origin) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: to_visit.append((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions conversions = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.get_nodes(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: conversions_bfs(graph, node, conversions) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions</code> </pre> <br>  Die Transformationsstruktur wird durch ein W√∂rterbuch der Einheit A in zwei Werten dargestellt: der Wurzel f√ºr die zugeh√∂rige Komponente der Einheit A und dem Umrechnungskoeffizienten zwischen der Wurzeleinheit und der Einheit A. Da wir bei jedem Besuch eine Einheit in dieses W√∂rterbuch einf√ºgen, k√∂nnen wir den Schl√ºsselraum dieses W√∂rterbuchs als eine Reihe von Besuchen verwenden, anstatt ihn zu verwenden eine spezielle Reihe von Besuchen.  Beachten Sie, dass wir keinen endg√ºltigen Knoten haben und stattdessen die Knoten durchlaufen, bis wir fertig sind. <br><br>  Au√üerhalb dieses BFS gibt es eine Hilfsfunktion, die √ºber Knoten in einem Diagramm iteriert.  Immer wenn es auf einen Knoten au√üerhalb des √úbersetzungsw√∂rterbuchs trifft, startet es BFS ab diesem Knoten.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somit ist garantiert, dass wir alle Knoten in ihre zugeh√∂rigen Komponenten zusammenfassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Beziehung zwischen den Einheiten finden m√ºssen, verwenden wir einfach die gerade berechnete Transformationsstruktur:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(conversions, start, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Given a conversion structure, performs a constant-time conversion'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: start_root, start_rate = conversions[start] end_root, end_rate = conversions[end] <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_root != end_root: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end_rate / start_rate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Situation ‚ÄûEs gibt keine solche Einheit‚Äú wird behandelt, indem beim Zugriff auf die Struktur von Transformationen auf eine Ausnahme gewartet wird. </font><font style="vertical-align: inherit;">Die Situation ‚ÄûEs gibt keine solchen Transformationen‚Äú wird durch Vergleichen der Wurzeln zweier Gr√∂√üen behandelt: Wenn sie unterschiedliche Wurzeln haben, werden sie durch zwei verschiedene BFS-Aufrufe erkannt, dh sie befinden sich in zwei verschiedenen verbundenen Komponenten, und daher gibt es keinen Weg zwischen ihnen. </font><font style="vertical-align: inherit;">Schlie√ülich f√ºhren wir die Konvertierung durch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So! </font><font style="vertical-align: inherit;">Die aktuelle L√∂sung weist eine Vorverarbeitungskomplexit√§t auf</font></font><code>O(V+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nicht schlechter als fr√ºhere L√∂sungen), aber sie sucht auch mit konstanter Zeit. Theoretisch verdoppeln wir den Platzbedarf, aber meistens ben√∂tigen wir das urspr√ºngliche Diagramm nicht mehr, sodass wir es einfach l√∂schen und nur dieses verwenden k√∂nnen. Dar√ºber hinaus ist die r√§umliche Komplexit√§t tats√§chlich geringer als beim urspr√ºnglichen Diagramm: Sie erfordert, </font></font><code>O(V+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weil alle Kanten und Eckpunkte gespeichert werden m√ºssen, und diese Struktur erfordert nur, </font></font><code>O(V)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weil wir keine Kanten mehr ben√∂tigen.</font></font><br><br><h2>  Ergebnisse </h2><br>     ,   ,        ,  ,      -              .     -   ,         .   ,     . <br><br>         ( ,  , ,     ),          ¬´ ¬ª.    ,     :     ,       ,    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist sofort ein n√ºtzliches Signal. Ich kann verstehen, wenn eine Person keine fortgeschrittenen oder undurchsichtigen Datenstrukturen kennt, weil wir ehrlich sind, m√ºssen Sie selten disjunkte Mengen implementieren. Grafiken sind jedoch eine grundlegende Datenstruktur und werden im Rahmen fast aller Einf√ºhrungskurse zu diesem Thema vermittelt. Wenn der Kandidat Schwierigkeiten hat, sie zu verstehen, oder sie nicht einfach anwenden kann, wird es f√ºr ihn wahrscheinlich schwierig sein, bei Google erfolgreich zu sein (zumindest in meiner Zeit dort wei√ü ich heute nicht, wie).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits war die Wahl des Algorithmus keine besonders n√ºtzliche Signalquelle. Leute, die die Framing-Phase durchlaufen haben, sind normalerweise ohne Probleme zum Algorithmus gekommen. Ich vermute, dass dies auf die Tatsache zur√ºckzuf√ºhren ist, dass Suchalgorithmen fast immer zusammen mit den Diagrammen selbst gelehrt werden. Wenn also jemand mit einem vertraut ist, kennt er den anderen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Implementierung war nicht einfach. Viele Leute hatten keine Probleme mit der rekursiven Implementierung von DFS, aber wie oben erw√§hnt, ist diese Implementierung nicht f√ºr die Produktion geeignet. Zu meiner √úberraschung scheinen die iterativen Implementierungen von BFS und DFS den Menschen nicht sehr vertraut zu sein, und selbst nach offensichtlichen Hinweisen schwebten sie oft im Thema.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meiner Meinung nach hat mir jeder, der die Implementierungsphase durchlaufen hat, bereits die Empfehlung ‚ÄûEinstellung‚Äú eingebracht, und die Diskussion √ºber die konstante Vorlaufzeit ist einfach ein Bonus. </font><font style="vertical-align: inherit;">Obwohl wir uns die L√∂sung im Artikel ausf√ºhrlich angesehen haben, ist in der Praxis eine m√ºndliche Diskussion anstelle des Schreibens von Code in der Regel produktiver. </font><font style="vertical-align: inherit;">Nur sehr wenige Kandidaten konnten sofort eine Entscheidung treffen. </font><font style="vertical-align: inherit;">Ich musste oft wesentliche Hinweise geben, und selbst dann konnten viele Leute ihn nicht finden. </font><font style="vertical-align: inherit;">Dies ist normal: Wie erwartet ist es schwierig, eine sehr empfohlene Bewertung zu erhalten.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aber warte, das ist noch nicht alles! </font></font></h2><br>  ,    ,        ,     ,      .     : <br><br> -, :     ,   ,        .  ,     ,    .   ,         - ,  -               .     ,       ,            . <br><br> -,    ,        ,    .       ‚Äî  :  ‚Äî  ,    A  B   ‚Äî    /   .            :  , ,    ,    ,     ,   .      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endlich ein echtes Juwel: Einige Einheiten werden als Kombination verschiedener Basiseinheiten ausgedr√ºckt. Beispielsweise wird ein Watt im SI-System als kg ‚Ä¢ m¬≤ / s¬≥ definiert. Die letzte Aufgabe besteht darin, dieses System zu erweitern, um die Konvertierung zwischen diesen Einheiten zu unterst√ºtzen, wobei nur die Definitionen der grundlegenden SI-Einheiten ber√ºcksichtigt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Fragen haben, k√∂nnen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mich gerne √ºber reddit kontaktieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Fazit </h2><br>        ,  ,      .      :     ,      ,       ,        . ,   ,  ,   ,     :            ,        .   ,      ,  ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, Sie fanden diesen Artikel hilfreich. </font><font style="vertical-align: inherit;">Ich verstehe, dass es mit Algorithmen m√∂glicherweise nicht so viele Abenteuer gibt wie in einigen fr√ºheren Artikeln. </font><font style="vertical-align: inherit;">Bei den Interviews mit Entwicklern ist es √ºblich, Algorithmen ausf√ºhrlich zu diskutieren. </font><font style="vertical-align: inherit;">Die Wahrheit ist jedoch, dass erhebliche Schwierigkeiten auftreten, wenn selbst eine einfache, bekannte Methode angewendet wird. </font><font style="vertical-align: inherit;">Der gesamte Code befindet sich im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository dieser Artikelserie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467371/">https://habr.com/ru/post/de467371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467359/index.html">PVS-Studio geht in die Cloud: Azure DevOps</a></li>
<li><a href="../de467361/index.html">Wir haben die Delegierung in JavaScript vergessen. Ereignisdelegation reagieren</a></li>
<li><a href="../de467363/index.html">Verwenden benutzerdefinierter Verlustfunktionen und Lernen von Qualit√§tsmetriken in Keras</a></li>
<li><a href="../de467365/index.html">Relais zur √úberwachung der Wohnspannung</a></li>
<li><a href="../de467369/index.html">RubyRussia 2019. Mikhail Pronyakin: Ist Ruby sicher?</a></li>
<li><a href="../de467375/index.html">Customer Experience Management - was ist das?</a></li>
<li><a href="../de467377/index.html">Drei in Folge: Top 10 Berichte von Mobius 2019 Piter</a></li>
<li><a href="../de467381/index.html">Mehrst√∂ckige LEDs, intelligente Lichter und Gl√ºhbirnen f√ºr 18 Rubel</a></li>
<li><a href="../de467383/index.html">"Der Manager muss weiter codieren": Interview mit Stephen Chin</a></li>
<li><a href="../de467385/index.html">Eine Auswahl psychologischer und atypischer technischer Fragen aus Java-Entwicklerinterviews</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>