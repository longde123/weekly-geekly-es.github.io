<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äç‚öïÔ∏è üè¶ üìÖ Complicamos os modelos de fic√ß√£o cient√≠fica de maneira processual: o que √© Greeble e como us√°-lo üçû üö£üèª üöë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para come√ßar, deixe-me reclamar que ‚Äúgreeble‚Äù √© uma palavra terr√≠vel a ser banida do dicion√°rio. 

 Bem, removendo a pedra da alma, passamos √†s explic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Complicamos os modelos de fic√ß√£o cient√≠fica de maneira processual: o que √© Greeble e como us√°-lo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482316/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/b32/235/ad5b322354c84b28b72a7f0a04a5dde9.png" alt="imagem"></div><br>  Para come√ßar, deixe-me reclamar que ‚Äúgreeble‚Äù √© uma palavra terr√≠vel a ser banida do dicion√°rio. <br><br>  Bem, removendo a pedra da alma, passamos √†s explica√ß√µes.  Greeble s√£o pequenos detalhes repetidos adicionados a um modelo para dar uma sensa√ß√£o de escala e uma certa est√©tica.  Os cogumelos se tornaram populares gra√ßas aos filmes cl√°ssicos de fic√ß√£o cient√≠fica, nos quais a escultura f√≠sica era frequentemente o "modelo": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb1/c56/a07/eb1c56a07e8d7f03875c2cbf2e80a224.jpg"></div><br>  Se voc√™ j√° sabe do meu <a href="https://lindenreid.wordpress.com/2017/11/05/procedural-mesh-extrusion-tutorial/">tutorial</a> sobre <a href="https://lindenreid.wordpress.com/2017/11/05/procedural-mesh-extrusion-tutorial/">extrus√£o</a> como extrudar malhas processuais, ent√£o entende como adicionar cogumelos.  A adi√ß√£o de <strong>cogumelos</strong> simples √† malha pode ser realizada <strong>extrudindo</strong> todos os pol√≠gonos da malha para um <strong>comprimento aleat√≥rio</strong> . <br><br>  No entanto, voc√™ deve ter notado que o tutorial acima trata apenas de tri√¢ngulos extrudados, enquanto a imagem no in√≠cio do artigo √© quadrada.  Eu tive que ajustar a malha para que ela fosse dividida em quadr√¢ngulos, e muitas malhas geralmente consistem em pol√≠gonos com mais de tr√™s √≠ndices.  Portanto, neste tutorial, aprenderemos como <strong>extrudar um pol√≠gono com n √≠ndices</strong> e aplicar esse algoritmo a toda a malha para criar cogumelos.  Tamb√©m aprendemos algumas maneiras de fazer varia√ß√µes no algoritmo crescente para obter resultados menos uniformes. <br><a name="habracut"></a><br><h2>  Superf√≠cie normal </h2><br>  Primeiro, vamos descobrir como o normal de um pol√≠gono com n √≠ndices arbitr√°rios √© calculado.  Se pudermos supor que esse pol√≠gono √© <strong>plano</strong> , ou seja, todos os seus v√©rtices est√£o no mesmo plano, o processo n√£o difere do c√°lculo da normal de um pol√≠gono com tr√™s √≠ndices. <br><br>  <strong>A superf√≠cie normal</strong> √© a perpendicular √† face do pol√≠gono, que pode ser calculada tomando o <strong>produto vetorial de dois vetores apontando ao longo da borda do pol√≠gono</strong> . <br><br>  Em seguida, <strong>normalizamos</strong> esse vetor para que seu comprimento seja 1, pois do normal para a superf√≠cie precisamos apenas de dire√ß√£o, n√£o de comprimento. <br><br><blockquote><pre>  fun√ß√£o getFaceNormal (malha, poli)
   Vec3 v1 = malha: getVertex (poli [1])
   Vec3 v2 = malha: getVertex (poli [2])
   Vec3 v3 = malha: getVertex (poli [3])
   Vec3 e1 = v2 - v1
   Vec3 e2 = v3 - v2
   Vec3 normal = e1: cruz (e2)
   retornar normal: normalize ()
 fim </pre></blockquote><br>  Se n√£o pudermos assumir com confian√ßa que o pol√≠gono √© plano, o algoritmo apresentado acima prefere o plano no qual os dois primeiros √≠ndices est√£o localizados.  Para uma representa√ß√£o mais precisa da dire√ß√£o na qual o pol√≠gono aponta, podemos obter a <strong>m√©dia de todos os produtos vetoriais das arestas</strong> : <br><br><blockquote><pre>  fun√ß√£o getFaceNormal (malha, poli)
   Vec3 n = Vec3 (0, 0, 0)
   para i = 1, #poly -2 do
     Vec3 v1 = malha: getVertex (poli [1])
     Vec3 v2 = malha: getVertex (poli [1+ i])
     Vec3 v3 = malha: getVertex (poli [2+ i])
     n: add ((v2 - v1): cross (v3 - v1))
   fim
   return n: normalize ()
 fim </pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cb/acd/7af/9cbacd7afe5483a32337e2c1fc734572.jpg"></div><br>  <i>Um exemplo mostrando a extrus√£o de um quadril√°tero plano.</i> <br><br><h2>  Extrus√£o </h2><br>  Agora que temos informa√ß√µes sobre a superf√≠cie normal, estamos prontos para extrudar o pol√≠gono na dire√ß√£o normal.  Simplificando, para a extrus√£o do pol√≠gono, criamos novos v√©rtices movendo os v√©rtices antigos na dire√ß√£o da superf√≠cie normal. <br><br>  Mais detalhes: <br><br><ol><li>  Crie <strong>novos picos ‚Äúacima‚Äù dos antigos</strong> na dire√ß√£o normal. <br><br>  Novos v√©rtices podem ser calculados da seguinte maneira: <br><br><blockquote><pre>  (posi√ß√£o do pico antigo) + (dire√ß√£o normal) </pre></blockquote><br>  Isso "muda" a posi√ß√£o antiga na dire√ß√£o da superf√≠cie normal. <br><br>  Por exemplo, veja a imagem acima, nela a <strong>v1 se move na dire√ß√£o normal para a v5.</strong> </li><li>  Crie <strong>quadr√¢ngulos</strong> para conectar os v√©rtices novos e antigos. <br><br>  Note-se que para cada √≠ndice no novo pol√≠gono, um novo quadril√°tero √© criado. <br><br>  Por exemplo, d√™ uma olhada em um <strong>quad criado a partir das v8, v7, v3 e v4</strong> . </li><li>  Substitua o pol√≠gono antigo por um <strong>novo pol√≠gono criado por novos v√©rtices.</strong>  Por exemplo, d√™ uma olhada em um quad criado a partir das v5, v6, v7 e v8. </li></ol><br><br><blockquote><pre>  fun√ß√£o extrudePoly (malha, poliIndex, comprimento)
   int [] poly = mesh.polys [polyIndex]
   int [] newPoly = []
   Vec3 n = getFaceNormal (malha, poli)

   - (1) Crie verts extrudados
   para j = 1, #poly
     local p = malha: getVertex (poly [j])
     newPoly [#newPoly + 1] = # mesh.verts
     - length determina o comprimento da extrus√£o
     malha: addVertex (p + (n * comprimento))
   fim

   - (2) Costure os lados da extrus√£o com quadril√°teros
   para j0 = 1, #poly do
     j1 local = j0% #poly + 1
     mesh: addQuad (
       poli [j0],
       poli [j1],
       newPoly [j1],
       newPoly [j0]
     )
   fim

   - (3) Mova a face existente para v√©rtices extrudadas
   para j = 1, #poly
     mesh.polys [pi] [j] = newPoly [j]
   fim
 fim </pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c2/52d/ddb/7c252dddbae852b66b3221dd5abe335f.png"></div><br>  <i>Cogumelo uniforme.</i> <br><br><h2>  Toda a malha de cogumelo </h2><br>  Agora que temos a fun√ß√£o getSurfaceNormal () e a fun√ß√£o extrude (), √© f√°cil multiplicar os cogumelos!  Simplesmente <strong>aplicamos a fun√ß√£o extrude () a cada pol√≠gono da malha</strong> .  Usamos a extrus√£o com um <strong>comprimento aleat√≥rio</strong> para que cada pol√≠gono extrudado tenha um tamanho ligeiramente diferente, o que cria uma sensa√ß√£o de textura.  O algoritmo mostrado abaixo √© aplicado ao cubo apresentado acima, que consiste inteiramente em quadr√¢ngulos. <br><br><blockquote><pre>  fun√ß√£o greeble (malha)
   para i = 1, # mesh.polys do
     - esses valores aleat√≥rios s√£o arbitr√°rios: p
     comprimento do flutuador = aleat√≥rio: getUniformRange (0.1, 1.0)
     extrudePoly (malha, i, comprimento)
   fim
   malha de retorno
 fim </pre></blockquote><br>  Parab√©ns, nosso cogumelo ganhou.  Mas n√≥s podemos fazer mais!  Agora a prolifera√ß√£o de cogumelos √© bastante uniforme.  Aqui est√£o dois exemplos de modifica√ß√µes para torn√°-lo mais interessante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a23/afe/251/a23afe2519b4268a2155ec14d4160089.png"></div><br><h4>  Modifica√ß√£o 1: a presen√ßa de fungling depende do acaso </h4><br>  √â bem simples: basta rolar o dado para determinar se o cogumelo deve ser aplicado a cada pol√≠gono.  Gra√ßas a isso, a prolifera√ß√£o de cogumelos se torna menos uniforme.  O algoritmo mostrado abaixo √© aplicado ao cubo acima. <br><br><blockquote><pre>  para i = 1, # mesh.polys do
    &lt;strong&gt; se aleat√≥rio: chance (0,33), ent√£o &lt;/strong&gt;
      comprimento do flutuador = aleat√≥rio (0,1, 1,0)
      extrudePoly (malha, i, comprimento)
    fim
  fim
  malha de retorno
 fim </pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d16/294/d0c/d16294d0c7f4be9a878ceec459bb25fa.png"></div><br><h4>  Modifica√ß√£o 2: Adicionar escala de extrus√£o </h4><br>  Isso requer altera√ß√£o do algoritmo de extrus√£o.  Quando criamos os v√©rtices de um pol√≠gono extrudado, podemos <strong>reduzi-los em dire√ß√£o ao centro do pol√≠gono</strong> em uma quantidade aleat√≥ria para tornar o objeto mais interessante. <br><br>  Para come√ßar, nossa fun√ß√£o extrude () deve receber um par√¢metro adicional que determina a quantidade de restri√ß√£o do novo pol√≠gono.  Vamos defini-lo como Vec3 chamado <code>scale</code> .  Para mover um v√©rtice em dire√ß√£o ao centro, <strong>interpolamos a posi√ß√£o do v√©rtice</strong> entre sua <strong>posi√ß√£o original</strong> e o <strong>centro do pol√≠gono</strong> pelo valor da <code>scale</code> . <br><br>  (Se voc√™ precisar conhecer o algoritmo para encontrar o centro de um pol√≠gono, recomendo pular rapidamente para o <a href="https://lindenreid.wordpress.com/2017/12/03/simple-mesh-tessellation-triangulation-tutorial/">tutorial sobre triangula√ß√£o</a> e ler sobre a triangula√ß√£o do ponto m√©dio (triangula√ß√£o do centr√≥ide).) <br><br><blockquote><pre>  - encontre o centro do pol√≠gono
 Vec3 c = malha: getFaceCentroid (poli)
 para j = 1, #poly
   local p = malha: getVertex (poly [j])
   newPoly [#newPoly + 1] = # mesh.verts
   self: addVertex (
     math.lerp (cx, px, scale.x) + nx * comprimento,
     math.lerp (cy, py, scale.y) + ny * comprimento,
     math.lerp (cz, pz, scale.z) + nz * comprimento
   )
   malha: addVertex (p + (n * comprimento))
 fim </pre></blockquote><br>  Agora voc√™ pode us√°-lo no algoritmo de multiplica√ß√£o escalando por um valor aleat√≥rio para cada pol√≠gono.  Ent√£o, temos a imagem mostrada acima. <br><br><blockquote><pre>  fun√ß√£o greeble (malha)
   para i = 1, # mesh.polys do
     comprimento do flutuador = aleat√≥rio: getUniformRange (0.1, 1.0)
     Escala Vec3 = (aleat√≥ria: getUniformRange (0.1, 1.0),
                   random: getUniformRange (0.1, 1.0),
                   random: getUniformRange (0.1, 1.0))
     extrudePoly (malha, i, comprimento, escala)
   fim
   malha de retorno
 fim </pre></blockquote><br><h2>  O fim </h2><br>  √ìtimo, chegamos ao fim!  Espero que este tutorial tenha sido √∫til para voc√™. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482316/">https://habr.com/ru/post/pt482316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482302/index.html">Neblina psicol√≥gica sobre o Ano Novo</a></li>
<li><a href="../pt482304/index.html">Feito para a China: como criar o banner perfeito para o consumidor chin√™s</a></li>
<li><a href="../pt482306/index.html">Hist√≥ria do porn√¥ na Internet. Parte 1</a></li>
<li><a href="../pt482310/index.html">Transporte de animais do s√©culo XXI</a></li>
<li><a href="../pt482314/index.html">Construindo um cluster PostgreSQL de alta disponibilidade usando Patroni, etcd, HAProxy</a></li>
<li><a href="../pt482318/index.html">Por que a ferrugem deve se tornar uma linguagem de programa√ß√£o funcional</a></li>
<li><a href="../pt482328/index.html">V&V n√£o para vendetta</a></li>
<li><a href="../pt482330/index.html">Lista de gemas b√°sicas para cria√ß√£o de perfil do aplicativo Ruby on Rails</a></li>
<li><a href="../pt482332/index.html">Como um entusiasta criou uma rede Wi-Fi no DOS</a></li>
<li><a href="../pt482336/index.html">Os comerciantes t√™m acesso a coletivas de imprensa do Banco Central da Inglaterra antes de sua transmiss√£o p√∫blica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>