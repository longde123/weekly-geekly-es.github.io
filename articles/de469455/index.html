<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖤 🖕 🤹🏽 Migration von Nginx zu Envoy Proxy 🧜🏾 🤷🏼 🖖🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich mache Sie auf die Übersetzung des Beitrags aufmerksam: Migration von Nginx zu Envoy Proxy . 


 Envoy ist ein leistungsstarker verteil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Migration von Nginx zu Envoy Proxy</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469455/"><p>  Hallo Habr!  Ich mache Sie auf die Übersetzung des Beitrags aufmerksam: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Migration von Nginx zu Envoy Proxy</a> . </p><br><p>  Envoy ist ein leistungsstarker verteilter Proxyserver (in C ++ geschrieben), der für einzelne Dienste und Anwendungen entwickelt wurde. Er ist auch ein Kommunikationsbus und eine „universelle Datenebene“, die für große „Service Mesh“ -Architekturen mit Mikrodiensten entwickelt wurde.  Bei der Erstellung wurden Lösungen für Probleme berücksichtigt, die bei der Entwicklung von Servern wie NGINX, HAProxy, Hardware-Load-Balancern und Cloud-Load-Balancern auftraten.  Envoy arbeitet mit jeder Anwendung und abstrahiert das Netzwerk und bietet unabhängig von der Plattform gemeinsame Funktionen.  Wenn der gesamte Büroverkehr in der Infrastruktur über das Envoy-Raster geleitet wird, können Problembereiche mit konsistenter Beobachtbarkeit, Optimierung der Gesamtleistung und Hinzufügen grundlegender Funktionen an einem bestimmten Ort leicht visualisiert werden. </p><br><h2 id="vozmozhnosti">  Die Möglichkeiten </h2><br><ul><li> Außerhalb der Prozessarchitektur: envoy ist ein eigenständiger Hochleistungsserver, der wenig RAM benötigt.  Es funktioniert in Verbindung mit jeder Anwendungssprache oder jedem Framework. </li><li>  Unterstützung für http / 2 und grpc: envoy bietet erstklassige Unterstützung für http / 2 und grpc für eingehende und ausgehende Verbindungen.  Dies ist ein transparenter Proxy von http / 1.1 bis http / 2. </li><li>  Verbesserter Lastausgleich: envoy unterstützt erweiterte Lastausgleichsfunktionen, einschließlich automatischer Wiederholungsversuche, offener Stromkreis, globales Tempolimit, Shadowing-Anforderungen, Lastausgleich in der lokalen Zone usw. </li><li>  Konfigurationsverwaltungs-API: envoy bietet eine robuste API zur dynamischen Verwaltung der Konfiguration. </li><li>  Beobachtbarkeit: tiefe Beobachtbarkeit des L7-Verkehrs, integrierte Unterstützung für die verteilte Verfolgung und Beobachtbarkeit von Mongodb, Dynamodb und vielen anderen Anwendungen. </li></ul><a name="habracut"></a><br><h2 id="shag-1---primer-konfiga-nginx">  Schritt 1 - Beispiel NGINX Config </h2><br><p>  Dieses Skript verwendet eine speziell erstellte Datei <em>nginx.conf</em> , die auf einem vollständigen Beispiel aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NGINX-Wiki</a> basiert.  Sie können die Konfiguration im Editor <em>anzeigen,</em> indem Sie die <em>Datei nginx.conf öffnen</em> </p><br><p>  Quell-Nginx-Konfiguration </p><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">user</span></span> www www; <span class="hljs-attribute"><span class="hljs-attribute">pid</span></span> /var/run/nginx.pid; <span class="hljs-attribute"><span class="hljs-attribute">worker_processes</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-section"><span class="hljs-section">events</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">worker_connections</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span>; } <span class="hljs-section"><span class="hljs-section">http</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gzip</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_min_length</span></span> <span class="hljs-number"><span class="hljs-number">1100</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_buffers</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8k</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_types</span></span> text/plain; <span class="hljs-attribute"><span class="hljs-attribute">log_format</span></span> main <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_addr</span></span></span><span class="hljs-string"> - </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_user</span></span></span><span class="hljs-string"> [</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time_local</span></span></span><span class="hljs-string">] '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request</span></span></span><span class="hljs-string">" </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$status</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$bytes_sent</span></span></span><span class="hljs-string"> '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_referer</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_user_agent</span></span></span><span class="hljs-string">" '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$gzip_ratio</span></span></span><span class="hljs-string">"'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">log_format</span></span> download <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_addr</span></span></span><span class="hljs-string"> - </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_user</span></span></span><span class="hljs-string"> [</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time_local</span></span></span><span class="hljs-string">] '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request</span></span></span><span class="hljs-string">" </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$status</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$bytes_sent</span></span></span><span class="hljs-string"> '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_referer</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_user_agent</span></span></span><span class="hljs-string">" '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_range</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$sent_http_content_range</span></span></span><span class="hljs-string">"'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> targetCluster { 172.18.0.3:80; 172.18.0.4:80; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> one.example.com www.one.example.com; <span class="hljs-attribute"><span class="hljs-attribute">access_log</span></span> /var/log/nginx.access_log main; <span class="hljs-attribute"><span class="hljs-attribute">error_log</span></span> /var/log/nginx.error_log <span class="hljs-literal"><span class="hljs-literal">info</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://targetCluster/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_redirect</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; } } }</code> </pre> <br><p>  NGINX-Konfigurationen haben normalerweise drei Schlüsselelemente: </p><br><ol><li>  Konfigurieren des NGINX-Servers, der Protokollstruktur und der Gzip-Funktionalität.  Dies wird in allen Fällen global bestimmt. </li><li>  Konfigurieren von NGINX zum Akzeptieren von Anforderungen für <em>one.example.com-</em> Host an Port 8080. </li><li>  Festlegen Ihres Zielorts, wie der Datenverkehr für verschiedene Teile der URL behandelt wird. </li></ol><br><p>  Nicht alle Konfigurationen werden auf Envoy Proxy angewendet, und Sie müssen einige Einstellungen nicht konfigurieren.  Envoy Proxy verfügt über <strong>vier Schlüsseltypen</strong> , die die von NGINX angebotene zugrunde liegende Infrastruktur unterstützen.  Der Kern ist: </p><br><ul><li>  <strong>Listener:</strong> Sie bestimmen, wie Envoy Proxy eingehende Anforderungen akzeptiert.  Envoy Proxy unterstützt derzeit nur TCP-basierte Listener.  Sobald die Verbindung hergestellt ist, wird sie zur Verarbeitung an eine Reihe von Filtern übertragen. </li><li>  <strong>Filter:</strong> Sie sind Teil einer Pipeline-Architektur, die eingehende und ausgehende Daten verarbeiten kann.  Diese Funktionalität umfasst Filter wie Gzip, die die Daten komprimieren, bevor sie an den Client gesendet werden. </li><li>  <strong>Router:</strong> Sie leiten den Datenverkehr zum gewünschten Ziel um, das als Cluster definiert ist. </li><li>  <strong>Cluster:</strong> Sie definieren den Endpunkt für die Verkehrs- und Konfigurationseinstellungen. </li></ul><br><p>  Wir werden diese vier Komponenten verwenden, um die Envoy Proxy-Konfiguration zu erstellen, die der spezifischen NGINX-Konfiguration entspricht.  Das Ziel von Envoy ist die Arbeit mit der API und der dynamischen Konfiguration.  In diesem Fall verwendet die Grundkonfiguration statische, fest codierte Parameter von NGINX. </p><br><h2 id="shag-2---konfiguraciya-nginx">  Schritt 2 - Konfigurieren Sie NGINX </h2><br><p>  Der erste Teil von <em>nginx.conf</em> definiert einige der internen NGINX-Komponenten, die konfiguriert werden müssen. </p><br><h4 id="worker-connections-rabochie-soedineniya">  Arbeiterverbindungen </h4><br><p>  Die folgende Konfiguration bestimmt die Anzahl der Arbeitsprozesse und Verbindungen.  Dies zeigt an, wie NGINX skaliert wird, um die Nachfrage zu befriedigen. </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">worker_processes</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-section"><span class="hljs-section">events</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">worker_connections</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span>; }</code> </pre> <br><p>  Envoy Proxy verwaltet Workflows und Verbindungen unterschiedlich. </p><br><p>  Envoy erstellt einen Workflow für jeden Hardware-Thread im System.  Jeder Arbeitsthread führt eine nicht blockierende Ereignisschleife aus, für die er verantwortlich ist </p><br><ol><li>  Jedem Zuhörer zuhören </li><li>  Akzeptiere neue Verbindungen </li><li>  Erstellen eines Filtersatzes für eine Verbindung </li><li>  Behandlung aller E / A-Vorgänge über die Lebensdauer einer Verbindung. </li></ol><br><p>  Die gesamte weitere Verbindungsverarbeitung wird vollständig im Workflow verarbeitet, einschließlich des Weiterleitungsverhaltens. </p><br><p>  Für jeden Workflow in Envoy gibt es eine Verbindung im Pool.  Daher stellen HTTP / 2-Verbindungspools jeweils nur eine Verbindung für jeden externen Host her. Wenn vier Arbeitsthreads vorhanden sind, gibt es vier HTTP / 2-Verbindungen für jeden externen Host in einem stabilen Zustand.  Durch Speichern von allem in einem Workflow kann fast der gesamte Code ohne Sperren geschrieben werden, als wäre er Single-Threaded.  Wenn mehr als die erforderlichen Workflows zugewiesen werden, kann dies zu einer ineffizienten Speichernutzung, der Erstellung einer großen Anzahl inaktiver Verbindungen und einer Verringerung der Anzahl der an den Pool zurückgegebenen Verbindungen führen. </p><br><p>  Weitere Informationen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Envoy Proxy-Blog</a> . </p><br><h4 id="konfiguraciya-http">  HTTP-Konfiguration </h4><br><p>  Der folgende NGINX-Konfigurationsblock definiert HTTP-Einstellungen, z. </p><br><ul><li>  Welche MIME-Typen werden unterstützt? </li><li>  Standardzeitüberschreitungen </li><li>  Gzip-Konfiguration </li></ul><br><p>  Sie können diese Aspekte mithilfe von Filtern in Envoy Proxy konfigurieren, auf die wir später noch eingehen werden. </p><br><h2 id="shag-3---konfiguraciya-server">  Schritt 3 - Serverkonfiguration </h2><br><p>  Im HTTP-Konfigurationsblock werden Sie in der NGINX-Konfiguration angewiesen, Port 8080 abzuhören und auf eingehende Anforderungen für die Domänen <em>one.example.com</em> und <em>www.one.example.com zu antworten</em> . </p><br><pre> <code class="nginx hljs"> <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> one.example.com www.one.example.com;</code> </pre> <br><p>  In Envoy kontrollieren die Zuhörer es. </p><br><h4 id="slushateli-envoy">  Gesandte Zuhörer </h4><br><p>  Der wichtigste Aspekt beim Einstieg in Envoy Proxy ist die Identifizierung von Listenern.  Sie müssen eine Konfigurationsdatei erstellen, die beschreibt, wie Sie eine Envoy-Instanz ausführen möchten. </p><br><p>  Das folgende Snippet erstellt einen neuen Listener und ordnet ihn Port 8080 zu. Die Konfiguration teilt Envoy Proxy mit, an welche Ports er für eingehende Anforderungen gebunden werden soll. </p><br><p>  Envoy Proxy verwendet für die Konfiguration die YAML-Notation.  Um sich mit dieser Notation vertraut zu machen, klicken Sie auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> hier. </p><br><pre> <code class="plaintext hljs">Copy to Editorstatic_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8080 }</code> </pre> <br><p>  Es ist nicht erforderlich, <em>Servernamen</em> zu definieren, da Envoy Proxy-Filter dies verarbeiten können. </p><br><h2 id="shag-4---konfiguraciya-mestopolozheniya">  Schritt 4 - Standortkonfiguration </h2><br><p>  Wenn eine Anforderung bei NGINX eintrifft, bestimmt der Standortblock, wie der Datenverkehr verarbeitet und wohin geleitet werden soll.  Im folgenden Fragment wird der gesamte Datenverkehr zur Site an einen Upstream-Cluster (Anmerkung des Übersetzers: Upstream ist normalerweise ein Anwendungsserver) mit dem Namen <em>targetCluster übertragen</em> .  Der Upstream-Cluster definiert die Knoten, die die Anforderung verarbeiten sollen.  Wir werden dies im nächsten Schritt diskutieren. </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://targetCluster/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_redirect</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; }</code> </pre> <br><p>  Bei Envoy macht Filter das. </p><br><h4 id="envoy-filters">  Gesandte Filter </h4><br><p>  Bei einer statischen Konfiguration bestimmen Filter, wie eingehende Anforderungen behandelt werden.  In diesem Fall setzen wir Filter, die mit <em>Servernamen</em> im vorherigen Schritt übereinstimmen.  Wenn eingehende Anforderungen eingehen, die bestimmten Domänen und Routen entsprechen, wird der Datenverkehr an den Cluster weitergeleitet.  Dies entspricht der NGINX-Upstream-Konfiguration. </p><br><pre> <code class="plaintext hljs">Copy to Editor filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: backend domains: - "one.example.com" - "www.one.example.com" routes: - match: prefix: "/" route: cluster: targetCluster http_filters: - name: envoy.router</code> </pre> <br><p>  Der Name <em>envoy.http_connection_manager</em> ist ein in Envoy Proxy integrierter Filter.  Andere Filter sind <em>Redis</em> , <em>Mongo</em> , <em>TCP</em> .  Die vollständige Liste finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . </p><br><p>  Weitere Informationen zu anderen Lastausgleichsrichtlinien finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Envoy-Dokumentation</a> . </p><br><h2 id="step-5---proxy-and-upstream-configuration">  Schritt 5 - Proxy- und Upstream-Konfiguration </h2><br><p>  In NGINX definiert die Upstream-Konfiguration die Zielserver, die den Datenverkehr verarbeiten.  In diesem Fall wurden zwei Cluster zugewiesen. </p><br><pre> <code class="nginx hljs"> <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> targetCluster { 172.18.0.3:80; 172.18.0.4:80; }</code> </pre> <br><p>  In Envoy wird es clusterverwaltet. </p><br><h4 id="envoy-clusters">  Gesandte Cluster </h4><br><p>  Das Äquivalent von Upstream wird als Cluster definiert.  In diesem Fall wurden die Hosts identifiziert, die den Datenverkehr bedienen.  Eine Methode für den Zugriff auf Hosts, z. B. ein Timeout, wird als Clusterkonfiguration definiert.  Auf diese Weise können Sie die Granularität von Aspekten wie Latenz und Lastausgleich genauer steuern. </p><br><pre> <code class="plaintext hljs">Copy to Editor clusters: - name: targetCluster connect_timeout: 0.25s type: STRICT_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN hosts: [ { socket_address: { address: 172.18.0.3, port_value: 80 }}, { socket_address: { address: 172.18.0.4, port_value: 80 }} ]</code> </pre> <br><p>  Bei Verwendung der <em>Diensterkennung STRICT_DNS löst</em> Envoy die angegebenen DNS-Ziele kontinuierlich und asynchron auf.  Jede als Ergebnis von DNS zurückgegebene IP-Adresse wird als expliziter Host im Upstream-Cluster betrachtet.  Wenn die Anforderung zwei IP-Adressen zurückgibt, geht Envoy davon aus, dass sich zwei Hosts im Cluster befinden und beide einen Lastausgleich aufweisen müssen.  Wenn der Host aus dem Ergebnis entfernt wird, geht Envoy davon aus, dass er nicht mehr vorhanden ist, und wählt Datenverkehr aus vorhandenen Verbindungspools aus. </p><br><p>  Weitere Informationen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Envoy Proxy-Dokumentation</a> . </p><br><h2 id="shag-6---dostup-k-zhurnalu-i-oshibki">  Schritt 6 - Protokollzugriff und Fehler </h2><br><p>  Die endgültige Konfiguration ist die Registrierung.  Anstatt Fehlerprotokolle auf die Festplatte zu übertragen, verwendet Envoy Proxy einen Cloud-basierten Ansatz.  Alle Anwendungsprotokolle werden in <em>stdout</em> und <em>stderr</em> angezeigt. </p><br><p>  Wenn Benutzer eine Anfrage stellen, sind Zugriffsprotokolle optional und standardmäßig deaktiviert.  Aktivieren Sie zum Aktivieren von Zugriffsprotokollen für HTTP-Anforderungen die Konfiguration <em>access_log</em> für den HTTP-Verbindungsmanager.  Der Pfad kann je nach Ihren Anforderungen entweder ein Gerät wie <em>stdout</em> oder eine Datei auf der Festplatte sein. </p><br><p>  Die folgende Konfiguration leitet alle Zugriffsprotokolle an <em>stdout um</em> (Anmerkung des Übersetzers - stdout ist für die Verwendung von envoy im Docker erforderlich. Wenn Sie ohne Docker verwenden, ersetzen Sie / dev / stdout durch den Pfad zur regulären Protokolldatei).  Kopieren Sie das Snippet in den Konfigurationsabschnitt für den Verbindungsmanager: </p><br><pre> <code class="plaintext hljs">Copy to Clipboardaccess_log: - name: envoy.file_access_log config: path: "/dev/stdout"</code> </pre> <br><p>  Die Ergebnisse sollten folgendermaßen aussehen: </p><br><pre> <code class="plaintext hljs"> - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http access_log: - name: envoy.file_access_log config: path: "/dev/stdout" route_config:</code> </pre> <br><p>  Standardmäßig verfügt Envoy über eine Formatzeichenfolge, die die Details der HTTP-Anforderung enthält: </p><br><pre> <code class="plaintext hljs">[%START_TIME%] "%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%" %RESPONSE_CODE% %RESPONSE_FLAGS% %BYTES_RECEIVED% %BYTES_SENT% %DURATION% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% "%REQ(X-FORWARDED-FOR)%" "%REQ(USER-AGENT)%" "%REQ(X-REQUEST-ID)%" "%REQ(:AUTHORITY)%" "%UPSTREAM_HOST%"\n</code> </pre> <br><p>  Das Ergebnis dieser Formatzeichenfolge: </p><br><pre> <code class="bash hljs">[2018-11-23T04:51:00.281Z] <span class="hljs-string"><span class="hljs-string">"GET / HTTP/1.1"</span></span> 200 - 0 58 4 1 <span class="hljs-string"><span class="hljs-string">"-"</span></span> <span class="hljs-string"><span class="hljs-string">"curl/7.47.0"</span></span> <span class="hljs-string"><span class="hljs-string">"f21ebd42-6770-4aa5-88d4-e56118165a7d"</span></span> <span class="hljs-string"><span class="hljs-string">"one.example.com"</span></span> <span class="hljs-string"><span class="hljs-string">"172.18.0.4:80"</span></span></code> </pre> <br><p>  Der Inhalt der Ausgabe kann durch Festlegen des Formatfelds angepasst werden.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">access_log: - name: envoy.file_access_log config: path: "/dev/stdout" format: "[%START_TIME%] "%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%" %RESPONSE_CODE% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% "%REQ(X-REQUEST-ID)%" "%REQ(:AUTHORITY)%" "%UPSTREAM_HOST%"\n"</code> </pre> <br><p>  Die Protokollzeichenfolge kann auch im JSON-Format ausgegeben werden, indem das Feld <em>json_format festgelegt</em> wird.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">access_log: - name: envoy.file_access_log config: path: "/dev/stdout" json_format: {"protocol": "%PROTOCOL%", "duration": "%DURATION%", "request_method": "%REQ(:METHOD)%"}</code> </pre> <br><p>  Weitere Informationen zu den Registrierungstechniken für Gesandte finden Sie unter </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.envoyproxy.io/docs/envoy/latest/configuration/access_log#config-access-log-format-dictionaries</a> </p><br><p>  Die Protokollierung ist nicht die einzige Möglichkeit, sich ein Bild von der Arbeit mit Envoy Proxy zu machen.  Es verfügt über integrierte erweiterte Funktionen für die Ablaufverfolgung und Metriken.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ablaufverfolgungsdokumentation</a> oder im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interaktiven</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ablaufverfolgungsskript</a> . </p><br><h2 id="shag-7---zapusk">  Schritt 7 - Starten </h2><br><p>  Jetzt haben Sie die Konfiguration von NGINX auf Envoy Proxy übertragen.  Der letzte Schritt besteht darin, eine Instanz von Envoy Proxy auszuführen, um sie zu testen. </p><br><h4 id="zapusk-ot-polzovatelya">  Vom Benutzer ausführen </h4><br><p>  Oben in der NGINX-Konfiguration befindet sich der Leitungsbenutzer <em>www www;</em>  gibt an, dass NGINX als Benutzer mit geringen Berechtigungen gestartet wurde, um die Sicherheit zu verbessern. </p><br><p>  Envoy Proxy verfolgt einen Cloud-basierten Ansatz, um zu verwalten, wem der Prozess gehört.  Wenn wir Envoy Proxy über den Container ausführen, können wir einen Benutzer mit einer niedrigen Berechtigungsstufe angeben. </p><br><h4 id="zapusk-envoy-proxy">  Starten Sie Envoy Proxy </h4><br><p>  Mit dem folgenden Befehl wird Envoy Proxy über den Docker-Container auf dem Host gestartet.  Dieser Befehl bietet Envoy die Möglichkeit, über Port 80 auf eingehende Anforderungen zu warten. Wie in der Listener-Konfiguration angegeben, wartet Envoy Proxy jedoch auf eingehenden Datenverkehr über Port 8080. Dadurch kann der Prozess als Benutzer mit geringen Berechtigungen ausgeführt werden. </p><br><pre> <code class="bash hljs">docker run --name proxy1 -p 80:8080 --user 1000:1000 -v /root/envoy.yaml:/etc/envoy/envoy.yaml envoyproxy/envoy</code> </pre> <br><h4 id="testirovanie">  Testen </h4><br><p>  Bei laufenden Proxys können jetzt Tests durchgeführt und verarbeitet werden.  Der folgende Befehl cURL gibt eine Anforderung mit dem in der Proxy-Konfiguration definierten Host-Header aus. </p><br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Host: one.example.com"</span></span> localhost -i</code> </pre> <br><p>  Eine HTTP-Anfrage führt zu Fehler <em>503</em> .  Dies liegt daran, dass Upstream-Verbindungen nicht funktionieren und nicht verfügbar sind.  Daher verfügt Envoy Proxy über keine verfügbaren Zielziele für die Anforderung.  Mit dem folgenden Befehl wird eine Reihe von HTTP-Diensten gestartet, die der für Envoy definierten Konfiguration entsprechen. </p><br><pre> <code class="bash hljs">docker run -d katacoda/docker-http-server; docker run -d katacoda/docker-http-server;</code> </pre> <br><p>  Mit den verfügbaren Diensten kann Envoy den Datenverkehr erfolgreich an sein Ziel weiterleiten. </p><br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Host: one.example.com"</span></span> localhost -i</code> </pre> <br><p>  Sie sollten eine Antwort sehen, die angibt, welcher Docker-Container die Anforderung verarbeitet hat.  In Envoy Proxy-Protokollen sollte auch die angezeigte Zugriffszeichenfolge angezeigt werden. </p><br><h4 id="dopolnitelnye-zagolovki-otveta-http-http-response">  Zusätzliche HTTP-Antwortheader </h4><br><p>  In den Antwortheadern der tatsächlichen Anforderung werden zusätzliche HTTP-Header angezeigt.  Der Header zeigt die Zeit an, die der Upstream-Host für die Verarbeitung der Anforderung aufgewendet hat.  Es wird in Millisekunden ausgedrückt.  Dies ist nützlich, wenn der Client die Servicezeit im Vergleich zur Netzwerklatenz bestimmen möchte. </p><br><pre> <code class="plaintext hljs">x-envoy-upstream-service-time: 0 server: envoy</code> </pre> <br><h2 id="itogovyy-konfig">  Endgültige Konfiguration </h2><br><pre> <code class="plaintext hljs">static_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8080 } filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: backend domains: - "one.example.com" - "www.one.example.com" routes: - match: prefix: "/" route: cluster: targetCluster http_filters: - name: envoy.router clusters: - name: targetCluster connect_timeout: 0.25s type: STRICT_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN hosts: [ { socket_address: { address: 172.18.0.3, port_value: 80 }}, { socket_address: { address: 172.18.0.4, port_value: 80 }} ] admin: access_log_path: /tmp/admin_access.log address: socket_address: { address: 0.0.0.0, port_value: 9090 }</code> </pre> <br><h2 id="dopolnitelnaya-informaciya-ot-perevodchika">  Zusätzliche Informationen vom Übersetzer </h2><br><p>  Installationsanweisungen für Envoy Proxy finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.getenvoy.io/</a> </p><br><p>  Standardmäßig gibt es in rpm keine systemd service config. </p><br><p>  Fügen Sie den systemd-Dienst config /etc/systemd/system/envoy.service hinzu: </p><br><pre> <code class="bash hljs">[Unit] Description=Envoy Proxy Documentation=https://www.envoyproxy.io/ After=network-online.target Requires=envoy-auth-server.service Wants=nginx.service [Service] User=root Restart=on-failure ExecStart=/usr/bin/envoy --config-path /etc/envoy/config.yaml [Install] WantedBy=multi-user.target</code> </pre> <br><p>  Sie müssen das Verzeichnis / etc / envoy / erstellen und dort die config.yaml-Konfiguration ablegen. </p><br><p>  Per Envoy Proxy gibt es einen Telegramm-Chat: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://t.me/envoyproxy_ru</a> </p><br><p>  Envoy Proxy unterstützt keine statische Inhaltsverteilung.  Wer kann also für das Feature stimmen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/envoyproxy/envoy/issues/378</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469455/">https://habr.com/ru/post/de469455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469445/index.html">Übersicht über AngularConnect 2019. Teil 2</a></li>
<li><a href="../de469447/index.html">Der Weg der künstlichen Intelligenz von einer fantastischen Idee zur wissenschaftlichen Industrie</a></li>
<li><a href="../de469449/index.html">EV SSL-Zertifikate: Gibt es ein Leben nach dem Tod?</a></li>
<li><a href="../de469451/index.html">Philosophie der Null</a></li>
<li><a href="../de469453/index.html">Management eines verteilten Teams im Multiprojektmodus (Überprüfung und Videobericht)</a></li>
<li><a href="../de469457/index.html">Wohin Extravaganza führt</a></li>
<li><a href="../de469459/index.html">Anschließen von IoT-Geräten in der Smart City</a></li>
<li><a href="../de469461/index.html">"Zu den Sternen": Anti-Kosmische "Apokalypse heute"</a></li>
<li><a href="../de469463/index.html">Trends und Prognosen in der Verarbeitung natürlicher Sprache</a></li>
<li><a href="../de469465/index.html">Initialisierung in modernem C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>