<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏻 🧖🏼 💏 Unity中的六边形图：保存和加载，纹理，距离 🤸🏾 👨‍🏫 👨🏿‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第1-3部分：网格，颜色和像元高度 

 第4-7部分：颠簸，河流和道路 

 第8-11部分：水，地貌和城墙 

 第12-15部分：保存和加载，纹理，距离 

 第16-19部分：找到道路，队员，动画 

 第20-23部分：战争迷雾，地图研究，程序生成 

 第24-27部分：水循环，侵蚀，生...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity中的六边形图：保存和加载，纹理，距离</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425919/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1-3部分：网格，颜色和像元高度</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4-7部分：颠簸，河流和道路</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8-11部分：水，地貌和城墙</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第12-15部分：保存和加载，纹理，距离</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第16-19部分：找到道路，队员，动画</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第20-23部分：战争迷雾，地图研究，程序生成</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第24-27部分：水循环，侵蚀，生物群落，圆柱图</a> <br><br><h1> 第12部分：保存和加载 </h1><br><ul><li> 跟踪地形的类型，而不是颜色。 </li><li> 创建一个文件。 </li><li> 我们将数据写入文件，然后读取它。 </li><li> 我们序列化单元格数据。 </li><li> 减小文件大小。 </li></ul><br> 我们已经知道如何创建非常有趣的地图。 现在，您需要学习如何保存它们。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/2ce/740/7bb2ce7409d37733e3b6f96c237ce1e9.jpg"></div><a name="habracut"></a><br>  <i>从<a href="">test.map</a>文件加载。</i> <br><br><h2> 地形类型 </h2><br> 保存地图时，我们不需要存储在应用程序执行过程中跟踪的所有数据。 例如，我们只需要记住像元高度级别。 它的垂直位置本身就是从此数据中获取的，因此您无需存储它。 实际上，最好不要存储这些计算得出的指标。 因此，即使以后我们决定更改高度偏移，地图数据也将保持正确。 数据与其表示是分开的。 <br><br> 同样，我们不需要存储单元格的确切颜色。 您可以写出该单元格为绿色。 但是，确切的绿色阴影会随着视觉样式的改变而改变。 为此，我们可以保存颜色索引，而不是颜色本身。 实际上，对于我们来说，在运行时在单元格中存储此索引而不是真实颜色可能就足够了。 这将允许以后继续进行浮雕的更复杂的可视化。 <br><br><h3> 移动颜色阵列 </h3><br> 如果单元格不再具有颜色数据，则应将其存储在其他位置。 将其存储在<code>HexMetrics</code>最方便。 因此，让我们为其添加颜色数组。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color[] colors;</code> </pre> <br> 像所有其他全局数据（例如噪声）一样，我们可以使用<code>HexGrid</code>初始化这些颜色。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; } }</code> </pre> <br> 并且由于现在我们不直接将颜色分配给单元格，因此我们将摆脱默认颜色。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color defaultColor = Color.white; … void CreateCell (int x, int z, int i) { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); // cell.Color = defaultColor; … }</span></span></code> </pre> <br> 设置新颜色以匹配六边形图编辑器的常规数组。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bf/3cb/002/4bf3cb002342f9ab3aa482cf3a526042.png"></div><br>  <i>将颜色添加到网格。</i> <br><br><h3> 单元重构 </h3><br> 从<code>HexCell</code>删除颜色字段。 相反，我们将存储索引。 代替颜色索引，我们使用更通用的浮雕类型索引。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Color color; int terrainTypeIndex;</span></span></code> </pre> <br>  color属性只能使用此索引来获取相应的颜色。 现在未直接设置，因此删除此部分。 在这种情况下，我们会收到一个编译错误，我们将尽快修复。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.colors[terrainTypeIndex]; } <span class="hljs-comment"><span class="hljs-comment">// set { // … // } }</span></span></code> </pre> <br> 添加新属性以获取并设置新的高程类型索引。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } }</code> </pre> <br><h3> 编辑器重构 </h3><br> 在<code>HexMapEditor</code>内部<code>HexMapEditor</code>删除所有与颜色有关的代码。 这将修复编译错误。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; … // Color activeColor; … // bool applyColor; … // public void SelectColor (int index) { // applyColor = index &gt;= 0; // if (applyColor) { // activeColor = colors[index]; // } // } … // void Awake () { // SelectColor(0); // } … void EditCell (HexCell cell) { if (cell) { // if (applyColor) { // cell.Color = activeColor; // } … } }</span></span></code> </pre> <br> 现在添加一个字段和方法来控制活动高程类型索引。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeTerrainTypeIndex; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainTypeIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeTerrainTypeIndex = index; }</code> </pre> <br> 我们使用此方法代替现在缺少的<code>SelectColor</code>方法。 使用<code>SetTerrainTypeIndex</code>连接UI中的颜色小部件，其他所有内容保持不变。 这意味着负索引仍在使用中，意味着颜色不应更改。 <br><br> 更改<code>EditCell</code>以便将高程类型索引分配给正在编辑的像元。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activeTerrainTypeIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.TerrainTypeIndex = activeTerrainTypeIndex; } … } }</code> </pre> <br> 尽管我们从单元格中删除了颜色数据，但该贴图应与以前一样工作。 唯一的区别是默认颜色现在是数组中的第一个。 就我而言，它是黄色的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/e7e/6ac/8cce7e6acb202e119a6e7d5cdae2db74.png"></div><br>  <i>黄色是新的默认颜色。</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">统一包装</a> <br><br><h2> 将数据保存到文件 </h2><br> 为了控制地图的保存和加载，我们使用<code>HexMapEditor</code> 。 我们将创建两个方法来执行此操作，现在将它们留空。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br> 将两个按钮添加到UI（ <em>GameObject / UI / Button</em> ）。 将它们连接到按钮并给出适当的标签。 我将它们放在右侧面板的底部。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/eba/96b/6eceba96bb5ff18fd0b4ad9472a19695.png"></div><br>  <i>保存和加载按钮。</i> <br><br><h3> 档案位置 </h3><br> 要存储卡，您需要将其保存在某处。 与大多数游戏一样，我们会将数据存储在文件中。 但是，将此文件放在文件系统中的何处？ 答案取决于游戏运行在哪个操作系统上。 每个操作系统都有自己的标准来存储与应用程序相关的文件。 <br><br> 我们不需要知道这些标准。  Unity知道我们可以使用<code>Application.persistentDataPath</code>获得正确的路径。 您可以在“ <code>Save</code>方法中检查它的状态，在控制台中显示它，然后在“播放”模式下按按钮。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(Application.persistentDataPath); }</code> </pre> <br> 在台式机系统上，路径将包含公司和产品的名称。 编辑器和程序集均使用此路径。 可以在“ <em>编辑” /“项目设置” /“播放器”中</em>配置名称。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/a60/056/656a60056f9d51c5a5f3d81762135b87.png"></div><br>  <i>公司和产品名称。</i> <br><br><div class="spoiler">  <b class="spoiler_title">为什么在Mac上找不到“库”文件夹？</b> <div class="spoiler_text">  <em>库</em>文件夹通常是隐藏的。 显示方式取决于OS X的版本。如果您没有旧版本，请在Finder中选择主文件夹，然后转到<em>显示视图选项</em> 。 有一个用于<em>库</em>文件夹的复选框。 </div></div><br><div class="spoiler">  <b class="spoiler_title">WebGL呢？</b> <div class="spoiler_text">  WebGL游戏无法访问用户的文件系统。 而是将所有文件操作都重定向到内存中的文件系统。 她对我们透明。 但是，要保存数据，您将需要手动订购网页以将数据转储到浏览器存储中。 </div></div><br><h3> 文件创建 </h3><br> 要创建文件，我们需要使用<code>System.IO</code>命名空间中的类。 因此，我们在<code>HexMapEditor</code>类上为其添加了<code>using</code>语句。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … }</code> </pre> <br> 首先，我们需要创建文件的完整路径。 我们使用<em>test.map</em>作为文件<em>名</em> 。 必须将其添加到存储数据的路径中。 是否需要插入正斜杠或反斜杠（斜杠或反斜杠）取决于平台。  <code>Path.Combine</code>方法将<code>Path.Combine</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); }</code> </pre> <br> 接下来，我们需要在此位置访问文件。 我们使用<code>File.Open</code>方法执行此操作。 由于我们想将数据写入此文件，因此我们需要使用其创建模式。 在这种情况下，将在指定路径上创建一个新文件，或者替换一个现有文件。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); File.Open(path, FileMode.Create);</code> </pre> <br> 调用此方法的结果将是与此文件关联的打开数据流。 我们可以使用它将数据写入文件。 而且，当我们不再需要它时，我们一定不要忘记关闭它。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); Stream fileStream = File.Open(path, FileMode.Create); fileStream.Close();</code> </pre> <br> 在此阶段，当您单击“ <em>保存”</em>按钮时，将在指定为存储数据路径的文件夹中创建<em>test.map</em>文件。 如果您研究此文件，它将是空的，大小为0字节，因为到目前为止我们还没有写任何东西。 <br><br><h3> 写入文件 </h3><br> 要将数据写入文件，我们需要一种将数据流式传输到文件的方法。 最简单的方法是使用<code>BinaryWriter</code> 。 这些对象使您可以将原始数据写入任何流。 <br><br> 创建一个新的<code>BinaryWriter</code>对象，我们的文件流将作为其参数。 关闭编写器将关闭其使用的流。 因此，我们不再需要存储到流的直接链接。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Close();</code> </pre> <br> 要将数据传输到流，可以使用<code>BinaryWriter.Write</code>方法。 所有基本类型（例如整数和浮点型）的<code>Write</code>方法都有一个变体。 它还可以记录行。 让我们尝试写整数123。 <br><br><pre> <code class="cs hljs"> BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); writer.Close();</code> </pre> <br> 单击<em>保存</em>按钮， <em>然后</em>再次检查<em>test.map</em> 。 现在，它的大小为4个字节，因为整数大小为4个字节。 <br><br><div class="spoiler">  <b class="spoiler_title">为什么我的文件管理器显示文件占用更多空间？</b> <div class="spoiler_text"> 因为文件系统将空间分成字节块。 它们不跟踪单个字节。 到目前为止，由于<em>test.map</em>仅占用四个字节，因此它需要一块存储空间。 </div></div><br> 请注意，我们存储二进制数据，而不是人类可读的文本。 因此，如果我们在文本编辑器中打开文件，我们将看到一组模糊的字符。 您可能会看到符号<em>{，</em>后面没有任何空格或一些占位符。 <br><br> 您可以在十六进制编辑器中打开文件。 在这种情况下，我们将看到<em>7b 00 00 00</em> 。 这是整数的四个字节，以十六进制表示法映射。 在普通十进制数中，这是<em>123 0 0 0</em> 。 以二进制形式，第一个字节看起来像<em>01111011</em> 。 <br><br>  <em>{</em>的ASCII码是123，因此可以在文本编辑器中显示此字符。  ASCII 0是一个空字符，与任何可见字符都不匹配。 <br><br> 剩余的三个字节等于零，因为我们写的数字小于256。如果我们写的是256，则在十六进制编辑器中将看到<em>00 01 00 00</em> 。 <br><br><div class="spoiler">  <b class="spoiler_title">123不应存储为00 00 00 7b吗？</b> <div class="spoiler_text">  <code>BinaryWriter</code>使用Little-endian格式保存数字。 这意味着最低有效字节将首先被写入。  Microsoft在开发.Net框架时使用了这种格式。 之所以选择它，是因为Intel CPU使用低位字节序格式。 <br><br> 一种替代方法是big-endian，其中最高有效字节先存储在其中。 这对应于数字中通常的数字顺序。  123是123，因为我们指的是大端记录。 如果是小端，则123表示三百二十一。 </div></div><br><h3> 我们释放资源 </h3><br> 关闭作家很重要。 打开文件系统后，文件系统将锁定文件，从而防止其他进程对其进行写入。 如果我们忘记关闭它，我们也会阻止自己。 如果我们两次按保存按钮，则第二次将无法打开流。 <br><br> 无需手动关闭编写器，我们可以为此创建一个<code>using</code>块。 它定义了作者有效的范围。 当可执行代码超出此范围时，将删除编写器并关闭线程。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// writer.Close();</span></span></code> </pre> <br> 这将起作用，因为writer和文件流类实现了<code>IDisposable</code>接口。 这些对象具有<code>Dispose</code>方法，当它们超出use的范围时会间接调用。 <br><br> 使用的最大好处是，无论程序超出范围如何，它都可以工作。 早期的回报，例外和错误不会打扰他。 另外，他非常简洁。 <br><br><h3> 资料检索 </h3><br> 要读取以前写入的数据，我们需要将代码插入<code>Load</code>方法。 与保存时一样，我们需要创建路径并打开文件流。 不同之处在于，现在我们打开文件进行读取，而不是写入。 而不是writer我们需要<code>BinaryReader</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.Open(path, FileMode.Open)) ) { } }</code> </pre> <br> 在这种情况下，我们可以使用<code>File.OpenRead</code>方法打开文件进行读取。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">为什么在编写时不能使用File.OpenWrite？</b> <div class="spoiler_text"> 此方法创建一个流，该流将数据添加到现有文件中，而不是替换它们。 </div></div><br> 阅读时，我们需要明确指出接收到的数据类型。 要从流中读取整数，我们需要使用<code>BinaryReader.ReadInt32</code> 。 此方法读取一个32位整数，即四个字节。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { Debug.Log(reader.ReadInt32()); }</code> </pre> <br> 应该注意的是，当接收到<em>123时，</em>足以读取一个字节。 但同时，流中将保留属于该整数的三个字节。 此外，这不适用于0-255范围以外的数字。 因此，请不要这样做。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">统一包装</a> <br><br><h2> 写入和读取地图数据 </h2><br> 保存数据时，一个重要的问题是是否使用人类可读的格式。 通常，人类可读格式为JSON，XML和具有某种结构的纯ASCII。 可以在文本编辑器中打开，解释和编辑此类文件。 此外，它们简化了不同应用程序之间的数据交换。 <br><br> 但是，此类格式有其自己的要求。 与使用二进制数据相比，文件将占用更多的空间（有时更多）。 从运行时和内存占用两方面来看，它们还可以大大增加编码和解码数据的成本。 <br><br> 相反，二进制数据是紧凑且快速的。 当记录大量数据时，这一点很重要。 例如，在游戏的每个回合中自动保存大地图时。 因此 <br> 我们将使用二进制格式。 如果可以处理，则可以使用更详细的格式。 <br><br><div class="spoiler">  <b class="spoiler_title">自动序列化呢？</b> <div class="spoiler_text"> 在序列化Unity数据的过程中，我们可以立即将序列化的类直接写入流中。 各个字段的记录详细信息将对我们隐藏。 但是，我们无法直接序列化单元格。 它们是<code>MonoBehaviour</code>类，其中包含我们不需要保存的数据。 因此，我们需要使用一个单独的对象层次结构，这破坏了自动序列化的简单性。 另外，支持将来的代码更改将更加困难。 因此，我们将通过手动序列化来保持完全控制。 此外，这将使我们真正了解正在发生的事情。 </div></div><br> 要序列化地图，我们需要存储每个单元格的数据。 要保存和加载单个单元格，请将<code>Save</code>和<code>Load</code>方法添加到<code>HexCell</code> 。 由于它们需要作者或读者才能工作，因此我们将其添加为参数。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br> 将<code>Save</code>和<code>Load</code>方法添加到<code>HexGrid</code> 。 这些方法只是通过调用其<code>Load</code>和<code>Save</code>方法来绕过所有单元格。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } } }</code> </pre> <br> 如果我们下载地图，则在更改单元格数据后需要对其进行更新。 为此，只需更新所有片段。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br> 最后，我们<code>HexMapEditor</code>的测试代码替换为对网格的<code>Save</code>和<code>Load</code>方法的调用，并<code>HexMapEditor</code>器或读取器。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { hexGrid.Load(reader); } }</code> </pre> <br><h3> 保存浮雕类型 </h3><br> 在当前阶段，重新保存将创建一个空文件，而下载则不执行任何操作。 让我们从仅记录和加载<code>HexCell</code>高程类型索引开始。 <br><br> 将值直接分配给terrainTypeIndex字段。 我们将不使用属性。 由于我们显式更新了所有片段，因此无需调用<code>Refresh</code>属性。 另外，由于我们仅保存正确的地图，因此我们假设所有下载的地图也是正确的。 因此，例如，我们不会检查河流或道路是否允许。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); }</code> </pre> <br> 当保存到该文件时，所有单元的浮雕类型的索引将被依次写入。 由于索引是整数，因此其大小为四个字节。 我的卡包含300个单元，即文件大小为1200个字节。 <br><br> 负载以与写入索引相同的顺序读取索引。 如果在保存后更改了单元格的颜色，则加载贴图会将颜色恢复为保存时的状态。 由于我们不再保存任何内容，因此其余的单元格数据将保持不变。 也就是说，加载将改变地形的类型，但不会改变其高度，水位，地形特征等。 <br><br><h3> 保存所有整数 </h3><br> 保存救济类型索引对我们来说还不够。 您需要保存所有其他数据。 让我们从所有整数字段开始。 这是浮雕类型，单元高度，水位，城市水平，农场水平，植被水平和特殊对象的索引。 必须按照记录时的顺序读取它们。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); }</code> </pre> <br> 现在尝试保存和加载地图，在这些操作之间进行更改。 除存储单元的高度外，我们已尽力恢复了存储在存储数据中的所有内容。 发生这种情况的原因是，当您更改高度级别时，需要更新单元格的垂直位置。 可以通过将其分配给属性（而不是字段）（已加载高度的值）来完成。 但是此属性完成了我们不需要的其他工作。 因此，让我们从“ <code>Elevation</code>设置器中提取更新单元格位置的代码，并将其插入到单独的<code>RefreshPosition</code>方法中。 您需要在此处进行的唯一更改是<code>value</code>对<code>elevation</code>字段<code>value</code>引用替换<code>value</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 position = transform.localPosition; position.y = elevation * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; }</code> </pre> <br> 现在，我们可以在设置属性时以及加载高度数据后调用该方法。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshPosition(); ValidateRivers(); … } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); … }</code> </pre> <br> 进行此更改后，单元将在加载时正确更改其外观高度。 <br><br><h3> 保存所有数据 </h3><br> 单元中是否存在墙和流入/流出的河流存储在布尔字段中。 我们可以简单地将它们写为整数。 此外，道路数据是六个布尔值的数组，我们可以使用循环来编写它们。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write(hasOutgoingRiver); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { writer.Write(roads[i]); } }</code> </pre> <br> 入库河和出库河的方向存储在<code>HexDirection</code>字段中。  <code>HexDirection</code>类型是一个枚举，在内部存储为多个整数值。 因此，我们还可以使用显式转换将它们序列化为整数。 <br><br><pre> <code class="cs hljs"> writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)outgoingRiver);</code> </pre> <br> 使用<code>BinaryReader.ReadBoolean</code>方法读取布尔值。 河流的方向是整数，我们必须将其转换回<code>HexDirection</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadInt32(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = reader.ReadBoolean(); } }</code> </pre> <br> 现在，我们保存了完整保存和还原地图所需的所有像元数据。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个单元需要9个整数和9个布尔值。</font><font style="vertical-align: inherit;">每个布尔值占用一个字节，因此每个单元格总共使用45个字节。</font><font style="vertical-align: inherit;">即，具有300个单元的卡总共需要13,500字节。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 缩小档案大小 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管对于300个单元来说，似乎13,500字节不是很多，但是也许我们可以用更少的空间来完成。</font><font style="vertical-align: inherit;">最后，我们可以完全控制数据的序列化方式。</font><font style="vertical-align: inherit;">让我们看看是否有一种更紧凑的方式来存储它们。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 数值间隔减少 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同的单元格级别和索引存储为整数。</font><font style="vertical-align: inherit;">但是，它们仅使用较小范围的值。</font><font style="vertical-align: inherit;">它们中的每个绝对将保持在0-255的范围内。</font><font style="vertical-align: inherit;">这意味着将仅使用每个整数的第一个字节。</font><font style="vertical-align: inherit;">其余三个始终为零。</font><font style="vertical-align: inherit;">存储这些空字节没有任何意义。</font><font style="vertical-align: inherit;">我们可以通过在写入流之前将整数写入字节来丢弃它们。</font></font><br><br><pre> <code class="cs hljs"> writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)elevation); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)waterLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)urbanLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)farmLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)plantLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)outgoingRiver);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，要返回这些数字，我们必须使用</font></font><code>BinaryReader.ReadByte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从字节到整数的转换是隐式完成的，因此我们不需要添加显式转换。</font></font><br><br><pre> <code class="cs hljs"> terrainTypeIndex = reader.ReadByte(); elevation = reader.ReadByte(); RefreshPosition(); waterLevel = reader.ReadByte(); urbanLevel = reader.ReadByte(); farmLevel = reader.ReadByte(); plantLevel = reader.ReadByte(); specialIndex = reader.ReadByte(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadByte(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadByte();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们摆脱了每个整数三个字节的位置，每个单元节省了27个字节。现在，我们每个单元花费18个字节，而每300个单元仅花费5400个字节。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值得注意的是，旧卡数据在此阶段变得毫无意义。加载旧的保存文件时，数据会混合在一起，从而导致单元格混乱。这是因为我们现在正在读取更少的数据。如果读取的数据比以前更多，则尝试读取文件末尾之外的内容时会出现错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法处理旧数据非常适合我们，因为我们正在确定格式。</font><font style="vertical-align: inherit;">但是，当我们决定保存格式时，我们将需要确保将来的代码始终可以读取它。</font><font style="vertical-align: inherit;">即使我们更改了格式，理想情况下，我们仍然应该能够读取旧格式。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 河字节联盟 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此阶段，我们使用四个字节存储河流数据，每个方向两个。</font><font style="vertical-align: inherit;">对于每个方向，我们都存储河流的存在及其流动方向，这</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然很明显不需要存储河流的方向。</font><font style="vertical-align: inherit;">这意味着没有河流的单元需要少两个字节。</font><font style="vertical-align: inherit;">实际上，无论河流的存在与否，只要向河的方向发送一个字节就足够了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有六个可能的方向，它们以数字形式存储在0-5之间。</font><font style="vertical-align: inherit;">三位就足够了，因为从0到5的二进制形式的数字看起来像000、001、010、011、100、101和110。也就是说，再有五个未使用的字节。</font><font style="vertical-align: inherit;">我们可以使用其中之一来指示是否存在河流。</font><font style="vertical-align: inherit;">例如，您可以使用对应于数字128的第八位，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，在将方向转换为字节之前，我们将在其上添加128。即，如果有一条河流流向西北，我们将写入133，其二进制形式为10000101。如果没有河流，那么我们只写一个零字节。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同时，还有四位未使用，但这是正常的。</font><font style="vertical-align: inherit;">我们可以将河流的两个方向合并为一个字节，但这已经太混乱了。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// writer.Write(hasIncomingRiver); // writer.Write((byte)incomingRiver); if (hasIncomingRiver) { writer.Write((byte)(incomingRiver + 128)); } else { writer.Write((byte)0); } // writer.Write(hasOutgoingRiver); // writer.Write((byte)outgoingRiver); if (hasOutgoingRiver) { writer.Write((byte)(outgoingRiver + 128)); } else { writer.Write((byte)0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要解码河流数据，我们首先需要读回字节。</font><font style="vertical-align: inherit;">如果其值不小于128，则意味着有一条河。</font><font style="vertical-align: inherit;">要获得其方向，请减去128，然后转换为</font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// hasIncomingRiver = reader.ReadBoolean(); // incomingRiver = (HexDirection)reader.ReadByte(); byte riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasIncomingRiver = true; incomingRiver = (HexDirection)(riverData - 128); } else { hasIncomingRiver = false; } // hasOutgoingRiver = reader.ReadBoolean(); // outgoingRiver = (HexDirection)reader.ReadByte(); riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasOutgoingRiver = true; outgoingRiver = (HexDirection)(riverData - 128); } else { hasOutgoingRiver = false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，我们每个单元得到16个字节。</font><font style="vertical-align: inherit;">改进似乎并不大，但这是用于减少二进制数据大小的技巧之一。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将道路保存在一个字节中 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使用类似的技巧来压缩道路数据。</font><font style="vertical-align: inherit;">我们有六个布尔值，可以存储在一个字节的前六位中。</font><font style="vertical-align: inherit;">也就是说，道路的每个方向都由2的幂表示。</font><font style="vertical-align: inherit;">它们是1、2、4、8、16和32，或二进制格式1、10、100、1000、10000和100000。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要创建完成的字节，我们需要设置与所用道路方向相对应的位。</font><font style="vertical-align: inherit;">为了获得正确的方向，我们可以使用运算符</font></font><code>&lt;&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后使用按位或运算符将它们合并。</font><font style="vertical-align: inherit;">例如，如果使用第一，第二，第三和第六条道路，那么完成的字节将为100111。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// writer.Write(roads[i]); if (roads[i]) { roadFlags |= 1 &lt;&lt; i; } } writer.Write((byte)roadFlags);</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;&lt;如何工作？</font></font></b> <div class="spoiler_text">     .   integer      .  .     integer .    ,          .   <code>1 &lt;&lt; n</code>  2 <sup>n</sup> ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要获取返回的布尔值，您需要检查该位是否已设置。</font><font style="vertical-align: inherit;">如果是这样，则使用具有适当数字的按位与运算符屏蔽所有其他位。</font><font style="vertical-align: inherit;">如果结果不等于零，则该位被设置并且道路存在。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = (roadFlags &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将六个字节压缩成一个字节后，我们每个单元收到11个字节。</font><font style="vertical-align: inherit;">对于300个单元，这仅为3,300字节。</font><font style="vertical-align: inherit;">也就是说，在处理了一些字节之后，我们将文件大小减少了75％。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为未来做好准备 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在宣布我们的保存格式完整之前，我们再添加一个细节。</font><font style="vertical-align: inherit;">在保存地图数据之前，我们将强制</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写入整数零。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">0</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这会将四个空字节添加到数据的开头。</font><font style="vertical-align: inherit;">也就是说，在加载卡之前，我们必须读取这四个字节。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { reader.ReadInt32(); hexGrid.Load(reader); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管到目前为止这些字节是无用的，但它们被用作标头，将来会提供向后兼容性。</font><font style="vertical-align: inherit;">如果我们没有添加这些空字节，那么前几个字节的内容取决于映射的第一个单元格。</font><font style="vertical-align: inherit;">因此，将来我们很难确定我们要处理的是哪种版本的保存格式。</font><font style="vertical-align: inherit;">现在我们可以检查前四个字节。</font><font style="vertical-align: inherit;">如果它们为空，那么我们正在处理格式为0的版本。在将来的版本中，可以在其中添加其他内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，如果标题不为零，则我们正在处理某些未知版本。</font><font style="vertical-align: inherit;">由于我们无法找到存在的数据，因此我们必须拒绝下载地图。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } }</code> </pre> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第13部分：卡管理 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们在“播放”模式下创建新卡。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 添加对各种卡大小的支持。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将地图的大小添加到保存的数据。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保存和加载任意地图。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 显示卡列表。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这一部分中，我们将添加对各种大小的卡的支持，以及保存不同的文件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从这一部分开始，将在Unity 5.5.0中创建教程。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/9e2/1e4/abd9e21e467d0b291c33f4ad31e96c51.jpg"></div><br> <i><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图库</font><a href=""><font style="vertical-align: inherit;">的开始</font></a><font style="vertical-align: inherit;">。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建新地图 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，在加载场景时，我们仅创建了一次六边形网格。</font><font style="vertical-align: inherit;">现在，我们将可以随时启动新地图。</font><font style="vertical-align: inherit;">新卡将仅替换当前卡。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Awake中</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，初始化了一些指标，然后确定了单元数，并创建了必要的片段和单元。</font><font style="vertical-align: inherit;">创建一组新的片段和单元格，然后创建一个新地图。</font><font style="vertical-align: inherit;">让我们</font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分为两部分-初始化源代码和常规方法</font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在用户界面中添加按钮以创建新地图。</font><font style="vertical-align: inherit;">我把它变大了，并放在保存和加载按钮下面。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c02/ff4/203c02ff4ca668836064c72ad770328c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新地图按钮。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们</font><font style="vertical-align: inherit;">将该按钮</font><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Click</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件</font><font style="vertical-align: inherit;">与</font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object </font><font style="vertical-align: inherit;">方法联系起来</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">也就是说，我们将不通过</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十六进制地图编辑器</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而是直接调用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十六进制网格</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象方法</font><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d04/a3e/36ad04a3ebf94b00faf7aebe8c783b2f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过单击创建地图。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 清除旧数据 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，当您单击</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮时</font><font style="vertical-align: inherit;">，将创建一组新的片段和单元格。</font><font style="vertical-align: inherit;">但是，旧的文件不会自动删除。</font><font style="vertical-align: inherit;">因此，结果，我们得到了几个相互叠加的地图网格。</font><font style="vertical-align: inherit;">为了避免这种情况，我们首先需要清除旧对象。</font><font style="vertical-align: inherit;">这可以通过在开始时销毁所有当前片段来完成</font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以重用现有对象吗？</font></font></b> <div class="spoiler_text">  ,         .     ,       .  ,    —    ,      . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否可以循环破坏像这样的子元素？</font></font></b> <div class="spoiler_text"> 当然可以         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 指定单元格中的大小而不是片段 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们通过字段</font></font><code>chunkCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>chunkCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">设置地图的大小时</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，在单元格中指示地图的大小将更加方便。</font><font style="vertical-align: inherit;">同时，我们甚至可以在将来更改片段的大小而无需更改卡的大小。</font><font style="vertical-align: inherit;">因此，让我们交换单元数和片段数字段的角色。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int chunkCountX = 4, chunkCountZ = 3; public int cellCountX = 20, cellCountZ = 15; … // int cellCountX, cellCountZ; int chunkCountX, chunkCountZ; … public void CreateMap () { … // cellCountX = chunkCountX * HexMetrics.chunkSizeX; // cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这将导致编译错误，因为它</font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用片段大小</font><font style="vertical-align: inherit;">来限制其position </font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">进行更改，</font></font><code>HexMapCamera.ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便他直接使用仍需要的单元数。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个片段的大小为5 x 5单元，默认情况下，地图的大小为4 x 3片段。</font><font style="vertical-align: inherit;">因此，要使卡保持相同，我们将必须使用20 x 15单元格的大小。</font><font style="vertical-align: inherit;">尽管我们已经在代码中分配了默认值，但是网格对象仍然不会自动使用它们，因为这些字段已经存在并且默认为0。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/2e3/da6/3992e3da66fb278c396e15a3d339707a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，卡的大小为20 x 15。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 自定义卡尺寸 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一步将支持创建任意大小的卡片，而不仅仅是默认大小。</font><font style="vertical-align: inherit;">为此，将</font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X和Z </font><font style="vertical-align: inherit;">添加到</font><font style="vertical-align: inherit;">参数中，它们将替换现有的单元格数量。</font><font style="vertical-align: inherit;">在内部，</font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将使用当前单元格的数量来调用它们。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，这仅在单元格数量为片段大小倍数的情况下才能正常工作。</font><font style="vertical-align: inherit;">否则，整数除法将产生太少的片段。</font><font style="vertical-align: inherit;">尽管我们可以添加对部分填充有单元格的片段的支持，但我们仅禁止使用与片段不对应的大小。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使用运算符</font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来计算将单元数除以片段数的余数。</font><font style="vertical-align: inherit;">如果不等于零，则存在差异，我们将不会创建新地图。</font><font style="vertical-align: inherit;">在执行此操作的同时，让我们增加针对零和负大小的保护。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 新卡菜单 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在当前阶段，“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新地图”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮</font><font style="vertical-align: inherit;">不再起作用，因为该方法</font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在具有两个参数。我们无法将Unity事件直接连接到此类方法。另外，要支持不同大小的卡，我们需要一些按钮。不用将所有这些按钮添加到主UI中，而是创建一个单独的弹出菜单。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在场景中添加一个新的画布（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Canvas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。我们将使用与现有画布相同的设置，不同之处在于其“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排序顺序”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应等于1。因此，它将位于主编辑器UI的顶部。我将画布和事件系统都设为新UI对象的子级，以使场景层次结构保持整洁。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c91/6c5/c2c/c916c5c2cee3f58576b12ac1a052bd64.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3be/a8b/79b/3bea8b79bae11a493aea43590394b0a3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画布菜单新地图。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font><font style="vertical-align: inherit;">面板</font><font style="vertical-align: inherit;">添加到“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新地图菜单”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以关闭整个屏幕。</font><font style="vertical-align: inherit;">需要使背景变暗，并且在菜单打开时不允许光标与其他所有东西交互。</font><font style="vertical-align: inherit;">我给它提供了统一的颜色，清除了它的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Image</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并将</font><font style="vertical-align: inherit;">（0，0，0，200）设置</font><font style="vertical-align: inherit;">为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/1f0/a4f/16c1f0a4f31e0769099b845794a83b4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">背景图像设置。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将菜单栏添加到画布的中心，类似于</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">面板</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们为她的小，中，大卡创建一个清晰的标签和按钮。</font><font style="vertical-align: inherit;">如果玩家改变主意，我们还将为她添加一个取消按钮。</font><font style="vertical-align: inherit;">完成设计的创建后，请停用整个“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新地图菜单”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/0d9/584/c0a0d95847337d91b97a823312c98a43.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/917/3a1/7c3/9173a17c38f4c6e35f258c407b44d710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新地图菜单。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要管理菜单，请创建一个组件</font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其添加到画布的“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新地图菜单”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要创建新地图，我们需要访问</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，我们向其中添加一个公共字段并将其连接。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NewMapMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/a25/c3e/f7da25c3ed3ebf12ba9f4785b19ec8e1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新地图菜单的组件。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 开闭 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过简单地激活和禁用画布对象来打开和关闭弹出菜单。</font><font style="vertical-align: inherit;">让我们添加</font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个常用方法来执行此操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，将</font><font style="vertical-align: inherit;">编辑器</font><font style="vertical-align: inherit;">的“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新建地图</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI” </font><font style="vertical-align: inherit;">按钮连接</font><font style="vertical-align: inherit;">到</font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新建地图菜单”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象中的方法</font><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b84/100/590/b841005902c164f5eb1dcab4f39c4221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按下以打开菜单。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同时将“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取消”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮连接</font><font style="vertical-align: inherit;">到方法</font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这将使我们能够打开和关闭弹出菜单。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建新地图 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要创建新地图，我们需要在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象中调用</font><font style="vertical-align: inherit;">方法</font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此外，此后，我们需要关闭弹出菜单。</font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑到任意大小，将其</font><font style="vertical-align: inherit;">添加到</font><font style="vertical-align: inherit;">将要处理</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">方法中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此方法不应通用，因为我们仍然无法将其直接连接到按钮事件。</font><font style="vertical-align: inherit;">而是，为每个按钮创建一个将以</font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定大小</font><font style="vertical-align: inherit;">调用的方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对于小地图，我使用20乘15的大小，对应于地图的默认大小。</font><font style="vertical-align: inherit;">对于中间卡，我决定将此大小加倍，即40乘30，然后再对大卡再次加倍。</font><font style="vertical-align: inherit;">用适当的方法连接按钮。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSmallMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMediumMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLargeMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 相机锁 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以使用弹出菜单创建三种不同尺寸的新地图！一切正常，但我们需要注意一些细节。当“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新地图菜单”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处于活动状态时，我们不能再与编辑器的用户界面和单元格进行交互。但是，我们仍然可以控制摄像机。理想情况下，打开菜单后，相机应锁定。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们只有一台相机，因此一种快速而务实的解决方案是简单地向其中添加静态属性</font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。对于广泛使用，此解决方案不是很合适，但对于我们的简单界面而言，就足够了。这要求我们跟踪其中的静态实例</font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">实例</font><font style="vertical-align: inherit;">是在Awake摄像头时设置的。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexMapCamera instance; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以是仅带有setter的简单静态布尔属性。</font><font style="vertical-align: inherit;">它所做的只是</font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在锁定</font><font style="vertical-align: inherit;">实例</font><font style="vertical-align: inherit;">时</font><font style="vertical-align: inherit;">关闭实例</font><font style="vertical-align: inherit;">，而在解锁</font><font style="vertical-align: inherit;">实例</font><font style="vertical-align: inherit;">时</font><font style="vertical-align: inherit;">将实例</font><font style="vertical-align: inherit;">打开。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Locked { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { instance.enabled = !<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，它</font></font><code>NewMapMenu.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以挡住相机了，并且</font></font><code>NewMapMenu.Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-将其解锁。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保持正确的相机位置 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相机还有另一个可能的问题。</font><font style="vertical-align: inherit;">当创建的新地图小于当前地图时，相机可能会出现在地图边界之外。</font><font style="vertical-align: inherit;">她将一直呆在那里，直到玩家尝试移动相机为止。</font><font style="vertical-align: inherit;">只有这样，它才会受到新地图限制的限制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了解决这个问题，我们可以添加</font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static方法</font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">调用</font></font><code>AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">零偏移量</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">实例</font><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">将迫使相机移动到地图的边界。</font><font style="vertical-align: inherit;">如果相机已经在新地图的边界内，则它将保持在原位。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidatePosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.AdjustPosition(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>NewMapMenu.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建新地图后，</font><font style="vertical-align: inherit;">在内部调用方法</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保存地图大小 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管我们可以创建不同大小的卡，但是在保存和加载时不会考虑它。</font><font style="vertical-align: inherit;">这意味着，如果当前地图的大小与所加载地图的大小不匹配，则加载地图将导致错误或错误的地图。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了解决这个问题，在加载像元数据之前，我们需要创建一个适当大小的新地图。</font><font style="vertical-align: inherit;">假设我们保存了一张小地图。</font><font style="vertical-align: inherit;">在这种情况下，如果我们在开始时创建</font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20 x 15的地图</font><font style="vertical-align: inherit;">，一切都会很好</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 卡大小存储 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，我们可以存储任何大小的卡。</font><font style="vertical-align: inherit;">因此，一种通用的解决方案是将地图的大小保存在这些单元格的前面。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 然后，我们可以获得真实的尺寸，并使用它来创建具有正确尺寸的地图。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(reader.ReadInt32(), reader.ReadInt32()); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于现在我们可以加载不同大小的地图，因此我们再次面临摄像机位置的问题。</font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加载地图后，</font><font style="vertical-align: inherit;">我们将通过检查其位置来解决它</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 新档案格式 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管这种方法适用于我们将来会保留的卡，但不适用于旧卡。</font><font style="vertical-align: inherit;">反之亦然-本教程上半部分的代码将无法正确加载新的地图文件。</font><font style="vertical-align: inherit;">为了区分新旧格式，我们将增加标头的整数值。</font><font style="vertical-align: inherit;">没有地图尺寸的旧保存格式的版本为0。具有地图尺寸的新格式的版本为1。因此，在记录时，它</font></font><code>HexMapEditor.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该写1而不是0。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">1</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从现在开始，这些卡将被保存为版本1。如果我们尝试从上一教程的程序集中打开它们，它们将拒绝加载并报告未知的卡格式。</font><font style="vertical-align: inherit;">实际上，如果我们已经尝试加载这样的卡，就会发生这种情况。</font><font style="vertical-align: inherit;">您需要更改方法，</font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便它接受新版本。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 向后兼容 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，如果需要，我们仍然可以下载版本0的地图，假设它们的大小均为20 x15。也就是说，标题不必为1，也可以为零。</font><font style="vertical-align: inherit;">由于每个版本都需要自己的方法，因此</font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须将标头传递给method </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数中</font><font style="vertical-align: inherit;">添加</font><font style="vertical-align: inherit;">标题</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">并使用它来制定有关进一步操作的决策。</font><font style="vertical-align: inherit;">如果标题不小于1，则需要读取卡大小数据。</font><font style="vertical-align: inherit;">否则，我们将使用20 x 15的旧固定卡大小，并跳过读取大小数据的操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } CreateMap(x, z); … }</code> </pre> <br> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图文件版本0</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 卡大小检查 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与创建新图一样，从理论上讲，我们可能必须加载与片段大小不兼容的图。</font><font style="vertical-align: inherit;">发生这种情况时，我们必须中断卡的下载。</font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经拒绝创建地图并在控制台中显示错误。</font><font style="vertical-align: inherit;">为了告诉方法的调用者，让我们返回一个布尔值来告诉您是否创建了地图。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，</font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当地图创建失败时</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">它也可以停止执行。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于加载会覆盖现有单元中的所有数据，因此，如果加载了相同大小的地图，则无需创建新的地图。</font><font style="vertical-align: inherit;">因此，可以跳过此步骤。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 档案管理 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以保存和加载不同大小的卡，但始终写入和读取</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，我们将添加对不同文件的支持。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与其直接保存或加载地图，不如使用另一个提供高级文件管理的弹出菜单。</font><font style="vertical-align: inherit;">像在“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新建地图菜单”中一样</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">创建另一个画布，</font><font style="vertical-align: inherit;">但是这次我们将其称为“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存加载菜单”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此菜单将保存和加载地图，具体取决于打开它所按下的按钮。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将创建“ </font><em><font style="vertical-align: inherit;">保存加载菜单”</font></em><font style="vertical-align: inherit;">设计。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就像是保存菜单一样稍后，我们将把它动态地变成启动菜单。像另一个菜单一样，它应该具有背景和菜单栏，菜单标签和取消按钮。然后将滚动视图（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Scroll View</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）添加到菜单以显示文件列表。我们在下面插入输入字段（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Input Field</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）以指示新卡的名称。我们还需要一个操作按钮来保存地图。最后。添加</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮</font><font style="vertical-align: inherit;">以删除不需要的卡。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c73/279/198/c732791989e1eb6fa53e73ec3435bc74.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/485/3da/1764853da66092443c0327638dc1803a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设计保存加载菜单。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，滚动视图允许水平和垂直滚动，但是我们只需要一个具有垂直滚动的列表。因此，禁用滚动</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水平</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并拔出水平滚动条。我们还将“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运动类型”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置</font><font style="vertical-align: inherit;">为“ clamped”，并禁用了“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inertia”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以使列表看起来更具限制性。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/3a9/e36/43f3a9e36202f436772f54eedcd96c76.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件列表选项。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将从</font><em><font style="vertical-align: inherit;">文件列表</font></em><font style="vertical-align: inherit;">对象中</font><font style="vertical-align: inherit;">删除</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scrollbar Horizo​​ntal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子级</font><font style="vertical-align: inherit;">，因为我们不需要它。</font><font style="vertical-align: inherit;">然后调整</font><em><font style="vertical-align: inherit;">垂直滚动条的</font></em><font style="vertical-align: inherit;">大小</font><font style="vertical-align: inherit;">，使其</font><em><font style="vertical-align: inherit;">到达</font></em><font style="vertical-align: inherit;">列表</font><em><font style="vertical-align: inherit;">的</font></em><font style="vertical-align: inherit;">底部。</font><em><font style="vertical-align: inherit;">名称输入</font></em><font style="vertical-align: inherit;">对象的占位符文本</font><font style="vertical-align: inherit;">可以在其子</font><em><font style="vertical-align: inherit;">Placeholder中</font></em><font style="vertical-align: inherit;">更改</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我使用了描述性文本，但是您可以将其保留为空白并删除占位符。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/7d5/d17/ed57d5d17dfb0695fc4b2f5f3f9dc8a5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改了菜单设计。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设计已经完成，现在停用菜单，以便默认情况下将其隐藏。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 菜单管理 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使菜单正常工作，我们需要另一个脚本，在这种情况下- </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">就像</font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它需要一个到网格的链接，以及方法</font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将此组件添加到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveLoadMenu，</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并为其提供指向网格对象的链接。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/974/86f/440/97486f440f44d4db9c744cfa9b6acec0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件SaveLoadMenu。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将打开一个菜单来保存或加载。</font><font style="vertical-align: inherit;">为了简化工作，请在方法中添加</font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布尔参数。</font><font style="vertical-align: inherit;">它确定菜单是否应处于保存模式。</font><font style="vertical-align: inherit;">我们将在现场跟踪此模式，以了解以后要执行的操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> saveMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面结合按钮</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加载</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">六角地图编辑器</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与方法</font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的对象</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存加载菜单</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">仅检查“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮的布尔参数</font><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/59c/44f/38c59c44fa001e97128532d7c7d92168.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在保存模式下打开菜单。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果尚未这样做，请将“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取消”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮事件连接</font><font style="vertical-align: inherit;">到方法</font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存加载菜单</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以打开和关闭。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 外观变化 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将菜单创建为保存菜单，但其模式由按下以打开的按钮确定。</font><font style="vertical-align: inherit;">我们需要根据模式更改菜单的外观。</font><font style="vertical-align: inherit;">特别是，我们需要更改菜单标签和操作按钮标签。</font><font style="vertical-align: inherit;">这意味着我们将需要链接到这些标签。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text menuLabel, actionButtonLabel; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/4d3/b8d/e7c4d3b8d55ce8c333d38be996a3ebc1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与标签连接。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在保存模式下打开菜单时，我们将使用现有标签，即</font><font style="vertical-align: inherit;">菜单的“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存地图</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”和</font><font style="vertical-align: inherit;">操作按钮的“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”。</font><font style="vertical-align: inherit;">否则，我们处于加载模式，即我们使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Save Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Save"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Load Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Load"</span></span>; } gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 输入卡名 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在让我们离开文件列表。</font><font style="vertical-align: inherit;">用户可以通过在输入字段中输入卡的名称来指定保存或下载的文件。</font><font style="vertical-align: inherit;">要获取此数据，我们需要引用</font><em><font style="vertical-align: inherit;">Name Input</font></em></font><code>InputField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">的组件</font><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InputField nameInput;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e49/8e0/021/e498e002162a42103571cfac7cf91221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接到输入字段。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不需要强迫用户输入地图文件的完整路径。</font><font style="vertical-align: inherit;">仅带扩展名</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的卡名称就足够了</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们添加一个接受用户输入并为其创建正确路径的方法。</font><font style="vertical-align: inherit;">当输入为空时，这是不可能的，因此在这种情况下，我们将返回</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectedPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName = nameInput.text; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mapName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Path.Combine(Application.persistentDataPath, mapName + <span class="hljs-string"><span class="hljs-string">".map"</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果用户输入无效字符怎么办？</font></font></b> <div class="spoiler_text">        ,       .  ,      ,         . <br><br>         <em>Content Type</em>  . ,       - ,     .      ,    ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保存和加载 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在它将从事保存和加载</font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，我们移动的方法</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在的</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它们不再需要共享，并且将使用path参数而不是固定路径。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// string path = Path.Combine(Application.persistentDataPath, "test.map"); using ( BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(1); hexGrid.Save(writer); } } void Load (string path) { // string path = Path.Combine(Application.persistentDataPath, "test.map"); using (BinaryReader reader = new BinaryReader(File.OpenRead(path))) { int header = reader.ReadInt32(); if (header &lt;= 1) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } else { Debug.LogWarning("Unknown map format " + header); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们现在正在上传任意文件，因此最好先验证文件是否确实存在，然后再尝试读取它。</font><font style="vertical-align: inherit;">如果不是，则抛出错误并终止操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在添加常规方法</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">首先要获取用户选择的路径。</font><font style="vertical-align: inherit;">如果有路径，请保存或加载。</font><font style="vertical-align: inherit;">然后关闭菜单。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { Save(path); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Load(path); } Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Action Button</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件附加到此方法</font><font style="vertical-align: inherit;">，我们可以使用任意映射名称进行保存和加载。</font><font style="vertical-align: inherit;">由于我们不重置输入字段，因此所选名称将保留到下一次保存或加载。</font><font style="vertical-align: inherit;">这对于连续多次从一个文件保存或加载非常方便，因此我们不会做任何更改。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 地图清单项目 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们将使用数据存储路径上的所有卡填写文件列表。</font><font style="vertical-align: inherit;">当您单击列表中的一项时，它将用作“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名称输入”中的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文本</font><font style="vertical-align: inherit;">。</font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此</font><font style="vertical-align: inherit;">添加一个</font><font style="vertical-align: inherit;">通用方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectItem</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { nameInput.text = name; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要一些清单项目。</font><font style="vertical-align: inherit;">通常的按钮会起作用。</font><font style="vertical-align: inherit;">创建它并将其高度减小到20个单位，以使其在垂直方向上不占用太多空间。</font><font style="vertical-align: inherit;">它看起来不应该像按钮，因此我们将清除</font><font style="vertical-align: inherit;">其</font><em><font style="vertical-align: inherit;">Image</font></em><font style="vertical-align: inherit;">组件</font><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Image</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，它将变成完全白色。</font><font style="vertical-align: inherit;">另外，我们将确保标签向左对齐，并且文本和按钮的左侧之间应有空格。</font><font style="vertical-align: inherit;">完成按钮的设计后，我们将其转变为预制件。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/0f0/6e5/5010f06e5b380440bca024ffb8c0e307.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67b/60b/21f/67b60b21f34e4ae69846c35ed5583fae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮是一个列表项。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们无法将按钮事件直接连接到“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新地图菜单”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为它是预制的，并且还不存在于场景中。</font><font style="vertical-align: inherit;">因此，菜单项需要链接到菜单，以便单击时可以调用方法</font></font><code>SelectItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他还需要跟踪他代表的卡的名称，并设置他的文本。</font><font style="vertical-align: inherit;">让我们为此创建一个小组件</font></font><code>SaveLoadItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadItem</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadMenu menu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MapName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapName; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { mapName = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Text&gt;().text = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { menu.SelectItem(mapName); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将一个组件添加到菜单项，并使按钮调用其方法</font></font><code>Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/249/172/7a0/2491727a0c07b0b92e89db0e3c02fe67.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目组件。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 清单填写 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要填充列表，您</font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要一个指向</font><em><font style="vertical-align: inherit;">File List</font></em><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">的</font><em><font style="vertical-align: inherit;">视口</font></em><font style="vertical-align: inherit;">内的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的链接</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他还需要一个指向项目预制件的链接。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform listContent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadItem itemPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b6/22a/0eb/4b622a0eb5cf47422ce591dcd5c120e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混合列表和预制的内容。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用一种新方法来填充此列表。</font><font style="vertical-align: inherit;">第一步是识别现有的地图文件。</font><font style="vertical-align: inherit;">要获取目录内所有文件路径的数组，可以使用方法</font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此方法有第二个参数，可让您过滤文件。</font><font style="vertical-align: inherit;">在我们的情况下，仅需要匹配</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* .map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掩码的文件</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，不能保证文件顺序。</font><font style="vertical-align: inherit;">要按字母顺序显示它们，我们需要使用对数组进行排序</font></font><code>System.Array.Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); Array.Sort(paths); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们将为阵列的每个元素创建预制实例。</font><font style="vertical-align: inherit;">将项目绑定到菜单，设置其地图名称，并使其成为列表内容的子级。</font></font><br><br><pre> <code class="cs hljs"> Array.Sort(paths); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; paths.Length; i++) { SaveLoadItem item = Instantiate(itemPrefab); item.menu = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; item.MapName = paths[i]; item.transform.SetParent(listContent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于它</font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回文件的完整路径，因此我们需要清除它们。</font><font style="vertical-align: inherit;">幸运的是，这正是使此便捷方法有效的原因</font></font><code>Path.GetFileNameWithoutExtension</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> item.MapName = Path.GetFileNameWithoutExtension(paths[i]);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在显示菜单之前，我们需要填写一个列表。</font><font style="vertical-align: inherit;">由于文件可能会更改，因此每次打开菜单时都需要执行此操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { … FillList(); gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 重新填写列表时，我们需要先删除所有旧列表，然后再添加新条目。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; listContent.childCount; i++) { Destroy(listContent.GetChild(i).gameObject); } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c83/4ff/fc3/c834fffc34b03b0d39de0056796fa199.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有安排的物品。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 积分的安排 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，列表将显示项目，但它们将重叠并且处在不利位置。要将它们变成垂直列表，请将“ </font><em><font style="vertical-align: inherit;">垂直布局组”</font></em><font style="vertical-align: inherit;">组件</font><font style="vertical-align: inherit;">（“ </font><em><font style="vertical-align: inherit;">组件/布局/垂直布局组”</font></em><font style="vertical-align: inherit;">）添加</font><font style="vertical-align: inherit;">到</font><font style="vertical-align: inherit;">列表</font><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了使布置正常工作，请启用</font><font style="vertical-align: inherit;">“ </font><em><font style="vertical-align: inherit;">子控件大小的</font></em><em><font style="vertical-align: inherit;">宽度</font></em><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">和“ </font><em><font style="vertical-align: inherit;">子力展开</font></em><font style="vertical-align: inherit;"> ”两者</font><font style="vertical-align: inherit;">。两个</font><em><font style="vertical-align: inherit;">高度</font></em><font style="vertical-align: inherit;">选项</font><font style="vertical-align: inherit;">均应禁用。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/32e/aac/39232eaac1c1741718d8993aae992bb4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/aba/ce4/7ddabace4df7d61a274544889de9a3c2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用垂直布局组。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有一个漂亮的物品清单。</font><font style="vertical-align: inherit;">但是，列表内容的大小无法调整为真实的项目数。</font><font style="vertical-align: inherit;">因此，滚动条永远不会更改大小。</font><font style="vertical-align: inherit;">我们可以</font><font style="vertical-align: inherit;">通过</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向其</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content Size Fitter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件</font><font style="vertical-align: inherit;">（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component / Layout / Content Size Fitter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）来</font><font style="vertical-align: inherit;">强制</font><em><font style="vertical-align: inherit;">Content</font></em><font style="vertical-align: inherit;">自动调整大小</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">其“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">垂直适合”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式</font><font style="vertical-align: inherit;">应设置为“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首选大小”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/c56/fdb/34ec56fdb61e1d3a2bc71989333a7a8a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/a17/bf1/acba17bf1387ddb89b00ea48c9e31035.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用内容大小拟合器。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在只有少量点，滚动条将消失。</font><font style="vertical-align: inherit;">并且当列表中有太多项目不适合视口时，滚动条就会出现并具有适当的大小。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/460/6d8/3274606d8e5831f783d282d5122e55cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出现滚动条。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 卡删除 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以方便地使用许多地图文件。</font><font style="vertical-align: inherit;">但是，有时有必要去除一些卡。</font><font style="vertical-align: inherit;">为此，您可以使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delete</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们为此创建一个方法并使按钮调用它。</font><font style="vertical-align: inherit;">如果有选定的路径，只需使用删除它</font></font><code>File.Delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们还应检查我们是否正在使用真正存在的文件。</font><font style="vertical-align: inherit;">如果不是这种情况，则我们不应尝试将其删除，但这不会导致错误。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取出卡后，我们不需要关闭菜单。</font><font style="vertical-align: inherit;">这样可以更轻松地一次删除多个文件。</font><font style="vertical-align: inherit;">但是，删除后，我们需要清除</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Input</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并更新文件列表。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); } nameInput.text = <span class="hljs-string"><span class="hljs-string">""</span></span>; FillList();</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第14部分：浮雕纹理 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用顶点颜色创建splat贴图。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建阵列纹理资产。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将高程索引添加到网格。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 浮雕纹理之间的过渡。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此之前，我们将纯色用于色卡。</font><font style="vertical-align: inherit;">现在我们将应用纹理。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/9e8/4fa/4da9e84faf824fdcf3933310de58ff9c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绘制纹理。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 三种类型的混合物 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管统一的颜色很明显是可以区分的并且可以很好地应付任务，但是它们看起来并不有趣。</font><font style="vertical-align: inherit;">使用纹理将大大增加地图的吸引力。</font><font style="vertical-align: inherit;">当然，为此，我们必须混合纹理，而不仅仅是颜色。</font><font style="vertical-align: inherit;">在“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染3”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">教程</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">“组合纹理”中，</font></a><font style="vertical-align: inherit;">我讨论了如何使用splat贴图混合多个纹理。</font><font style="vertical-align: inherit;">在我们的六边形图中，您可以使用类似的方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“ </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">渲染3”</font></a><font style="vertical-align: inherit;">教程中</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅混合了四个纹理，使用一个splat贴图，我们最多可以支持五个纹理。</font><font style="vertical-align: inherit;">目前，我们使用五种不同的颜色，因此这非常适合我们。</font><font style="vertical-align: inherit;">但是，稍后我们可以添加其他类型。</font><font style="vertical-align: inherit;">因此，需要支持任意数量的浮雕类型。</font><font style="vertical-align: inherit;">使用显式设置的纹理属性时，这是不可能的，因此必须使用纹理数组。</font><font style="vertical-align: inherit;">稍后我们将创建它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用纹理数组时，我们需要以某种方式告诉着色器要混合哪些纹理。</font><font style="vertical-align: inherit;">对于角三角形来说，最困难的混合是必需的，角三角形可以在具有其自身类型的地形的三个像元之间。</font><font style="vertical-align: inherit;">因此，我们需要在每个三角形的三种类型之间混合支持。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用顶点颜色作为Splat贴图 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设我们可以告诉您要混合的纹理，我们可以使用顶点颜色为每个三角形创建一个splat贴图。</font><font style="vertical-align: inherit;">由于在每种情况下最多使用三个纹理，因此我们仅需要三个颜色通道。</font><font style="vertical-align: inherit;">红色代表第一个纹理，绿色代表第二个纹理，蓝色代表第三个纹理。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf1/3fb/603/cf13fb603f1d7ab8e83d9290b483b9ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三角形Splat地图。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三角形图示的总和是否始终等于1？</font></font></b> <div class="spoiler_text"> 是的         .     . ,        (1, 0, 0)  ,  (½, ½, 0)     (&amp;frac13;, &amp;frac13;, &amp;frac13;)  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果三角形仅需要一个纹理，则仅使用第一个通道。</font><font style="vertical-align: inherit;">即，其颜色将完全为红色。</font><font style="vertical-align: inherit;">在两种不同类型之间混合的情况下，我们使用第一和第二通道。</font><font style="vertical-align: inherit;">也就是说，三角形的颜色将是红色和绿色的混合物。</font><font style="vertical-align: inherit;">当找到所有三种类型时，它将是红色，绿色和蓝色的混合物。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/364/890/aa33648906f62a94be8a45aba4bd80de.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三种Splat地图配置。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无论实际混合了哪些纹理，我们都将使用这些splat贴图配置。</font><font style="vertical-align: inherit;">也就是说，splat映射将始终相同。</font><font style="vertical-align: inherit;">只有纹理会改变。</font><font style="vertical-align: inherit;">如何执行此操作，我们将在以后找到。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要进行更改，</font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便它创建这些splat贴图，而不是使用单元格颜色。</font><font style="vertical-align: inherit;">由于我们将经常使用三种颜色，因此我们将为它们创建静态字段。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 细胞中心 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从默认情况下替换单元格中心的颜色开始。</font><font style="vertical-align: inherit;">这里没有进行任何混合，因此我们只使用第一种颜色，即红色。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, color1); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/44b/f10/3e944bf109bb387ab6a620ea680c2772.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">细胞红色中心。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单元中心现在变成红色。</font><font style="vertical-align: inherit;">无论纹理是什么，它们都使用三个纹理中的第一个。</font><font style="vertical-align: inherit;">它们的splat贴图是相同的，而不管我们为细胞着色的颜色如何。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 河邻里 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们仅在单元内部更改了段，没有河流沿它们流动。</font><font style="vertical-align: inherit;">我们需要对与河流相邻的路段做同样的事情。</font><font style="vertical-align: inherit;">在我们的案例中，这既是肋条，也是肋的三角形扇形。</font><font style="vertical-align: inherit;">在这里，对于我们来说，只有红色就足够了。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/846/a8a/b7c846a8a2a4b5a2670b77359d55f9f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与河流相邻的红色部分。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 河流 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们需要注意单元内部河流的几何形状。</font><font style="vertical-align: inherit;">它们也都应该变成红色。</font><font style="vertical-align: inherit;">首先，让我们看一下河流的起点和终点。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后是构成河岸和河床的几何形状。</font><font style="vertical-align: inherit;">我对颜色方法调用进行了分组，以使代码更易于阅读。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); terrain.AddTriangle(centerL, m.v1, m.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(cell.Color); terrain.AddQuad(centerL, center, m.v2, m.v3); // terrain.AddQuadColor(cell.Color); terrain.AddQuad(center, centerR, m.v3, m.v4); // terrain.AddQuadColor(cell.Color); terrain.AddTriangle(centerR, m.v4, m.v5); // terrain.AddTriangleColor(cell.Color); terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); … }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/46a/455/da846a455aa262ddff54429faa207267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿细胞的红河。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排骨 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有边缘都是不同的，因为它们位于可以具有不同类型地形的单元之间。</font><font style="vertical-align: inherit;">我们将第一种颜色用于当前单元格类型，将第二种颜色用于邻居类型。</font><font style="vertical-align: inherit;">结果，即使两个单元格是同一类型，splat贴图也将变为红绿色渐变。</font><font style="vertical-align: inherit;">如果两个单元使用相同的纹理，则它只是在两侧变成了相同纹理的混合物。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/368/42b/88c/36842b88cd626359ef4adfd4c3b99b13.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红绿色的肋骨，不包括壁架。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红色和绿色之间的急剧过渡会不会引起问题？</font></font></b> <div class="spoiler_text">   ,         ,      .        .     splat map,         .            . <br><br>  ,           . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有壁架的边缘要复杂一些，因为它们具有附加的顶点。</font><font style="vertical-align: inherit;">幸运的是，现有的插值代码可用于splat贴图颜色。</font><font style="vertical-align: inherit;">仅使用第一和第二种颜色，而不使用开始和结束单元格的颜色。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, color1, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, color2, hasRoad); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/635/fe1/450635fe13e41a888046f2f7e0cce830.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红绿色的肋骨壁架。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 角度 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像元角是最困难的，因为它们必须混合三种不同的纹理。</font><font style="vertical-align: inherit;">我们将红色用于底峰，将绿色用于左峰，将蓝色用于右峰。</font><font style="vertical-align: inherit;">让我们从一个三角形的角开始。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/d9c/218/10ad9c21858e48e059c92bbed08c779f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红-绿-蓝色的角，壁架除外。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们可以再次将现有的颜色插值代码用于带有壁架的角。</font><font style="vertical-align: inherit;">仅在三种而不是两种颜色之间进行插值。</font><font style="vertical-align: inherit;">首先，考虑不在悬崖附近的壁架。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/d1d/6b3/504d1d6b3997b321e0a6e7bf5aa253f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">红-绿-蓝角corner，悬崖峭壁除外。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当谈到悬崖时，我们需要使用一种方法</font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此方法接收开始和左单元格作为参数。</font><font style="vertical-align: inherit;">但是，现在我们需要适当的splat颜色，具体取决于拓扑。</font><font style="vertical-align: inherit;">因此，我们将这些参数替换为颜色。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对其进行更改，</font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以使其使用正确的颜色。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … Color boundaryColor = Color.Lerp(color1, color3, b); TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并针对进行相同操作</font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … Color boundaryColor = Color.Lerp(color1, color2, b); TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/7e0/e40/f897e0e408335e1e7b198ced5e1dc8ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整的splat救济图。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 纹理阵列 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们的地形有了一个splat贴图，我们可以将纹理集合传递给着色器。</font><font style="vertical-align: inherit;">我们不能仅将着色器分配给C＃纹理数组，因为该数组必须作为单个实体存在于GPU内存中。</font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自5.4版以来，</font><font style="vertical-align: inherit;">我们将必须使用</font><font style="vertical-align: inherit;">Unity中已支持</font><font style="vertical-align: inherit;">的特殊对象</font><font style="vertical-align: inherit;">。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有GPU是否都支持纹理阵列？</font></font></b> <div class="spoiler_text">  GPU  ,         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> Unity</a> . <br><ul><li> Direct3D 11/12 (Windows, Xbox One) </li><li> OpenGL Core (Mac OS X, Linux) </li><li> Metal (iOS, Mac OS X) </li><li> OpenGL ES 3.0 (Android, iOS, WebGL 2.0) </li><li> PlayStation 4 </li></ul></div></div><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 大师 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，Unity在5.5版中对纹理数组的支持很小。</font><font style="vertical-align: inherit;">我们不仅可以创建纹理阵列资源并为其分配纹理。</font><font style="vertical-align: inherit;">我们必须手动进行。</font><font style="vertical-align: inherit;">我们可以在“播放”模式下创建纹理数组，也可以在编辑器中创建资产。</font><font style="vertical-align: inherit;">让我们创建一个资产。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么要创建资产？</font></font></b> <div class="spoiler_text">     ,         Play    .        ,        . <br><br>     ,    . Unity            .            ,    . ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要创建纹理数组，我们将组装自己的母版。</font><font style="vertical-align: inherit;">创建一个脚本</font></font><code>TextureArrayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其放置在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件夹中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">相反，</font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它应该</font></font><code>ScriptableWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从namespace </font><font style="vertical-align: inherit;">扩展类型</font></font><code>UnityEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextureArrayWizard</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableWizard</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过通用的静态方法打开向导</font></font><code>ScriptableWizard.DisplayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它的参数是向导窗口及其创建按钮的名称。</font><font style="vertical-align: inherit;">我们将以静态方法调用此方法</font></font><code>CreateWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ScriptableWizard.DisplayWizard&lt;TextureArrayWizard&gt;( <span class="hljs-string"><span class="hljs-string">"Create Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Create"</span></span> ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要通过编辑器访问向导，我们需要将此方法添加到Unity菜单中。</font><font style="vertical-align: inherit;">这可以通过向该方法添加属性来完成</font></font><code>MenuItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们将其添加到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">菜单中</font><font style="vertical-align: inherit;">，更具体地说，</font><font style="vertical-align: inherit;">将其添加到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets / Create / Texture Array中</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">MenuItem(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assets/Create/Texture Array"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/2b4/433/f7d2b44333870be6838dcd48ea3a697f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的自定义向导。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用新的菜单项，您可以打开我们的自定义向导的弹出菜单。</font><font style="vertical-align: inherit;">它不是很漂亮，但是适合解决问题。</font><font style="vertical-align: inherit;">但是，它仍然是空的。</font><font style="vertical-align: inherit;">要创建纹理数组，我们需要一个纹理数组。</font><font style="vertical-align: inherit;">向其添加一个主字段的通用字段。</font><font style="vertical-align: inherit;">向导的标准GUI像标准检查器一样显示它。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D[] textures;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/beb/aa7/d6d/bebaa7d6dd8e0d995ea485d670ea5a0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掌握纹理。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们创造一些东西 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当您单击</font><font style="vertical-align: inherit;">向导</font><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按钮时</font><font style="vertical-align: inherit;">，它消失了。</font><font style="vertical-align: inherit;">另外，Unity抱怨没有方法</font></font><code>OnWizardCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是单击“创建”按钮时调用的方法，因此我们需要将其添加到向导中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们将创建纹理数组。</font><font style="vertical-align: inherit;">至少如果用户将纹理添加到母版上。</font><font style="vertical-align: inherit;">如果没有，那么什么也没有创建，需要停止工作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一步是请求保存纹理阵列资产的位置。</font><font style="vertical-align: inherit;">可以使用方法打开文件保存面板</font></font><code>EditorUtility.SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">其参数定义面板名称，默认文件名，文件扩展名和描述。</font><font style="vertical-align: inherit;">纹理数组使用常规</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资产</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件扩展名</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> );</code> </pre> <br> <code>SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回用户选择的文件路径。</font><font style="vertical-align: inherit;">如果用户单击此面板上的“取消”，则路径将为空字符串。</font><font style="vertical-align: inherit;">因此，在这种情况下，我们必须中断工作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建纹理数组 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们有正确的道路，那么我们可以继续前进并创建一个新对象</font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他的构造方法需要指定纹理的宽度和高度，数组的长度，纹理的格式以及对mip纹理的需求。</font><font style="vertical-align: inherit;">对于阵列中的所有纹理，这些参数应该相同。</font><font style="vertical-align: inherit;">要配置对象，我们使用第一个纹理。</font><font style="vertical-align: inherit;">用户必须验证所有纹理具有相同的格式。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Texture2D t = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于纹理数组是单个GPU资源，因此它对所有纹理使用相同的过滤和折叠模式。</font><font style="vertical-align: inherit;">在这里，我们再次使用第一个纹理进行设置。</font></font><br><br><pre> <code class="cs hljs"> Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ); textureArray.anisoLevel = t.anisoLevel; textureArray.filterMode = t.filterMode; textureArray.wrapMode = t.wrapMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以使用方法将纹理复制到数组中</font></font><code>Graphics.CopyTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该方法一次复制一个纹理级别的原始纹理数据。</font><font style="vertical-align: inherit;">因此，我们需要遍历所有纹理及其mip级别。</font><font style="vertical-align: inherit;">方法参数是两组，分别由纹理资源，索引和Mip级别组成。</font><font style="vertical-align: inherit;">由于原始纹理不是数组，因此它们的索引始终为零。</font></font><br><br><pre> <code class="cs hljs"> textureArray.wrapMode = t.wrapMode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; t.mipmapCount; m++) { Graphics.CopyTexture(textures[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, m, textureArray, i, m); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此阶段，我们已经在内存中存储了正确的纹理数组，但这还不是一项资产。</font><font style="vertical-align: inherit;">最后一步将是调用</font></font><code>AssetDatabase.CreateAsset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组及其路径。</font><font style="vertical-align: inherit;">在这种情况下，数据将被写入我们项目中的文件中，并将出现在项目窗口中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { … } AssetDatabase.CreateAsset(textureArray, path);</code> </pre> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 贴图 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要创建真实的纹理数组，我们需要原始纹理。这是与我们到目前为止使用的颜色相匹配的五种纹理。黄色变成沙子，绿色变成草，蓝色变成泥土，橙色变成石头，白色变成雪。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/195/104/a40/195104a4070bfa42e6c4e0eaff218d42.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/777/f86/0d7777f865b086c46a1c95a06380c66a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f8/30b/55f/0f830b55ffdbc729bc02d013805bb2c3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/4eb/37b/3474eb37b3a5404866a6fd384e9c6352.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/0eb/fa3/6de0ebfa32b5b0b04c8c082e6cce0c01.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沙子，草，地球，石头和雪纹理。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，这些纹理不是此浮雕的照片。</font><font style="vertical-align: inherit;">这些是我使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumberFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建的简单伪随机模式</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我努力创建与抽象多边形浮雕不冲突的可识别浮雕类型和细节。</font><font style="vertical-align: inherit;">真实感不适用于此。</font><font style="vertical-align: inherit;">此外，尽管模式增加了可变性，但其中几乎没有明显的特征会使重复立即引起注意。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将这些纹理添加到主阵列中，确保其顺序与颜色匹配。</font><font style="vertical-align: inherit;">也就是说，首先是沙子，然后是草，泥土，石头，最后是雪。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ec/511/2a1/5ec5112a1bdaa4f170ec382b2549ad9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a54/4e8/1f0/a544e81f0c74fa36290553a6c6a328df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建纹理数组。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建纹理阵列资产后，选择它并在检查器中对其进行检查。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/8f3/8d6/6e18f38d6682f71b3c8a999823642cd4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纹理阵列检查器。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是最简单的纹理阵列数据显示。请注意，</font><font style="vertical-align: inherit;">最初已打开</font><font style="vertical-align: inherit;">一个</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“可读”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开关</font><font style="vertical-align: inherit;">。由于我们不需要从数组中读取像素数据，因此请将其关闭。我们无法在向导中执行此操作，因为</font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有方法或属性可以访问此参数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（在Unity 5.6中，有一个错误会破坏多个平台上的程序集中的纹理数组。您可以在不禁用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Readable的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况下解决它</font><font style="vertical-align: inherit;">。）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有一点值得注意，它有一个</font><em><font style="vertical-align: inherit;">Color Space</font></em><font style="vertical-align: inherit;">字段</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它的值被指定为1。这意味着纹理被假定为在伽马空间中，这是正确的。</font><font style="vertical-align: inherit;">如果假定它们在线性空间中，则必须将字段设置为0。实际上，设计者</font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有一个用于指定颜色空间的附加参数，但是它</font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会显示它是否在线性空间中，因此，无论如何，您都需要设置手动值。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 着色器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们有了一系列纹理，我们需要教着色器如何使用它。</font><font style="vertical-align: inherit;">现在，我们使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VertexColors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器来渲染terrain </font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从现在开始，我们将使用纹理而不是颜色，将其重命名为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，将其</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font><font style="vertical-align: inherit;">转换为纹理数组，并为其分配资产。</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Shader</span></span> <span class="hljs-string"><span class="hljs-string">"Custom/Terrain"</span></span> { <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/878/0b2/3de/8780b23ded3ced3ab980a039d0f5753d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有一系列纹理的浮雕材料。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要在支持它们的所有平台上启用纹理阵列，您需要将着色器的目标级别从3.0增加到3.5。</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.5</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于变量</font></font><code>_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在引用纹理数组，因此我们需要更改其类型。</font><font style="vertical-align: inherit;">类型取决于目标平台，宏将负责此工作</font></font><code>UNITY_DECLARE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// sampler2D _MainTex; UNITY_DECLARE_TEX2DARRAY(_MainTex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与其他着色器一样，要采样浮雕的纹理，我们需要XZ世界的坐标。</font><font style="vertical-align: inherit;">因此，我们将在世界上为表面着色器的输入结构添加一个位置。</font><font style="vertical-align: inherit;">我们还删除了默认的UV坐标，因为我们不需要它们。</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// float2 uv_MainTex; float4 color : COLOR; float3 worldPos; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要采样一组纹理，我们需要使用一个macro </font></font><code>UNITY_SAMPLE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要采样一个数组，它需要三个坐标。</font><font style="vertical-align: inherit;">前两个是常规UV坐标。</font><font style="vertical-align: inherit;">我们将使用缩放到0.02的XZ世界坐标。</font><font style="vertical-align: inherit;">因此，我们在全放大倍数下可以获得良好的纹理分辨率。</font><font style="vertical-align: inherit;">纹理大约每四个单元重复一次。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与常规数组一样，第三个坐标用作纹理数组的索引。</font><font style="vertical-align: inherit;">由于坐标是浮动的，因此在索引GPU数组之前会对它们进行四舍五入。</font><font style="vertical-align: inherit;">因为直到我们知道需要什么纹理，我们才总是使用第一个。</font><font style="vertical-align: inherit;">同样，顶点的颜色不会影响最终结果，因为它是一个散点图。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, float3(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>)); Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/a19/df0/c08a19df0f6c0674406e4922b6595585.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切都变成了沙子。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 纹理选择 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要一个将三个类型混合成一个三角形的浮雕图示。</font><font style="vertical-align: inherit;">我们有一系列纹理，每种类型的地形都有一个纹理。</font><font style="vertical-align: inherit;">我们有一个着色器，可以对一系列纹理进行采样。</font><font style="vertical-align: inherit;">但是到目前为止，我们还没有办法告诉着色器为每个三角形选择哪种纹理。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于每个三角形最多混合三种类型，因此我们需要将三个索引与每个三角形关联。</font><font style="vertical-align: inherit;">我们无法存储三角形的信息，因此我们必须存储顶点的索引。</font><font style="vertical-align: inherit;">三角形的所有三个顶点将仅存储与纯色相同的索引。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 网格数据 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使用其中一组UV网格来存储索引。</font><font style="vertical-align: inherit;">由于三个索引存储在每个顶点上，因此现有的2D UV集将不足。</font><font style="vertical-align: inherit;">幸运的是，UV集最多可以包含四个坐标。</font><font style="vertical-align: inherit;">因此，我们将添加到</font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个列表中</font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们将其称为救济类型。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useTerrainTypes; [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为“ </font><em><font style="vertical-align: inherit;">十六进制网格块”</font></em><font style="vertical-align: inherit;">预制件</font><font style="vertical-align: inherit;">的“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地形”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子代</font><font style="vertical-align: inherit;">启用地形类型</font><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/728/0c5/4eb/7280c54ebcd1a6063fb3df9f0328cc5b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用救济类型。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如有必要，我们将</font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在网格清洁过程中</font><font style="vertical-align: inherit;">使用另一种</font><font style="vertical-align: inherit;">浮雕类型</font><font style="vertical-align: inherit;">列表</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { terrainTypes = ListPool&lt;Vector3&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在应用网格数据的过程中，我们将浮雕类型保存在第三个UV集中。</font><font style="vertical-align: inherit;">因此，如果我们决定一起使用它们，它们将不会与其他两个集合冲突。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, terrainTypes); ListPool&lt;Vector3&gt;.Add(terrainTypes); } hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要设置三角形的浮雕类型，我们将使用</font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于整个三角形的数据相同，因此我们只需将相同的数据添加三遍。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Quad中混合的工作原理相同。</font><font style="vertical-align: inherit;">所有四个顶点都属于同一类型。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 排骨三角形的粉丝 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们需要在中向网格数据添加类型</font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们从开始</font></font><code>TriangulateEdgeFan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">首先，为了提高可读性，我们将对顶点和颜色方法的调用分开。</font><font style="vertical-align: inherit;">回想一下，每次调用此方法时，我们都会将其传递给他</font></font><code>color1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此我们可以直接使用此颜色，而无需应用参数。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v2, edge.v3); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v3, edge.v4); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v4, edge.v5); // terrain.AddTriangleColor(color); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在颜色之后，我们添加浮雕类型。</font><font style="vertical-align: inherit;">由于三角形的类型可能不同，因此应使用该参数替换颜色。</font><font style="vertical-align: inherit;">使用此简单类型创建</font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">只有前四个通道对我们很重要，因为在这种情况下，图示图示始终为红色。</font><font style="vertical-align: inherit;">由于向量的所有三个组成部分都需要分配，因此让我们为它们分配一种类型。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">)</span></span> { … Vector3 types; types.x = types.y = types.z = type; terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们需要更改对该方法的所有调用，将color参数替换为单元的地形类型的索引。</font><font style="vertical-align: inherit;">Vnesom这种变化</font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeFan(center, e, color1); TriangulateEdgeFan(center, e, cell.TerrainTypeIndex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此时，当您启动“播放”模式时，将出现错误，通知您第三组UV网格超出范围。</font><font style="vertical-align: inherit;">发生这种情况是因为我们尚未将浮雕类型添加到每个三角形和四边形。</font><font style="vertical-align: inherit;">因此，让我们继续进行更改</font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 肋条 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，当创建边缘条时，我们需要知道两侧的地形类型。</font><font style="vertical-align: inherit;">因此，我们将它们添加为参数，然后创建一个类型向量，其两个通道都被分配了这些类型。</font><font style="vertical-align: inherit;">第三个渠道并不重要，因此只需将其等同于第一个渠道即可。</font><font style="vertical-align: inherit;">添加颜色后，将类型添加到四边形。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); Vector3 types; types.x = types.z = type1; types.y = type2; terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们需要改变挑战</font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">首先</font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您必须使用的细胞类型的翅片的两侧。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeStrip( m, color1, cell.TerrainTypeIndex, e, color1, cell.TerrainTypeIndex );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，最简单的边缘情况</font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须将单元格类型用于最近边缘，将邻居类型用于远端边缘。</font><font style="vertical-align: inherit;">它们可以相同或不同。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); TriangulateEdgeStrip( e1, color1, cell.TerrainTypeIndex, e2, color2, neighbor.TerrainTypeIndex, hasRoad ); } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这同样适用于</font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是三次</font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">壁架的类型相同。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = beginCell.TerrainTypeIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = endCell.TerrainTypeIndex; TriangulateEdgeStrip(begin, color1, t1, e2, c2, t2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, t1, e2, c2, t2, hasRoad); } TriangulateEdgeStrip(e2, c2, t1, end, color2, t2, hasRoad); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 角度 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">角的最简单情况是一个简单的三角形。</font><font style="vertical-align: inherit;">底部的单元格传递第一种类型，左侧的单元格传递第二种，右侧的单元格传递第三种。</font><font style="vertical-align: inherit;">使用它们，创建类型的向量并将其添加到三角形。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); Vector3 types; types.x = bottomCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在中使用相同的方法</font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，仅在此处创建一组四边形。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); terrain.AddQuadTerrainTypes(types); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); terrain.AddQuadTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在混合壁架和悬崖时，我们需要使用</font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">只需为其提供类型向量参数并将其添加到其所有三角形即可。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor, Vector3 types </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于所发送的细胞类型创建矢量。</font><font style="vertical-align: inherit;">然后将其添加到一个三角形并传递</font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryColor = Color.Lerp(color1, color3, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样的道理</font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryColor = Color.Lerp(color1, color2, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 河流 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后一种更改方法是</font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因为这里我们位于单元格的中心，所以我们只处理当前单元格的类型。</font><font style="vertical-align: inherit;">因此，为其创建一个向量，并将其添加到三角形和quad-s中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); Vector3 types; types.x = types.y = types.z = cell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 类型混合 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这一阶段，网格包含必要的高程指数。</font><font style="vertical-align: inherit;">对我们而言，剩下的就是强制</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地形</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">使用它们。</font><font style="vertical-align: inherit;">为了使索引落入片段着色器中，我们首先需要将它们传递通过顶点着色器。</font><font style="vertical-align: inherit;">我们可以像在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器中那样在自己的顶点函数中执行此操作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，我们向输入结构添加一个字段</font></font><code>float3 terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将其复制到其中</font></font><code>v.texcoord2.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.5</span></span> … struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); data.terrain = v.texcoord2.xyz; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要对每个片段采样3次纹理数组。</font><font style="vertical-align: inherit;">因此，让我们创建一个方便的函数来创建纹理坐标，对数组进行采样并使用splat贴图为一个索引调制样本。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以将向量作为数组使用吗？</font></font></b> <div class="spoiler_text"> 是的   - <code>color[0]</code>  <code>color.r</code> .  <code>color[1]</code>  <code>color.g</code> ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用此功能，我们可以简单地对纹理数组进行三次采样并组合结果。 </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { // float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); o.Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da9/2fa/577/da92fa577510b38d4d0cdb99db83aea0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纹理浮雕。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以用纹理绘制浮雕。</font><font style="vertical-align: inherit;">它们像纯色一样混合。</font><font style="vertical-align: inherit;">由于我们将世界坐标用作UV坐标，因此它们不会随高度变化。</font><font style="vertical-align: inherit;">结果，沿着陡峭的悬崖，纹理被拉伸了。</font><font style="vertical-align: inherit;">如果纹理相当中性且变化很大，那么结果将是可以接受的。</font><font style="vertical-align: inherit;">否则，我们会得到大的丑陋妊娠纹。</font><font style="vertical-align: inherit;">您可以尝试使用其他几何形状或悬崖纹理将其隐藏，但是在本教程中，我们不会这样做。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 扫一扫 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，当我们使用纹理而不是颜色时，更改编辑器面板将是合乎逻辑的。</font><font style="vertical-align: inherit;">我们可以创建一个甚至可以显示浮雕纹理的漂亮界面，但是我将重点介绍与现有方案样式相对应的缩写。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/c52/c81/263c52c812c97de2b8095b6ca80a8f5d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">救济选项。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不再需要color属性，因此将其删除。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color Color { // get { // return HexMetrics.colors[terrainTypeIndex]; // } // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还可以从中删除颜色数组和相关代码。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; … void Awake () { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } … … void OnEnable () { if (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，中也不需要颜色数组</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public static Color[] colors;</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第15部分：距离 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 显示网格线。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在编辑和导航模式之间切换。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 计算单元格之间的距离。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们找到绕过障碍的方法。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们考虑了搬家的可变成本。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建了高质量的地图后，我们将开始导航。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/b5d/65d/15bb5d65de19358da88e581cedad71cb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最短的路径并不总是直的。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 网格显示 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过在一个单元格之间移动来执行地图上的导航。</font><font style="vertical-align: inherit;">要到达某个地方，您需要遍历一系列单元。</font><font style="vertical-align: inherit;">为了更容易估算距离，让我们添加选项以显示地图所基于的六边形网格。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 网格纹理 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管地图网格不规则，但下面的网格还是完美平坦的。</font><font style="vertical-align: inherit;">我们可以通过将栅格图案投影到地图上来显示这一点。</font><font style="vertical-align: inherit;">这可以使用重复的网格纹理来实现。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/74c/76e/3a774c76e29b57018450a8e21f5bf1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重复网格纹理。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面显示的纹理包含覆盖2 x 2格的六边形网格的一小部分。</font><font style="vertical-align: inherit;">此区域是矩形，而不是正方形。</font><font style="vertical-align: inherit;">由于纹理本身是正方形，因此图案看起来很拉伸。</font><font style="vertical-align: inherit;">采样时，我们需要对此进行补偿。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 网格投影 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要投影网格图案，我们需要向</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader添加</font><font style="vertical-align: inherit;">一个texture属性。</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/708/6de/2837086dedff939d3380396c9146ddfc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有网状纹理的浮雕材料。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用世界的XZ坐标对纹理进行采样，然后将其乘以反照率。</font><font style="vertical-align: inherit;">由于纹理上的网格线为灰色，因此会将图案交织到浮雕中。</font></font><br><br><pre> <code class="hljs pgsql"> sampler2D _GridTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fixed4 grid = tex2D(_GridTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz); o.Albedo = c.rgb * grid * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/a3e/432/972a3e4323541d1195904c9777a29e07.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反照率乘以细网格。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要缩放模式，使其与地图中的单元格匹配。</font><font style="vertical-align: inherit;">相邻单元格中心之间的距离为15，需要向上翻倍才能向上移动两个单元格。</font><font style="vertical-align: inherit;">也就是说，我们需要将V网格的坐标除以30。像元的内半径为5√3，并且要将两个像元向右移动，则需要四倍。</font><font style="vertical-align: inherit;">因此，有必要将U网格的坐标除以20√3。</font></font><br><br><pre> <code class="hljs markdown"> float2 gridUV = IN.worldPos.xz; gridUV.x <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (4 *</span></span> 8.66025404); gridUV.y <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (2 *</span></span> 15.0); fixed4 grid = tex2D(_GridTex, gridUV);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/1ba/191/4541ba19123145c27422e2b90b52aa6f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的网格尺寸。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，网格线对应于地图的单元格。</font><font style="vertical-align: inherit;">就像浮雕纹理一样，它们忽略了高度，因此线条将沿着悬崖伸展。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98a/708/906/98a7089069b6d04bc708851045c9fe7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投影到具有高度的单元格上。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格变形通常不会那么糟，尤其是在远距离观看地图时。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/287/5ac/690/2875ac690eb796bf00a86b48d193aec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在远处网格。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 网格包含 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管显示网格很方便，但并非总是必需的。</font><font style="vertical-align: inherit;">例如，在截屏时应将其关闭。</font><font style="vertical-align: inherit;">此外，并非每个人都喜欢不断看到网格。</font><font style="vertical-align: inherit;">因此，让我们将其设为可选。</font><font style="vertical-align: inherit;">我们将把multi_compile指令添加到着色器，以创建带有和不带有网格的选项。</font><font style="vertical-align: inherit;">为此，我们将使用关键字</font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">教程</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">“ Multiple Lights”中</font></a><font style="vertical-align: inherit;">介绍了条件着色器的编译</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">multi_compile</span></span> _ <span class="hljs-selector-tag"><span class="hljs-selector-tag">GRID_ON</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在声明变量时，我们</font></font><code>grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先为其分配值1。结果，网格将被禁用。</font><font style="vertical-align: inherit;">然后，我们将仅对具有特定关键字的变体采样网格纹理</font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs mel"> fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(GRID_ON) float2 gridUV = IN.worldPos.xz; gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = tex2D(_GridTex, gridUV); #endif o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> * _Color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于关键字</font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不包括在terrain shader中，因此网格将消失。</font><font style="vertical-align: inherit;">要再次启用它，我们将向地图编辑器用户界面添加一个开关。</font><font style="vertical-align: inherit;">为了使之成为可能，我</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须获得指向</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">材质的链接</font><font style="vertical-align: inherit;">以及启用或禁用关键字的方法</font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material terrainMaterial; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visible) { terrainMaterial.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d0/d53/873/7d0d53873a0aace69be804dcbf22d7ce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考材料的编辑器March六边形。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开关添加到UI </font><font style="vertical-align: inherit;">并将其连接到方法</font></font><code>ShowGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56b/38a/6b6/56b38a6b6792eb8b89fb3936a55e9194.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电网开关。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 保存状态 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，在“播放”模式下，我们可以切换网格的显示。</font><font style="vertical-align: inherit;">在第一个测试中，网格最初是关闭的，并且在我们打开开关时变得可见。</font><font style="vertical-align: inherit;">当您关闭它时，网格将再次消失。</font><font style="vertical-align: inherit;">但是，如果在显示网格时退出播放模式，则下次关闭播放模式时，即使开关已关闭，它也会再次打开。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是因为我们正在更改常规</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">材质的关键字</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们正在编辑物料资产，因此更改将保存在Unity编辑器中。</font><font style="vertical-align: inherit;">它不会保存在装配体中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了始终在没有网格的情况下开始游戏，我们将禁用</font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awake中</font><font style="vertical-align: inherit;">的关键字</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编辑模式 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果要控制地图上的运动，则需要与其进行交互。</font><font style="vertical-align: inherit;">至少，我们需要选择单元格作为路径的起点。</font><font style="vertical-align: inherit;">但是，当您单击一个单元格时，它将被编辑。</font><font style="vertical-align: inherit;">我们可以手动禁用所有编辑选项，但这很不方便。</font><font style="vertical-align: inherit;">另外，我们不希望在地图编辑期间执行位移计算。</font><font style="vertical-align: inherit;">因此，让我们添加一个确定我们是否处于编辑模式的开关。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编辑开关 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加到</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boolean字段</font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及定义它的方法。</font><font style="vertical-align: inherit;">然后将另一个开关添加到UI进行控制。</font><font style="vertical-align: inherit;">让我们从导航模式开始，即默认情况下将禁用编辑模式。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> editMode; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/19b/ace/1bf19baceed0ecfa766dbe0386ed38d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编辑模式开关。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要真正禁用编辑，请使调用</font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取决于</font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 调试标签 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们还没有单位可以在地图上移动。</font><font style="vertical-align: inherit;">相反，我们将移动距离可视化。</font><font style="vertical-align: inherit;">为此，您可以使用现有的单元格标签。</font><font style="vertical-align: inherit;">因此，当禁用编辑模式时，我们将使它们可见。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; hexGrid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们从导航模式开始，因此应启用默认标签。</font><font style="vertical-align: inherit;">当前</font></font><code>HexGridChunk.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">禁用它们，但他不应再这样做。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; <span class="hljs-comment"><span class="hljs-comment">// ShowUI(false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/730/666/90c/73066690c998f0715fb22356a0374fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">坐标标签。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，在启动“播放”模式后立即可以看到单元坐标。</font><font style="vertical-align: inherit;">但是我们不需要坐标，我们使用标签显示距离。</font><font style="vertical-align: inherit;">由于每个单元格只需要一个数字，因此可以增加字体大小，以便更好地阅读它们。</font><font style="vertical-align: inherit;">更改</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十六进制单元标签</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的预制</font><font style="vertical-align: inherit;">，使其使用大小为8的粗体。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/008/aa0/8ea008aa075686891f8815148c70ba06.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有粗体字体的标签8.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，在启动“播放”模式后，我们将看到大标签。</font><font style="vertical-align: inherit;">仅该单元格的第一个坐标可见，其余未放置在标签中。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/baf/016/745baf0160c2f9cf8aaae974ff285d16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大标签。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们不再需要坐标，因此我们将删除</font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配中</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">值</font></font><code>label.text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); <span class="hljs-comment"><span class="hljs-comment">// label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您也可以从UI中删除“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标签”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开关</font><font style="vertical-align: inherit;">及其关联的方法</font></font><code>HexMapEditor.ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public void ShowUI (bool visible) { // hexGrid.ShowUI(visible); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/4d4/652/6e04d46522e65937a9324e0f3498d480.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法切换不再。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 寻找距离 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们有了标记的导航模式，我们可以开始显示距离了。</font><font style="vertical-align: inherit;">我们将选择一个单元格，然后显示从该单元格到地图上所有单元格的距离。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 距离显示 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要跟踪到单元格的距离，请添加到</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integer字段</font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它将指示此单元格与所选单元格之间的距离。</font><font style="vertical-align: inherit;">因此，对于选定的单元格本身，它将为零，对于紧邻的邻居为1，依此类推。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置距离后，我们必须更新单元格标签以显示其值。</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有对</font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI对象</font><font style="vertical-align: inherit;">的引用</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将需要打电话给他</font></font><code>GetComponent&lt;Text&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进入牢房。</font><font style="vertical-align: inherit;">考虑</font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">名称空间中的内容</font></font><code>UnityEngine.UI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此请在脚本开头使用它。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance.ToString(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不应该直接链接到Text组件吗？</font></font></b> <div class="spoiler_text"> ,   .     ,       ,  ,    .   ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们将常规属性设置为接收并设置到单元的距离，并更新其标签。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; UpdateDistanceLabel(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用cell参数</font><font style="vertical-align: inherit;">将其添加到</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常规方法中</font></font><code>FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，我们将简单地设置每个单元的零距离。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果未启用编辑模式，则</font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用当前单元格调用新方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 坐标之间的距离 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在处于导航模式，触摸其中之一后，所有单元格均显示为零。</font><font style="vertical-align: inherit;">但是，当然，它们应该显示到单元格的真实距离。</font><font style="vertical-align: inherit;">要计算到它们的距离，我们可以使用像元的坐标。</font><font style="vertical-align: inherit;">因此，假设它</font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有方法</font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并在中使用它</font></font><code>HexGrid.FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在添加到</font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法中</font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他必须将自己的坐标与另一组坐标进行比较。</font><font style="vertical-align: inherit;">让我们仅从测量X开始，我们将相互减去X坐标。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - other.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，我们获得了相对于所选单元格沿X的偏移。</font><font style="vertical-align: inherit;">但是距离不能为负，因此您需要返回坐标差X模。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; other.x ? other.x - x : x - other.x;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdb/c62/16c/fdbc6216c12ae4a38ff7edaba203116e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿X的距离。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，仅在仅考虑一个维度的情况下，我们才能获得正确的距离。</font><font style="vertical-align: inherit;">但是六边形网格中有三个尺寸。</font><font style="vertical-align: inherit;">因此，让我们将所有三个维度的距离加起来，看看它能给我们带来什么。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/170/ac0/ffd170ac0b133a9b589e3dea9d6fd2b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XYZ距离的总和。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，我们得到的距离是原来的两倍。</font><font style="vertical-align: inherit;">即，为了获得正确的距离，必须将该数量分成两半。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z)) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/37d/353/9bd37d3535471f748d31be64ce897c17.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真实距离。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么总和等于距离的两倍？</font></font></b> <div class="spoiler_text">  ,       .      ,  (1, −3, 2).       .      ,       .      .   ,            .         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/533/197/09e533197dfc487db1c5b91f92fd6ba8.png"></div><br> <i> .</i> </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 克服障碍 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们计算出的距离对应于从选定单元格到其他单元格的最短路径。</font><font style="vertical-align: inherit;">我们找不到更短的方法。</font><font style="vertical-align: inherit;">但是，如果路由不阻塞任何内容，则可以保证这些路径是正确的。</font><font style="vertical-align: inherit;">悬崖，水和其他障碍物会使我们四处走走。</font><font style="vertical-align: inherit;">也许根本无法到达某些细胞。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了找到绕过障碍物的方法，我们需要使用其他方法，而不是简单地计算坐标之间的距离。</font><font style="vertical-align: inherit;">我们不再能够单独检查每个单元格。</font><font style="vertical-align: inherit;">我们将不得不搜索地图，直到找到可以到达的每个单元。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 搜索可视化 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图搜索是一个反复的过程。</font><font style="vertical-align: inherit;">要了解我们在做什么，查看搜索的每个阶段会有所帮助。</font><font style="vertical-align: inherit;">我们可以通过将搜索算法转换为协程来实现，为此我们需要一个搜索空间</font></font><code>System.Collections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">每秒60次迭代的刷新率很小，足以让我们看到正在发生的事情，并且在小地图上进行搜索并不会花费太多时间。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(Search(cell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要确保在任何给定时间只有一个搜索处于活动状态。</font><font style="vertical-align: inherit;">因此，在开始新搜索之前，我们将停止所有协程。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(cell)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此外，加载新地图时，我们需要完成搜索。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 广度优先搜索 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">甚至在开始搜索之前，我们就知道到选定单元格的距离为零。而且，如果可以达到的话，到所有邻居的距离当然是1。然后，我们可以看看这些邻居之一。此单元格很可能具有其自己的邻居，并且尚未计算出其距离。如果是这样，那么到这些邻居的距离应该是2。我们可以对距离为1的所有邻居重复此过程。之后，我们对距离为2的所有邻居重复此过程。依此类推，直到到达所有像元。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，首先找到距离为1的所有像元，然后找到距离为2的所有像元，然后距离为3的依此类推，依此类推，直到完成。</font><font style="vertical-align: inherit;">这样可以确保我们找到与每个可达单元的最小距离。</font><font style="vertical-align: inherit;">该算法称为广度优先搜索。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使其正常工作，我们需要知道是否已经确定到单元的距离。</font><font style="vertical-align: inherit;">为此，通常将单元格放置在称为现成或封闭集合的集合中。</font><font style="vertical-align: inherit;">但是我们可以设置到该单元格的距离以</font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指示我们尚未访问它。</font><font style="vertical-align: inherit;">我们需要在执行搜索之前对所有单元格执行此操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您也可以使用更改更改隐藏所有未访问的单元格</font></font><code>HexCell.UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">之后，我们将在空白地图上开始每次搜索。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue ? <span class="hljs-string"><span class="hljs-string">""</span></span> : distance.ToString(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们需要跟踪需要访问的单元以及它们的访问顺序。</font><font style="vertical-align: inherit;">这样的集合通常称为边界或开放集。</font><font style="vertical-align: inherit;">我们只需要按照遇到它们的相同顺序处理单元。</font><font style="vertical-align: inherit;">为此，您可以使用队列</font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它是命名空间的一部分</font></font><code>System.Collections.Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">所选单元格将是第一个放置在此队列中的单元，并且距离为0。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); Queue&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Enqueue(cell); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // yield return delay; // cells[i].Distance = // cell.coordinates.DistanceTo(cells[i].coordinates); // } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从这一刻起，当队列中有内容时，算法将执行循环。</font><font style="vertical-align: inherit;">在每次迭代时，都会从队列中检索最前面的单元格。</font></font><br><br><pre> <code class="cs hljs"> frontier.Enqueue(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们有了当前单元格，该单元格可以任意距离。</font><font style="vertical-align: inherit;">接下来，我们需要将其所有邻居添加到队列中，离所选单元格更远一步。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是，我们应该仅添加尚未指定距离的那些像元。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">广泛的搜索。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免饮水 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确保广度优先搜索在单调地图上找到正确的距离后，我们可以开始添加障碍。</font><font style="vertical-align: inherit;">如果满足某些条件，可以通过拒绝将单元格添加到队列中来完成。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，我们已经跳过了一些单元格：那些不存在的单元格，以及我们已经指出的距离。</font><font style="vertical-align: inherit;">让我们重写代码，以便在这种情况下我们显式跳过邻居。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还跳过所有在水下的细胞。</font><font style="vertical-align: inherit;">这意味着在搜索最短距离时，我们仅考虑地面运动。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无水移动距离。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该算法仍然可以找到最短的距离，但是现在可以避免所有积水。</font><font style="vertical-align: inherit;">因此，水下细胞永远不会像隔离的土地那样增加距离。</font><font style="vertical-align: inherit;">如果选择了水下单元，则仅接收距离。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免悬崖 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样，为了确定访问邻居的可能性，我们可以使用肋骨的类型。</font><font style="vertical-align: inherit;">例如，您可以让悬崖遮挡整个路径。</font><font style="vertical-align: inherit;">如果您允许在斜坡上移动，那么仅在其他路​​径上仍可以到达悬崖另一侧的单元。</font><font style="vertical-align: inherit;">因此，它们之间的距离可能非常不同。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有越过悬崖的距离。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 差旅费 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以避免像元和边，但是这些选项是二进制的。</font><font style="vertical-align: inherit;">可以想象，在某些方向上导航比在其他方向上导航更容易。</font><font style="vertical-align: inherit;">在这种情况下，距离是用人工或时间来衡量的。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 快速道路 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺理成章的是，在道路上行驶更容易，更快捷，因此，让我们让边缘与道路的交点变得更便宜。</font><font style="vertical-align: inherit;">由于我们使用整数值来设置距离，因此沿道路移动的成本将等于1，而与其他边缘交叉的成本将增加至10。这是一个很大的差异，可让我们立即查看是否获得正确的结果。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } neighbor.Distance = distance;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/225/6e3/8992256e34fef206c7282bc31a72a573.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">距离错误的道路。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 边框排序 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，事实证明，广度优先搜索无法在变动的移动成本下工作。</font><font style="vertical-align: inherit;">他假设将单元按距离增加的顺序添加到边界，对我们而言，这不再相关。</font><font style="vertical-align: inherit;">我们需要一个优先级队列，即一个对自身进行排序的队列。</font><font style="vertical-align: inherit;">没有标准优先级队列，因为您不能以适合所有情况的方式对其进行编程。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以创建自己的优先级队列，但是让我们在以后的教程中对其进行优化。</font><font style="vertical-align: inherit;">现在，我们仅将队列替换为具有method的列表</font></font><code>Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … neighbor.Distance = distance; frontier.Add(neighbor); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不能使用ListPool &lt;HexCell&gt;吗？</font></font></b> <div class="spoiler_text"> , ,  .       ,  ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使边框正确，我们需要在向其添加单元格后对其进行排序。</font><font style="vertical-align: inherit;">实际上，我们可以推迟排序，直到添加了单元的所有邻居为止，但是，我重复一遍，直到优化对我们不感兴趣为止。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们要按距离对单元格进行排序。</font><font style="vertical-align: inherit;">为此，我们需要调用列表排序方法，并带有执行该比较方法的链接。</font></font><br><br><pre> <code class="cs hljs"> frontier.Add(neighbor); frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种排序方法如何工作？</font></font></b> <div class="spoiler_text">     .     ,       .        . <br><br><pre> <code class="cs hljs"> frontier.Sort(CompareDistances); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareDistances</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell x, HexCell y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.Distance.CompareTo(y.Distance); }</code> </pre> </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ca/f5d/f85/2caf5df85335f7997694522b7885d882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">排序的边框仍然不正确。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 边框更新 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在开始对边界进行分类之后，我们开始获得更好的结果，但是仍然存在错误。这是因为将单元格添加到边界时，我们不一定会找到到该单元格的最短距离。这意味着现在我们不能再跳过已经分配了距离的邻居。相反，我们需要检查是否找到了更短的路径。如果是这样，那么我们需要更改到邻居的距离，而不是将其添加到边界。</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; } frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的距离。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们有了正确的距离，我们将开始考虑移动的成本。</font><font style="vertical-align: inherit;">您可能会注意到，到某些像元的距离最初太大，但是当它们从边界移开时会被校正。</font><font style="vertical-align: inherit;">这种方法称为Dijkstra算法，以Edsger Dijkstra的第一个发明命名。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 斜坡 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不希望仅限于公路成本。</font><font style="vertical-align: inherit;">例如，您可以将不带道路的平面边缘相交的成本降低到5，而不带道路的坡度的值为10。</font></font><br><br><pre> <code class="cs hljs"> HexEdgeType edgeType = current.GetEdgeType(neighbor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/8e1/1b5/8fd8e11b5a95d0e35ce03d1eb8bc32a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要克服斜坡，您需要做更多的工作，而且道路总是快的。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 救济对象 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以在存在救济物的情况下增加成本。</font><font style="vertical-align: inherit;">例如，在许多游戏中，导航森林更加困难。</font><font style="vertical-align: inherit;">在这种情况下，我们只需将对象的所有级别添加到距离中即可。</font><font style="vertical-align: inherit;">这条路再次加速了一切。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6e/ef4/b2b/f6eef4b2bba378bd83daf9377f9a1603.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果没有路，物体会减速。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 墙壁 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，让我们考虑一下墙壁。</font><font style="vertical-align: inherit;">如果道路不通过，则墙壁应阻止移动。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b3/9cd/7a9/1b39cd7a97483749c25474622ed8326b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁不允许我们通过，您需要寻找大门。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425919/">https://habr.com/ru/post/zh-CN425919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425905/index.html">如何用重叠的指令编写汇编代码（另一种混淆字节码的技术）</a></li>
<li><a href="../zh-CN425907/index.html">我们正在用Python做一个机器学习项目。 第二部分</a></li>
<li><a href="../zh-CN425911/index.html">将云CRM转移到盒装版本</a></li>
<li><a href="../zh-CN425915/index.html">跨境通信如何取代交通信号灯并缩短工作方式</a></li>
<li><a href="../zh-CN425917/index.html">正义战士阻止Waymo获得关键激光雷达技术的专利</a></li>
<li><a href="../zh-CN425921/index.html">在线有关CLRium＃4 +的.NET社区会议</a></li>
<li><a href="../zh-CN425923/index.html">25岁的厄运</a></li>
<li><a href="../zh-CN425925/index.html">以STUDIO 911为例创建布局中的3D打印</a></li>
<li><a href="../zh-CN425927/index.html">Arduino上的气象站，从A到Z。第2部分</a></li>
<li><a href="../zh-CN425929/index.html">谷歌放弃了争夺五角大楼第十亿个合同的斗争</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>