<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÄ üâê üôãüèæ Comprendre le protocole de pagination POCSAG ü§òüèª ü§≥üèæ ü•ü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a longtemps, quand un t√©l√©phone portable co√ªtait environ 2000 $ et qu'une minute d'appel vocal co√ªtait 50 cents, les t√©l√©avertisseurs √©taient vra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre le protocole de pagination POCSAG</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438906/">  Il y a longtemps, quand un t√©l√©phone portable co√ªtait environ 2000 $ et qu'une minute d'appel vocal co√ªtait 50 cents, les t√©l√©avertisseurs √©taient vraiment populaires.  Plus tard, les t√©l√©phones portables sont devenus moins chers, les prix des appels et des SMS sont devenus plus bas, et les t√©l√©avertisseurs ont finalement disparu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/7j/xw/8t7jxwauxqbonmzwmweakgmwpvw.jpeg"></div><br>  Pour les personnes qui poss√©daient un t√©l√©avertisseur auparavant et qui veulent savoir comment cela fonctionne, cet article sera utile. <br><a name="habracut"></a><br><h2>  Infos principales </h2><br>  Pour les personnes qui ont oubli√© les principes ou qui sont n√©es apr√®s 2000x, je rappellerai bri√®vement les principales id√©es. <br><br>  Le r√©seau de communication de radiomessagerie pr√©sente certains avantages, qui sont parfois encore importants aujourd'hui: <br><br>  - Il s'agit d'une communication √† sens unique, sans aucune sorte de confirmation, de sorte que le r√©seau ne peut pas √™tre surcharg√© - cela ne d√©pend tout simplement pas d'un certain nombre d'utilisateurs.  Les messages sont transmis en continu "tels quels", l'un apr√®s l'autre, et le pager re√ßoit le message si son num√©ro (appel√© Capcode) est √©gal au num√©ro interne de l'appareil. <br><br>  - Le r√©cepteur est tr√®s l√©ger (√† la fois litt√©ralement et √©lectroniquement), et peut fonctionner jusqu'√† un mois √† partir de 2 piles AA. <br><br>  Il existe deux normes de base pour la transmission des messages - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">POCSAG</a> (Post Office Code Standardization Advisory Group) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FLEX</a> .  Les deux normes sont assez anciennes, POCSAG a √©t√© fabriqu√© en 1982, il peut supporter des vitesses de 512, 1200 et 2400 bit / s.  Pour la transmission, la m√©thode FSK (fr√©quence shift keying) est utilis√©e avec une s√©paration de fr√©quence de 4,5 KHz.  FLEX est un peu plus r√©cent (a √©t√© fabriqu√© par Motorola au 90e), il peut fonctionner avec une vitesse allant jusqu'√† 6400 bit / s et peut utiliser √† la fois FSK2 et FSK4. <br><br>  Les deux protocoles sont en g√©n√©ral tr√®s faciles, et il y a environ 20 ans, des d√©codeurs PC ont √©t√© cr√©√©s, qui peuvent d√©coder les messages √† partir d'un port s√©rie de la carte son (aucun cryptage n'est pris en charge, donc tous les messages peuvent √™tre lus par n'importe qui). <br><br>  Regardons comment cela fonctionne. <br><br><h2>  Recevoir un signal </h2><br>  Tout d'abord, nous avons besoin d'un signal pour le d√©codage.  Permet de prendre un ordinateur portable, un r√©cepteur rtl-sdr et de l'obtenir. <br><br><img src="https://habrastorage.org/webt/vj/ba/2g/vjba2gslgleejthwn_m8ccsvf00.jpeg"><br><br>  La touche de d√©calage de fr√©quence est utilis√©e, nous allons donc d√©finir FM.  Avec HDSDR, nous enregistrerons un signal au format WAV. <br><br>  V√©rifions ce que nous obtenons.  Chargement du fichier wav en tant que tableau de donn√©es Python: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"pocsag.wav"</span></span>) plt.plot(data) plt.show()</code> </pre> <br>  Sortie (bits ajout√©s manuellement): <br><br><img src="https://habrastorage.org/webt/pm/ss/y7/pmssy79glsbnfsgxogjd93ylqre.jpeg"><br><br>  Comme nous pouvons le voir, c'est facile, et m√™me "√† l'≈ìil nu", nous pouvons dessiner des bits dans Paint, il est facile de distinguer o√π est "0" et o√π est "1".  Mais il sera trop long de le faire manuellement, il est temps d'automatiser le processus. <br><br>  Apr√®s avoir agrandi le graphique, nous pouvons voir que chaque bit a une largeur de 20 √©chantillons.  Nous avons 24000 √©chantillons par seconde de fichier wav de d√©bit binaire, donc la vitesse de saisie est de 1200bit / s.  Permet de trouver une position de passage √† z√©ro - c'est le d√©but de la s√©quence de bits.  Permet √©galement d'ajouter des marqueurs pour v√©rifier que tous les bits sont aux bons endroits. <br><br><pre> <code class="python hljs">speed = <span class="hljs-number"><span class="hljs-number">1200</span></span> fs = <span class="hljs-number"><span class="hljs-number">24000</span></span> cnt = int(fs/speed) start = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>*cnt): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[p] &lt; - <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[p+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>: start = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment"># Bits frame bits = np.zeros(data.size) for p in range(0, data.size - cnt, cnt): bits[start + p] = 500 plt.plot(bits)</span></span></code> </pre><br>  Comme nous pouvons le voir, son ne correspond pas parfaitement (l'√©metteur et le r√©cepteur ont des fr√©quences l√©g√®rement diff√©rentes), mais c'est certainement suffisant pour le d√©codage. <br><br><img src="https://habrastorage.org/webt/hc/s1/lf/hcs1lfxgchl-ngpkyeemhhsgrly.jpeg"><br><br>  Pour les signaux longs, nous aurons probablement besoin d'un algorithme de correction de fr√©quence automatique, mais pour ce type de signaux, ce n'est pas critique. <br><br>  La derni√®re √©tape - nous devons traduire le fichier wav dans la s√©quence de bits.  C'est aussi facile, nous connaissons la longueur de chaque bit, si la somme des donn√©es est positive, nous ajouterons ¬´1¬ª, sinon ¬´0¬ª (enfin, il a √©t√© constat√© qu'un signal doit √™tre invers√©, donc 0 et 1 ont √©t√© remplac√©s) . <br><br><pre> <code class="python hljs">bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, data.size - cnt, cnt): s = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(p, p+cnt): s += data[p] bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> print(<span class="hljs-string"><span class="hljs-string">"Bits"</span></span>) print(bits_str)</code> </pre><br>  Sortie - s√©quence de bits appropri√©e (sous forme de cha√Æne), qui contient notre message. <br><br> <code>101010101010101010101010101010101010101010101010101010101010101010101010101 <br> 010101010101010101010101010101010101010101010100111110011010010000101001101 <br> 100001111010100010011100000110010111011110101000100111000001100101110111101 <br> 010001001110000011001011101111010100010011100000110010111011110101000100111 <br> 000001100101110111101010001001110000011001011101111010100010011100000110010 <br> 011011110101000100111000001100101110111101010001001110000011001011101111010 <br> 100010011100000110010111011110101000100111000001100101110111101010001001110 <br> ... <br> 111101111</code> <br> <br><h2>  D√©codage des messages num√©riques uniquement </h2><br>  Une s√©quence de bits est beaucoup plus pratique qu'un fichier wav, nous pouvons en extraire des donn√©es.  Tout d'abord, permet de diviser les donn√©es en blocs de 4 octets. <br><br> <code>10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> <br> 01111100110100100001010011011000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00001000011011110100010001101000 <br> 10000011010000010101010011010100 <br> <br> 01111100110100100001010111011000 <br> 11110101010001000001000000111000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00100101101001011010010100101111</code> <br> <br>  Nous pouvons certainement voir un mod√®le.  Maintenant, nous devons trouver ce que signifie chaque partie.  Le manuel POCSAG est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">au format PDF</a> , permet de v√©rifier la description des structures de donn√©es. <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png"><br><br>  C'est maintenant beaucoup plus clair.  L'en-t√™te contient un long bloc "10101010101", il est utilis√© pour "r√©veiller" le pager d'un mode veille.  Le message lui-m√™me contient les blocs Batch-1 ... Batch-N, chaque bloc part de la s√©quence unique FSC.  Ensuite, comme nous pouvons le voir dans le manuel, si la cha√Æne commence √† "0", elle contient l'adresse du destinataire.  L'adresse elle-m√™me (capcode) est stock√©e est le pager, et si elle ne correspond pas, le pager ignorera le message.  Si une cha√Æne commence √† "1", elle contient le corps du message.  Dans notre exemple, nous avons 2 cha√Ænes de ce type. <br><br>  Permet de ne pas v√©rifier chaque bloc.  Nous pouvons √©galement voir les codes inactifs - blocs vides 01111 ... 0111, ils ne contiennent aucune information utile.  Apr√®s les avoir supprim√©s, nous obtenons seulement ceci: <br><br> <code>01111100110100100001010011011000 - Frame Sync <br> 00001000011011110100010001101000 - Address <br> 10000011010000010101010011010100 - Message <br> <br> 01111100110100100001010111011000 - Frame Sync <br> 11110101010001000001000000111000 - Message <br> 00100101101001011010010100101111 - Address</code> <br> <br>  Nous devons trouver ce qui se trouve √† l'int√©rieur. <br><br>  Apr√®s avoir v√©rifi√© le manuel, il est clair qu'il existe deux types de messages - <b>uniquement num√©riques</b> et <b>alphanum√©riques</b> .  Les messages num√©riques sont enregistr√©s sous forme de codes BCD 4 bits, donc 20 bits peuvent contenir 5 symboles (il y a aussi des bits CRC, nous ne les utilisons pas pour l'instant).  Si le message est alphanum√©rique, le codage ASCII 7 bits est utilis√©.  Ce message est trop court, il ne peut donc s'agir que d'un message uniquement num√©rique. <br><br>  √Ä partir des cha√Ænes 10000011010000010101010011010100 et 11110101010001000001000000111000, nous pouvons obtenir ces s√©quences de 4 bits: <br>  <i>1 0000 0110 1000 0010 10101 0011010100</i> - 0h 6h 8h 2h Ah <br>  <i>1 1110 1010 1000 1000 00100 0000111000</i> - Eh Ah 8h 8h 2h <br><br>  L'√©tape suivante consiste √† obtenir la table de d√©codage du manuel: <br><br><img src="https://habrastorage.org/webt/vb/sj/zl/vbsjzluxbhaeuy_zrefccmqhogw.jpeg"><br><br>  Il est √©vident qu'un message uniquement num√©rique peut contenir des chiffres de 0 √† 9, la lettre U ("ugrent"), un espace et deux parenth√®ses.  Permet d'√©crire une petite m√©thode pour le d√©coder: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 16 lines in a batch, each block has a length 32 bits for cw in range(16): cws = block[32 * cw:32 * (cw + 1)] if cws[0] == "0": addr = cws[1:19] print(" Addr:" + addr) else: msg = cws[1:21] print(" Msg: " + msg) size = 4 s = "" for ind in range(0, len(msg), size): bcd_s = msg[ind:ind + size] value = int(bcd_s, 2) symbols = "0123456789*U -)(" s += symbols[value] print(" ", s) print()</span></span></code> </pre><br>  Enfin, nous obtenons un message "0682 *) * 882". <br><br>  Il est difficile de dire ce que cela signifie, mais si les messages uniquement num√©riques sont utilis√©s, quelqu'un en a probablement besoin. <br><br><h2>  D√©codage des messages alphanum√©riques </h2><br>  L'√©tape suivante, et plus int√©ressante, consiste √† d√©coder les messages alphanum√©riques.  C'est plus int√©ressant, car en sortie, nous devrions obtenir le texte lisible par l'homme. <br><br>  Tout d'abord, nous devons enregistrer √† nouveau un message, nous utiliserons HDSDR.  Nous ne connaissons pas un type de message avant le d√©codage, nous allons donc simplement enregistrer un message le plus long, nous pouvons l'obtenir, et esp√©rons qu'il contiendra du texte. <br><br><img src="https://habrastorage.org/webt/lu/ue/sk/luuesk79iv_yalka_pchncpwzoi.jpeg"><br><br>  Apr√®s la conversion de wav en une s√©quence de bits (voir un code Python ci-dessus), nous obtenons ceci: <br><br><img src="https://habrastorage.org/webt/qb/wt/ud/qbwtud3zptfcwxw3xs0pam7pkr4.jpeg"><br><br>  Certaines choses int√©ressantes que nous pouvons voir imm√©diatement, √† l'≈ìil nu - par exemple, la s√©quence de d√©marrage 01010101010101 se r√©p√®te deux fois.  Ainsi, ce message n'est pas seulement plus long, il contient litt√©ralement deux messages, fusionn√©s ensemble (une norme ne le nie pas, btw). <br><br>  Comme nous l'avons constat√© pr√©c√©demment, chaque bloc de donn√©es commence √† partir d'une s√©quence, appel√©e Frame Sync Code (01111100 ...), apr√®s son envoi de blocs 32 bits.  Chaque bloc peut stocker l'adresse ou le corps du message. <br><br>  Auparavant, nous recevions les messages num√©riques uniquement, maintenant nous voulons lire les messages ASCII.  Tout d'abord, nous devons les distinguer.  Ces donn√©es sont enregistr√©es dans un champ "Function Bits" (bits 20-21) - si les deux bits sont 00, c'est un message uniquement num√©rique, si les bits sont 11, c'est un message texte. <br><br>  Il est int√©ressant de mentionner que ce champ de message est de 20 bits, il est donc id√©al d'y placer cinq blocs de 4 bits dans le cas d'un message num√©rique uniquement.  Mais si nous avons un message ASCII 7 bits, nous ne pouvons pas diviser 20 √† 7. Il est possible de pr√©dire que la premi√®re version du protocole ne supportait que les messages num√©riques (n'oubliez pas qu'il a √©t√© cr√©√© en 1982 <s>et probablement les premiers pagers √† tube nixie n'ont pas pu afficher plus</s> ), et seule la prise en charge des messages ASCII ult√©rieurs a √©t√© ajout√©e.  Pour des raisons h√©rit√©es, la norme de cadrage n'a pas √©t√© modifi√©e et les d√©veloppeurs ont utilis√© l'approche simple - ils ont simplement combin√© les bits "tels quels", l'un apr√®s l'autre.  De chaque message, nous devons prendre 20 bits et le fusionner au suivant, enfin nous pouvons d√©coder le corps du message. <br><br>  Permet de voir un bloc de notre message (les espaces ont √©t√© ajout√©s pour faciliter la lecture): <br><br> <code>0 0001010011100010111111110010010 <br> 1 00010100000110110011 11100111001 <br> 1 01011010011001110100 01111011100 <br> 1 11010001110110100100 11011000100 <br> 1 11000001101000110100 10011110111 <br> 1 11100000010100011011 11101110000 <br> 1 00110010111011001101 10011011010 <br> 1 00011001011100010110 10011000010 <br> 1 10101100000010010101 10110000101 <br> 1 00010110111011001101 00000011011 <br> 1 10100101000000101000 11001010100 <br> 1 00111101010101101100 11011111010</code> <br> <br>  Bit "0" Dans la premi√®re cha√Æne nous montre que c'est le champ d'adresse, et "11" dans 20-21 bits nous montre que le message est vraiment alphanum√©rique.  Ensuite, nous prenons simplement 20 bits de chaque cha√Æne et les fusionnons ensemble. <br><br>  Voici notre s√©quence de bits: <br><br> <code>00010100000110110011010110100110011101001101000111011010010011000001101000 <br> 11010011100000010100011011001100101110110011010001100101110001011010101100 <br> 000010010101000101101110110011011010010100000010100000111101010101101</code> <br> <br>  Dans POCSAG, le code ASCII 7 bits est utilis√©, nous allons donc diviser une cha√Æne en 7 blocs de caract√®res: <br><br> <code>0001010 0000110 1100110 1011010 0110011 1010011 ...</code> <br> <br>  Apr√®s avoir essay√© de le d√©coder (la table ASCII peut √™tre facilement trouv√©e sur Internet), nous obtenons ... juste rien.  En v√©rifiant √† nouveau le manuel, voici la petite phrase "Les caract√®res ASCII sont plac√©s de gauche √† droite (MSB √† LSB).  Le LSB transmet en premier. ".  Ainsi, le bit bas transmet en premier - pour un d√©codage correct, nous devons inverser toutes les cha√Ænes. <br><br>  C'est trop ennuyeux pour le faire manuellement, alors √©crivons un code Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> msgs = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">16</span></span>): cws = block[<span class="hljs-number"><span class="hljs-number">32</span></span> * cw:<span class="hljs-number"><span class="hljs-number">32</span></span> * (cw + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-comment"><span class="hljs-comment"># Skip the idle word if cws.startswith("0111101010"): continue if cws[0] == "0": addr, type = cws[1:19], cws[19:21] print(" Addr:" + addr, type) else: msg = cws[1:21] print(" Msg: " + msg) msgs += msg # Split long string to 7 chars blocks bits = [msgs[i:i+7] for i in range(0, len(msgs), 7)] # Get the message msg = "" for b in bits: b1 = b[::-1] # Revert string value = int(b1, 2) msg += chr(value) print("Msg:", msg) print()</span></span></code> </pre><br>  Enfin, nous obtenons cette s√©quence (bits, codes de symboles et symboles ASCII): <br><br><pre> <code class="plaintext hljs">0101000 40 ( 0110000 48 0 0110011 51 3 0101101 45 - 1100110 102 f 1100101 101 e 1100010 98 b 0101101 45 - 0110010 50 2 0110000 48 0 0110001 49 1 0111001 57 9 0100000 32 0110001 49 1 0110011 51 3 0111010 58 : 0110011 51 3 0110001 49 1 0111010 58 : 0110100 52 4 0110101 53 5 0100000 32 0101010 42 * 0110100 52 4 0110111 55 7 0110110 54 6 0101001 41 ) 0100000 32 1000001 65 A 1010111 87 W 1011010 90 Z</code> </pre><br>  Apr√®s la fusion, nous obtenons la cha√Æne: "(03-feb-2019 13:31:45 * 476) AWZ".  Comme promis, c'est assez lisible par l'homme. <br><br>  Soit dit en passant, il est int√©ressant de mentionner que les codes ASCII 7 bits sont utilis√©s.  Les symboles de certains alphabets (allemand, cyrillique, etc.) ne peuvent pas √™tre correctement cod√©s en 7 bits.  Pourquoi 7 bits?  Probablement les ing√©nieurs avaient d√©cid√© que "7 bits suffiront √† tous", qui sait ... <br><br><h2>  Conclusion </h2><br>  C'√©tait vraiment int√©ressant de voir comment fonctionne POCSAG.  C'est l'un des rares protocoles, en usage jusqu'√† pr√©sent, qui peut litt√©ralement √™tre d√©cod√© sur la feuille de papier (et je ne vais certainement pas essayer cela avec TETRA ou GSM). <br><br>  Bien s√ªr, le protocole POCSAG n'est pas enti√®rement d√©crit ici.  La partie la plus importante et la plus int√©ressante est termin√©e, d'autres choses ne sont pas si excitantes.  Au moins, il n'y a pas de d√©codage de codes √† barres et il n'y a pas de code de correction d'erreur (BCH Check Bits) - il peut permettre de corriger jusqu'√† 2 bits incorrects dans le message.  Mais il n'y avait aucun objectif d'√©crire un autre d√©codeur POCSAG ici, il y en a d√©j√† assez. <br><br>  Pour ceux qui veulent tester le vrai d√©codage avec rtl-sdr, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application PDW</a> freeware peut √™tre utilis√©e.  Il ne n√©cessite pas d'installation, il suffit de transmettre le son du HDSDR au PDW via l'application Virtual Audio Cable. <br><br>  Le r√©sultat ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/-7/g-/ka/-7g-kalvhmaqlv79qju-wmgpglg.jpeg"><br><br>  (veuillez garder √† l'esprit que le d√©codage des messages de service public peut √™tre ill√©gal dans certains pays, et de toute fa√ßon respecter la vie priv√©e des destinataires) <br><br>  Si quelqu'un veut obtenir plus d'informations sur ce sujet, les sources du d√©codeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">multimon-ng</a> sont disponibles, il peut d√©coder de nombreux protocoles, √©galement POCSAG et FLEX. <br><br>  Merci d'avoir lu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438906/">https://habr.com/ru/post/fr438906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438894/index.html">Pourquoi le d√©veloppement Web sur Go est plus agr√©able que sur PHP</a></li>
<li><a href="../fr438896/index.html">Ne pleure pas</a></li>
<li><a href="../fr438898/index.html">Installation invers√©e et d'extension de Chrome</a></li>
<li><a href="../fr438900/index.html">En route vers les principes physiques de l'√©volution biologique. Fin + texte int√©gral de la traduction</a></li>
<li><a href="../fr438902/index.html">Utilisation de DBREPLICATION lors de la r√©duction de bases de donn√©es sur Microsoft SQL Server</a></li>
<li><a href="../fr438908/index.html">Formation Cisco 200-125 CCNA v3.0. Sp√©cialiste r√©seau certifi√© Cisco (CCNA). Jour 1. Bases du r√©seau</a></li>
<li><a href="../fr438910/index.html">Samba en tant qu'ADDC dans Solaris 11.4</a></li>
<li><a href="../fr438916/index.html">Notes d'un phytochimiste. La pomme de terre. Troisi√®me partie. "Bullet Fugu" ou SOLANIN</a></li>
<li><a href="../fr438920/index.html">Avalonia: premi√®re rencontre</a></li>
<li><a href="../fr438922/index.html">Chiffrement du trafic dans Direct Connect, partie 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>