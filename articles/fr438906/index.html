<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎀 🉐 🙋🏾 Comprendre le protocole de pagination POCSAG 🤘🏻 🤳🏾 🥟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a longtemps, quand un téléphone portable coûtait environ 2000 $ et qu'une minute d'appel vocal coûtait 50 cents, les téléavertisseurs étaient vra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre le protocole de pagination POCSAG</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438906/">  Il y a longtemps, quand un téléphone portable coûtait environ 2000 $ et qu'une minute d'appel vocal coûtait 50 cents, les téléavertisseurs étaient vraiment populaires.  Plus tard, les téléphones portables sont devenus moins chers, les prix des appels et des SMS sont devenus plus bas, et les téléavertisseurs ont finalement disparu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/7j/xw/8t7jxwauxqbonmzwmweakgmwpvw.jpeg"></div><br>  Pour les personnes qui possédaient un téléavertisseur auparavant et qui veulent savoir comment cela fonctionne, cet article sera utile. <br><a name="habracut"></a><br><h2>  Infos principales </h2><br>  Pour les personnes qui ont oublié les principes ou qui sont nées après 2000x, je rappellerai brièvement les principales idées. <br><br>  Le réseau de communication de radiomessagerie présente certains avantages, qui sont parfois encore importants aujourd'hui: <br><br>  - Il s'agit d'une communication à sens unique, sans aucune sorte de confirmation, de sorte que le réseau ne peut pas être surchargé - cela ne dépend tout simplement pas d'un certain nombre d'utilisateurs.  Les messages sont transmis en continu "tels quels", l'un après l'autre, et le pager reçoit le message si son numéro (appelé Capcode) est égal au numéro interne de l'appareil. <br><br>  - Le récepteur est très léger (à la fois littéralement et électroniquement), et peut fonctionner jusqu'à un mois à partir de 2 piles AA. <br><br>  Il existe deux normes de base pour la transmission des messages - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">POCSAG</a> (Post Office Code Standardization Advisory Group) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FLEX</a> .  Les deux normes sont assez anciennes, POCSAG a été fabriqué en 1982, il peut supporter des vitesses de 512, 1200 et 2400 bit / s.  Pour la transmission, la méthode FSK (fréquence shift keying) est utilisée avec une séparation de fréquence de 4,5 KHz.  FLEX est un peu plus récent (a été fabriqué par Motorola au 90e), il peut fonctionner avec une vitesse allant jusqu'à 6400 bit / s et peut utiliser à la fois FSK2 et FSK4. <br><br>  Les deux protocoles sont en général très faciles, et il y a environ 20 ans, des décodeurs PC ont été créés, qui peuvent décoder les messages à partir d'un port série de la carte son (aucun cryptage n'est pris en charge, donc tous les messages peuvent être lus par n'importe qui). <br><br>  Regardons comment cela fonctionne. <br><br><h2>  Recevoir un signal </h2><br>  Tout d'abord, nous avons besoin d'un signal pour le décodage.  Permet de prendre un ordinateur portable, un récepteur rtl-sdr et de l'obtenir. <br><br><img src="https://habrastorage.org/webt/vj/ba/2g/vjba2gslgleejthwn_m8ccsvf00.jpeg"><br><br>  La touche de décalage de fréquence est utilisée, nous allons donc définir FM.  Avec HDSDR, nous enregistrerons un signal au format WAV. <br><br>  Vérifions ce que nous obtenons.  Chargement du fichier wav en tant que tableau de données Python: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"pocsag.wav"</span></span>) plt.plot(data) plt.show()</code> </pre> <br>  Sortie (bits ajoutés manuellement): <br><br><img src="https://habrastorage.org/webt/pm/ss/y7/pmssy79glsbnfsgxogjd93ylqre.jpeg"><br><br>  Comme nous pouvons le voir, c'est facile, et même "à l'œil nu", nous pouvons dessiner des bits dans Paint, il est facile de distinguer où est "0" et où est "1".  Mais il sera trop long de le faire manuellement, il est temps d'automatiser le processus. <br><br>  Après avoir agrandi le graphique, nous pouvons voir que chaque bit a une largeur de 20 échantillons.  Nous avons 24000 échantillons par seconde de fichier wav de débit binaire, donc la vitesse de saisie est de 1200bit / s.  Permet de trouver une position de passage à zéro - c'est le début de la séquence de bits.  Permet également d'ajouter des marqueurs pour vérifier que tous les bits sont aux bons endroits. <br><br><pre> <code class="python hljs">speed = <span class="hljs-number"><span class="hljs-number">1200</span></span> fs = <span class="hljs-number"><span class="hljs-number">24000</span></span> cnt = int(fs/speed) start = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>*cnt): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data[p] &lt; - <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[p+<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>: start = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment"># Bits frame bits = np.zeros(data.size) for p in range(0, data.size - cnt, cnt): bits[start + p] = 500 plt.plot(bits)</span></span></code> </pre><br>  Comme nous pouvons le voir, son ne correspond pas parfaitement (l'émetteur et le récepteur ont des fréquences légèrement différentes), mais c'est certainement suffisant pour le décodage. <br><br><img src="https://habrastorage.org/webt/hc/s1/lf/hcs1lfxgchl-ngpkyeemhhsgrly.jpeg"><br><br>  Pour les signaux longs, nous aurons probablement besoin d'un algorithme de correction de fréquence automatique, mais pour ce type de signaux, ce n'est pas critique. <br><br>  La dernière étape - nous devons traduire le fichier wav dans la séquence de bits.  C'est aussi facile, nous connaissons la longueur de chaque bit, si la somme des données est positive, nous ajouterons «1», sinon «0» (enfin, il a été constaté qu'un signal doit être inversé, donc 0 et 1 ont été remplacés) . <br><br><pre> <code class="python hljs">bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, data.size - cnt, cnt): s = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(p, p+cnt): s += data[p] bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> print(<span class="hljs-string"><span class="hljs-string">"Bits"</span></span>) print(bits_str)</code> </pre><br>  Sortie - séquence de bits appropriée (sous forme de chaîne), qui contient notre message. <br><br> <code>101010101010101010101010101010101010101010101010101010101010101010101010101 <br> 010101010101010101010101010101010101010101010100111110011010010000101001101 <br> 100001111010100010011100000110010111011110101000100111000001100101110111101 <br> 010001001110000011001011101111010100010011100000110010111011110101000100111 <br> 000001100101110111101010001001110000011001011101111010100010011100000110010 <br> 011011110101000100111000001100101110111101010001001110000011001011101111010 <br> 100010011100000110010111011110101000100111000001100101110111101010001001110 <br> ... <br> 111101111</code> <br> <br><h2>  Décodage des messages numériques uniquement </h2><br>  Une séquence de bits est beaucoup plus pratique qu'un fichier wav, nous pouvons en extraire des données.  Tout d'abord, permet de diviser les données en blocs de 4 octets. <br><br> <code>10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> 10101010101010101010101010101010 <br> <br> 01111100110100100001010011011000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00001000011011110100010001101000 <br> 10000011010000010101010011010100 <br> <br> 01111100110100100001010111011000 <br> 11110101010001000001000000111000 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 01111010100010011100000110010111 <br> 00100101101001011010010100101111</code> <br> <br>  Nous pouvons certainement voir un modèle.  Maintenant, nous devons trouver ce que signifie chaque partie.  Le manuel POCSAG est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">au format PDF</a> , permet de vérifier la description des structures de données. <br><br><img src="https://habrastorage.org/webt/3k/yt/dc/3kytdccgmehfmqstxxli1nt3fpa.png"><br><br>  C'est maintenant beaucoup plus clair.  L'en-tête contient un long bloc "10101010101", il est utilisé pour "réveiller" le pager d'un mode veille.  Le message lui-même contient les blocs Batch-1 ... Batch-N, chaque bloc part de la séquence unique FSC.  Ensuite, comme nous pouvons le voir dans le manuel, si la chaîne commence à "0", elle contient l'adresse du destinataire.  L'adresse elle-même (capcode) est stockée est le pager, et si elle ne correspond pas, le pager ignorera le message.  Si une chaîne commence à "1", elle contient le corps du message.  Dans notre exemple, nous avons 2 chaînes de ce type. <br><br>  Permet de ne pas vérifier chaque bloc.  Nous pouvons également voir les codes inactifs - blocs vides 01111 ... 0111, ils ne contiennent aucune information utile.  Après les avoir supprimés, nous obtenons seulement ceci: <br><br> <code>01111100110100100001010011011000 - Frame Sync <br> 00001000011011110100010001101000 - Address <br> 10000011010000010101010011010100 - Message <br> <br> 01111100110100100001010111011000 - Frame Sync <br> 11110101010001000001000000111000 - Message <br> 00100101101001011010010100101111 - Address</code> <br> <br>  Nous devons trouver ce qui se trouve à l'intérieur. <br><br>  Après avoir vérifié le manuel, il est clair qu'il existe deux types de messages - <b>uniquement numériques</b> et <b>alphanumériques</b> .  Les messages numériques sont enregistrés sous forme de codes BCD 4 bits, donc 20 bits peuvent contenir 5 symboles (il y a aussi des bits CRC, nous ne les utilisons pas pour l'instant).  Si le message est alphanumérique, le codage ASCII 7 bits est utilisé.  Ce message est trop court, il ne peut donc s'agir que d'un message uniquement numérique. <br><br>  À partir des chaînes 10000011010000010101010011010100 et 11110101010001000001000000111000, nous pouvons obtenir ces séquences de 4 bits: <br>  <i>1 0000 0110 1000 0010 10101 0011010100</i> - 0h 6h 8h 2h Ah <br>  <i>1 1110 1010 1000 1000 00100 0000111000</i> - Eh Ah 8h 8h 2h <br><br>  L'étape suivante consiste à obtenir la table de décodage du manuel: <br><br><img src="https://habrastorage.org/webt/vb/sj/zl/vbsjzluxbhaeuy_zrefccmqhogw.jpeg"><br><br>  Il est évident qu'un message uniquement numérique peut contenir des chiffres de 0 à 9, la lettre U ("ugrent"), un espace et deux parenthèses.  Permet d'écrire une petite méthode pour le décoder: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 16 lines in a batch, each block has a length 32 bits for cw in range(16): cws = block[32 * cw:32 * (cw + 1)] if cws[0] == "0": addr = cws[1:19] print(" Addr:" + addr) else: msg = cws[1:21] print(" Msg: " + msg) size = 4 s = "" for ind in range(0, len(msg), size): bcd_s = msg[ind:ind + size] value = int(bcd_s, 2) symbols = "0123456789*U -)(" s += symbols[value] print(" ", s) print()</span></span></code> </pre><br>  Enfin, nous obtenons un message "0682 *) * 882". <br><br>  Il est difficile de dire ce que cela signifie, mais si les messages uniquement numériques sont utilisés, quelqu'un en a probablement besoin. <br><br><h2>  Décodage des messages alphanumériques </h2><br>  L'étape suivante, et plus intéressante, consiste à décoder les messages alphanumériques.  C'est plus intéressant, car en sortie, nous devrions obtenir le texte lisible par l'homme. <br><br>  Tout d'abord, nous devons enregistrer à nouveau un message, nous utiliserons HDSDR.  Nous ne connaissons pas un type de message avant le décodage, nous allons donc simplement enregistrer un message le plus long, nous pouvons l'obtenir, et espérons qu'il contiendra du texte. <br><br><img src="https://habrastorage.org/webt/lu/ue/sk/luuesk79iv_yalka_pchncpwzoi.jpeg"><br><br>  Après la conversion de wav en une séquence de bits (voir un code Python ci-dessus), nous obtenons ceci: <br><br><img src="https://habrastorage.org/webt/qb/wt/ud/qbwtud3zptfcwxw3xs0pam7pkr4.jpeg"><br><br>  Certaines choses intéressantes que nous pouvons voir immédiatement, à l'œil nu - par exemple, la séquence de démarrage 01010101010101 se répète deux fois.  Ainsi, ce message n'est pas seulement plus long, il contient littéralement deux messages, fusionnés ensemble (une norme ne le nie pas, btw). <br><br>  Comme nous l'avons constaté précédemment, chaque bloc de données commence à partir d'une séquence, appelée Frame Sync Code (01111100 ...), après son envoi de blocs 32 bits.  Chaque bloc peut stocker l'adresse ou le corps du message. <br><br>  Auparavant, nous recevions les messages numériques uniquement, maintenant nous voulons lire les messages ASCII.  Tout d'abord, nous devons les distinguer.  Ces données sont enregistrées dans un champ "Function Bits" (bits 20-21) - si les deux bits sont 00, c'est un message uniquement numérique, si les bits sont 11, c'est un message texte. <br><br>  Il est intéressant de mentionner que ce champ de message est de 20 bits, il est donc idéal d'y placer cinq blocs de 4 bits dans le cas d'un message numérique uniquement.  Mais si nous avons un message ASCII 7 bits, nous ne pouvons pas diviser 20 à 7. Il est possible de prédire que la première version du protocole ne supportait que les messages numériques (n'oubliez pas qu'il a été créé en 1982 <s>et probablement les premiers pagers à tube nixie n'ont pas pu afficher plus</s> ), et seule la prise en charge des messages ASCII ultérieurs a été ajoutée.  Pour des raisons héritées, la norme de cadrage n'a pas été modifiée et les développeurs ont utilisé l'approche simple - ils ont simplement combiné les bits "tels quels", l'un après l'autre.  De chaque message, nous devons prendre 20 bits et le fusionner au suivant, enfin nous pouvons décoder le corps du message. <br><br>  Permet de voir un bloc de notre message (les espaces ont été ajoutés pour faciliter la lecture): <br><br> <code>0 0001010011100010111111110010010 <br> 1 00010100000110110011 11100111001 <br> 1 01011010011001110100 01111011100 <br> 1 11010001110110100100 11011000100 <br> 1 11000001101000110100 10011110111 <br> 1 11100000010100011011 11101110000 <br> 1 00110010111011001101 10011011010 <br> 1 00011001011100010110 10011000010 <br> 1 10101100000010010101 10110000101 <br> 1 00010110111011001101 00000011011 <br> 1 10100101000000101000 11001010100 <br> 1 00111101010101101100 11011111010</code> <br> <br>  Bit "0" Dans la première chaîne nous montre que c'est le champ d'adresse, et "11" dans 20-21 bits nous montre que le message est vraiment alphanumérique.  Ensuite, nous prenons simplement 20 bits de chaque chaîne et les fusionnons ensemble. <br><br>  Voici notre séquence de bits: <br><br> <code>00010100000110110011010110100110011101001101000111011010010011000001101000 <br> 11010011100000010100011011001100101110110011010001100101110001011010101100 <br> 000010010101000101101110110011011010010100000010100000111101010101101</code> <br> <br>  Dans POCSAG, le code ASCII 7 bits est utilisé, nous allons donc diviser une chaîne en 7 blocs de caractères: <br><br> <code>0001010 0000110 1100110 1011010 0110011 1010011 ...</code> <br> <br>  Après avoir essayé de le décoder (la table ASCII peut être facilement trouvée sur Internet), nous obtenons ... juste rien.  En vérifiant à nouveau le manuel, voici la petite phrase "Les caractères ASCII sont placés de gauche à droite (MSB à LSB).  Le LSB transmet en premier. ".  Ainsi, le bit bas transmet en premier - pour un décodage correct, nous devons inverser toutes les chaînes. <br><br>  C'est trop ennuyeux pour le faire manuellement, alors écrivons un code Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block)</span></span></span><span class="hljs-function">:</span></span> msgs = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">16</span></span>): cws = block[<span class="hljs-number"><span class="hljs-number">32</span></span> * cw:<span class="hljs-number"><span class="hljs-number">32</span></span> * (cw + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-comment"><span class="hljs-comment"># Skip the idle word if cws.startswith("0111101010"): continue if cws[0] == "0": addr, type = cws[1:19], cws[19:21] print(" Addr:" + addr, type) else: msg = cws[1:21] print(" Msg: " + msg) msgs += msg # Split long string to 7 chars blocks bits = [msgs[i:i+7] for i in range(0, len(msgs), 7)] # Get the message msg = "" for b in bits: b1 = b[::-1] # Revert string value = int(b1, 2) msg += chr(value) print("Msg:", msg) print()</span></span></code> </pre><br>  Enfin, nous obtenons cette séquence (bits, codes de symboles et symboles ASCII): <br><br><pre> <code class="plaintext hljs">0101000 40 ( 0110000 48 0 0110011 51 3 0101101 45 - 1100110 102 f 1100101 101 e 1100010 98 b 0101101 45 - 0110010 50 2 0110000 48 0 0110001 49 1 0111001 57 9 0100000 32 0110001 49 1 0110011 51 3 0111010 58 : 0110011 51 3 0110001 49 1 0111010 58 : 0110100 52 4 0110101 53 5 0100000 32 0101010 42 * 0110100 52 4 0110111 55 7 0110110 54 6 0101001 41 ) 0100000 32 1000001 65 A 1010111 87 W 1011010 90 Z</code> </pre><br>  Après la fusion, nous obtenons la chaîne: "(03-feb-2019 13:31:45 * 476) AWZ".  Comme promis, c'est assez lisible par l'homme. <br><br>  Soit dit en passant, il est intéressant de mentionner que les codes ASCII 7 bits sont utilisés.  Les symboles de certains alphabets (allemand, cyrillique, etc.) ne peuvent pas être correctement codés en 7 bits.  Pourquoi 7 bits?  Probablement les ingénieurs avaient décidé que "7 bits suffiront à tous", qui sait ... <br><br><h2>  Conclusion </h2><br>  C'était vraiment intéressant de voir comment fonctionne POCSAG.  C'est l'un des rares protocoles, en usage jusqu'à présent, qui peut littéralement être décodé sur la feuille de papier (et je ne vais certainement pas essayer cela avec TETRA ou GSM). <br><br>  Bien sûr, le protocole POCSAG n'est pas entièrement décrit ici.  La partie la plus importante et la plus intéressante est terminée, d'autres choses ne sont pas si excitantes.  Au moins, il n'y a pas de décodage de codes à barres et il n'y a pas de code de correction d'erreur (BCH Check Bits) - il peut permettre de corriger jusqu'à 2 bits incorrects dans le message.  Mais il n'y avait aucun objectif d'écrire un autre décodeur POCSAG ici, il y en a déjà assez. <br><br>  Pour ceux qui veulent tester le vrai décodage avec rtl-sdr, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application PDW</a> freeware peut être utilisée.  Il ne nécessite pas d'installation, il suffit de transmettre le son du HDSDR au PDW via l'application Virtual Audio Cable. <br><br>  Le résultat ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/-7/g-/ka/-7g-kalvhmaqlv79qju-wmgpglg.jpeg"><br><br>  (veuillez garder à l'esprit que le décodage des messages de service public peut être illégal dans certains pays, et de toute façon respecter la vie privée des destinataires) <br><br>  Si quelqu'un veut obtenir plus d'informations sur ce sujet, les sources du décodeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">multimon-ng</a> sont disponibles, il peut décoder de nombreux protocoles, également POCSAG et FLEX. <br><br>  Merci d'avoir lu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438906/">https://habr.com/ru/post/fr438906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438894/index.html">Pourquoi le développement Web sur Go est plus agréable que sur PHP</a></li>
<li><a href="../fr438896/index.html">Ne pleure pas</a></li>
<li><a href="../fr438898/index.html">Installation inversée et d'extension de Chrome</a></li>
<li><a href="../fr438900/index.html">En route vers les principes physiques de l'évolution biologique. Fin + texte intégral de la traduction</a></li>
<li><a href="../fr438902/index.html">Utilisation de DBREPLICATION lors de la réduction de bases de données sur Microsoft SQL Server</a></li>
<li><a href="../fr438908/index.html">Formation Cisco 200-125 CCNA v3.0. Spécialiste réseau certifié Cisco (CCNA). Jour 1. Bases du réseau</a></li>
<li><a href="../fr438910/index.html">Samba en tant qu'ADDC dans Solaris 11.4</a></li>
<li><a href="../fr438916/index.html">Notes d'un phytochimiste. La pomme de terre. Troisième partie. "Bullet Fugu" ou SOLANIN</a></li>
<li><a href="../fr438920/index.html">Avalonia: première rencontre</a></li>
<li><a href="../fr438922/index.html">Chiffrement du trafic dans Direct Connect, partie 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>