<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèæ üõãÔ∏è üßëüèæ‚Äçü§ù‚Äçüßëüèº Tudo que voc√™ precisa √© de URL üëí üõ¥ üö•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os usu√°rios do VKontakte trocam 10 bilh√µes de mensagens diariamente. Eles enviam fotos, quadrinhos, memes e outros anexos. URLProtocol como criamos um...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tudo que voc√™ precisa √© de URL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/467605/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/l2/us/g6l2usvzzisf7ezfubycuyoty08.jpeg" alt="imagem"></div><br>  Os usu√°rios do VKontakte trocam 10 bilh√µes de mensagens diariamente.  Eles enviam fotos, quadrinhos, memes e outros anexos.  <b><code>URLProtocol</code></b> como criamos um aplicativo iOS para fazer upload de imagens usando o <b><code>URLProtocol</code></b> e, passo a passo, descobriremos como implementar nossos pr√≥prios. <br><a name="habracut"></a><br>  H√° cerca de um ano e meio, o desenvolvimento de uma nova se√ß√£o de mensagens no aplicativo VK para iOS estava em pleno andamento.  Esta √© a primeira se√ß√£o escrita inteiramente em Swift.  Ele est√° localizado em um m√≥dulo separado <code>vkm</code> (VK Messages), que n√£o sabe nada sobre o dispositivo do aplicativo principal.  Pode at√© ser executado em um projeto separado - a funcionalidade b√°sica de ler e enviar mensagens continuar√° funcionando.  No aplicativo principal, os controladores de mensagens s√£o adicionados por meio do Container View Controller correspondente para exibir, por exemplo, uma lista de conversas ou mensagens em uma conversa. <br><br>  Mensagens √© uma das se√ß√µes mais populares do aplicativo m√≥vel VKontakte, por isso √© importante que funcione como um rel√≥gio.  No projeto de <code>messages</code> , lutamos por todas as linhas de c√≥digo.  Sempre gostamos muito de como as mensagens s√£o organizadas de maneira organizada no aplicativo e nos esfor√ßamos para garantir que tudo permane√ßa o mesmo. <br><br>  Ao preencher gradualmente a se√ß√£o com novas fun√ß√µes, abordamos a seguinte tarefa: tivemos que garantir que a foto anexada √† mensagem fosse exibida pela primeira vez em um rascunho e, depois de envi√°-la, na lista geral de mensagens.  Poder√≠amos simplesmente adicionar um m√≥dulo para trabalhar com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>PHImageManager</code></a> , mas condi√ß√µes adicionais tornaram a tarefa mais dif√≠cil. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/7t/hm/0l7thmey5vyyonmpbt5wicd-vjm.gif" alt="imagem"></div><br><br>  Ao escolher uma imagem, o usu√°rio pode process√°-la: aplicar um filtro, girar, cortar etc. No aplicativo VK, essa funcionalidade √© implementada em um componente <code>AssetService</code> separado.  Agora era necess√°rio aprender a trabalhar com ele no projeto da mensagem. <br><br><blockquote>  Bem, a tarefa √© bem simples, vamos fazer.  Esta √© aproximadamente a solu√ß√£o m√©dia, porque h√° muitas varia√ß√µes.  Pegamos o protocolo, colocamos em mensagens e come√ßamos a preench√™-lo com m√©todos.  Adicionamos ao AssetService, adaptamos o protocolo e adicionamos nossa implementa√ß√£o de cache!  para viscosidade.  Em seguida, colocamos a implementa√ß√£o em mensagens, adicionamos a algum servi√ßo ou gerente que ir√° trabalhar com tudo isso e come√ßamos a us√°-lo.  Ao mesmo tempo, um novo desenvolvedor ainda aparece e, enquanto tenta descobrir tudo, ele condena em um sussurro ... (bem, voc√™ entende).  Ao mesmo tempo, o suor aparece na testa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7i/ze/q8/7izeq8h2gkpsgj2qybfro74kobc.jpeg" alt="imagem"></div><br></blockquote><br>  Esta decis√£o <i>n√£o</i> foi <i>do nosso agrado</i> .  Novas entidades parecem que os componentes da mensagem precisam conhecer ao trabalhar com imagens do <code>AssetService</code> .  O desenvolvedor tamb√©m precisa fazer um trabalho extra para descobrir como esse sistema funciona.  Por fim, havia um link impl√≠cito adicional para os componentes do projeto principal, que tentamos evitar para que a se√ß√£o de mensagens continue funcionando como um m√≥dulo independente. <br><br>  Queria resolver o problema para que o projeto n√£o soubesse nada sobre que tipo de imagem foi escolhida, como armazen√°-la, se precisava de carregamento e renderiza√ß√£o especiais.  Al√©m disso, j√° temos a capacidade de baixar imagens convencionais da Internet, mas elas n√£o s√£o baixadas por meio de um servi√ßo adicional, mas simplesmente por <code>URL</code> .  E, de fato, n√£o h√° diferen√ßa entre os dois tipos de imagens.  Apenas alguns s√£o armazenados localmente, enquanto outros s√£o armazenados no servidor. <br><br>  Ent√£o, tivemos uma id√©ia muito simples: e se os recursos locais tamb√©m puderem ser aprendidos a carregar via <code>URL</code> ?  Parece que, com um clique dos dedos de <s>Thanos</s> , isso resolveria todos os nossos problemas: voc√™ n√£o precisa saber nada sobre o <code>AssetService</code> , adicionar novos tipos de dados e aumentar a entropia em v√£o, aprender a carregar um novo tipo de imagem, cuidar do cache de dados.  Parece um plano. <br><br><h2>  Tudo o que precisamos √© de um URL </h2><br>  Consideramos essa ideia e decidimos definir o formato do <code>URL</code> que usaremos para carregar ativos locais: <br><br><pre> <code class="json hljs">asset://?id=<span class="hljs-number"><span class="hljs-number">123</span></span>&amp;width=<span class="hljs-number"><span class="hljs-number">1920</span></span>&amp;height=<span class="hljs-number"><span class="hljs-number">1280</span></span></code> </pre> <br>  Usaremos o valor da propriedade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>localIdentifier</code></a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>localIdentifier</code></a> como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>PHObject</code></a> e passaremos os par√¢metros de <code>width</code> e <code>height</code> para carregar as imagens do tamanho desejado.  Tamb√©m adicionamos mais alguns par√¢metros, como <code>crop</code> , <code>filter</code> , <code>rotate</code> , o que permitir√° que voc√™ trabalhe com as informa√ß√µes da imagem processada. <br><br>  Para lidar com esses <code>URL</code> criaremos um <code>AssetURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Sua tarefa √© carregar a imagem atrav√©s do <code>AssetService</code> e retornar os dados que j√° est√£o prontos para uso. <br><br>  Tudo isso nos permitir√° delegar quase completamente o trabalho do protocolo de <code>URL Loading System</code> e do <code>URL Loading System</code> . <br><br>  Dentro das mensagens, ser√° poss√≠vel operar com os <code>URL</code> mais comuns, apenas em um formato diferente.  Tamb√©m ser√° poss√≠vel reutilizar o mecanismo existente para carregar imagens, √© muito simples serializar no banco de dados e implementar o cache de dados por meio do <code>URLCache</code> padr√£o. <br><br>  Isso deu certo?  Se, lendo este artigo, voc√™ puder anexar uma foto da galeria √† mensagem no aplicativo VKontakte, ent√£o sim :) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/6j/tb/bm6jtb7mkd489czjvwhzpy-dpo0.jpeg" alt="imagem"></div><br>  Para deixar claro como implementar seu <code>URLProtocol</code> , proponho considerar isso com um exemplo. <br><br>  N√≥s nos propusemos a tarefa: implementar um aplicativo simples com uma lista na qual voc√™ precisa exibir uma lista de instant√¢neos de mapa nas coordenadas fornecidas.  Para fazer o download de instant√¢neos, usaremos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MKMapSnapshotter</code></a> padr√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MapKit</code></a> e carregaremos dados atrav√©s do <code>URLProtocol</code> personalizado.  O resultado pode ser algo como isto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="imagem"></div><br>  Primeiro, implementamos o mecanismo para carregar dados por <code>URL</code> .  Para exibir o instant√¢neo do mapa, precisamos conhecer as coordenadas do ponto - latitude e longitude ( <code>latitude</code> , <code>longitude</code> ).  Defina o formato de <code>URL</code> personalizado pelo qual queremos carregar informa√ß√µes: <br><br><pre> <code class="json hljs">map://?latitude=<span class="hljs-number"><span class="hljs-number">59.935634</span></span>&amp;longitude=<span class="hljs-number"><span class="hljs-number">30.325935</span></span></code> </pre> <br>  Agora, implementamos o <code>URLProtocol</code> , que processar√° esses links e gerar√° o resultado desejado.  Vamos criar a classe <code>MapURLProtocol</code> , que herdaremos da classe base <code>URLProtocol</code> .  Apesar do nome, o <code>URLProtocol</code> √© uma classe abstrata, no entanto.  N√£o tenha vergonha, aqui usamos outros conceitos: o <code>URLProtocol</code> representa exatamente o protocolo de <code>URL</code> e n√£o tem rela√ß√£o com os termos de POO.  Ent√£o <code>MapURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Agora redefinimos alguns m√©todos necess√°rios sem os quais o protocolo de <code>URL</code> n√£o funcionar√°: <br><br><h3>  1. <code>canInit(with:)</code> </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canInit</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.url?.scheme == <span class="hljs-string"><span class="hljs-string">"map"</span></span> }</code> </pre> <br>  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>canInit(with:)</code></a> √© necess√°rio para indicar quais tipos de solicita√ß√µes nosso protocolo de <code>URL</code> pode manipular.  Neste exemplo, suponha que o protocolo processe apenas solicita√ß√µes com um esquema de <code>map</code> na <code>URL</code> .  Antes de iniciar qualquer solicita√ß√£o, o <code>URL Loading System</code> percorre todos os protocolos registrados para a sess√£o e chama esse m√©todo.  O primeiro protocolo registrado, que neste m√©todo retornar√° <code>true</code> , ser√° usado para processar a solicita√ß√£o. <br><br><h4>  <code>canonicalRequest(for:)</code> </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canonicalRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request }</code> </pre> <br>  O m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>canonicalRequest(for:)</code></a> tem como objetivo reduzir a solicita√ß√£o para o formato can√¥nico.  A documenta√ß√£o diz que a pr√≥pria implementa√ß√£o do protocolo decide o que √© considerado a defini√ß√£o desse conceito.  Aqui voc√™ pode normalizar o esquema, adicionar cabe√ßalhos √† solicita√ß√£o, se necess√°rio, etc. O √∫nico requisito para esse m√©todo funcionar √© que, para cada solicita√ß√£o recebida, sempre haja o mesmo resultado, inclusive porque esse m√©todo tamb√©m √© usado para procurar respostas em cache solicita√ß√µes no <code>URLCache</code> . <br><br><h4>  3. <code>startLoading()</code> </h4><br>  O m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>startLoading()</code></a> descreve toda a l√≥gica para carregar os dados necess√°rios.  Neste exemplo, √© necess√°rio analisar a <code>URL</code> da solicita√ß√£o e, com base nos valores de seus par√¢metros de <code>latitude</code> e <code>longitude</code> , <code>MKMapSnapshotter</code> para <code>MKMapSnapshotter</code> e carregue a captura instant√¢nea do mapa desejada. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with queryItems: [URLQueryItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshotter = <span class="hljs-type"><span class="hljs-type">MKMapSnapshotter</span></span>(queryItems: queryItems) snapshotter.start( with: <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.global(qos: .background), completionHandler: handle ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">1</span></span>) { complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { fail(with: error) } }</code> </pre> <br>  Ap√≥s receber os dados, √© necess√°rio desligar corretamente o protocolo: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with data: Data)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = client <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-type"><span class="hljs-type">URLResponse</span></span>( url: url, mimeType: <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>, expectedContentLength: data.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>, textEncodingName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didLoad: data) client.urlProtocolDidFinishLoading(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br>  Primeiro, crie um objeto do tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>URLResponse</code></a> .  Este objeto cont√©m metadados importantes para responder a uma solicita√ß√£o.  Em seguida, executamos tr√™s m√©todos importantes para um objeto do tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>URLProtocolClient</code></a> .  A propriedade do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>client</code></a> deste tipo cont√©m cada entidade do protocolo de <code>URL</code> .  Ele atua como um proxy entre o protocolo da <code>URL</code> e a <code>URL Loading System</code> inteira <code>URL Loading System</code> , que, ao chamar esses m√©todos, tira conclus√µes sobre o que precisa ser feito com os dados: armazenar em cache, enviar solicita√ß√µes para o <code>completionHandler</code> , de alguma forma processar o desligamento do protocolo etc. e o n√∫mero de chamadas para esses m√©todos pode variar dependendo da implementa√ß√£o do protocolo.  Por exemplo, podemos baixar dados da rede com lotes e notificar periodicamente o <code>URLProtocolClient</code> sobre isso para mostrar o progresso do carregamento de dados na interface. <br><br>  Se ocorrer um erro na opera√ß√£o do protocolo, tamb√©m ser√° necess√°rio processar e notificar corretamente o <code>URLProtocolClient</code> sobre isso: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with error: Error)</span></span></span></span> { client?.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailWithError: error) }</code> </pre> <br>  √â esse erro que ser√° enviado para a <code>completionHandler</code> solicita√ß√£o, onde pode ser processado e uma bela mensagem exibida ao usu√°rio. <br><br><h4>  4. <code>stopLoading()</code> </h4><br>  O m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>stopLoading()</code></a> √© chamado quando a opera√ß√£o do protocolo foi conclu√≠da por algum motivo.  Isso pode ser uma conclus√£o bem-sucedida, uma conclus√£o de erro ou um cancelamento de solicita√ß√£o.  √â um bom lugar para liberar recursos ocupados ou excluir dados tempor√°rios. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { }</code> </pre> <br>  Isso completa a implementa√ß√£o do protocolo de <code>URL</code> e pode ser usado em qualquer lugar do aplicativo.  Para estar onde aplicar nosso protocolo, adicione mais algumas coisas. <br><br><h4> <code>URLImageView</code> </h4> <br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLImageView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImageView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDataTask?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taskId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url: URL)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(task == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || task?.taskIdentifier != taskId) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) task = session.dataTask(with: request, completionHandler: complete) taskId = task?.taskIdentifier task?.resume() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Data?, response: URLResponse?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.taskId == task?.taskIdentifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(data: data) { didLoadRemote(image: image) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didLoadRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image: UIImage)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.async { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.image = image } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareForReuse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { task?.cancel() taskId = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> image = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Esta √© uma classe simples, descendente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>UIImageView</code></a> , uma implementa√ß√£o semelhante da qual voc√™ provavelmente possui em qualquer aplicativo.  Aqui, simplesmente carregamos a imagem pela <code>URL</code> no m√©todo <code>render(url:)</code> e a gravamos na propriedade da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>image</code></a> .  A conveni√™ncia √© que voc√™ pode fazer upload de absolutamente qualquer imagem, seja pelo <code>URL</code> <code>http</code> / <code>https</code> ou pelo nosso <code>URL</code> personalizado. <br><br>  Para executar solicita√ß√µes para carregar imagens, voc√™ tamb√©m precisar√° de um objeto do tipo <code>URLSession</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>( configuration: config, delegate: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> )</code> </pre> <br>  A configura√ß√£o da sess√£o √© especialmente importante aqui.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>URLSessionConfiguration</code></a> existe uma propriedade importante para n√≥s - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>protocolClasses</code></a> .  Esta √© uma lista dos tipos de protocolos de <code>URL</code> que uma sess√£o com esta configura√ß√£o pode manipular.  Por padr√£o, a sess√£o suporta o processamento de protocolos <code>http</code> / <code>https</code> e, se for necess√°rio suporte personalizado, eles dever√£o ser especificados.  Para o nosso exemplo, especifique <code>MapURLProtocol</code> . <br><br>  Tudo o que falta fazer √© implementar o View Controller, que exibir√° instant√¢neos do mapa.  Seu c√≥digo fonte pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Aqui est√° o resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/gf/c8/edgfc8crekglljfq33hfggic520.gif" alt="imagem"></div><br><h2>  E o cache? </h2><br>  Tudo parece funcionar bem - exceto por um ponto importante: quando rolamos a lista para a frente e para tr√°s, manchas brancas aparecem na tela.  Parece que os instant√¢neos n√£o s√£o armazenados em cache de forma alguma e, para cada chamada ao m√©todo <code>render(url:)</code> , <code>MKMapSnapshotter</code> dados por meio do <code>MKMapSnapshotter</code> .  Isso leva tempo e, portanto, essas lacunas no carregamento.  Vale a pena implementar um mecanismo de armazenamento em cache de dados para que os snapshots j√° criados n√£o sejam baixados novamente.  Aqui usamos o poder do <code>URL Loading System</code> , que j√° possui um mecanismo de cache para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>URLCache</code></a> fornecido para isso. <br><br>  Considere esse processo com mais detalhes e divida o trabalho com o cache em dois est√°gios importantes: leitura e escrita. <br><br><h3>  Leitura </h3><br>  Para ler corretamente os dados em cache, o <code>URL Loading System</code> precisa de ajuda para obter respostas para v√°rias perguntas importantes: <br><br>  <b>1. Qual URLCache usar?</b> <br><br>  Obviamente, o <code>URLCache.shared</code> j√° foi conclu√≠do, mas a <code>URL Loading System</code> nem sempre pode us√°-lo - afinal, o desenvolvedor pode querer criar e usar sua pr√≥pria entidade <code>URLCache</code> .  Para responder a essa pergunta, a <code>URLSessionConfiguration</code> sess√£o <code>URLSessionConfiguration</code> possui uma propriedade <code>urlCache</code> .  √â usado para ler e gravar respostas a solicita√ß√µes.  N√≥s <code>URLCache</code> algum <code>URLCache</code> para esses prop√≥sitos em nossa configura√ß√£o existente. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.urlCache = <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.current <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }()</code> </pre> <br>  <b>2. Preciso usar dados em cache ou baixar novamente?</b> <br><br>  A resposta a esta pergunta depende da solicita√ß√£o <code>URLRequest</code> que estamos prestes a executar.  Ao criar uma solicita√ß√£o, temos a oportunidade de especificar uma pol√≠tica de cache no argumento <code>cachePolicy</code> , al√©m da <code>URL</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>( url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: <span class="hljs-number"><span class="hljs-number">30</span></span> )</code> </pre> <br>  O valor padr√£o √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>.useProtocolCachePolicy</code></a> , que tamb√©m est√° escrito na documenta√ß√£o.  Isso significa que, nesta vers√£o, a tarefa de encontrar uma resposta em cache para uma solicita√ß√£o e determinar sua relev√¢ncia reside inteiramente na implementa√ß√£o do protocolo de <code>URL</code> .  Mas existe uma maneira mais f√°cil.  Se voc√™ definir o valor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>.returnCacheDataElseLoad</code></a> , ao criar a pr√≥xima entidade <code>URLProtocol</code> <code>URL Loading System</code> <code>URLProtocol</code> parte do trabalho: ele solicitar√° ao <code>urlCache</code> resposta em cache √† solicita√ß√£o atual usando o m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>cachedResponse(for:)</code></a> .  Se houver dados em cache, um objeto do tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>CachedURLResponse</code></a> ser√° transferido imediatamente quando o <code>URLProtocol</code> inicializado e armazenado na propriedade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>cachedResponse</code></a> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>, cachedResponse: <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span>, client: <span class="hljs-type"><span class="hljs-type">URLProtocolClient?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: request, cachedResponse: cachedResponse, client: client ) }</code> </pre> <br>  <code>CachedURLResponse</code> √© uma classe simples que cont√©m dados ( <code>Data</code> ) e meta-informa√ß√µes para eles ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>URLResponse</code></a> ). <br><br>  S√≥ podemos alterar um <code>startLoading</code> o m√©todo <code>startLoading</code> e verificar o valor dessa propriedade dentro dele - e finalizar imediatamente o protocolo com esses dados: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse.data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } }</code> </pre> <br><h3>  Record </h3><br>  Para encontrar dados no cache, voc√™ precisa coloc√°-lo l√°.  O <code>URL Loading System</code> tamb√©m cuida deste trabalho.  Tudo o que √© necess√°rio para n√≥s √© dizer a ela que queremos armazenar em cache os dados quando o protocolo for <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>cacheStoragePolicy</code></a> usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>cacheStoragePolicy</code></a> pol√≠tica de cache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>cacheStoragePolicy</code></a> .  Esta √© uma enumera√ß√£o simples com os seguintes valores: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StoragePolicy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowedInMemoryOnly <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> notAllowed }</code> </pre> <br>  Eles significam que o armazenamento em cache √© permitido na mem√≥ria e no disco, apenas na mem√≥ria ou √© proibido.  Em nosso exemplo, indicamos que o cache √© permitido na mem√≥ria e no disco, porque por que n√£o? <br><br><pre> <code class="swift hljs">client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed)</code> </pre> <br>  Portanto, seguindo algumas etapas simples, apoiamos a capacidade de armazenar em cache instant√¢neos de mapa.  E agora o aplicativo funciona assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="imagem"></div><br>  Como voc√™ pode ver, n√£o h√° mais pontos em branco - os cart√µes s√£o carregados uma vez e simplesmente reutilizados no cache. <br><br><h2>  Nem sempre √© f√°cil </h2><br>  Ao implementar o protocolo de <code>URL</code> , encontramos uma s√©rie de falhas. <br><br>  O primeiro foi relacionado √† implementa√ß√£o interna da intera√ß√£o do <code>URL Loading System</code> com o <code>URLCache</code> ao armazenar em cache as respostas √†s solicita√ß√µes.  A documenta√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">declara</a> : apesar da seguran√ßa do <code>URLCache</code> do <code>URLCache</code> , a opera√ß√£o dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>cachedResponse(for:)</code></a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>storeCachedResponse(_:for:)</code></a> para leitura / grava√ß√£o de respostas a solicita√ß√µes pode levar a uma corrida de estados, portanto, esse ponto deve ser levado em considera√ß√£o nas subclasses do <code>URLCache</code> .  Esper√°vamos que, usando o <code>URLCache.shared</code> esse problema fosse resolvido, mas acabou errado.  Para corrigir isso, usamos um cache <code>ImageURLCache</code> separado, um descendente do <code>URLCache</code> , no qual executamos os m√©todos especificados de forma s√≠ncrona em uma fila separada.  Como um b√¥nus agrad√°vel, podemos configurar separadamente a capacidade do cache na mem√≥ria e no disco separadamente de outras entidades do <code>URLCache</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accessQueue = <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>( label: <span class="hljs-string"><span class="hljs-string">"image-urlcache-access"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.cachedResponse(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storeCachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> response: CachedURLResponse, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.storeCachedResponse(response, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } }</code> </pre> <br>  Outro problema foi reproduzido apenas em dispositivos com iOS 9. Os m√©todos para iniciar e finalizar o carregamento do protocolo de <code>URL</code> podem ser executados em diferentes segmentos, o que pode levar a falhas raras, por√©m desagrad√°veis.  Para resolver o problema, salvamos o encadeamento atual no m√©todo <code>startLoading</code> e, em seguida, executamos o c√≥digo de conclus√£o do download diretamente nesse encadeamento. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread: <span class="hljs-type"><span class="hljs-type">Thread!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } thread = <span class="hljs-type"><span class="hljs-type">Thread</span></span>.current <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { load(request: request, url: url, queryItems: queryItems) } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { thread.execute { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">0.7</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fail(with: error) } } }</code> </pre> <br><h2>  Quando um protocolo de URL pode ser √∫til? </h2><br>  Como resultado, quase todos os usu√°rios de nosso aplicativo iOS, de uma maneira ou de outra, encontram elementos que funcionam atrav√©s do protocolo de <code>URL</code> .  Al√©m de baixar m√≠dia da galeria, v√°rias implementa√ß√µes de protocolos de <code>URL</code> nos ajudam a exibir mapas e pesquisas, al√©m de mostrar avatares de bate-papo compostos por fotografias de seus participantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/jz/sl/5vjzsliedpi6l9qt6qhnaloi1l8.jpeg" alt="imagem"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/g4/rz/p0g4rzbdjqqbx3oc-ochol6ilwy.jpeg" alt="imagem"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/1e/mb/n41embtawargx2zofdmevlyq_nk.jpeg" alt="imagem"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j4/dn/gj/j4dngjkluh5gyxb3od9vwkse9zu.jpeg" alt="imagem"></div><br>  Como qualquer solu√ß√£o, o <code>URLProtocol</code> tem suas vantagens e desvantagens. <br><br><h3>  Desvantagens do <code>URLProtocol</code> </h3><br><ul><li>  <b>Falta de digita√ß√£o estrita</b> - ao criar uma <code>URL</code> par√¢metros <code>URL</code> esquema e do link s√£o especificados manualmente por meio de strings.  Se voc√™ digitar um erro de digita√ß√£o, o par√¢metro desejado n√£o ser√° processado.  Isso pode complicar a depura√ß√£o do aplicativo e a busca de erros em sua opera√ß√£o.  No aplicativo VKontakte, usamos <code>URLBuilder</code> especiais que formam o <code>URL</code> final com base nos par√¢metros passados.  Essa decis√£o n√£o √© muito bonita e contradiz um pouco o objetivo de n√£o produzir entidades adicionais, mas ainda n√£o h√° uma id√©ia melhor.  Mas sabemos que, se voc√™ precisar criar algum tipo de <code>URL</code> personalizado, com certeza haver√° um <code>URLBuilder</code> especial que o ajudar√° a n√£o cometer erros. </li><li>  <b>Falhas n√£o √≥bvias</b> - Eu j√° descrevi alguns cen√°rios que podem causar <code>URLProtocol</code> um aplicativo usando o <code>URLProtocol</code> .  Talvez haja outros.   ,  ,      ,    stack trace'    . </li></ul><br><h3>  URLProtocol </h3><br><ul><li> <b>  </b> ‚Äî  ,      ,      ,   :     ,   .       <code>URL</code> ‚Äî     . </li><li> <b> </b> ‚Äî    <code>URL</code> -        .         . </li><li> <b>  </b> ‚Äî       ,      ,   <code>URL</code> -.       <code>URL</code> , <code>URLSession</code> , <code>URLSessionDataTask</code> . </li><li> <b> </b> ‚Äî    <code>URL</code> -   <code>URL</code> -,             <code>URL Loading System</code> . </li><li> <b>*  API</b> ‚Äî      .     ,        API,   -  ,   <code>URL</code> -.       ,       API         ,  .         <code>URL</code> -      <code>http</code> / <code>https</code> . </li></ul><br> <code>URL</code> - ‚Äî         .      .  -   ,   -    ,   ,    , ‚Äî  ,      .  ,     , ‚Äî  <code>URL</code> . <br><br> <b>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  GitHub</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467605/">https://habr.com/ru/post/pt467605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467591/index.html">A nova prova resolve a aproxima√ß√£o de n√∫meros como pi</a></li>
<li><a href="../pt467593/index.html">(N√£o relevante, reparado) Nota. Como a Tele2 compartilha o acesso √† conta pessoal de novos assinantes</a></li>
<li><a href="../pt467595/index.html">Viajando pelo data center Selectel. Dinossauro em chamas, VMware, C2F5H e o lobisomem invis√≠vel</a></li>
<li><a href="../pt467597/index.html">Personalizando as diretrizes de produtos de big data com o Vowpal Wabbit</a></li>
<li><a href="../pt467599/index.html">Renderiza√ß√£o de gr√°ficos 3D com OpenGL</a></li>
<li><a href="../pt467607/index.html">Confiss√£o do √≥dio dos estivadores</a></li>
<li><a href="../pt467609/index.html">Criando um aplicativo m√≥vel no React Native</a></li>
<li><a href="../pt467611/index.html">Algoritmos de detec√ß√£o de contorno de imagem</a></li>
<li><a href="../pt467615/index.html">Como criar wrapper Python e n√£o enlouquecer</a></li>
<li><a href="../pt467617/index.html">Kaspresso: a estrutura de autoteste que voc√™ estava esperando</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>