<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÑ ‚úã üéÖ Algoritmos de detecci√≥n de esquema de imagen üßíüèª ‚ôæ üåç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El art√≠culo presenta los cuatro algoritmos de detecci√≥n de bucle m√°s comunes. 

 Los dos primeros, a saber, el algoritmo para trazar cuadrados y traza...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritmos de detecci√≥n de esquema de imagen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467611/">  El art√≠culo presenta los cuatro algoritmos de detecci√≥n de bucle m√°s comunes. <br><br>  Los dos primeros, a saber, el algoritmo para trazar cuadrados y trazar los alrededores de Moore, son f√°ciles de implementar y, por lo tanto, a menudo se usan para determinar el contorno de un patr√≥n dado.  Desafortunadamente, ambos algoritmos tienen varias debilidades, lo que hace que sea <b>imposible</b> detectar el contorno de una gran clase de patrones debido a su tipo especial de adyacencia. <br><br>  Estos algoritmos ignorar√°n todos los <b><i>"agujeros"</i></b> en el patr√≥n.  Por ejemplo, si tenemos un patr√≥n similar al que se muestra en la <b><i>Figura 1</i></b> , entonces el circuito detectado por los algoritmos ser√° similar al que se muestra en la <b><i>Figura 2</i></b> (el contorno se indica mediante p√≠xeles azules).  En algunas √°reas de aplicaci√≥n, esto es bastante aceptable, pero en otras √°reas, por ejemplo, en el reconocimiento de caracteres, se requiere la detecci√≥n de las partes internas de un patr√≥n para encontrar todos los espacios que distinguen un car√°cter espec√≠fico.  (La <b><i>Figura 3</i></b> muestra el esquema "completo" del patr√≥n). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/d3b/f5b/0e7d3bf5bc9c451588718fe5d909a2fb.gif" alt="imagen"></div><br><br>  Por lo tanto, para obtener un contorno completo, primero es necesario usar el algoritmo de <b><i>"b√∫squeda de agujeros"</i></b> que determina los agujeros en un patr√≥n dado, y luego aplicar el algoritmo de detecci√≥n de contorno a cada agujero. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/22c/32f/cb722c32fcc45aeea8d8b097a0d01f84.gif" alt="imagen"></div><a name="habracut"></a><br><h2>  ¬øQu√© es la conectividad? </h2><br>  En im√°genes digitales con valores binarios, un p√≠xel puede tener uno de los siguientes valores: 1: cuando forma parte del patr√≥n o 0: cuando forma parte del fondo, es decir,  sin gradaci√≥n de gris.  (Asumiremos que los p√≠xeles con un valor de 1 son negros y con un valor de 0 son blancos). <br><br>  Para identificar <b><i>objetos</i></b> en un patr√≥n digital, necesitamos encontrar grupos de p√≠xeles negros que est√©n "conectados" entre s√≠.  En otras palabras, los <b><i>objetos</i></b> en un patr√≥n digital dado son los <b><i>componentes conectados de</i></b> este patr√≥n. <br><br>  En el caso general, un <b><i>componente conectado</i></b> es un conjunto de p√≠xeles negros <b>P</b> , de modo que para cada par de p√≠xeles <b>p <sub>i</sub></b> y <b>p <sub>j</sub></b> en <b>P</b> hay una secuencia de p√≠xeles <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tal que: <br><br>  a) todos los p√≠xeles en la secuencia est√°n en el conjunto <b>P</b> , es decir  son negros y <br><br>  b) cada 2 p√≠xeles <b><i>en la secuencia</i></b> uno <b><i>al lado del otro</i></b> son "vecinos". <br><br>  Surge una pregunta importante: ¬ø <b><i>cu√°ndo podemos decir que 2 p√≠xeles son "vecinos"?</i></b>  Dado que usamos p√≠xeles cuadrados, la respuesta a la pregunta anterior no es trivial por la siguiente raz√≥n: en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teselaci√≥n cuadrada, los</a> p√≠xeles tienen un borde com√∫n o un v√©rtice, o no tienen nada en com√∫n.  Cada p√≠xel tiene 8 p√≠xeles en com√∫n con √©l;  tales p√≠xeles forman el "vecindario de Moore" de ese p√≠xel.  ¬øDeber√≠amos considerar que los p√≠xeles "vecinos" tienen un solo v√©rtice com√∫n?  ¬øO para ser considerados "vecinos", dos p√≠xeles deben tener un borde com√∫n? <br><br>  Entonces, hay dos tipos de conectividad, a saber: 4-conectividad y 8-conectividad. <br><br><h4>  4 conexiones </h4><br>  ¬øCu√°ndo podemos decir que un conjunto dado de p√≠xeles negros est√° <b><i>4-conectado?</i></b>  Primero, debe definir el concepto de un <b><i>vecino de 4</i></b> (tambi√©n llamado <b><i>vecino directo</i></b> ): <br><br>  <b>Definici√≥n de 4 vecinos</b> : un p√≠xel <b>Q</b> es un <b><i>4 vecino de un</i></b> p√≠xel <b>P</b> dado si <b>Q</b> y <b>P</b> tienen un borde com√∫n.  Los 4 vecinos del p√≠xel <b>P</b> (designado como <b>P2, P4, P6</b> y <b>P8</b> ) se muestran en la <b><i>Figura 2 a</i></b> continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/592/5ef/02b5925eff29a4b14330e63c43714837.gif" height="202" width="177"></div><br>  <b>Definici√≥n de un componente conectado a 4</b> : el conjunto de p√≠xeles negros <b>P</b> es un <b><i>componente conectado a 4</i></b> si para cada par de p√≠xeles <b>p <sub>i</sub></b> y <b>p <sub>j</sub></b> en <b>P</b> hay una secuencia de p√≠xeles <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tal que: <br><br>  a) todos los p√≠xeles en la secuencia est√°n en el conjunto <b>P</b> , es decir  son negros y <br><br>  b) cada dos p√≠xeles <b><i>adyacentes en la secuencia</i></b> son <b><i>4 vecinos</i></b> <br><br><h4>  Ejemplos de patrones 4 conectados </h4><br>  Los siguientes diagramas muestran ejemplos de patrones conectados a 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/3c8/b76/b713c8b761d034fc04d486aed3029149.gif" height="216" width="576"></div><br><br><h4>  8 conexiones </h4><br>  ¬øCu√°ndo puedo decir que un conjunto dado de p√≠xeles negros est√° <b><i>conectado a 8</i></b> ?  Primero, necesitamos definir el concepto de un <b><i>vecino de 8</i></b> (tambi√©n llamado <b><i>vecino indirecto</i></b> ): <br><br>  <b>Definici√≥n de 8 vecinos</b> : un p√≠xel <b>Q</b> es un <b><i>8 vecino</i></b> (o simplemente un <b><i>vecino</i></b> ) de un p√≠xel <b>P</b> dado si <b>Q</b> y <b>P</b> tienen un borde o v√©rtice com√∫n.  Los 8 vecinos de un p√≠xel <b>P</b> conforman el vecindario de Moore de este p√≠xel. <br><br>  <b>Definici√≥n de un componente conectado a 8</b> : el conjunto de p√≠xeles negros <b>P</b> es un <b><i>componente conectado a 8</i></b> (o simplemente un <b><i>componente conectado</i></b> ) si para cada par de p√≠xeles <b>p <sub>i</sub></b> y <b>p <sub>j</sub></b> en <b>P</b> hay una secuencia de p√≠xeles <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> tal que : <br><br>  a) todos los p√≠xeles en la secuencia est√°n en el conjunto <b>P</b> , es decir  son negros y <br><br>  b) cada dos p√≠xeles <b><i>adyacentes en esta secuencia</i></b> son <b><i>8 vecinos</i></b> <br><br>  <b>Nota</b> : todos los patrones conectados a 4 est√°n conectados a 8, es decir  Los patrones de 4 conectados son un subconjunto de los muchos patrones de 8 conectados.  Por otro lado, un patr√≥n conectado a 8 puede no estar conectado a 4. <br><br><h4>  Ejemplo de patr√≥n de 8 enlaces </h4><br>  El siguiente diagrama muestra un patr√≥n que est√° conectado a 8 pero no a 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/3d4/d90/7f03d4d904e9a4ebd1b7765ee7f4358f.gif" height="180" width="180"></div><br><br><h4>  Un ejemplo de un patr√≥n no conectado a 8: </h4><br>  El siguiente diagrama muestra un ejemplo de un patr√≥n que no est√° conectado a 8, es decir  compuesto de m√°s de un componente conectado (el diagrama muestra tres componentes conectados): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/768/7bb/f90/7687bbf9070e4e581e4ebfde132a1164.gif" height="180" width="180"></div><br><br><h2>  Algoritmo de traza cuadrada </h2><br><h4>  Idea </h4><br>  La idea detr√°s del algoritmo de trazado cuadrado es muy simple;  Esto puede atribuirse al hecho de que el algoritmo fue uno de los primeros intentos de detectar el contorno de un patr√≥n binario. <br><br>  Para entender c√≥mo funciona, necesitas un poco de imaginaci√≥n ... <br><br>  Supongamos que tenemos un patr√≥n digital, por ejemplo, un grupo de p√≠xeles negros sobre un fondo de p√≠xeles blancos, es decir,  en la cuadr√≠cula;  encontrar el p√≠xel negro y declararlo como nuestro p√≠xel " <b>inicial</b> ".  (Encontrar el p√≠xel " <b>inicial</b> " se puede implementar de muchas maneras diferentes; comenzaremos desde la esquina inferior izquierda de la cuadr√≠cula, escanearemos cada columna de p√≠xeles de abajo hacia arriba, desde la columna m√°s a la izquierda hasta la derecha, hasta encontrar un p√≠xel negro. Lo declararemos " <b>inicial</b> " ".) <br><br>  Ahora imagine que es una mariquita parada en el p√≠xel <b>inicial</b> , como se muestra en la <b><i>Figura 1 a</i></b> continuaci√≥n.  Para obtener el esquema de un patr√≥n, debe hacer lo siguiente: <br><br> <code> ,      ,  ,  <br> <br>  ,      ,  , <br> <br>      <b></b> .</code> <br> <br>  Los p√≠xeles negros que rodeaste ser√°n el contorno del patr√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/0c2/69e/baa0c269e22368fa231d774f6bf3b062.gif" height="252" width="216"></div><br>  Un aspecto importante del algoritmo de traza cuadrada es el "sentido de direcci√≥n".  Los giros hacia la izquierda y hacia la derecha se realizan en relaci√≥n con la ubicaci√≥n actual, que depende de c√≥mo lleg√≥ al p√≠xel actual.  Por lo tanto, para realizar los movimientos correctos, debe seguir su direcci√≥n. <br><br><h4>  Algoritmo </h4><br>  La siguiente es una descripci√≥n formal del algoritmo de rastreo cuadrado: <br><br>  Entrada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teselaci√≥n</a> cuadrada, <b>T</b> , que contiene el componente conectado <b>P de</b> las c√©lulas negras. <br><br>  Salida: fila <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> )</b> de p√≠xeles de borde, es decir  contorno <br><br>  Inicio <br><br><ul><li>  Defina <b>B</b> como un conjunto vac√≠o. </li><li>  Escanee las celdas <b>T</b> de abajo hacia arriba y de izquierda a derecha hasta encontrar un p√≠xel negro <b>s</b> de <b>P.</b> </li><li>  Inserte <b>s</b> en <b>B.</b> </li><li>  Convierta el p√≠xel actual <b>p en el</b> p√≠xel inicial <b>s</b> . </li><li>  Gire a la izquierda, es decir  ir al p√≠xel vecino a la izquierda de <b>p</b> . </li><li>  Actualizaci√≥n <b>p</b> , es decir  se convierte en el p√≠xel actual. </li><li>  Mientras <b>p</b> no <b>es</b> igual a <b>s</b> , ejecute <br><br>  Si el p√≠xel actual <b>p</b> es negro <br><ul><li>  inserte <b>p</b> en <b>B</b> y gire a la izquierda (vaya al p√≠xel vecino a la izquierda de <b>p</b> ). </li><li>  Actualizaci√≥n <b>p</b> , es decir  se convierte en el p√≠xel actual. </li></ul><br>  de lo contrario <br><ul><li>  gire a la derecha (vaya al siguiente p√≠xel a la derecha de <b>p</b> ). </li><li>  Actualizaci√≥n <b>p</b> , es decir  se convierte en el p√≠xel actual. </li></ul><br>  Fin del ciclo "Bye" </li></ul><br>  El final <br><br>  <b>Nota: los</b> conceptos de "izquierda" y "derecha" deben considerarse no con respecto a la p√°gina o al lector, sino con respecto a la direcci√≥n de entrada en el p√≠xel "actual" durante el escaneo. <br><br><h4>  Demostraci√≥n </h4><br>  La siguiente es una demostraci√≥n animada de c√≥mo el algoritmo de rastreo cuadrado detecta el contorno de un patr√≥n.  No olvides que la mariquita se mueve en p√≠xeles;  observe c√≥mo cambia su direcci√≥n al girar a la izquierda y a la derecha.  Los giros hacia la izquierda y hacia la derecha se realizan en relaci√≥n con la direcci√≥n actual en un p√≠xel, es decir  Orientaci√≥n de mariquita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/148/f77/39c148f774519015dc130273d8383dd3.gif" height="360" width="288"></div><br><h4>  An√°lisis </h4><br>  Resulta que las capacidades del algoritmo de rastreo cuadrado son muy limitadas.  No puede detectar los contornos de una gran familia de patrones que a menudo surgen en aplicaciones del mundo real. <br><br>  Esto se debe principalmente al hecho de que las rotaciones izquierda y derecha no tienen en cuenta los p√≠xeles ubicados "a lo largo de <br>  diagonales "del p√≠xel actual. <br><br>  Veamos los diferentes patrones con diferente conectividad y veamos por qu√© falla el algoritmo de rastreo cuadrado.  Adem√°s, estudiaremos formas de mejorar las capacidades del algoritmo y hacerlo funcionar incluso con patrones que tienen un tipo especial de conectividad. <br><br><h4>  Criterio de parada </h4><br>  Una de las debilidades del algoritmo es la elecci√≥n del criterio de detenci√≥n.  En otras palabras, ¬øcu√°ndo deja de ejecutarse un algoritmo? <br><br>  En la descripci√≥n original del algoritmo de rastreo cuadrado, la condici√≥n de finalizaci√≥n es alcanzar el p√≠xel <b>inicial por</b> segunda vez.  Resulta que si el algoritmo depende de tal criterio, entonces no podr√° detectar los contornos de una gran familia de patrones. <br><br>  La siguiente es una demostraci√≥n animada que explica c√≥mo el algoritmo no puede detectar el contorno exacto del patr√≥n debido a la selecci√≥n de un criterio de detenci√≥n incorrecto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ef/783/09a/0ef78309a17e9e72b09a28890abb6791.gif" height="252" width="216"></div><br>  Como puede ver, mejorar el criterio de detenci√≥n puede ser un buen comienzo para mejorar el rendimiento general del algoritmo.  Hay dos alternativas efectivas para un criterio de apagado existente: <br><br>  a) Pare solo visitando el p√≠xel <b>inicial</b> <b><i>n</i></b> veces, donde n es al menos 2, O <br><br>  b) Det√©ngase despu√©s de golpear el p√≠xel de <b>inicio por</b> segunda vez, tal como lo golpeamos inicialmente. <br><br>  Este criterio fue propuesto por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jacob Eliosoff</a> , por lo que lo llamaremos el <b><i>criterio para detener a Jacob</i></b> . <br><br>  Cambiar el criterio de detenci√≥n en el caso general mejora la efectividad del algoritmo de rastreo cuadrado, pero no supera otras debilidades que tiene en el caso de patrones con tipos especiales de conectividad. <br><br>  El algoritmo de rastreo cuadrado no puede detectar el contorno de una familia de patrones con una conectividad de 8 que NO tiene una conectividad de 4. <br><br>  La siguiente es una demostraci√≥n animada de c√≥mo el algoritmo de rastreo cuadrado (con el criterio de detenci√≥n de Jacob) no puede detectar el esquema correcto de un patr√≥n con conectividad 8 sin conectividad 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/c26/238/9bbc26238da41c3fb5c5eac1e44fe507.gif" height="288" width="216"></div><br><h2>  ¬øEs este algoritmo completamente in√∫til? </h2><br>  Si lee el an√°lisis anterior, probablemente piense que el algoritmo de rastreo cuadrado no puede detectar los contornos de la mayor√≠a de los patrones.  Pero resulta que  que existe una familia especial de patrones en los que el algoritmo de rastreo cuadrado detecta completamente la ruta. <br><br>  Sea <b>P</b> el conjunto de p√≠xeles negros con conectividad 4 en la cuadr√≠cula.  Deje que los p√≠xeles blancos de la cuadr√≠cula, es decir  los p√≠xeles de fondo <b>W</b> tambi√©n tienen una conectividad de 4. Resulta que bajo tales condiciones del patr√≥n y su fondo, se puede demostrar que el algoritmo de traza cuadrada (con el criterio de detenci√≥n de Jacob) siempre se ocupar√° con √©xito de la determinaci√≥n del contorno. <br><br>  A continuaci√≥n se muestra la prueba de que, en el caso de que tanto el patr√≥n como los p√≠xeles de fondo est√©n conectados, el algoritmo de traza cuadrada determinar√° correctamente el contorno cuando se utilice el criterio de detenci√≥n de Jacob. <br><br>  Prueba <br>  <b>Dado</b> : el patr√≥n <b>P es</b> tal que todos los p√≠xeles del patr√≥n (es decir, negro) y los p√≠xeles de fondo (es decir, blanco) W tienen una conectividad de 4. <br><br>  <b>Primera observaci√≥n</b> <br><br>  Dado que el conjunto de p√≠xeles blancos W tiene una conectividad de 4, esto significa que no puede haber " <b><i>agujeros</i></b> " en el patr√≥n (en t√©rminos informales, " <b><i>agujeros</i></b> " nos referimos a grupos de p√≠xeles blancos completamente rodeados por p√≠xeles negros del patr√≥n). <br><br>  La presencia de cualquier " <b><i>agujero</i></b> " en el patr√≥n conducir√° a la separaci√≥n del grupo de p√≠xeles blancos de los p√≠xeles blancos restantes;  sin embargo, muchos p√≠xeles blancos pierden conectividad 4. <br><br>  <i>La Figura 2</i> y la <b><i>Figura 3 a</i></b> continuaci√≥n muestran dos tipos de " <b><i>agujeros</i></b> " que pueden ocurrir en un patr√≥n con conectividad 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/a4e/9b1/8d9a4e9b18b2753038c0abbd11ad7dcd.gif" height="180" width="432"></div><br><br>  <b>Segunda observaci√≥n</b> <br><br>  Cualquiera de los dos p√≠xeles negros de un patr√≥n DEBE tener un lado com√∫n. <br><br>  Supongamos que dos p√≠xeles negros tienen solo un v√©rtice com√∫n.  Luego, para satisfacer la propiedad de 4-conectividad del patr√≥n, debe haber una ruta que conecte estos dos p√≠xeles para que cada dos p√≠xeles adyacentes en esta ruta tengan una conectividad de 4. Pero esto nos dar√° un patr√≥n similar a la <b><i>Figura 3</i></b> .  En otras palabras, esto dar√° como resultado una separaci√≥n de p√≠xeles blancos.  <b><i>La Figura 4 a</i></b> continuaci√≥n muestra un patr√≥n t√≠pico que satisface la suposici√≥n de que los p√≠xeles en el patr√≥n y el fondo est√°n conectados a 4, es decir  no tienen " <b><i>agujeros</i></b> ", y cada dos p√≠xeles negros tienen un lado com√∫n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a68/2e0/7e0/a682e07e0732655da35269badcfe6b69.gif" height="216" width="216"></div><br>  Es √∫til representar tales patrones de la siguiente manera: <br><br>  Primero consideramos los p√≠xeles del l√≠mite, es decir  esquema del patr√≥n.  Luego, si consideramos que cada p√≠xel l√≠mite tiene 4 bordes de unidad de longitud, veremos que algunos de estos bordes son comunes con los p√≠xeles blancos vecinos.  Llamaremos a estos bordes bordes <b><i>l√≠mite</i></b> . <br><br>  Tales bordes l√≠mite pueden considerarse como bordes de un pol√≠gono.  En la <b><i>foto</i></b> <b><i><br></i></b>  <b><i>5 a</i></b> continuaci√≥n, esta idea se demuestra con el ejemplo de un pol√≠gono correspondiente al patr√≥n de la <b><i>Figura 4</i></b> anterior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/ebe/5ea/220ebe5ea9383e00a2709117b237248b.gif" height="216" width="216"></div><br>  Si consideramos todas las "configuraciones" posibles de p√≠xeles l√≠mite que pueden ocurrir en dichos patrones, veremos que hay dos casos simples, que se muestran en la <b><i>Figura 6</i></b> y la <b><i>Figura 7 a</i></b> continuaci√≥n. <br><br>  Los p√≠xeles de l√≠mite pueden ser m√∫ltiplos de estos casos u otros arreglos, es decir  los giros y vueltas de estos dos casos.  Las costillas l√≠mite est√°n marcadas en azul como <b>E1, E2, E3</b> y <b>E4</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/99b/6fa/bf599b6fafebb09a80c32eceb0520270.gif" height="216" width="576"></div><br>  <b>Tercera observaci√≥n</b> <br><br>  En el caso de los dos casos anteriores, sin importar el p√≠xel inicial que elijamos, y en cualquier direcci√≥n en la que <b>caiga</b> , el algoritmo de traza cuadrada nunca <b>"retroceder√°" (retroceso)</b> , nunca <b>"atravesar√°" el</b> <i>borde</i> <b>del</b> <i>l√≠mite</i> dos veces ( solo si no traza el borde por segunda vez) y nunca pierde el <b><i>borde del l√≠mite</i></b> .  ¬°Compru√©balo! <br><br>  Aqu√≠ hay que aclarar dos conceptos: <br><br>  a) el algoritmo <b>"retrocede"</b> , cuando antes de trazar todo el borde vuelve a visitar un p√≠xel ya visitado, y <br><br>  b) para cada <b><i>costilla l√≠mite,</i></b> hay dos formas de <b>"pasar a trav√©s de ella"</b> , a saber, "hacia adentro" y "hacia afuera" (donde "hacia adentro" significa el movimiento hacia adentro del pol√≠gono correspondiente, y "hacia afuera" - hacia afuera del pol√≠gono). <br><br>  Adem√°s, cuando el algoritmo pasa "hacia adentro" a trav√©s de uno de los bordes del l√≠mite, pasar√° "hacia afuera" a trav√©s del siguiente borde del l√≠mite, es decir  el algoritmo de traza cuadrada no deber√≠a poder pasar a trav√©s de dos bordes consecutivos de la misma manera. <br><br>  <b>√öltima observaci√≥n</b> <br><br>  Cada patr√≥n tiene un <b>n√∫mero par de</b> <b>bordes l√≠mite</b> . <br><br>  Si observa el pol√≠gono de la <b><i>Figura 5</i></b> , puede ver que: <br><br>  Si queremos comenzar desde el v√©rtice <b>S</b> marcado en el diagrama y seguir los bordes l√≠mite hasta que alcancemos <b>S</b> nuevamente, entonces notamos que en el proceso cruzamos un n√∫mero par de bordes l√≠mite.  Podemos considerar cada borde l√≠mite como un "paso" en una direcci√≥n separada.  Luego, para cada "paso" a la derecha debe haber un "paso" correspondiente a la izquierda, si queremos volver a la posici√≥n inicial.  Lo mismo se aplica a los "pasos" verticales.  Por lo tanto, los "pasos" deben tener pares correspondientes, y esto explica por qu√© cada uno de estos patrones tendr√° un n√∫mero par de bordes de l√≠mite. <br><br>  Por lo tanto, cuando el algoritmo para trazar cuadrados ingresa por el <b>borde l√≠mite inicial</b> (del p√≠xel inicial) por segunda vez, lo har√° en <b>la misma</b> direcci√≥n que la primera vez. <br><br>  La raz√≥n de esto es que, dado que hay dos formas de atravesar el borde l√≠mite, y el algoritmo se mueve alternativamente hacia adentro y hacia afuera, y hay un n√∫mero par de bordes l√≠mite, el algoritmo pasar√° por el borde l√≠mite inicial por segunda vez de la misma manera que en el primero <br><br><h4>  Conclusi√≥n </h4><br>  En el caso de un patr√≥n y un fondo 4 conectados, el algoritmo de rastreo cuadrado detectar√° todo el borde, es decir  contorno, patr√≥n y dejar√° de funcionar despu√©s de una sola traza, es decir  no lo rastrear√° nuevamente, porque cuando alcanza el <b>borde l√≠mite inicial</b> por segunda vez, lo ingresar√° de la misma manera que la primera vez.  En consecuencia, el algoritmo de traza cuadrada con el criterio de detenci√≥n de Jacob determinar√° correctamente el contador de cualquier patr√≥n, siempre que tanto el patr√≥n como el fondo est√©n 4 conectados. <br><br><h2>  Rastreando los alrededores de Moore </h2><br><h4>  Idea </h4><br>  La idea detr√°s del rastreo de Moore-Neighbour es simple;  pero antes de explicarlo, necesitamos explicar un concepto importante: <b><i>el vecindario Moore de un</i></b> p√≠xel. <br><br><h4>  El barrio de Moore </h4><br>  El vecindario de Moore de un p√≠xel <b>P</b> es un conjunto de 8 p√≠xeles que tienen un v√©rtice o borde com√∫n con ese p√≠xel.  Dichos p√≠xeles, a saber, <b>P1, P2, P3, P4, P5, P6, P7 y P8</b> , se muestran en la <b><i>Figura 1</i></b> . <br><br>  El vecindario de Moore (tambi√©n llamado <b><i>8-vecinos</i></b> o <b><i>vecinos</i></b> <b><i>indirectos</i></b> ) es un concepto importante al que a menudo se hace referencia en la literatura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/08c/2ea/86308c2ea8863bc111d206fb5070250f.gif" height="195" width="178"></div><br>  Ahora estamos listos para familiarizarnos con la idea subyacente en el rastro de los alrededores de Moore. <br><br>  Que haya un patr√≥n digital, es decir  un grupo de p√≠xeles negros, sobre un fondo de p√≠xeles blancos, es decir  en la cuadr√≠cula;  encuentre el p√≠xel negro y declare el p√≠xel " <b>inicial</b> ".  (Hay varias formas de encontrar el p√≠xel " <b>inicial</b> ", pero, como antes, comenzaremos desde la esquina inferior izquierda y escanearemos todas las columnas de p√≠xeles en orden, hasta que encontremos el primer p√≠xel negro, que declararemos " <b>inicial</b> "). <br><br>  Ahora, de nuevo, imagine que es una mariquita parada en el p√≠xel <b>inicial</b> , como se muestra en la <b><i>Figura 2 a</i></b> continuaci√≥n.  Sin p√©rdida de generalizaci√≥n, detectaremos el contorno movi√©ndonos alrededor del patr√≥n en el sentido de las agujas del reloj.  (No importa qu√© direcci√≥n elijamos, lo principal es usarla constantemente en el algoritmo). <br><br>  La idea general es esta: cada vez que llegamos al p√≠xel negro <b>P</b> , volvemos, es decir, al p√≠xel blanco en el que nos encontramos antes.  Luego <b>damos la</b> vuelta al p√≠xel <b>P en el</b> sentido de las agujas del reloj, visitando cada p√≠xel en su vecindad de Moore, hasta llegar al p√≠xel negro.  El algoritmo termina cuando el p√≠xel de inicio alcanza el p√≠xel de inicio por segunda vez. <br><br>  Esos p√≠xeles negros que visit√≥ el algoritmo ser√°n el contorno del patr√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/afb/a2f/43eafba2f0611e11eb82c8ed7159971c.gif" height="252" width="216"></div><br><h4>  Algoritmo </h4><br>  La siguiente es una descripci√≥n formal del algoritmo de rastreo de vecindario de Moore: <br><br>  Entrada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teselaci√≥n</a> cuadrada <b>T que</b> contiene un componente conectado <b>P</b> de celdas negras. <br><br>  Salida: fila <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> ) de</b> p√≠xeles l√≠mite, es decir  contorno <br><br>  Denote por <b>M (a)</b> el vecindario de Moore del p√≠xel <b>a</b> . <br><br>  Deje que <b>p</b> sea ‚Äã‚Äãel p√≠xel del borde actual. <br><br>  Sea <b>c</b> el p√≠xel actual en consideraci√≥n, es decir.  <b>c</b> est√° en <b>M (p)</b> . <br><br>  Inicio <br><br><ul><li>  Defina <b>B</b> como un conjunto vac√≠o. </li><li>  De abajo hacia arriba y de izquierda a derecha, escanee las celdas <b>T</b> hasta encontrar un p√≠xel negro <b>s</b> de <b>P.</b> </li><li>  Inserte <b>s</b> en <b>B.</b> </li><li>  Establecemos el punto <b>s</b> como el punto l√≠mite actual <b>p</b> , es decir  <b>p = s</b> </li><li>  Volvamos, es decir  pasemos al p√≠xel desde el que llegamos al <b>s</b> . </li><li>  Sea <b>c el</b> siguiente p√≠xel en sentido horario en <b>M (p)</b> . </li><li>  Mientras <b>c</b> no <b>es</b> igual a <b>s</b> , ejecute <br><br><ul><li>  si <b>c</b> es negro <br><ul><li>  Insertar <b>c</b> en <b>B</b> </li><li>  establecemos <b>p = c</b> </li><li>  volver atr√°s (mover el p√≠xel actual <b>c</b> al p√≠xel desde el que llegamos a <b>p</b> ) </li></ul><br>  de lo contrario <br><ul><li>  mueve el p√≠xel actual <b>c</b> al siguiente p√≠xel en sentido horario en <b>M (p)</b> </li></ul><br>  Fin del ciclo Bye </li></ul></li></ul><br>  El final <br><br><h4>  Demostraci√≥n </h4><br>  La siguiente es una demostraci√≥n animada de c√≥mo la traza de vecindario de Moore realiza la detecci√≥n de patrones.  (Decidimos trazar el contorno en sentido horario). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/3f0/295/5443f02954a35cf08c7a9e462bfa0f8a.gif" height="360" width="360"></div><br><h4>  An√°lisis </h4><br>  La principal debilidad en el rastreo de los alrededores de Moore radica en la elecci√≥n de los criterios de detenci√≥n. <br><br>  En la descripci√≥n original del algoritmo para rastrear los alrededores de Moore, el criterio de detenci√≥n es golpear el p√≠xel <b>inicial por</b> segunda vez.  Similar al algoritmo de trazado cuadrado, resulta que el rastreo de los alrededores de Moore usando este criterio no puede detectar los contornos de una gran familia de patrones. <br><br>  La siguiente es una demostraci√≥n animada que explica por qu√© el algoritmo no puede encontrar el esquema exacto del patr√≥n debido a la selecci√≥n de un criterio de detenci√≥n incorrecto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d5e/7af/a1cd5e7afa1cd1b7312e5770c6cf826c.gif" height="252" width="216"></div><br>  Como puede ver, mejorar el criterio de detenci√≥n puede ser un buen comienzo para mejorar el rendimiento general de la traza.  Hay dos alternativas efectivas para el criterio de apagado, similar al criterio de apagado de Jacob. <br><br>  El uso del criterio de Jacob mejora significativamente la efectividad del trazado de los alrededores de Moore, lo que lo convierte en el mejor algoritmo para determinar el contorno de cualquier patr√≥n, independientemente de su conectividad. <br><br>  La raz√≥n de esto es principalmente porque el algoritmo verifica todo el vecindario de Moore del p√≠xel l√≠mite para buscar el siguiente p√≠xel l√≠mite.  A diferencia del algoritmo de traza cuadrada, que solo gira a izquierda y derecha y pierde los p√≠xeles "en diagonal", la traza de vecindario de Moore siempre podr√° detectar el l√≠mite exterior de cualquier componente conectado.  La raz√≥n es esta: para cualquier patr√≥n de <b><i>8 conectados</i></b> (o simplemente <b><i>conectados</i></b> ), el <b>siguiente</b> p√≠xel del borde se encuentra dentro del vecindario de Moore del p√≠xel del borde actual.  Debido a que el rastreo de vecindad de Moore verifica cada uno de los p√≠xeles en la vecindad de Moore del p√≠xel l√≠mite actual, debe detectar el siguiente p√≠xel l√≠mite. <br><br>  Cuando el trazado del vecindario de Moore alcanza el p√≠xel inicial por segunda vez de la misma manera que lo hizo la primera vez, esto significa que se ha detectado un <b>contorno externo</b> <b>completo</b> <b>del</b> patr√≥n, y si el algoritmo no se detiene, detectar√° nuevamente el mismo contorno. <br><br><h2>  Exploraci√≥n radial </h2><br>  El algoritmo de barrido radial es un algoritmo de detecci√≥n de contornos discutido en algunos libros.  A pesar del nombre complejo, la idea subyacente es muy simple.  De hecho, resulta que el algoritmo de barrido radial <b>es id√©ntico al</b> rastro del entorno de Moore.  Uno puede preguntar: "¬øPor qu√© lo mencionamos en absoluto?" <br><br>  El rastreo de los alrededores de Moore busca en las proximidades de Moore el p√≠xel l√≠mite actual en una determinada direcci√≥n (elegimos la direcci√≥n de las agujas del reloj) hasta que encuentre un p√≠xel negro.  Luego declara ese p√≠xel como el p√≠xel l√≠mite actual y contin√∫a. <br><br>  El algoritmo de exploraci√≥n radial hace lo mismo.  Por otro lado, proporciona una forma interesante de encontrar el siguiente p√≠xel negro en el vecindario de Moore de un p√≠xel l√≠mite determinado. <br><br>  El m√©todo se basa en la siguiente idea: <br><br>  cada vez que encontremos un nuevo p√≠xel l√≠mite, convi√©rtalo en el p√≠xel actual <b>P</b> y dibuje <b>un segmento de l√≠nea imaginario que</b> conecte <b>P</b> con el p√≠xel l√≠mite <b>anterior</b> .  Luego <b>giramos el</b> segmento con respecto a <b>P en el</b> sentido de las agujas del reloj hasta que se encuentra con un p√≠xel negro en el vecindario de Moore del p√≠xel <b>P.</b>  La rotaci√≥n de la l√≠nea es id√©ntica a la comprobaci√≥n de cada p√≠xel en las proximidades de Moore <b>P.</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creamos una demostraci√≥n animada de c√≥mo funciona el algoritmo de exploraci√≥n radial y c√≥mo se ve el trazado de los alrededores de Moore. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/419/ff6/fa1419ff6b8efc7ef94d978854f99fab.gif" height="360" width="326"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øY cu√°ndo se detiene el algoritmo de barrido radial? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos a explicar el comportamiento del algoritmo usando los siguientes criterios de detenci√≥n ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criterio de parada 1 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deje que el algoritmo de exploraci√≥n radial se complete cuando visite el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p√≠xel inicial por</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segunda vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n se muestra una demostraci√≥n animada, a partir de la cual est√° claro por qu√© el criterio de interrupci√≥n se cambiar√° correctamente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/432/408/04c432408fca093316e950c77bdd5537.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n vale la pena mencionar que cuando se utiliza este criterio de detenci√≥n en ambos algoritmos, la efectividad del algoritmo de exploraci√≥n radial es id√©ntica al rastreo del entorno de Moore. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el algoritmo de rastreo cuadrado y en el rastreo de vecindario de Moore, encontramos que el uso del criterio de detenci√≥n de Jacob mejora significativamente el rendimiento de ambos algoritmos. </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El criterio de detenci√≥n de Jacob</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requiere que el algoritmo deje de ejecutarse cuando visita el </font><font style="vertical-align: inherit;">p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial por</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segunda vez en la misma direcci√≥n que la primera vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafortunadamente, no podemos usar el criterio de detenci√≥n de Jacob en el algoritmo de barrido radial. La raz√≥n es que el algoritmo de exploraci√≥n radial no define el concepto</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La "direcci√≥n" en la que golpea el p√≠xel l√≠mite</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En otras palabras, no est√° clara la "direcci√≥n" en la que el algoritmo cay√≥ en el p√≠xel l√≠mite (y su definici√≥n no es trivial). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, debemos proponer otro criterio de detenci√≥n, que no dependa de la direcci√≥n de golpear un p√≠xel determinado, que puede mejorar la efectividad del algoritmo de exploraci√≥n radial ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criterio de parada 2 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponga que cada vez que el algoritmo detecta un nuevo p√≠xel l√≠mite </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se inserta en una </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serie de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> p√≠xeles l√≠mite: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; y declarado como el p√≠xel del borde actual. ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consideraremos el </font><font style="vertical-align: inherit;">p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Esto significa que conocemos el p√≠xel de borde anterior </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-1 de</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada p√≠xel de borde actual </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (En cuanto al </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p√≠xel inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , asumiremos que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es un p√≠xel imaginario que no es equivalente a ninguno de los p√≠xeles en la cuadr√≠cula que se enfrenta al </font><font style="vertical-align: inherit;">p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la fila de p√≠xeles de l√≠mite). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seg√∫n los supuestos anteriores, podemos determinar el criterio de detenci√≥n de la siguiente manera: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El algoritmo detiene la ejecuci√≥n cuando: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) el p√≠xel l√≠mite actual </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i se</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ha </font><font style="vertical-align: inherit;">encontrado </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previamente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como un p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (donde </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j &lt;i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) en una serie de p√≠xeles l√≠mite, y </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En otras palabras, el algoritmo completa la ejecuci√≥n cuando visita el p√≠xel l√≠mite P en el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segundo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veces si el p√≠xel l√≠mite antes de P (en la fila de p√≠xeles l√≠mite) por segunda vez es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el mismo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> p√≠xel que estaba antes de P cuando se visit√≥ P por </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primera</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si se cumple la condici√≥n del criterio de detenci√≥n y el algoritmo no se apaga, entonces el algoritmo de exploraci√≥n radial continuar√° detectando </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el mismo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> l√≠mite por segunda vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El rendimiento del algoritmo de barrido radial con este criterio de detenci√≥n es similar al rendimiento del rastreo del vecindario de Moore con el criterio de detenci√≥n de Jacob.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmo Theo Pavlidis </font></font></h2><br><h4>  Idea </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este algoritmo es uno de los √∫ltimos algoritmos de detecci√≥n de bucles propuestos por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theo Pavlidis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lo cit√≥ en su libro de 1982 </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithms for Graphics and Image Processing</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (cap√≠tulo 7, secci√≥n 5). No es tan simple como el algoritmo para trazar cuadrados o trazar los alrededores de Moore, pero no es tan complicado (esto es t√≠pico para la mayor√≠a de los algoritmos de detecci√≥n de bordes). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No explicaremos este algoritmo de la misma manera que se hizo en su libro. Nuestro enfoque es m√°s f√°cil de entender y da una idea de la idea general subyacente al algoritmo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin p√©rdida de generalizaci√≥n, decidimos dar la vuelta al bucle en el sentido de las agujas del reloj para que coincida con el orden de todos los dem√°s algoritmos presentados en el art√≠culo. Por otro lado, Pavlidis eligi√≥ la direcci√≥n en sentido antihorario. Esto no afectar√° el rendimiento del algoritmo. La √∫nica diferencia es la direcci√≥n relativa de los movimientos que haremos cuando rodeamos el contorno. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora pasemos a la idea ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digamos que tenemos un patr√≥n digital, es decir un grupo de p√≠xeles negros sobre un fondo de p√≠xeles blancos, es decir en la cuadr√≠cula; encuentre el p√≠xel negro y declare el </font><font style="vertical-align: inherit;">p√≠xel </font><font style="vertical-align: inherit;">" </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". Puede buscar el </font><font style="vertical-align: inherit;">p√≠xel </font><font style="vertical-align: inherit;">" </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " de varias maneras, por ejemplo, como se describi√≥ anteriormente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para encontrar la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p√≠xeles para usar este m√©todo es opcional. En su lugar, elegiremos un </font><font style="vertical-align: inherit;">p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que satisfaga las siguientes restricciones impuestas por el algoritmo Pavlidis para seleccionar un p√≠xel inicial: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una limitaci√≥n importante de la direcci√≥n en la que ingresamos el p√≠xel inicial.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De hecho, puede elegir CUALQUIER p√≠xel de borde negro como p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bajo esta condici√≥n: si inicialmente se para. en √©l, el p√≠xel vecino izquierdo NO es negro. En otras palabras, debe ingresar el </font><font style="vertical-align: inherit;">p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en una direcci√≥n tal que el p√≠xel vecino izquierdo sea blanco (la "izquierda" aqu√≠ se toma en relaci√≥n con la direcci√≥n en la que ingresamos el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p√≠xel inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora imagina que eres una mariquita parada</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p√≠xel </font><b><font style="vertical-align: inherit;">inicial</font></b><font style="vertical-align: inherit;"> , como se muestra en la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 1 a</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> continuaci√≥n. Durante la ejecuci√≥n del algoritmo, solo nos interesar√°n tres p√≠xeles delante de usted, es decir, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 se</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muestran en la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Designaremos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como el </font><font style="vertical-align: inherit;">p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delante de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usted, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el p√≠xel a la izquierda de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el p√≠xel a la derecha de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/792/4b1/53e7924b1a7cb6c5e84f70a038d52bc8.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que con el algoritmo de traza cuadrada, lo m√°s importante en el algoritmo de Pavlidis es el "sentido de la direcci√≥n". Los giros hacia la izquierda y hacia la derecha son relativos a la posici√≥n actual, que depende de c√≥mo ingres√≥ el p√≠xel actual. Por lo tanto, para realizar los movimientos correctos, es importante realizar un seguimiento de su orientaci√≥n actual. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero no importa c√≥mo se encuentre, los p√≠xeles P1, P2 y P3 se determinan como se describe anteriormente.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Con esta informaci√≥n, estamos listos para explicar el algoritmo ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada vez que se encuentre en el p√≠xel l√≠mite actual (que es primero el </font><font style="vertical-align: inherit;">p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), hacemos lo siguiente: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verifique el p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1 es</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> negro, declare </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el p√≠xel l√≠mite actual y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avance un paso hacia adelante, y luego</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√© </font><b><font style="vertical-align: inherit;">un paso hacia la izquierda</font></b><font style="vertical-align: inherit;"> para estar en P1 (el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orden de los</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> movimientos es muy importante). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la Figura 2</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a continuaci√≥n ilustra este caso. </font><font style="vertical-align: inherit;">El camino para llegar a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se muestra en azul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c32/131/ae9c321310cb5a8902ae4df3dc42cdc9.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y solo si P1 es blanco, procedemos a verificar P2 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 es</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> negro, declare </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2 como el</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> p√≠xel l√≠mite actual y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avance un paso</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para estar en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este caso se muestra en la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 3 a</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> continuaci√≥n. </font><font style="vertical-align: inherit;">La ruta que debe seguir en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se muestra en azul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/7eb/934/b347eb9345873e5ba6aa136ab2fbb406.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo si P1 y P2 son blancos, vaya a verificar P3 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 es</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> negro, declare </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 como el</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> p√≠xel del borde actual y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mu√©vase un paso hacia la derecha y luego un paso hacia la izquierda</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como se muestra en la Figura 4 a continuaci√≥n.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/bb6/7fa/0adbb67fa67183dec47bb4c1bf3221a7.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eso es todo!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tres reglas simples para tres casos simples. Como puede ver, es importante hacer un seguimiento de su direcci√≥n en las curvas, ya que todos los movimientos se realizan en relaci√≥n con la orientaci√≥n actual. Pero parece que olvidamos algo? </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© pasa si los tres p√≠xeles son blancos frente a nosotros?</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luego giramos (de pie en el p√≠xel l√≠mite actual) 90 grados en el sentido de las agujas del reloj para ver un nuevo conjunto de tres p√≠xeles frente a nosotros. Luego hacemos la misma verificaci√≥n para estos nuevos p√≠xeles. Todav√≠a puede tener una pregunta: ¬øqu√© pasa si todos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tres p√≠xeles son blancos? Luego, nuevamente giramos 90 grados en el sentido de las agujas del reloj, de pie en el mismo p√≠xel. Antes de verificar todo el vecindario del p√≠xel de Moore, puede rotar tres veces (cada 90 grados en el sentido de las agujas del reloj).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si giramos tres veces sin encontrar p√≠xeles negros, significa que estamos parados en un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p√≠xel aislado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , no conectado a ning√∫n otro p√≠xel negro. </font><font style="vertical-align: inherit;">Es por eso que el algoritmo le permite rotar tres veces y luego completa su ejecuci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro aspecto: ¬ø </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cu√°ndo completa la ejecuci√≥n el algoritmo? </font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El algoritmo termina en dos casos: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) como se mencion√≥ anteriormente. </font><font style="vertical-align: inherit;">el algoritmo le permite rotar tres veces (90 grados en el sentido de las agujas del reloj cada vez), despu√©s de completar la ejecuci√≥n y declarar el p√≠xel aislado O </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) cuando el p√≠xel l√≠mite actual es el </font><font style="vertical-align: inherit;">p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el algoritmo completa la ejecuci√≥n al "declarar" que detect√≥ el contorno del patr√≥n.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La siguiente es una descripci√≥n formal del algoritmo de Pavlidis: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entrada: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teselaci√≥n</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cuadrada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T que</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contiene un componente conectado </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√©lulas negras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salida: fila </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> p√≠xeles l√≠mite, es decir </font><font style="vertical-align: inherit;">contorno </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definiciones:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denote por </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p el</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> p√≠xel l√≠mite actual, es decir </font><font style="vertical-align: inherit;">El p√≠xel en el que nos encontramos.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Defina </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3 de la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> siguiente manera: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(vea tambi√©n la Figura 1 arriba)</font></font></i></b> </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el p√≠xel frente a usted, adyacente al que est√° parado, es decir, </font><font style="vertical-align: inherit;">con pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <b>P1</b> ‚Äî  ,   <b>P2</b> . </li><li> <b>P3</b> ‚Äî  ,   <b>P2</b> . </li><li>  <b>¬´¬ª</b>            . </li></ul><br>  Inicio <br><br><ul><li>  <b>B</b>   . </li><li>   <b>T</b>     ,      <b></b>  <b>s</b>  <b>P</b> <b><i>(.     ,       )</i></b> </li><li>  <b>s</b>  <b>B</b> . </li><li>    <b>p</b>     <b>s</b> . </li><li>  : <br>   <b>P1</b>  <br><ul><li>  <b>P1</b>  <b>B</b> </li><li>  <b>p=P1</b> </li><li>     ,      </li></ul><br>   <b>P2</b>  <br><ul><li>  <b>P2</b>  <b>B</b> </li><li>  <b>p=P2</b> </li><li>      <b><i>(.   3)</i></b> </li></ul><br>   <b>P3</b>  <br><ul><li>  <b>P3</b>  <b>B</b> </li><li>  <b>p=P3</b> </li><li>    ,      <b><i>(.   4)</i></b> </li></ul><br>        90    ,   <b>  p</b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminar el programa y declarar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p un</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aislado</font></font></b><font style="vertical-align: inherit;"></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de lo contrario </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">girar 90 grados en el sentido de las agujas del reloj, de pie en el p√≠xel actual </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p = s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Fin del ciclo de repetici√≥n)</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El final </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demostraci√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La siguiente es una demostraci√≥n animada de c√≥mo el algoritmo Pavlidis detecta el contorno de un patr√≥n dado. </font><font style="vertical-align: inherit;">No olvides que caminamos en p√≠xeles; </font><font style="vertical-align: inherit;">observe c√≥mo cambia la orientaci√≥n al girar a la izquierda o derecha. </font><font style="vertical-align: inherit;">Para explicar el algoritmo con el mayor detalle posible, incluimos todos los casos posibles en √©l.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/f0f/1dd/22af0f1dd39a517bb6097cd0fe3ec99d.gif" height="324" width="288"></div><br><h4>  An√°lisis </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si cree que el algoritmo de Pavlidis es ideal para detectar esquemas de patrones, entonces deber√≠a cambiar de opini√≥n ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este algoritmo es realmente un poco m√°s complicado que, por ejemplo, rastrear los alrededores de Moore, en el que no hay casos especiales que requieran un procesamiento separado, pero no podr√° determinar los contornos de un gran Una familia de patrones que tiene un cierto tipo de conectividad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El algoritmo funciona muy bien en patrones 4 conectados. Su problema ocurre al rastrear algunos patrones conectados a 8 que no est√°n conectados a 4. La siguiente es una demostraci√≥n animada de c√≥mo el algoritmo Pavlidis no puede detectar el contorno correcto de un patr√≥n conectado a 8 (no uno conectado a 4): omite la mayor parte del borde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/56a/816/22556a816442cf010492cc30b64392eb.gif" height="252" width="247"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay dos formas simples de modificar un algoritmo para mejorar significativamente su rendimiento. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Reemplace el criterio de detenci√≥n</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En lugar de completar el algoritmo cuando visita el p√≠xel de inicio por segunda vez, puede finalizarlo cuando visita el p√≠xel de inicio por tercera o incluso cuarta vez. Esto mejorar√° el rendimiento general del algoritmo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Llegue a la fuente del problema, es decir, antes de seleccionar el p√≠xel inicial.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Existe una limitaci√≥n importante con respecto a la direcci√≥n en la que se realiza la entrada al p√≠xel inicial. Esencialmente, debe ingresar el p√≠xel de inicio para que cuando se pare sobre √©l, el p√≠xel a su izquierda sea blanco. La raz√≥n para introducir esta restricci√≥n es la siguiente: ya que siempre miramos los tres p√≠xeles que </font><font style="vertical-align: inherit;">tenemos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delante</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en cierto orden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en algunos patrones omitiremos el p√≠xel l√≠mite que se encuentra directamente a la izquierda del p√≠xel inicial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos arriesgamos a perder no solo el p√≠xel vecino izquierdo del p√≠xel inicial, sino tambi√©n el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p√≠xel directamente debajo de √©l</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (como se demostr√≥ en el an√°lisis). Adem√°s, en algunos patrones, se omitir√° un p√≠xel correspondiente al p√≠xel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 5 a</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> continuaci√≥n. Por lo tanto, suponemos que el p√≠xel inicial debe golpearse en una direcci√≥n tal que los p√≠xeles correspondientes a los p√≠xeles </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L, W</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R que se</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muestran en la </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 5 a</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> continuaci√≥n sean blancos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/a81/359/9c8a81359338b31b6f5c0e016230e629.gif" height="200" width="159"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, los patrones como el que se muestra en la demostraci√≥n se detectar√°n correctamente y la eficacia del algoritmo de Pavlidis mejorar√° significativamente. </font><font style="vertical-align: inherit;">Por otro lado, encontrar un p√≠xel inicial que satisfaga estos requisitos puede ser un desaf√≠o, y en muchos casos ser√° imposible encontrar dicho p√≠xel. </font><font style="vertical-align: inherit;">En este caso, debe utilizar una forma alternativa para mejorar el algoritmo de Pavlidis, es decir, la finalizaci√≥n del algoritmo despu√©s de visitar el punto de partida por tercera vez.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467611/">https://habr.com/ru/post/467611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467597/index.html">Personalizaci√≥n de pautas de productos de Big Data con Vowpal Wabbit</a></li>
<li><a href="../467599/index.html">Representaci√≥n de gr√°ficos en 3D con OpenGL</a></li>
<li><a href="../467605/index.html">Todo lo que necesitas es URL</a></li>
<li><a href="../467607/index.html">Confesi√≥n del enemigo del estibador</a></li>
<li><a href="../467609/index.html">Crear una aplicaci√≥n m√≥vil en React Native</a></li>
<li><a href="../467615/index.html">C√≥mo crear Python wrapper y no volverse loco</a></li>
<li><a href="../467617/index.html">Kaspresso: el marco de autotest que estabas esperando</a></li>
<li><a href="../467619/index.html">Los lanzadores Aquafor son un buen ejemplo de c√≥mo no se pueden dise√±ar filtros para el tratamiento del agua</a></li>
<li><a href="../467621/index.html">Reuni√≥n de Elasticsearch Mosc√∫ en Ozon</a></li>
<li><a href="../467623/index.html">React Native: crear un campo de entrada animado con la API animada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>