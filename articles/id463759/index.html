<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë©üèΩ ü§¶üèæ üí≤ PVS-Studio mengunjungi Apache Hive ‚òùüèª üòí üë®‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama sepuluh tahun terakhir, pergerakan open source telah menjadi salah satu faktor kunci dalam pengembangan industri TI dan merupakan bagian pentin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio mengunjungi Apache Hive</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463759/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/2d0/eb3/0ad2d0eb30d726eefba9c913edaa346a.png" alt="Gambar 1"></div><br>  Selama sepuluh tahun terakhir, pergerakan open source telah menjadi salah satu faktor kunci dalam pengembangan industri TI dan merupakan bagian penting darinya.  Peran dan tempat open source tidak hanya ditingkatkan oleh pertumbuhan indikator kuantitatif, tetapi ada juga perubahan dalam posisi kualitatifnya di pasar TI secara keseluruhan.  Tanpa duduk diam, tim pemberani dari PVS-Studio secara aktif berkontribusi untuk mengkonsolidasikan posisi proyek sumber terbuka, menemukan bug tersembunyi dalam ketebalan besar basis kode dan menawarkan lisensi gratis untuk proyek-proyek tersebut.  Artikel ini tidak terkecuali!  Hari ini kita akan berbicara tentang Apache Hive!  Laporan diterima - ada sesuatu untuk dilihat! <br><a name="habracut"></a><br><h2>  Tentang PVS-Studio </h2><br>  Alat analisis kode statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> telah ada selama lebih dari 10 tahun di pasar TI dan merupakan solusi perangkat lunak yang multifungsi dan mudah diimplementasikan.  Saat ini, alat analisa mendukung C, C ++, C #, bahasa Java dan bekerja pada platform Windows, Linux dan macOS. <br><br>  PVS-Studio adalah solusi B2B berbayar dan digunakan oleh sejumlah besar tim di berbagai perusahaan.  Jika Anda ingin melihat apa yang mampu dilakukan oleh alat analisa, maka unduh kit distribusi dan minta kunci percobaan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Jika Anda seorang geek sumber terbuka atau, misalnya, adalah seorang siswa, maka Anda dapat menggunakan salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi</a> lisensi gratis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari</a> PVS-Studio. <br><br><h2>  Tentang Apache Hive </h2><br>  Volume data dalam beberapa tahun terakhir tumbuh dengan kecepatan tinggi.  Database standar tidak lagi dapat mempertahankan operabilitas pada tingkat pertumbuhan dalam jumlah informasi yang berfungsi sebagai kemunculan istilah Big Data dan segala sesuatu yang terkait dengannya (pemrosesan, penyimpanan, dan semua tindakan selanjutnya dengan volume data yang demikian). <br><br>  Saat ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Hadoop</a> dianggap sebagai salah satu teknologi dasar Big Data.  Tujuan utama dari teknologi ini adalah penyimpanan, pemrosesan dan pengelolaan volume data yang besar.  Komponen utama dari kerangka kerja adalah Hadoop Common, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HDFS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hadoop MapReduce</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hadoop YARN</a> .  Seiring waktu, seluruh ekosistem proyek dan teknologi terkait telah terbentuk di sekitar Hadoop, banyak di antaranya yang awalnya dikembangkan sebagai bagian dari proyek, dan kemudian menjadi mandiri.  Salah satu proyek ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Hive</a> . <br><br>  Apache Hive adalah gudang data terdistribusi.  Ini mengelola data yang disimpan dalam HDFS dan menyediakan bahasa query berbasis SQL (HiveQL) untuk bekerja dengan data ini.  Untuk kenalan terperinci dengan proyek ini, Anda dapat mempelajari informasi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Tentang analisis </h2><br>  Urutan langkah-langkah untuk analisis ini cukup sederhana dan tidak memerlukan banyak waktu: <br><br><ul><li>  Mendapat Apache Hive dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> ; </li><li>  Saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi</a> untuk memulai penganalisis Java dan memulai analisis; </li><li>  Saya menerima laporan analisa, menganalisisnya dan menyoroti kasus-kasus menarik. </li></ul><br>  Hasil analisis: 1456 peringatan tingkat kepercayaan Tinggi dan Menengah (masing-masing 602 dan 854) dikeluarkan untuk 6500+ file. <br><br>  Tidak semua peringatan adalah kesalahan.  Ini adalah situasi yang normal, dan sebelum menggunakan penganalisa secara teratur, konfigurasinya diperlukan.  Maka kita dapat mengharapkan persentase positif palsu yang cukup rendah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> ). <br><br>  Di antara peringatan, 407 peringatan (177 Tinggi dan 230 Medium) per file uji tidak dipertimbangkan.  Aturan diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6022</a> tidak dipertimbangkan (sulit untuk memisahkan situasi yang salah dari yang benar dalam kode asing), yang memiliki sebanyak 482 peringatan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6021</a> dengan 179 peringatan juga tidak dipertimbangkan. <br><br>  Pada akhirnya, semua sama, sejumlah peringatan tetap ada.  Dan karena saya tidak mengonfigurasi analisa, di antara mereka lagi ada positif palsu.  Tidak masuk akal untuk menggambarkan sejumlah besar peringatan dalam sebuah artikel :).  Pertimbangkan apa yang menarik perhatian saya dan tampak menarik. <br><br><h2>  Kondisi yang ditentukan sebelumnya </h2><br>  Aturan diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6007</a> adalah pemegang rekor di antara semua peringatan penganalisa yang tersisa.  Lebih dari 200 peringatan !!!  Beberapa, seperti, tidak berbahaya, beberapa mencurigakan, sementara yang lain benar-benar kesalahan!  Mari kita lihat beberapa di antaranya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6007</a> Expression 'key.startsWith ("hplsql.")' Selalu benar.  Exec.java (675) <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initOptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == null || value == null || !key.startsWith(<span class="hljs-string"><span class="hljs-string">"hplsql."</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } else if (key.compareToIgnoreCase(Conf.CONN_DEFAULT) == 0) { .... } else if (key.startsWith("hplsql.conn.init.")) { .... } else if (key.startsWith(Conf.CONN_CONVERT)) { .... } else if (key.startsWith("hplsql.conn.")) { .... } else if (key.startsWith("hplsql.")) { // &lt;= .... } }</span></span></code> </pre> <br>  Konstruksi if-else-if yang cukup panjang!  Penganalisis bersumpah pada akhirnya <i>if (key.startsWith ("hplsql."))</i> , Menunjukkan kebenarannya jika program mencapai fragmen kode ini.  Memang, jika Anda melihat awal konstruksi if-else-if, maka cek sudah selesai.  Dan seandainya baris kami tidak dimulai dengan substring <i>"hplsql."</i>  , maka eksekusi kode langsung melompat ke iterasi berikutnya. <br><br>  Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6007</a> ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">columnNameProperty.length</a> () == 0' selalu salah.  OrcRecordUpdater.java (238) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDescription </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTypeDescriptionFromTableProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tableProperties != null) { final String columnNameProperty = ....; final String columnTypeProperty = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !Strings.isNullOrEmpty(columnNameProperty) &amp;&amp; !Strings.isNullOrEmpty(columnTypeProperty)) { List&lt;String&gt; columnNames = columnNameProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;() : ....; List&lt;TypeInfo&gt; columnTypes = columnTypeProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;TypeInfo&gt;() : ....; .... } } } .... }</code> </pre> <br>  Membandingkan panjang string dari <i>columnNameProperty</i> dengan nol akan selalu menghasilkan <i>false</i> .  Ini karena perbandingan kami sedang diuji <i>! Strings.isNullOrEmpty (columnNameProperty)</i> .  Jika keadaan program mencapai kondisi kita yang dimaksud, maka baris <i>columnNameProperty</i> dijamin tidak nol dan tidak kosong. <br><br>  Ini juga berlaku untuk baris <i>columnTypeProperty</i> .  Baris peringatan di bawah ini: <br><br><ul><li>  Ekspresi V6007 'columnTypeProperty.length () == 0' selalu salah.  OrcRecordUpdater.java (239) </li></ul><br>  Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6007</a> 'colOrScalar1.equals ("Column")' selalu salah.  GenVectorCode.java (3469) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateDateTimeArithmeticIntervalYearMonth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] tdesc)</span></span></span><span class="hljs-function"> throws Exception </span></span>{ .... String colOrScalar1 = tdesc[<span class="hljs-number"><span class="hljs-number">4</span></span>]; .... String colOrScalar2 = tdesc[<span class="hljs-number"><span class="hljs-number">6</span></span>]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Col"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } else if (colOrScalar1.equals("Col") &amp;&amp; colOrScalar1.equals("Scalar")) { .... } else if (colOrScalar1.equals("Scalar") &amp;&amp; colOrScalar1.equals("Column")) { .... }</span></span></code> </pre> <br>  } <br><br>  Inilah copy-paste yang sepele.  Ternyata garis <i>colOrScalar1</i> harus sama dengan nilai yang berbeda pada saat yang sama, dan ini tidak mungkin.  Rupanya, variabel <i>colOrScalar1</i> harus diperiksa di sebelah kiri, dan <i>colOrScalar2</i> di sebelah kanan. <br><br>  Lebih banyak peringatan serupa di baris di bawah ini: <br><br><ul><li>  Ekspresi V6007 'colOrScalar1.equals ("Scalar")' selalu salah.  GenVectorCode.java (3475) </li><li>  Ekspresi V6007 'colOrScalar1.equals ("Column")' selalu salah.  GenVectorCode.java (3486) </li></ul><br>  Akibatnya, tidak ada tindakan dalam konstruksi if-else-if yang akan dieksekusi. <br><br>  Beberapa peringatan lain untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6007</a> : <br><br><ul><li>  Ekspresi V6007 'karakter == null' selalu salah.  RandomTypeUtil.java (43) </li><li>  Ekspresi V6007 'writeIdHwm&gt; 0' selalu salah.  TxnHandler.java (1603) </li><li>  Ekspresi V6007 'fields.equals ("*")' selalu benar.  Server.java (983) </li><li>  Ekspresi V6007 'currentGroups! = Null' selalu benar.  GenericUDFCurrentGroups.java (90) </li><li>  Ekspresi V6007 'this.wh == null' selalu salah.  Pengembalian baru bukan-null referensi.  StorageBasedAuthorizationProvider.java (93), StorageBasedAuthorizationProvider.java (92) </li><li>  dan seterusnya ... </li></ul><br><h2>  NPE </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6008</a> Potensi null dereference dari 'dagLock'.  QueryTracker.java (557), QueryTracker.java (553) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleFragmentCompleteExternalQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QueryInfo queryInfo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryInfo.isExternalQuery()) { ReadWriteLock dagLock = getDagLock(queryInfo.getQueryIdentifier()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dagLock == null) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Ignoring fragment completion for unknown query: {}"</span></span>, queryInfo.getQueryIdentifier()); } boolean locked = dagLock.writeLock().tryLock(); ..... } }</code> </pre> <br>  Tertangkap objek nol, berjanji dan ... terus bekerja.  Ini mengarah pada fakta bahwa setelah memeriksa objek dereferencing objek nol terjadi.  Kesedihan! <br><br>  Kemungkinan besar, dalam kasus referensi nol, Anda harus segera keluar dari fungsi atau membuang beberapa pengecualian khusus. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6008</a> Null dereference 'buffer' dalam fungsi 'unlockSingleBuffer'.  MetadataCache.java (410), MetadataCache.java (465) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LlapBufferOrBuffers buffers, ....)</span></span></span><span class="hljs-function"> </span></span>{ LlapAllocatorBuffer buffer = buffers.getSingleLlapBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer != null) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return lockOneBuffer(buffer, doNotifyPolicy); } LlapAllocatorBuffer[] bufferArray = buffers.getMultipleLlapBuffers(); for (int i = 0; i &lt; bufferArray.length; ++i) { if (lockOneBuffer(bufferArray[i], doNotifyPolicy)) continue; for (int j = 0; j &lt; i; ++j) { unlockSingleBuffer(buffer, true); // &lt;= } .... } .... } .... private void unlockSingleBuffer(LlapAllocatorBuffer buffer, ....) { boolean isLastDecref = (buffer.decRef() == 0); // &lt;= if (isLastDecref) { .... } }</span></span></code> </pre> <br>  Dan lagi NPE potensial.  Jika program mencapai metode <i>unlockSingleBuffer</i> , objek <i>buffer</i> akan menjadi nol.  Katakanlah itu terjadi!  Mari kita lihat metode <i>unlockSingleBuffer</i> dan segera pada baris pertama kita melihat bahwa objek kita mengalami dereferensi.  Kita disini! <br><br><h2>  Tidak mengikuti shift </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6034</a> Shift dengan nilai 'bitShiftsInWord - 1' bisa tidak konsisten dengan ukuran tipe: 'bitShiftsInWord - 1' = [-1 ... 30].  UnsignedInt128.java (1791) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, boolean roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } assert (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br>  Kemungkinan diimbangi dengan -1.  Jika, misalnya, <i>wordShifts == 3</i> dan <i>bitShiftsInWord == 0</i> datang ke input metode yang dimaksud, maka 1 &lt;&lt; -1 akan muncul di baris yang ditentukan.  Apakah ini direncanakan? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6034</a> Shift dengan nilai 'j' bisa tidak konsisten dengan ukuran tipe: 'j' = [0 ... 63].  IoTrace.java (272) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, boolean[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br>  Pada baris yang ditentukan, variabel <i>j</i> dapat mengambil nilai dalam rentang [0 ... 63].  Karena itu, perhitungan nilai <i>val</i> dalam loop mungkin tidak terjadi sesuai keinginan pengembang.  Dalam ekspresi <i>(1 &lt;&lt; j),</i> unit bertipe <i>int</i> , dan, menggesernya dari 32 atau lebih, kita melampaui batas yang diizinkan.  Untuk memperbaiki situasi, Anda harus menulis <i>((panjang) 1 &lt;&lt; j)</i> . <br><br><h2>  Antusias tentang logging </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6046</a> Format salah.  Jumlah item format yang berbeda diharapkan.  Argumen tidak digunakan: 1, 2. StatsSources.java (89) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ImmutableList&lt;PersistedRuntimeStats&gt; extractStatsFromPlanMapper (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stat.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> || sig.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { StringBuffer sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuffer(); sb.append(String.format( <span class="hljs-string"><span class="hljs-string">"expected(stat-sig) 1-1, got {}-{} ;"</span></span>, <span class="hljs-comment"><span class="hljs-comment">// &lt;= stat.size(), sig.size() )); .... } .... if (e.getAll(OperatorStats.IncorrectRuntimeStatsMarker.class).size() &gt; 0) { LOG.debug( "Ignoring {}, marked with OperatorStats.IncorrectRuntimeStatsMarker", sig.get(0) ); continue; } .... }</span></span></code> </pre> <br>  Saat memformat string melalui <i>String.format (),</i> pengembang membingungkan sintaksisnya.  Intinya: parameter yang dikirimkan tidak masuk ke string yang dihasilkan.  Saya dapat berasumsi bahwa dalam tugas sebelumnya pengembang bekerja pada logging, dari mana dia meminjam sintaks. <br><br><h2>  Mencuri pengecualian </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6051</a> Penggunaan pernyataan 'kembali' di blok 'akhirnya' dapat menyebabkan hilangnya pengecualian yang tidak ditangani.  ObjectStore.java (9080) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;MPartitionColumnStatistics&gt; getMPartitionColumnStatistics(....) throws NoSuchObjectException, MetaException { boolean committed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex instanceof MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } finally { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br>  Mengembalikan sesuatu dari blok terakhir adalah praktik yang sangat buruk, dan dengan contoh ini kita akan melihat ini. <br><br>  Di blok <i>coba</i> , permintaan terbentuk dan penyimpanan diakses.  Variabel yang <i>dikomitmenkan</i> secara default menjadi <i>false</i> dan mengubah statusnya hanya setelah semua tindakan yang berhasil diselesaikan di blok <i>coba</i> .  Ini berarti bahwa jika pengecualian terjadi, variabel kami akan selalu <i>salah</i> .  Blok menangkap menangkap pengecualian, sedikit diperbaiki dan melemparkan lebih jauh.  Dan ketika saatnya tiba untuk blok <i>akhirnya,</i> eksekusi memasuki kondisi dari mana kita mengembalikan daftar kosong ke luar.  Berapa pengembalian ini kepada kita?  Tapi itu sepadan dengan kenyataan bahwa semua pengecualian yang tertangkap tidak akan pernah dibuang dan diproses dengan cara yang tepat.  Semua pengecualian yang ditunjukkan dalam metode tanda tangan tidak akan pernah dibuang dan hanya membingungkan. <br><br>  Peringatan serupa: <br><br><ul><li>  V6051 Penggunaan pernyataan 'kembali' di blok 'akhirnya' dapat menyebabkan hilangnya pengecualian yang tidak ditangani.  ObjectStore.java (808) </li></ul><br><h2>  ... lainnya </h2><br>  Fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6009</a> 'compareTo' menerima argumen aneh.  Objek 'o2.getWorkerIdentity ()' digunakan sebagai argumen untuk metode sendiri.  LlapFixedRegistryImpl.java (244) <br><br><pre> <code class="cpp hljs">@Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;LlapServiceInstance&gt; getAllInstancesOrdered(....) { .... Collections.sort(<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Comparator&lt;LlapServiceInstance&gt;() { @Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compare(LlapServiceInstance o1, LlapServiceInstance o2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o2.getWorkerIdentity().compareTo(o2.getWorkerIdentity()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } }); .... }</span></span></code> </pre> <br>  Copy-paste, kecerobohan, kesibukan dan banyak alasan lain untuk melakukan kesalahan bodoh ini.  Saat memeriksa proyek sumber terbuka, kesalahan semacam ini cukup umum.  Bahkan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel lengkap</a> tentang itu. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6020</a> Bagilah dengan nol.  Kisaran nilai penyebut 'pembagi' termasuk nol.  SqlMathUtil.java (265) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divideUnsignedLong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divisor &lt; <span class="hljs-number"><span class="hljs-number">0L</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*some comments*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (compareUnsignedLong(dividend, divisor)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0L</span></span> : <span class="hljs-number"><span class="hljs-number">1L</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dividend &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Both inputs non-negative return dividend / divisor; // &lt;= } else { .... } }</span></span></code> </pre> <br>  Semuanya cukup sederhana di sini.  Sejumlah cek tidak memperingatkan terhadap pembagian dengan 0. <br><br>  Lebih banyak peringatan: <br><br><ul><li>  V6020 Mod dengan nol.  Kisaran nilai penyebut 'pembagi' termasuk nol.  SqlMathUtil.java (309) </li><li>  V6020 Bagilah dengan nol.  Kisaran nilai penyebut 'pembagi' termasuk nol.  SqlMathUtil.java (276) </li><li>  V6020 Bagilah dengan nol.  Kisaran nilai penyebut 'pembagi' termasuk nol.  SqlMathUtil.java (312) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6030</a> Metode yang terletak di sebelah kanan '|'  operator akan dipanggil terlepas dari nilai operan kiri.  Mungkin, lebih baik menggunakan '||'.  OperatorUtils.java (573) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Operator&lt;? extends OperatorDesc&gt; findSourceRS(....) { .... List&lt;Operator&lt;? extends OperatorDesc&gt;&gt; parents = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parents == null | parents.isEmpty()) { <span class="hljs-comment"><span class="hljs-comment">// reached end eg TS operator return null; } .... }</span></span></code> </pre> <br>  Alih-alih operator logis ||  menulis operator bitwise |  Ini berarti bahwa sisi kanan akan dieksekusi terlepas dari hasil sisi kiri.  Kesalahan seperti itu, dalam kasus <i>orang tua == null</i> , akan segera mengarah ke NPE di subekspresi logis berikutnya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6042</a> Ekspresi diperiksa untuk kompatibilitas dengan tipe 'A' tetapi dilemparkan ke tipe 'B'.  VectorColumnAssignFactory.java (347) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VectorColumnAssign </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildObjectAssign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VectorizedRowBatch outputBatch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outColIndex, PrimitiveCategory category)</span></span></span><span class="hljs-function"> throws HiveException </span></span>{ VectorColumnAssign outVCA = null; ColumnVector destCol = outputBatch.cols[outColIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol instanceof LongColumnVector) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(category) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LONG: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorLongColumnAssign() { .... } .init(.... , (LongColumnVector) destCol); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TIMESTAMP: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorTimestampColumnAssign() { .... }.init(...., (TimestampColumnVector) destCol); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case DATE: outVCA = new VectorLongColumnAssign() { .... } .init(...., (LongColumnVector) destCol); break; case INTERVAL_YEAR_MONTH: outVCA = new VectorLongColumnAssign() { .... }.init(...., (LongColumnVector) destCol); break; case INTERVAL_DAY_TIME: outVCA = new VectorIntervalDayTimeColumnAssign() { .... }.init(...., (IntervalDayTimeColumnVector) destCol);// &lt;= break; default: throw new HiveException(....); } } else if (destCol instanceof DoubleColumnVector) { .... } .... else { throw new HiveException(....); } return outVCA; }</span></span></code> </pre> <br>  Kelas-kelas yang <i>dimaksud adalah LongColumnVector extends ColumnVector</i> dan <i>TimestampColumnVector extends ColumnVector</i> .  Memeriksa objek <i>destCol</i> kami untuk kepemilikan <i>LongColumnVector</i> dengan jelas memberi tahu kami bahwa objek kelas ini akan berada di dalam pernyataan bersyarat.  Meskipun demikian, kami melakukan casting ke <i>TimestampColumnVector</i> !  Seperti yang Anda lihat, kelas-kelas ini berbeda, tidak termasuk orang tua mereka.  Akibatnya - <i>ClassCastException</i> . <br><br>  Semua yang sama dapat dikatakan tentang konversi tipe ke <i>IntervalDayTimeColumnVector</i> : <br><br><ul><li>  V6042 Ekspresi diperiksa untuk kompatibilitas dengan tipe 'A' tetapi dilemparkan ke tipe 'B'.  VectorColumnAssignFactory.java (390) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6060</a> Referensi 'var' digunakan sebelum diverifikasi terhadap nol.  Var.java (402), Var.java (395) <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getClass() != obj.getClass()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } Var var = (Var)obj; if (this == var) { return true; } else if (var == null || // &lt;= var.value == null || this.value == null) { return false; } .... }</span></span></code> </pre> <br>  Perbandingan aneh dari objek <i>var</i> dengan <i>null</i> setelah dereferencing telah terjadi.  Dalam konteks ini, <i>var</i> dan <i>obj</i> adalah objek yang sama ( <i>var = (Var) obj</i> ).  Memeriksa <i>null</i> menyiratkan bahwa objek nol dapat datang.  Dan dalam kasus <i>equals (null),</i> kita langsung mendapatkan NPE baris pertama dan bukan <i>false yang</i> diharapkan.  Sayangnya, ada cek, tetapi tidak ada. <br><br>  Momen mencurigakan serupa menggunakan objek sebelum pemeriksaan terjadi: <br><br><ul><li>  V6060 Referensi 'nilai' digunakan sebelum diverifikasi terhadap nol.  ParquetRecordReaderWrapper.java (168), ParquetRecordReaderWrapper.java (166) </li><li>  V6060 Referensi 'defaultConstraintCols' digunakan sebelum diverifikasi terhadap nol.  HiveMetaStore.java (2539), HiveMetaStore.java (2530) </li><li>  V6060 Referensi 'projIndxLst' digunakan sebelum diverifikasi terhadap nol.  RelOptHiveTable.java (683), RelOptHiveTable.java (682) </li><li>  V6060 Referensi 'oldp' digunakan sebelum diverifikasi terhadap nol.  ObjectStore.java (4343), ObjectStore.java (4339) </li><li>  dan seterusnya ... </li></ul><br><h2>  Kesimpulan </h2><br>  Siapa pun yang sedikit tertarik pada Big Data, ia hampir tidak melewatkan arti dari Apache Hive.  Proyek ini populer dan cukup besar, dan dalam komposisinya memiliki lebih dari 6500 file kode sumber (* .java).  Kode ini telah ditulis oleh banyak pengembang selama bertahun-tahun dan, sebagai akibatnya, analisa statis memiliki sesuatu untuk ditemukan.  Ini sekali lagi menegaskan bahwa analisis statis sangat penting dan berguna dalam pengembangan proyek menengah dan besar! <br><br>  Catatan  Pemeriksaan satu kali seperti itu menunjukkan kemampuan penganalisa kode statis, tetapi merupakan cara yang sepenuhnya salah untuk menggunakannya.  Ide ini disajikan secara lebih rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Gunakan analisis secara teratur! <br><br>  Saat memeriksa Hive, sejumlah kecacatan dan momen yang mencurigakan terdeteksi.  Jika artikel ini menarik perhatian tim pengembang Apache Hive, kami akan senang berkontribusi pada tugas yang sulit ini. <br><br>  Mustahil untuk membayangkan Apache Hive tanpa Apache Hadoop, sehingga kemungkinan unicorn dari PVS-Studio juga akan terlihat di sana.  Tapi itu saja untuk hari ini, tetapi untuk sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">unduh</a> penganalisa dan periksa proyek Anda sendiri. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Maxim Stefanov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio Mengunjungi Apache Hive</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463759/">https://habr.com/ru/post/id463759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463747/index.html">Akses properti di dalam bidang Jsonb untuk Npgsql</a></li>
<li><a href="../id463749/index.html">Scrum vs Kanban: Tetap Tenang dan Pilih Yang Cocok Untukmu</a></li>
<li><a href="../id463751/index.html">iOS 13: Apa yang Anda butuhkan dan apa yang benar-benar tidak perlu Anda lakukan saat mengembangkan untuk OS baru</a></li>
<li><a href="../id463753/index.html">PVS-Studio Mengunjungi Apache Hive</a></li>
<li><a href="../id463755/index.html">Perbedaan antara "Juni", "Tengah" dan "Senior". Dan apa yang harus dilakukan untuk naik satu level</a></li>
<li><a href="../id463761/index.html">Kerangka kerja microservice PHP - Swoft</a></li>
<li><a href="../id463763/index.html">Sederhanakan migrasi dari OpenShift 3 ke OpenShift 4</a></li>
<li><a href="../id463765/index.html">Slurm DevOps: mengapa kita tidak akan membahas filosofi DevOps dan apa yang akan terjadi sebagai gantinya</a></li>
<li><a href="../id463769/index.html">Mitap Netologii ‚ÄúKarir dalam Ilmu Data: Dari Pemula hingga Menengah‚Äù</a></li>
<li><a href="../id463771/index.html">[Peter] Bertemu JUG.ru dengan Sebastian Dashner - Jadikan tes menulis perusahaan lebih menyenangkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>