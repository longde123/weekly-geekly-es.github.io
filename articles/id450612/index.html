<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€ğŸ­ ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ¼ ğŸ‘ˆğŸ¾ Intro Newton Protocol: apa yang bisa muat dalam 4 kilobyte ğŸ§™ğŸ½ ğŸ‘ ğŸ™‹ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya baru-baru ini berkompetisi dalam adegan demo Revisi 2019 dalam kategori intro PC 4k, dan intro saya memenangkan tempat pertama. Saya melakukan co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intro Newton Protocol: apa yang bisa muat dalam 4 kilobyte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450612/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfa/bba/a35/bfabbaa350d27446b3b058ce41e73228.png" alt="gambar"></div><br>  Saya baru-baru ini berkompetisi dalam adegan demo Revisi 2019 dalam kategori intro PC 4k, dan intro saya memenangkan tempat pertama.  Saya melakukan coding dan grafik, dan dixan menggubah musik.  Aturan dasar dari kompetisi ini adalah untuk membuat file atau situs web yang dapat dieksekusi yang hanya berukuran 4.096 byte.  Ini berarti bahwa segala sesuatu harus dihasilkan menggunakan matematika dan algoritma;  tidak ada cara lain yang bisa saya peras gambar, video dan audio ke dalam sejumlah kecil memori.  Pada artikel ini, saya akan berbicara tentang pipa render intro intro Newton saya.  Di bawah ini Anda dapat melihat hasil yang sudah selesai, atau <a href="">klik di sini</a> untuk melihat tampilannya langsung di Revisi, atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buka pouet</a> untuk berkomentar dan mengunduh intro yang berpartisipasi dalam kompetisi.  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membaca</a> tentang pekerjaan dan koreksi pesaing di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iIIu7kPCN-8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  Teknik bidang jarak pari Ray sangat populer dalam disiplin intro 4k karena memungkinkan Anda menentukan bentuk kompleks hanya dalam beberapa baris kode.  Namun, kelemahan dari pendekatan ini adalah kecepatan eksekusi.  Untuk membuat adegan, Anda perlu menemukan titik persimpangan sinar dengan adegan, pertama-tama tentukan apa yang Anda lihat, misalnya, sinar dari kamera, dan kemudian sinar berikutnya dari objek ke sumber cahaya untuk menghitung pencahayaan.  Saat bekerja dengan ray marching, persimpangan ini tidak dapat ditemukan dalam satu langkah, Anda perlu mengambil banyak langkah kecil di sepanjang balok dan mengevaluasi semua objek di setiap titik.  Di sisi lain, ketika menggunakan ray tracing, Anda dapat menemukan persimpangan yang tepat dengan memeriksa setiap objek hanya sekali, tetapi himpunan bentuk yang dapat digunakan sangat terbatas: Anda perlu memiliki rumus untuk setiap jenis untuk menghitung persimpangan dengan sinar. <br><br>  Dalam pengantar ini, saya ingin mensimulasikan pencahayaan yang sangat akurat.  Karena itu perlu untuk merefleksikan jutaan sinar di tempat kejadian, ray tracing tampaknya merupakan pilihan logis untuk mencapai efek ini.  Saya membatasi diri pada satu figur - bola, karena persimpangan sinar dan bola dihitung cukup sederhana.  Bahkan dinding di intro sebenarnya adalah bola yang sangat besar.  Selain itu, ini menyederhanakan simulasi fisika;  itu sudah cukup untuk memperhitungkan hanya konflik antar bidang. <br><br>  Untuk menggambarkan jumlah kode yang sesuai dengan 4096 byte, di bawah ini saya sajikan kode sumber lengkap dari intro yang sudah selesai.  Semua bagian kecuali HTML di bagian akhir dikodekan sebagai gambar PNG untuk mengkompresnya ke ukuran yang lebih kecil.  Tanpa kompresi ini, kode akan mengambil hampir 8900 byte.  Bagian yang disebut Synth adalah versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SoundBox</a> .  Untuk mengemas kode dalam format minimal ini, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Closure Compiler</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader Minifier</a> .  Pada akhirnya, hampir semuanya dikompres ke PNG menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JsExe</a> .  Pipa kompilasi lengkap dapat dilihat pada kode sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Core Kritis</a> 4k intro saya sebelumnya, karena sepenuhnya cocok dengan yang disajikan di sini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/274/690/e5b27469046c9c34bfb14fc2fbe33fa5.png"></div><br>  <i>Musik dan synthesizer sepenuhnya diimplementasikan dalam Javascript.</i>  <i>Bagian pada WebGL dibagi menjadi dua bagian (disorot dengan warna hijau dalam kode);</i>  <i>dia membuat pipa render.</i>  <i>Fisika dan elemen pelacak sinar adalah pembagi GLSL.</i>  <i>Sisa kode dikodekan dalam gambar PNG, dan HTML ditambahkan ke akhir gambar yang dihasilkan tidak berubah.</i>  <i>Browser mengabaikan data gambar dan hanya mengeksekusi kode HTML, yang pada gilirannya menerjemahkan PNG kembali ke javascript dan mengeksekusinya.</i> <br><br><h3>  Rendering pipeline </h3><br>  Gambar di bawah ini menunjukkan saluran rendering.  Ini terdiri dari dua bagian.  Bagian pertama dari pipa adalah simulator fisika.  Adegan intro berisi 50 bola bertabrakan satu sama lain di dalam ruangan.  Ruangan itu sendiri terdiri dari enam bola, beberapa di antaranya lebih kecil dari yang lain untuk membuat dinding lebih melengkung.  Dua sumber iluminasi vertikal di sudut-sudut juga merupakan bola, yaitu total 58 bola di TKP.  Bagian kedua dari pipa adalah pelacak sinar, yang membuat adegan.  Diagram di bawah ini menunjukkan rendering satu frame pada waktu t.  Simulasi fisika mengambil bingkai sebelumnya (t-1) dan mensimulasikan keadaan saat ini.  Pelacak ray mengambil posisi saat ini dan posisi frame sebelumnya (untuk saluran kecepatan) dan membuat adegan.  Kemudian post-processing menggabungkan 5 frame sebelumnya dan frame saat ini untuk mengurangi distorsi dan kebisingan, dan kemudian menciptakan hasil akhir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6a/848/ac0/f6a848ac09343ca15abfd03393a7ceeb.png"></div><br>  <i>Merender bingkai pada waktu t.</i> <br><br>  Bagian fisiknya cukup sederhana, di Internet Anda bisa menemukan banyak tutorial tentang cara membuat simulasi primitif untuk bola.  Posisi, jari-jari, kecepatan, dan massa disimpan dalam dua tekstur dengan resolusi 1 x 58. Saya menggunakan fungsionalitas Webgl 2, yang memungkinkan rendering ke beberapa target render, sehingga data dua tekstur direkam secara bersamaan.  Fungsionalitas yang sama digunakan oleh pelacak ray untuk membuat tiga tekstur.  Webgl tidak menyediakan akses apa pun ke tracing API pelacakan sinar NVidia RTX atau DirectX Raytracing (DXR), jadi semuanya dilakukan dari awal. <br><br><h3>  Ray tracer </h3><br>  Ray tracing sendiri adalah teknik yang cukup primitif.  Kami melepaskan sinar ke dalam pemandangan, itu dipantulkan 4 kali, dan jika masuk ke sumber cahaya, warna pantulan menumpuk;  kalau tidak, kita jadi hitam.  Pada 4096 byte (yang meliputi musik, synthesizer, fisika, dan rendering) tidak ada ruang untuk membuat struktur pelacak ray akselerasi yang kompleks.  Oleh karena itu, kami menggunakan metode brute-force, yaitu, kami memeriksa semua 57 bola (dinding depan tidak termasuk) untuk setiap sinar, tanpa membuat optimasi untuk mengecualikan bagian dari bola.  Ini berarti bahwa untuk memberikan 60 frame per detik dalam resolusi 1080p, Anda hanya dapat memancarkan 2-6 sinar, atau sampel per piksel.  Ini cukup dekat untuk membuat pencahayaan yang halus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b23/2ce/72d/b232ce72d49f57a69b96d402ec0bb148.png"></div><br>  <i>1 sampel per piksel.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e52/77d/19e/e5277d19e5a7b897b8dd9046eaae6f26.png"></div><br>  <i>6 sampel per piksel.</i> <br><br>  Bagaimana cara mengatasinya?  Pada awalnya saya menyelidiki algoritma ray tracing, tetapi sudah disederhanakan ke titik.  Saya berhasil sedikit meningkatkan kinerja dengan menghilangkan kasus ketika sinar mulai di dalam bola, karena kasus seperti itu hanya berlaku di hadapan efek transparansi, dan hanya objek buram hadir dalam adegan kami.  Setelah itu, saya menggabungkan masing-masing kondisi jika menjadi pernyataan terpisah untuk menghindari percabangan yang tidak perlu: meskipun perhitungan "berlebihan", pendekatan ini masih lebih cepat daripada sekelompok pernyataan kondisional.  Anda juga dapat meningkatkan pola pengambilan sampel: alih-alih memancarkan sinar secara acak, kami dapat mendistribusikannya di seluruh tempat dengan pola yang lebih rata.  Sayangnya, ini tidak membantu dan menyebabkan artefak bergelombang di setiap algoritma yang saya coba.  Namun, pendekatan ini menciptakan hasil yang bagus untuk gambar foto.  Akibatnya, saya kembali menggunakan distribusi yang sepenuhnya acak. <br><br>  Piksel tetangga harus memiliki pencahayaan yang sangat mirip, jadi mengapa tidak menggunakannya saat menghitung pencahayaan satu piksel?  Kami tidak ingin mengaburkan tekstur, hanya pencahayaan, jadi kami perlu merendernya di saluran yang terpisah.  Kami juga tidak ingin mengaburkan objek, jadi kami harus memperhitungkan pengidentifikasi objek untuk mengetahui piksel mana yang dapat dengan mudah dikaburkan.  Karena kita memiliki objek yang memantulkan cahaya dan kita membutuhkan pantulan yang jelas, tidak cukup hanya dengan mengetahui ID dari objek pertama yang bertabrakan dengan balok.  Saya menggunakan kasus khusus untuk bahan reflektif murni untuk juga memasukkan ID dari objek pertama dan kedua yang terlihat dalam refleksi di saluran pengidentifikasi objek.  Dalam hal ini, kabur dapat menghaluskan pencahayaan pada objek dalam pantulan, sementara pada saat yang sama mempertahankan batas-batas objek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/a24/a6b/f69a24a6b9094903309af27b5606e923.png"></div><br>  <i>Saluran tekstur, kami tidak perlu mengaburkannya.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/c4a/7f6/a4fc4a7f6ec4fa0552542edf7204cb58.png"></div><br>  <i>Di sini, di saluran merah berisi ID dari objek pertama, hijau - kedua, dan biru - ketiga.</i>  <i>Dalam praktiknya, mereka semua dikodekan ke dalam nilai float tunggal, di mana bagian integer menyimpan pengidentifikasi objek, dan yang fraksional menunjukkan kekasaran: 332211.RR.</i> <br><br>  Karena ada objek dengan kekasaran yang berbeda dalam adegan (beberapa area kasar, cahaya tersebar pada yang lain, di ketiga ada pantulan cermin), saya menyimpan kekasaran untuk mengontrol jari-jari blur.  Tidak ada detail kecil dalam adegan, jadi saya menggunakan inti 50 x 50 besar dengan bobot dalam bentuk kuadrat terbalik untuk kabur.  Ini tidak memperhitungkan ruang dunia (ini bisa direalisasikan untuk mendapatkan hasil yang lebih akurat), karena pada permukaan yang terletak pada sudut di beberapa arah, itu mengikis area yang lebih besar.  Pengaburan seperti itu menciptakan gambar yang cukup halus, tetapi artefak terlihat jelas, terutama dalam gerakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/553/f9d/ca6553f9d61bc8f7dda51ba41c2cbf28.png"></div><br>  <i>Saluran pencahayaan dengan artefak yang kabur dan masih terlihat.</i>  <i>Dalam gambar ini, titik-titik buram di dinding belakang terlihat, yang disebabkan oleh bug kecil dengan pengidentifikasi objek yang dipantulkan kedua (sinar meninggalkan tempat kejadian).</i>  <i>Pada gambar yang sudah jadi, ini tidak terlalu terlihat, karena pantulan yang jelas diambil dari saluran tekstur.</i>  <i>Sumber pencahayaan juga menjadi buram, tetapi saya menyukai efek ini dan saya meninggalkannya.</i>  <i>Jika diinginkan, ini dapat dicegah dengan mengubah pengidentifikasi objek tergantung pada materi.</i> <br><br>  Saat objek berada dalam adegan dan kamera yang memotret adegan bergerak perlahan, pencahayaan di setiap frame harus tetap konstan.  Oleh karena itu, kita dapat melakukan blur tidak hanya pada koordinat XY layar;  kita bisa kabur dalam waktu.  Jika kita berasumsi bahwa pencahayaan tidak berubah terlalu banyak dalam 100 ms, kita dapat rata-rata untuk 6 frame.  Tetapi selama jendela waktu ini, objek dan kamera akan tetap agak jauh, sehingga perhitungan sederhana dari rata-rata untuk 6 frame akan menghasilkan gambar yang sangat buram.  Namun, kami tahu di mana semua objek dan kamera berada di peta sebelumnya, sehingga kami dapat menghitung vektor kecepatan di ruang layar.  Ini disebut proyeksi ulang sementara.  Jika saya memiliki piksel pada waktu t, maka saya dapat mengambil kecepatan piksel itu dan menghitung di mana itu pada waktu t-1, dan kemudian menghitung di mana piksel pada waktu t-1 pada waktu t-2, dan seterusnya. 5 frame kembali.  Tidak seperti ruang layar yang buram, saya menggunakan bobot yang sama untuk setiap bingkai, mis.  hanya rata-rata warna antara semua frame untuk "blur" sementara. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fc/a4c/e42/1fca4ce4250f372223862a34472add21.png"></div><br>  <i>Saluran kecepatan piksel yang melaporkan di mana piksel berada di bingkai terakhir berdasarkan pergerakan objek dan kamera.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/011/bb5/1f6/011bb51f60e3b3066c87ee4a1d46d403.png"></div><br>  <i>Untuk menghindari keburaman bersama dari objek, kita akan kembali menggunakan saluran pengidentifikasi objek.</i>  <i>Dalam hal ini, kami hanya mempertimbangkan objek pertama yang bertabrakan dengan balok.</i>  <i>Ini memberikan anti-aliasing di dalam objek, mis.</i>  <i>dalam refleksi.</i> <br><br>  Tentu saja, pikselnya mungkin tidak terlihat di bingkai sebelumnya;  itu bisa disembunyikan oleh objek lain atau berada di luar bidang pandang kamera.  Dalam kasus seperti itu, kami tidak dapat menggunakan informasi sebelumnya.  Pemeriksaan ini dilakukan secara terpisah untuk setiap frame, jadi kami dapatkan dari 1 hingga 6 sampel atau frame per piksel, dan gunakan yang mungkin.  Gambar di bawah ini menunjukkan bahwa untuk benda lambat ini bukan masalah yang sangat serius. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5b/c89/8fc/c5bc898fc8ac6ff9b5a0c8685312604f.png"></div><br>  <i>Ketika objek bergerak dan membuka bagian baru dari pemandangan, kami tidak memiliki 6 bingkai informasi untuk rata-rata untuk bagian ini.</i>  <i>Gambar ini menunjukkan area yang memiliki 6 bingkai (putih), serta yang tidak memilikinya (gradasi yang gelap secara bertahap).</i>  <i>Munculnya kontur disebabkan oleh pengacakan lokasi pengambilan sampel untuk piksel di setiap bingkai dan fakta bahwa kami mengambil pengidentifikasi objek dari sampel pertama.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/570/c4c/b4a/570c4cb4a84f008a497678b0b735930e.png"></div><br>  <i>Pencahayaan kabur rata-rata lebih dari enam frame.</i>  <i>Artefak hampir tidak terlihat dan hasilnya stabil dari waktu ke waktu, karena di setiap frame hanya satu frame dari enam perubahan di mana pencahayaan diperhitungkan.</i> <br><br>  Menggabungkan semua ini, kita mendapatkan gambar yang sudah jadi.  Pencahayaan buram ke piksel tetangga, sementara tekstur dan pantulan tetap jelas.  Kemudian semua ini dirata-rata antara enam frame untuk membuat gambar yang lebih halus dan lebih stabil dari waktu ke waktu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfa/bba/a35/bfabbaa350d27446b3b058ce41e73228.png"></div><br>  <i>Gambar yang sudah jadi.</i> <br><br>  Artefak redaman masih terlihat, karena saya rata-rata beberapa sampel per piksel, meskipun saya mengambil saluran pengidentifikasi objek dan kecepatan untuk persimpangan pertama.  Anda dapat mencoba memperbaikinya dan merapikan pantulan dengan membuang sampel jika tidak sesuai dengan yang pertama, atau setidaknya jika tabrakan pertama tidak bersamaan.  Dalam prakteknya, jejaknya hampir tidak terlihat, jadi saya tidak repot-repot menghilangkannya.  Batas-batas objek juga terdistorsi, karena saluran kecepatan dan pengidentifikasi objek tidak dapat dihaluskan.  Saya sedang mempertimbangkan kemungkinan rendering seluruh gambar pada 2160p dengan pengurangan skala lebih lanjut menjadi 1080p, tetapi NVidia GTX 980ti saya tidak mampu memproses resolusi seperti itu pada 60fps, jadi saya memutuskan untuk meninggalkan ide ini. <br><br>  Secara umum, saya sangat senang dengan bagaimana intro itu ternyata.  Saya berhasil memeras segala yang ada dalam pikiran saya, dan meskipun ada sedikit bug, hasil akhirnya adalah kualitas yang sangat tinggi.  Di masa mendatang, Anda dapat mencoba memperbaiki bug dan meningkatkan anti-aliasing.  Layak juga bereksperimen dengan fitur-fitur seperti transparansi, blur gerakan, berbagai bentuk dan transformasi objek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba9/f56/e02/ba9f56e02c13d046f73e888540a0d75e.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450612/">https://habr.com/ru/post/id450612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450602/index.html">"Bagaimana Kita Membangun IaaS": 1 bahan keras</a></li>
<li><a href="../id450604/index.html">Memilah miliaran angka sederhana lebih cepat dari Wikipedia</a></li>
<li><a href="../id450606/index.html">Suatu hari dalam kehidupan seorang model restoran</a></li>
<li><a href="../id450608/index.html">Bercinta di antara kita</a></li>
<li><a href="../id450610/index.html">Termoacoustics. Menghasilkan listrik dari suara menggunakan speaker</a></li>
<li><a href="../id450614/index.html">April 2019 Joomla Intisari</a></li>
<li><a href="../id450618/index.html">Mengapa, menurut statistik dari Yandex dan StackOverfow C #, apakah programmer paling murah?</a></li>
<li><a href="../id450620/index.html">Teka-teki neutrino dari Supernova 1987A</a></li>
<li><a href="../id450624/index.html">Salut dari Hayabusa-2</a></li>
<li><a href="../id450626/index.html">Perbaiki pola desain - Singleton dalam PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>