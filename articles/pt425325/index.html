<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèº üìü üëßüèΩ Int√©rpretes de Bytecode DIY üë©üèø‚Äçü§ù‚Äçüë®üèΩ üíê üåï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="M√°quinas virtuais de linguagens de programa√ß√£o se tornaram muito difundidas nas √∫ltimas d√©cadas. Muito tempo se passou desde a apresenta√ß√£o da Java Vi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Int√©rpretes de Bytecode DIY</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/425325/"><p><img src="https://habrastorage.org/webt/aa/zv/cl/aazvcl84q5xly1zkqhtxelkemju.png"></p><br><p>  M√°quinas virtuais de linguagens de programa√ß√£o se tornaram muito difundidas nas √∫ltimas d√©cadas.  Muito tempo se passou desde a apresenta√ß√£o da Java Virtual Machine na segunda metade dos anos 90, e √© seguro dizer que os int√©rpretes de c√≥digo de bytes n√£o s√£o o futuro, mas o presente. </p><br><p>  Mas essa t√©cnica, na minha opini√£o, √© quase universal, e o entendimento dos princ√≠pios b√°sicos do desenvolvimento de int√©rpretes √© √∫til n√£o apenas para o criador do pr√≥ximo desafiante do t√≠tulo "Linguagem do Ano" de acordo com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TIOBE</a> , mas para qualquer programador em geral. </p><br><p>  Em uma palavra, se voc√™ estiver interessado em aprender como nossas linguagens de programa√ß√£o favoritas somam n√∫meros, sobre o que os desenvolvedores de m√°quinas virtuais ainda est√£o discutindo e sobre como combinar strings e express√µes regulares sem problemas, pe√ßo cat. </p><a name="habracut"></a><br><p>  Parte um, introdut√≥ria (atual) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte Dois, Otimizando</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte Tr√™s, Aplicada</a> </p><br><h1 id="predystoriya">  Antecedentes </h1><br><p>  Um dos sistemas auto-escritos do departamento de Business Intelligence da nossa empresa possui uma interface na forma de uma linguagem de consulta simples.  Na primeira vers√£o do sistema, esse idioma foi interpretado em tempo real, sem compila√ß√£o, diretamente da linha de entrada com a solicita√ß√£o.  A segunda vers√£o do analisador j√° funcionar√° com bytecode intermedi√°rio, o que permitir√° que voc√™ separe o idioma da consulta da execu√ß√£o deles e simplifique bastante o c√≥digo. </p><br><p> No processo de trabalhar na segunda vers√£o do sistema, tive f√©rias durante as quais, durante uma ou duas horas todos os dias, me distra√≠ dos assuntos da fam√≠lia para estudar materiais sobre a arquitetura e o desempenho dos int√©rpretes de bytecode.  Decidi compartilhar as notas e exemplos de int√©rpretes resultantes com os leitores de Habr como uma s√©rie de artigos. </p><br><p>  O primeiro deles apresenta cinco m√°quinas virtuais pequenas (at√© centenas de linhas de c√≥digo C simples), cada uma das quais revela um certo aspecto do desenvolvimento de tais int√©rpretes. </p><br><h1 id="otkuda-est-poshli-bayt-kody-v-yazykah-programmirovaniya">  Para onde foram os c√≥digos de bytes nas linguagens de programa√ß√£o? </h1><br><p>  Muitas m√°quinas virtuais, os mais diversos conjuntos de instru√ß√µes virtuais nas √∫ltimas d√©cadas, foram inventados.  A Wikipedia afirma que as primeiras linguagens de programa√ß√£o come√ßaram a se compilar em v√°rias representa√ß√µes intermedi√°rias simplificadas nos anos 60 do s√©culo passado.  Alguns desses c√≥digos de primeiro byte foram convertidos em c√≥digos de m√°quina e executados por processadores reais, enquanto outros foram interpretados em tempo real por processadores virtuais. </p><br><p>  A popularidade dos conjuntos de instru√ß√µes virtuais como uma representa√ß√£o intermedi√°ria do c√≥digo se deve a tr√™s raz√µes: </p><br><ol><li>  Os programas de bytecode s√£o facilmente portados para novas plataformas. </li><li>  Os int√©rpretes de bytecode s√£o mais r√°pidos que os int√©rpretes da √°rvore de c√≥digo da sintaxe. </li><li>  Voc√™ pode desenvolver uma m√°quina virtual simples em apenas algumas horas. </li></ol><br><p>  Vamos criar algumas m√°quinas virtuais C simples e usar esses exemplos para destacar os principais aspectos t√©cnicos da implementa√ß√£o de m√°quinas virtuais. </p><br><p>  C√≥digos de amostra completos est√£o dispon√≠veis no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Exemplos podem ser compilados com qualquer GCC relativamente recente: </p><br><pre><code class="plaintext hljs">gcc interpreter-basic-switch.c -o interpreter ./interpreter</code> </pre> <br><p>  Todos os exemplos t√™m a mesma estrutura: primeiro vem o c√≥digo da pr√≥pria m√°quina virtual, depois a fun√ß√£o principal com asser√ß√µes que verificam a opera√ß√£o do c√≥digo.  Tentei comentar claramente os c√≥digos de opera√ß√£o e os principais locais dos int√©rpretes.  Espero que este artigo seja compreens√≠vel at√© para as pessoas que n√£o escrevem em C diariamente. </p><br><h1 id="samyy-prostoy-v-mire-interpretator-bayt-koda">  O interpretador de bytecodes mais f√°cil do mundo </h1><br><p>  Como eu disse, o int√©rprete mais simples √© muito f√°cil de fazer.  Os coment√°rios est√£o logo atr√°s da lista, mas vamos come√ßar diretamente com o c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Existem menos de cem linhas, mas todos os atributos caracter√≠sticos de uma m√°quina virtual s√£o representados.  A m√°quina possui um √∫nico registro ( <code>vm.accumulator</code> ), tr√™s opera√ß√µes (incremento do registro, decremento do registro e conclus√£o da execu√ß√£o do programa) e um ponteiro para a instru√ß√£o atual ( <code>vm.ip</code> ). </p><br><p>  Cada opera√ß√£o (por exemplo, <em>c√≥digo de</em> <em>opera√ß√£o</em> ou <em>opcode</em> ) √© codificada com um byte e o agendamento √© realizado usando a <code>switch</code> usual na fun√ß√£o <code>vm_interpret</code> .  As ramifica√ß√µes no <code>switch</code> cont√™m a l√≥gica das opera√ß√µes, ou seja, elas alteram o estado do registro ou encerram a execu√ß√£o do programa. </p><br><p>  As opera√ß√µes s√£o transferidas para a fun√ß√£o <code>vm_interpret</code> na forma de uma matriz de bytes - um bytecode (Eng. <em>Bytecode</em> ) - e s√£o executadas sequencialmente at√© que a opera√ß√£o de <code>OP_DONE</code> m√°quina virtual ( <code>OP_DONE</code> ) seja <code>OP_DONE</code> . </p><br><p>  Um aspecto fundamental de uma m√°quina virtual √© a sem√¢ntica, ou seja, o conjunto de opera√ß√µes que s√£o poss√≠veis nela.  Nesse caso, existem apenas duas opera√ß√µes e elas alteram o valor de um √∫nico registro. </p><br><p>  Alguns pesquisadores ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">T√©cnicas de Abstra√ß√£o e Otimiza√ß√£o de M√°quinas Virtuais</a> , 2009) prop√µem a divis√£o de m√°quinas virtuais em m√°quinas de <em>alto</em> e <em>baixo n√≠vel, de</em> acordo com a proximidade da sem√¢ntica da m√°quina virtual com a sem√¢ntica da m√°quina f√≠sica na qual o bytecode ser√° executado. </p><br><p>  No caso extremo, o bytecode de m√°quinas virtuais de baixo n√≠vel pode repetir completamente o c√≥digo da m√°quina f√≠sica com RAM simulada, um conjunto completo de registros, instru√ß√µes para trabalhar com a pilha e assim por diante.  A m√°quina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bochs</a> , por exemplo, repete o conjunto de instru√ß√µes da arquitetura x86. </p><br><p>  E vice-versa: as opera√ß√µes de m√°quinas virtuais de alto n√≠vel refletem de perto a sem√¢ntica de uma linguagem de programa√ß√£o especializada compilada no bytecode.  Ent√£o trabalhe, por exemplo, SQLite, Gawk e v√°rias vers√µes do Prolog. </p><br><p>  As posi√ß√µes intermedi√°rias s√£o ocupadas por int√©rpretes de linguagens de programa√ß√£o de uso geral, com elementos de n√≠veis alto e baixo.  A Java Virtual Machine mais popular possui instru√ß√µes de baixo n√≠vel para trabalhar com a pilha e suporte interno para programa√ß√£o orientada a objetos com aloca√ß√£o autom√°tica de mem√≥ria. </p><br><p>  √â mais prov√°vel que o c√≥digo acima seja a mais primitiva das m√°quinas virtuais de baixo n√≠vel: cada instru√ß√£o virtual √© um inv√≥lucro com uma ou duas instru√ß√µes f√≠sicas, o registro virtual √© totalmente consistente com um registro do processador "iron". </p><br><h1 id="argumenty-instrukciy-v-bayt-kode">  Argumentos de instru√ß√£o de bytecode </h1><br><p>  Podemos dizer que o √∫nico registro em nosso exemplo de m√°quina virtual √© um argumento e o valor de retorno de todas as instru√ß√µes executadas.  No entanto, podemos achar √∫til passar argumentos nas instru√ß√µes.  Uma maneira √© coloc√°-los diretamente no bytecode. </p><br><p>  Expandiremos o exemplo introduzindo instru√ß√µes (OP_ADDI, OP_SUBI) que recebem um argumento na forma de um byte imediatamente ap√≥s o c√≥digo de opera√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* add the immediate argument to the register */</span></span> OP_ADDI, <span class="hljs-comment"><span class="hljs-comment">/* subtract the immediate argument from the register */</span></span> OP_SUBI, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator += arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_SUBI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator -= arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Novas instru√ß√µes (consulte a fun√ß√£o <code>vm_interpret</code> ) leem seu argumento do bytecode e o adicionam ao registro / subtraem-no do registro. </p><br><p>  Esse argumento √© chamado de <em>argumento imediato</em> , porque est√° localizado diretamente na matriz opcode.  A principal limita√ß√£o em nossa implementa√ß√£o √© que o argumento √© um byte √∫nico e pode levar apenas 256 valores. </p><br><p>  Em nossa m√°quina virtual, o intervalo de poss√≠veis valores de argumentos de instru√ß√µes n√£o desempenha um grande papel.  Mas se a m√°quina virtual for usada como int√©rprete da linguagem real, faz sentido complicar o bytecode adicionando uma tabela de constantes separada da matriz de opcodes e instru√ß√µes com um argumento direto correspondente ao endere√ßo desse argumento na tabela de constantes. </p><br><h1 id="stekovaya-mashina">  M√°quina de empilhar </h1><br><p>  As instru√ß√µes em nossa m√°quina virtual simples sempre funcionam com um registro e n√£o podem transmitir dados entre si de forma alguma.  Al√©m disso, o argumento para a instru√ß√£o s√≥ pode ser imediato e, digamos, a opera√ß√£o de adi√ß√£o ou multiplica√ß√£o leva dois argumentos. </p><br><p>  Simplificando, n√£o temos como avaliar express√µes complexas.  Para resolver esse problema, √© necess√°ria uma m√°quina empilhada, ou seja, uma m√°quina virtual com uma pilha integrada: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STACK_MAX 256 struct { uint8_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Fixed-size stack */</span></span></span><span class="hljs-meta"> uint64_t stack[STACK_MAX]; uint64_t *stack_top; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* push the immediate argument onto the stack */</span></span></span><span class="hljs-meta"> OP_PUSHI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, add and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, subtract and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, divide and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, multiply and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop the top of the stack and set it as execution result */</span></span></span><span class="hljs-meta"> OP_POP_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; vm.stack_top = vm.stack; } void vm_stack_push(uint64_t value) { *vm.stack_top = value; vm.stack_top++; } uint64_t vm_stack_pop(void) { vm.stack_top--; return *vm.stack_top; } interpret_result vm_interpret(uint8_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; for (;;) { uint8_t instruction = *vm.ip++; switch (instruction) { case OP_PUSHI: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span></span><span class="hljs-meta"> uint8_t arg = *vm.ip++; vm_stack_push(arg); break; } case OP_ADD: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left + arg_right; vm_stack_push(res); break; } case OP_SUB: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, subtract 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left - arg_right; vm_stack_push(res); break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, divide 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arg_right == 0) return ERROR_DIVISION_BY_ZERO; uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left / arg_right; vm_stack_push(res); break; } case OP_MUL: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, multiply 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left * arg_right; vm_stack_push(res); break; } case OP_POP_RES: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop the top of the stack, set it as a result value */</span></span></span><span class="hljs-meta"> uint64_t res = vm_stack_pop(); vm.result = res; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  Neste exemplo, j√° existem mais opera√ß√µes e quase todas funcionam apenas com a pilha.  OP_PUSHI coloca seu argumento imediato na pilha.  As instru√ß√µes OP_ADD, OP_SUB, OP_DIV, OP_MUL s√£o exibidas de uma pilha de valores, calculam o resultado e empurram-no de volta para a pilha.  OP_POP_RES remove o valor da pilha e o coloca no registro de resultados, destinado aos resultados da m√°quina virtual. </p><br><p>  Para a opera√ß√£o de divis√£o (OP_DIV), um erro de divis√£o por zero √© capturado, o que para a m√°quina virtual. </p><br><p>  As capacidades dessa m√°quina s√£o muito mais amplas do que a anterior com um √∫nico registro e permitem, por exemplo, calcular express√µes aritm√©ticas complexas.  Outra vantagem (e importante!) √â a simplicidade de compilar linguagens de programa√ß√£o no c√≥digo de bytes da m√°quina de empilhamento. </p><br><h1 id="registrovaya-mashina">  Registrar m√°quina </h1><br><p>  Devido √† sua simplicidade, as m√°quinas virtuais empilhadas s√£o mais amplamente usadas entre os desenvolvedores de linguagens de programa√ß√£o;  as mesmas VMs JVMs e Python as usam exatamente. </p><br><p>  No entanto, essas m√°quinas t√™m desvantagens: elas precisam adicionar instru√ß√µes especiais para trabalhar com a pilha; ao calcular express√µes, todos os argumentos passam repetidamente por uma √∫nica estrutura de dados; muitas instru√ß√µes extras aparecer√£o inevitavelmente no c√≥digo da pilha. </p><br><p>  Enquanto isso, a execu√ß√£o de cada instru√ß√£o extra implica o custo da programa√ß√£o, isto √©, decodificar o c√≥digo de opera√ß√£o e mudar para o corpo das instru√ß√µes. </p><br><p>  Uma alternativa para m√°quinas empilhadas √© registrar m√°quinas virtuais.  Eles t√™m um bytecode mais complexo: o n√∫mero de argumentos do registro e o n√∫mero do resultado do registro s√£o codificados explicitamente em cada instru√ß√£o.  Portanto, em vez de uma pilha, um conjunto estendido de registros √© usado como armazenamento de valores intermedi√°rios. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REGISTER_NUM 16 struct { uint16_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Register array */</span></span></span><span class="hljs-meta"> uint64_t reg[REGISTER_NUM]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Load an immediate value into r0 */</span></span></span><span class="hljs-meta"> OP_LOADI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Add values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Subtract values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Divide values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Multiply values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Move a value from r0 register into the result register */</span></span></span><span class="hljs-meta"> OP_MOV_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; } void decode(uint16_t instruction, uint8_t *op, uint8_t *reg0, uint8_t *reg1, uint8_t *reg2, uint8_t *imm) { *op = (instruction &amp; 0xF000) &gt;&gt; 12; *reg0 = (instruction &amp; 0x0F00) &gt;&gt; 8; *reg1 = (instruction &amp; 0x00F0) &gt;&gt; 4; *reg2 = (instruction &amp; 0x000F); *imm = (instruction &amp; 0x00FF); } interpret_result vm_interpret(uint16_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; uint8_t op, r0, r1, r2, immediate; for (;;) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* fetch the instruction */</span></span></span><span class="hljs-meta"> uint16_t instruction = *vm.ip++; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* decode it */</span></span></span><span class="hljs-meta"> decode(instruction, &amp;op, &amp;r0, &amp;r1, &amp;r2, &amp;immediate); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* dispatch */</span></span></span><span class="hljs-meta"> switch (op) { case OP_LOADI: { vm.reg[r0] = immediate; break; } case OP_ADD: { vm.reg[r2] = vm.reg[r0] + vm.reg[r1]; break; } case OP_SUB: { vm.reg[r2] = vm.reg[r0] - vm.reg[r1]; break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (vm.reg[r1] == 0) return ERROR_DIVISION_BY_ZERO; vm.reg[r2] = vm.reg[r0] / vm.reg[r1]; break; } case OP_MUL: { vm.reg[r2] = vm.reg[r0] * vm.reg[r1]; break; } case OP_MOV_RES: { vm.result = vm.reg[r0]; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  O exemplo mostra uma m√°quina de registro com 16 registros.  As instru√ß√µes ocupam 16 bits cada e s√£o codificadas de tr√™s maneiras: </p><br><ol><li>  4 bits por c√≥digo de opera√ß√£o + 4 bits por nome de registro + 8 bits por argumento. </li><li>  4 bits por c√≥digo de opera√ß√£o + tr√™s vezes 4 bits por nomes de registro. </li><li>  4 bits por c√≥digo de opera√ß√£o + 4 bits por nome de registro √∫nico + 8 bits n√£o utilizados. </li></ol><br><p>  Nossa pequena m√°quina virtual possui muito poucas opera√ß√µes, portanto, quatro bits (ou 16 opera√ß√µes poss√≠veis) por c√≥digo de opera√ß√£o s√£o suficientes.  A opera√ß√£o determina o que exatamente os bits restantes da instru√ß√£o representam. </p><br><p>  O primeiro tipo de codifica√ß√£o (4 + 4 + 8) √© necess√°rio para carregar dados nos registradores com a opera√ß√£o OP_LOADI.  O segundo tipo (4 + 4 + 4 + 4) √© usado para opera√ß√µes aritm√©ticas, que devem saber onde levar um par de argumentos e onde adicionar o resultado do c√°lculo.  E finalmente, a √∫ltima forma (4 + 4 + 8 bits desnecess√°rios) √© usada para instru√ß√µes com um √∫nico registro como argumento, no nosso caso √© OP_MOV_RES. </p><br><p>  Para codificar e decodificar instru√ß√µes, agora precisamos de l√≥gica especial (fun√ß√£o de <code>decode</code> ).  Por outro lado, a l√≥gica das instru√ß√µes, gra√ßas √† indica√ß√£o expl√≠cita da localiza√ß√£o dos argumentos, fica mais f√°cil - as opera√ß√µes com a pilha desaparecem. </p><br><p>  Recursos principais: no bytecode das m√°quinas de registro, h√° menos instru√ß√µes, instru√ß√µes individuais s√£o mais amplas, a compila√ß√£o nesse bytecode √© mais dif√≠cil - o compilador precisa decidir como usar os registros dispon√≠veis. </p><br><p>  Deve-se notar que, na pr√°tica, no registro de m√°quinas virtuais, geralmente h√° uma pilha em que, por exemplo, argumentos de fun√ß√£o s√£o colocados;  registradores s√£o usados ‚Äã‚Äãpara calcular express√µes individuais.  Mesmo se n√£o houver pilha expl√≠cita, uma matriz √© usada para construir a pilha, desempenhando o mesmo papel que a RAM em m√°quinas f√≠sicas. </p><br><h1 id="stekovye-i-registrovye-mashiny-sravnenie">  M√°quinas de empilhar e registrar, compara√ß√£o </h1><br><p>  H√° um estudo interessante ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confronta√ß√£o de m√°quinas virtuais: Stack versus registradores</a> , 2008) que teve uma grande influ√™ncia em todos os desenvolvimentos subsequentes no campo de m√°quinas virtuais para linguagens de programa√ß√£o.  Seus autores propuseram um m√©todo de tradu√ß√£o direta do c√≥digo de pilha de uma JVM padr√£o para um c√≥digo de registro e compararam o desempenho. </p><br><p>  O m√©todo n√£o √© trivial: o c√≥digo √© primeiro traduzido e depois otimizado de uma maneira bastante complicada.  Por√©m, uma compara√ß√£o subsequente do desempenho do mesmo programa mostrou que os ciclos adicionais do processador gastos em instru√ß√µes de decodifica√ß√£o s√£o totalmente compensados ‚Äã‚Äãpor uma diminui√ß√£o no n√∫mero total de instru√ß√µes.  Em geral, em resumo, a m√°quina registradora era mais eficiente que a pilha. </p><br><p>  Como j√° mencionado acima, essa efici√™ncia tem um pre√ßo bastante tang√≠vel: o compilador deve alocar os pr√≥prios registros e um otimizador avan√ßado √© adicionalmente desej√°vel. </p><br><p>  O debate sobre qual arquitetura √© melhor ainda n√£o acabou.  Se falamos de compiladores Java, o bytecode da Dalvik VM, que at√© recentemente funcionava em todos os dispositivos Android, era registrado;  mas o t√≠tulo JVM manteve uma pilha de instru√ß√µes.  A m√°quina virtual Lua usa uma m√°quina de registro, mas a VM Python ainda √© empilh√°vel.  E assim por diante </p><br><h1 id="bayt-kod-v-interpretatorah-regulyarnyh-vyrazheniy">  Bytecode em int√©rpretes de express√£o regular </h1><br><p>  Por fim, para nos distrair das m√°quinas virtuais de baixo n√≠vel, vejamos um int√©rprete especializado que verifica as seq√º√™ncias de caracteres quanto √† correspond√™ncia de express√µes regulares: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* match a single char to an immediate argument from the string and advance ip and cp, or * abort*/</span></span> OP_CHAR, <span class="hljs-comment"><span class="hljs-comment">/* jump to and match either left expression or the right one, abort if nothing matches*/</span></span> OP_OR, <span class="hljs-comment"><span class="hljs-comment">/* do an absolute jump to an offset in the immediate argument */</span></span> OP_JUMP, <span class="hljs-comment"><span class="hljs-comment">/* stop execution and report a successful match */</span></span> OP_MATCH, } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { MATCH_OK, MATCH_FAIL, MATCH_ERROR, } match_result; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match_recur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *sp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_CHAR:{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cur_c = *sp; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> arg_c = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*ip ; <span class="hljs-comment"><span class="hljs-comment">/* no match? FAILed to match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg_c != cur_c) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_FAIL; <span class="hljs-comment"><span class="hljs-comment">/* advance both current instruction and character pointers */</span></span> ip++; sp++; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JUMP:{ <span class="hljs-comment"><span class="hljs-comment">/* read the offset and jump to the instruction */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> offset = *ip; ip = bytecode + offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_OR:{ <span class="hljs-comment"><span class="hljs-comment">/* get both branch offsets */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> left_offset = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> right_offset = *ip; <span class="hljs-comment"><span class="hljs-comment">/* check if following the first offset get a match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *left_ip = bytecode + left_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vm_match_recur(bytecode, left_ip, sp) == MATCH_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; <span class="hljs-comment"><span class="hljs-comment">/* no match? Check the second branch */</span></span> ip = bytecode + right_offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_MATCH:{ <span class="hljs-comment"><span class="hljs-comment">/* success */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_ERROR; } } <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Start matching a string: %s\n"</span></span>, str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vm_match_recur(bytecode, bytecode, str); }</code> </pre><br><p>  A instru√ß√£o principal √© OP_CHAR.  Ela pega seu argumento imediato e o compara com o caractere atual na string ( <code>char *sp</code> ).  Em caso de coincid√™ncia dos caracteres esperados e atuais na linha, fa√ßa a transi√ß√£o para a pr√≥xima instru√ß√£o e o pr√≥ximo caractere. </p><br><p>  A m√°quina tamb√©m entende a opera√ß√£o de salto (OP_JUMP), que usa um √∫nico argumento imediato.  O argumento significa o deslocamento absoluto no bytecode, de onde continuar o c√°lculo. </p><br><p>  A √∫ltima opera√ß√£o importante √© OP_OR.  Ela pega duas compensa√ß√µes, tentando aplicar o c√≥digo primeiro na primeira delas e, em caso de erro, na segunda.  Ela faz isso com uma chamada recursiva, ou seja, a instru√ß√£o faz uma caminhada na profundidade da √°rvore de todas as variantes poss√≠veis da express√£o regular. </p><br><p>  Surpreendentemente, quatro opcodes e setenta linhas de c√≥digo s√£o suficientes para expressar express√µes regulares como "abc", "a? Bc", "(ab | bc) d", "a * bc".  Essa m√°quina virtual nem sequer tem um estado expl√≠cito, pois tudo o que voc√™ precisa - ponteiros para o in√≠cio do fluxo de instru√ß√µes, a instru√ß√£o atual e o caractere atual - √© passado como argumento para a fun√ß√£o recursiva. </p><br><p>  Se voc√™ estiver interessado nos detalhes do trabalho dos mecanismos de express√£o regular, primeiro leia uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√©rie de artigos de</a> Russ Cox, autor do mecanismo de express√£o regular do Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RE2</a> . </p><br><h1 id="itogi">  Sum√°rio </h1><br><p>  Vamos resumir. </p><br><p>  Para linguagens de programa√ß√£o de uso geral, como regra, duas arquiteturas s√£o usadas: empilhar e registrar. </p><br><p>  No modelo de pilha, a estrutura de dados principal e o m√©todo de transmiss√£o de argumentos entre instru√ß√µes √© a pilha.  No modelo de registro, um conjunto de registros √© usado para calcular express√µes, mas uma pilha expl√≠cita ou impl√≠cita ainda √© usada para armazenar argumentos de fun√ß√£o. </p><br><p>  A presen√ßa de uma pilha expl√≠cita e de um conjunto de registros aproxima essas m√°quinas das de baixo n√≠vel e at√© f√≠sicas.  A abund√¢ncia de instru√ß√µes de baixo n√≠vel nesse c√≥digo de bytes significa que um gasto significativo de recursos do processador f√≠sico recai na decodifica√ß√£o e programa√ß√£o de instru√ß√µes virtuais. </p><br><p>  Por outro lado, as instru√ß√µes de alto n√≠vel desempenham um papel importante nas m√°quinas virtuais populares.  Em Java, por exemplo, estas s√£o instru√ß√µes para chamadas de fun√ß√µes polim√≥rficas, aloca√ß√£o de objetos e coleta de lixo. </p><br><p>  M√°quinas virtuais puramente de alto n√≠vel - por exemplo, int√©rpretes de c√≥digos de bytes de linguagens com sem√¢ntica desenvolvida e distante do ferro - passam a maior parte do tempo n√£o no expedidor ou decodificador, mas no corpo das instru√ß√µes e, portanto, s√£o relativamente eficientes. </p><br><p>  Recomenda√ß√µes pr√°ticas: </p><br><ol><li>  Se voc√™ precisar executar qualquer bytecode e faz√™-lo em um per√≠odo de tempo razo√°vel, tente operar com as instru√ß√µes mais pr√≥ximas da sua tarefa;  quanto maior o n√≠vel sem√¢ntico, melhor.  Isso reduzir√° os custos de agendamento e simplificar√° a gera√ß√£o de c√≥digo. </li><li>  Se voc√™ precisar de mais flexibilidade e sem√¢ntica heterog√™nea, tente pelo menos destacar o denominador comum no c√≥digo de bytes para que as instru√ß√µes resultantes estejam em um n√≠vel m√©dio condicional. </li><li>  Se, no futuro, for necess√°rio calcular qualquer express√£o, criar uma m√°quina empilhada, isso reduzir√° a dor de cabe√ßa ao compilar o c√≥digo de bytes. </li><li>  Se express√µes n√£o forem esperadas, crie uma m√°quina de registro trivial, que evitar√° o custo da pilha e simplificar√° as instru√ß√µes. </li></ol><br><p>  Nos artigos a seguir, discutirei implementa√ß√µes pr√°ticas de m√°quinas virtuais em linguagens de programa√ß√£o populares e explicarei por que o departamento de Business Intelligence Badoo precisava de um bytecode. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425325/">https://habr.com/ru/post/pt425325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425313/index.html">As 10 melhores extens√µes de c√≥digo VS de 2018 para desenvolvedores front-end</a></li>
<li><a href="../pt425315/index.html">Organizando o armazenamento de c√≥digo no GitLab e integrando a revis√£o de c√≥digo no GitFlow</a></li>
<li><a href="../pt425317/index.html">Como √© feito: escrevemos ‚ÄúCampo Minado‚Äù em 4 minutos</a></li>
<li><a href="../pt425321/index.html">Programa√ß√£o √© a materializa√ß√£o de id√©ias.</a></li>
<li><a href="../pt425323/index.html">"Toca do coelho". Designer de UX na equipe de produtos</a></li>
<li><a href="../pt425327/index.html">Programa√ß√£o funcional: me√ßa sete vezes, corte uma vez</a></li>
<li><a href="../pt425329/index.html">Alguns conselhos aos millennials dos "oldies". Como ter sucesso em nosso mundo digital</a></li>
<li><a href="../pt425331/index.html">Alice ajudar√° os desenvolvedores a encontrar objetos nas solicita√ß√µes do usu√°rio. NER em caixas de di√°logo</a></li>
<li><a href="../pt425333/index.html">Inicie voc√™ mesmo, a primavera est√° chegando (Parte 2)</a></li>
<li><a href="../pt425335/index.html">Armada invicta Garmin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>