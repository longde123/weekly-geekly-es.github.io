<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏼 📟 👧🏽 Intérpretes de Bytecode DIY 👩🏿‍🤝‍👨🏽 💐 🌕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Máquinas virtuais de linguagens de programação se tornaram muito difundidas nas últimas décadas. Muito tempo se passou desde a apresentação da Java Vi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intérpretes de Bytecode DIY</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/425325/"><p><img src="https://habrastorage.org/webt/aa/zv/cl/aazvcl84q5xly1zkqhtxelkemju.png"></p><br><p>  Máquinas virtuais de linguagens de programação se tornaram muito difundidas nas últimas décadas.  Muito tempo se passou desde a apresentação da Java Virtual Machine na segunda metade dos anos 90, e é seguro dizer que os intérpretes de código de bytes não são o futuro, mas o presente. </p><br><p>  Mas essa técnica, na minha opinião, é quase universal, e o entendimento dos princípios básicos do desenvolvimento de intérpretes é útil não apenas para o criador do próximo desafiante do título "Linguagem do Ano" de acordo com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TIOBE</a> , mas para qualquer programador em geral. </p><br><p>  Em uma palavra, se você estiver interessado em aprender como nossas linguagens de programação favoritas somam números, sobre o que os desenvolvedores de máquinas virtuais ainda estão discutindo e sobre como combinar strings e expressões regulares sem problemas, peço cat. </p><a name="habracut"></a><br><p>  Parte um, introdutória (atual) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte Dois, Otimizando</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte Três, Aplicada</a> </p><br><h1 id="predystoriya">  Antecedentes </h1><br><p>  Um dos sistemas auto-escritos do departamento de Business Intelligence da nossa empresa possui uma interface na forma de uma linguagem de consulta simples.  Na primeira versão do sistema, esse idioma foi interpretado em tempo real, sem compilação, diretamente da linha de entrada com a solicitação.  A segunda versão do analisador já funcionará com bytecode intermediário, o que permitirá que você separe o idioma da consulta da execução deles e simplifique bastante o código. </p><br><p> No processo de trabalhar na segunda versão do sistema, tive férias durante as quais, durante uma ou duas horas todos os dias, me distraí dos assuntos da família para estudar materiais sobre a arquitetura e o desempenho dos intérpretes de bytecode.  Decidi compartilhar as notas e exemplos de intérpretes resultantes com os leitores de Habr como uma série de artigos. </p><br><p>  O primeiro deles apresenta cinco máquinas virtuais pequenas (até centenas de linhas de código C simples), cada uma das quais revela um certo aspecto do desenvolvimento de tais intérpretes. </p><br><h1 id="otkuda-est-poshli-bayt-kody-v-yazykah-programmirovaniya">  Para onde foram os códigos de bytes nas linguagens de programação? </h1><br><p>  Muitas máquinas virtuais, os mais diversos conjuntos de instruções virtuais nas últimas décadas, foram inventados.  A Wikipedia afirma que as primeiras linguagens de programação começaram a se compilar em várias representações intermediárias simplificadas nos anos 60 do século passado.  Alguns desses códigos de primeiro byte foram convertidos em códigos de máquina e executados por processadores reais, enquanto outros foram interpretados em tempo real por processadores virtuais. </p><br><p>  A popularidade dos conjuntos de instruções virtuais como uma representação intermediária do código se deve a três razões: </p><br><ol><li>  Os programas de bytecode são facilmente portados para novas plataformas. </li><li>  Os intérpretes de bytecode são mais rápidos que os intérpretes da árvore de código da sintaxe. </li><li>  Você pode desenvolver uma máquina virtual simples em apenas algumas horas. </li></ol><br><p>  Vamos criar algumas máquinas virtuais C simples e usar esses exemplos para destacar os principais aspectos técnicos da implementação de máquinas virtuais. </p><br><p>  Códigos de amostra completos estão disponíveis no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Exemplos podem ser compilados com qualquer GCC relativamente recente: </p><br><pre><code class="plaintext hljs">gcc interpreter-basic-switch.c -o interpreter ./interpreter</code> </pre> <br><p>  Todos os exemplos têm a mesma estrutura: primeiro vem o código da própria máquina virtual, depois a função principal com asserções que verificam a operação do código.  Tentei comentar claramente os códigos de operação e os principais locais dos intérpretes.  Espero que este artigo seja compreensível até para as pessoas que não escrevem em C diariamente. </p><br><h1 id="samyy-prostoy-v-mire-interpretator-bayt-koda">  O interpretador de bytecodes mais fácil do mundo </h1><br><p>  Como eu disse, o intérprete mais simples é muito fácil de fazer.  Os comentários estão logo atrás da lista, mas vamos começar diretamente com o código: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Existem menos de cem linhas, mas todos os atributos característicos de uma máquina virtual são representados.  A máquina possui um único registro ( <code>vm.accumulator</code> ), três operações (incremento do registro, decremento do registro e conclusão da execução do programa) e um ponteiro para a instrução atual ( <code>vm.ip</code> ). </p><br><p>  Cada operação (por exemplo, <em>código de</em> <em>operação</em> ou <em>opcode</em> ) é codificada com um byte e o agendamento é realizado usando a <code>switch</code> usual na função <code>vm_interpret</code> .  As ramificações no <code>switch</code> contêm a lógica das operações, ou seja, elas alteram o estado do registro ou encerram a execução do programa. </p><br><p>  As operações são transferidas para a função <code>vm_interpret</code> na forma de uma matriz de bytes - um bytecode (Eng. <em>Bytecode</em> ) - e são executadas sequencialmente até que a operação de <code>OP_DONE</code> máquina virtual ( <code>OP_DONE</code> ) seja <code>OP_DONE</code> . </p><br><p>  Um aspecto fundamental de uma máquina virtual é a semântica, ou seja, o conjunto de operações que são possíveis nela.  Nesse caso, existem apenas duas operações e elas alteram o valor de um único registro. </p><br><p>  Alguns pesquisadores ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Técnicas de Abstração e Otimização de Máquinas Virtuais</a> , 2009) propõem a divisão de máquinas virtuais em máquinas de <em>alto</em> e <em>baixo nível, de</em> acordo com a proximidade da semântica da máquina virtual com a semântica da máquina física na qual o bytecode será executado. </p><br><p>  No caso extremo, o bytecode de máquinas virtuais de baixo nível pode repetir completamente o código da máquina física com RAM simulada, um conjunto completo de registros, instruções para trabalhar com a pilha e assim por diante.  A máquina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bochs</a> , por exemplo, repete o conjunto de instruções da arquitetura x86. </p><br><p>  E vice-versa: as operações de máquinas virtuais de alto nível refletem de perto a semântica de uma linguagem de programação especializada compilada no bytecode.  Então trabalhe, por exemplo, SQLite, Gawk e várias versões do Prolog. </p><br><p>  As posições intermediárias são ocupadas por intérpretes de linguagens de programação de uso geral, com elementos de níveis alto e baixo.  A Java Virtual Machine mais popular possui instruções de baixo nível para trabalhar com a pilha e suporte interno para programação orientada a objetos com alocação automática de memória. </p><br><p>  É mais provável que o código acima seja a mais primitiva das máquinas virtuais de baixo nível: cada instrução virtual é um invólucro com uma ou duas instruções físicas, o registro virtual é totalmente consistente com um registro do processador "iron". </p><br><h1 id="argumenty-instrukciy-v-bayt-kode">  Argumentos de instrução de bytecode </h1><br><p>  Podemos dizer que o único registro em nosso exemplo de máquina virtual é um argumento e o valor de retorno de todas as instruções executadas.  No entanto, podemos achar útil passar argumentos nas instruções.  Uma maneira é colocá-los diretamente no bytecode. </p><br><p>  Expandiremos o exemplo introduzindo instruções (OP_ADDI, OP_SUBI) que recebem um argumento na forma de um byte imediatamente após o código de operação: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* add the immediate argument to the register */</span></span> OP_ADDI, <span class="hljs-comment"><span class="hljs-comment">/* subtract the immediate argument from the register */</span></span> OP_SUBI, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator += arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_SUBI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator -= arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Novas instruções (consulte a função <code>vm_interpret</code> ) leem seu argumento do bytecode e o adicionam ao registro / subtraem-no do registro. </p><br><p>  Esse argumento é chamado de <em>argumento imediato</em> , porque está localizado diretamente na matriz opcode.  A principal limitação em nossa implementação é que o argumento é um byte único e pode levar apenas 256 valores. </p><br><p>  Em nossa máquina virtual, o intervalo de possíveis valores de argumentos de instruções não desempenha um grande papel.  Mas se a máquina virtual for usada como intérprete da linguagem real, faz sentido complicar o bytecode adicionando uma tabela de constantes separada da matriz de opcodes e instruções com um argumento direto correspondente ao endereço desse argumento na tabela de constantes. </p><br><h1 id="stekovaya-mashina">  Máquina de empilhar </h1><br><p>  As instruções em nossa máquina virtual simples sempre funcionam com um registro e não podem transmitir dados entre si de forma alguma.  Além disso, o argumento para a instrução só pode ser imediato e, digamos, a operação de adição ou multiplicação leva dois argumentos. </p><br><p>  Simplificando, não temos como avaliar expressões complexas.  Para resolver esse problema, é necessária uma máquina empilhada, ou seja, uma máquina virtual com uma pilha integrada: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STACK_MAX 256 struct { uint8_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Fixed-size stack */</span></span></span><span class="hljs-meta"> uint64_t stack[STACK_MAX]; uint64_t *stack_top; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* push the immediate argument onto the stack */</span></span></span><span class="hljs-meta"> OP_PUSHI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, add and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, subtract and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, divide and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, multiply and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop the top of the stack and set it as execution result */</span></span></span><span class="hljs-meta"> OP_POP_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; vm.stack_top = vm.stack; } void vm_stack_push(uint64_t value) { *vm.stack_top = value; vm.stack_top++; } uint64_t vm_stack_pop(void) { vm.stack_top--; return *vm.stack_top; } interpret_result vm_interpret(uint8_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; for (;;) { uint8_t instruction = *vm.ip++; switch (instruction) { case OP_PUSHI: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span></span><span class="hljs-meta"> uint8_t arg = *vm.ip++; vm_stack_push(arg); break; } case OP_ADD: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left + arg_right; vm_stack_push(res); break; } case OP_SUB: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, subtract 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left - arg_right; vm_stack_push(res); break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, divide 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arg_right == 0) return ERROR_DIVISION_BY_ZERO; uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left / arg_right; vm_stack_push(res); break; } case OP_MUL: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, multiply 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left * arg_right; vm_stack_push(res); break; } case OP_POP_RES: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop the top of the stack, set it as a result value */</span></span></span><span class="hljs-meta"> uint64_t res = vm_stack_pop(); vm.result = res; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  Neste exemplo, já existem mais operações e quase todas funcionam apenas com a pilha.  OP_PUSHI coloca seu argumento imediato na pilha.  As instruções OP_ADD, OP_SUB, OP_DIV, OP_MUL são exibidas de uma pilha de valores, calculam o resultado e empurram-no de volta para a pilha.  OP_POP_RES remove o valor da pilha e o coloca no registro de resultados, destinado aos resultados da máquina virtual. </p><br><p>  Para a operação de divisão (OP_DIV), um erro de divisão por zero é capturado, o que para a máquina virtual. </p><br><p>  As capacidades dessa máquina são muito mais amplas do que a anterior com um único registro e permitem, por exemplo, calcular expressões aritméticas complexas.  Outra vantagem (e importante!) É a simplicidade de compilar linguagens de programação no código de bytes da máquina de empilhamento. </p><br><h1 id="registrovaya-mashina">  Registrar máquina </h1><br><p>  Devido à sua simplicidade, as máquinas virtuais empilhadas são mais amplamente usadas entre os desenvolvedores de linguagens de programação;  as mesmas VMs JVMs e Python as usam exatamente. </p><br><p>  No entanto, essas máquinas têm desvantagens: elas precisam adicionar instruções especiais para trabalhar com a pilha; ao calcular expressões, todos os argumentos passam repetidamente por uma única estrutura de dados; muitas instruções extras aparecerão inevitavelmente no código da pilha. </p><br><p>  Enquanto isso, a execução de cada instrução extra implica o custo da programação, isto é, decodificar o código de operação e mudar para o corpo das instruções. </p><br><p>  Uma alternativa para máquinas empilhadas é registrar máquinas virtuais.  Eles têm um bytecode mais complexo: o número de argumentos do registro e o número do resultado do registro são codificados explicitamente em cada instrução.  Portanto, em vez de uma pilha, um conjunto estendido de registros é usado como armazenamento de valores intermediários. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REGISTER_NUM 16 struct { uint16_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Register array */</span></span></span><span class="hljs-meta"> uint64_t reg[REGISTER_NUM]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Load an immediate value into r0 */</span></span></span><span class="hljs-meta"> OP_LOADI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Add values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Subtract values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Divide values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Multiply values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Move a value from r0 register into the result register */</span></span></span><span class="hljs-meta"> OP_MOV_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; } void decode(uint16_t instruction, uint8_t *op, uint8_t *reg0, uint8_t *reg1, uint8_t *reg2, uint8_t *imm) { *op = (instruction &amp; 0xF000) &gt;&gt; 12; *reg0 = (instruction &amp; 0x0F00) &gt;&gt; 8; *reg1 = (instruction &amp; 0x00F0) &gt;&gt; 4; *reg2 = (instruction &amp; 0x000F); *imm = (instruction &amp; 0x00FF); } interpret_result vm_interpret(uint16_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; uint8_t op, r0, r1, r2, immediate; for (;;) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* fetch the instruction */</span></span></span><span class="hljs-meta"> uint16_t instruction = *vm.ip++; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* decode it */</span></span></span><span class="hljs-meta"> decode(instruction, &amp;op, &amp;r0, &amp;r1, &amp;r2, &amp;immediate); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* dispatch */</span></span></span><span class="hljs-meta"> switch (op) { case OP_LOADI: { vm.reg[r0] = immediate; break; } case OP_ADD: { vm.reg[r2] = vm.reg[r0] + vm.reg[r1]; break; } case OP_SUB: { vm.reg[r2] = vm.reg[r0] - vm.reg[r1]; break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (vm.reg[r1] == 0) return ERROR_DIVISION_BY_ZERO; vm.reg[r2] = vm.reg[r0] / vm.reg[r1]; break; } case OP_MUL: { vm.reg[r2] = vm.reg[r0] * vm.reg[r1]; break; } case OP_MOV_RES: { vm.result = vm.reg[r0]; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  O exemplo mostra uma máquina de registro com 16 registros.  As instruções ocupam 16 bits cada e são codificadas de três maneiras: </p><br><ol><li>  4 bits por código de operação + 4 bits por nome de registro + 8 bits por argumento. </li><li>  4 bits por código de operação + três vezes 4 bits por nomes de registro. </li><li>  4 bits por código de operação + 4 bits por nome de registro único + 8 bits não utilizados. </li></ol><br><p>  Nossa pequena máquina virtual possui muito poucas operações, portanto, quatro bits (ou 16 operações possíveis) por código de operação são suficientes.  A operação determina o que exatamente os bits restantes da instrução representam. </p><br><p>  O primeiro tipo de codificação (4 + 4 + 8) é necessário para carregar dados nos registradores com a operação OP_LOADI.  O segundo tipo (4 + 4 + 4 + 4) é usado para operações aritméticas, que devem saber onde levar um par de argumentos e onde adicionar o resultado do cálculo.  E finalmente, a última forma (4 + 4 + 8 bits desnecessários) é usada para instruções com um único registro como argumento, no nosso caso é OP_MOV_RES. </p><br><p>  Para codificar e decodificar instruções, agora precisamos de lógica especial (função de <code>decode</code> ).  Por outro lado, a lógica das instruções, graças à indicação explícita da localização dos argumentos, fica mais fácil - as operações com a pilha desaparecem. </p><br><p>  Recursos principais: no bytecode das máquinas de registro, há menos instruções, instruções individuais são mais amplas, a compilação nesse bytecode é mais difícil - o compilador precisa decidir como usar os registros disponíveis. </p><br><p>  Deve-se notar que, na prática, no registro de máquinas virtuais, geralmente há uma pilha em que, por exemplo, argumentos de função são colocados;  registradores são usados ​​para calcular expressões individuais.  Mesmo se não houver pilha explícita, uma matriz é usada para construir a pilha, desempenhando o mesmo papel que a RAM em máquinas físicas. </p><br><h1 id="stekovye-i-registrovye-mashiny-sravnenie">  Máquinas de empilhar e registrar, comparação </h1><br><p>  Há um estudo interessante ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confrontação de máquinas virtuais: Stack versus registradores</a> , 2008) que teve uma grande influência em todos os desenvolvimentos subsequentes no campo de máquinas virtuais para linguagens de programação.  Seus autores propuseram um método de tradução direta do código de pilha de uma JVM padrão para um código de registro e compararam o desempenho. </p><br><p>  O método não é trivial: o código é primeiro traduzido e depois otimizado de uma maneira bastante complicada.  Porém, uma comparação subsequente do desempenho do mesmo programa mostrou que os ciclos adicionais do processador gastos em instruções de decodificação são totalmente compensados ​​por uma diminuição no número total de instruções.  Em geral, em resumo, a máquina registradora era mais eficiente que a pilha. </p><br><p>  Como já mencionado acima, essa eficiência tem um preço bastante tangível: o compilador deve alocar os próprios registros e um otimizador avançado é adicionalmente desejável. </p><br><p>  O debate sobre qual arquitetura é melhor ainda não acabou.  Se falamos de compiladores Java, o bytecode da Dalvik VM, que até recentemente funcionava em todos os dispositivos Android, era registrado;  mas o título JVM manteve uma pilha de instruções.  A máquina virtual Lua usa uma máquina de registro, mas a VM Python ainda é empilhável.  E assim por diante </p><br><h1 id="bayt-kod-v-interpretatorah-regulyarnyh-vyrazheniy">  Bytecode em intérpretes de expressão regular </h1><br><p>  Por fim, para nos distrair das máquinas virtuais de baixo nível, vejamos um intérprete especializado que verifica as seqüências de caracteres quanto à correspondência de expressões regulares: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* match a single char to an immediate argument from the string and advance ip and cp, or * abort*/</span></span> OP_CHAR, <span class="hljs-comment"><span class="hljs-comment">/* jump to and match either left expression or the right one, abort if nothing matches*/</span></span> OP_OR, <span class="hljs-comment"><span class="hljs-comment">/* do an absolute jump to an offset in the immediate argument */</span></span> OP_JUMP, <span class="hljs-comment"><span class="hljs-comment">/* stop execution and report a successful match */</span></span> OP_MATCH, } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { MATCH_OK, MATCH_FAIL, MATCH_ERROR, } match_result; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match_recur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *sp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_CHAR:{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cur_c = *sp; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> arg_c = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*ip ; <span class="hljs-comment"><span class="hljs-comment">/* no match? FAILed to match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg_c != cur_c) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_FAIL; <span class="hljs-comment"><span class="hljs-comment">/* advance both current instruction and character pointers */</span></span> ip++; sp++; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JUMP:{ <span class="hljs-comment"><span class="hljs-comment">/* read the offset and jump to the instruction */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> offset = *ip; ip = bytecode + offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_OR:{ <span class="hljs-comment"><span class="hljs-comment">/* get both branch offsets */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> left_offset = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> right_offset = *ip; <span class="hljs-comment"><span class="hljs-comment">/* check if following the first offset get a match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *left_ip = bytecode + left_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vm_match_recur(bytecode, left_ip, sp) == MATCH_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; <span class="hljs-comment"><span class="hljs-comment">/* no match? Check the second branch */</span></span> ip = bytecode + right_offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_MATCH:{ <span class="hljs-comment"><span class="hljs-comment">/* success */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_ERROR; } } <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Start matching a string: %s\n"</span></span>, str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vm_match_recur(bytecode, bytecode, str); }</code> </pre><br><p>  A instrução principal é OP_CHAR.  Ela pega seu argumento imediato e o compara com o caractere atual na string ( <code>char *sp</code> ).  Em caso de coincidência dos caracteres esperados e atuais na linha, faça a transição para a próxima instrução e o próximo caractere. </p><br><p>  A máquina também entende a operação de salto (OP_JUMP), que usa um único argumento imediato.  O argumento significa o deslocamento absoluto no bytecode, de onde continuar o cálculo. </p><br><p>  A última operação importante é OP_OR.  Ela pega duas compensações, tentando aplicar o código primeiro na primeira delas e, em caso de erro, na segunda.  Ela faz isso com uma chamada recursiva, ou seja, a instrução faz uma caminhada na profundidade da árvore de todas as variantes possíveis da expressão regular. </p><br><p>  Surpreendentemente, quatro opcodes e setenta linhas de código são suficientes para expressar expressões regulares como "abc", "a? Bc", "(ab | bc) d", "a * bc".  Essa máquina virtual nem sequer tem um estado explícito, pois tudo o que você precisa - ponteiros para o início do fluxo de instruções, a instrução atual e o caractere atual - é passado como argumento para a função recursiva. </p><br><p>  Se você estiver interessado nos detalhes do trabalho dos mecanismos de expressão regular, primeiro leia uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">série de artigos de</a> Russ Cox, autor do mecanismo de expressão regular do Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RE2</a> . </p><br><h1 id="itogi">  Sumário </h1><br><p>  Vamos resumir. </p><br><p>  Para linguagens de programação de uso geral, como regra, duas arquiteturas são usadas: empilhar e registrar. </p><br><p>  No modelo de pilha, a estrutura de dados principal e o método de transmissão de argumentos entre instruções é a pilha.  No modelo de registro, um conjunto de registros é usado para calcular expressões, mas uma pilha explícita ou implícita ainda é usada para armazenar argumentos de função. </p><br><p>  A presença de uma pilha explícita e de um conjunto de registros aproxima essas máquinas das de baixo nível e até físicas.  A abundância de instruções de baixo nível nesse código de bytes significa que um gasto significativo de recursos do processador físico recai na decodificação e programação de instruções virtuais. </p><br><p>  Por outro lado, as instruções de alto nível desempenham um papel importante nas máquinas virtuais populares.  Em Java, por exemplo, estas são instruções para chamadas de funções polimórficas, alocação de objetos e coleta de lixo. </p><br><p>  Máquinas virtuais puramente de alto nível - por exemplo, intérpretes de códigos de bytes de linguagens com semântica desenvolvida e distante do ferro - passam a maior parte do tempo não no expedidor ou decodificador, mas no corpo das instruções e, portanto, são relativamente eficientes. </p><br><p>  Recomendações práticas: </p><br><ol><li>  Se você precisar executar qualquer bytecode e fazê-lo em um período de tempo razoável, tente operar com as instruções mais próximas da sua tarefa;  quanto maior o nível semântico, melhor.  Isso reduzirá os custos de agendamento e simplificará a geração de código. </li><li>  Se você precisar de mais flexibilidade e semântica heterogênea, tente pelo menos destacar o denominador comum no código de bytes para que as instruções resultantes estejam em um nível médio condicional. </li><li>  Se, no futuro, for necessário calcular qualquer expressão, criar uma máquina empilhada, isso reduzirá a dor de cabeça ao compilar o código de bytes. </li><li>  Se expressões não forem esperadas, crie uma máquina de registro trivial, que evitará o custo da pilha e simplificará as instruções. </li></ol><br><p>  Nos artigos a seguir, discutirei implementações práticas de máquinas virtuais em linguagens de programação populares e explicarei por que o departamento de Business Intelligence Badoo precisava de um bytecode. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425325/">https://habr.com/ru/post/pt425325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425313/index.html">As 10 melhores extensões de código VS de 2018 para desenvolvedores front-end</a></li>
<li><a href="../pt425315/index.html">Organizando o armazenamento de código no GitLab e integrando a revisão de código no GitFlow</a></li>
<li><a href="../pt425317/index.html">Como é feito: escrevemos “Campo Minado” em 4 minutos</a></li>
<li><a href="../pt425321/index.html">Programação é a materialização de idéias.</a></li>
<li><a href="../pt425323/index.html">"Toca do coelho". Designer de UX na equipe de produtos</a></li>
<li><a href="../pt425327/index.html">Programação funcional: meça sete vezes, corte uma vez</a></li>
<li><a href="../pt425329/index.html">Alguns conselhos aos millennials dos "oldies". Como ter sucesso em nosso mundo digital</a></li>
<li><a href="../pt425331/index.html">Alice ajudará os desenvolvedores a encontrar objetos nas solicitações do usuário. NER em caixas de diálogo</a></li>
<li><a href="../pt425333/index.html">Inicie você mesmo, a primavera está chegando (Parte 2)</a></li>
<li><a href="../pt425335/index.html">Armada invicta Garmin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>