<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µ ü§º üìã Como resolver o problema do reconhecimento de √°udio no GO üéÖ üë®üèΩ‚Äçüè´ ü§≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, o BI.ZONE participou da confer√™ncia HighLoad ++. √â claro que chegamos l√° n√£o apenas para olhar as bancas de outras pessoas, mas trouxemo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como resolver o problema do reconhecimento de √°udio no GO</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bizone/blog/480092/">  Recentemente, o BI.ZONE participou da confer√™ncia HighLoad ++.  √â claro que chegamos l√° n√£o apenas para olhar as bancas de outras pessoas, mas trouxemos algo interessante.  Funcion√°rios de diferentes departamentos da empresa prepararam tarefas para os convidados da confer√™ncia, cuja solu√ß√£o oferecemos pr√™mios.  Uma das tarefas de Golang foi dedicada ao reconhecimento de som.  Pedimos √† autora que falasse sobre ela. <br><br><h2>  Declara√ß√£o do problema </h2><br>  Em nossa tarefa, precisamos indexar um certo n√∫mero de faixas e aprender a procurar no banco de dados a composi√ß√£o original por sua amostra.  Nesse caso, a amostra pode muito bem ser barulhenta, gravada em um microfone ruim, pode ter uma frequ√™ncia diferente.  A maior parte do c√≥digo j√° foi escrita para o participante, ele s√≥ precisa implementar a fun√ß√£o de impress√£o digital, que remove a impress√£o digital da pista. <br><a name="habracut"></a><br><h2>  Como gravar um som </h2><br>  √â claro que qualquer faixa √© uma onda mec√¢nica de natureza anal√≥gica.  As ondas na f√≠sica t√™m duas caracter√≠sticas: frequ√™ncia e amplitude.  No que diz respeito √†s ondas sonoras, por simplicidade, podemos assumir que a amplitude √© o volume e a frequ√™ncia √© o tom, embora, na verdade, sons altos pare√ßam mais altos para uma pessoa na mesma amplitude. <br><br>  Ou seja, do ponto de vista da f√≠sica, cada composi√ß√£o √© descrita por uma fun√ß√£o cont√≠nua, o que significa que qualquer pe√ßa arbitrariamente pequena da m√∫sica conter√° uma quantidade infinita de informa√ß√µes (embora se esse seja algum tipo de p√≥s-punk, provavelmente haver√° pouca informa√ß√£o nas faixas menos).  Por esse motivo, o sinal anal√≥gico n√£o pode ser salvo; voc√™ ter√° que lidar com a digitaliza√ß√£o.  A principal abordagem para a digitaliza√ß√£o de sinais anal√≥gicos √© a modula√ß√£o por c√≥digo de pulso, que ser√° discutida nesta se√ß√£o.  O PCM consiste em tr√™s est√°gios: discretiza√ß√£o, quantiza√ß√£o e codifica√ß√£o.  Vamos analisar brevemente o que acontece em cada um deles. <br><br><h3>  Discretiza√ß√£o </h3><br>  Portanto, temos uma fun√ß√£o de amplitude versus tempo.  Se algu√©m tiver uma pergunta, onde est√° a frequ√™ncia, ela ficar√° oculta atr√°s das curvas do gr√°fico de fun√ß√µes.  Ela ainda n√£o est√° vis√≠vel, mas mais tarde a puxaremos para fora.  Como estamos falando de um sinal anal√≥gico, a fun√ß√£o √© cont√≠nua e definida em todo o conjunto de argumentos poss√≠veis (qualquer n√∫mero real de zero ao final da faixa).  Ou seja, sabemos o valor da fun√ß√£o a qualquer momento e temos muitos momentos.  Obviamente, n√£o precisamos de muito, portanto, basta pegar um subconjunto discreto.  Para fazer isso, salvaremos o valor do sinal em um pequeno intervalo fixo.  Deve ser pequeno o suficiente para n√£o ouvir a diferen√ßa de ouvido, mas grande o suficiente para n√£o economizar muito, porque isso tamb√©m √© indesej√°vel. <br><br>  De fato, ao digitalizar, n√£o √© o intervalo definido, mas a frequ√™ncia, que √© chamada de "frequ√™ncia de amostragem".  Dependendo das tarefas, a frequ√™ncia de amostragem pode variar de 8 kHz em telefones a v√°rios milhares de kHz em equipamentos de √°udio profissional.  As m√∫sicas para audi√ß√£o comum fora dos est√∫dios de grava√ß√£o geralmente s√£o armazenadas a uma frequ√™ncia de 44,1 kHz ou 48 kHz. <br><br><h3>  Quantiza√ß√£o </h3><br>  Gra√ßas √† discretiza√ß√£o, agora temos v√°rios pontos em vez de um gr√°fico de fun√ß√µes cont√≠nuas, mas ainda n√£o podemos trabalhar com isso, precisamos estragar ainda mais o som.  A fun√ß√£o inicial da amplitude versus tempo comparou a amplitude do continuum com o tempo do continuum.  Com o tempo, descobrimos isso e agora precisamos criar algo com amplitude, porque seus valores atuais est√£o espalhados pelo conjunto de n√∫meros reais de maneira muito ca√≥tica para que possamos salv√°-los sem problemas.  Por exemplo, entre eles, com certeza, existem outros irracionais que n√£o podemos salvar de forma alguma sem arredondamentos. <br><br>  A quantiza√ß√£o √© um processo durante o qual arredondamos amplitudes para valores de um conjunto pr√©-selecionado.  Obviamente, queremos que o n√∫mero de amplitudes seja uma pot√™ncia de dois.  Para trilhas de √°udio comuns, √© utilizada a quantiza√ß√£o de 16 bits, ou seja, o n√∫mero de amplitudes ser√° 65 536 (2 a 16 graus).  A grava√ß√£o de som profissional pode ser realizada com maior precis√£o, mas poucas pessoas de ouvido conseguem distinguir quantiza√ß√£o de 16 bits de 24 bits.  Ent√£o, pegamos o poder de dois, pegamos um monte de amplitudes inteiras e os chamamos de n√≠veis de quantiza√ß√£o.  Ent√£o ser√° poss√≠vel dizer que o sinal √© quantizado em 65 536 n√≠veis (soa autoritativamente, certo?).  Cada amplitude √© arredondada para um dos n√≠veis, o que, em √∫ltima an√°lise, permite armazenar seu valor em 16 bits, e de ouvido essa grava√ß√£o √© indistingu√≠vel do som cont√≠nuo anal√≥gico. <br><br>  Como ilustra√ß√£o, voc√™ pode ver a figura abaixo ou gerar suas pr√≥prias imagens em Python (o c√≥digo √© ainda mais baixo).  O canto superior direito da ilustra√ß√£o mostra cinco n√≠veis de quantiza√ß√£o.  Ou seja, a faixa ter√° apenas cinco n√≠veis de volume. <br><br><img src="https://habrastorage.org/webt/9c/44/ma/9c44marhas3olwvom6w5lhjcxx4.png" alt="imagem"><br>  <i>Alguns exemplos</i> <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.sin(x) q = <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">#      k = 0 #      1/2  1/4 vf = np.vectorize(f) orig_f = vf(np.arange(0, 4 * m.pi, 0.001)) quanted_f = q * np.round(orig_f/q + k) plt.plot(orig_f) plt.plot(quanted_f)</span></span></code> </pre> <br><h3>  Codifica√ß√£o </h3><br>  No est√°gio de codifica√ß√£o, salvamos os resultados das etapas anteriores de forma compreens√≠vel.  Todas as a√ß√µes anteriores a isso geralmente s√£o executadas por equipamento especializado, mas queremos ter um arquivo no computador ou uma matriz na mem√≥ria onde haver√° amplitudes.  Portanto, nesta fase, os sinais do equipamento s√£o convertidos em uma matriz de n√∫meros, que chamaremos de PCM (modula√ß√£o de c√≥digo de pulso) no futuro.  Seus √≠ndices s√£o de tempo condicional (√≠ndice de intervalo ap√≥s a amostragem) e as amplitudes s√£o armazenadas nele, arredondadas para n√∫meros inteiros no est√°gio de quantiza√ß√£o. <br><br><h2>  Transformada de Fourier </h2><br>  Inicialmente, t√≠nhamos uma onda mec√¢nica e um desejo de digitaliz√°-la, mas agora temos um sinal digitalizado e um desejo de obter frequ√™ncias a partir dele.  O desejado pode ser alcan√ßado usando a transformada de Fourier.  Apenas no caso, vou recontar seu valor aplicado nesse problema.  A transforma√ß√£o de Fourier permite que voc√™ tome qualquer fun√ß√£o e a decomponha na soma de senos e cossenos.  Estamos interessados ‚Äã‚Äãnisso, porque as ondas sinus√≥ides e cosseno s√£o sobre vibra√ß√µes, e o som √© sobre vibra√ß√µes.  Ou seja, usando a transformada de Fourier, √© poss√≠vel obter os componentes de uma oscila√ß√£o complexa, descobrir sua amplitude e frequ√™ncia, apenas observando quais coeficientes est√£o na frente dos argumentos seno e seno (ou cosseno).  Por exemplo, existe essa onda. <br><br><img src="https://habrastorage.org/webt/jo/l2/cn/jol2cnvs7nfgyxwrbvbxr3jesvi.png" alt="imagem"><br>  <i>A onda</i> <br><br>  De fato, sabemos que ela √© definida pela fun√ß√£o 10sin (3x) + sin (x) + 4sin (4x) + 20sin (2x), mas isso √© agora, e a onda sonora real consiste em uma infinidade de termos e gostar√≠amos de poder trabalhe com isso.  Ent√£o, vamos executar esta fun√ß√£o atrav√©s da transforma√ß√£o de Fourier usando o programa <a href="http://www.siarion.net/rus/free/fourierscope/">FourierScope</a> e ver o espectro de amplitude. <br><br><img src="https://habrastorage.org/webt/wa/i0/xe/wai0xeqihurjmrbsul2p01dotja.png" alt="imagem"><br>  <i>Espectro de amplitude</i> <br><br>  √â assim que os quatro seios se parecem.  √â f√°cil ver que o gr√°fico corresponde aos coeficientes dos senos e seus argumentos. <br><br>  Deve-se esclarecer que, de fato, foi uma demonstra√ß√£o do poder n√£o da pr√≥pria transformada de Fourier, mas de sua vers√£o discreta, adequada para sinais que passaram pela modula√ß√£o do c√≥digo de pulso com todas as suas discretiza√ß√µes e quantiza√ß√µes.  Seria sup√©rfluo apresentar um algoritmo para a transformada discreta de Fourier, ent√£o vamos concordar com o fato de que existe uma coisa chamada DFT, bem como sua modifica√ß√£o, a r√°pida transformada de Fourier (FFT).  Nesse caso, o significado aplicado da FFT √© o seguinte: o algoritmo recebe um peda√ßo de PCM na entrada e fornece uma matriz contendo as amplitudes, e os compartimentos de frequ√™ncia s√£o os √≠ndices.  √â uma quest√£o de caixas de frequ√™ncia, n√£o apenas de frequ√™ncias, j√° que a convers√£o √© discreta.  Na verdade, era ing√™nuo esperar que voc√™ pudesse aumentar o sinal ao longo do artigo e depois obter frequ√™ncias sem problemas e imprecis√µes.  De fato, o compartimento de frequ√™ncia √© um conjunto de frequ√™ncias que a FFT n√£o consegue distinguir uma da outra. <br><br>  Vale a pena notar que as FFTs geralmente s√£o escritas incorretamente ao reescrever um algoritmo de livros e artigos.  Abaixo est√° um c√≥digo mais correto para trabalhar com a FFT, exatamente o que esper√°vamos dos participantes em sua solu√ß√£o. <br><br><pre> <code class="plaintext hljs">import "github.com/mjibson/go-dsp/fft" ... blocksCount := len(pcm) / fftWindowSize for i := 0; i &lt; blocksCount; i++ { complexArray := fft.FFTReal(pcm[i*fftWindowSize : i*fftWindowSize+fftWindowSize]) // use complexArray... }</code> </pre><br>  A tecnologia moderna permite que voc√™ escreva a transforma√ß√£o r√°pida de Fourier em apenas algumas linhas.  A FFT √© usada para segmentos de tamanho fftWindowSize e retorna uma matriz de n√∫meros complexos, que usaremos para impress√µes digitais no futuro. <br><br>  Em geral, a transforma√ß√£o de Fourier √© o local mais fino de todo o problema.  Primeiro, o tamanho da lixeira √© $ \ frac {frequency \ sampling} {size \ window} $.  Dessa forma, voc√™ pode ampliar a janela e obter mais frequ√™ncias, o que √© bom, mas, √© claro, tem consequ√™ncias negativas.  O aumento no tamanho da janela leva ao fato de analisarmos o PCM em grandes intervalos e perdermos sons de curta dura√ß√£o.  Em diferentes circunst√¢ncias, isso pode piorar repetidamente o programa se sons curtos fizerem parte da composi√ß√£o, ou pode melhorar se forem apenas ru√≠dos.  Ou talvez n√£o afete nada.  Em uma situa√ß√£o t√£o dif√≠cil, o programador deve agir decisivamente: pegue um bom n√∫mero, como $ 2 ^ 9 $ ou $ 2 ^ {10} $, e tente n√£o se preocupar com os meandros onde isso n√£o √© necess√°rio.  O suficiente para resolver o problema, mas em um aplicativo s√©rio voc√™ ainda precisa usar algumas janelas do Hamming e muito mais para pensar. <br><br><h2>  Impress√£o digital </h2><br>  A tarefa √© aprender a ter um hash que pode ser mapeado para uma faixa e que √© insens√≠vel a mudan√ßas, tendo as frequ√™ncias e amplitudes da composi√ß√£o.  Eles podem ser muito diferentes: um pouco de ru√≠do, uma mudan√ßa de todas as frequ√™ncias, tocando outra m√∫sica em paralelo, e assim por diante.  Voc√™ tamb√©m precisa considerar que o banco de dados pode conter simultaneamente muitas trilhas semelhantes que precisam ser diferenciadas uma da outra.  Ou talvez todas as faixas sejam diferentes, e o problema n√£o ser√° estabelecer qual √© a mais adequada, mas entender que nenhuma √© a mais adequada.  Em geral, existe um certo escopo para a criatividade. <br><br>  Voc√™ pode imprimir de diferentes maneiras.  Digamos que fa√ßa um hash na forma de uma lista de v√°rios indicadores diferentes.  Entre eles, pode estar, por exemplo, o n√∫mero m√©dio de passagens de sinal zero, BPM, valores m√©dios de frequ√™ncia.  Eu fiz isso nas vers√µes anteriores do <a href="https://github.com/metabrainz">Musicbrainz</a> , e os problemas dessa abordagem est√£o escritos <a href="https://wiki.musicbrainz.org/Fingerprinting">aqui</a> .  E voc√™ pode considerar conceitos mais abstratos, como ritmo, analisando a faixa usando o algoritmo EM ( <a href="https://ieeexplore.ieee.org/document/1203279">artigo</a> ).  Em geral, completa liberdade de express√£o.  Infelizmente, a maioria dos algoritmos propostos, aparentemente, n√£o possui uma implementa√ß√£o p√∫blica; portanto, apenas pegar e compar√°-los n√£o funcionar√°. <br><br>  A implementa√ß√£o principal √© descrita <a href="https://www.ee.columbia.edu/~dpwe/papers/Wang03-shazam.pdf">neste</a> artigo.  √â especialmente bom que voc√™ possa implementar esse algoritmo em v√°rias linhas.  Por exemplo, no artigo original, prop√µe-se dividir as frequ√™ncias em 6 intervalos, encontrar a amplitude m√°xima em cada uma, obter a m√©dia de todas as seis e salvar os compartimentos que s√£o maiores que a m√©dia, mas muitas outras implementa√ß√µes s√£o poss√≠veis. <br><br><pre> <code class="plaintext hljs">var freqBins = [...]int16{40, 80, 120, 180, 300} func getKeyPoints(frame []freq_domain) int { highScores := make([]float64, len(freqBins)) recordPoints := make([]uint, len(freqBins)) for bin := freqBins[0]; bin &lt; freqBins[len(freqBins)-1]; bin++ { magnitude := frame[bin] binIdx := 0 for freqBins[binIdx] &lt; bin { binIdx++ } if magnitude &gt; highScores[binIdx] { highScores[binIdx] = magnitude recordPoints[binIdx] = (uint)(bin) } } return hash(recordPoints) }</code> </pre><br>  A fun√ß√£o acima implementa o algoritmo de impress√£o digital.  No final, uma matriz de frequ√™ncias (ou melhor, compartimentos) √© passada para a fun√ß√£o `hash ()`, que deve transformar uma matriz de v√°rios n√∫meros em um n√∫mero.  Voc√™ pode fazer isso de qualquer maneira adequada, pode at√© tentar usar o md5 (embora isso seja uma m√° ideia). <br><br><h2>  Sobre o teste </h2><br>  <b>V√°rios casos de teste foram preparados:</b> <br><br><ol><li>  Pr√©-teste normal com uma faixa.  O original e a amostra coincidiram completamente. </li><li>  Outro pr√©-teste com duas faixas.  Os originais coincidiram com as amostras. </li><li>  Um n√∫mero um pouco maior de faixas √© indexado, todas s√£o pesquisadas alternadamente. </li><li>  Um grande n√∫mero de faixas √© carregado, elas s√£o pesquisadas, mas ap√≥s a redu√ß√£o da amostra. </li><li>  As faixas s√£o indexadas ap√≥s a redu√ß√£o da amostra, as originais s√£o pesquisadas. </li><li>  Indexou v√°rias faixas semelhantes, procurando uma similar, mas n√£o no banco de dados. </li><li>  V√°rias faixas s√£o indexadas, s√£o pesquisadas, mas com ru√≠do. </li></ol><br><br><h2>  Alguns links interessantes </h2><br>  <a href="https://metacpan.org/pod/Audio::Ofa::Util">https://metacpan.org/pod/Audio::Ofa::Util</a> <br>  <a href="https://www.researchgate.net/publication/228347102_A_Review_of_Audio_Fingerprinting">https://www.researchgate.net/publication/228347102_A_Review_of_Audio_Fingerprinting</a> <br>  <a href="http://www.freshmeat.net/projects/songprint">http://www.freshmeat.net/projects/songprint</a> <br>  <a href="https://link.springer.com/article/10.1007/s11265-005-4152-2">https://link.springer.com/article/10.1007/s11265-005-4152-2</a> <br>  <a href="https://github.com/acoustid/chromaprint">https://github.com/acoustid/chromaprint</a> <br>  <a href="https://laplacian.wordpress.com/2009/01/10/how-shazam-works/">https://laplacian.wordpress.com/2009/01/10/how-shazam-works/</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480092/">https://habr.com/ru/post/pt480092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480080/index.html">O que voc√™ precisa na anota√ß√£o de aplicativos?</a></li>
<li><a href="../pt480082/index.html">Usando particionamento no MySQL para Zabbix com um grande n√∫mero de objetos de monitoramento</a></li>
<li><a href="../pt480086/index.html">Como cumprir os requisitos do 152-FZ, proteger os dados pessoais de nossos clientes e n√£o pisar em nosso ancinho</a></li>
<li><a href="../pt480088/index.html">DevOps - OK, mas o que fazer? Como reduzir o trabalho manual e alcan√ßar o resultado desejado</a></li>
<li><a href="../pt480090/index.html">C√≥digo aberto √© tudo</a></li>
<li><a href="../pt480096/index.html">Fim da inf√¢ncia: direitos autorais sobre obras criadas por intelig√™ncia artificial (IA)</a></li>
<li><a href="../pt480098/index.html">JH Rainwater "Como pastar gatos": do outro lado do desenvolvimento</a></li>
<li><a href="../pt480100/index.html">Iniciantes Sobre SEO</a></li>
<li><a href="../pt480102/index.html">Resumo do gerenciamento de produtos em novembro</a></li>
<li><a href="../pt480104/index.html">9 truques √∫teis em HTML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>