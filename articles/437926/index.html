<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåÔ∏è üîØ üî≤ La gu√≠a autorizada para Fragmentos de Blockchain üë®‚Äçüë©‚Äçüë¶ üçÅ ü§ôüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola, soy uno de los desarrolladores del protocolo cercano de blockchain fragmentado, y en este art√≠culo quiero hablar sobre qu√© es el fragmentaci√≥n d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La gu√≠a autorizada para Fragmentos de Blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437926/"><p>  Hola, soy uno de los desarrolladores del protocolo cercano de blockchain fragmentado, y en este art√≠culo quiero hablar sobre qu√© es el fragmentaci√≥n de blockchain, c√≥mo se implementa y qu√© problemas existen en los dise√±os de fragmentaci√≥n de blockchain. </p><br><p>  Es bien sabido que Ethereum, la cadena de bloques de prop√≥sito general m√°s utilizada en el momento de escribir este art√≠culo, solo puede procesar menos de 20 transacciones por segundo en la cadena principal.  Esta limitaci√≥n, junto con la popularidad de la red, conduce a altos precios del gas (el costo de ejecutar una transacci√≥n en la red) y largos tiempos de confirmaci√≥n;  a pesar del hecho de que en el momento de escribir este art√≠culo, se produce un nuevo bloque aproximadamente cada 10-20 segundos, el tiempo promedio que se tarda en agregar una transacci√≥n a la cadena de bloques es de 1.2 minutos, seg√∫n la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ETH Gas Station</a> .  El bajo rendimiento, los altos precios y la alta latencia hacen que Ethereum no sea adecuado para ejecutar servicios que necesitan escalarse con la adopci√≥n. </p><a name="habracut"></a><br><p>  ¬øCu√°l es la raz√≥n principal del bajo rendimiento de Ethereum?  La raz√≥n es que cada nodo en la red necesita procesar cada transacci√≥n individual.  Los desarrolladores han propuesto muchas soluciones para abordar el problema del rendimiento a nivel de protocolo.  Estas soluciones se pueden separar principalmente en aquellas que delegan toda la computaci√≥n a un peque√±o conjunto de nodos potentes, y aquellas que tienen cada nodo en la red solo hacen un subconjunto de la cantidad total de trabajo.  Un caso extremo del primer enfoque es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Thunder</a> que tiene un solo nodo que procesa todas las transacciones y reclamaciones para lograr 1200 tx / seg, una mejora de 100x sobre Ethereum (sin embargo, no respaldo a Thunder ni atestiguo la validez de sus reclamaciones )  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Algorand</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpaceMesh</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solana</a> encajan en la categor√≠a anterior, construyendo varias mejoras en el consenso y la estructura de la propia cadena de bloques para ejecutar significativamente m√°s transacciones, pero a√∫n limitado por lo que puede procesar una sola m√°quina (aunque muy poderosa). </p><br><p>  El √∫ltimo enfoque, en el que el trabajo se divide entre todos los nodos participantes, se denomina fragmentaci√≥n.  As√≠ es como Ethereum Foundation actualmente planea escalar Ethereum.  En el momento de escribir esto, la especificaci√≥n completa a√∫n no se ha publicado.  Aqu√≠ hay enlaces a una descripci√≥n detallada de las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cadenas de fragmentos Ethereum</a> y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cadena Beacon</a> . </p><br><p>  En esta publicaci√≥n, resumo las ideas centrales de fragmentaci√≥n de blockchain, en las que se basan tanto Near como la mayor√≠a de otros protocolos fragmentados.  La publicaci√≥n posterior describir√° temas m√°s avanzados en sharding. </p><br><h2 id="the-simplest-sharding-aka-beanstalk">  El fragmentaci√≥n m√°s simple, tambi√©n conocido como beanstalk </h2><br><p>  Comencemos con el enfoque m√°s simple para fragmentar, que a lo largo de este art√≠culo llamaremos Beanstalk.  Esto tambi√©n es lo que Vitalik llama "escalar por mil monedas alternativas" en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> presentaci√≥n. </p><br><p>  En este enfoque, en lugar de ejecutar una cadena de bloques, ejecutaremos m√∫ltiples y llamaremos a cada una de estas cadenas de bloques un "fragmento".  Cada fragmento tendr√° su propio conjunto de validadores.  Aqu√≠ y a continuaci√≥n usamos un t√©rmino gen√©rico "validador" para referirnos a los participantes que verifican las transacciones y producen bloques, ya sea por miner√≠a, como en Prueba de trabajo, o mediante un mecanismo basado en la votaci√≥n.  Por ahora supongamos que los fragmentos nunca se comunican entre s√≠. </p><br><p>  El dise√±o de Beanstalk, aunque simple, es suficiente para delinear algunos desaf√≠os importantes en el fragmentaci√≥n. </p><br><h2 id="validator-partitioning-and-beacon-chains">  Validaci√≥n de particionamiento y cadenas de baliza </h2><br><p>  El primer desaf√≠o es que cada fragmento tiene sus propios validadores, cada fragmento es ahora 10 veces menos seguro que toda la cadena.  Entonces, si una cadena no fragmentada con validadores X decide bifurcarse en una cadena fragmentada y divide los validadores X en 10 fragmentos, cada fragmento ahora solo tiene validadores X / 10, y corromper un fragmento solo requiere corromper 5.1% (51% / 10) del n√∫mero total de validadores. </p><br><p>  Lo que nos lleva al segundo punto: ¬øqui√©n elige validadores para cada fragmento?  Controlar el 5.1% de los validadores solo es perjudicial si todos esos 5.1% de los validadores est√°n en el mismo fragmento.  Si los validadores no pueden elegir en qu√© fragmento van a validar, es muy poco probable que un participante que controla el 5,1% de los validadores obtenga todos sus validadores en el mismo fragmento, lo que reduce en gran medida su capacidad de comprometer el sistema. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c8/bd1/f09/6c8bd1f0949baeb207f4d7e6c6c81d8f.png" alt="imagen"></p><br><p>  Casi todos los dise√±os de fragmentos de hoy dependen de alguna fuente de aleatoriedad para asignar validadores a los fragmentos.  La aleatoriedad en blockchain en s√≠ misma es un tema muy desafiante y merecer√≠a una publicaci√≥n de blog por separado en una fecha posterior, pero por ahora supongamos que hay alguna fuente de aleatoriedad que podemos usar. </p><br><p>  Tanto la aleatoriedad como la asignaci√≥n de validadores requieren un c√°lculo que no es espec√≠fico de ning√∫n fragmento en particular.  Para ese c√°lculo, pr√°cticamente todos los dise√±os existentes tienen una cadena de bloques separada que se encarga de realizar las operaciones necesarias para el mantenimiento de toda la red.  Adem√°s de generar n√∫meros aleatorios y asignar validadores a los fragmentos, estas operaciones a menudo tambi√©n incluyen recibir actualizaciones de los fragmentos y tomar instant√°neas de ellos, procesar estacas y recortar en los sistemas de Prueba de estaca y reequilibrar los fragmentos cuando se admite esa caracter√≠stica.  Dicha cadena se llama cadena Beacon en Ethereum y Near, una cadena Relay en PolkaDot y el Cosmos Hub en Cosmos. </p><br><p>  A lo largo de esta publicaci√≥n nos referiremos a dicha cadena como una <strong>cadena Beacon</strong> .  La existencia de la cadena Beacon nos lleva al siguiente tema interesante, el fragmentaci√≥n cuadr√°tica. </p><br><h2 id="quadratic-sharding">  Fragmentaci√≥n cuadr√°tica </h2><br><p>  Sharding a menudo se anuncia como una soluci√≥n que se escala infinitamente con el n√∫mero de nodos que participan en la operaci√≥n de la red.  Si bien en teor√≠a es posible dise√±ar una soluci√≥n de fragmentaci√≥n de este tipo, cualquier soluci√≥n que tenga el concepto de una cadena Beacon no tiene una escalabilidad infinita.  Para entender por qu√©, tenga en cuenta que la cadena Beacon tiene que hacer algunos c√°lculos de contabilidad, como asignar validadores a fragmentos o tomar instant√°neas de bloques de cadena de fragmentos, que es proporcional al n√∫mero de fragmentos en el sistema.  Dado que la cadena Beacon es en s√≠ misma una cadena de bloques √∫nica, con un c√≥mputo limitado por las capacidades computacionales de los nodos que lo operan, la cantidad de fragmentos es naturalmente limitada. </p><br><p>  Sin embargo, la estructura de una red fragmentada otorga un efecto multiplicador a cualquier mejora en sus nodos.  Considere el caso en el que se realiza una mejora arbitraria en la eficiencia de los nodos en la red que les permitir√° tiempos de procesamiento de transacciones m√°s r√°pidos. </p><br><p>  Si los nodos que operan la red, incluidos los nodos en la cadena Beacon, se vuelven cuatro veces m√°s r√°pidos, entonces cada fragmento podr√° procesar cuatro veces m√°s transacciones, y la cadena Beacon podr√° mantener 4 veces m√°s fragmentos.  El rendimiento en todo el sistema aumentar√° en un factor de 4 x 4 = 16, de ah√≠ el nombre de fragmentaci√≥n <strong>cuadr√°tica</strong> . </p><br><p>  Es dif√≠cil proporcionar una medici√≥n precisa de cu√°ntos fragmentos son viables hoy en d√≠a, pero es poco probable que en un futuro previsible las necesidades de rendimiento de los usuarios de blockchain superen las limitaciones del fragmentaci√≥n cuadr√°tica.  La gran cantidad de nodos necesarios para operar un volumen de fragmentos de manera segura es un orden de magnitud mayor que la cantidad de nodos que operan todas las cadenas de bloques combinadas hoy en d√≠a. </p><br><p>  Sin embargo, si queremos construir protocolos a prueba de futuro, podr√≠a valer la pena comenzar a investigar soluciones a este problema hoy.  La propuesta m√°s desarrollada a partir de ahora es el fragmento exponencial, en el que los fragmentos mismos est√°n formando un √°rbol, y cada fragmento principal est√° orquestando una serie de fragmentos secundarios, mientras que puede ser hijo de alg√∫n otro fragmento. </p><br><p>  Se sabe que Vlad Zamfir de la Fundaci√≥n Ethereum est√° trabajando en un dise√±o de fragmentaci√≥n que no involucra una cadena de baliza;  Trabaj√© con √©l en uno de los prototipos, cuyo resumen detallado est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><h2 id="state-sharding">  Fragmentaci√≥n del estado </h2><br><p>  Hasta ahora no hemos definido muy bien qu√© es exactamente y qu√© no est√° separado cuando una red se divide en fragmentos.  Espec√≠ficamente, los nodos en la cadena de bloques realizan tres tareas importantes: no solo 1) procesan transacciones, tambi√©n 2) retransmiten transacciones validadas y bloques completados a otros nodos y 3) almacenan el estado y el historial de todo el libro mayor de la red.  Cada una de estas tres tareas impone un requisito creciente en los nodos que operan la red: </p><br><ol><li>  La necesidad de procesar transacciones requiere m√°s potencia de c√≥mputo con el mayor n√∫mero de transacciones que se procesan; </li><li>  La necesidad de retransmitir transacciones y bloques requiere m√°s ancho de banda de red con el mayor n√∫mero de transacciones que se retransmiten; </li><li>  La necesidad de almacenar datos requiere m√°s almacenamiento a medida que crece el estado.  Es importante destacar que, a diferencia de la potencia de procesamiento y la red, el requisito de almacenamiento aumenta incluso si la tasa de transacci√≥n (n√∫mero de transacciones procesadas por segundo) permanece constante. </li></ol><br><p>  De la lista anterior, puede parecer que el requisito de almacenamiento ser√≠a el m√°s urgente, ya que es el √∫nico que se incrementa con el tiempo, incluso si el n√∫mero de transacciones por segundo no cambia, pero en la pr√°ctica el requisito m√°s urgente hoy en d√≠a. es la potencia de c√°lculo  El estado completo de Ethereum a partir de este escrito es de 100 GB, f√°cilmente manejable por la mayor√≠a de los nodos.  Pero la cantidad de transacciones que Ethereum puede procesar es de alrededor de 20, √≥rdenes de magnitud menos de lo que se necesita para muchos casos de uso pr√°ctico. </p><br><p>  Zilliqa es el proyecto m√°s conocido que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fragmenta el procesamiento</a> pero no el almacenamiento.  El fragmentaci√≥n del procesamiento es un problema m√°s f√°cil porque cada nodo tiene el estado completo, lo que significa que los contratos pueden invocar libremente otros contratos y leer cualquier informaci√≥n de la cadena de bloques.  Se necesita una ingenier√≠a cuidadosa para asegurarse de que las actualizaciones de varios fragmentos que actualizan las mismas partes del estado no entren en conflicto.  En esos aspectos, Zilliqa est√° adoptando un enfoque muy simplista, cuyas cr√≠ticas se pueden encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta publicaci√≥n</a> . </p><br><p>  Si bien se propuso fragmentar el almacenamiento sin fragmentar el procesamiento, no conozco ning√∫n proyecto que funcione en √©l.  Por lo tanto, en la pr√°ctica, el fragmentaci√≥n del almacenamiento, o fragmentaci√≥n de estado, casi siempre implica fragmentaci√≥n del procesamiento y fragmentaci√≥n de la red. </p><br><p>  Pr√°cticamente, bajo Fragmento de estado, los nodos en cada fragmento est√°n construyendo su propia cadena de bloques que contiene transacciones que afectan solo a la parte local del estado global asignado a ese fragmento.  Por lo tanto, los validadores en el fragmento solo necesitan almacenar su parte local del estado global y solo ejecutar, y como tal solo retransmitir, las transacciones que afectan su parte del estado.  Esta partici√≥n reduce linealmente el requisito de toda la potencia de c√≥mputo, el almacenamiento y el ancho de banda de la red, pero presenta nuevos problemas, como la disponibilidad de datos y las transacciones de fragmentos cruzados, los cuales cubriremos a continuaci√≥n. </p><br><h2 id="cross-shard-transactions">  Transacciones de fragmentos cruzados </h2><br><p>  Beanstalk como modelo no es un enfoque muy √∫til para fragmentar, porque si los fragmentos individuales no pueden comunicarse entre s√≠, no son mejores que m√∫ltiples cadenas de bloques independientes.  Incluso hoy, cuando el fragmentaci√≥n no est√° disponible, existe una gran demanda de interoperabilidad entre varias blockchains. </p><br><p>  Consideremos por ahora solo transacciones de pago simples, donde cada participante tiene una cuenta en exactamente un fragmento.  Si se desea transferir dinero de una cuenta a otra dentro del mismo fragmento, los validadores de ese fragmento pueden procesar completamente la transacci√≥n.  Sin embargo, si Alice, que reside en el fragmento n. ¬∞ 1, quiere enviar dinero a Bob que reside en el fragmento n. ¬∞ 2, ni los validadores en el fragmento n. ¬∞ 1 (no podr√°n acreditar la cuenta de Bob) ni los validadores en el fragmento n. ¬∞ 2 ( no podr√°n debitar la cuenta de Alice) puede procesar la transacci√≥n completa. </p><br><p>  Hay dos familias de enfoques para las transacciones entre fragmentos: </p><br><ol><li>  <strong>Sincr√≥nico</strong> : cada vez que se necesita ejecutar una transacci√≥n de fragmentos cruzados, los bloques en fragmentos m√∫ltiples que contienen la transici√≥n de estado relacionada con la transacci√≥n se producen todos al mismo tiempo, y los validadores de fragmentos m√∫ltiples colaboran en la ejecuci√≥n de tales transacciones.  La propuesta m√°s detallada que conozco es Merge Blocks, que se describe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </li><li>  <strong>As√≠ncrono</strong> : una transacci√≥n de fragmentos cruzados que afecta a m√∫ltiples fragmentos se ejecuta en esos fragmentos de forma as√≠ncrona, el fragmento de "Cr√©dito" ejecuta su mitad una vez que tiene evidencia suficiente de que el fragmento de "D√©bito" ha ejecutado su parte.  Este enfoque tiende a ser m√°s frecuente debido a su simplicidad y facilidad de coordinaci√≥n.  Este sistema se propone hoy en Cosmos, Ethereum Serenity, Near, Kadena y otros.  Un problema con este enfoque radica en que si los bloques se producen de forma independiente, existe una probabilidad distinta de cero de que uno de los m√∫ltiples bloques quede hu√©rfano, por lo que la transacci√≥n solo se aplica parcialmente.  Considere la figura a continuaci√≥n que muestra dos fragmentos que encontraron una bifurcaci√≥n y una transacci√≥n de fragmentos cruzados que se registr√≥ en los bloques A y X 'correspondientemente.  Si las cadenas AB y V'-X'-Y'-Z 'terminan siendo can√≥nicas en los fragmentos correspondientes, la transacci√≥n est√° completamente finalizada.  Si A'-B'-C'-D 'y VX se vuelven can√≥nicos, entonces la transacci√≥n se abandona por completo, lo cual es aceptable.  Pero si, por ejemplo, AB y VX se vuelven can√≥nicos, entonces una parte de la transacci√≥n se finaliza y otra se abandona, creando una falla de atomicidad.  Cubriremos c√≥mo se aborda este problema en los protocolos propuestos en la segunda parte, cuando cubramos los cambios en las reglas de elecci√≥n de la bifurcaci√≥n y los algoritmos de consenso propuestos para los protocolos fragmentados. </li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/640/162/e6c/640162e6c138290296c5186fab24e5d1.png" alt="imagen"></p><br><p>  Tenga en cuenta que la comunicaci√≥n entre cadenas tambi√©n es √∫til fuera de las blockchains fragmentadas.  La interoperabilidad entre cadenas es un problema complejo que muchos proyectos est√°n tratando de resolver.  En las cadenas de bloques fragmentadas, el problema es algo m√°s f√°cil ya que la estructura de bloques y el consenso son los mismos en todos los fragmentos, y hay una cadena de baliza que se puede usar para la coordinaci√≥n.  Sin embargo, en una cadena de bloques fragmentada, todas las cadenas de fragmentos son iguales, mientras que en el ecosistema global de cadenas de bloques hay muchas cadenas de bloques diferentes, con diferentes casos de uso objetivo, descentralizaci√≥n y garant√≠as de privacidad. </p><br><p>  La construcci√≥n de un sistema en el que un conjunto de cadenas tenga diferentes propiedades pero use un consenso y una estructura de bloques suficientemente similares y tenga una cadena de baliza com√∫n podr√≠a permitir un ecosistema de cadenas de bloques heterog√©neas que tengan un subsistema de interoperabilidad funcional.  Es poco probable que dicho sistema tenga rotaci√≥n de validador, por lo que se deben tomar algunas medidas adicionales para garantizar la seguridad.  Tanto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cosmos</a> como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PolkaDot</a> son efectivamente tales sistemas.  Este art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrito</a> por Zaki Manian de Cosmos proporciona una descripci√≥n detallada y una comparaci√≥n de los aspectos clave de los dos proyectos. </p><br><h2 id="malicious-behavior">  Comportamiento malicioso </h2><br><p>  Ahora tiene una buena comprensi√≥n de c√≥mo se implementa el fragmentaci√≥n, incluidos los conceptos de la cadena de baliza, las rotaciones del validador y las transacciones de fragmentos cruzados. </p><br><p>  Con toda esa informaci√≥n, hay una √∫ltima cosa importante a considerar.  Espec√≠ficamente, qu√© comportamiento de confrontaci√≥n pueden ejercer los validadores maliciosos. </p><br><h3 id="malicious-forks">  Horquillas maliciosas </h3><br><p>  Un conjunto de validadores maliciosos podr√≠a intentar crear una bifurcaci√≥n.  Tenga en cuenta que no importa si el consenso subyacente es BFT o no, corromper un n√∫mero suficiente de validadores siempre har√° posible crear una bifurcaci√≥n. </p><br><p>  Es significativamente m√°s probable que se corrompa m√°s del 50% de un solo fragmento, que que se corrompa m√°s del 50% de toda la red (profundizaremos en estas probabilidades en la segunda parte).  Como se discuti√≥ anteriormente, las transacciones de fragmentos cruzados implican ciertos cambios de estado en fragmentos m√∫ltiples, y los bloques correspondientes en dichos fragmentos que aplican dichos cambios de estado deben estar todos finalizados (es decir, aparecer en las cadenas seleccionadas en sus fragmentos correspondientes), o todos quedar hu√©rfanos. (es decir, no aparece en las cadenas seleccionadas en sus fragmentos correspondientes).  Dado que, en general, la probabilidad de que los fragmentos se corrompan no es insignificante, no podemos suponer que las horquillas no suceder√°n incluso si se alcanza un consenso bizantino entre los validadores de fragmentos, o si se produjeron muchos bloques en la parte superior del bloque con el cambio de estado . </p><br><p>  Este problema tiene m√∫ltiples soluciones, la m√°s com√∫n es la reticulaci√≥n ocasional del √∫ltimo bloque de cadena de fragmentos con la cadena de baliza.  La regla de elecci√≥n de la bifurcaci√≥n en las cadenas de fragmentos se cambia para preferir siempre la cadena que est√° entrecruzada, y solo aplica la regla de elecci√≥n de la bifurcaci√≥n espec√≠fica de fragmento para los bloques que se publicaron desde el √∫ltimo enlace cruzado. </p><br><h3 id="approving-invalid-blocks">  Aprobar bloques inv√°lidos </h3><br><p>  Un conjunto de validadores podr√≠a intentar crear un bloque que aplique la funci√≥n de transici√≥n de estado incorrectamente.  Por ejemplo, comenzando con un estado en el que Alice tiene 10 tokens y Bob tiene 0 tokens, el bloque puede contener una transacci√≥n que env√≠a 10 tokens de Alice a Bob, pero termina con un estado en el que Alice tiene 0 tokens y Bob tiene 1000 fichas </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e68/edd/049/e68edd049344263dd671209a10be0890.png" alt="imagen"></p><br><p>  En una cadena de bloques cl√°sica no fragmentada, tal ataque no es posible, ya que todos los participantes en la red validan todos los bloques, y el bloque con una transici√≥n de estado no v√°lida ser√° rechazado por los otros productores de bloques y los participantes de la red. que no crean bloques  Incluso si los validadores maliciosos contin√∫an creando bloques encima de un bloque tan inv√°lido m√°s r√°pido que los validadores honestos construyen la cadena correcta, por lo que la cadena con el bloque inv√°lido es m√°s larga, no importa, ya que cada participante que est√° usando la cadena de bloques para cualquier prop√≥sito valida todos los bloques y descarta todos los bloques construidos encima del bloque no v√°lido. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c5/0a8/b45/1c50a8b45dfda77a14262225dc3351ca.png" alt="imagen"></p><br><p>  En la figura anterior hay cinco validadores, tres de los cuales son maliciosos.  Crearon un bloque no v√°lido A ', y luego continuaron construyendo nuevos bloques encima de √©l.  Dos validadores honestos descartaron A 'como inv√°lido y estaban construyendo sobre el √∫ltimo bloque v√°lido conocido por ellos, creando una bifurcaci√≥n.  Como hay menos validadores en la bifurcaci√≥n honesta, su cadena es m√°s corta.  Sin embargo, en la cadena de bloques cl√°sica no fragmentada, cada participante que usa blockchain para cualquier prop√≥sito es responsable de validar todos los bloques que reciben y volver a calcular el estado.  Por lo tanto, cualquier persona que tenga alg√∫n inter√©s en la cadena de bloques observar√° que A 'no es v√°lido y, por lo tanto, tambi√©n descartar√° inmediatamente B', C 'y D', por lo que tomar√° la cadena AB como la cadena v√°lida m√°s larga actual. </p><br><p>  Sin embargo, en una cadena de bloques fragmentada, ning√∫n participante puede validar todas las transacciones en todos los fragmentos, por lo que deben tener alguna forma de confirmar que en ning√∫n momento de la historia de cualquier fragmento de la cadena de bloques no se haya incluido ning√∫n bloque no v√°lido. </p><br><p>  Tenga en cuenta que, a diferencia de las horquillas, la reticulaci√≥n a la cadena Beacon no es una soluci√≥n suficiente, ya que la cadena Beacon no tiene la capacidad de validar los bloques.  Solo puede validar que un n√∫mero suficiente de validadores en ese fragmento firm√≥ el bloque (y como tal atestigu√≥ su correcci√≥n). </p><br><p>  Solo conozco dos soluciones a este problema, ninguna de las cuales es realmente satisfactoria hoy: </p><br><ol><li>  Tenga alg√∫n mecanismo razonable que alertar√° al sistema si se intenta aplicar la transici√≥n de estado de manera incorrecta.  Asumiendo que cada fragmento est√° ejecutando alg√∫n tipo de consenso BFT, mientras el n√∫mero de validadores maliciosos en un fragmento particular sea menor que ‚Öî, al menos un validador honesto necesitar√≠a dar fe de un bloque y verificar que la funci√≥n de transici√≥n de estado sea aplicado correctamente  Si m√°s de ‚Öî de los nodos son maliciosos, pueden finalizar un bloque sin la participaci√≥n de un solo nodo honesto.  Suponiendo que al menos un nodo en el fragmento no es malicioso, se necesita alg√∫n mecanismo que permita a dichos nodos monitorear qu√© bloques se est√°n produciendo y tener tiempo suficiente para desafiar a los nodos con una transici√≥n de estado no v√°lida. </li><li>  Tenga alguna informaci√≥n en los bloques que sea suficiente para demostrar que la transici√≥n de estado se aplica correctamente pero que es significativamente m√°s barata de validar que la aplicaci√≥n real de la funci√≥n de transici√≥n de estado.  El mecanismo m√°s cercano para lograrlo es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">zk-SNARKs</a> (aunque realmente no necesitamos la parte "zk", o conocimiento cero, una SNARK que no sea zk ser√≠a suficiente), pero los zk-SNARK son notoriamente lentos para calcular en este punto </li></ol><br><p>  En la actualidad, muchos protocolos suponen que con la rotaci√≥n adecuada del validador y un consenso tolerante a fallos bizantinos, no son posibles bifurcaciones ni transiciones de estado inv√°lidas.  La raz√≥n por la cual esta suposici√≥n no es razonable es un tema para un art√≠culo separado. </p><br><h2 id="outro">  Outro </h2><br><p>  Escribo mucho sobre blockchains y sharding, y tambi√©n tenemos una serie de videos donde hablamos con los fundadores de protocolos escalables, como Cosmos y Solana, con inmersiones profundas tecnol√≥gicas.  Puedes seguirme en twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437926/">https://habr.com/ru/post/437926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437914/index.html">Generaci√≥n de clases Jaxb (XJC) a partir del esquema XML (XSD) con descripciones de clase y campo en forma de anotaciones. Complemento XJC</a></li>
<li><a href="../437916/index.html">¬°Dale al lector de libros electr√≥nicos en cada bolsillo! Revisi√≥n de las √∫ltimas innovaciones de ONYX BOOX</a></li>
<li><a href="../437918/index.html">Grabaci√≥n de video con expulsi√≥n autom√°tica de pausa mediante software gratuito con construcci√≥n de bicicletas</a></li>
<li><a href="../437922/index.html">Modelo de ataque: donde se abusa principalmente en adquisiciones electr√≥nicas y c√≥mo tratarlo</a></li>
<li><a href="../437924/index.html">Fragmento de blockchain</a></li>
<li><a href="../437928/index.html">Como aprender ingles</a></li>
<li><a href="../437930/index.html">Combo de accesorios de iluminaci√≥n</a></li>
<li><a href="../437932/index.html">Intel Optane Memory H10: Optane Cache + QLC 3D NAND</a></li>
<li><a href="../437934/index.html">Gesti√≥n del tiempo en la vida real.</a></li>
<li><a href="../437936/index.html">Su plataforma de video es ffmpeg y calidad de codificaci√≥n de video. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>