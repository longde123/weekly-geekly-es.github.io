<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëΩ üóìÔ∏è üôÜüèø Teil 1. QInst: Es ist besser, einen Tag zu verlieren und dann in f√ºnf Minuten zu fliegen (Schreibger√§te sind trivial) üë©üèæ‚Äçü§ù‚Äçüë®üèΩ ü§≠ üßöüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im vorherigen Teil habe ich grob beschrieben, wie Sie eBPF-Funktionen aus einer ELF-Datei laden k√∂nnen. Jetzt ist es an der Zeit, von der Fantasie zu ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teil 1. QInst: Es ist besser, einen Tag zu verlieren und dann in f√ºnf Minuten zu fliegen (Schreibger√§te sind trivial)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452608/"><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teil habe</a> ich grob beschrieben, wie Sie eBPF-Funktionen aus einer ELF-Datei laden k√∂nnen.  Jetzt ist es an der Zeit, von der Fantasie zu sowjetischen Cartoons √ºberzugehen und nach einem gewissen Aufwand ein universelles Instrumentierungswerkzeug zu befolgen <del>  <em>(oder kurz UII !!!)</em> </del>  .  Dabei werde ich das Golden Hammer Antipattern-Design nutzen und ein Tool aus der relativ bekannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QEMU</a> erstellen.  Als Bonus erhalten wir architektur√ºbergreifende Instrumente sowie Instrumente auf der Ebene des gesamten virtuellen Computers.  Die Instrumentierung hat die Form ‚Äûeine kleine native So-Datei + eine kleine O-Datei mit eBPF‚Äú.  In diesem Fall werden eBPF-Funktionen vor den entsprechenden Anweisungen der internen Darstellung von QEMU vor der Optimierung und Codegenerierung ersetzt. </p><br><p> Infolgedessen sieht die Instrumentierung selbst, die <strong>w√§hrend der Codegenerierung hinzugef√ºgt wird</strong> (dh ohne ein paar Kilobyte der normalen Systemlaufzeit), folgenderma√üen aus, und dies ist <strong>kein</strong> Pseudocode: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Nun, es ist Zeit, unseren Elfen in die Matrix zu laden.  Nun, eher wie man herunterl√§dt <del>  klatschen </del>  spr√ºhen. </p><a name="habracut"></a><br><p>  Wie bereits im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel √ºber QEMU.js erw√§hnt</a> , ist einer der QEMU-Betriebsmodi die JIT-Generierung von Host-Maschinencode aus dem Gast (m√∂glicherweise f√ºr eine v√∂llig andere Architektur).  Wenn ich das letzte Mal mein Codegenerierungs-Backend implementiert habe, werde ich dieses Mal die interne Darstellung verarbeiten, indem ich direkt vor dem Optimierer klemme.  Ist das eine willk√ºrliche Entscheidung?  Nein.  Es besteht die Hoffnung, dass der Optimierer √ºbersch√ºssige Ecken abschneidet, unn√∂tige Variablen wegwirft usw.  Soweit ich wei√ü, macht er tats√§chlich einfache und schnell umsetzbare Dinge: Konstanten verschieben, Ausdr√ºcke wie ‚Äûx: = x + 0‚Äú ausgeben und nicht erreichbaren Code l√∂schen.  Und wir k√∂nnen eine anst√§ndige Menge davon bekommen. </p><br><h1 id="konfiguraciya-sborochnyh-skriptov">  Konfiguration des Assemblerskripts </h1><br><p>  <code>tcg/bpf-loader.c</code> unsere Quelldateien hinzu: <code>tcg/bpf-loader.c</code> und <code>tcg/instrument.c</code> zu den Makefiles.  Im Allgemeinen besteht der Wunsch, dies eines Tages in den Upstream zu verschieben, sodass Sie dies am Ende mit Bedacht tun m√ºssen, aber im Moment werde ich diese Dateien nur bedingungslos zur Assembly hinzuf√ºgen.  Und ich werde die Parameter in den besten Traditionen der AFL √ºbernehmen - durch Umgebungsvariablen.  √úbrigens werde ich dies noch einmal an der Instrumentierung f√ºr AFL testen. </p><br><p>  Suchen Sie einfach nach der Erw√§hnung des "Nachbarn" - der Datei <code>optimize.c</code> mit <code>grep -R</code> und wir werden nichts finden.  Weil es notwendig war, nach <code>optimize.o</code> zu suchen: </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/Makefile.target +++ b/Makefile.target @@ -110,7 +110,7 @@ obj-y += trace/ obj-y += exec.o obj-y += accel/ obj-$(CONFIG_TCG) += tcg/tcg.o tcg/tcg-op.o tcg/tcg-op-vec.o tcg/tcg-op-gvec.o -obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o +obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o tcg/instrument.o tcg/bpf-loader.o obj-$(CONFIG_TCG_INTERPRETER) += tcg/tci.o obj-$(CONFIG_TCG_INTERPRETER) += disas/tci.o obj-$(CONFIG_TCG) += fpu/softfloat.o</span></span></code> </pre> <br><h1 id="tak-vot-ty-kakoe-metaprogrammirovanie-na-c">  Also hier sind Sie, Metaprogrammierung in C ... </h1><br><p>  <code>bpf-loader.c</code> aus der letzten Serie mit Code hinzu, der Einstiegspunkte f√ºr QEMU-Operationen herauszieht.  Und die mysteri√∂se Datei <code>tcg-opc.h</code> wird uns dabei helfen.  Es sieht so aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * DEF(name, oargs, iargs, cargs, flags) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* predefined ops */</span></span> DEF(discard, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TCG_OPF_NOT_PRESENT) DEF(set_label, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT) <span class="hljs-comment"><span class="hljs-comment">/* variable number of parameters */</span></span> DEF(call, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, TCG_OPF_CALL_CLOBBER | TCG_OPF_NOT_PRESENT) DEF(br, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END) <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Was f√ºr ein Unsinn?  Und die Sache ist einfach, dass es nicht im Quellheader verbunden ist - Sie m√ºssen das <code>DEF</code> Makro definieren, diese Datei einschlie√üen und das Makro sofort l√∂schen.  Sehen Sie, er hat nicht einmal Wache. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *inst_function_names[] = { #define DEF(name, a, b, c, d) stringify(inst_qemu_##name), #include <span class="hljs-string"><span class="hljs-string">"tcg-opc.h"</span></span> #undef DEF <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre> <br><p>  Als Ergebnis erhalten wir ein ordentliches Array von Zielfunktionsnamen, die durch Opcodes indiziert sind und mit NULL enden, die wir f√ºr jedes Zeichen in der Datei ausf√ºhren k√∂nnen.  Ich verstehe, dass dies nicht effektiv ist.  Aber es ist einfach, was angesichts des einmaligen Charakters dieser Operation wichtig ist.  Als n√§chstes √ºberspringen wir einfach alle Zeichen, f√ºr die </p><br><pre> <code class="cpp hljs">ELF64_ST_BIND(sym-&gt;st_info) == STB_LOCAL || ELF64_ST_TYPE(sym-&gt;st_info) != STT_FUNC</code> </pre> <br><p>  Der Rest wird mit der Liste verglichen. </p><br><h1 id="privyazyvaemsya-k-potoku-vypolneniya">  Wir sind an einen Ausf√ºhrungsfluss gebunden </h1><br><p>  Jetzt m√ºssen Sie irgendwo im Ablauf des Codegenerierungsmechanismus aufstehen und warten, bis die interessierende Anweisung vergeht.  Aber zuerst m√ºssen Sie Ihre Funktionen <code>instrumentation_init</code> , <code>tcg_instrument</code> und <code>instrumentation_shutdown</code> in der <code>tcg/tcg.h</code> und ihre Aufrufe notieren: Initialisierung - nachdem das Backend initialisiert wurde, instrumentation - unmittelbar vor dem Aufruf von <code>tcg_optimize</code> .  Es scheint, dass <code>instrumentation_shutdown</code> in <code>instrumentation_init</code> auf <code>atexit</code> und nicht in die H√∂he <code>atexit</code> werden kann.  Ich dachte auch, und h√∂chstwahrscheinlich wird es im vollst√§ndigen <code>_exit</code> funktionieren, aber im Usermode-Emulationsmodus √ºbersetzt QEMU die <code>exit_group</code> und beendet manchmal den Funktionsaufruf <code>_exit</code> , der alle diese atexit-Handler ignoriert. Daher werden wir in <code>linux-user/syscall.c</code> und <code>linux-user/syscall.c</code> Aufruf in unseren Code davor <code>linux-user/syscall.c</code> . </p><br><h1 id="interpretiruem-baytkod">  Bytecode interpretieren </h1><br><p>  Es ist also Zeit zu lesen, was der Compiler f√ºr uns generiert hat.  Dies geschieht bequemerweise mit <code>llvm-objdump</code> mit der Option <code>-x</code> oder besser sofort mit <code>-d -t -r</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Ausgabebeispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./compile-bpf.sh test-bpf.o: file format ELF64-BPF Disassembly of section .text: 0000000000000000 inst_brcond_i64: 0: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000000: R_BPF_64_64 prev 2: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 3: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 4: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 5: af 13 00 00 00 00 00 00 r3 ^= r1 6: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 7: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 0000000000000038: R_BPF_64_64 __afl_area_ptr 9: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 10: 0f 34 00 00 00 00 00 00 r4 += r3 11: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 12: 07 03 00 00 01 00 00 00 r3 += 1 13: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 14: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 15: 95 00 00 00 00 00 00 00 exit 0000000000000080 inst_brcond_i32: 16: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000080: R_BPF_64_64 prev 18: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 19: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 20: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 21: af 13 00 00 00 00 00 00 r3 ^= r1 22: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 23: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 00000000000000b8: R_BPF_64_64 __afl_area_ptr 25: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 26: 0f 34 00 00 00 00 00 00 r4 += r3 27: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 28: 07 03 00 00 01 00 00 00 r3 += 1 29: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 30: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 31: 95 00 00 00 00 00 00 00 exit SYMBOL TABLE: 0000000000000000 l df *ABS* 00000000 test-bpf.c 0000000000000000 ld .text 00000000 .text 0000000000000000 *UND* 00000000 __afl_area_ptr 0000000000000080 g F .text 00000080 inst_brcond_i32 0000000000000000 g F .text 00000080 inst_brcond_i64 0000000000000008 g O *COM* 00000008 prev</code> </pre> </div></div><br><p>  Wenn Sie versuchen, nach einer Beschreibung der eBPF-Opcodes zu suchen, werden Sie feststellen, dass an offensichtlichen Stellen (Quell- und Manpages des Linux-Kernels) Beschreibungen zu deren Verwendung, Kompilierung usw. vorhanden sind.  Dann sto√üen Sie auf die <a href="">Seite</a> des iovisor-Toolteams mit einer praktischen inoffiziellen eBPF-Referenz. </p><br><p>  Der Befehl belegt ein 64-Bit-Wort (etwa zwei) und hat die Form </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dst:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> src:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> imm; };</code> </pre> <br><p>  Diejenigen, die zwei W√∂rter belegen, bestehen einfach aus der ersten Anweisung mit der gesamten Logik und einem ‚ÄûTrailer‚Äú mit 32 weiteren Bits von unmittelbarem Wert und sind auf dem objdump-Disassembler sehr deutlich sichtbar. </p><br><p>  Die Opcodes selbst haben ebenfalls eine regul√§re Struktur: Die unteren drei Bits sind die Operationsklasse: 32-Bit-ALU, 64-Bit-ALU, Laden / Speichern, bedingte Verzweigung.  Daher ist es sehr praktisch, sie in Makros in den besten Traditionen von QEMU zu implementieren.  Ich werde keine detaillierten Anweisungen auf der Codebasis durchf√ºhren <del>  Wir sind nicht auf Code-√úberpr√ºfung </del>  Ich erz√§hle Ihnen besser von den Fallstricken. </p><br><p>  Mein erstes Problem war, dass ich einen faulen eBPF-Registerzuweiser in Form von QEMU- <code>local_temp</code> und den Aufruf dieser Funktion gedankenlos an das Makro √ºbertragen habe.  Es stellte sich wie in einem ber√ºhmten Mem heraus: "Wir haben eine Abstraktion in eine Abstraktion eingef√ºgt, damit Sie eine Anweisung generieren k√∂nnen, w√§hrend Sie eine Anweisung generieren."  Post factum verstehe ich schon nicht sehr gut, was damals kaputt war, aber mit der Reihenfolge der generierten Anweisungen passierte anscheinend etwas Seltsames.  Danach habe ich Analoga der Funktionen <code>tcg_gen_...</code> , um neue Anweisungen in die Mitte der Liste zu verschieben, wobei Operanden als Argumente f√ºr die Funktion verwendet wurden, und die Reihenfolge wurde automatisch so, wie sie sollte (da die Argumente genau einmal vor dem Aufruf vollst√§ndig berechnet wurden). </p><br><p>  Das zweite Problem bestand darin, die TCG-Konstante als Operanden einer beliebigen Anweisung zu verschieben, wenn der unmittelbare Operand in eBPF betrachtet wurde.  Bei der Aufforderung zur bereits erw√§hnten <code>tcg-opc.h</code> ist die Zusammensetzung der Argumentliste der Operation streng festgelegt: <code>n</code> Eingabeargumente, <code>m</code> Ausgabe und <code>k</code> Konstante.  √úbrigens hilft es beim Debuggen eines solchen Codes, QEMU das Befehlszeilenargument <code>-d op,op_opt</code> oder sogar <code>-d op,op_opt,out_asm</code> . </p><br><div class="spoiler">  <b class="spoiler_title">M√∂gliche Argumente</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./x86_64-linux-user/qemu-x86_64 -d help Log items (comma separated): out_asm show generated host assembly code for each compiled TB in_asm show target assembly code for each compiled TB op show micro ops for each compiled TB op_opt show micro ops after optimization op_ind show micro ops before indirect lowering int show interrupts/exceptions in short format exec show trace before each executed TB (lots of logs) cpu show CPU registers before entering a TB (lots of logs) fpu include FPU registers in the 'cpu' logging mmu log MMU-related activities pcall x86 only: show protected mode far calls/returns/exceptions cpu_reset show CPU state before CPU resets unimp log unimplemented functionality guest_errors log when the guest OS does something invalid (eg accessing a non-existent register) page dump pages at beginning of user mode emulation nochain do not chain compiled TBs so that "exec" and "cpu" show complete traces trace:PATTERN enable trace events Use "-d trace:help" to get a list of trace events.</code> </pre> </div></div><br><p>  Wiederholen Sie meine Fehler nicht: Der Disassembler f√ºr interne Anweisungen ist ziemlich weit fortgeschritten. Wenn Sie so etwas wie <code>add_i64 loc15,loc15,$554412123213</code> , ist dieses Ding nach dem Dollarzeichen kein Zeiger.  Genauer gesagt ist dies nat√ºrlich ein Zeiger, der jedoch m√∂glicherweise mit Flags und in der Rolle des Literalwerts des Operanden und nicht des Zeigers aufgeh√§ngt ist.  All dies gilt nat√ºrlich, wenn Sie wissen, dass es eine bestimmte Zahl wie <code>$0</code> oder <code>$ff</code> , m√ºssen Sie sich √ºberhaupt nicht vor Zeigern f√ºrchten.  :) Wie man damit <code>movi</code> - Sie m√ºssen nur eine Funktion erstellen, die eine neue <code>movi</code> , in die durch <code>movi</code> die gew√ºnschte Konstante gesetzt wird. </p><br><p>  √úbrigens, wenn Sie <code>#define USE_TCG_OPTIMIZATIONS</code> im <code>tcg/tcg.c</code> <code>#define USE_TCG_OPTIMIZATIONS</code> <code>tcg/tcg.c</code> , wird die Optimierung pl√∂tzlich <code>tcg/tcg.c</code> und es ist einfacher, <code>tcg/tcg.c</code> zu analysieren. </p><br><p>  F√ºr sim werde ich einen Leser schicken, der daran interessiert ist, QEMU in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation aufzunehmen</a> , sogar die offizielle!  Im √úbrigen werde ich die versprochene Instrumentierung f√ºr AFL demonstrieren. </p><br><h1 id="te-zhe-i-krolik">  Das gleiche und das Kaninchen </h1><br><p>  F√ºr den vollst√§ndigen Text der Laufzeit werde ich den Leser erneut an das Repository senden, da er (der Text) nicht von k√ºnstlerischem Wert ist und ehrlich aus <code>qemu_mode</code> aus der AFL-Lieferung geh√§rtet wird und im Allgemeinen ein regul√§rer Teil des C-Codes ist. Aber so sieht die Instrumentierung selbst aus :: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Es ist wichtig, dass Hook-Funktionen so viele Argumente wie <code>iargs</code> f√ºr die entsprechende QEMU-Operation haben.  Zwei <code>extern</code> im Header werden w√§hrend des Verschiebungsprozesses mit der Laufzeit verkn√ºpft.  Im Prinzip k√∂nnte <code>prev</code> genau hier definiert werden, aber dann muss es als <code>static</code> definiert werden, sonst f√§llt es in den GEMEINSAMEN Abschnitt, den ich nicht unterst√ºtze.  Eigentlich haben wir den Pseudocode einfach aus der Dokumentation umgeschrieben, aber hier ist er maschinenlesbar! </p><br><p>  Erstellen Sie zur <code>bug.c</code> Datei <code>bug.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { char buf[16]; int res = read(0, buf, 4); if (buf[0] == 'T' &amp;&amp; buf[1] == 'E' &amp;&amp; buf[2] == 'S' &amp;&amp; buf[3] == 'T') abort(); return res * 0; }</span></span></span></span></code> </pre> <br><p>  Und auch - <code>forksrv</code> Datei, die bequem ist, um AFL zu f√ºttern: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash export NATIVE_INST=./instrumentation-examples/afl/afl-native.so export BPF_INST=./instrumentation-examples/afl/afl-bpf.co exec ./x86_64-linux-user/qemu-x86_64 ./instrumentation-examples/afl/bug</span></span></code> </pre> <br><p>  Und laufen Sie Fuzzing: </p><br><pre> <code class="bash hljs">AFL_SKIP_BIN_CHECK=1 afl-fuzz -i ../input -o ../output -m none -- ./forksrv</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Amerikanischer Fuzzy Lop</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1234 T234 TE34 TES4 TEST &lt;-     crashes,    2200  </code> </pre> </div></div><br><p>  Bisher ist die Geschwindigkeit nicht so hoch, aber als Entschuldigung <code>qemu_mode</code> ich sagen, dass hier ( <code>qemu_mode</code> ) ein wichtiges Merkmal des urspr√ºnglichen <code>qemu_mode</code> nicht verwendet wird: das Senden von Adressen mit ausf√ºhrbarem Code an den Fork-Server.  Aber es gibt jetzt nichts AFL in der QEMU-Codebasis, und es besteht die Hoffnung, dass diese verallgemeinerte Instrumentierung eines Tages in den Upstream gesteckt wird. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Projekt</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452608/">https://habr.com/ru/post/de452608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452592/index.html">Teil 0. Erfordert, dass ein Elf in der Matrix arbeitet. Umzug ist m√∂glich</a></li>
<li><a href="../de452596/index.html">735.000 IPv4-Adressen wurden von einem Betr√ºger √ºbernommen und an die Registrierung zur√ºckgegeben</a></li>
<li><a href="../de452598/index.html">Management eines Programmierteams: Wie und wie kann man sie richtig motivieren? Teil eins</a></li>
<li><a href="../de452602/index.html">Cisco Hyperflex f√ºr Datenbankmanagementsysteme mit hoher Auslastung</a></li>
<li><a href="../de452606/index.html">UDB. Was ist das Teil 8. Adressierung von UDB</a></li>
<li><a href="../de452610/index.html">Hilfe und Bitte f√ºr sie. Artikel √ºber Informationssicherheit f√ºr normale Benutzer</a></li>
<li><a href="../de452612/index.html">Verst√§rktes maschinelles Lernen in tiefen neuronalen Netzen auf tensorflow.js: Tricks</a></li>
<li><a href="../de452614/index.html">So starten Sie die Programmierung in Adobe Illustrator. Teil zwei</a></li>
<li><a href="../de452618/index.html">Was auf Google I / O 2019 gesagt wurde: Android 10, AR-Anwendungen und vieles mehr</a></li>
<li><a href="../de452620/index.html">Ableiten eines Aktionstyps mithilfe von Typescript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>