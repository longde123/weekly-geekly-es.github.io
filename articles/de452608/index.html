<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👽 🗓️ 🙆🏿 Teil 1. QInst: Es ist besser, einen Tag zu verlieren und dann in fünf Minuten zu fliegen (Schreibgeräte sind trivial) 👩🏾‍🤝‍👨🏽 🤭 🧚🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im vorherigen Teil habe ich grob beschrieben, wie Sie eBPF-Funktionen aus einer ELF-Datei laden können. Jetzt ist es an der Zeit, von der Fantasie zu ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teil 1. QInst: Es ist besser, einen Tag zu verlieren und dann in fünf Minuten zu fliegen (Schreibgeräte sind trivial)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452608/"><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Teil habe</a> ich grob beschrieben, wie Sie eBPF-Funktionen aus einer ELF-Datei laden können.  Jetzt ist es an der Zeit, von der Fantasie zu sowjetischen Cartoons überzugehen und nach einem gewissen Aufwand ein universelles Instrumentierungswerkzeug zu befolgen <del>  <em>(oder kurz UII !!!)</em> </del>  .  Dabei werde ich das Golden Hammer Antipattern-Design nutzen und ein Tool aus der relativ bekannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QEMU</a> erstellen.  Als Bonus erhalten wir architekturübergreifende Instrumente sowie Instrumente auf der Ebene des gesamten virtuellen Computers.  Die Instrumentierung hat die Form „eine kleine native So-Datei + eine kleine O-Datei mit eBPF“.  In diesem Fall werden eBPF-Funktionen vor den entsprechenden Anweisungen der internen Darstellung von QEMU vor der Optimierung und Codegenerierung ersetzt. </p><br><p> Infolgedessen sieht die Instrumentierung selbst, die <strong>während der Codegenerierung hinzugefügt wird</strong> (dh ohne ein paar Kilobyte der normalen Systemlaufzeit), folgendermaßen aus, und dies ist <strong>kein</strong> Pseudocode: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Nun, es ist Zeit, unseren Elfen in die Matrix zu laden.  Nun, eher wie man herunterlädt <del>  klatschen </del>  sprühen. </p><a name="habracut"></a><br><p>  Wie bereits im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel über QEMU.js erwähnt</a> , ist einer der QEMU-Betriebsmodi die JIT-Generierung von Host-Maschinencode aus dem Gast (möglicherweise für eine völlig andere Architektur).  Wenn ich das letzte Mal mein Codegenerierungs-Backend implementiert habe, werde ich dieses Mal die interne Darstellung verarbeiten, indem ich direkt vor dem Optimierer klemme.  Ist das eine willkürliche Entscheidung?  Nein.  Es besteht die Hoffnung, dass der Optimierer überschüssige Ecken abschneidet, unnötige Variablen wegwirft usw.  Soweit ich weiß, macht er tatsächlich einfache und schnell umsetzbare Dinge: Konstanten verschieben, Ausdrücke wie „x: = x + 0“ ausgeben und nicht erreichbaren Code löschen.  Und wir können eine anständige Menge davon bekommen. </p><br><h1 id="konfiguraciya-sborochnyh-skriptov">  Konfiguration des Assemblerskripts </h1><br><p>  <code>tcg/bpf-loader.c</code> unsere Quelldateien hinzu: <code>tcg/bpf-loader.c</code> und <code>tcg/instrument.c</code> zu den Makefiles.  Im Allgemeinen besteht der Wunsch, dies eines Tages in den Upstream zu verschieben, sodass Sie dies am Ende mit Bedacht tun müssen, aber im Moment werde ich diese Dateien nur bedingungslos zur Assembly hinzufügen.  Und ich werde die Parameter in den besten Traditionen der AFL übernehmen - durch Umgebungsvariablen.  Übrigens werde ich dies noch einmal an der Instrumentierung für AFL testen. </p><br><p>  Suchen Sie einfach nach der Erwähnung des "Nachbarn" - der Datei <code>optimize.c</code> mit <code>grep -R</code> und wir werden nichts finden.  Weil es notwendig war, nach <code>optimize.o</code> zu suchen: </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/Makefile.target +++ b/Makefile.target @@ -110,7 +110,7 @@ obj-y += trace/ obj-y += exec.o obj-y += accel/ obj-$(CONFIG_TCG) += tcg/tcg.o tcg/tcg-op.o tcg/tcg-op-vec.o tcg/tcg-op-gvec.o -obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o +obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o tcg/instrument.o tcg/bpf-loader.o obj-$(CONFIG_TCG_INTERPRETER) += tcg/tci.o obj-$(CONFIG_TCG_INTERPRETER) += disas/tci.o obj-$(CONFIG_TCG) += fpu/softfloat.o</span></span></code> </pre> <br><h1 id="tak-vot-ty-kakoe-metaprogrammirovanie-na-c">  Also hier sind Sie, Metaprogrammierung in C ... </h1><br><p>  <code>bpf-loader.c</code> aus der letzten Serie mit Code hinzu, der Einstiegspunkte für QEMU-Operationen herauszieht.  Und die mysteriöse Datei <code>tcg-opc.h</code> wird uns dabei helfen.  Es sieht so aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * DEF(name, oargs, iargs, cargs, flags) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* predefined ops */</span></span> DEF(discard, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TCG_OPF_NOT_PRESENT) DEF(set_label, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT) <span class="hljs-comment"><span class="hljs-comment">/* variable number of parameters */</span></span> DEF(call, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, TCG_OPF_CALL_CLOBBER | TCG_OPF_NOT_PRESENT) DEF(br, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END) <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Was für ein Unsinn?  Und die Sache ist einfach, dass es nicht im Quellheader verbunden ist - Sie müssen das <code>DEF</code> Makro definieren, diese Datei einschließen und das Makro sofort löschen.  Sehen Sie, er hat nicht einmal Wache. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *inst_function_names[] = { #define DEF(name, a, b, c, d) stringify(inst_qemu_##name), #include <span class="hljs-string"><span class="hljs-string">"tcg-opc.h"</span></span> #undef DEF <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre> <br><p>  Als Ergebnis erhalten wir ein ordentliches Array von Zielfunktionsnamen, die durch Opcodes indiziert sind und mit NULL enden, die wir für jedes Zeichen in der Datei ausführen können.  Ich verstehe, dass dies nicht effektiv ist.  Aber es ist einfach, was angesichts des einmaligen Charakters dieser Operation wichtig ist.  Als nächstes überspringen wir einfach alle Zeichen, für die </p><br><pre> <code class="cpp hljs">ELF64_ST_BIND(sym-&gt;st_info) == STB_LOCAL || ELF64_ST_TYPE(sym-&gt;st_info) != STT_FUNC</code> </pre> <br><p>  Der Rest wird mit der Liste verglichen. </p><br><h1 id="privyazyvaemsya-k-potoku-vypolneniya">  Wir sind an einen Ausführungsfluss gebunden </h1><br><p>  Jetzt müssen Sie irgendwo im Ablauf des Codegenerierungsmechanismus aufstehen und warten, bis die interessierende Anweisung vergeht.  Aber zuerst müssen Sie Ihre Funktionen <code>instrumentation_init</code> , <code>tcg_instrument</code> und <code>instrumentation_shutdown</code> in der <code>tcg/tcg.h</code> und ihre Aufrufe notieren: Initialisierung - nachdem das Backend initialisiert wurde, instrumentation - unmittelbar vor dem Aufruf von <code>tcg_optimize</code> .  Es scheint, dass <code>instrumentation_shutdown</code> in <code>instrumentation_init</code> auf <code>atexit</code> und nicht in die Höhe <code>atexit</code> werden kann.  Ich dachte auch, und höchstwahrscheinlich wird es im vollständigen <code>_exit</code> funktionieren, aber im Usermode-Emulationsmodus übersetzt QEMU die <code>exit_group</code> und beendet manchmal den Funktionsaufruf <code>_exit</code> , der alle diese atexit-Handler ignoriert. Daher werden wir in <code>linux-user/syscall.c</code> und <code>linux-user/syscall.c</code> Aufruf in unseren Code davor <code>linux-user/syscall.c</code> . </p><br><h1 id="interpretiruem-baytkod">  Bytecode interpretieren </h1><br><p>  Es ist also Zeit zu lesen, was der Compiler für uns generiert hat.  Dies geschieht bequemerweise mit <code>llvm-objdump</code> mit der Option <code>-x</code> oder besser sofort mit <code>-d -t -r</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Ausgabebeispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./compile-bpf.sh test-bpf.o: file format ELF64-BPF Disassembly of section .text: 0000000000000000 inst_brcond_i64: 0: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000000: R_BPF_64_64 prev 2: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 3: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 4: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 5: af 13 00 00 00 00 00 00 r3 ^= r1 6: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 7: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 0000000000000038: R_BPF_64_64 __afl_area_ptr 9: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 10: 0f 34 00 00 00 00 00 00 r4 += r3 11: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 12: 07 03 00 00 01 00 00 00 r3 += 1 13: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 14: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 15: 95 00 00 00 00 00 00 00 exit 0000000000000080 inst_brcond_i32: 16: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000080: R_BPF_64_64 prev 18: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 19: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 20: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 21: af 13 00 00 00 00 00 00 r3 ^= r1 22: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 23: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 00000000000000b8: R_BPF_64_64 __afl_area_ptr 25: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 26: 0f 34 00 00 00 00 00 00 r4 += r3 27: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 28: 07 03 00 00 01 00 00 00 r3 += 1 29: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 30: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 31: 95 00 00 00 00 00 00 00 exit SYMBOL TABLE: 0000000000000000 l df *ABS* 00000000 test-bpf.c 0000000000000000 ld .text 00000000 .text 0000000000000000 *UND* 00000000 __afl_area_ptr 0000000000000080 g F .text 00000080 inst_brcond_i32 0000000000000000 g F .text 00000080 inst_brcond_i64 0000000000000008 g O *COM* 00000008 prev</code> </pre> </div></div><br><p>  Wenn Sie versuchen, nach einer Beschreibung der eBPF-Opcodes zu suchen, werden Sie feststellen, dass an offensichtlichen Stellen (Quell- und Manpages des Linux-Kernels) Beschreibungen zu deren Verwendung, Kompilierung usw. vorhanden sind.  Dann stoßen Sie auf die <a href="">Seite</a> des iovisor-Toolteams mit einer praktischen inoffiziellen eBPF-Referenz. </p><br><p>  Der Befehl belegt ein 64-Bit-Wort (etwa zwei) und hat die Form </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dst:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> src:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> imm; };</code> </pre> <br><p>  Diejenigen, die zwei Wörter belegen, bestehen einfach aus der ersten Anweisung mit der gesamten Logik und einem „Trailer“ mit 32 weiteren Bits von unmittelbarem Wert und sind auf dem objdump-Disassembler sehr deutlich sichtbar. </p><br><p>  Die Opcodes selbst haben ebenfalls eine reguläre Struktur: Die unteren drei Bits sind die Operationsklasse: 32-Bit-ALU, 64-Bit-ALU, Laden / Speichern, bedingte Verzweigung.  Daher ist es sehr praktisch, sie in Makros in den besten Traditionen von QEMU zu implementieren.  Ich werde keine detaillierten Anweisungen auf der Codebasis durchführen <del>  Wir sind nicht auf Code-Überprüfung </del>  Ich erzähle Ihnen besser von den Fallstricken. </p><br><p>  Mein erstes Problem war, dass ich einen faulen eBPF-Registerzuweiser in Form von QEMU- <code>local_temp</code> und den Aufruf dieser Funktion gedankenlos an das Makro übertragen habe.  Es stellte sich wie in einem berühmten Mem heraus: "Wir haben eine Abstraktion in eine Abstraktion eingefügt, damit Sie eine Anweisung generieren können, während Sie eine Anweisung generieren."  Post factum verstehe ich schon nicht sehr gut, was damals kaputt war, aber mit der Reihenfolge der generierten Anweisungen passierte anscheinend etwas Seltsames.  Danach habe ich Analoga der Funktionen <code>tcg_gen_...</code> , um neue Anweisungen in die Mitte der Liste zu verschieben, wobei Operanden als Argumente für die Funktion verwendet wurden, und die Reihenfolge wurde automatisch so, wie sie sollte (da die Argumente genau einmal vor dem Aufruf vollständig berechnet wurden). </p><br><p>  Das zweite Problem bestand darin, die TCG-Konstante als Operanden einer beliebigen Anweisung zu verschieben, wenn der unmittelbare Operand in eBPF betrachtet wurde.  Bei der Aufforderung zur bereits erwähnten <code>tcg-opc.h</code> ist die Zusammensetzung der Argumentliste der Operation streng festgelegt: <code>n</code> Eingabeargumente, <code>m</code> Ausgabe und <code>k</code> Konstante.  Übrigens hilft es beim Debuggen eines solchen Codes, QEMU das Befehlszeilenargument <code>-d op,op_opt</code> oder sogar <code>-d op,op_opt,out_asm</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Mögliche Argumente</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./x86_64-linux-user/qemu-x86_64 -d help Log items (comma separated): out_asm show generated host assembly code for each compiled TB in_asm show target assembly code for each compiled TB op show micro ops for each compiled TB op_opt show micro ops after optimization op_ind show micro ops before indirect lowering int show interrupts/exceptions in short format exec show trace before each executed TB (lots of logs) cpu show CPU registers before entering a TB (lots of logs) fpu include FPU registers in the 'cpu' logging mmu log MMU-related activities pcall x86 only: show protected mode far calls/returns/exceptions cpu_reset show CPU state before CPU resets unimp log unimplemented functionality guest_errors log when the guest OS does something invalid (eg accessing a non-existent register) page dump pages at beginning of user mode emulation nochain do not chain compiled TBs so that "exec" and "cpu" show complete traces trace:PATTERN enable trace events Use "-d trace:help" to get a list of trace events.</code> </pre> </div></div><br><p>  Wiederholen Sie meine Fehler nicht: Der Disassembler für interne Anweisungen ist ziemlich weit fortgeschritten. Wenn Sie so etwas wie <code>add_i64 loc15,loc15,$554412123213</code> , ist dieses Ding nach dem Dollarzeichen kein Zeiger.  Genauer gesagt ist dies natürlich ein Zeiger, der jedoch möglicherweise mit Flags und in der Rolle des Literalwerts des Operanden und nicht des Zeigers aufgehängt ist.  All dies gilt natürlich, wenn Sie wissen, dass es eine bestimmte Zahl wie <code>$0</code> oder <code>$ff</code> , müssen Sie sich überhaupt nicht vor Zeigern fürchten.  :) Wie man damit <code>movi</code> - Sie müssen nur eine Funktion erstellen, die eine neue <code>movi</code> , in die durch <code>movi</code> die gewünschte Konstante gesetzt wird. </p><br><p>  Übrigens, wenn Sie <code>#define USE_TCG_OPTIMIZATIONS</code> im <code>tcg/tcg.c</code> <code>#define USE_TCG_OPTIMIZATIONS</code> <code>tcg/tcg.c</code> , wird die Optimierung plötzlich <code>tcg/tcg.c</code> und es ist einfacher, <code>tcg/tcg.c</code> zu analysieren. </p><br><p>  Für sim werde ich einen Leser schicken, der daran interessiert ist, QEMU in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation aufzunehmen</a> , sogar die offizielle!  Im Übrigen werde ich die versprochene Instrumentierung für AFL demonstrieren. </p><br><h1 id="te-zhe-i-krolik">  Das gleiche und das Kaninchen </h1><br><p>  Für den vollständigen Text der Laufzeit werde ich den Leser erneut an das Repository senden, da er (der Text) nicht von künstlerischem Wert ist und ehrlich aus <code>qemu_mode</code> aus der AFL-Lieferung gehärtet wird und im Allgemeinen ein regulärer Teil des C-Codes ist. Aber so sieht die Instrumentierung selbst aus :: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Es ist wichtig, dass Hook-Funktionen so viele Argumente wie <code>iargs</code> für die entsprechende QEMU-Operation haben.  Zwei <code>extern</code> im Header werden während des Verschiebungsprozesses mit der Laufzeit verknüpft.  Im Prinzip könnte <code>prev</code> genau hier definiert werden, aber dann muss es als <code>static</code> definiert werden, sonst fällt es in den GEMEINSAMEN Abschnitt, den ich nicht unterstütze.  Eigentlich haben wir den Pseudocode einfach aus der Dokumentation umgeschrieben, aber hier ist er maschinenlesbar! </p><br><p>  Erstellen Sie zur <code>bug.c</code> Datei <code>bug.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { char buf[16]; int res = read(0, buf, 4); if (buf[0] == 'T' &amp;&amp; buf[1] == 'E' &amp;&amp; buf[2] == 'S' &amp;&amp; buf[3] == 'T') abort(); return res * 0; }</span></span></span></span></code> </pre> <br><p>  Und auch - <code>forksrv</code> Datei, die bequem ist, um AFL zu füttern: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash export NATIVE_INST=./instrumentation-examples/afl/afl-native.so export BPF_INST=./instrumentation-examples/afl/afl-bpf.co exec ./x86_64-linux-user/qemu-x86_64 ./instrumentation-examples/afl/bug</span></span></code> </pre> <br><p>  Und laufen Sie Fuzzing: </p><br><pre> <code class="bash hljs">AFL_SKIP_BIN_CHECK=1 afl-fuzz -i ../input -o ../output -m none -- ./forksrv</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Amerikanischer Fuzzy Lop</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1234 T234 TE34 TES4 TEST &lt;-     crashes,    2200  </code> </pre> </div></div><br><p>  Bisher ist die Geschwindigkeit nicht so hoch, aber als Entschuldigung <code>qemu_mode</code> ich sagen, dass hier ( <code>qemu_mode</code> ) ein wichtiges Merkmal des ursprünglichen <code>qemu_mode</code> nicht verwendet wird: das Senden von Adressen mit ausführbarem Code an den Fork-Server.  Aber es gibt jetzt nichts AFL in der QEMU-Codebasis, und es besteht die Hoffnung, dass diese verallgemeinerte Instrumentierung eines Tages in den Upstream gesteckt wird. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Projekt</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452608/">https://habr.com/ru/post/de452608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452592/index.html">Teil 0. Erfordert, dass ein Elf in der Matrix arbeitet. Umzug ist möglich</a></li>
<li><a href="../de452596/index.html">735.000 IPv4-Adressen wurden von einem Betrüger übernommen und an die Registrierung zurückgegeben</a></li>
<li><a href="../de452598/index.html">Management eines Programmierteams: Wie und wie kann man sie richtig motivieren? Teil eins</a></li>
<li><a href="../de452602/index.html">Cisco Hyperflex für Datenbankmanagementsysteme mit hoher Auslastung</a></li>
<li><a href="../de452606/index.html">UDB. Was ist das Teil 8. Adressierung von UDB</a></li>
<li><a href="../de452610/index.html">Hilfe und Bitte für sie. Artikel über Informationssicherheit für normale Benutzer</a></li>
<li><a href="../de452612/index.html">Verstärktes maschinelles Lernen in tiefen neuronalen Netzen auf tensorflow.js: Tricks</a></li>
<li><a href="../de452614/index.html">So starten Sie die Programmierung in Adobe Illustrator. Teil zwei</a></li>
<li><a href="../de452618/index.html">Was auf Google I / O 2019 gesagt wurde: Android 10, AR-Anwendungen und vieles mehr</a></li>
<li><a href="../de452620/index.html">Ableiten eines Aktionstyps mithilfe von Typescript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>