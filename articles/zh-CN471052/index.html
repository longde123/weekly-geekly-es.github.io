<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📙 🕺 🖖🏻 我可以晕吗？ 受到通用类型编程的打击 🤫 🙅🏾 🏣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha 


 上一次，我们描述了“ Has模式”，概述了其解决的问题，并编写了一些特定的实例： 


 instance HasDbConfig AppConfig where getDbConfig = dbConfig instance HasWebServerConfig AppConfig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我可以晕吗？ 受到通用类型编程的打击</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471052/"><p> 哈Ha </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一次，</a>我们描述了“ <code>Has</code>模式”，概述了其解决的问题，并编写了一些特定的实例： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HasDbConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> getDbConfig = dbConfig <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">HasWebServerConfig</span></span> <span class="hljs-type"><span class="hljs-type">AppConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> getWebServerConfig = webServerConfig <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">HasCronConfig</span></span> <span class="hljs-type"><span class="hljs-type">AppConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> getCronConfig = cronConfig</code> </pre> <br><p> 看起来不错 这里会出现什么困难？ </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/821/f4f/397/821f4f397a69ccd020b677098f5ecaf7.jpg" alt="图片"></p><br><p> 好吧，让我们考虑一下我们可能还需要哪些其他实例。 首先，本身具有配置的具体类型是这些类型类的（简单）实现的良好候选者，这为我们提供了另外三个实例，其中每种方法都是通过<code>id</code>实现的，例如 </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HasDbConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> getDbConfig = id</code> </pre> <br><p> 它们使我们能够轻松编写独立于整个<code>AppConfig</code>单个测试或帮助程序实用程序。 </p><br><p> 这已经很无聊，但仍会继续。 可以想象，一些集成测试会检查一对模块的交互，而我们仍然不希望依赖于整个应用程序的配置，因此现在我们需要编写六个实例（每个类型两个），每个实例都将简化为<code>fst</code>或<code>snd</code> 。 例如，对于<code>DbConfig</code> ： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HasDbConfig</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> getDbConfig = fst <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">HasDbConfig</span></span> (a, <span class="hljs-type"><span class="hljs-type">DbConfig</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> getDbConfig = snd</code> </pre> <br><p> 恐怖片 希望我们永远不需要同时测试三个模块的操作-否则，您将不得不编写9个无聊的实例。 无论如何，我个人已经很不舒服，我宁愿花几个小时来自动执行此问题，也不希望花几分钟来编写额外的代码行。 </p><br><p> 此外，如果您对如何以一般方式解决此问题感兴趣，那么它是从属类型，以及最终看起来像Haskell-Welkom猫。 </p><a name="habracut"></a><br><h1 id="obobschaem-has-klass"> 总结<code>Has</code>类 </h1><br><p> 首先，请注意，对于不同的环境，我们有不同的类。 这可能会妨碍制定通用解决方案，因此我们在单独的参数中取出环境： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> part record </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract :: record -&gt; part</code> </pre> <br><p> 可以说， <code>Has part record</code>意味着可以从类型<code>record</code>的值中提取<code>part</code>类型的值。 用这些术语，我们好的旧式<code>HasDbConfig</code>变为<code>Has DbConfig</code> ，对于我们先前编写的其他类型类也是如此。 事实证明，这几乎是纯粹的语法变化，例如，上一篇文章中的一种函数的类型由 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doSmthWithDbAndCron</span></span> :: (<span class="hljs-type"><span class="hljs-type">MonadReader</span></span> rm, <span class="hljs-type"><span class="hljs-type">HasDbConfig</span></span> r, <span class="hljs-type"><span class="hljs-type">HasCronConfig</span></span> r) =&gt; ...</code> </pre> <br><p> 在 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doSmthWithDbAndCron</span></span> :: (<span class="hljs-type"><span class="hljs-type">MonadReader</span></span> rm, <span class="hljs-type"><span class="hljs-type">Has</span></span> <span class="hljs-type"><span class="hljs-type">DbConfig</span></span> r, <span class="hljs-type"><span class="hljs-type">Has</span></span> <span class="hljs-type"><span class="hljs-type">CronConfig</span></span> r) =&gt; ...</code> </pre> <br><p> 唯一的变化是在正确的位置有几个空格。 </p><br><p> 另外，我们在类型推断方面并没有损失太多：在实践中遇到的大多数情况下，计时器仍可以在周围的上下文中输出必要的<code>extract</code>返回值。 </p><br><p> 现在，我们不在乎特定的环境类型，让我们看看哪些记录可以为固定<code>part</code>实现“ <code>Has part record</code>类。 此任务具有良好的归纳结构： </p><br><ol><li> 每种类型都有它自己： <code>Has record record</code>方法很简单（ <code>extract = id</code> ）。 </li><li> 如果<code>record</code>是<code>rec1</code>和<code>rec2</code>类型的<code>rec1</code> ，则仅当<code>Has part rec1</code>或<code>Has part rec2</code>时，才实现<code>Has part record</code> 。 </li><li> 如果<code>record</code>是<code>rec1</code>和<code>rec2</code>类型的总和，则只有当<code>Has part rec1</code>和<code>Has part rec2</code> ，才<code>Has part record</code> 。 尽管在这种情况下这种情况的实际患病率并不明显，但出于完整性考虑，仍然值得一提。 </li></ol><br><p> 因此，看起来我们已经制定了算法的草图，可以自动确定是否<code>Has part record</code>为<code>part</code>实施了<code>part</code> <code>record</code>并<code>record</code>数据！ </p><br><p> 幸运的是，这种基于类型的归纳推理非常适合Haskell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">泛型</a>机制。 简而言之，泛型是Haskell中广义元编程的方法之一，这是由于观察到每种类型都是求和类型，乘积类型或具有一个字段的单构造基本类型。 </p><br><p> 我不会再编写有关泛型的教程，所以继续学习代码。 </p><br><h1 id="pervaya-popytka"> 第一次尝试 </h1><br><p> 我们将通过辅助类<code>GHas</code> <code>Has</code>的<code>Generic</code>实现的经典方法： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> part grecord </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract :: grecord p -&gt; part</code> </pre> <br><p>  <code>grecord</code>是我们<code>record</code>类型的<code>Generic</code>表示形式。 </p><br><p>  <code>GHas</code>实现遵循我们上面提到的归纳结构： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> record (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract (<span class="hljs-type"><span class="hljs-type">K1</span></span> x) = x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part record =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (<span class="hljs-type"><span class="hljs-type">M1</span></span> it record) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (<span class="hljs-type"><span class="hljs-type">M1</span></span> x) = gextract x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part l =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (l :*: _) = gextract l <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part r =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (_ :*: r) = gextract r</code> </pre> <br><ol><li>  <code>K1</code>对应于基本情况。 </li><li>  <code>M1</code>我们在任务中不需要的泛型特定元数据，因此我们只需忽略它们并遍历它们。 </li><li> 产品类型<code>l :*: r</code>的第一个实例对应于产品的“左”部分具有我们需要的类型<code>part</code>的值的情况（可能是递归的）。 </li><li> 类似地，产品类型<code>l :*: r</code>的第二种情况对应于产品的“右侧”部分具有类型<code>part</code>的期望值（自然，也可能递归）的情况。 </li></ol><br><p> 我们仅在这里支持产品类型。 我的主观印象是<code>MonadReader</code>和类似类的上下文中不经常使用金额，因此可以忽略它们以简化考虑。 </p><br><p> 此外，请注意每个 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhhFeDWUiCNSDS1LUz5mLoek5Yo3ag#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> n </script> 一元类型乘积<code>(a1, ..., an)</code>可以表示为组成 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.398ex" height="2.057ex" viewBox="0 -728.2 2323.9 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhhFeDWUiCNSDS1LUz5mLoek5Yo3ag#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhhFeDWUiCNSDS1LUz5mLoek5Yo3ag#MJMAIN-2212" x="822" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhhFeDWUiCNSDS1LUz5mLoek5Yo3ag#MJMAIN-31" x="1823" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>−</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> n-1 </script> 对<code>(a1, (a2, (a3, (..., an))))</code> ，所以我允许自己将产品类型与对关联。 </p><br><p> 使用我们的<code>GHas</code> ，您可以为<code>Has</code>编写一个使用泛型的默认实现： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> part record </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract :: record -&gt; part <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> extract :: <span class="hljs-type"><span class="hljs-type">Generic</span></span> record =&gt; record -&gt; part extract = gextract . from</code> </pre> <br><p> 做完了 </p><br><p> 还是不行 </p><br><h1 id="problema"> 问题 </h1><br><p> 如果我们尝试编译此代码，则即使没有尝试使用此实现（默认情况下也是如此）并报告那里的一些重叠实例，我们仍会看到它并没有解决问题。 更糟糕的是，这些实例在某些方面是相同的。 似乎是时候弄清楚Haskell中解析实例的机制如何工作了。 </p><br><p> 可以有 </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> context =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> barPattern bazPattern </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> ...</code> </pre> <br><p>  （顺便说一句， <code>=&gt;</code>之后的东西称为实例头。） </p><br><p> 读为 </p><br><blockquote> 让我们需要为<code>Foo bar baz</code>选择一个实例。  <em>如果</em>满足<code>context</code> ， <em>则</em>可以选择此实例，前提是<code>bar</code>和<code>baz</code>对应于<code>barPattern</code>和<code>bazPattern</code> 。 </blockquote><p> 但是，这是一种误解，而恰恰相反： </p><br><blockquote> 让我们需要为<code>Foo bar baz</code>选择一个实例。  <em>如果</em> <code>bar</code>和<code>baz</code>对应于<code>barPattern</code>和<code>bazPattern</code> ，那么我们选择此实例并将<code>context</code>添加到必须解析的常量列表中。 </blockquote><p> 现在很明显问题出在哪里。 让我们仔细看看以下两个实例： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> part l =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> part (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class"> :*: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract (l :*: _) = gextract l <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part r =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (_ :*: r) = gextract r</code> </pre> <br><p> 它们具有相同的实例头，所以难怪它们相交！ 此外，它们都不比其他更具体。 </p><br><p> 此外，无法以某种方式优化这些实例，以使其不再重叠。 好吧，除了添加更多的<code>GHas</code>参数。 </p><br><h1 id="vyrazitelnye-tipy-speshat-na-pomosch"> 表现力类型急救！ </h1><br><p> 解决该问题的方法是预先计算出我们感兴趣的值的“路径”，并使用该路径来指导实例的选择。 </p><br><p> 由于我们同意不支持求和类型，因此从字面上看，路径是产品类型的左转或右转序列（即，选择一对中的第一个或第二个成分），并在找到所需类型后以大的“ HERE”指针结尾。 我们这样写： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Here</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">举个例子</b> <div class="spoiler_text"><p> 请考虑以下类型： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbAddress</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbAddress</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbUsername</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Username</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbPassword</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Password</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p> 来自<code>AppConfig</code>的路径的一些示例是什么？ </p><br><ol><li> 到<code>DbConfig</code> <code>L Here</code> 。 </li><li> 至<code>WebServerConfig</code> <code>R (L Here)</code>为<code>R (L Here)</code> 。 </li><li> 至<code>CronConfig</code> <code>R (R Here)</code>为<code>R (R Here)</code> 。 </li><li> 到<code>DbAddress</code> <code>L (L Here)</code> 。 </li></ol></div></div><br><p> 搜索所需类型的值可能是什么结果？ 显而易见有两个选择：我们可以找到它，也可以找不到它。 但实际上，所有事情都有些复杂：我们可以找到这种类型的多个值。 显然，在这个有争议的案例中，最明智的行为也将是错误消息。 特定值的任何选择都将具有一定程度的随机性。 </p><br><p> 确实，请考虑我们的标准Web服务示例。 如果有人想要获取类型<code>(Host, Port)</code> ，那么它应该是数据库服务器的地址还是Web服务器的地址？ 最好不要冒险。 </p><br><p> 无论如何，让我们用代码表达这一点： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybePath</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Conflict</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> 我们将<code>NotFound</code>和<code>Conflict</code>分开，因为这些情况的处理方式根本不同：如果在我们产品类型的一个分支中获得<code>NotFound</code> ，则在其他某个分支中找到所需的值不会有任何损害，而任何分支中的<code>Conflict</code>立即意味着已满失败。 </p><br><p> 现在，我们考虑产品类型的一种特殊情况（按照我们的同意，我们将其视为对）。 如何在其中找到所需类型的值？ 您可以在一对中的每个组件中递归运行搜索<code>p2</code>分别获得结果<code>p1</code>和<code>p2</code>然后以某种方式将它们组合。 </p><br><p> 由于我们正在讨论的是在编译过程中发生的时间类实例的选择，因此我们实际上需要进行编译时计算，这些计算在Haskell中通过对类型的计算来表示（即使类型是通过使用<code>DataKinds</code>在Universe中提出的术语来<code>DataKinds</code> ）。 因此，此类关于类型的函数表示为类型族： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">family</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> p1 p2 where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> _ _ = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Conflict</span></span></span></span></code> </pre> <br><p> 此函数代表几种情况： </p><br><ol><li> 如果其中一个递归搜索成功，而另一个<code>NotFound</code> ，则我们采用成功搜索的路径，并在正确的方向附加转弯。 </li><li> 如果两个递归搜索都以<code>NotFound</code>终止，那么显然整个搜索都以<code>NotFound</code>终止。 </li><li> 在任何其他情况下，我们都会得到<code>Conflict</code> 。 </li></ol><br><p> 现在，我们将编写一个Tipe级函数来获取要查找的<code>part</code> ，并以<code>Generic</code>表示形式查找<code>part</code> ，并进行搜索： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">family</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">grecord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class"> -&gt; *) :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybePath</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class">) = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Here</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">other</span></span></span><span class="hljs-class">) = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part x </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class"> :*: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> _ _ = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span></span></code> </pre> <br><p> 请注意，我们得到的含义与我们先前对<code>GHas</code>尝试非常相似。 这是意料之中的，因为我们实际上是在重现我们试图通过时间类表达的算法。 </p><br><p>  <code>GHas</code> ，剩下的就是为该类添加一个附加参数，该参数负责前面找到的路径，并将用于选择特定实例： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class">) part grecord </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> path -&gt; grecord p -&gt; part</code> </pre> <br><p> 我们还为<code>gextract</code>添加了一个附加参数，以便编译器可以为给定路径选择正确的实例（为此必须在函数签名中提及）。 </p><br><p> 现在编写实例非常简单： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Here</span></span></span><span class="hljs-class"> record (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract _ (<span class="hljs-type"><span class="hljs-type">K1</span></span> x) = x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part record =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part (<span class="hljs-type"><span class="hljs-type">M1</span></span> it record) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract proxy (<span class="hljs-type"><span class="hljs-type">M1</span></span> x) = gextract proxy x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part l =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> ('<span class="hljs-type"><span class="hljs-type">L</span></span> path) part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract _ (l :*: _) = gextract (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> path) l <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part r =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> ('<span class="hljs-type"><span class="hljs-type">R</span></span> path) part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract _ (_ :*: r) = gextract (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> path) r</code> </pre> <br><p> 实际上，我们只是根据我们先前计算的路径中的<code>path</code>选择所需实例。 </p><br><p> 现在如何在<code>Has</code>类中编写我们的<code>extract :: record -&gt; part</code>函数的<code>default</code>实现？ 我们有几个条件： </p><br><ol><li>  <code>record</code>必须实现<code>Generic</code>以便可以应用泛型机制，因此我们获得了<code>Generic record</code> 。 </li><li>  <code>Search</code>函数应该在<code>record</code>找到<code>part</code> （或者在<code>record</code>的<code>Generic</code>表示形式中，表示为<code>Rep record</code> ）。 在代码中，这看起来有点不寻常： <code>Search part (Rep record) ~ 'Found path</code> 。 此记录表示限制，即<code>Search part (Rep record)</code>的结果<code>Search part (Rep record)</code>应等于<code>'Found path</code>某些<code>path</code>的<code>'Found path</code> ”（实际上，这对我们很有趣）。 </li><li> 我们应该能够将<code>GHas</code>与<code>part</code>一起使用，从最后一步开始，它是<code>record</code>和<code>path</code>的通用表示形式，它将变成<code>GHas path part (Rep record)</code> 。 </li></ol><br><p> 我们将多次遇到最后两个常量，因此将它们放在单独的const同义词中很有用： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> part record path = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">) ~ '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> path, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> path part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br><p> 有了这个同义词，我们得到 </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> part record </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract :: record -&gt; part <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> extract :: forall path. (<span class="hljs-type"><span class="hljs-type">Generic</span></span> <span class="hljs-title"><span class="hljs-title">record</span></span>, <span class="hljs-type"><span class="hljs-type">SuccessfulSearch</span></span> <span class="hljs-title"><span class="hljs-title">part</span></span> <span class="hljs-title"><span class="hljs-title">record</span></span> <span class="hljs-title"><span class="hljs-title">path</span></span>) =&gt; record -&gt; part extract = gextract (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> <span class="hljs-title"><span class="hljs-title">path</span></span>) . from</code> </pre> <br><p> 现在一切！ </p><br><h1 id="ispolzovanie-obobschyonnogo-has"> 使用通用<code>Has</code> </h1><br><p> 为了了解所有这些情况，我们将为假人编写一些通用实例： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) path =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">) path =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a3</span></span></span><span class="hljs-class">) path =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a3</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> 在此， <code>SuccessfulSearch a (a0, ..., an) path</code>是<code>a0, ..., an</code>恰好在<code>a0, ..., an</code>之间发生的事实。 </p><br><p> 愿我们现在拥有美好的旧时光 </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p> 并且我们要输出<code>Has DbConfig</code> ， <code>Has WebServerConfig</code>和<code>Has CronConfig</code> 。 包含<code>DeriveGeneric</code>和<code>DeriveAnyClass</code>并添加正确的<code>deriving</code>声明就足够了： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> 我们很幸运（或者我们有足够的见识）可以安排<code>Has</code>的参数，以便嵌套类型的名称首先出现，以便我们可以依赖<code>DeriveAnyClass</code>机制来减少<code>DeriveAnyClass</code> 。 </p><br><h2 id="bezopasnost-prevyshe-vsego"> 安全第一 </h2><br><p> 如果我们没有任何类型怎么办？ </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> 不，我们在类型定义时遇到了一个错误： </p><br><pre> <code class="plaintext hljs">Spec.hs:35:24: error: • Couldn't match type ''NotFound' with ''Found path0' arising from the 'deriving' clause of a data type declaration • When deriving the instance for (Has CronConfig AppConfig) | 35 | } deriving (Generic, Has CronConfig) | ^^^^^^^^^^^^^^</code> </pre> <br><p> 不是最友好的错误消息，但是即使从错误消息中您仍然可以了解问题所在：奇数频率<code>NotFound</code>奇数频率<code>CronConfig</code> 。 </p><br><p> 如果我们有几个相同类型的字段怎么办？ </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prodDbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qaDbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> 不，与预期的一样： </p><br><pre> <code class="plaintext hljs">Spec.hs:37:24: error: • Couldn't match type ''Conflict' with ''Found path0' arising from the 'deriving' clause of a data type declaration • When deriving the instance for (Has DbConfig AppConfig) | 37 | } deriving (Generic, Has DbConfig) | ^^^^^^^^^^^^</code> </pre> <br><p> 一切似乎都很好。 </p><br><h1 id="podytozhivaya"> 总结一下 </h1><br><p> 因此，我们将尝试简要地提出所提出的方法。 </p><br><p> 假设我们有某种类型的打字机，并且我们想根据一些递归规则自动显示其实例。 然后，我们可以避免歧义（如下所示：如果规则不重要且不适合解决实例的标准机制，则通常表达这些规则）： </p><br><ol><li> 我们以归纳数据类型<code>T</code>的形式编码递归规则<code>T</code> </li><li> 我们将在类型（以类型族的形式）上编写一个函数，以初步计算该类型<code>T</code>的值<code>v</code> （或者就Haskell而言，类型<code>T</code>类型<code>v</code>其中是我的从属类型），它描述了需要采取的具体步骤顺序。 </li><li> 使用此<code>v</code>作为<code>Generic</code>帮助程序的附加参数，可以确定现在与<code>v</code>值匹配的实例的特定顺序。 </li></ol><br><p> 好吧，就是这样！ </p><br><p> 在以下文章中，我们将研究此方法的一些优雅扩展（以及优雅限制）。 </p><br><p> 哦是的 跟踪我们的概括顺序很有趣。 </p><br><ol><li> 从<code>Env -&gt; Foo</code> 。 </li><li> 不够笼统，请在<code>Reader Env</code> monad中进行总结。 </li><li> 不够通用，请使用<code>MonadReader Env m</code>重写。 </li><li> 不够通用，重写<code>MonadReader rm, HasEnv r</code> 。 </li><li> 不够通用， <code>MonadReader rm, Has Env r</code>编写<code>MonadReader rm, Has Env r</code>并添加泛型，以便编译器在那里执行所有操作。 </li><li> 现在是规范。 </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471052/">https://habr.com/ru/post/zh-CN471052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471042/index.html">使用pwnable.kr 25解决问题-OTP Linux文件大小限制</a></li>
<li><a href="../zh-CN471044/index.html">Sass MediaScreen-定义CSS设备</a></li>
<li><a href="../zh-CN471046/index.html">时尚的阿瓦隆</a></li>
<li><a href="../zh-CN471048/index.html">React + Mobx：有什么意义？</a></li>
<li><a href="../zh-CN471050/index.html">D语言发展基金融资：新平台和新赠款...</a></li>
<li><a href="../zh-CN471054/index.html">Longrid关于加密货币的量子威胁的现实主义和“ 2027年预言”问题</a></li>
<li><a href="../zh-CN471062/index.html">如何教爱丽丝管理您的智能家居。 Yandex报告</a></li>
<li><a href="../zh-CN471066/index.html">zip存档是什么样的，我们可以怎么做</a></li>
<li><a href="../zh-CN471070/index.html">为移动开发人员选择哪种服务器语言...</a></li>
<li><a href="../zh-CN471072/index.html">电报中有多少克？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>