<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏾 👩🏼‍⚕️ 🛕 تنفيذ الحد الأدنى من الوظائف المنطقية بطريقة Quine \ McCluskey مع مجموعة إدخال غير مكتملة 🏴󠁧󠁢󠁥󠁮󠁧󠁿 🙋🏽 🚶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="هذه المقالة ، إلى حد ما ، استمرار لمقالتي حول تقليل الوظائف المنطقية بطريقة Quine-Mac'Klaski ( https://habr.com/post/328506 ). وقد نظرت في حالة ذات وظ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تنفيذ الحد الأدنى من الوظائف المنطقية بطريقة Quine \ McCluskey مع مجموعة إدخال غير مكتملة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424517/" style=";text-align:right;direction:rtl">  هذه المقالة ، إلى حد ما ، استمرار لمقالتي حول تقليل الوظائف المنطقية بطريقة Quine-Mac'Klaski ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://habr.com/post/328506</a> ).  وقد نظرت في حالة ذات وظائف منطقية محددة تمامًا (على الرغم من أن هذا لم يتم ذكرها مباشرة فيها ، ولكن ضمنيًا فقط).  في الواقع ، مثل هذه الحالة نادرة جدًا عندما يكون عدد متغيرات الإدخال صغيرًا.  إن التعريفات الجزئية أو غير المكتملة هي وظائف منطقية يتم إعطاء قيمها فقط للجزء Q من المجموعة الكاملة P = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mi>N</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.854ex" height="2.419ex" viewBox="0 -935.7 1228.8 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMATHI-4E" x="707" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>N</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ N </script>  المجموعات (المصطلحات) الممكنة لحججهم (المتغيرات) من العدد <i>N</i> ، أي Q &lt;P. تمت مواجهة هذا الموقف عمليًا في معظم حالات تطبيق الخوارزميات لتحسين الوظائف المنطقية.  في الواقع ، على سبيل المثال ، إذا كان عدد متغيرات المدخلات هو <i>N</i> = 30 ، وهي حالة عادية ، على سبيل المثال ، في الأسواق المالية ، فيجب أن يكون حجم عينة تدريب المدخلات من ترتيب <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>30</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>30</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-2"> 2 ^ {30} </script>  &gt; <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>10</mn><mn>9</mn></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.379ex" height="2.419ex" viewBox="0 -935.7 1454.9 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-39" x="1415" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mn>9</mn></msup></math></span></span><script type="math/tex" id="MathJax-Element-3"> 10 ^ 9 </script>  شروط فريدة فريدة من نوعها.  لا توجد مثل هذه المجموعة من البيانات في كل مؤسسة كبيرة جدًا ، ناهيك عن الأفراد ، وهذا هو بالفعل مجال BigData ، واستخدام مراكز البيانات ، إلخ. <br><br>  لذلك ، في الممارسة العملية ، في الغالب لن يتم تحديد الوظائف المنطقية المصغرة بشكل كامل وذلك ببساطة بسبب نقص الكمية المطلوبة من البيانات المتراكمة أو بسبب أسباب موضوعية أخرى (على سبيل المثال ، لا توجد مساحة كافية لتخزينها).  يطرح السؤال حول إمكانية "التحايل" على هذه المشكلة عند استخدام خوارزمية تعمل مع مجموعة محددة تمامًا من الوظائف المنطقية للمصطلح ، مثل ، على سبيل المثال ، من مقالتي السابقة. <br><a name="habracut"></a><br><br>  تتمثل الممارسة القياسية في هذه الحالة في تحديد مجموعة المدخلات غير المكتملة لقيم (مصطلح) المتغيرة إلى القيمة الكاملة بحيث تعطي نتيجة مثالية لمجموعة البيانات الحالية.  ولكن ، في هذه الحالة ، هناك مشكلة في تعداد جميع المتغيرات الممكنة للتعريفات الإضافية ، والتي يبلغ عددها الإجمالي V = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>P</mi><mo>&amp;#x2212;</mo><mi>Q</mi></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.207ex" height="2.539ex" viewBox="0 -987.6 2242 1093.4" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMATHI-50" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-2212" x="751" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMATHI-51" x="1530" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mi>P</mi><mo>−</mo><mi>Q</mi></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-4"> 2 ^ {P-Q} </script>  لتحديد الخيار الأفضل لتعريف إضافي وفقًا لمعيار معين.  من الواضح ، بالنسبة للقيم المستخدمة بالفعل لـ Q و P ، فإن عدد الخيارات المصنفة لتعريفات إضافية كبير فلكيًا ولا يمكن تنفيذ هذا النهج في الممارسة العملية بسبب التكلفة الحسابية الهائلة. <br><br>  وبالتالي ، هناك حاجة إلى نهج مختلف من شأنه أن يلغي الحاجة إلى تعداد خيارات مختلفة لتعاريف إضافية.  لذلك ، من الضروري تحديث الخوارزمية الأصلية ، التي تعمل في البداية فقط مع مجموعة إدخال محددة بالكامل ، بحيث يمكنها أيضًا العمل مع مجموعة مقطوعة.  إنه تطبيق للخوارزمية المقترحة في هذه المقالة ، استنادًا إلى حقيقة أنه أثناء عملية التصغير تتم معالجة قائمتين غير مكتملتين من المصطلحات في وقت واحد ، حيث يتم تحديد الوظيفة على أنها FALSE (0) و TRUE (1). <br><br>  من وجهة نظر التعلم الآلي ، تطبق خوارزمية Quine-Mac'Klaski نموذج التعلم مع المعلم عندما يتم تضمين قيم المخرجات المقابلة للوظيفة الموضوعية في عملية التعلم (في هذه الحالة ، التقليل) في وقت واحد.  دعني أذكرك أن مبدأ تشغيل طريقة Quine-Mac'Klaski الأساسية وفقًا للنظرية يتكون من مرحلتين رئيسيتين: <br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  المرحلة.  إيجاد جميع مصطلحات LF البسيطة باستخدام قواعد (قوانين) اللصق: <br>  أ) (أ و ب)؟  (A &amp;! B)؟  أ ؛ <br>  ب) (أ؟ ب) و (أ؟ ب)؟  أ ؛ <br>  أين &amp; المنطقية AND العملية ؛؟  - تشغيل المنطقية "OR" ؛!  - تشغيل النفي المنطقي "NOT".  ويترتب على هذه الصيغ أنه يتم لصق مصطلحين معًا إذا اختلف كل منهما عن الآخر فقط في أحد مواضع المتغيرات.  في الموضع الذي يختلف فيه المصطلحان عن بعضهما البعض ، يتم وضع العلامة "*".  وبالتالي ، فإن الأبجدية من حيث اللصق مقارنة مع الأصلي يمتد إلى ثلاث قيم: <br>  • 0 =&gt; خطأ ؛ <br>  • 1 =&gt; صحيح ؛ <br>  • 2 =&gt; متغير لاصق (*). </li><li style=";text-align:right;direction:rtl">  المرحلة.  تقليل عدد المصطلحات الملصوقة التي تم الحصول عليها بعد المرحلة الأولى ، كمشكلة في العثور على التغطية المثلى لمجموعة المصطلحات الأولية بالكمية Q. أي ، نظرًا لأن كل مصطلح ناتج يغطي مجموعة فرعية معينة من مصطلحات المصدر ، فمن الضروري اختيار مجموعة دنيا من مصطلحات الإخراج التي تم تحديدها مع معهم ، غطت مجموعات فرعية بأطوال مختلفة في المجموع جميع شروط الإدخال الأولية.  يعني الطلاء في هذه الحالة أن التشغيل أحادي الاتجاه لفصل مصطلح الإخراج على مدى الإدخال يعطي قيمة حقيقية.  لنفترض أن مصطلح اللصق الناتج يحتوي على الشكل التالي: 10 * 0110 *. <br>  ثم يغطي المصطلح 10101100: <br>  10 * 0110 * &amp; 10101100 = صحيح <br>  ولكن لا يشمل المصطلح 00101100: <br>  10 * 0110 * &amp; 00101100 = خطأ <br>  أي ، يجب أن يتطابق مصطلح الإدخال والإخراج في كل مكان باستثناء المواضع التي يوجد بها الرمز "*" - في هذا الموضع يمكن لمتغير مصطلح الإدخال أن يأخذ أي قيمة ، لأن  في هذا الموقف يتم استبعاد المتغير من الاعتبار. </li></ol><br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">رمز التنفيذ على النحو التالي (انقر للعرض):</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs">using System; using System.Collections.Generic; using System.Linq; #region   /// &lt;summary&gt; ///      /// &lt;/summary&gt; public abstract class LogicFunction { // ""  public const byte cStarSymb = 2; //    public readonly ICollection&lt;byte[]&gt; Terms = new LinkedList&lt;byte[]&gt;(); //   public abstract bool Calculate(bool[] X); //   public abstract bool Calculate(char[] X); //   public abstract bool Calculate(byte[] X); } /// &lt;summary&gt; ///    /// &lt;/summary&gt; public class Dnf : LogicFunction { public static bool Calculate(byte[] X, byte[] term) { bool bResult = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] == cStarSymb) || (term[i] == X[i])) continue; bResult = false; break; } return bResult; } public override bool Calculate(byte[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || (term[i] == X[i])) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } public override bool Calculate(char[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || (term[i] == (byte)(X[i] == '0' ? 0 : 1))) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } public override bool Calculate(bool[] X) { bool bResult = false; foreach (byte[] term in Terms) { bool bTermVal = true; for (int i = 0; i &lt; term.Length; i++) { if ((term[i] &gt;= cStarSymb) || ((term[i] != 0) == X[i])) continue; bTermVal = false; break; } //bResult |= bTermVal; if (bTermVal) { bResult = true; break; } } return bResult; } } #endregion /// &lt;summary&gt; ///   /// &lt;/summary&gt; public class TreeFuncTerm { /// &lt;summary&gt; ///     /// &lt;/summary&gt; public class TreeNodeEnd { } //    private readonly TreeNodeEnd pCommonTreeNodeEnd = new TreeNodeEnd(); //  private readonly object[] rootNode = new object[3]; // ()  private int _rang = 0; public int Rang { get { return _rang; } } //    private int enumerationPos = 0; private object[][] enumerationBuf; //,     private byte[] enumerationTerm; public byte[] EnumerationTerm { get { return enumerationTerm; } } //     private UInt32 _count = 0; public UInt32 Count { get { return _count; } } // public TreeFuncTerm() { Clear(); } //  public void Clear() { _count = 0; _rang = 0; enumerationPos = 0; enumerationBuf = null; enumerationTerm = null; rootNode[0] = rootNode[1] = rootNode[2] = null; } //      public TreeNodeEnd EnumerationInit() { enumerationPos = 0; enumerationTerm = new byte[_rang]; enumerationTerm[0] = 0; enumerationBuf = new object[_rang][]; enumerationBuf[0] = rootNode; //    return EnumerationNextNode(); } //     public TreeNodeEnd EnumerationNextNode() { int iIsNext = (enumerationPos &gt; 0 ? 1 : 0); TreeNodeEnd pRetTreeNode = null; while ((pRetTreeNode == null) &amp;&amp; (enumerationPos &gt;= 0)) { object[] pCurrNodes = enumerationBuf[enumerationPos]; object pNextNode = null; int i = enumerationTerm[enumerationPos] + iIsNext; for (; i &lt; 3; i++) if ((pNextNode = pCurrNodes[i]) != null) break; if (pNextNode == null) { //    enumerationPos--; iIsNext = 1; } else { enumerationTerm[enumerationPos] = (byte)i; if (pNextNode is object[]) { //    enumerationPos++; enumerationBuf[enumerationPos] = (object[])pNextNode; enumerationTerm[enumerationPos] = 0; iIsNext = 0; } else //if (pNextNode is TreeNodeEnd) { //   pRetTreeNode = (TreeNodeEnd)pNextNode; } } } return pRetTreeNode; } //     public void AddTerm(byte[] term) { _rang = Math.Max(_rang, term.Length); object[] pCurrNode = rootNode; int iTermLength1 = term.Length - 1; for (int j = 0; j &lt; iTermLength1; j++) { byte cSymb = term[j]; object item = pCurrNode[cSymb]; if (item == null) { item = new object[3]; pCurrNode[cSymb] = item; } pCurrNode = (object[])item; } if (pCurrNode[term[iTermLength1]] == null) { //    pCurrNode[term[iTermLength1]] = pCommonTreeNodeEnd; _count++; } } //      public TreeNodeEnd Remove(byte[] term) { int iTermLength1 = term.Length - 1; object[] pCurrNode = rootNode; for (int i = 0; i &lt; iTermLength1; i++) { pCurrNode = (object[])pCurrNode[term[i]]; if (pCurrNode == null) break; } TreeNodeEnd pRemovedNode = null; if (pCurrNode != null) { //      pRemovedNode = (TreeNodeEnd)pCurrNode[term[iTermLength1]]; if (pRemovedNode != null) { //     pCurrNode[term[iTermLength1]] = null; // -  _count--; } } return pRemovedNode; } //     public bool Contains(byte[] term) { object pCurrNode = rootNode; foreach (byte cSymb in term) { pCurrNode = ((object[])pCurrNode)[cSymb]; if (pCurrNode == null) break; } return ((pCurrNode != null) &amp;&amp; (pCurrNode is TreeNodeEnd)); } } /// &lt;summary&gt; ///     ---- /// &lt;/summary&gt; public class Quine_McCluskey { //    private readonly Dnf _result = new Dnf(); public Dnf Result { get { return _result; } } //    private readonly Dnf _resultNeg = new Dnf(); public Dnf ResultNeg { get { return _resultNeg; } } //     private static void Skleivanie(TreeFuncTerm X1Tree, TreeFuncTerm X2Tree, TreeFuncTerm NegativTree, IEnumerable&lt;byte[]&gt; InpNegTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; OutResult, int iLevel) { LinkedList&lt;byte[]&gt; OutR = new LinkedList&lt;byte[]&gt;(); if (OutResult != null) OutResult.Add(iLevel, OutR); bool IsVirtSkleivOn = ((NegativTree != null) &amp;&amp; (InpNegTerms != null) &amp;&amp; (InpNegTerms.Count() != 0)); for (TreeFuncTerm.TreeNodeEnd x1 = X1Tree.EnumerationInit(); x1 != null; x1 = X1Tree.EnumerationNextNode()) { bool bIsSkleiv = false; byte[] pCurrTerm = X1Tree.EnumerationTerm; for (int iPos = 0; iPos &lt; pCurrTerm.Length; iPos++) { byte cSymbSav = pCurrTerm[iPos]; if (cSymbSav == LogicFunction.cStarSymb) continue; //      pCurrTerm[iPos] = (byte)(1 - cSymbSav); if (X1Tree.Contains(pCurrTerm)) { bIsSkleiv = true; //,         if (cSymbSav == 1) { pCurrTerm[iPos] = LogicFunction.cStarSymb; //  X2Tree.AddTerm(pCurrTerm); } } //    ,    NegativTree else if (IsVirtSkleivOn &amp;&amp; !NegativTree.Contains(pCurrTerm)) { bool bIsNotCanAdd = false; pCurrTerm[iPos] = LogicFunction.cStarSymb; //  foreach (byte[] NegTerm in InpNegTerms) { if (bIsNotCanAdd = Dnf.Calculate(NegTerm, pCurrTerm)) break; } if (!bIsNotCanAdd) { bIsSkleiv = true; X2Tree.AddTerm(pCurrTerm); } } pCurrTerm[iPos] = cSymbSav; } //    ,       if (!bIsSkleiv) OutR.AddLast((byte[])pCurrTerm.Clone()); } } //     private static UInt64 GetTermCode(byte[] pTerm) { UInt64 iMultip = 1, iCode = 0; for (int i = 0; i &lt; pTerm.Length; i++) { iCode += (iMultip * pTerm[i]); iMultip *= 3; } return iCode; } //     private static byte[] GetTermByCode(UInt64 iCode, int iTermLength, byte[] pTerm = null) { if (pTerm == null) pTerm = new byte[iTermLength]; int iCounter = 0; while (iCode != 0) { pTerm[iCounter++] = (byte)(iCode % 3); iCode /= 3; } while (iCounter &lt; iTermLength) pTerm[iCounter++] = 0; return pTerm; } //     private static void Skleivanie(ICollection&lt;UInt64&gt; X1Tree, ICollection&lt;UInt64&gt; X2Tree, ICollection&lt;UInt64&gt; NegativTree, IEnumerable&lt;byte[]&gt; InpNegTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; OutResult, int iLevel, int iTermLength) { LinkedList&lt;byte[]&gt; OutR = new LinkedList&lt;byte[]&gt;(); if (OutResult != null) OutResult.Add(iLevel, OutR); byte[] pCurrTerm = new byte[iTermLength]; bool IsVirtSkleivOn = ((NegativTree != null) &amp;&amp; (InpNegTerms != null) &amp;&amp; (InpNegTerms.Count() != 0)); foreach (UInt64 x1 in X1Tree) { GetTermByCode(x1, iTermLength, pCurrTerm); bool bIsSkleiv = false; UInt64 iMultip = 1; for (int iPos = 0; iPos &lt; iTermLength; iPos++) { byte cSymbSav = pCurrTerm[iPos]; //(byte)((x1 / iMultip) % 3); if (cSymbSav != LogicFunction.cStarSymb) { UInt64 iCode = (cSymbSav == 0 ? x1 + iMultip : x1 - iMultip); //      if (X1Tree.Contains(iCode)) { bIsSkleiv = true; //,         if (cSymbSav == 1) { X2Tree.Add(x1 + iMultip); } } //    ,    NegativTree else if (IsVirtSkleivOn &amp;&amp; !NegativTree.Contains(iCode)) { bool bIsNotCanAdd = false; pCurrTerm[iPos] = LogicFunction.cStarSymb; //  foreach (byte[] NegTerm in InpNegTerms) { if (bIsNotCanAdd = Dnf.Calculate(NegTerm, pCurrTerm)) break; } pCurrTerm[iPos] = cSymbSav; if (!bIsNotCanAdd) { bIsSkleiv = true; X2Tree.Add(x1 + (byte)(LogicFunction.cStarSymb - cSymbSav) * iMultip); } } } iMultip *= 3; } //    ,       if (!bIsSkleiv) OutR.AddLast((byte[])pCurrTerm.Clone()); } } //      //       private static void DeleteDublicatingTerms(IEnumerable&lt;byte[]&gt; InX1, ICollection&lt;UInt64&gt; OutX2Tree) { OutX2Tree.Clear(); foreach (byte[] x1 in InX1) { UInt64 iCode = GetTermCode(x1); if (OutX2Tree.Contains(iCode)) continue; OutX2Tree.Add(iCode); } } //      //       private static void DeleteDublicatingTerms(IEnumerable&lt;byte[]&gt; InX1, TreeFuncTerm OutX2Tree) { OutX2Tree.Clear(); foreach (byte[] x1 in InX1) OutX2Tree.AddTerm(x1); } //    private static bool IsEqualTerms(byte[] pTermC, byte[] pTermB) { if ((pTermC == null) || (pTermB == null) || (pTermC.Length != pTermB.Length)) return false; bool bIsEqual = false; int iLength = Math.Min(pTermC.Length, pTermB.Length); for ( int i = 0; i &lt; iLength; i++) { if (!(bIsEqual = (pTermB[i] == pTermC[i]))) break; } return bIsEqual; } //            private static void ReduceRedundancyTerms(LinkedList&lt;byte[]&gt; InpTerms, Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivTerms, ICollection&lt;byte[]&gt; ResultTerms) { if ((InpTerms == null) || (SkleivTerms == null) || (ResultTerms == null)) return; //   ResultTerms.Clear(); //        ,    Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt; Outputs2Inputs = new Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt;(); //        ,    Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt; Inputs2Outputs = new Dictionary&lt;byte[], HashSet&lt;byte[]&gt;&gt;(); //    foreach (int iLevel in SkleivTerms.Keys.OrderByDescending(p =&gt; p).AsEnumerable()) { //       foreach (byte[] outTerm in SkleivTerms[iLevel]) { //  ,      term HashSet&lt;byte[]&gt; InpTermsLst = new HashSet&lt;byte[]&gt;(); //     foreach (byte[] inpTerm in InpTerms) { if (Dnf.Calculate(inpTerm, outTerm)) { InpTermsLst.Add(inpTerm); if (!Inputs2Outputs.ContainsKey(inpTerm)) Inputs2Outputs.Add(inpTerm, new HashSet&lt;byte[]&gt;()); Inputs2Outputs[inpTerm].Add(outTerm); } } Outputs2Inputs.Add(outTerm, InpTermsLst); } } //      -    Inputs2Outputs = Inputs2Outputs.OrderBy(p =&gt; p.Value.Count).ToDictionary(p =&gt; p.Key, v =&gt; v.Value); //   ,   -    while (Inputs2Outputs.Count &gt; 0) { byte[] outTerm = Inputs2Outputs.First().Value.OrderByDescending(q =&gt; Outputs2Inputs[q].Count()).First(); ResultTerms.Add(outTerm); foreach (byte[] inpTerm in Outputs2Inputs[outTerm].ToArray()) { foreach (byte[] outTerm2Del in Inputs2Outputs[inpTerm]) Outputs2Inputs[outTerm2Del].Remove(inpTerm); Inputs2Outputs.Remove(inpTerm); } } } //    public static void LogicFuncMinimize(IEnumerable&lt;byte[]&gt; PositivTerms, ICollection&lt;byte[]&gt; OutPos, IEnumerable&lt;byte[]&gt; NegativTerms, ICollection&lt;byte[]&gt; OutNeg) { int iTotalLevels = (PositivTerms.Count() &gt; 0 ? PositivTerms.First().Length : (NegativTerms != null &amp;&amp; NegativTerms.Count() &gt; 0 ? NegativTerms.First().Length : 0)); Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivPosTerms = new Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt;(iTotalLevels); Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt; SkleivNegTerms = new Dictionary&lt;int, LinkedList&lt;byte[]&gt;&gt;(iTotalLevels); LinkedList&lt;byte[]&gt; InpPosTerms = new LinkedList&lt;byte[]&gt;(); LinkedList&lt;byte[]&gt; InpNegTerms = new LinkedList&lt;byte[]&gt;(); if (iTotalLevels &lt; 40) { HashSet&lt;UInt64&gt; X1PositivTree = new HashSet&lt;UInt64&gt;(); DeleteDublicatingTerms(PositivTerms, X1PositivTree); HashSet&lt;UInt64&gt; X1NegativTree = null; if (NegativTerms != null) { X1NegativTree = new HashSet&lt;UInt64&gt;(); DeleteDublicatingTerms(NegativTerms, X1NegativTree); //        foreach(UInt64 iNumb in X1PositivTree.Intersect(X1NegativTree)) { // -    X1   NegativTerms int iPos_Count = PositivTerms.Count(p =&gt; GetTermCode(p) == iNumb); int iNeg_Count = NegativTerms.Count(p =&gt; GetTermCode(p) == iNumb); if (iPos_Count &gt; iNeg_Count) { X1NegativTree.Remove(iNumb); } else if (iPos_Count &lt; iNeg_Count) { X1PositivTree.Remove(iNumb); } else //if (iPos_Count == iNeg_Count) { X1PositivTree.Remove(iNumb); X1NegativTree.Remove(iNumb); } } //           foreach (UInt64 code in X1NegativTree) { InpNegTerms.AddLast(GetTermByCode(code, iTotalLevels)); } } //          foreach (UInt64 code in X1PositivTree) { InpPosTerms.AddLast(GetTermByCode(code, iTotalLevels)); } int iLevelCounter = 0; //        while ((X1PositivTree.Count != 0) &amp;&amp; (iLevelCounter &lt; iTotalLevels)) { HashSet&lt;UInt64&gt; X2PositivTree = new HashSet&lt;UInt64&gt;(); Skleivanie(X1PositivTree, X2PositivTree, X1NegativTree, InpNegTerms, SkleivPosTerms, iLevelCounter, iTotalLevels); if ((X1NegativTree != null) &amp;&amp; (X1NegativTree.Count != 0)) { HashSet&lt;UInt64&gt; X2NegativTree = new HashSet&lt;UInt64&gt;(); Skleivanie(X1NegativTree, X2NegativTree, X1PositivTree, InpPosTerms, SkleivNegTerms, iLevelCounter, iTotalLevels); //   X1NegativTree.Clear(); X1NegativTree = X2NegativTree; } //   X1PositivTree.Clear(); X1PositivTree = X2PositivTree; iLevelCounter++; GC.Collect(); } } else { TreeFuncTerm X1PositivTree = new TreeFuncTerm(); DeleteDublicatingTerms(PositivTerms, X1PositivTree); TreeFuncTerm X1NegativTree = null; if (NegativTerms != null) { X1NegativTree = new TreeFuncTerm(); DeleteDublicatingTerms(NegativTerms, X1NegativTree); //         for (TreeFuncTerm.TreeNodeEnd x1 = X1PositivTree.EnumerationInit(); x1 != null; x1 = X1PositivTree.EnumerationNextNode()) { if (!X1NegativTree.Contains(X1PositivTree.EnumerationTerm)) continue; // -    PositivTerms   NegativTerms int iPos_Count = PositivTerms.Count(p =&gt; IsEqualTerms(p, X1PositivTree.EnumerationTerm)); int iNeg_Count = NegativTerms.Count(p =&gt; IsEqualTerms(p, X1PositivTree.EnumerationTerm)); if (iPos_Count &gt; iNeg_Count) { X1NegativTree.Remove(X1PositivTree.EnumerationTerm); } else if (iPos_Count &lt; iNeg_Count) { X1PositivTree.Remove(X1PositivTree.EnumerationTerm); } else //if (iPos_Count == iNeg_Count) { X1PositivTree.Remove(X1PositivTree.EnumerationTerm); X1NegativTree.Remove(X1PositivTree.EnumerationTerm); } } //           for (TreeFuncTerm.TreeNodeEnd x1 = X1NegativTree.EnumerationInit(); x1 != null; x1 = X1NegativTree.EnumerationNextNode()) { InpNegTerms.AddLast((byte[])X1NegativTree.EnumerationTerm.Clone()); } } //          for (TreeFuncTerm.TreeNodeEnd X1Term = X1PositivTree.EnumerationInit(); X1Term != null; X1Term = X1PositivTree.EnumerationNextNode()) { InpPosTerms.AddLast((byte[])X1PositivTree.EnumerationTerm.Clone()); } int iLevelCounter = 0; //        while ((X1PositivTree.Count != 0) &amp;&amp; (iLevelCounter &lt; iTotalLevels)) { TreeFuncTerm X2PositivTree = new TreeFuncTerm(); Skleivanie(X1PositivTree, X2PositivTree, X1NegativTree, InpNegTerms, SkleivPosTerms, iLevelCounter); if ((X1NegativTree != null) &amp;&amp; (X1NegativTree.Count != 0)) { TreeFuncTerm X2NegativTree = new TreeFuncTerm(); Skleivanie(X1NegativTree, X2NegativTree, X1PositivTree, InpPosTerms, SkleivNegTerms, iLevelCounter); //   X1NegativTree.Clear(); X1NegativTree = X2NegativTree; } //   X1PositivTree.Clear(); X1PositivTree = X2PositivTree; iLevelCounter++; GC.Collect(); } } //       ReduceRedundancyTerms(InpPosTerms, SkleivPosTerms, OutPos); //       ReduceRedundancyTerms(InpNegTerms, SkleivNegTerms, OutNeg); } //  public void Start(IEnumerable&lt;byte[]&gt; TermsInput) { LogicFuncMinimize(TermsInput, _result.Terms, null, null); } //  public void Start(IEnumerable&lt;byte[]&gt; TermsInput, IEnumerable&lt;byte[]&gt; NegativTerms) { LogicFuncMinimize(TermsInput, _result.Terms, NegativTerms, _resultNeg.Terms); } //  public void Start(IEnumerable&lt;char[]&gt; TermsInput) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray())); } //  public void Start(IEnumerable&lt;char[]&gt; TermsInput, IEnumerable&lt;char[]&gt; NegativTerms) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray()), NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray())); } //  public void Start(IEnumerable&lt;bool[]&gt; TermsInput) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray())); } //  public void Start(IEnumerable&lt;bool[]&gt; TermsInput, IEnumerable&lt;bool[]&gt; NegativTerms) { Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray()), NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray())); } public void PrintResult() { Console.WriteLine("--------Otvet-------"); char[] pTermSymbs = new char[] { '0', '1', '*' }; foreach (byte[] Term in _result.Terms) { for (int j = 0; j &lt; Term.Length; j++) { Console.Write(pTermSymbs[Term[j]].ToString() + " "); } Console.WriteLine(); } } }</code> </pre> <br></div></div><br><br>  الفئة Quine_McCluskey هي تطبيق لهذه الخوارزمية التي تستخدم فئات وواجهات أخرى: Dnf و TreeNodeBase و TreeNodeMiddle و TreeNodeEnd و TreeFuncTerm.  لبدء التحسين ، تحتاج إلى استدعاء إحدى طرق البدء المحملة بشكل زائد ، والتي تستدعي وظيفة LogicFuncMinimize ، حيث يتم في الواقع تنفيذ خوارزمية التصغير.  يتم تنفيذ آلية التقليل في نسختين: <br>  • استخدام الحاوية .NET SortedSet لتخزين مصطلحات البحث والبحث عنها. <br>  • بدون استخدام حاويات .NET على أساس الشجرة الثلاثية TreeFuncTerm. <br><br>  من حيث السرعة ، هذان الخياران متساويان تقريبًا (مع حاويات .NET ، ربما أسرع قليلاً ، ولكن ليس دائمًا) ، ولكن الحاجة إلى تطبيق TreeFuncTerm ترجع إلى عدة عوامل: <br>  • الخيار الأول ، استنادًا إلى رموز تجزئة عدد صحيح 64 بت والبحث في قاموس SortedSet .NET ، يعمل بشكل صحيح فقط مع عدد متغيرات الإدخال من حيث تصل إلى 40 ، ومع عدد أكبر يتجاوز شبكة رمز تجزئة عدد صحيح 64 بت ، تستخدم لتشغيل الحاوية.  في الواقع ، بما أن المنطق الثلاثي يُستخدم في المصطلحات الملصقة داخل الخوارزمية ، فعندئذٍ مع عدد متغيرات الإدخال تساوي 41 ، فإن القيمة القصوى لشفرة التجزئة <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>3</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>41</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,392)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-34"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-31" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>3</mn><mrow class="MJX-TeXAtom-ORD"><mn>41</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-5"> 3 ^ {41} </script>  يتجاوز بالفعل القيمة القصوى <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>64</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-36"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-34" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>64</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-6"> 2 ^ {64} </script>  -1 ، والتي يمكن كتابتها إلى متغير 64 بت.  باستخدام المزيد من المتغيرات ، يتم استخدام خيار بناءً على شجرة البحث الثلاثية للمؤلف TreeFuncTerm. <br>  • من الضروري التحقق من تشغيل التطبيق على حاويات .NET مع تنفيذ آخر مستقل عنه. <br>  • أنت تحتاج فقط إلى خيار خالٍ من حاويات .NET ، والتي يمكن تنفيذها بسهولة على الأنظمة الأساسية التي لا توجد فيها منصة .NET (على سبيل المثال ، في وحدات التحكم الدقيقة ، و FPGA ، وما إلى ذلك). <br>  يعتمد تشغيل شجرة البحث TreeFuncTerm على تكوين الارتباطات إلى فئتي TreeNodeMiddle و TreeNodeEnd ، وهي عمليات تنفيذ لواجهة TreeNodeBase.  الفئة TreeNodeMiddle هي عقدة وسيطة للشجرة ، والفئة TreeNodeEnd هي نهاية الشجرة.  باستخدام الدالتين EnumerationInit () و EnumerationNextNode () ، يتم تنفيذ آلية غير متكررة لتعداد جميع أوراق الشجرة لـ TreeNodeEnd في الشجرة.  تقوم الدالة EnumerationInit () بتهيئة التعداد وإرجاع الورقة الأولى في الشجرة.  ترجع الدالة EnumerationNextNode () صفحة الشجرة التالية أو NULL إذا لم يعد هناك أوراق للتحديد.  علاوة على ذلك ، فإن البنية الداخلية المساعدة EnumerationTerm ، والتي تعكس موضع البحث "المؤشر" داخل الشجرة ، هي أيضًا رمز مصطلح الورقة الموجودة في المنطق الثلاثي {0،1،2}.  وتجدر الإشارة إلى أن ترتيب اختيار الأوراق من الشجرة لا يتزامن مع ترتيب إضافتها إليها. <br><br>  يمكن تقسيم الخوارزمية لأغراض وظيفية إلى ثلاث مراحل. <br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <b>تحضير.</b>  لحل المشكلة المذكورة أعلاه المتمثلة في القضاء على تعداد الخيارات لتعريفات إضافية في التنفيذ قيد النظر ، تتلقى الدالة LogicFuncMinimize مجموعتي بيانات أوليتين PositivTerms و NegativTerms ، حيث تقبل الوظيفة المحسنة القيم الحقيقية (TRUE ، 1) والقيم الخاطئة (FALSE ، 0) ، على التوالي.  بادئ ذي بدء ، يتم فحص هذه القوائم للتأكد من اتساق البيانات المصدر.  من الضروري ضمان احتواء كل مجموعة من مجموعات البيانات فقط على مصطلحات فريدة موجودة فقط في أي من القوائم.  لضمان ذلك ، يتم فحص كل مصطلح إدخال فريد ويتم العثور على عدد الإدخالات في كل قائمة من قوائم المصادر.  إذا ظهر المصطلح في كلتا القائمتين ، فإنه يبقى فقط في القائمة التي يظهر فيها أكثر ، ويتم حذفه من الآخر.  إذا حدث المصطلح في كل قائمة بشكل متساوٍ ، فسيتم إزالته من كلتا القائمتين ، مما يضمن التفرد. </li><li style=";text-align:right;direction:rtl">  <b>الترابط.</b>  بعد ذلك ، يتم تنفيذ دورة تكرارية لمصطلحات الإدخال.  عند كل تكرار ، بعبارات لاصقة ، تتم إضافة علامة واحدة * للموضع الملصق.  لذلك ، لا يمكن أن يكون عدد التكرارات أكبر من عدد المتغيرات <i>N.</i>  على عكس التنفيذ السابق ، فإن وظيفة Skleivanie لمصطلحات المدخلات لديها القدرة على الغراء ليس فقط مع المصطلحات من قائمتها ، ولكن أيضًا في حالة عدم وجود مصطلح بفارق واحد أيضًا مع المصطلحات "الافتراضية".  نعني بالمصطلحات "الافتراضية" مصطلحات محددة بشكل مصطنع لا توجد في أي من قوائم مصطلحات مجموعة من المستوى الحالي.  لكن التصاق ممكن فقط إذا كان المصطلح "الظاهري" لا يغطي مصطلحًا واحدًا من المجموعة الأولية من القائمة المقابلة. <br>  يتم استدعاء وظيفة Skleivanie لمعالجة القوائم في كل تكرار مرتين بحيث يتطابق معنى استخدام قوائم PositivTerms و NegativTerms مع محتواها الفعلي في المكالمة الأولى ، وفي المكالمة الثانية ، يتم تبديل قوائم PositivTerms و NegativTerms من حيث الاستخدام ، أي أنه يعتبر تحتوي قائمة PositivTerms على مصطلحات سلبية ، وتحتوي قائمة NegativTerms على مصطلحات إيجابية: <br>  Skleivanie (X1PositivTree، ...، X1NegativTree، ...، SkleivTerms، ...)؛ <br>  Skleivanie (X1NegativTree، ...، X1PositivTree، ...، null، ...)؛ <br>  وبالتالي ، يحدث لصق متزامن ومتزامن لمصطلحات قائمتين. <br>  إذا لم يكن هناك مصطلح آخر يختلف عن المصطلح في موضع واحد فقط ، لا حقيقي ولا افتراضي ، أي أن المصطلح لا يلتصق مع أي شخص ، عندئذٍ يعتبر من نتائج الخطوة 1 من الخوارزمية ، يتم استبعاده من المزيد من العمل فيه ويذهب لإدخال المرحلة 2 من الخوارزمية التي تم تنفيذها في إجراء ReduceRedundancyTerms.  يتم إرسال المصطلحات غير الملصقة إلى إخراج الخوارزمية فقط على هذا الاستدعاء لوظيفة Skleivanie ، والتي يتزامن معها استخدام قوائم PositivTerms و NegativTerms مع تعبئتها الفعلية ، أي في المكالمة الأولى. </li><li style=";text-align:right;direction:rtl">  <b>اختصار.</b>  يتم تجاهل المصطلحات الملصقة الزائدة في ReduceRedundancyTerms باستخدام خوارزمية لحل تقريبي لمشكلة تغطية المجموعة الأصلية بمجموعات فرعية متغيرة الطول.  يتم توفير التغطية الأقرب إلى الأقصر من خلال خوارزمية تحويل جدول التغطية (TP) ، استنادًا إلى طريقة "الحد الأدنى للعمود - الحد الأقصى للصف" (والتي يمكن رؤيتها ، على سبيل المثال ، هنا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">http://www.studfiles.ru/preview/5175815/page:4</a> ) . <br>  المنطق التقريبي لعمله هو كما يلي: <br>  0. يعتبر الجدول الأصلي هو TP المحول الحالي ، مجموعة خطوط التغطية فارغة ؛ <br>  1. يتم تمييز العمود الذي يحتوي على أقل عدد من الوحدات في الجدول الحالي.  من بين الصفوف التي تحتوي على وحدات في هذا العمود ، يتم تمييز واحد به أكبر عدد من الوحدات.  يتم تضمين هذا الصف في التغطية ، ويتم تقليل الجدول الحالي عن طريق حذف جميع الأعمدة التي يحتوي فيها الصف المحدد على وحدة. <br>  2. في حالة عدم وجود أعمدة متقاطعة في الجدول ، يتم تنفيذ الخطوة 1 ؛ وإلا ، يتم إنشاء التغطية.  ملاحظة: عند حساب عدد الوحدات المتتالية ، يتم أخذ الوحدات في الأعمدة غير المميزة بعين الاعتبار. <br>  تعمل هذه الخوارزمية بسرعة كافية وتعطي نتيجة قريبة من المثلى. <br>  لاختبار تشغيل الخوارزمية ، يُقترح استخدام وظيفة الاختبار TestQuineMcCluskeyRandomPart ، والتي ، من إجمالي مجموعة المصطلحات المحتملة ، هي <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mi>N</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.854ex" height="2.419ex" viewBox="0 -935.7 1228.8 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=https://habr.com/ru/post/424517/&amp;usg=ALkJrhj2tCSbGoCjbPX_zfI4RRMabSqj1w#MJMATHI-4E" x="707" y="557"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>N</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-7"> 2 ^ N </script>  يختار عشوائيًا فقط الجزء المعطى 0 &lt;dPart &lt;= 1 (هو معلمة الوظيفة) ، والتي يتم إجراء التحسين لها.  باستخدام المعلمة dPart &lt;1 ، سيتم الحصول على مجموعة مبتورة من مصطلحات الإدخال ، ومع dPart = 1 ، سيتم الحصول على مجموعة كاملة من بيانات الإدخال. </li></ol><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">TestQuineMcCluskeyRandomPart (انقر للعرض)</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">public static void TestQuineMcCluskeyRandomPart(int iVariableAmount, double dPart=1) { if (dPart &lt; 0) throw new ArgumentException(" dPart    0   1"); if (dPart &gt; 1) dPart = 1; //   ulong iTotalCombines = (ulong)1 &lt;&lt; iVariableAmount; LinkedList&lt;byte[]&gt; pTrueCol = new LinkedList&lt;byte[]&gt;(); LinkedList&lt;byte[]&gt; pFalseCol = new LinkedList&lt;byte[]&gt;(); HashSet&lt;ulong&gt; pUsedTerms = new HashSet&lt;ulong&gt;(); Random rnd = new Random(); byte[] buf = new byte[8]; while (pUsedTerms.LongCount() &lt; (iTotalCombines * dPart)) { rnd.NextBytes(buf); ulong iCurValue = (ulong)BitConverter.ToInt64(buf, 0) % iTotalCombines; if (pUsedTerms.Contains(iCurValue)) { //  -     do { iCurValue = ++iCurValue % iTotalCombines; } while (pUsedTerms.Contains(iCurValue)); } pUsedTerms.Add(iCurValue); byte[] sLine = new byte[iVariableAmount]; for (int i = 0; i &lt; iVariableAmount; i++) { sLine[i] += (byte)(iCurValue % 2); iCurValue &gt;&gt;= 1; } if (rnd.Next(2) != 0) { pTrueCol.AddLast(sLine); } else { pFalseCol.AddLast(sLine); } } //   DateTime DtStart = DateTime.Now; Console.WriteLine(" - " + DtStart.ToLongTimeString()); Quine_McCluskey Logic = new Quine_McCluskey(); Logic.Start(pTrueCol, pFalseCol); DateTime DtEnd = DateTime.Now; Logic.PrintResult(); Console.WriteLine(" - " + DtStart.ToLongTimeString()); Console.WriteLine(" - " + DtEnd.ToLongTimeString()); TimeSpan Elapsed = DtEnd - DtStart; Console.WriteLine(" - " + String.Format("{0:00}:{1:00}:{2:00}", Elapsed.Hours, Elapsed.Minutes, Elapsed.Seconds)); //  int iErrorsCounter = 0; foreach (byte[] kvp in pTrueCol) { if (Logic.Result.Calculate(kvp) != true) iErrorsCounter++; } foreach (byte[] kvp in pFalseCol) { if (Logic.Result.Calculate(kvp) != false) iErrorsCounter++; } Console.WriteLine("-   = " + pUsedTerms.Count); Console.WriteLine("-   = " + Logic.Result.Terms.Count); Console.WriteLine("-  = " + iErrorsCounter); Console.ReadLine(); }</code> </pre><br></div></div><br><br>  نتيجة لوظيفة الاختبار ، يتم حساب عدد المصطلحات في الحد الأدنى من الشكل العادي المفصل وعدد الأخطاء التي تغطيها مع مجموعة المصطلحات الأصلية. <br><br>  في الختام ، أود أن أشير إلى أن هذا التطبيق للخوارزمية أثبت عمليًا أنه وسيلة فعالة وموثوقة لتقليل الوظائف المنطقية المحددة بواسطة مجموعتين غير مكتملتين من المصطلحات التي تأخذ فيها الوظيفة المنطقية قيم TRUE و FALSE ، على التوالي.  بالطبع ، يمكن استخدام هذا التطبيق أيضًا في الشكل الكلاسيكي في حالة وظيفة إدخال منطقية محددة بالكامل ، عندما يتم إدخال قائمة مصطلحات واحدة أو أخرى فقط.  على سبيل العيب ، من الضروري التحقق في وظيفة Skleivanie من عدم وجود أخطاء في التغطية لكل مصطلح افتراضي لقائمة مصطلحات المصدر الكاملة عند كل تكرار للخوارزمية ، مما يؤدي إلى تكاليف زمنية كبيرة مع عدد كبير من مصطلحات الإدخال. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar424517/">https://habr.com/ru/post/ar424517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar424505/index.html">"لدينا أفكار لـ Maven 4 وحتى Maven 5" - مقابلة مع روبرت شولت ، أحد المشاركين الرئيسيين في مشروع Maven</a></li>
<li><a href="../ar424507/index.html">السادس السنوي JetBrains Hackathon: Shiftius Altius Ctrlius</a></li>
<li><a href="../ar424509/index.html">العمل مع KOMPAS-3D API → الدرس 12 → الخطوط المركبة</a></li>
<li><a href="../ar424511/index.html">أدوات للعثور على فئات مشروحة في جافا</a></li>
<li><a href="../ar424513/index.html">حول مراكز البيانات الرخيصة وحماية ILV و DDoS</a></li>
<li><a href="../ar424519/index.html">هل يمكن لبيتهوفن إرسال طلبات الإزالة؟</a></li>
<li><a href="../ar424525/index.html">التحكم في سرعة الحفر الصغيرة</a></li>
<li><a href="../ar424531/index.html">الخدمات الصغيرة: الحجم مهم حتى لو كان لديك Kubernetes</a></li>
<li><a href="../ar424533/index.html">"أي شخص في مجال تكنولوجيا المعلومات يحترم نفسه يشارك في التكنولوجيا في وقت فراغه" - 10 أسئلة للمبرمج ، العدد 6</a></li>
<li><a href="../ar424537/index.html">أطلق بنك Sberbank المشغل الخاص به SberMobile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>