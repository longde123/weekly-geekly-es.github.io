<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏽 👩🏼‍✈️ 👨🏻‍🎓 «Programmation en direct»: comment s'est déroulée la demi-finale régionale du CIPC à l'Université ITMO ❌ ▶️ 🎋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Début décembre, la demi-finale du championnat du monde de programmation étudiante ICPC. Nous allons vous dire quels «essais» les participants ont pris...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>«Programmation en direct»: comment s'est déroulée la demi-finale régionale du CIPC à l'Université ITMO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/spbifmo/blog/433644/">  Début décembre, la demi-finale du championnat du monde de programmation étudiante ICPC.  Nous allons vous dire quels «essais» les participants ont pris et qui représentera la région Nord Eurasie au printemps, lors du principal tournoi mondial de programmateurs sportifs. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/jv/no/ci/jvnociayuanefgep0ihhfiyd8lc.jpeg"></a> <a name="habracut"></a><br>  <font color="#A9A9A9"><i><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">icpcnews</a> / Flickr / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CC BY</a> / Final ICPC-2017</sup></i></font> <br><br><h2>  Quinze gagnants </h2><br>  Des compétitions, auxquelles ont participé plus de 300 équipes, se sont déroulées simultanément sur quatre sites: à Saint-Pétersbourg, Barnaul, Tbilissi et Alma-Ata.  L'ITMO University a reçu plus d'une centaine d'équipes de Russie et des États baltes.  Les participants se sont battus pour la NEERC Northern Eurasia Cup et le droit d'aller à la finale du CIPC. <br><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que l'ICPC?</b> <div class="spoiler_text">  <i>Il s'agit d'un concours d'équipe pour les étudiants universitaires et les étudiants diplômés de la première année d'études.</i>  <i>Le championnat se déroule depuis plus de quarante ans.</i>  <i>Chaque équipe est composée de trois personnes et obtient un ordinateur qui n'a pas accès à Internet.</i>  <i>Sur cette machine, ils doivent résoudre conjointement une dizaine de tâches.</i>  <i>Cette approche vous permet de tester non seulement les connaissances des étudiants, mais aussi leurs compétences en travail d'équipe.</i>  <i>Les gagnants de l'Olympiade reçoivent des prix en espèces et des invitations à l'emploi de grandes sociétés informatiques.</i> <br></div></div><br>  L'équipe de l'Université d'État de Moscou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est devenue la</a> championne absolue, après avoir résolu onze problèmes.  Personne n'a plus réussi à faire ça.  Les deuxième et troisième places étaient des participants du MIPT.  La progression des "batailles" pouvait être regardée en direct.  Il existe un enregistrement sur la chaîne YouTube de l'ICPC: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FuzwimhgNU8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Au total, quinze équipes ont été sélectionnées lors de la finale de l'ICPC-2019 (la liste complète peut être consultée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ), y compris des gars de l'Université ITMO.  Fin mars, ils se rendront à Porto (Portugal) pour se battre pour le titre de champion du monde. <br><br><h2>  Comment se sont passées les demi-finales? </h2><br>  Les étudiants ont utilisé les langages de programmation Java, C ++, Python ou Kotlin.  Toutes les tâches exigeaient de l'attention, de la concentration et de la connaissance de divers algorithmes. <br><br>  Par exemple, la tâche suivante a été proposée par le double vainqueur de l'ICPC au sein de l'équipe de l'Université ITMO <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gennady Korotkevich</a> : <br><br><blockquote> <i>Il existe un graphique non pondéré non orienté.</i>  <i>La distance entre deux sommets <b>u</b> et <b>v</b> est déterminée par le nombre d'arêtes dans le chemin le plus court.</i>  <i>Trouvez la somme <b>d (u, v) de</b> toutes les paires de sommets désordonnées.</i> <i><br><br></i>  <i>Tout d'abord, deux nombres <b>n</b> et <b>m</b> (2 ≤ n ≤ 10 <sup>5</sup> ; n-1 ≤ m ≤ n + 42) - le nombre de sommets et d'arêtes, respectivement, est appliqué à l'entrée du programme.</i>  <i>Les sommets sont numérotés de <b>1</b> à <b>n</b> .</i>  <i>Ensuite, <b>m</b> lignes sont entrées avec deux valeurs entières: <b>x <sub>i</sub></b> et <b>y <sub>i</sub></b> (1 ≤ x <sub>i</sub> , y <sub>i</sub> ≤ n; x <sub>i</sub> ≠ y <sub>i</sub> ) - ce sont les points d'extrémité du ième bord.</i>  <i>Il existe au moins une arête entre n'importe quelle paire de sommets.</i> <br><br>  Exemple de programme avec une solution (proposé par un membre du jury): <br><br><div class="spoiler">  <b class="spoiler_title">Code C ++</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> _GLIBCXX_DEBUG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;bits/stdc++.h&gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;set&lt;int&gt;&gt; gs(n); for (int i = 0; i &lt; m; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; x--; y--; gs[x].insert(y); gs[y].insert(x); } long long ans = 0; vector&lt;int&gt; weight(n, 1); set&lt;pair&lt;int,int&gt;&gt; s; for (int i = 0; i &lt; n; i++) { s.emplace(gs[i].size(), i); } while (s.size() &gt; 1) { int i = s.begin()-&gt;second; assert(!gs[i].empty()); if (gs[i].size() &gt; 1) { break; } s.erase(s.begin()); int j = *gs[i].begin(); gs[i].clear(); ans += (long long) 2 * weight[i] * (n - weight[i]); weight[j] += weight[i]; auto it = gs[j].find(i); assert(it != gs[j].end()); s.erase({gs[j].size(), j}); gs[j].erase(it); s.emplace(gs[j].size(), j); } if (s.size() == 1) { cout &lt;&lt; ans / 2 &lt;&lt; '\n'; return 0; } vector&lt;vector&lt;int&gt;&gt; g(n); for (int i = 0; i &lt; n; i++) { g[i] = vector&lt;int&gt;(gs[i].begin(), gs[i].end()); } vector&lt;int&gt; id(n, -1); int cnt = 0; for (int i = 0; i &lt; n; i++) { if ((int) g[i].size() &gt; 2) { id[i] = cnt++; } } if (cnt == 0) { for (int i = 0; i &lt; n; i++) { if ((int) g[i].size() == 2) { id[i] = cnt++; break; } } assert(cnt &gt; 0); } vector&lt;int&gt; rev_id(n, -1); for (int i = 0; i &lt; n; i++) { if (id[i] != -1) { rev_id[id[i]] = i; } } vector&lt;vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&gt; edges(cnt, vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;(cnt)); for (int i = 0; i &lt; n; i++) { if (id[i] &gt;= 0) { for (int j : g[i]) { if (id[j] &gt;= 0) { edges[id[i]][id[j]].emplace_back(); } } } } for (int i = 0; i &lt; n; i++) { if ((int) g[i].size() == 2 &amp;&amp; id[i] == -1) { vector&lt;int&gt; edge; edge.push_back(weight[i]); id[i] = -2; vector&lt;int&gt; fin(2); for (int dir = 0; dir &lt; 2; dir++) { int x = g[i][dir]; int px = i; while (id[x] == -1) { assert((int) g[x].size() == 2); edge.push_back(weight[x]); id[x] = -2; int nx = px ^ g[x][0] ^ g[x][1]; px = x; x = nx; } fin[dir] = x; reverse(edge.begin(), edge.end()); } edges[id[fin[1]]][id[fin[0]]].push_back(edge); } } vector&lt;vector&lt;int&gt;&gt; dist(cnt, vector&lt;int&gt;(cnt, n + 1)); for (int i = 0; i &lt; cnt; i++) { dist[i][i] = 0; } for (int i = 0; i &lt; cnt; i++) { for (int j = 0; j &lt; cnt; j++) { for (auto &amp;p : edges[i][j]) { dist[i][j] = dist[j][i] = min(dist[i][j], (int) p.size() + 1); } } } for (int k = 0; k &lt; cnt; k++) { for (int i = 0; i &lt; cnt; i++) { for (int j = 0; j &lt; cnt; j++) { dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); } } } vector&lt;vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt;&gt; edge_pref_sum(cnt, vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt;(cnt)); vector&lt;vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt;&gt; edge_pref_sum_by_pos(cnt, vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt;(cnt)); for (int i = 0; i &lt; cnt; i++) { for (int j = 0; j &lt; cnt; j++) { edge_pref_sum[i][j].resize(edges[i][j].size()); edge_pref_sum_by_pos[i][j].resize(edges[i][j].size()); for (int k = 0; k &lt; (int) edges[i][j].size(); k++) { edge_pref_sum[i][j][k].resize(edges[i][j][k].size() + 1); edge_pref_sum_by_pos[i][j][k].resize(edges[i][j][k].size() + 1); for (int t = 0; t &lt; (int) edges[i][j][k].size(); t++) { edge_pref_sum[i][j][k][t + 1] = edge_pref_sum[i][j][k][t] + edges[i][j][k][t]; edge_pref_sum_by_pos[i][j][k][t + 1] = edge_pref_sum_by_pos[i][j][k][t] + (long long) edges[i][j][k][t] * t; } } } } auto get = [&amp;](int i, int j, int k, int from, int to, int coeff_from, int coeff_to) -&gt; long long { if (from &gt; to) { return 0; } assert(0 &lt;= from &amp;&amp; to &lt;= (int) edges[i][j][k].size() - 1); long long ret = (edge_pref_sum[i][j][k][to + 1] - edge_pref_sum[i][j][k][from]) * coeff_from; if (coeff_from != coeff_to) { assert(abs(coeff_from - coeff_to) == to - from); long long other = edge_pref_sum_by_pos[i][j][k][to + 1] - edge_pref_sum_by_pos[i][j][k][from]; other -= (edge_pref_sum[i][j][k][to + 1] - edge_pref_sum[i][j][k][from]) * from; ret += other * (coeff_from &lt; coeff_to ? 1 : -1); } return ret; }; for (int v = 0; v &lt; cnt; v++) { long long w = weight[rev_id[v]]; for (int j = 0; j &lt; cnt; j++) { ans += dist[v][j] * w * weight[rev_id[j]]; } for (int i = 0; i &lt; cnt; i++) { for (int j = 0; j &lt; cnt; j++) { for (int k = 0; k &lt; (int) edges[i][j].size(); k++) { int x = dist[v][i]; int y = dist[v][j]; int cc = (y - x + (int) edges[i][j][k].size() + 1) / 2; cc = min(max(cc, 0), (int) edges[i][j][k].size()); ans += w * get(i, j, k, 0, cc - 1, x + 1, x + cc); ans += w * get(i, j, k, cc, (int) edges[i][j][k].size() - 1, y + ((int) edges[i][j][k].size() - cc), y + 1); } } } } vector&lt;pair&lt;int,int&gt;&gt; pairs; for (int i = 0; i &lt; cnt; i++) { for (int j = 0; j &lt; cnt; j++) { if (!edges[i][j].empty()) { pairs.emplace_back(i, j); } } } for (int ii = 0; ii &lt; cnt; ii++) { for (int jj = 0; jj &lt; cnt; jj++) { for (int kk = 0; kk &lt; (int) edges[ii][jj].size(); kk++) { for (int tt = 0; tt &lt; (int) edges[ii][jj][kk].size(); tt++) { long long w = edges[ii][jj][kk][tt]; for (int i = 0; i &lt; cnt; i++) { int d1 = dist[ii][i] + tt + 1; int d2 = dist[jj][i] + (int) edges[ii][jj][kk].size() - tt; ans += w * weight[rev_id[i]] * min(d1, d2); } for (auto &amp;p : pairs) { int i = p.first; int j = p.second; for (int k = 0; k &lt; (int) edges[i][j].size(); k++) { if (i == ii &amp;&amp; j == jj &amp;&amp; k == kk) { int d1 = tt; int d2 = (int) edges[ii][jj][kk].size() - tt + dist[i][j] + 1; if (d1 &lt;= d2) { ans += w * get(i, j, k, 0, tt, tt, 0); } else { int cut = (d1 - d2 + 1) / 2; ans += w * get(i, j, k, 0, cut - 1, d2, d2 + cut - 1); ans += w * get(i, j, k, cut, tt, tt - cut, 0); } int d3 = (int) edges[ii][jj][kk].size() - 1 - tt; int d4 = tt + 1 + dist[i][j] + 1; if (d3 &lt;= d4) { ans += w * get(i, j, k, tt, (int) edges[i][j][k].size() - 1, 0, (int) edges[i][j][k].size() - 1 - tt); } else { int cut = (d3 - d4 + 1) / 2; ans += w * get(i, j, k, (int) edges[i][j][k].size() - cut, (int) edges[i][j][k].size() - 1, d4 + cut - 1, d4); ans += w * get(i, j, k, tt, (int) edges[i][j][k].size() - 1 - cut, 0, (int) edges[i][j][k].size() - 1 - cut - tt); } } else { int d1 = dist[ii][i] + tt + 1; int d2 = dist[jj][i] + (int) edges[ii][jj][kk].size() - tt; int d3 = dist[ii][j] + tt + 1; int d4 = dist[jj][j] + (int) edges[ii][jj][kk].size() - tt; int x = min(d1, d2); int y = min(d3, d4); int cc = (y - x + (int) edges[i][j][k].size() + 1) / 2; cc = min(max(cc, 0), (int) edges[i][j][k].size()); ans += w * get(i, j, k, 0, cc - 1, x + 1, x + cc); ans += w * get(i, j, k, cc, (int) edges[i][j][k].size() - 1, y + ((int) edges[i][j][k].size() - cc), y + 1); } } } } } } } assert(ans % 2 == 0); cout &lt;&lt; ans / 2 &lt;&lt; '\n'; return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Et voici le code que l'une des équipes participantes a proposé comme solution: <br><br><div class="spoiler">  <b class="spoiler_title">Code C ++</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;bits/stdc++.h&gt; #define ll long long #define ld long double using namespace std; int main() { int n,m; cin&gt;&gt;n&gt;&gt;m; int b[n+1][n+1]={}; int c[n+1][n+1]={}; int a1,b1; vector &lt; vector &lt;int&gt; &gt; v(n+1); vector &lt;int&gt; met(n+1); queue &lt;int&gt; q; for(int i=0;i&lt;m;i++){ cin&gt;&gt;a1&gt;&gt;b1; v[a1].push_back(b1); v[b1].push_back(a1); c[a1][b1]=1; c[b1][a1]=1; } long long ans=0; for(int i=1;i&lt;=n;i++){ q.push(i); met.clear(); met.resize(n+1); while(!q.empty()){ int frontt = q.front(); met[frontt]=1; for(int j=0;j&lt;v[frontt].size();j++){ if(!met[v[frontt][j]]){ if(b[i][frontt]+1&lt;b[i][v[frontt][j]] || b[i][v[frontt][j]]==0){ ans-=b[i][v[frontt][j]]; b[i][v[frontt][j]]=b[i][frontt]+1; ans+=b[i][v[frontt][j]]; } q.push(v[frontt][j]); met[v[frontt][j]]=1; } } q.pop(); } } cout&lt;&lt;ans/2; return 0; }</span></span></span></span></code> </pre><br></div></div><br>  L'analyse de la solution se trouve dans le document officiel sur notre site Internet ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page 3</a> ). <br></blockquote><br>  Une autre tâche est les «échecs»: <br><br><blockquote>  <i>Elma apprend à jouer aux échecs et sait déjà que la tour se déplace horizontalement ou verticalement.</i>  <i>La grand-mère d'Elma lui a donné un échiquier 8x8 et lui a demandé de trouver un moyen de déplacer la tour de la cellule A1 à H8 en <b>n</b> mouvements.</i>  <i>Dans ce cas, toutes les cellules sur lesquelles la figure s'arrête doivent être différentes.</i>  <i>L'entrée est fournie avec la valeur <b>n</b> (2 ≤ n ≤ 63).</i>  <i>Les participants doivent lister toutes les cellules sur lesquelles Elma a placé la tour.</i> <br><br>  Voici un exemple de la solution à ce problème qui a été proposée par les membres du jury: <br><br><div class="spoiler">  <b class="spoiler_title">Code Java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.InputStreamReader; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.StringTokenizer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">easy_chess_va_wa</span></span></span><span class="hljs-class"> </span></span>{ BufferedReader br; StringTokenizer st; PrintWriter out; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (st == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !st.hasMoreTokens()) { st = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringTokenizer(br.readLine()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> st.nextToken(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nextInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Integer.parseInt(nextToken()); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) (<span class="hljs-string"><span class="hljs-string">'a'</span></span> + x) + <span class="hljs-string"><span class="hljs-string">""</span></span> + (y + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = nextInt() + <span class="hljs-number"><span class="hljs-number">1</span></span>; ArrayList&lt;Cell&gt; cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = Math.min(<span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>, n + <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">7</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span> &amp;&amp; cells.size() &lt; k; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">8</span></span> &amp;&amp; cells.size() &lt; k; j++) { cells.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ? j : <span class="hljs-number"><span class="hljs-number">7</span></span> - j, i)); } } Cell last = cells.get(cells.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (last.x != <span class="hljs-number"><span class="hljs-number">7</span></span>) { cells.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(last.x, <span class="hljs-number"><span class="hljs-number">7</span></span>)); } cells.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; j++) { cells.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ? j : <span class="hljs-number"><span class="hljs-number">7</span></span> - j, i)); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; j++) { cells.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(i, i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">7</span></span> - j : <span class="hljs-number"><span class="hljs-number">6</span></span> + j)); } } Cell last = cells.get(cells.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (last.y != <span class="hljs-number"><span class="hljs-number">7</span></span>) { cells.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(last.x, <span class="hljs-number"><span class="hljs-number">7</span></span>)); } cells.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cell(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cells.size() &gt; n) { cells.remove(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Cell cell : cells) { out.print(cell + <span class="hljs-string"><span class="hljs-string">" "</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { br = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(System.in)); out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(System.out); solve(); out.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { e.printStackTrace(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> easy_chess_va_wa().run(); } }</code> </pre><br></div></div></blockquote><br>  La liste complète des tâches est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publiée sur le site officiel du concours</a> .  Vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">y trouverez des réponses</a> avec une analyse détaillée des solutions.  Le code que les participants ont suggéré <a href="">se trouve dans une archive distincte</a> , et <a href="">ici</a> vous pouvez trouver toutes les solutions et tests qui ont été utilisés pour la vérification automatique. <br><br>  Pendant l'Olympiade, les participants ont transmis leurs décisions à un serveur de test, qui a «vérifié» le code sur un ensemble de tests pré-préparé.  En cas de réussite de tous les tests, les participants ont obtenu des points.  Sinon, l'équipe a reçu des commentaires sur l'erreur et pourrait apporter des modifications au code. <br><br>  Selon les règles de l'ICPC, l'équipe qui a résolu la plupart des tâches gagne. <br><br>  Si plusieurs participants ont marqué le même nombre de points à la fois, leur position au classement est déterminée par le temps de pénalité.  Le temps de pénalité est cumulé pour chaque problème correctement résolu et est égal au temps écoulé depuis le début de la compétition jusqu'à ce que le code réussisse tous les tests.  De plus, pour chaque tentative infructueuse de réussir la tâche, 20 minutes s'ajoutent à la pénalité (seulement si à la fin le problème peut être résolu).  Aucune pénalité n'est accordée si l'équipe n'a pas proposé la bonne solution au problème. <br><br><img src="https://habrastorage.org/webt/ui/ob/gc/uiobgcaexajii8mncx3ehpdyexw.jpeg"><br>  <font color="#A9A9A9"><i><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">icpcnews</a> / Flickr / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CC BY</a> / Final ICPC-2017</sup></i></font> <br><br><h2>  Pourquoi les finalistes concourront-ils? </h2><br>  Comme nous l'avons déjà dit, les champions de demi-finale - quinze équipes - iront au Portugal, dans la ville de Porto, où ils se battront pour la Coupe du monde et 15 000 $.  Les équipes qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">se</a> classeront du premier au quatrième seront récompensées par des médailles d'or.  Les participants qui «ont terminé» aux places du cinquième au huitième recevront des médailles d'argent, et du neuvième au douzième - le bronze.  Des prix en espèces leur sont également fournis. <br><br>  L'équipe de l'Université ITMO est devenue championne de l'ICPC à sept reprises (la dernière - en 2017).  C'est un record du monde qui n'a encore été battu par personne: en deuxième position du nombre de titres de champion se trouvent également des compatriotes, l'Université d'État de Saint-Pétersbourg, avec quatre coupes, et les rivaux étrangers les plus proches, l'American Stanford et l'Université chinoise de Jao Tong - trois victoires.  Pendant sept années consécutives, l'équipe russe a remporté la finale mondiale.  Espérons qu'à ICPC 2019 les gars montreront un résultat décent. <br><br>  À propos de ce que nous écrivons d'autre sur Habré: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ITMO University Digest: Nouvelles études et projets internationaux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment fonctionne le cours de programmation de bas niveau à l'Université ITMO</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433644/">https://habr.com/ru/post/fr433644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433632/index.html">Une autre application mobile a "divulgué" les données de ses utilisateurs</a></li>
<li><a href="../fr433634/index.html">Surveillance des ruches | Moi Dadan et demi-ukrainien | Redondance des données</a></li>
<li><a href="../fr433636/index.html">Lampe de poche-charge-kubotan: une bonne idée ou un mannequin</a></li>
<li><a href="../fr433638/index.html">Décomposition de projet pour frontend</a></li>
<li><a href="../fr433642/index.html">Vous n'aimez pas les systèmes CRM? Vous ne savez tout simplement pas comment les faire cuire</a></li>
<li><a href="../fr433646/index.html">Staffcop: vue latérale</a></li>
<li><a href="../fr433648/index.html">Le premier profit de l'histoire des services de streaming occidentaux: pourquoi ce n'est pas une si bonne nouvelle</a></li>
<li><a href="../fr433650/index.html">Istio et Kubernetes en production. Partie 2. Traçage</a></li>
<li><a href="../fr433652/index.html">La 5G vue par les utilisateurs. Attentes et préoccupations</a></li>
<li><a href="../fr433658/index.html">IT in Germany - comment chercher du travail dans les grandes villes en Allemagne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>