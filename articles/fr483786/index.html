<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèª ü§≤üèø üèä Tri hybride üëÜüèø üì∞ üßîüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comme tout le monde le sait d√©j√†, le tri peut √™tre bas√© sur les √©changes, les insertions, la s√©lection, la fusion et la distribution. 

 Mais si diff√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tri hybride</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/483786/"> <a href="https://habr.com/ru/company/edison/blog/483786/"><img width="694" height="321" src="https://habrastorage.org/webt/ql/cs/2p/qlcs2psim6ksv4hbrwrndioyifi.png"></a> <br><br>  Comme tout le monde le sait d√©j√†, le tri peut √™tre bas√© sur les √©changes, les insertions, la s√©lection, la fusion et la distribution. <br><br>  Mais si diff√©rentes m√©thodes sont combin√©es dans l'algorithme, alors il appartient √† la classe des sortes hybrides. <a name="habracut"></a><habracut text=""></habracut><blockquote> <a href="https://www.edsd.ru/" title="Logiciel EDISON - d√©veloppement web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Logiciel EDISON - d√©veloppement web"></a> <br clear="right">  Cet article a √©t√© √©crit avec le soutien d'EDISON. <br><br>  Nous sommes engag√©s dans la <a href="https://www.edsd.ru/ru/o_kompanii/novosti/dorabotka-i-soprovozhdenie-sajta-na-1s-bitriks">r√©alisation et la maintenance de sites sur 1C-Bitrix</a> , ainsi que dans le <a href="https://www.edsd.ru/ru/proekty/mobilnye_prilozhenija">d√©veloppement d'applications mobiles Android et iOS</a> . <br><br>  Nous aimons la th√©orie des algorithmes!  ;-) </blockquote>  Rappelons rapidement quels sont les algorithmes de tri des classes et quelles sont les fonctionnalit√©s de chacun d'eux. <br><br><h4>  Exchange Sorts </h4><img align="right" width="350" height="132" src="https://habrastorage.org/webt/ay/2k/km/ay2kkmr3ipze-pdbcmxfjgdp-le.png"><br>  Les √©l√©ments du r√©seau sont compar√©s deux √† deux et des √©changes sont effectu√©s pour des paires d√©sordonn√©es. <br><br>  Le repr√©sentant le plus efficace de cette classe est le <b>tri rapide</b> l√©gendaire. <br><br><h4>  Tri d'insertion </h4><img align="right" width="398" height="102" src="https://habrastorage.org/webt/tm/hd/35/tmhd35egnxxtisoa_zd8d_ucggi.png"><br>  Les √©l√©ments de la partie non tri√©e du tableau sont ins√©r√©s √† leur place dans la zone tri√©e. <br><br>  Dans cette classe, le <b>tri par insertions simples est le</b> plus souvent utilis√©.  Bien que cet algorithme ait une complexit√© moyenne de O ( <b>n <sup>2</sup></b> ), ce tri fonctionne tr√®s rapidement avec des tableaux presque ordonn√©s - sur eux la complexit√© atteint O ( <b>n</b> ).  De plus, ce tri est l'une des meilleures options pour le traitement de petits tableaux. <br><br>  <b>Le tri √† l'aide de l'arbre de recherche binaire</b> appartient √©galement √† cette classe. <br><br><h4>  Trier par s√©lection </h4><img align="right" width="300" height="100" src="https://habrastorage.org/webt/gp/bh/ho/gpbhhomuobutgbg6l-r9basjzlg.png"><br>  Dans la zone non ordonn√©e, l'√©l√©ment minimum / maximum est s√©lectionn√©, qui est transf√©r√© √† la fin / au d√©but de la partie non tri√©e du tableau. <br><br>  Le tri avec un choix simple fonctionne tr√®s lentement (en moyenne O ( <b>n <sup>2</sup></b> )), mais dans cette classe il y a un <b>tri</b> difficile <b>par tas</b> (aka <b>tri pyramidal</b> ), qui a une complexit√© temporelle de O ( <b>n</b> log <b>n</b> ) - et, ce qui est tr√®s pr√©cieux, Il n'y a pas de cas d√©g√©n√©r√©s de ce tri, quelles que soient les donn√©es entrantes.  Soit dit en passant, ce tri n'a pas non plus les meilleurs cas pour les donn√©es entrantes. <br><br><h4>  Fusionner les tris </h4><br>  Les zones tri√©es sont prises dans le tableau et elles sont fusionn√©es, c'est-√†-dire que les sous-r√©seaux tri√©s plus petits sont combin√©s en un sous-tableau tri√© plus grand. <br><br><div style="text-align:center;"><img width="677" height="50" src="https://habrastorage.org/webt/qm/mh/vn/qmmhvnkmevjb34akg2dxjquef90.png"></div><br><br>  Si deux sous-r√©seaux sont tri√©s, leur combinaison est une op√©ration facile √† mettre en ≈ìuvre et rapide.  Le revers de la m√©daille est que la fusion n√©cessite presque toujours le co√ªt de la m√©moire suppl√©mentaire O ( <b>n</b> ) - bien qu'il existe tr√®s peu d'options tr√®s sophistiqu√©es pour trier avec la fusion, o√π le co√ªt de la m√©moire est O (1). <br><br><h4>  Trier par distribution </h4><br>  Les √©l√©ments du tableau sont distribu√©s et redistribu√©s en classes jusqu'√† ce que le tableau accepte un √©tat tri√©. <br><br>  Les √©l√©ments sont dispers√©s en groupes soit en fonction de leur valeur (les soi-disant <b>triages de comptage</b> ) soit en fonction de la valeur des chiffres individuels (ce sont d√©j√† <b>des triages au niveau du bit</b> ). <br><br><div style="text-align:center;"><img width="657" height="219" src="https://habrastorage.org/webt/42/ch/6z/42ch6zg2eg2zfkqbmgxmte9arii.png"></div><br><br>  <b>Le tri</b> par <b>seau</b> appartient √©galement √† cette classe. <br><br>  Une caract√©ristique du tri par distribution est qu'ils n'utilisent pas de comparaisons par paire d'√©l√©ments entre eux, ou que de telles comparaisons sont pr√©sentes dans une faible mesure.  Par cons√©quent, le tri par distribution est souvent en avance sur la vitesse, par exemple, le tri rapide.  D'un autre c√¥t√©, le tri par distribution n√©cessite souvent beaucoup de m√©moire suppl√©mentaire, car les groupes d'√©l√©ments constamment redistribu√©s doivent √™tre stock√©s quelque part. <br><br><hr><hr><hr><hr><hr><br>  Les diff√©rends concernant le tri <i>le plus</i> efficace sont tr√®s fr√©quents, mais le fait est qu'il n'y a pas et ne peut pas √™tre un algorithme id√©al pour toutes les occasions.  Par exemple, le tri rapide est vraiment tr√®s rapide (mais pas le plus rapide) dans la plupart des situations, mais il rencontre √©galement des cas d√©g√©n√©r√©s dans lesquels un crash se produit.  Le tri par insertions simples est lent, mais pour les tableaux presque ordonn√©s, il contournera facilement les autres algorithmes.  Le tri de tas fonctionne assez rapidement avec toutes les donn√©es entrantes, mais pas aussi rapidement que d'autres tri dans certaines conditions et il n'y a aucun moyen d'acc√©l√©rer la pyramide.  Le tri par fusion est plus lent que le tri rapide, mais s'il existe des sous-tableaux tri√©s dans le tableau, il est plus rapide de les fusionner que le tri par tri rapide.  Si le tableau contient de nombreux √©l√©ments r√©p√©titifs ou si nous trions les lignes, le tri par distribution est probablement la meilleure option.  Chaque m√©thode est particuli√®rement bonne dans sa situation la plus favorable. <br><br>  N√©anmoins, les programmeurs continuent d'inventer les tris les plus rapides au monde, synth√©tisant les m√©thodes les plus efficaces de diff√©rentes classes.  Voyons √† quel point c'est r√©ussi pour eux. <br><br>  √âtant donn√© que de nombreux algorithmes non triviaux sont mentionn√©s dans l'article, je ne couvre que bri√®vement les principes de base de leur travail, sans surcharger l'article d'animations et d'explications d√©taill√©es.  √Ä l'avenir, il y aura des articles s√©par√©s, o√π il y aura des dessins anim√©s pour chaque algorithme et des nuances subtiles d√©taill√©es. <br><br><hr><hr><hr><hr><hr><br><h2>  Ins√©rer + fusionner </h2><br>  Une conclusion purement empirique est que la fusion et / ou l'insertion sont le plus souvent utilis√©es dans les hybrides.  Dans la plupart des tri, on trouve l'une ou l'autre m√©thode, ou les deux ensemble.  Et il y a une explication logique √† cela. <br><br>  Les inventeurs de tri s'efforcent souvent de cr√©er des algorithmes parall√®les qui ordonnent simultan√©ment diff√©rentes parties d'un tableau.  La meilleure fa√ßon de traiter plusieurs sous-r√©seaux tri√©s est de les fusionner - ce sera le plus rapide. <br><br>  Les algorithmes modernes utilisent souvent la r√©cursivit√©.  Lors d'une descente r√©cursive, le r√©seau est g√©n√©ralement divis√© en deux parties; au niveau le plus bas, le r√©seau est ordonn√©.  Lorsque l'on revient √† des niveaux de r√©cursivit√© sup√©rieurs, la question se pose de combiner des sous-r√©seaux tri√©s √† des niveaux inf√©rieurs. <br><br>  En ce qui concerne les insertions, dans des algorithmes hybrides √† certaines √©tapes, on obtient souvent des sous-r√©seaux approximativement ordonn√©s, qui sont mieux conduits √† la commande finale √† l'aide d'inserts. <br><br>  Ce groupe contient des tris hybrides, dans lesquels il y a une fusion et une insertion, et ces m√©thodes sont utilis√©es tr√®s diff√©remment. <br><br><h3>  Tri par fusion-insertion <br>  Algorithme Ford Johnson :: Algorithme Ford-Johnson </h3><br><h4>  <i>Fusionner + Ins√©rer</i> </h4><img align="right" width="200" height="285" src="https://habrastorage.org/webt/pr/io/c-/prioc-ed14huk3as3gadpjccxks.jpeg"><br clear="left">  Une mani√®re tr√®s ancienne, d√©j√† en 1959.  Il est d√©crit en d√©tail dans le travail immortel de Donald Knuth, ¬´The Art of Programming¬ª, Volume 3, ¬´Sorting and Searching¬ª, Chapter 5, ¬´Sorting¬ª, Section 5.3, ¬´Optimal Sorting¬ª, sous-section, ¬´Sorting with a minimum number of comparisons¬ª, and part ¬´Sorting by Inserts and Merging¬ª. . <br><br>  Le tri n'a plus de valeur pratique, mais il est int√©ressant pour ceux qui aiment la th√©orie des algorithmes.  Le probl√®me de trouver un moyen de trier <b>n</b> √©l√©ments avec le moins de comparaisons est consid√©r√©.  Une modification heuristique non triviale du tri par insertion (une telle insertion que vous ne trouverez nulle part ailleurs) utilisant des <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0_%25D0%25AF%25D0%25BA%25D0%25BE%25D0%25B1%25D1%2581%25D1%2582%25D0%25B0%25D0%25BB%25D1%258F">nombres de Jacobstal est propos√©e</a> afin de minimiser le nombre de comparaisons.  √Ä ce jour, il est √©galement connu que ce n'est pas la meilleure option et vous pouvez encore plus habilement esquiver et obtenir encore moins de comparaisons.  En g√©n√©ral, le tri acad√©mique standard n'est pas d'une utilit√© pratique, mais pour les connaisseurs du genre, c'est un plaisir de d√©monter de telles astuces avec un biais alg√©brique. <br><br><h3>  Tim Sort :: Timsort </h3><br><h4>  <i>Ins√©rer + fusionner</i> </h4><img align="right" width="530" height="192" src="https://habrastorage.org/webt/cu/mf/fu/cumfful_rsg9ipz1yryimfpldxi.jpeg"><br clear="left">  <i>Publi√© par Tim Peters il y a 15 ans et maintenant</i> <br><br>  Ce tri sur Habr√© est tr√®s souvent rappel√©. <br>  Th√®se: dans un tableau, on recherche des petits sous-r√©seaux presque ordonn√©s pour lesquels le tri par insertion est utilis√©.  Ces sous-r√©seaux sont ensuite fusionn√©s √† l'aide de la fusion. <br><br>  La fusion dans TimSort est la partie la plus int√©ressante: la fusion ascendante classique est encore optimis√©e pour diff√©rentes situations.  Par exemple, il est connu que la fusion est plus efficace si les sous-r√©seaux joints ont approximativement la m√™me taille.  Dans TimSort, si les tailles sont tr√®s diff√©rentes, apr√®s des actions suppl√©mentaires, il y a un ajustement (nous pouvons dire qu'une partie des √©l√©ments ¬´coulera¬ª du plus grand sous-tableau vers un plus petit, apr√®s quoi la fusion se poursuivra en mode standard).  Diverses situations insidieuses sont √©galement fournies - par exemple, si dans un sous-tableau tous les √©l√©ments seront inf√©rieurs √† ceux d'un autre.  Dans ce cas, la comparaison des √©l√©ments des deux sous-r√©seaux sera inactive.  La proc√©dure de fusion modifi√©e ¬´remarquera¬ª une telle √©volution ind√©sirable des √©v√©nements dans le temps, et si elle est ¬´convaincue¬ª d'une option pessimiste utilisant la recherche binaire, elle passera √† une option de traitement plus optimale. <br><br>  En moyenne, ce tri fonctionne un peu plus lentement que QuickSort, cependant, si le tableau entrant contient un nombre suffisant de sous-s√©quences ordonn√©es d'√©l√©ments, alors la vitesse augmente de mani√®re significative et ici TimSort devance les autres. <br><br><h3>  Tri par fusion de blocs :: Tri par fusion de blocs <br>  Wiki-sort :: Wiki-sort <br>  Holy Grail Sort :: Grailsort </h3><br><h4>  <i>Inserts + Fusionner + Godets</i> </h4><img align="right" width="343" height="240" src="https://habrastorage.org/webt/bz/ev/g6/bzevg6rsbv563fjqzz-hsqpfeso.gif"><br clear="left">  <i>Animation de tri par fusion de blocs de Wikipedia.</i> <br><br>  Il s'agit d'un algorithme tr√®s r√©cent (2008) et en m√™me temps tr√®s prometteur.  Le fait est que le probl√®me relativement important de la fusion est le co√ªt de la m√©moire suppl√©mentaire.  Habituellement, l√† o√π la fusion est l√†, il y a aussi la complexit√© de la m√©moire O ( <b>n</b> ). <br><br>  Mais WikiSort est con√ßu pour que la fusion se fasse sans l'utilisation de m√©moire suppl√©mentaire - parmi les types de fusion, √† cet √©gard, il s'agit d'un cas tr√®s rare.  De plus, l'algorithme est stable.  Eh bien, si le tri par fusion conventionnel a la meilleure vitesse algorithmique O ( <b>n</b> log <b>n</b> ), alors dans le tri wiki, cet indicateur est O ( <b>n</b> ).  Jusqu'√† r√©cemment, on pensait que fusionner le tri avec un tel ensemble de caract√©ristiques √©tait en principe impossible, mais les programmeurs chinois ont surpris tout le monde. <br><br>  L'algorithme est tr√®s compliqu√© √† expliquer en quelques phrases.  Mais un jour j'√©crirai une habrast distincte √† son sujet. <br><br>  Initialement, l'algorithme √©tait appel√© sans nom Block Merge Sort, cependant, avec la main l√©g√®re de Tim Peters, qui a √©tudi√© le tri en d√©tail (pour d√©terminer si certaines de ses id√©es devraient √™tre transf√©r√©es √† TimSort), le nom WikiSort y est rest√©. <br><br>  Le habruiser partant pr√©matur√©ment <a href="https://habr.com/ru/users/mrrl/" class="user_link">Mrrl a</a> travaill√© ind√©pendamment pendant plusieurs ann√©es sur le tri par fusion, qui serait simultan√©ment rapide avec toutes les donn√©es entrantes, √©conomique en m√©moire et stable.  <a href="https://habr.com/ru/post/205290/">Ses recherches cr√©atives ont √©t√© couronn√©es de succ√®s</a> et il a appel√© plus tard l'algorithme d√©velopp√© un tri du Saint Graal (car il r√©pond √† toutes les exigences √©lev√©es du ¬´tri parfait¬ª).  La plupart des id√©es de cet algorithme sont similaires √† celles impl√©ment√©es dans WikiSort, bien que ces sortes ne soient pas identiques et soient d√©velopp√©es ind√©pendamment les unes des autres. <br><br><h3>  Tri de table de hachage :: Tri de table de hachage </h3><br><h4>  <i>Distribution + Insertion + Fusion</i> </h4><br>  Le tableau est r√©cursivement divis√© en deux, jusqu'√† ce que le nombre d'√©l√©ments dans les sous-r√©seaux r√©sultants atteigne une certaine valeur de seuil.  Au niveau de r√©cursivit√© le plus bas, une distribution approximative se produit (√† l'aide d'une table de hachage) et le sous-tableau est tri√© par insertions.  Ensuite, il y a un retour r√©cursif √† des niveaux sup√©rieurs, les moiti√©s tri√©es sont combin√©es par fusion. <br><br>  J'ai <a href="https://habr.com/ru/post/478654/">parl√© un</a> peu plus de cet algorithme il y a un <a href="https://habr.com/ru/post/478654/">mois</a> . <br><br><hr><hr><hr><hr><hr><br><h2>  Tri rapide comme principal </h2><br>  Apr√®s la fusion et l'insertion, la troisi√®me place du hit-parade hybride est fermement d√©tenue par le tri rapide pr√©f√©r√© de tous. <br><br>  Il s'agit d'un algorithme tr√®s efficace, mais il existe √©galement des cas d√©g√©n√©r√©s.  Certains inventeurs tentent de rendre QuickSort compl√®tement invuln√©rable √† toute mauvaise donn√©e entrante et sugg√®rent de la compl√©ter avec des id√©es fortes d'autres types. <br><br><h3>  Tri introspectif :: Introsort, tri introspectif, std :: sort </h3><br><h4>  <i>Inserts rapides + tas +</i> </h4><img align="right" width="395" height="470" src="https://habrastorage.org/webt/kq/om/vq/kqomvqs3ugrvl1xdnrw0vm54jnu.png"><br clear="left">  Le tri par tas fonctionne un peu plus lentement que le tri rapide, mais en m√™me temps, contrairement √† QuickSort, il n'a pas de cas d√©g√©n√©r√©s - la complexit√© temporelle algorithmique moyenne, meilleure et pire est O ( <b>n</b> log <b>n</b> ). <br><br>  Par cons√©quent, David Musser a propos√© d'√™tre s√ªr lors du tri rapide - s'il y a un niveau d'imbrication trop √©lev√©, cela est consid√©r√© comme une attaque contre le syst√®me, qui a gliss√© un "mauvais" tableau.  Le passage au tri par segment de m√©moire se produit, ce qui n'est pas m√©gaoctet, mais pas non plus lent pour faire face <nobr><i>aux</i></nobr> donn√©es entrantes. <br><br>  C ++ poss√®de un algorithme appel√© std :: sort, qui est une impl√©mentation du tri introspectif.  Un petit ajout - si au niveau de r√©cursivit√© suivant le <nobr>nombre d'√©l√©ments du sous-tableau est ‚â§ 16</nobr> , alors le tri par insertion est appliqu√© au sous-tableau. <br><br><h3>  Tri multi-points :: Tri multi-points <br>  Tri rapide au niveau du bit :: Tri rapide Radix </h3><br><h4>  <i>Fast + rangs</i> </h4><br>  Tri rapide, seules les valeurs des √©l√©ments du tableau sont compar√©es, mais leurs chiffres individuels (d'abord, nous organisons les chiffres les plus √©lev√©s de cette mani√®re, nous passons des plus jeunes √† eux). <br><br>  Ou alors - c'est un tri au niveau du bit par ordre √©lev√©, l'ordre √† l'int√©rieur du bit suivant est effectu√© selon l'algorithme de tri rapide. <br><br><h3>  Tri par dispersion :: Spreadsort </h3><br><h4>  <i>Rapide + fusion + seaux + d√©charges</i> </h4><br>  Gestalt √† partir du tri rapide, du tri par fusion, du tri par compartiment et du tri au niveau du bit. <br><br>  En un mot, ne l'expliquez pas.  Nous analyserons cet algorithme en d√©tail dans l'un des articles suivants. <br><br><hr><hr><hr><hr><hr><br><h2>  Autres hybrides </h2><br><h3>  Tri par comptage d'arbres </h3><br><h4>  <i>Comptage + arbre</i> </h4><br>  L'algorithme <a href="https://habr.com/ru/post/418355/">propos√© par l'</a> utilisateur <a href="https://habr.com/ru/users/alexanderusatov/" class="user_link">AlexanderUsatov</a> .  En comptant le tri, le nombre de cl√©s compt√©es est stock√© dans une arborescence √©quilibr√©e. <br><br><h3>  J-sort :: J-sort </h3><br><h4>  <i>Tas + inserts</i> </h4><br>  J'ai <a href="https://habr.com/ru/post/221095/">d√©j√† √©crit</a> sur ce tri <a href="https://habr.com/ru/post/221095/">il y a 5 ans</a> .  Tout est assez simple - d'abord dans le tableau, vous devez cr√©er une fois un tas non croissant, puis faire exactement le contraire - construire une fois non d√©croissant.  √Ä la suite de la premi√®re op√©ration, le minimum sera √† la premi√®re place du tableau et les petits √©l√©ments dans leur ensemble se d√©placeront de mani√®re significative au d√©but.  Dans le second cas, le maximum sera √† la derni√®re place et les gros √©l√©ments migreront vers la fin du tableau.  En g√©n√©ral, nous obtenons un tableau presque tri√© avec lequel nous faisons quoi?  C'est vrai - triez les inserts. <br><br><div style="text-align:center;"><img width="646" height="304" src="https://habrastorage.org/webt/uv/ed/ud/uvedudkaitwonk4bfuy2alkkvwk.gif"></div><br><br><hr><hr><hr><hr><hr><br><h2>  Les r√©f√©rences </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://en.wikipedia.org/wiki/Merge-insertion_sort">Fusion-insertion</a> , <a href="https://en.wikipedia.org/wiki/Block_sort">Bloc-fusion</a> , <a href="https://en.wikipedia.org/wiki/Timsort">Tim</a> , <a href="https://en.wikipedia.org/wiki/Introsort">Introspective</a> , <a href="https://en.wikipedia.org/wiki/Spreadsort">Spread</a> , <a href="https://en.wikipedia.org/wiki/Multi-key_quicksort">Multikey</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png">  <a href="https://github.com/Mrrl/GrailSort">Graal</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png">  <a href="https://habr.com/ru/post/205290/">Graal</a> , <a href="https://habr.com/ru/post/203032/">table de hachage</a> , <a href="https://habr.com/ru/post/418355/">comte / arbre</a> , <a href="https://habr.com/ru/post/221095/">J</a> <br><br><h3>  Articles de s√©rie: </h3><br><ul><li>  <a href="https://habr.com/post/414447/">Application Excel AlgoLab.xlsm</a> </li><li>  <a href="https://habr.com/post/414653/">Exchange Sorts</a> </li><li>  <a href="https://habr.com/post/415935/">Tri d'insertion</a> </li><li>  <a href="https://habr.com/post/422085/">Trier par s√©lection</a> </li><li>  <a href="https://habr.com/ru/post/431964/">Fusionner les tris</a> </li><li>  <a href="https://habr.com/ru/post/472466/">Trier par distribution</a> </li><li>  <strong>Tri hybride</strong> <br><ul><li>  Ins√©rer un tri par fusion </li><li>  Tim Sort </li><li>  Tri Wiki </li><li>  Tri par dispersion </li></ul><br></li></ul>  De tous les tri qui sont pr√©sent√©s ici, dans l'application Excel AlgoLab, seule l'animation Jsort est actuellement impl√©ment√©e. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483786/">https://habr.com/ru/post/fr483786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483774/index.html">Le condens√© des √©v√©nements pour les professionnels des RH en informatique pour janvier 2020</a></li>
<li><a href="../fr483776/index.html">Introduction √† la m√©thode diff√©rentielle s√©mantique en 5 minutes</a></li>
<li><a href="../fr483778/index.html">Semaine de la s√©curit√© 03: Principes responsables de rapport de bogue</a></li>
<li><a href="../fr483780/index.html">Qu'est-ce que Slack et comment √ßa marche?</a></li>
<li><a href="../fr483784/index.html">Comment faire une application multi-locataire √† partir d'une application non-locataire</a></li>
<li><a href="../fr483788/index.html">Une petite nation insulaire gagne gr√¢ce √† Twitch</a></li>
<li><a href="../fr483790/index.html">Notes du fournisseur IoT. Technologie et √©conomie LoRaWAN dans l'√©clairage urbain</a></li>
<li><a href="../fr483794/index.html">Quitter: pourquoi ne pas prendre Kontroffer</a></li>
<li><a href="../fr483796/index.html">Param√®tres facultatifs dans les r√©f√©rentiels de donn√©es Spring</a></li>
<li><a href="../fr483798/index.html">Comment automatiser la composition d'annonces dans Google Ads</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>