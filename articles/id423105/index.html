<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•™ üà∏ ü•õ System.IO.Pipelines: IO Kinerja Tinggi dalam .NET üë©üèø‚Äç‚öïÔ∏è üï∫üèΩ üë®üèø‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="System.IO.Pipelines adalah perpustakaan baru yang menyederhanakan organisasi kode di .NET. Sulit untuk memastikan kinerja dan akurasi tinggi jika Anda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines: IO Kinerja Tinggi dalam .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423105/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">System.IO.Pipelines</a> adalah perpustakaan baru yang menyederhanakan organisasi kode di .NET.  Sulit untuk memastikan kinerja dan akurasi tinggi jika Anda harus berurusan dengan kode yang rumit.  Tugas System.IO.Pipelines adalah menyederhanakan kode.  Lebih detail di bawah cut! <br><br><img src="https://habrastorage.org/webt/nq/me/p-/nqmep-tqvyyv5nlkpcxjnmlw8z4.jpeg"><a name="habracut"></a><br><br>  Perpustakaan muncul sebagai hasil dari upaya tim pengembangan .NET Core untuk menjadikan Kestrel salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">server web tercepat di industri</a> .  Awalnya dirancang sebagai bagian dari implementasi Kestrel, tetapi telah berkembang menjadi API yang dapat digunakan kembali, tersedia dalam versi 2.1 sebagai API BCL kelas pertama (System.IO.Pipelines). <br><br><h2>  Masalah apa yang dia pecahkan? </h2><br>  Untuk menganalisis data dengan benar dari aliran atau soket, Anda perlu menulis sejumlah besar kode standar.  Pada saat yang sama, ada banyak jebakan yang menyulitkan kode itu sendiri dan dukungannya. <br><br><h2>  Kesulitan apa yang muncul hari ini? </h2><br>  Mari kita mulai dengan tugas sederhana.  Kita perlu menulis server TCP yang menerima pesan yang dibatasi baris (\ n) dari klien. <br><br><h2>  TCP Server dengan NetworkStream </h2><br>  DEVIASI: seperti dalam tugas apa pun yang membutuhkan kinerja tinggi, setiap kasus spesifik harus dipertimbangkan berdasarkan fitur aplikasi Anda.  Mungkin tidak masuk akal untuk menghabiskan sumber daya pada penggunaan berbagai pendekatan, yang akan dibahas nanti, jika skala aplikasi jaringan tidak terlalu besar. <br><br>  Kode .NET biasa sebelum menggunakan jaringan pipa terlihat seperti ini: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length); <span class="hljs-comment"><span class="hljs-comment">// Process a single line from the buffer ProcessLine(buffer); }</span></span></code> </pre> <br>  lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sample1.cs</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> <br><br>  Kode ini mungkin akan bekerja dengan pengujian lokal, tetapi memiliki sejumlah kesalahan: <br><br><ul><li>  Mungkin setelah satu panggilan ke ReadAsync, seluruh pesan tidak akan diterima (sampai akhir baris). </li><li>  Ini mengabaikan hasil dari metode stream.ReadAsync () - jumlah data yang sebenarnya ditransfer ke buffer. </li><li>  Kode tidak menangani menerima beberapa baris dalam satu panggilan ReadAsync. </li></ul><br>  Ini adalah kesalahan pembacaan data streaming yang paling umum.  Untuk menghindarinya, Anda perlu melakukan sejumlah perubahan: <br><br><ul><li>  Anda perlu melakukan buffer data yang masuk sampai baris baru ditemukan. </li><li>  Penting untuk menganalisis semua baris yang dikembalikan ke buffer. </li></ul><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesBuffered = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.ReadAsync(buffer, bytesBuffered, buffer.Length - bytesBuffered); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytesRead == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// EOF break; } // Keep track of the amount of buffered bytes bytesBuffered += bytesRead; var linePosition = -1; do { // Look for a EOL in the buffered data linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed); if (linePosition &gt;= 0) { // Calculate the length of the line based on the offset var lineLength = linePosition - bytesConsumed; // Process the line ProcessLine(buffer, bytesConsumed, lineLength); // Move the bytesConsumed to skip past the line we consumed (including \n) bytesConsumed += lineLength + 1; } } while (linePosition &gt;= 0); } }</span></span></code> </pre> <br>  lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sample2.cs</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> <br><br>  Saya ulangi: ini bisa bekerja dengan pengujian lokal, tetapi kadang-kadang ada string yang lebih panjang dari 1 Kb (1024 byte).  Penting untuk meningkatkan ukuran buffer input hingga baris baru ditemukan. <br><br>  Selain itu, kami mengumpulkan buffer ke dalam array saat memproses string panjang.  Kami dapat meningkatkan proses ini dengan ArrayPool, yang menghindari alokasi ulang buffer selama analisis garis panjang dari klien. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = ArrayPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Shared.Rent(<span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesBuffered = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Calculate the amount of bytes remaining in the buffer var bytesRemaining = buffer.Length - bytesBuffered; if (bytesRemaining == 0) { // Double the buffer size and copy the previously buffered data into the new buffer var newBuffer = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length * 2); Buffer.BlockCopy(buffer, 0, newBuffer, 0, buffer.Length); // Return the old buffer to the pool ArrayPool&lt;byte&gt;.Shared.Return(buffer); buffer = newBuffer; bytesRemaining = buffer.Length - bytesBuffered; } var bytesRead = await stream.ReadAsync(buffer, bytesBuffered, bytesRemaining); if (bytesRead == 0) { // EOF break; } // Keep track of the amount of buffered bytes bytesBuffered += bytesRead; do { // Look for a EOL in the buffered data linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed); if (linePosition &gt;= 0) { // Calculate the length of the line based on the offset var lineLength = linePosition - bytesConsumed; // Process the line ProcessLine(buffer, bytesConsumed, lineLength); // Move the bytesConsumed to skip past the line we consumed (including \n) bytesConsumed += lineLength + 1; } } while (linePosition &gt;= 0); } }</span></span></code> </pre> <br>  <i>lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sample3.cs</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a></i> <br><br>  Kode berfungsi, tetapi sekarang ukuran buffer telah berubah, sebagai akibatnya, banyak salinannya muncul.  Lebih banyak memori juga digunakan, karena logika tidak mengurangi buffer setelah memproses baris.  Untuk menghindari ini, Anda dapat menyimpan daftar buffer, daripada mengubah ukuran buffer setiap kali sebuah string datang lebih dari 1 Kb. <br><br>  Selain itu, kami tidak menambah ukuran buffer 1 KB, sampai benar-benar kosong.  Ini berarti bahwa kami akan mentransfer buffer yang lebih kecil dan lebih kecil ke ReadAsync, sebagai akibatnya, jumlah panggilan ke sistem operasi akan meningkat. <br><br>  Kami akan mencoba menghilangkan ini dan akan mengalokasikan buffer baru segera setelah ukuran yang ada menjadi kurang dari 512 byte: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BufferSegment</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Buffer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Remaining =&gt; Buffer.Length - Count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimumBufferSize = <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;BufferSegment&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumedBufferIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferSegment { Buffer = ArrayPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Shared.Rent(<span class="hljs-number"><span class="hljs-number">1024</span></span>) }; segments.Add(segment); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Calculate the amount of bytes remaining in the buffer if (segment.Remaining &lt; minimumBufferSize) { // Allocate a new segment segment = new BufferSegment { Buffer = ArrayPool&lt;byte&gt;.Shared.Rent(1024) }; segments.Add(segment); } var bytesRead = await stream.ReadAsync(segment.Buffer, segment.Count, segment.Remaining); if (bytesRead == 0) { break; } // Keep track of the amount of buffered bytes segment.Count += bytesRead; while (true) { // Look for a EOL in the list of segments var (segmentIndex, segmentOffset) = IndexOf(segments, (byte)'\n', bytesConsumedBufferIndex, bytesConsumed); if (segmentIndex &gt;= 0) { // Process the line ProcessLine(segments, segmentIndex, segmentOffset); bytesConsumedBufferIndex = segmentOffset; bytesConsumed = segmentOffset + 1; } else { break; } } // Drop fully consumed segments from the list so we don't look at them again for (var i = bytesConsumedBufferIndex; i &gt;= 0; --i) { var consumedSegment = segments[i]; // Return all segments unless this is the current segment if (consumedSegment != segment) { ArrayPool&lt;byte&gt;.Shared.Return(consumedSegment.Buffer); segments.RemoveAt(i); } } } } (int segmentIndex, int segmentOffest) IndexOf(List&lt;BufferSegment&gt; segments, byte value, int startBufferIndex, int startSegmentOffset) { var first = true; for (var i = startBufferIndex; i &lt; segments.Count; ++i) { var segment = segments[i]; // Start from the correct offset var offset = first ? startSegmentOffset : 0; var index = Array.IndexOf(segment.Buffer, value, offset, segment.Count - offset); if (index &gt;= 0) { // Return the buffer index and the index within that segment where EOL was found return (i, index); } first = false; } return (-1, -1); }</span></span></code> </pre> <br>  <i>lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sample4.cs</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a></i> <br><br>  Akibatnya, kode ini sangat rumit.  Selama pencarian pembatas, kami melacak buffer yang diisi.  Untuk melakukan ini, gunakan Daftar, yang menampilkan data buffer saat mencari pemisah baris baru.  Akibatnya, ProcessLine dan IndexOf akan menerima Daftar alih-alih byte [], offset dan hitung.  Logika parsing akan mulai memproses satu segmen buffer atau beberapa. <br><br>  Dan sekarang server akan memproses sebagian pesan dan menggunakan memori bersama untuk mengurangi konsumsi memori secara keseluruhan.  Namun, sejumlah perubahan perlu dilakukan: <br><br><ol><li>  Dari ArrayPoolbyte kami hanya menggunakan Byte [] - array yang dikelola secara standar.  Dengan kata lain, ketika fungsi ReadAsync atau WriteAsync dieksekusi, periode validitas buffer terikat dengan waktu operasi asinkron (untuk berinteraksi dengan API I / O sistem operasi sendiri).  Karena memori yang disematkan tidak dapat dipindahkan, ini mempengaruhi kinerja pengumpul sampah dan dapat menyebabkan fragmentasi array.  Anda mungkin perlu mengubah implementasi kumpulan, tergantung pada berapa lama operasi asinkron akan menunggu eksekusi. </li><li>  Throughput dapat ditingkatkan dengan memutus tautan antara logika baca dan proses.  Kami mendapatkan efek pemrosesan batch, dan sekarang logika parsing akan dapat membaca sejumlah besar data, memproses blok buffer yang besar, daripada menganalisis setiap baris.  Akibatnya, kode ini menjadi lebih rumit: <br><br><ul><li>  Anda perlu membuat dua siklus yang bekerja secara independen satu sama lain.  Yang pertama akan membaca data dari soket, dan yang kedua akan menganalisis buffer. </li><li>  Yang diperlukan adalah cara untuk memberi tahu logika parsing bahwa data menjadi tersedia. </li><li>  Penting juga untuk menentukan apa yang terjadi jika loop membaca data dari soket terlalu cepat.  Kita perlu cara untuk menyesuaikan siklus baca jika logika parsing tidak mengikutinya.  Ini biasanya disebut sebagai "kontrol aliran" atau "hambatan aliran." </li><li>  Kita harus memastikan bahwa data ditransmisikan dengan aman.  Sekarang set buffer digunakan oleh siklus baca dan siklus parsing, mereka bekerja secara independen satu sama lain pada utas yang berbeda. </li><li>  Logika manajemen memori juga terlibat dalam dua bagian kode yang berbeda: meminjam data dari buffer pool, yang membaca data dari socket, dan kembali dari pool buffer, yang merupakan logika parsing. </li><li>  Seseorang harus sangat berhati-hati dengan mengembalikan buffer setelah mengeksekusi logika parsing.  Jika tidak, ada kemungkinan bahwa kami akan mengembalikan buffer ke mana logika baca soket masih ditulis. </li></ul></li></ol><br>  Kompleksitas mulai menembus atap (dan ini jauh dari semua kasus!).  Untuk membuat jaringan berkinerja tinggi, Anda perlu menulis kode yang sangat kompleks. <br><br>  Tujuan System.IO.Pipelines adalah untuk menyederhanakan prosedur ini. <br><br><h4>  Server TCP dan System.IO.Pipelines </h4><br>  Mari kita lihat bagaimana System.IO.Pipelines bekerja: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket socket</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Task writing = FillPipeAsync(socket, pipe.Writer); Task reading = ReadPipeAsync(pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.WhenAll(reading, writing); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket socket, PipeWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimumBufferSize = <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Allocate at least 512 bytes from the PipeWriter Memory&lt;byte&gt; memory = writer.GetMemory(minimumBufferSize); try { int bytesRead = await socket.ReceiveAsync(memory, SocketFlags.None); if (bytesRead == 0) { break; } // Tell the PipeWriter how much was read from the Socket writer.Advance(bytesRead); } catch (Exception ex) { LogError(ex); break; } // Make the data available to the PipeReader FlushResult result = await writer.FlushAsync(); if (result.IsCompleted) { break; } } // Tell the PipeReader that there's no more data coming writer.Complete(); } async Task ReadPipeAsync(PipeReader reader) { while (true) { ReadResult result = await reader.ReadAsync(); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; SequencePosition? position = null; do { // Look for a EOL in the buffer position = buffer.PositionOf((byte)'\n'); if (position != null) { // Process the line ProcessLine(buffer.Slice(0, position.Value)); // Skip the line + the \n character (basically position) buffer = buffer.Slice(buffer.GetPosition(1, position.Value)); } } while (position != null); // Tell the PipeReader how much of the buffer we have consumed reader.AdvanceTo(buffer.Start, buffer.End); // Stop reading if there's no more data coming if (result.IsCompleted) { break; } } // Mark the PipeReader as complete reader.Complete(); }</span></span></code> </pre> <br>  <i>lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sample5.cs</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a></i> <br><br>  Versi pipelined dari pembaca baris kami memiliki dua loop: <br><br><ul><li>  FillPipeAsync membaca dari soket dan menulis ke PipeWriter. </li><li>  ReadPipeAsync membaca dari PipeReader dan mem-parsing garis masuk. </li></ul><br>  Berbeda dengan contoh pertama, tidak ada buffer yang ditugaskan secara khusus.  Ini adalah salah satu fungsi utama System.IO.Pipelines.  Semua tugas manajemen buffer ditransfer ke implementasi PipeReader / PipeWriter. <br><br>  Prosedur ini disederhanakan: kami menggunakan kode hanya untuk logika bisnis, alih-alih menerapkan manajemen buffer yang kompleks. <br><br>  Pada loop pertama, PipeWriter.GetMemory (int) pertama kali dipanggil untuk mendapatkan sejumlah memori dari penulis utama.  Kemudian PipeWriter.Advance (int) dipanggil, yang memberitahu PipeWriter berapa banyak data yang sebenarnya ditulis ke buffer.  Ini diikuti oleh panggilan ke PipeWriter.FlushAsync () sehingga PipeReader dapat mengakses data. <br><br>  Loop kedua mengkonsumsi buffer yang ditulis oleh PipeWriter tetapi awalnya diterima dari soket.  Ketika permintaan dikembalikan ke PipeReader.ReadAsync (), kita mendapatkan ReadResult yang berisi dua pesan penting: data membaca dalam bentuk ReadOnlySequence, serta tipe data logis IsCompleted, yang memberi tahu pembaca apakah penulis telah selesai bekerja (EOF).  Ketika line terminator (EOL) ditemukan dan string diuraikan, kami akan membagi buffer menjadi bagian-bagian untuk melewati fragmen yang telah diproses.  Setelah itu, PipeReader.AdvanceTo dipanggil dan ia memberi tahu PipeReader berapa banyak data yang telah dikonsumsi. <br><br>  Pada akhir setiap siklus, pembaca dan penulis selesai.  Akibatnya, saluran utama melepaskan semua memori yang dialokasikan. <br><br><h2>  System.io.pipelines </h2><br><h4>  Membaca sebagian </h4><br>  Selain mengelola memori, System.IO.Pipelines melakukan fungsi penting lainnya: memindai data di saluran, tetapi tidak mengkonsumsinya. <br><br>  PipeReader memiliki dua API utama: ReadAsync dan AdvanceTo.  ReadAsync menerima data dari saluran, AdvanceTo memberi tahu PipeReader bahwa buffer ini tidak lagi diperlukan oleh pembaca, sehingga Anda dapat membuangnya (misalnya, mengembalikannya ke kumpulan buffer utama). <br><br>  Berikut ini adalah contoh penganalisis HTTP yang membaca data dari buffer data saluran sebagian hingga menerima garis awal yang sesuai. <br><br><img src="https://habrastorage.org/webt/9c/lp/d8/9clpd8h1r6b1m1jrwultkuggw6i.png"><br><br><h2>  BacaHanya KesetaraanT </h2><br>  Implementasi saluran menyimpan daftar buffer terkait yang dilewati antara PipeWriter dan PipeReader.  PipeReader.ReadAsync mengekspos ReadOnlySequence, yang merupakan tipe baru BCL dan terdiri dari satu atau lebih segmen ReadOnlyMemory &lt;T&gt;.  Ini mirip dengan Rentang atau Memori, yang memberi kita kesempatan untuk melihat array dan string. <br><br><img src="https://habrastorage.org/webt/79/y0/kw/79y0kwylohggq941soblji6qd2o.png"><br><br>  Di dalam saluran ada petunjuk yang menunjukkan di mana pembaca dan penulis berada di set umum data yang disorot, dan juga memperbaruinya saat data ditulis dan dibaca.  SequencePosition adalah satu titik di daftar buffer yang ditautkan dan digunakan untuk memisahkan ReadOnlySequence &lt;T&gt; secara efisien. <br><br>  Karena ReadOnlySequence &lt;T&gt; mendukung satu atau lebih segmen, operasi standar logika berkinerja tinggi adalah memisahkan jalur cepat dan lambat berdasarkan jumlah segmen. <br><br>  Sebagai contoh, berikut adalah fungsi yang mengubah ASCII ReadOnlySequence menjadi string: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAsciiString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; buffer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.IsSingleSegment) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Encoding.ASCII.GetString(buffer.First.Span); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Create((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buffer.Length, buffer, (span, sequence) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence) { Encoding.ASCII.GetChars(segment.Span, span); span = span.Slice(segment.Length); } }); }</code> </pre> <br>  lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sample6.cs</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> <br><br><h4>  Resistensi aliran dan kontrol aliran </h4><br>  Idealnya, membaca dan menganalisis bekerja bersama: arus baca mengkonsumsi data dari jaringan dan menempatkannya dalam buffer, sementara aliran analisis menciptakan struktur data yang sesuai.  Analisis biasanya memakan waktu lebih lama dari sekadar menyalin blok data dari jaringan.  Akibatnya, aliran baca dapat dengan mudah membebani aliran analisis.  Oleh karena itu, aliran baca akan dipaksa untuk memperlambat atau menggunakan lebih banyak memori untuk menyimpan data untuk aliran analisis.  Untuk memastikan kinerja yang optimal, diperlukan keseimbangan antara frekuensi jeda dan alokasi sejumlah besar memori. <br><br>  Untuk mengatasi masalah ini, pipa memiliki dua fungsi kontrol aliran data: PauseWriterThreshold dan ResumeWriterThreshold.  PauseWriterThreshold menentukan berapa banyak data yang perlu di-buffer sebelum PipeWriter.FlushAsync dijeda.  ResumeWriterThreshold menentukan berapa banyak memori yang dapat dikonsumsi pembaca sebelum perekam melanjutkan operasi. <br><br><img src="https://habrastorage.org/webt/qf/yj/5u/qfyj5u6aahkadlp8nk1gtc9bqr4.png"><br><br>  PipeWriter.FlushAsync "mengunci" ketika jumlah data dalam aliran pipelined melebihi batas yang ditetapkan di PauseWriterThreshold, dan "membuka kunci" ketika jatuh di bawah batas yang ditetapkan di ResumeWriterThreshold.  Untuk mencegah melebihi batas konsumsi, hanya dua nilai yang digunakan. <br><br><h4>  Penjadwalan I / O </h4><br>  Saat menggunakan async / menunggu, operasi selanjutnya biasanya disebut di thread pool atau di SynchronizationContext saat ini. <br><br>  Saat melakukan I / O, sangat penting untuk memantau dengan hati-hati di mana itu dilaksanakan untuk memanfaatkan cache prosesor dengan lebih baik.  Ini penting untuk aplikasi berkinerja tinggi seperti server web.  System.IO.Pipelines menggunakan PipeScheduler untuk menentukan tempat untuk melakukan panggilan balik asinkron.  Ini memungkinkan Anda untuk mengontrol aliran mana yang harus digunakan untuk I / O. <br><br>  Contoh aplikasi praktis adalah transportasi Kestrel Libuv, di mana panggilan balik I / O dilakukan pada saluran khusus pada loop acara. <br><br><h2>  Ada manfaat lain untuk templat PipeReader. </h2><br><ul><li>  Beberapa sistem basis mendukung "tunggu tanpa buffering": Anda tidak perlu mengalokasikan buffer hingga data yang tersedia muncul di sistem dasar.  Jadi, di Linux dengan epoll, Anda tidak dapat menyediakan buffer baca hingga data siap.  Ini menghindari situasi ketika ada banyak utas menunggu data, dan Anda harus segera memesan sejumlah besar memori. </li><li>  Pipa default memudahkan untuk menulis tes unit kode jaringan: logika parsing terpisah dari kode jaringan, dan tes unit hanya menjalankan logika ini dalam buffer dalam memori, daripada memakannya langsung dari jaringan.  Ini juga membuatnya mudah untuk menguji pola yang kompleks dengan mengirim data parsial.  ASP.NET Core menggunakannya untuk menguji berbagai aspek alat parsing http Kestrel. </li><li>  Sistem yang memungkinkan kode pengguna untuk menggunakan buffer OS utama (misalnya, API Windows I / O terdaftar) pada awalnya cocok untuk menggunakan jaringan pipa karena implementasi PipeReader selalu menyediakan buffer. </li></ul><br><h4>  Jenis terkait lainnya </h4><br>  Kami juga menambahkan sejumlah tipe BCL sederhana baru ke System.IO.Pipelines: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MemoryPoolT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IMemoryOwnerT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MemoryManagerT</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ArrayPoolT</a> ditambahkan dalam .NET Core 1.0, dan .NET Core 2.1 sekarang ada representasi abstrak yang lebih umum untuk kumpulan yang bekerja dengan MemoryT.  Kami mendapatkan titik ekstensibilitas yang memungkinkan kami menerapkan strategi distribusi yang lebih maju, serta mengontrol manajemen buffer (misalnya, menggunakan buffer yang telah ditentukan alih-alih array yang dikelola secara eksklusif). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBufferWriterT</a> adalah penerima untuk merekam data buffered yang disinkronkan (diimplementasikan oleh PipeWriter). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IValueTaskSource</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ValueTaskT telah</a> ada sejak rilis .NET Core 1.1, tetapi dalam. NET Core 2.1 telah memperoleh alat yang sangat efektif yang menyediakan operasi asinkron tanpa gangguan tanpa distribusi.  Lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini untuk</a> informasi lebih lanjut. </li></ul><br><h2>  Bagaimana cara menggunakan conveyor? </h2><br>  API berada dalam paket nuget <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">System.IO.Pipelines</a> . <br><br>  Untuk contoh aplikasi server .NET Server 2.1 yang menggunakan jaringan pipa untuk memproses pesan huruf kecil (dari contoh di atas), lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Itu bisa mulai menggunakan dotnet run (atau Visual Studio).  Dalam contoh tersebut, data diharapkan dikirim dari soket pada port 8087, kemudian pesan yang diterima ditulis ke konsol.  Anda dapat menggunakan klien, seperti netcat atau dempul, untuk terhubung ke port 8087.  Kirim pesan kecil dan lihat cara kerjanya. <br><br>  Saat ini, pipeline berjalan pada Kestrel dan SignalR, dan kami berharap akan menemukan aplikasi yang lebih luas di banyak pustaka jaringan dan komponen komunitas .NET di masa mendatang. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423105/">https://habr.com/ru/post/id423105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423093/index.html">Kami meningkatkan keacakan fakta bahwa [mungkin] [hampir] secara tidak sengaja</a></li>
<li><a href="../id423095/index.html">Apa yang Baru di Presentasi Apple</a></li>
<li><a href="../id423097/index.html">Tugas dan solusi untuk pejuang PostgreSQL</a></li>
<li><a href="../id423101/index.html">Menyebarkan Penyimpanan LINSTOR untuk Proxmox</a></li>
<li><a href="../id423103/index.html">Python Podcasts: Hanya Itu yang Kami Temukan</a></li>
<li><a href="../id423107/index.html">Kami mengundang Anda ke pertemuan Go in Production</a></li>
<li><a href="../id423109/index.html">Apa yang diperkenalkan Apple dan apa yang dipikirkan pengembang iOS tentang hal itu</a></li>
<li><a href="../id423115/index.html">Efek yang ditingkatkan dengan mode pencampuran lapisan latar belakang CSS</a></li>
<li><a href="../id423117/index.html">Hidup lebih lama atau tumbuh lebih tua lebih lambat: pendekatan teknologi untuk usia tua</a></li>
<li><a href="../id423119/index.html">Mesin arcade TTL DIY ... tahun 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>