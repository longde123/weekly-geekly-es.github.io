<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèë üêî ‚úåüèª Fusion √† 3 voies dans werf: d√©ploiement dans Kubernetes avec Helm "sous st√©ro√Ødes" ü•ô üç∂ üêô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelque chose s'est produit que nous (et pas seulement nous) attendions: werf , notre utilitaire Open Source pour cr√©er des applications et les livrer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fusion √† 3 voies dans werf: d√©ploiement dans Kubernetes avec Helm "sous st√©ro√Ødes"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476646/"> Quelque chose s'est produit que nous (et pas seulement nous) attendions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">werf</a> , notre utilitaire Open Source pour cr√©er des applications et les livrer √† Kubernetes, prend d√©sormais en charge l'application des modifications √† l'aide de correctifs de fusion √† 3 voies!  En plus de cela, il est devenu possible d'adopter les ressources K8 existantes dans les versions de Helm sans recr√©er ces ressources. <br><br><img src="https://habrastorage.org/webt/os/yc/op/osycopyy-kknbg7fnwuf8cjohxi.png"><br><br>  S'il est tr√®s court, d√©finissez <code>WERF_THREE_WAY_MERGE=enabled</code> - nous obtenons le d√©ploiement "comme dans <code>kubectl apply</code> ", compatible avec les installations existantes sur Helm 2 et m√™me un peu plus. <br><br>  Mais commen√ßons par la th√©orie: qu'est-ce que les correctifs de fusion √† 3 voies en g√©n√©ral, comment les gens en sont-ils venus √† leur g√©n√©ration et pourquoi sont-ils importants dans les processus CI / CD avec une infrastructure bas√©e sur Kubernetes?  Et apr√®s cela - voyons ce qu'est la fusion √† 3 dans werf, quels modes sont utilis√©s par d√©faut et comment le g√©rer. <a name="habracut"></a><br><br><h2>  Qu'est-ce qu'un patch de fusion √† 3 voies? </h2><br>  Commen√ßons donc par d√©ployer les ressources d√©crites dans les manifestes YAML dans Kubernetes. <br><br>  Pour travailler avec des ressources, l'API Kubernetes propose les op√©rations de base suivantes: cr√©er, corriger, remplacer et supprimer.  Il est suppos√© qu'avec leur aide, il est n√©cessaire de cr√©er un d√©ploiement continu pratique des ressources vers le cluster.  Comment? <br><br><h3>  √âquipes imp√©ratives de Kubectl </h3><br>  La premi√®re approche de la gestion des objets dans Kubernetes consiste √† utiliser les commandes imp√©ratives de kubectl pour cr√©er, modifier et supprimer ces objets.  Autrement dit: <br><br><ul><li>  <code>kubectl run</code> commande <code>kubectl run</code> peut ex√©cuter le d√©ploiement ou le travail: <br><br><pre> <code class="bash hljs">kubectl run --generator=deployment/apps.v1 DEPLOYMENT_NAME --image=IMAGE</code> </pre> </li><li>  <code>kubectl scale</code> - modifiez le nombre de r√©pliques: <br><br><pre> <code class="bash hljs">kubectl scale --replicas=3 deployment/mysql</code> </pre> </li><li>  etc. </li></ul><br>  Une telle approche peut sembler commode √† premi√®re vue.  Cependant, il y a des probl√®mes: <br><br><ol><li>  C'est difficile √† <b>automatiser</b> . </li><li>  Comment <b>refl√©ter la configuration</b> dans Git?  Comment revoir les changements survenus dans un cluster? </li><li>  Comment assurer la <b>reproductibilit√© de la</b> configuration au red√©marrage? </li><li>  ... </li></ol><br>  Il est clair que cette approche ne cadre pas bien avec le stockage de l'application et de l'infrastructure sous forme de code (IaC; ou m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitOps en</a> tant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qu'option</a> plus moderne, gagnant en popularit√© dans l'√©cosyst√®me Kubernetes) avec le code.  Par cons√©quent, ces √©quipes n'ont pas re√ßu de d√©veloppement suppl√©mentaire dans kubectl. <br><br><h3>  Cr√©er, obtenir, remplacer et supprimer des op√©rations </h3><br>  Avec la <b>cr√©ation</b> primaire <b>,</b> tout est simple: on envoie le manifeste √† l'op√©ration de <code>create</code> de kube api et la ressource est cr√©√©e.  La repr√©sentation YAML du manifeste peut √™tre stock√©e dans Git, et pour cr√©er, utilisez la commande <code>kubectl create -f manifest.yaml</code> . <br><br>  <b>La suppression est</b> √©galement simple: nous substituons le m√™me <code>manifest.yaml</code> de Git √† la commande <code>kubectl delete -f manifest.yaml</code> . <br><br>  L'op√©ration de <b><code>replace</code></b> vous permet de remplacer compl√®tement la configuration des ressources par une nouvelle, sans recr√©er la ressource.  Cela signifie qu'avant d'apporter une modification √† une ressource, il est logique de demander la version actuelle avec l'op√©ration <code>get</code> , de la modifier et de la mettre √† jour avec l'op√©ration <code>replace</code> .  Le verrouillage optimiste est int√©gr√© √† kube apiserver, et si l'objet a chang√© apr√®s l'op√©ration <code>get</code> , l'op√©ration de <code>replace</code> √©chouera. <br><br>  Pour stocker la configuration dans Git et la mettre √† jour √† l'aide de replace, vous devez effectuer une op√©ration <code>get</code> , conserver la configuration de Git avec ce que nous avons obtenu et effectuer le <code>replace</code> .  Normalement, kubectl vous permet uniquement d'utiliser la commande <code>kubectl replace -f manifest.yaml</code> , o√π <code>manifest.yaml</code> est le <code>manifest.yaml</code> enti√®rement pr√©par√© (dans notre cas, joint) qui doit √™tre install√©.  Il s'av√®re que l'utilisateur doit impl√©menter des manifestes de fusion, mais ce n'est pas une mince affaire ... <br><br>  Il convient √©galement de noter que bien que <code>manifest.yaml</code> soit stock√© dans Git, nous ne pouvons pas savoir √† l'avance si vous devez cr√©er un objet ou le mettre √† jour - cela devrait √™tre fait par le logiciel utilisateur. <br><br>  Conclusion: <b>pouvons-nous cr√©er un d√©ploiement continu</b> uniquement avec cr√©er, remplacer et supprimer, en veillant √† ce que la configuration de l'infrastructure soit stock√©e dans Git avec le code et un CI / CD pratique? <br><br>  Fondamentalement, nous pouvons ... Pour ce faire, nous <b>devons impl√©menter l'op√©ration de fusion des</b> manifestes et une sorte de liaison qui: <br><br><ul><li>  v√©rifie la pr√©sence d'un objet dans le cluster, </li><li>  effectue la cr√©ation initiale de la ressource, </li><li>  le met √† jour ou le supprime. </li></ul><br>  Lors de la mise √† jour, vous devez tenir compte du fait que la <i>ressource peut avoir chang√©</i> depuis le dernier <code>get</code> et g√©rer automatiquement le cas d'un verrouillage optimiste - effectuez des tentatives r√©p√©t√©es de mise √† jour. <br><br>  Cependant, pourquoi r√©inventer la roue lorsque kube-apiserver offre une autre fa√ßon de mettre √† jour les ressources: l'op√©ration de <code>patch</code> , qui supprime certains des probl√®mes d√©crits par l'utilisateur? <br><br><h3>  Patch </h3><br>  Nous sommes donc arriv√©s aux patchs. <br><br>  Les correctifs sont le principal moyen d'appliquer des modifications aux objets existants dans Kubernetes.  L'op√©ration de <code>patch</code> fonctionne de telle sorte que: <br><br><ul><li>  l'utilisateur kube-apiserver doit envoyer le patch au format JSON et sp√©cifier l'objet, </li><li>  et apiserver lui-m√™me traitera l'√©tat actuel de l'objet et l'am√®nera √† la forme souhait√©e. </li></ul><br>  Un verrouillage optimiste dans ce cas n'est pas n√©cessaire.  Cette op√©ration est plus d√©clarative par rapport √† remplacer, bien qu'√† premi√®re vue, cela puisse sembler l'inverse. <br><br>  De cette fa√ßon: <br><br><ul><li>  en utilisant l'op√©ration de <code>create</code> , nous cr√©ons un objet √† partir du manifeste de Git, </li><li>  en utilisant <code>delete</code> - supprimer si l'objet n'est plus requis, </li><li>  en utilisant <code>patch</code> - nous modifions l'objet, en le ramenant √† la forme d√©crite dans Git. </li></ul><br>  Cependant, pour ce faire, vous devez cr√©er le <i>correctif correct</i> ! <br><br><h3>  Fonctionnement des correctifs dans Helm 2: fusion bidirectionnelle </h3><br>  La premi√®re fois qu'une version est install√©e, Helm effectue une op√©ration de <code>create</code> sur les ressources de graphique. <br><br>  Lors de la mise √† jour de la version Helm pour chaque ressource: <br><br><ul><li>  compte le patch entre la version de la ressource du graphique pr√©c√©dent et la version actuelle du graphique, </li><li>  applique ce patch. </li></ul><br>  Nous appellerons un tel correctif de <b>fusion bidirectionnelle</b> , car 2 manifestes participent √† sa cr√©ation: <br><br><ul><li>  Manifeste des ressources de la version pr√©c√©dente, </li><li>  Manifeste de la ressource √† partir de la ressource actuelle. </li></ul><br>  Lors de la suppression, l'op√©ration de <code>delete</code> dans kube apiserver est appel√©e pour les ressources d√©clar√©es dans la version pr√©c√©dente mais non d√©clar√©es dans la version actuelle. <br><br>  L'approche avec le correctif de fusion bidirectionnel a un probl√®me: elle conduit √† une <b>d√©synchronisation de l'√©tat r√©el de la ressource dans le cluster et du manifeste dans Git</b> . <br><br><h3>  Un exemple de probl√®me </h3><br><ul><li>  Dans Git, un manifeste est stock√© sur le graphique dans lequel le champ <code>image</code> d√©ploiement a la valeur <code>ubuntu:18.04</code> . </li><li>  L'utilisateur via <code>kubectl edit</code> chang√© la valeur de ce champ en <code>ubuntu:19.04</code> . </li><li>  Lorsque vous red√©ployez le graphique, Helm <i>ne g√©n√®re pas de correctif</i> , car le champ d' <code>image</code> dans la version pr√©c√©dente de la version et dans le graphique actuel est le m√™me. </li><li>  Apr√®s le d√©ploiement r√©p√©t√© de l' <code>image</code> , <code>ubuntu:19.04</code> reste, bien que <code>ubuntu:18.04</code> soit √©crit sur le graphique. </li></ul><br>  Nous avons obtenu la d√©synchronisation et perdu la d√©clarativit√©. <br><br><h3>  Qu'est-ce qu'une ressource synchronis√©e? </h3><br>  D'une mani√®re g√©n√©rale, il est impossible d'obtenir une correspondance <i>compl√®te</i> entre un manifeste de ressources dans un cluster en cours d'ex√©cution et un manifeste de Git.  Parce que dans le manifeste r√©el, il peut y avoir des annotations / √©tiquettes de service, des conteneurs suppl√©mentaires et d'autres donn√©es ajout√©es et supprim√©es dynamiquement par certains contr√¥leurs de la ressource.  Nous ne pouvons pas et ne voulons pas conserver ces donn√©es dans Git.  Cependant, nous voulons que lors du d√©ploiement, les champs que nous avons explicitement sp√©cifi√©s dans Git prennent les valeurs appropri√©es. <br><br>  Il s'av√®re que cette <b>r√®gle</b> g√©n√©rale <b>d'une ressource synchronis√©e</b> : lorsque vous d√©ployez une ressource, vous pouvez modifier ou supprimer uniquement les champs qui sont explicitement sp√©cifi√©s dans le manifeste de Git (ou qui √©taient enregistr√©s dans la version pr√©c√©dente, mais sont maintenant supprim√©s). <br><br><h3>  Patch de fusion √† 3 voies </h3><br>  L'id√©e principale du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch de fusion √† 3 voies</a> : nous g√©n√©rons un patch entre la derni√®re version appliqu√©e du manifeste de Git et la version cible du manifeste de Git, en tenant compte de la version actuelle du manifeste du cluster de travail.  Le correctif final doit respecter la r√®gle des ressources synchronis√©es: <br><br><ul><li>  les nouveaux champs ajout√©s √† la version cible sont ajout√©s √† l'aide du patch; </li><li>  les champs existants dans la derni√®re version appliqu√©e et qui n'existent pas dans le champ cible sont r√©initialis√©s √† l'aide du correctif; </li><li>  Les champs de la version actuelle de l'objet qui diff√®rent de la version cible du manifeste sont mis √† jour √† l'aide du correctif. </li></ul><br>  C'est par ce principe que sont g√©n√©r√©s les patchs <code>kubectl apply</code> : <br><br><ul><li>  la derni√®re version appliqu√©e du manifeste est stock√©e dans l'annotation de l'objet lui-m√™me, </li><li>  target - extrait du fichier YAML sp√©cifi√©, </li><li>  actuel - √† partir d'un cluster de travail. </li></ul><br>  Maintenant que nous avons compris la th√©orie, il est temps de vous dire ce que nous avons fait au werf. <br><br><h2>  Appliquer les modifications √† werf </h2><br>  Auparavant, werf, comme Helm 2, utilisait des correctifs de fusion bidirectionnelle. <br><br><h3>  Patch de r√©paration </h3><br>  Afin de passer √† un nouveau type de correctifs - fusion √† 3 voies - la premi√®re √©tape, nous avons introduit les <b>correctifs</b> dits de <b>r√©paration</b> . <br><br>  Lors du d√©ploiement, le correctif de fusion bidirectionnel standard est utilis√©, mais werf g√©n√®re en outre un correctif qui synchronise l'√©tat r√©el de la ressource avec ce qui est √©crit dans Git (un tel correctif est cr√©√© en utilisant la m√™me r√®gle de ressource synchronis√©e d√©crite ci-dessus). <br><br>  En cas de rassynchronisation, √† la fin du d√©ploiement, l'utilisateur re√ßoit un AVERTISSEMENT avec le message et le correctif appropri√©s, qui doivent √™tre appliqu√©s pour amener la ressource sous une forme synchronis√©e.  De plus, ce patch est enregistr√© dans une annotation sp√©ciale <code>werf.io/repair-patch</code> .  Il est suppos√© que l'utilisateur <b>lui-m√™me</b> appliquera ce patch avec ses mains: werf ne l'appliquera pas en principe. <br><br>  La g√©n√©ration de correctifs de r√©paration est une mesure temporaire qui vous permet de tester r√©ellement la cr√©ation de correctifs sur le principe de la fusion √† trois, mais sans appliquer automatiquement ces correctifs.  Pour le moment, ce mode de fonctionnement est activ√© par d√©faut. <br><br><h3>  Patch de fusion √† 3 voies pour les nouvelles versions uniquement </h3><br>  √Ä compter du 1er d√©cembre 2019, les versions b√™ta et alpha de werf commencent <b>par d√©faut √†</b> utiliser des correctifs de fusion √† trois voies √† part enti√®re pour appliquer les modifications uniquement aux nouvelles versions de Helm d√©ploy√©es via werf.  Les versions existantes continueront d'utiliser l'approche de correctif de fusion + r√©paration bidirectionnelle. <br><br>  Vous pouvez activer ce mode de fonctionnement de mani√®re explicite en d√©finissant <code>WERF_THREE_WAY_MERGE_MODE=onlyNewReleases</code> maintenant. <br><br>  <i><b>Remarque</b> : la fonctionnalit√© est apparue dans werf sur plusieurs versions: dans le canal alpha, elle est devenue pr√™te √† partir de la version <a href="">v1.0.5-alpha.19</a> , et dans le canal b√™ta avec <a href="">v1.0.4-beta.20</a> .</i> <br><br><h3>  Patch de fusion √† 3 voies pour toutes les versions </h3><br>  √Ä partir du 15 d√©cembre 2019, les versions b√™ta et alpha de werf commencent √† utiliser des correctifs de fusion √† trois voies par d√©faut pour appliquer les modifications √† toutes les versions. <br><br>  Ce mode de fonctionnement peut √™tre explicitement <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> d√©finissant <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> maintenant. <br><br><h3>  Que faire des ressources de mise √† l'√©chelle automatique? </h3><br>  Kubernetes propose 2 types de mise √† l'√©chelle automatique: HPA (horizontal) et VPA (vertical). <br><br>  Horizontal s√©lectionne automatiquement le nombre de r√©pliques, vertical - le nombre de ressources.  Le nombre de r√©pliques et les besoins en ressources sont sp√©cifi√©s dans le manifeste de ressources (voir <code>spec.replicas</code> ou <code>spec.containers[].resources.limits.cpu</code> , <code>spec.containers[].resources.limits.memory</code> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres</a> ). <br><br>  Probl√®me: si un utilisateur configure une ressource sur le graphique afin qu'elle affiche des valeurs sp√©cifiques pour les ressources ou que les r√©pliques et les scalers automatiques soient activ√©s pour cette ressource, √† chaque d√©ploiement werf r√©initialisera ces valeurs √† ce qui est √©crit dans le manifeste du graphique. <br><br>  Il existe deux solutions au probl√®me.  Pour commencer, il est pr√©f√©rable de ne pas sp√©cifier explicitement les valeurs de mise √† l'√©chelle automatique dans le manifeste du graphique.  Si, pour une raison quelconque, cette option ne convient pas (par exemple, car il est pratique de d√©finir les limites de ressources initiales et le nombre de r√©pliques sur le graphique), werf propose les annotations suivantes: <br><br><ul><li> <code>werf.io/set-replicas-only-on-creation=true</code> </li> <li> <code>werf.io/set-resources-only-on-creation=true</code> </li> </ul><br>  Si une telle annotation est pr√©sente, werf ne r√©initialisera pas les valeurs correspondantes √† chaque d√©ploiement, mais les d√©finira uniquement lors de la cr√©ation initiale de la ressource. <br><br>  Pour plus d'informations, consultez la documentation du projet pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HPA</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VPA</a> . <br><br><h3>  Refuser l'utilisation du correctif de fusion √† 3 voies </h3><br>  L'utilisateur peut toujours interdire l'utilisation de nouveaux correctifs dans werf en utilisant la variable d'environnement <code>WERF_THREE_WAY_MERGE_MODE=disabled</code> .  Cependant, √† partir <b>du 1er mars 2020, cette interdiction cessera de fonctionner</b> et il ne sera possible d'utiliser que des correctifs de fusion √† 3 voies. <br><br><h2>  Adoption de ressources dans werf </h2><br>  La ma√Ætrise de la m√©thode d'application des modifications dans les correctifs de fusion √† 3 voies nous a permis d'impl√©menter imm√©diatement une fonctionnalit√© telle que l'adoption des ressources existantes dans le cluster dans la version Helm. <br><br>  Helm 2 a un probl√®me: vous ne pouvez pas ajouter une ressource √† un manifeste de graphique qui existe d√©j√† dans le cluster sans recr√©er cette ressource √† partir de z√©ro (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 6031</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 3275</a> ).  Nous avons appris √† werf √† accepter les ressources existantes dans une version.  Pour ce faire, vous devez d√©finir une annotation sur la version actuelle de la ressource √† partir d'un cluster en cours d'ex√©cution (par exemple, en utilisant <code>kubectl edit</code> ): <br><br><pre> <code class="plaintext hljs">"werf.io/allow-adoption-by-release": RELEASE_NAME</code> </pre> <br>  Maintenant, la ressource doit √™tre d√©crite sur le graphique et lors du prochain d√©ploiement par la version werf de la version avec le nom correspondant, la ressource existante sera accept√©e dans cette version et restera sous son contr√¥le.  De plus, dans le processus d'acceptation de la ressource pour publication, werf ram√®nera l'√©tat actuel de la ressource du cluster de travail √† l'√©tat d√©crit sur le graphique en utilisant les m√™mes correctifs de fusion √† 3 voies et la r√®gle de ressource synchronis√©e. <br><br>  <i><b>Remarque</b> : la d√©finition de <code>WERF_THREE_WAY_MERGE_MODE</code> n'affecte pas l'adoption des ressources - dans le cas de l'adoption, un correctif de fusion √† 3 voies est toujours utilis√©.</i> <br><br>  Les d√©tails sont dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . <br><br><h2>  Conclusions et plans futurs </h2><br>  J'esp√®re qu'apr√®s cet article, il est devenu plus clair ce que sont les correctifs de fusion √† 3 et pourquoi ils sont venus √† eux.  D'un point de vue pratique du d√©veloppement du projet werf, leur mise en ≈ìuvre a constitu√© une nouvelle √©tape vers l'am√©lioration du d√©ploiement de type Helm.  Vous pouvez maintenant oublier les probl√®mes de synchronisation de configuration, qui se sont souvent produits lors de l'utilisation de Helm 2. En m√™me temps, une nouvelle fonctionnalit√© utile de l'adoption des ressources Kubernetes d√©j√† t√©l√©charg√©es dans la version Helm a √©t√© ajout√©e. <br><br>  Il y a encore des probl√®mes et des difficult√©s dans le d√©ploiement de type Helm, tels que l'utilisation des mod√®les Go, et nous continuerons √† les r√©soudre. <br><br>  Des informations sur les m√©thodes de mise √† jour des ressources et leur adoption sont √©galement disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette page de documentation</a> . <br><br><h3>  Heaume 3 </h3><br>  Une note sp√©ciale est digne de la nouvelle version majeure r√©cemment publi√©e de Helm - v3 - qui utilise √©galement des correctifs de fusion √† 3 voies et se d√©barrasse de Tiller.  La nouvelle version de Helm n√©cessite la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">migration des</a> installations existantes afin de les convertir dans un nouveau format de stockage de version. <br><br>  Werf, pour sa part, a d√©sormais √©limin√© l'utilisation de Tiller, est pass√© √† la fusion √† 3 et en a ajout√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">beaucoup plus</a> , tout en restant compatible avec les installations existantes sur Helm 2 (aucun script de migration n'est n√©cessaire).  Par cons√©quent, jusqu'√† ce que werf passe √† Helm 3, les utilisateurs de werf ne perdent pas les principaux avantages de Helm 3 par rapport √† Helm 2 (ils existent √©galement dans werf). <br><br>  Cependant, le passage de werf √† la base de code de Helm 3 est in√©vitable et se produira dans un avenir proche.  Vraisemblablement, ce sera werf 1.1 ou werf 1.2 (pour le moment, la version principale de werf est 1.0; pour plus de d√©tails sur le dispositif de version werf, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  Pendant ce temps, Helm 3 aura le temps de se stabiliser. <br><br><h2>  PS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  Une s√©rie de notes sur les innovations dans werf: <br><ul><li>  ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de werf pour d√©ployer des graphiques Helm complexes</a> ¬ª; </li><li>  ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge de monorepo et multirepo dans werf et qu'est-ce que le Docker Registry a √† voir avec cela</a> ¬ª; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous pouvez maintenant cr√©er des images Docker dans werf en utilisant le Dockerfile habituel</a> ." </li></ul></li><li>  ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Werf est notre outil CI / CD √† Kubernetes (revue et rapport vid√©o)</a> ¬ª; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Assemblage et d√©ploiement du m√™me type de microservices avec werf et GitLab CI</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©sentation de Helm 3.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476646/">https://habr.com/ru/post/fr476646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476626/index.html">PVS-Studio dans les nuages: GitLab CI / CD</a></li>
<li><a href="../fr476628/index.html">PVS-Studio passe aux nuages: GitLab CI / CD</a></li>
<li><a href="../fr476636/index.html">Optimisation de Firebird et Linux pour une base de donn√©es de 691 Go avec plus de 1000 utilisateurs</a></li>
<li><a href="../fr476640/index.html">Protection de Zimbra OSE contre la force brute et les attaques DoS</a></li>
<li><a href="../fr476644/index.html">Couches linguistiques</a></li>
<li><a href="../fr476648/index.html">Lenovo √† FINOPOLIS 2019</a></li>
<li><a href="../fr476650/index.html">La place de l'√©num√©ration dans le monde en mutation d'aujourd'hui</a></li>
<li><a href="../fr476656/index.html">26 novembre, Moscou - Alfa JS MeetUP # 3</a></li>
<li><a href="../fr476658/index.html">VPS avec une carte vid√©o (partie 2): capacit√©s informatiques</a></li>
<li><a href="../fr476664/index.html">oktech: Frontend Meetup # 2: mini interviews de conf√©renciers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>