<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíä üå∞ üàØÔ∏è Menggunakan semua fitur indeks di PostgreSQL üñïüèº ü§ûüèº üéÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di dunia Postgres, indeks sangat penting untuk menavigasi repositori basis data secara efisien (disebut heap, heap). Postgres tidak mendukung pengelom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan semua fitur indeks di PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/453046/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/aj/sm/1h/ajsm1hnpv2mljoxorbwxshprkog.jpeg"></div><br>  Di dunia Postgres, indeks sangat penting untuk menavigasi repositori basis data secara efisien (disebut heap, heap).  Postgres tidak mendukung pengelompokan untuk itu, dan arsitektur MVCC menyebabkan Anda mengumpulkan banyak versi dari tuple yang sama.  Oleh karena itu, sangat penting untuk dapat membuat dan memelihara indeks yang efektif untuk mendukung aplikasi. <br><br>  Berikut adalah beberapa kiat untuk mengoptimalkan dan meningkatkan penggunaan indeks. <br><br>  <i>Catatan: kueri yang ditampilkan di bawah ini berfungsi pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">database sampel pagila yang</a> tidak dimodifikasi.</i> <br><a name="habracut"></a><br><h3>  Menggunakan Covering Indexes </h3><br>  Mari kita tinjau permintaan untuk mengambil alamat email untuk pengguna yang tidak aktif.  Tabel <code>customer</code> memiliki kolom <code>active</code> , dan permintaannya sederhana: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># EXPLAIN SELECT email FROM customer WHERE active=0; QUERY PLAN ----------------------------------------------------------- Seq Scan on customer (cost=0.00..16.49 rows=15 width=32) Filter: (active = 0) (2 rows)</span></span></code> </pre> <br>  Permintaan meminta urutan lengkap pemindaian tabel <code>customer</code> .  Mari kita buat indeks untuk kolom <code>active</code> : <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_cust1 ON customer(active); CREATE INDEX pagila=# EXPLAIN SELECT email FROM customer WHERE active=0; QUERY PLAN ----------------------------------------------------------------------------- Index Scan using idx_cust1 on customer (cost=0.28..12.29 rows=15 width=32) Index Cond: (active = 0) (2 rows)</span></span></code> </pre> <br>  Ini membantu, pemindaian selanjutnya berubah menjadi " <code>index scan</code> ".  Ini berarti Postgres akan memindai indeks <code>idx_cust1</code> , dan kemudian melanjutkan mencari tumpukan tabel untuk membaca nilai-nilai kolom lain (dalam hal ini, kolom <code>email</code> ) yang dibutuhkan oleh kueri. <br><br>  PostgreSQL 11 diperkenalkan meliputi indeks.  Mereka memungkinkan Anda untuk memasukkan satu atau lebih kolom tambahan dalam indeks itu sendiri - nilainya disimpan dalam penyimpanan data indeks. <br><br>  Jika kami menggunakan fitur ini dan menambahkan nilai email di dalam indeks, maka Postgres tidak perlu mencari nilai <code>email</code> di tumpukan tabel.  Mari kita lihat apakah ini bekerja: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_cust2 ON customer(active) INCLUDE (email); CREATE INDEX pagila=# EXPLAIN SELECT email FROM customer WHERE active=0; QUERY PLAN ---------------------------------------------------------------------------------- Index Only Scan using idx_cust2 on customer (cost=0.28..12.29 rows=15 width=32) Index Cond: (active = 0) (2 rows)</span></span></code> </pre> <br>  " <code>Index Only Scan</code> " memberi tahu kita bahwa permintaan sekarang hanya membutuhkan satu indeks, yang membantu menghindari semua disk I / O untuk membaca tumpukan tabel. <br><br>  Hari ini, indeks penutupan hanya tersedia untuk pohon-B.  Namun, dalam hal ini, upaya pengawalan akan lebih tinggi. <br><br><h3>  Menggunakan indeks parsial </h3><br>  Indeks parsial hanya mengindeks sebagian dari baris dalam tabel.  Ini menghemat ukuran indeks dan pemindaian lebih cepat. <br><br>  Misalkan kita perlu mendapatkan daftar alamat email dari pelanggan California kami.  Permintaan akan seperti ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.email <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customer c <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> address a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> c.address_id = a.address_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.district = <span class="hljs-string"><span class="hljs-string">'California'</span></span>; which has a query plan that involves scanning both the tables that are joined: pagila=<span class="hljs-comment"><span class="hljs-comment"># EXPLAIN SELECT c.email FROM customer c pagila-# JOIN address a ON c.address_id = a.address_id pagila-# WHERE a.district = 'California'; QUERY PLAN ---------------------------------------------------------------------- Hash Join (cost=15.65..32.22 rows=9 width=32) Hash Cond: (c.address_id = a.address_id) -&gt; Seq Scan on customer c (cost=0.00..14.99 rows=599 width=34) -&gt; Hash (cost=15.54..15.54 rows=9 width=4) -&gt; Seq Scan on address a (cost=0.00..15.54 rows=9 width=4) Filter: (district = 'California'::text) (6 rows)</span></span></code> </pre> <br>  Apa yang biasa diberikan indeks kepada kami: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_address1 ON address(district); CREATE INDEX pagila=# EXPLAIN SELECT c.email FROM customer c pagila-# JOIN address a ON c.address_id = a.address_id pagila-# WHERE a.district = 'California'; QUERY PLAN --------------------------------------------------------------------------------------- Hash Join (cost=12.98..29.55 rows=9 width=32) Hash Cond: (c.address_id = a.address_id) -&gt; Seq Scan on customer c (cost=0.00..14.99 rows=599 width=34) -&gt; Hash (cost=12.87..12.87 rows=9 width=4) -&gt; Bitmap Heap Scan on address a (cost=4.34..12.87 rows=9 width=4) Recheck Cond: (district = 'California'::text) -&gt; Bitmap Index Scan on idx_address1 (cost=0.00..4.34 rows=9 width=0) Index Cond: (district = 'California'::text) (8 rows)</span></span></code> </pre> <br>  Pemindaian <code>address</code> digantikan oleh <code>idx_address1</code> indeks <code>idx_address1</code> , dan kemudian tumpukan <code>address</code> dipindai. <br><br>  Karena ini adalah kueri yang sering dan perlu dioptimalkan, kami dapat menggunakan indeks parsial yang hanya mengindeks baris-baris dengan alamat di mana wilayah <code>'California'</code> : <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_address2 ON address(address_id) WHERE district='California'; CREATE INDEX pagila=# EXPLAIN SELECT c.email FROM customer c pagila-# JOIN address a ON c.address_id = a.address_id pagila-# WHERE a.district = 'California'; QUERY PLAN ------------------------------------------------------------------------------------------------ Hash Join (cost=12.38..28.96 rows=9 width=32) Hash Cond: (c.address_id = a.address_id) -&gt; Seq Scan on customer c (cost=0.00..14.99 rows=599 width=34) -&gt; Hash (cost=12.27..12.27 rows=9 width=4) -&gt; Index Only Scan using idx_address2 on address a (cost=0.14..12.27 rows=9 width=4) (5 rows)</span></span></code> </pre> <br>  Sekarang permintaan hanya membaca <code>idx_address2</code> dan tidak menyentuh tabel <code>address</code> . <br><br><h3>  Menggunakan Indeks Multi-Nilai </h3><br>  Beberapa kolom yang perlu diindeks mungkin tidak mengandung tipe data skalar.  Jenis <code>jsonb</code> seperti <code>jsonb</code> , <code>arrays</code> dan <code>tsvector</code> berisi beberapa nilai.  Jika Anda perlu mengindeks kolom tersebut, Anda biasanya harus mencari semua nilai individual di kolom ini. <br><br>  Mari kita coba menemukan nama-nama semua film yang berisi potongan dari pengambilan yang tidak berhasil.  Tabel <code>film</code> memiliki kolom teks yang disebut <code>special_features</code> .  Jika film memiliki "properti khusus" ini, maka kolom berisi elemen dalam bentuk array teks <code>Behind The Scenes</code> .  Untuk mencari semua film semacam itu, kita perlu memilih semua baris dengan "Di Balik Layar" untuk nilai <b>apa pun</b> dari array <code>special_features</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> film <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> special_features @&gt; <span class="hljs-string"><span class="hljs-string">'{"Behind The Scenes"}'</span></span>;</code> </pre> <br>  Operator kontainmen <code>@&gt;</code> memeriksa untuk melihat apakah sisi kanan adalah subset dari sisi kiri. <br><br>  Paket Permintaan: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># EXPLAIN SELECT title FROM film pagila-# WHERE special_features @&gt; '{"Behind The Scenes"}'; QUERY PLAN ----------------------------------------------------------------- Seq Scan on film (cost=0.00..67.50 rows=5 width=15) Filter: (special_features @&gt; '{"Behind The Scenes"}'::text[]) (2 rows)</span></span></code> </pre> <br>  Yang meminta pemindaian tumpukan penuh dengan biaya 67. <br><br>  Mari kita lihat apakah indeks B-tree reguler membantu kita: <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_film1 ON film(special_features); CREATE INDEX pagila=# EXPLAIN SELECT title FROM film pagila-# WHERE special_features @&gt; '{"Behind The Scenes"}'; QUERY PLAN ----------------------------------------------------------------- Seq Scan on film (cost=0.00..67.50 rows=5 width=15) Filter: (special_features @&gt; '{"Behind The Scenes"}'::text[]) (2 rows)</span></span></code> </pre> <br>  Indeks itu bahkan tidak dipertimbangkan.  Indeks B-tree tidak menyadari keberadaan elemen individu dalam nilai yang diindeks. <br><br>  Kami membutuhkan indeks GIN. <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX idx_film2 ON film USING GIN(special_features); CREATE INDEX pagila=# EXPLAIN SELECT title FROM film pagila-# WHERE special_features @&gt; '{"Behind The Scenes"}'; QUERY PLAN --------------------------------------------------------------------------- Bitmap Heap Scan on film (cost=8.04..23.58 rows=5 width=15) Recheck Cond: (special_features @&gt; '{"Behind The Scenes"}'::text[]) -&gt; Bitmap Index Scan on idx_film2 (cost=0.00..8.04 rows=5 width=0) Index Cond: (special_features @&gt; '{"Behind The Scenes"}'::text[]) (4 rows)</span></span></code> </pre> <br>  GIN-index mendukung perbandingan nilai individu dengan nilai komposit terindeks, sebagai akibatnya, biaya rencana kueri berkurang lebih dari setengah. <br><br><h3>  Singkirkan indeks rangkap </h3><br>  Indeks terakumulasi dari waktu ke waktu, dan terkadang indeks baru mungkin berisi definisi yang sama dengan yang sebelumnya.  Untuk mendapatkan definisi indeks yang dapat dibaca manusia, Anda dapat menggunakan <code>pg_indexes</code> tampilan katalog.  Anda juga dapat dengan mudah menemukan definisi yang sama: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> array_agg(indexname) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">indexes</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span>(indexdef, indexname, <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> defn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_indexes <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> defn <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; And here's the result when run on the stock pagila database: pagila=<span class="hljs-comment"><span class="hljs-comment"># SELECT array_agg(indexname) AS indexes, replace(indexdef, indexname, '') AS defn pagila-# FROM pg_indexes pagila-# GROUP BY defn pagila-# HAVING count(*) &gt; 1; indexes | defn ------------------------------------------------------------------------+------------------------------------------------------------------ {payment_p2017_01_customer_id_idx,idx_fk_payment_p2017_01_customer_id} | CREATE INDEX ON public.payment_p2017_01 USING btree (customer_id {payment_p2017_02_customer_id_idx,idx_fk_payment_p2017_02_customer_id} | CREATE INDEX ON public.payment_p2017_02 USING btree (customer_id {payment_p2017_03_customer_id_idx,idx_fk_payment_p2017_03_customer_id} | CREATE INDEX ON public.payment_p2017_03 USING btree (customer_id {idx_fk_payment_p2017_04_customer_id,payment_p2017_04_customer_id_idx} | CREATE INDEX ON public.payment_p2017_04 USING btree (customer_id {payment_p2017_05_customer_id_idx,idx_fk_payment_p2017_05_customer_id} | CREATE INDEX ON public.payment_p2017_05 USING btree (customer_id {idx_fk_payment_p2017_06_customer_id,payment_p2017_06_customer_id_idx} | CREATE INDEX ON public.payment_p2017_06 USING btree (customer_id (6 rows)</span></span></code> </pre><br><h3>  Indeks Superset </h3><br>  Mungkin terjadi bahwa Anda mengumpulkan banyak indeks, salah satunya indeks bagian dari kolom yang indeks indeks lainnya.  Ini bisa baik diinginkan atau tidak - superset hanya dapat memindai berdasarkan indeks, yang bagus, tetapi dapat memakan banyak ruang, atau permintaan yang superset ini dimaksudkan untuk dioptimalkan tidak lagi digunakan. <br><br>  Jika Anda perlu mengotomatiskan definisi indeks tersebut, Anda bisa mulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_index</a> dari tabel <code>pg_catalog</code> . <br><br><h3>  Indeks yang Tidak Digunakan </h3><br>  Saat aplikasi yang menggunakan basis data berkembang, demikian juga kueri yang mereka gunakan.  Indeks yang ditambahkan sebelumnya mungkin tidak lagi digunakan oleh permintaan apa pun.  Setiap kali indeks dipindai, itu ditandai oleh manajer statistik, dan dalam <code>pg_stat_user_indexes</code> katalog sistem <code>pg_stat_user_indexes</code> Anda dapat melihat nilai <code>idx_scan</code> , yang merupakan penghitung kumulatif.  Melacak nilai ini selama periode waktu tertentu (katakanlah, sebulan) akan memberikan ide bagus tentang indeks mana yang tidak digunakan dan dapat dihapus. <br><br>  Berikut adalah permintaan untuk mendapatkan jumlah pemindaian saat ini dari semua indeks dalam skema <code>'public'</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname, indexrelname, idx_scan <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_catalog.pg_stat_user_indexes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> schemaname = <span class="hljs-string"><span class="hljs-string">'public'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">output</span></span> <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> this: pagila=<span class="hljs-comment"><span class="hljs-comment"># SELECT relname, indexrelname, idx_scan pagila-# FROM pg_catalog.pg_stat_user_indexes pagila-# WHERE schemaname = 'public' pagila-# LIMIT 10; relname | indexrelname | idx_scan ---------------+--------------------+---------- customer | customer_pkey | 32093 actor | actor_pkey | 5462 address | address_pkey | 660 category | category_pkey | 1000 city | city_pkey | 609 country | country_pkey | 604 film_actor | film_actor_pkey | 0 film_category | film_category_pkey | 0 film | film_pkey | 11043 inventory | inventory_pkey | 16048 (10 rows)</span></span></code> </pre> <br><h3>  Buat kembali indeks dengan kunci lebih sedikit </h3><br>  Seringkali indeks harus dibuat ulang, misalnya ketika ukurannya digelembungkan, dan pembuatan ulang dapat mempercepat pemindaian.  Juga, indeks mungkin rusak.  Mengubah parameter indeks mungkin juga perlu membuatnya kembali. <br><br><h3>  Aktifkan pembuatan indeks paralel </h3><br>  Di PostgreSQL 11, membuat indeks B-Tree kompetitif.  Untuk mempercepat proses pembuatan, beberapa pekerja paralel dapat digunakan.  Namun, pastikan bahwa parameter konfigurasi ini diatur dengan benar: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_workers = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_maintenance_workers = <span class="hljs-number"><span class="hljs-number">16</span></span>;</code> </pre> <br>  Nilai default terlalu kecil.  Idealnya, angka-angka ini harus ditambah seiring dengan jumlah inti prosesor.  Baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi untuk</a> lebih jelasnya. <br><br><h3>  Pembuatan Indeks Latar Belakang </h3><br>  Anda dapat membuat indeks di latar belakang menggunakan parameter <code>CONCURRENTLY</code> dari perintah <code>CREATE INDEX</code> : <br><br><pre> <code class="sql hljs">pagila=<span class="hljs-comment"><span class="hljs-comment"># CREATE INDEX CONCURRENTLY idx_address1 ON address(district); CREATE INDEX</span></span></code> </pre> <br><br>  Prosedur pembuatan indeks ini berbeda dari yang biasa karena tidak memerlukan penguncian tabel, dan karenanya tidak memblokir operasi penulisan.  Di sisi lain, dibutuhkan lebih banyak waktu dan menghabiskan lebih banyak sumber daya. <br><br>  Postgres menyediakan banyak opsi fleksibel untuk membuat indeks dan cara untuk menyelesaikan kasus tertentu, serta menyediakan cara untuk mengelola basis data jika terjadi ledakan pertumbuhan aplikasi Anda.  Kami harap tips ini akan membantu Anda membuat kueri Anda lebih cepat dan database Anda siap untuk ditingkatkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453046/">https://habr.com/ru/post/id453046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453032/index.html">Kami memainkan mobil dewasa-2: bagaimana kami menjadi pemasok telematika untuk berbagi mobil dan membuka 5 kantor di seluruh dunia</a></li>
<li><a href="../id453034/index.html">Ayah membuat prostesis bionik untuk putranya menggunakan printer 3D dan X-Box</a></li>
<li><a href="../id453038/index.html">Software Defined Radio - bagaimana cara kerjanya? Bagian 4</a></li>
<li><a href="../id453042/index.html">Windows Terminal Build 2019 FAQ</a></li>
<li><a href="../id453044/index.html">Langkah yang telah lama ditunggu-tunggu menuju dokumen yang terstruktur rumit (+ video)</a></li>
<li><a href="../id453056/index.html">Membuat prototipe game seluler, mulai dari mana, dan bagaimana melakukannya. Bagian 1</a></li>
<li><a href="../id453058/index.html">AI belajar membuat video dari satu bingkai. Lukisan lama sekarang bisa dibuat hidup</a></li>
<li><a href="../id453064/index.html">Membahayakan untuk kebaikan: Sistem kekebalan tubuh Lamprey dalam perang melawan kanker otak manusia</a></li>
<li><a href="../id453066/index.html">UI tipografi - cara baru untuk mengembangkan antarmuka pengguna</a></li>
<li><a href="../id453068/index.html">Subjektivitas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>