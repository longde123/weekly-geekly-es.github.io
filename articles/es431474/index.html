<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚀 ⛄️ 💆🏿 Arquitectura de microservicios en una pila moderna de tecnologías Java 🥒 🎲 🤟🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teníamos JDK 11, Kotlin, Spring 5 y Spring Boot 2, Gradle 5 con Kotlin DSL, JUnit 5 y una docena de bibliotecas de pila Spring Cloud para el descubrim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arquitectura de microservicios en una pila moderna de tecnologías Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431474/">  <i>Teníamos JDK 11, Kotlin, Spring 5 y Spring Boot 2, Gradle 5 con Kotlin DSL, JUnit 5 y una docena de bibliotecas de pila Spring Cloud para el descubrimiento de servicios, creación de API de puerta de enlace, equilibrio de clientes e implementación de disyuntor. escribir clientes HTTP declarativos, rastreo distribuido y todo eso.</i>  <i>No es que todo esto fuera necesario para crear una arquitectura de microservicio, solo por diversión ...</i> <br><a name="habracut"></a><br><h1>  Entrada </h1><br>  En este artículo, verá un ejemplo de arquitectura de microservicios que utiliza tecnologías relevantes en el mundo de Java, las principales a continuación (estas versiones se utilizan en el proyecto en el momento de la publicación): <br><div class="scrollable-table"><table><tbody><tr><th>  Tipo de tecnología </th><th>  Titulo </th><th>  Versión </th></tr><tr><td>  Plataforma </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Jdk</a> </td><td>  11.0.1 </td></tr><tr><td>  Lenguaje de programación </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Kotlin</a> </td><td>  1.3.10 </td></tr><tr><td rowspan="2">  Marco de aplicación </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Marco de primavera</a> </td><td>  5.0.9 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Bota de primavera</a> </td><td>  2.0.5 </td></tr><tr><td rowspan="2">  Sistema de construcción </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Gradle</a> </td><td>  5.0 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Gradle Kotlin DSL</a> </td><td>  1.0.4 </td></tr><tr><td>  Marco de prueba de unidad </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Junit</a> </td><td>  5.1.1 </td></tr><tr><td colspan="3" align="center">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Nube de primavera</a> </td></tr><tr><td>  Punto de acceso único (puerta de enlace API) </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Spring Cloud Gateway</a> </td><td rowspan="7">  Incluido en el tren de lanzamiento del proyecto Finchley SR2 Spring Cloud </td></tr><tr><td>  Configuración centralizada </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Spring Cloud config</a> </td></tr><tr><td>  Solicitud de seguimiento (seguimiento distribuido) </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Detective de nubes de primavera</a> </td></tr><tr><td>  Cliente HTTP declarativo </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Spring Cloud OpenFeign</a> </td></tr><tr><td>  Descubrimiento de servicio </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Spring Cloud Netflix Eureka</a> </td></tr><tr><td>  Disyuntor </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Spring Cloud Netflix Hystrix</a> </td></tr><tr><td>  Balanceo de carga del lado del cliente </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Spring Cloud Netflix Ribbon</a> </td></tr></tbody></table></div><br>  El proyecto consta de 5 microservicios: 3 infraestructura (servidor de configuración, servidor de descubrimiento de servicios, puerta de enlace de UI) y ejemplos de front-end (UI de elementos) y back-end (servicio de elementos): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jz/rw/ia/jzrwiaehuhksnkj2dzmjea-43fy.png"></div><br>  Todos ellos serán considerados secuencialmente a continuación.  En un proyecto de "combate", obviamente, habrá significativamente más microservicios que implementarán cualquier funcionalidad comercial.  Agregarlos a una arquitectura similar se realiza técnicamente de la misma manera que la interfaz de usuario de ítems y el servicio de ítems. <br><br><h3>  Descargo de responsabilidad </h3><br>  El artículo no considera instrumentos para contenerización y orquestación, ya que actualmente no se utilizan en el proyecto. <br><br><h1>  Servidor de configuración </h1><br>  Spring Cloud Config se utilizó para crear un repositorio centralizado de configuraciones de aplicaciones.  Las configuraciones se pueden leer desde varias fuentes, por ejemplo, un repositorio git separado;  en este proyecto, por simplicidad y claridad, están en los recursos de la aplicación: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sm/35/af/sm35aft9609348sicenfjgosw1k.png"></div><br>  En este caso, la configuración del servidor de configuración ( <code>application.yml</code> ) se ve así: <br><br><pre> <code class="plaintext hljs">spring: profiles: active: native cloud: config: server: native: search-locations: classpath:/config server: port: 8888</code> </pre> <br>  El uso del puerto 8888 permite a los clientes del servidor de configuración no especificar explícitamente su puerto en su <code>bootstrap.yml</code> .  Al inicio, cargan su configuración ejecutando una solicitud GET al servidor de configuración de API HTTP. <br><br>  El código del programa para este microservicio consta de un solo archivo, que contiene la declaración de la clase de aplicación y el método principal, que, a diferencia del código Java equivalente, es una función de nivel superior: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigServer</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigServerApplication</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span></span>(args: Array&lt;String&gt;) { runApplication&lt;ConfigServerApplication&gt;(*args) }</code> </pre> <br>  Las clases de aplicación y los métodos principales en otros microservicios tienen una apariencia similar. <br><br><h1>  Servidor de descubrimiento de servicios </h1><br>  El descubrimiento de servicios es un patrón de arquitectura de microservicios que le permite simplificar la interacción entre las aplicaciones ante un posible cambio en el número de sus instancias y la ubicación de la red.  Un componente clave en este enfoque es el registro del Servicio, una base de datos de microservicios, sus instancias y ubicaciones de red (más detalles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aquí</a> ). <br><br>  En este proyecto, el descubrimiento de servicios se implementa sobre la base de Netflix Eureka, que es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">descubrimiento de servicios del lado del cliente</a> : el servidor Eureka realiza la función del registro del servicio, y el cliente Eureka, antes de ejecutar una solicitud a cualquier microservicio, se pone en contacto con el servidor Eureka para obtener una lista de instancias de la aplicación llamada y realiza el equilibrio de forma independiente cargar (usando la cinta de Netflix).  Netflix Eureka, como algunos otros componentes de la pila OSS de Netflix (como Hystrix y Ribbon) se integra con las aplicaciones Spring Boot que utilizan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Spring Cloud Netflix</a> . <br><br>  En la configuración del servidor de descubrimiento de servicios ubicada en sus recursos ( <code>bootstrap.yml</code> ), solo se indica el nombre de la aplicación y el parámetro que indica que el inicio del microservicio se interrumpirá si es imposible conectarse al servidor de configuración: <br><br><pre> <code class="plaintext hljs">spring: application: name: eureka-server cloud: config: fail-fast: true</code> </pre> <br>  El resto de la configuración de la aplicación se encuentra en el <code>eureka-server.yml</code> en los recursos del servidor de configuración: <br><br><pre> <code class="plaintext hljs">server: port: 8761 eureka: client: register-with-eureka: true fetch-registry: false</code> </pre> <br>  El servidor Eureka usa el puerto 8761, que permite a todos los clientes de Eureka no especificarlo usando el valor predeterminado.  El valor del <code>register-with-eureka</code> (indicado para mayor claridad, porque también se usa de forma predeterminada) significa que la aplicación misma, como otros microservicios, se registrará en el servidor Eureka.  El parámetro <code>fetch-registry</code> determina si el cliente Eureka recibirá datos del registro del Servicio. <br><br>  Una lista de aplicaciones registradas y otra información está disponible en <code>http://localhost:8761/</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sh/co/lz/shcolza08r8j3qkdmgb42exawqs.png"></div><br>  Las alternativas para implementar el descubrimiento de servicios son Cónsul, Zookeeper y otros. <br><br><h1>  Servicio de artículos </h1><br>  Esta aplicación es un ejemplo de un back-end con una API REST implementada utilizando el marco WebFlux que apareció en Spring 5 (la documentación está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aquí</a> ), o más bien Kotlin DSL para ello: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">itemsRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handler: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ItemHandler</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = router { path(<span class="hljs-string"><span class="hljs-string">"/items"</span></span>).nest { GET(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, handler::getAll) POST(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, handler::add) GET(<span class="hljs-string"><span class="hljs-string">"/{id}"</span></span>, handler::getOne) PUT(<span class="hljs-string"><span class="hljs-string">"/{id}"</span></span>, handler::update) } }</code> </pre> <br>  El procesamiento de las solicitudes HTTP recibidas se delega al <code>ItemHandler</code> clase <code>ItemHandler</code> .  Por ejemplo, un método para obtener una lista de objetos de alguna entidad se ve así: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServerRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = ServerResponse.ok() .contentType(APPLICATION_JSON_UTF8) .body(fromObject(itemRepository.findAll()))</code> </pre> <br>  La aplicación se convierte en un cliente del servidor Eureka, es decir, registra y recibe datos del registro del Servicio, debido a la presencia de la <code>spring-cloud-starter-netflix-eureka-client</code> .  Después del registro, la aplicación envía hartbits al servidor Eureka con cierta frecuencia, y si durante un cierto período de tiempo el porcentaje de hartbits recibidos por el servidor Eureka en relación con el valor máximo posible cae por debajo de un cierto umbral, la aplicación se eliminará del registro del Servicio. <br><br>  Considere una de las formas de enviar metadatos adicionales al servidor Eureka: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@PostConstruct</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = aim.registerAppMetadata(mapOf(<span class="hljs-string"><span class="hljs-string">"description"</span></span> to <span class="hljs-string"><span class="hljs-string">"Some description"</span></span>))</code> </pre> <br>  Asegúrese de que el servidor Eureka reciba estos datos en <code>http://localhost:8761/eureka/apps/items-service</code> través de Postman: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5l/0v/xg/5l0vxgolfgjzyuceskxhmdv-0kc.png"></div><br><br><h1>  UI de elementos </h1><br>  Este microservicio, además de demostrar la interacción con la puerta de enlace de la interfaz de usuario (se mostrará en la siguiente sección), realiza la función front-end para el servicio Items, que puede interactuar con la API REST de varias maneras: <br><br><ol><li>  Cliente a REST API escrito usando OpenFeign: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@FeignClient(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"items-service"</span></span></span><span class="hljs-meta">, fallbackFactory = ItemsServiceFeignClient.ItemsServiceFeignClientFallbackFactory::class)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ItemsServiceFeignClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GetMapping(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/items/{id}"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@PathVariable(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"id"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String <span class="hljs-meta"><span class="hljs-meta">@GetMapping(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/not-existing-path"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHystrixFallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ItemsServiceFeignClientFallbackFactory</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FallbackFactory</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ItemsServiceFeignClient</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> log = LoggerFactory.getLogger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">override</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span></span>(cause: Throwable) = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ItemsServiceFeignClient { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String { log.error(<span class="hljs-string"><span class="hljs-string">"Cannot get item with id=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ItemsUiException(cause) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHystrixFallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { log.error(<span class="hljs-string"><span class="hljs-string">"This is expected error"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"{\"error\" : \"Some error\"}"</span></span> } } } }</code> </pre> </li><li>  Frijol <code>RestTemplate</code> <br>  Se crea un bin en la configuración de java: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@LoadBalanced</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = RestTemplate()</code> </pre> <br>  Y usado de esta manera: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestWithRestTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String = restTemplate.getForEntity(<span class="hljs-string"><span class="hljs-string">"http://items-service/items/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span>, String::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">body</span></span></span><span class="hljs-class"> ?: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">"No result"</span></span></span></span></code> </pre> </li><li>  <code>WebClient</code> class <code>WebClient</code> (método específico para el marco de WebFlux) <br>  Se crea un bin en la configuración de java: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">webClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loadBalancerClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LoadBalancerClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = WebClient.builder() .filter(LoadBalancerExchangeFilterFunction(loadBalancerClient)) .build()</code> </pre> <br>  Y usado de esta manera: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestWithWebClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Mono&lt;String&gt; = webClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().uri(<span class="hljs-string"><span class="hljs-string">"http://items-service/items/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span>).retrieve().bodyToMono(String::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre> </li></ol><br>  El hecho de que los tres métodos devuelvan el mismo resultado puede verificarse en <code>http://localhost:8081/example</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/c8/oz/mac8ozz07cju5mitffz_qiew9mc.png"></div><br>  Prefiero la opción usando OpenFeign, porque permite desarrollar un contrato para la interacción con el microservicio llamado, cuya implementación es realizada por Spring.  Se inyecta un objeto que implementa este contrato y se usa como un bean normal: <br><br><pre> <code class="kotlin hljs">itemsServiceFeignClient.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Si la solicitud falla por algún motivo, se llamará al método correspondiente de la clase que implementa la interfaz <code>FallbackFactory</code> , en el que debe procesar el error y devolver la respuesta predeterminada (o lanzar una excepción más).  En el caso de que falle un cierto número de llamadas consecutivas, el Fusible abrirá el circuito (más sobre el disyuntor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aquí</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aquí</a> ), dando tiempo para recuperar el microservicio caído. <br><br>  Para utilizar el cliente Feign, debe anotar la <code>@EnableFeignClients</code> aplicación <code>@EnableFeignClients</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableFeignClients(clients = [ItemsServiceFeignClient::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ItemsUiApplication</span></span></span></span></code> </pre> <br>  Para que el respaldo de Hystrix funcione en el cliente de Feign, debe agregar lo siguiente a la configuración de la aplicación: <br><br><pre> <code class="plaintext hljs">feign: hystrix: enabled: true</code> </pre> <br>  Para probar el funcionamiento de la recuperación de Hystrix en el cliente Feign, solo vaya a <code>http://localhost:8081/hystrix-fallback</code> .  El cliente de Feign intentará ejecutar la solicitud en una ruta que no existe en el servicio de Elementos, lo que conducirá a la devolución de la respuesta: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"error"</span></span> : <span class="hljs-string"><span class="hljs-string">"Some error"</span></span>}</code> </pre> <br><h1>  UI gateway </h1><br>  El patrón de puerta de enlace API le permite crear un único punto de entrada para la API proporcionada por otros microservicios (más detalles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aquí</a> ).  Una aplicación que implementa este patrón realiza el enrutamiento (enrutamiento) de solicitudes a microservicios y también puede realizar funciones adicionales, por ejemplo, autenticación. <br><br>  En este proyecto, para mayor claridad, se implementa una puerta de enlace de IU, es decir, un único punto de entrada para diferentes IU;  obviamente, la API de puerta de enlace se implementa de manera similar.  El microservicio se implementa sobre la base del marco Spring Cloud Gateway.  Una alternativa es Netflix Zuul, parte de Netflix OSS e integrado con Spring Boot usando Spring Cloud Netflix. <br>  La puerta de enlace de la IU se ejecuta en el puerto 443 con el certificado SSL generado (ubicado en el proyecto).  SSL y HTTPS se configuran de la siguiente manera: <br><br><pre> <code class="plaintext hljs">server: port: 443 ssl: key-store: classpath:keystore.p12 key-store-password: qwerty key-alias: test_key key-store-type: PKCS12</code> </pre> <br>  Los inicios de sesión y las contraseñas de los usuarios se almacenan en una implementación basada en el mapa de la interfaz <code>ReactiveUserDetailsService</code> basada en WebFlux: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reactiveUserDetailsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ReactiveUserDetailsService { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user = User.withDefaultPasswordEncoder() .username(<span class="hljs-string"><span class="hljs-string">"john_doe"</span></span>).password(<span class="hljs-string"><span class="hljs-string">"qwerty"</span></span>).roles(<span class="hljs-string"><span class="hljs-string">"USER"</span></span>) .build() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> admin = User.withDefaultPasswordEncoder() .username(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>).password(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>).roles(<span class="hljs-string"><span class="hljs-string">"ADMIN"</span></span>) .build() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MapReactiveUserDetailsService(user, admin) }</code> </pre> <br>  La configuración de seguridad se configura de la siguiente manera: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">springWebFilterChain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(http: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServerHttpSecurity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: SecurityWebFilterChain = http .formLogin().loginPage(<span class="hljs-string"><span class="hljs-string">"/login"</span></span>) .and() .authorizeExchange() .pathMatchers(<span class="hljs-string"><span class="hljs-string">"/login"</span></span>).permitAll() .pathMatchers(<span class="hljs-string"><span class="hljs-string">"/static/**"</span></span>).permitAll() .pathMatchers(<span class="hljs-string"><span class="hljs-string">"/favicon.ico"</span></span>).permitAll() .pathMatchers(<span class="hljs-string"><span class="hljs-string">"/webjars/**"</span></span>).permitAll() .pathMatchers(<span class="hljs-string"><span class="hljs-string">"/actuator/**"</span></span>).permitAll() .anyExchange().authenticated() .and() .csrf().disable() .build()</code> </pre> <br>  La configuración dada determina que parte de los recursos web (por ejemplo, estadísticas) está disponible para todos los usuarios, incluidos aquellos que no se han autenticado, y todo lo demás ( <code>.anyExchange()</code> ) solo está autenticado.  Si intenta ingresar una URL que requiere autenticación, será redirigida a la página de inicio de sesión ( <code>https://localhost/login</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vz/eu/yx/vzeuyxohx_kfb17mrg4llnv4n8q.png"></div><br>  Esta página utiliza las herramientas del marco Bootstrap, que está conectado al proyecto mediante Webjars, lo que permite administrar las bibliotecas del lado del cliente como dependencias regulares.  Thymeleaf se usa para formar páginas HTML.  El acceso a la página de inicio de sesión se configura mediante WebFlux: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = router { GET(<span class="hljs-string"><span class="hljs-string">"/login"</span></span>) { ServerResponse.ok().contentType(MediaType.TEXT_HTML).render(<span class="hljs-string"><span class="hljs-string">"login"</span></span>) } }</code> </pre> <br>  El enrutamiento de Spring Cloud Gateway se puede configurar en una configuración YAML o Java.  Las rutas a los microservicios se asignan manualmente o se crean automáticamente según los datos recibidos del registro del Servicio.  Con un número suficientemente grande de UI para las cuales se requiere enrutamiento, será más conveniente usar la integración con el registro del Servicio: <br><br><pre> <code class="plaintext hljs">spring: cloud: gateway: discovery: locator: enabled: true lower-case-service-id: true include-expression: serviceId.endsWith('-UI') url-expression: "'lb:http://'+serviceId"</code> </pre> <br>  El valor del parámetro <code>include-expression</code> indica que las rutas se crearán solo para microservicios cuyos nombres terminan en <i>-UI</i> , y el valor del parámetro <code>url-expression</code> es que son accesibles a través del protocolo HTTP, a diferencia de la puerta de enlace UI que funciona a través de HTTPS, y cuando se accede utilizarán el equilibrio de carga del cliente (implementado con Netflix Ribbon). <br><br>  Considere el ejemplo de crear rutas en la configuración de Java manualmente (sin integración con el registro del Servicio): <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routeLocator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RouteLocatorBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = builder.routes { route(<span class="hljs-string"><span class="hljs-string">"eureka-gui"</span></span>) { path(<span class="hljs-string"><span class="hljs-string">"/eureka"</span></span>) filters { rewritePath(<span class="hljs-string"><span class="hljs-string">"/eureka"</span></span>, <span class="hljs-string"><span class="hljs-string">"/"</span></span>) } uri(<span class="hljs-string"><span class="hljs-string">"lb:http://eureka-server"</span></span>) } route(<span class="hljs-string"><span class="hljs-string">"eureka-internals"</span></span>) { path(<span class="hljs-string"><span class="hljs-string">"/eureka/**"</span></span>) uri(<span class="hljs-string"><span class="hljs-string">"lb:http://eureka-server"</span></span>) } }</code> </pre> <br>  La primera ruta enruta a la página de inicio del servidor Eureka mostrada anteriormente ( <code>http://localhost:8761</code> ), la segunda es necesaria para cargar recursos en esta página. <br><br>  Todas las rutas creadas por la aplicación están disponibles en <code>https://localhost/actuator/gateway/routes</code> . <br><br>  En los microservicios subyacentes, puede ser necesario acceder al inicio de sesión y / o funciones del usuario autenticado en la puerta de enlace de la interfaz de usuario.  Para hacer esto, creé un filtro que agrega los encabezados apropiados a la solicitud: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddCredentialsGlobalFilter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GlobalFilter { private val loggedInUserHeader = "logged-in-user" private val loggedInUserRolesHeader = "logged-in-user-roles" override fun filter</span></span></span></span>(exchange: ServerWebExchange, chain: GatewayFilterChain) = exchange.getPrincipal&lt;Principal&gt;() .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> request = exchange.request.mutate() .header(loggedInUserHeader, it.name) .header(loggedInUserRolesHeader, (it <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Authentication).authorities?.joinToString(<span class="hljs-string"><span class="hljs-string">";"</span></span>) ?: <span class="hljs-string"><span class="hljs-string">""</span></span>) .build() chain.filter(exchange.mutate().request(request).build()) } }</code> </pre> <br>  Ahora pasemos a la interfaz de usuario de los elementos utilizando la puerta de enlace de la interfaz de usuario: <code>https://localhost/items-ui/greeting</code> , suponiendo correctamente que el procesamiento de estos encabezados ya se ha implementado en la interfaz de usuario de los elementos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/sl/_s/rcsl_sdjuf6vkxkite5h3rgzoui.png"></div><br>  Spring Cloud Sleuth es una solución para el seguimiento de consultas en un sistema distribuido.  El Id. De seguimiento (identificador de paso) y el Id de intervalo (identificador de unidad de trabajo) se agregan a los encabezados de la solicitud que pasa por varios microservicios (para facilitar la comprensión, simplifiqué el esquema; <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aquí hay una</a> explicación detallada) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sp/1q/em/sp1qem4a6silx9bo3kh83enn_mu.png"></div><br>  Esta funcionalidad se conecta simplemente agregando la <code>spring-cloud-starter-sleuth</code> . <br><br>  Una vez especificada la configuración de registro adecuada, en la consola de los microservicios correspondientes puede ver algo como lo siguiente (el Id. De seguimiento y el Id de intervalo se muestran después del nombre del microservicio): <br><br><pre> <code class="plaintext hljs">DEBUG [ui-gateway,009b085bfab5d0f2,009b085bfab5d0f2,false] oscghRoutePredicateHandlerMapping : Route matched: CompositeDiscoveryClient_ITEMS-UI DEBUG [items-ui,009b085bfab5d0f2,947bff0ce8d184f4,false] oswrfunction.server.RouterFunctions : Predicate "(GET &amp;&amp; /example)" matches against "GET /example" DEBUG [items-service,009b085bfab5d0f2,dd3fa674cd994b01,false] oswrfunction.server.RouterFunctions : Predicate "(GET &amp;&amp; /{id})" matches against "GET /1"</code> </pre> <br>  Para una representación gráfica del rastreo distribuido, puede usar, por ejemplo, Zipkin, que actuará como un servidor que agrega información sobre las solicitudes HTTP de otros microservicios (más detalles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aquí</a> ). <br><br><h1>  Asamblea </h1><br>  Dependiendo del sistema operativo, se <code>gradlew clean build</code> <code>./gradlew clean build</code> o <code>./gradlew clean build</code> . <br><br>  Dada la posibilidad de usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Gradle wrapper</a> , no hay necesidad de un Gradle instalado localmente. <br><br>  La compilación y el lanzamiento posterior pasan con éxito JDK 11.0.1.  Antes de esto, el proyecto funcionaba en JDK 10, por lo que supongo que en esta versión no habrá problemas con el ensamblaje y el lanzamiento.  No tengo datos sobre versiones anteriores de JDK.  Además, tenga en cuenta que el Gradle 5 utilizado requiere al menos JDK 8. <br><br><h1>  Lanzamiento </h1><br>  Recomiendo iniciar las aplicaciones en el orden en que se describen en este artículo.  Si está utilizando Intellij IDEA con Run Dashboard habilitado, debería obtener algo como lo siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7h/yb/t0/7hybt0ljfcfnrkckajkikwctj-g.png"></div><br><h1>  Conclusión </h1><br>  El artículo examinó un ejemplo de arquitectura de microservicios en la pila de tecnología actual en el mundo Java, sus componentes principales y algunas características.  Espero para alguien que el material sea útil.  Gracias por su atencion! <br><br><h1>  Referencias </h1><br><ul><li>  Código fuente del proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Artículos de microservicio de</a> Chris Richardson </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Un artículo sobre los microservicios de</a> Martin Fowler </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Guía de</a> microservicios Martin Fowler </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431474/">https://habr.com/ru/post/es431474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431460/index.html">"Calendario de prueba" para noviembre. Prueba de par razonable</a></li>
<li><a href="../es431462/index.html">Cómo hicimos un escáner de libros para barcos</a></li>
<li><a href="../es431466/index.html">Cómo dejar de luchar por la excelencia y alcanzar la máxima productividad</a></li>
<li><a href="../es431468/index.html">Una implementación práctica del generador de conmutación utilizando Verilog HDL</a></li>
<li><a href="../es431470/index.html">Esto puedes (computadora). Una historia sobre un programa de televisión olvidado</a></li>
<li><a href="../es431478/index.html">Conferencia de Roskomnadzor "Protección de datos personales"</a></li>
<li><a href="../es431480/index.html">Magento lanzó una nueva versión de plataforma importante - 2.3.0 GA</a></li>
<li><a href="../es431482/index.html">Y tú, Yota ...</a></li>
<li><a href="../es431486/index.html">Moscas invisibles: un nuevo método para estudiar el sistema nervioso a través de la despigmentación de tejidos</a></li>
<li><a href="../es431488/index.html">Modulación de sonido</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>