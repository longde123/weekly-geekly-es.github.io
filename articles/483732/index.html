<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèñÔ∏è üë§ üë©üèæ‚Äçü§ù‚Äçüë©üèº Lea el firmware seguro del flash STM32F1xx usando ChipWhisperer üë®üèº‚Äç‚úàÔ∏è üë®‚Äçüöí üö∂üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el art√≠culo anterior , tratamos los ataques de falla Vcc usando ChipWhisperer. Nuestro objetivo adicional fue un estudio por fases del proceso de l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lea el firmware seguro del flash STM32F1xx usando ChipWhisperer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/483732/"><img src="https://habrastorage.org/webt/8h/fe/kf/8hfekfa930idilbg4asymru0cbm.png"><br><p>  En el <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">art√≠culo</a> anterior <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">,</a> tratamos los ataques de falla Vcc usando ChipWhisperer.  Nuestro objetivo adicional fue un estudio por fases del proceso de lectura de microcontroladores de firmware protegidos.  Usando tales ataques, un atacante puede obtener acceso a todas las contrase√±as de dispositivos y algoritmos de software.  Un ejemplo v√≠vido es el <a href="https://www.youtube.com/watch%3Flist%3DPLhixgUqwRTjyLgF4x-ZLVFL-CRTCrUo03%255E_%255Eamp%255E_%255Etime_continue%3D3%255E_%255Eamp%255E_%255Ev%3DnNBktKw9Is4">pirateo de la</a> billetera criptogr√°fica de hardware Ledger Nano S con la placa MK STM32F042 usando ataques de falla Vcc. </p><br><p>  Interesante?  Miremos debajo del gato. </p><a name="habracut"></a><br><p>  Aprendimos sobre la posibilidad de leer el firmware protegido de un <a href="https://pdfs.semanticscholar.org/4c01/a7514deacc2c02d010bb14c4fb58d1712adc.pdf">art√≠culo</a> que muestra los resultados de un ataque de falla de Vcc, evitando el byte de protecci√≥n RDP a trav√©s de un gestor de arranque para varios microcontroladores (en adelante, MK).  Tambi√©n recomendamos leer el <a href="https://limitedresults.com/2019/11/pwn-the-esp32-forever-flash-encryption-and-sec-boot-keys-extraction/">art√≠culo</a> sobre c√≥mo romper el ESP32. </p><br><p>  La base te√≥rica del estudio fue la <a href="https://wiki.newae.com/Tutorial_A9_Bypassing_LPC1114_Read_Protect">gu√≠a para</a> leer con √©xito el firmware protegido para LPC1114 a trav√©s de un gestor de arranque enmascarado que utiliza ChipWhisperer. </p><br><p>  Como en el primer art√≠culo, decidimos realizar experimentos en la placa MK STM32F103RBT6: </p><br><img src="https://habrastorage.org/webt/nc/ul/rw/nculrwzmxjlbwnjkwqzs9wlpq3e.png"><br><p>  <em>Junta STM32F103RBT6</em> </p><br><p>  La capacidad de escribir datos en los sectores de memoria flash y RAM o leerlos, as√≠ como realizar otras acciones con la memoria MK est√° determinada por el valor del byte de protecci√≥n (para STM32 - RDP).  Para diferentes MK, los valores y el prop√≥sito de los bytes de protecci√≥n, as√≠ como el algoritmo para verificarlos, son diferentes. </p><br><p>  <strong>Configuraci√≥n de hardware</strong> </p><br><p>  Comencemos el experimento.  Primero debe conectar ChipWhisperer a MK de acuerdo con la figura: </p><br><img src="https://habrastorage.org/webt/cw/fs/8s/cwfs8sdseto5gdlv8bcedgk9wzg.png"><br><p>  <em>Diagrama de conexi√≥n de ChipWhisperer a STM32 para leer firmware protegido a trav√©s de un cargador de m√°scaras</em> </p><br><p>  Los elementos que se deben quitar de la placa STM32F103RBT6 se tachan en el diagrama (en contraste con la conexi√≥n MK est√°ndar).  Las flechas indican los puntos de conexi√≥n de ChipWhisperer, y las firmas indican sus pines. </p><br><p>  La presencia de cuarzo externo, que se muestra en el diagrama, no es necesaria, porque cuando se trabaja con un cargador de m√°scaras, el MK STM32F103RBT6 usa un RELOJ interno con una frecuencia de 24 MHz, por lo que no hay sincronizaci√≥n entre ChipWhisperer y MK. </p><br><p>  Pasemos a configurar ChipWhisperer.  Como se se√±al√≥ anteriormente, la frecuencia recomendada de ChipWhisperer es de 24 MHz (u otro m√∫ltiplo).  Cuanto mayor sea la multiplicidad de esta frecuencia, m√°s exactamente podr√° ajustar el momento del ataque.  Debido a la falta de sincronizaci√≥n, la selecci√≥n del par√°metro scope.glitch.offset es opcional; se le puede asignar cualquier valor. </p><br><p>  Los par√°metros scope.glitch.repeat y scope.glitch.width deben seleccionarse seg√∫n la frecuencia establecida de ChipWhisperer.  Con un valor de frecuencia grande, todos los pulsos a corto plazo, cuyo n√∫mero se establece usando scope.glitch.repeat, se fusionan en un pulso largo.  Por lo tanto, puede seleccionar el valor del par√°metro scope.glitch.width y scope.glitch.repeat fix, o viceversa.  Encontramos que la duraci√≥n √≥ptima del pulso debe ser de aproximadamente 80 ns (definida como el ancho del pulso a la mitad del m√°ximo). </p><br><p>  Queda por seleccionar el valor del par√°metro scope.glitch.ext_offset. </p><br><p>  <strong>Selecci√≥n scope.glitch.ext_offset</strong> </p><br><p>  Primero debes elegir el momento del ataque.  Seg√∫n el esquema presentado en el <a href="https://www.st.com/content/ccc/resource/technical/document/application_note/51/5f/03/1e/bd/9b/45/be/CD00264342.pdf/files/CD00264342.pdf/jcr:content/translations/en.CD00264342.pdf">documento de</a> la empresa STM, el valor del byte de protecci√≥n se verifica despu√©s de recibir una solicitud para leer datos del sector flash: </p><br><img src="https://habrastorage.org/webt/m7/b-/ja/m7b-jat7np90pioveykbe8giw6y.jpeg"><br><p>  <em>El algoritmo para responder a una solicitud de lectura de datos del sector flash</em> </p><br><p>  Para verificar la validez de dicho esquema de verificaci√≥n, leemos el c√≥digo ejecutable del cargador de arranque de un MK similar sin protecci√≥n RDP a trav√©s de ST-Link.  Las siguientes figuras muestran partes del algoritmo de procesamiento del <strong>comando Leer memoria</strong> . </p><br><img src="https://habrastorage.org/webt/tf/1k/uf/tf1kufh_t31hbeol-vhdxzooqba.png"><br><p>  <em>Vista general del procesamiento de un comando de lectura de memoria (la llamada a la funci√≥n de verificaci√≥n RDP y el env√≠o de NACK en caso de una verificaci√≥n fallida son claramente visibles)</em> </p><br><img src="https://habrastorage.org/webt/as/vk/3h/asvk3h81acmw7vjx75he0tcimga.jpeg"><br><p>  <em>Cuerpo de la funci√≥n de validaci√≥n de RDP</em> </p><br><p> Prestemos atenci√≥n al cuerpo de la funci√≥n de verificaci√≥n RDP: se puede ver que el registro se lee a <code>0x40022000 + 0x1C</code> , un cambio l√≥gico de 30 bits y ramificaci√≥n.  De la documentaci√≥n del <a href="https://www.st.com/content/ccc/resource/technical/document/programming_manual/10/98/e8/d4/2b/51/4b/f5/CD00283419.pdf/files/CD00283419.pdf/jcr:content/translations/en.CD00283419.pdf">manual de programaci√≥n PM0075 (microcontroladores de memoria flash STM32F10xxx)</a> , queda claro que <code>0x40022000</code> es la direcci√≥n base del controlador de memoria flash, y <code>0x1C</code> es el <strong>desplazamiento del</strong> registro <strong>FLASH_OBR</strong> , en el que estamos interesados ‚Äã‚Äãen el segundo bit <strong>RDPRT</strong> : Protecci√≥n contra lectura, que contiene el estado de protecci√≥n RDP. </p><br><p>  El momento necesario del ataque es el desarrollo de la instrucci√≥n <code>LDR</code> (carga desde la memoria).  Esta instrucci√≥n se encuentra entre la solicitud para leer el firmware (enviando un byte <code>0x11</code> con una <code>0xEE</code> ) y la respuesta <code>ACK</code> / <code>NOACK</code> MK de UART.  Para arreglar visualmente este momento, es necesario conectar el osciloscopio a UART1_RX (pin PA10) y UART1_TX (pin PA9), y luego monitorear el cambio de voltaje de acuerdo con UART1.  Como resultado, la forma de onda de ataque de potencia con el valor de scope.glitch.ext_offset seleccionado deber√≠a verse as√≠: </p><br><img src="https://habrastorage.org/webt/fz/dm/j5/fzdmj5iyu5zfmcvmbqx0hf2mqms.jpeg"><br><p>  <em>Elegir el momento del ataque</em> </p><br><p>  <strong>Script de lectura de firmware</strong> </p><br><p>  Ahora debe especificar el momento del disparador CW_TRIG en el c√≥digo Python para interceptar el momento de transmitir la suma de verificaci√≥n a trav√©s de UART1_RX.  ChipWhisperer tiene una biblioteca para comunicarse con el cargador de m√°scaras STM32 MK.  En modo normal, esta biblioteca se utiliza para descargar firmware de los manuales al MK utilizando la clase de <code>class STM32FSerial(object)</code> ubicada en el archivo <code>programmer_stm32fserial.py</code> largo de la ruta <code>software/chipwhisperer/hardware/naeusb/</code> .  Para activar el desencadenador, debe copiar esta clase en el script ejecutable principal para que el m√©todo de clase <code>CmdGeneric(self, cmd)</code> sea ‚Äã‚Äãaccesible globalmente, y agregar el <code>scope.arm()</code> antes de enviar la suma de comprobaci√≥n (0xEE) de la solicitud para leer el sector de memoria.  La clase final se da en el spoiler a continuaci√≥n. </p><br><div class="spoiler">  <b class="spoiler_title">Clase para comunicar ChipWhisperer con STM32</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.common.utils <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> util <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.hardware.naeusb.programmer_stm32fserial <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> supported_stm32f <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.capture.api.programmers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Programmer <span class="hljs-comment"><span class="hljs-comment"># class which can normally using internal CW library for reading STM32 firmware by UART class STM32Reader(Programmer): def __init__(self): super(STM32Reader, self).__init__() self.supported_chips = supported_stm32f self.slow_speed = False self.small_blocks = True self.stm = None def stm32prog(self): if self.stm is None: stm = self.scope.scopetype.dev.serialstm32f else: stm = self.stm stm.slow_speed = self.slow_speed stm.small_blocks = self.small_blocks return stm def stm32open(self): stm32f = self.stm32prog() stm32f.open_port() def stm32find(self): stm32f = self.stm32prog() stm32f.scope = self.scope sig, chip = stm32f.find() def stm32readMem(self, addr, lng): stm32f = self.stm32prog() stm32f.scope = self.scope #answer = stm32f.readMemory(addr, lng) answer = self.ReadMemory(addr, lng) return answer def stm32GetID(self): stm32f = self.stm32prog() stm32f.scope = self.scope answer = stm32f.cmdGetID() return answer # Needed for connection to STM after reload by reset_target(scope) method def FindSTM(self): #setup serial port (or CW-serial port?) stm32f = self.stm32prog() try: stm32f.initChip() except IOError: print("Failed to detect chip. Check following: ") print(" 1. Connections and device power. ") print(" 2. Device has valid clock (or remove clock entirely for internal osc).") print(" 3. On Rev -02 CW308T-STM32Fx boards, BOOT0 is routed to PDIC.") raise boot_version = stm32f.cmdGet() chip_id = stm32f.cmdGetID() for t in supported_stm32f: if chip_id == t.signature: # print("Detected known STMF32: %s" % t.name) stm32f.setChip(t) return chip_id, t # print("Detected unknown STM32F ID: 0x%03x" % chip_id) return chip_id, None</span></span></code> </pre> </div></div><br><p>  Cabe se√±alar que el cargador de m√°scara STM32F1xx le permite leer no m√°s de 256 bytes de firmware de un sector flash especificado en una sola solicitud.  Por lo tanto, cuando se lee todo el firmware del MK, es necesario realizar varias solicitudes de lectura durante el ataque Vcc-glitch.  Luego, los 256 bytes recibidos deber√≠an dividirse en ocho matrices de 32 bytes y formar un archivo HEX a partir de ellos. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo convertidor HEX y funciones auxiliares</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int2str_0xFF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int_number, number_of_bytes)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{0:0{1}X}'</span></span>.format(int_number,number_of_bytes_in_string) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data_dividing_from_256_to_32_bytes</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_to_divide, mem_sector, mem_step=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mem_sector &gt; <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>: mem_conversion = mem_sector &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span> mem_conversion = mem_sector - (mem_conversion &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) data_out = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(int(<span class="hljs-number"><span class="hljs-number">256</span></span>/mem_step)): data_vector = data_to_divide[(i * mem_step):((i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * mem_step)] mem_calc = mem_conversion + (i * mem_step) data_out += read_and_convert_data_hex_file(data_vector, mem_calc, mem_step) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_out <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_and_convert_data_hex_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_to_convert, memory_address, mem_step)</span></span></span><span class="hljs-function">:</span></span> addr_string = memory_address -((memory_address &gt;&gt; <span class="hljs-number"><span class="hljs-number">20</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) data_buffer = <span class="hljs-string"><span class="hljs-string">''</span></span> crcacc = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(data_to_convert)): data_buffer += int2str_0xFF(data_to_convert[x], <span class="hljs-number"><span class="hljs-number">2</span></span>) crcacc += data_to_convert[x] crcacc += mem_step temp_addr_string = addr_string <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>): crcacc += temp_addr_string &gt;&gt; i*<span class="hljs-number"><span class="hljs-number">4</span></span> temp_addr_string -= ((temp_addr_string &gt;&gt; i*<span class="hljs-number"><span class="hljs-number">4</span></span>) &lt;&lt; i*<span class="hljs-number"><span class="hljs-number">4</span></span>) crcacc_2nd_symbol = (crcacc &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> crcacc = (crcacc_2nd_symbol &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) - crcacc <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> crcacc == <span class="hljs-number"><span class="hljs-number">0x100</span></span>: crcacc = <span class="hljs-number"><span class="hljs-number">0</span></span> RECTYP = <span class="hljs-number"><span class="hljs-number">0x00</span></span> out_string = <span class="hljs-string"><span class="hljs-string">':'</span></span>+ Int_To_Hex_String(mem_step, <span class="hljs-number"><span class="hljs-number">2</span></span>) +\ Int_To_Hex_String((addr_string),<span class="hljs-number"><span class="hljs-number">4</span></span>) +\ Int_To_Hex_String(RECTYP, <span class="hljs-number"><span class="hljs-number">2</span></span>) +\ data_buffer +\ Int_To_Hex_String(crcacc, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out_string <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_to_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(info_to_output, File_name, directory)</span></span></span><span class="hljs-function">:</span></span> file = open(directory + File_name + <span class="hljs-string"><span class="hljs-string">'.hex'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) file.write(info_to_output) file.close() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset_target</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope)</span></span></span><span class="hljs-function">:</span></span> scope.io.nrst = <span class="hljs-string"><span class="hljs-string">'low'</span></span> time.sleep(<span class="hljs-number"><span class="hljs-number">0.05</span></span>) scope.io.nrst = <span class="hljs-string"><span class="hljs-string">'high'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple Range = namedtuple(<span class="hljs-string"><span class="hljs-string">'Range'</span></span>, [<span class="hljs-string"><span class="hljs-string">'min'</span></span>, <span class="hljs-string"><span class="hljs-string">'max'</span></span>, <span class="hljs-string"><span class="hljs-string">'step'</span></span>])</code> </pre></div></div><br><p>  La configuraci√≥n de ChipWhisperer ahora est√° completa.  El gui√≥n final para leer el firmware es el siguiente: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># string of start HEX file Start_of_File_Record = ':020000040800F2' # string of end HEX file End_of_File_Record = ':00000001FF' length_of_sector = 256 if length_of_sector % 4 != 0: sys.exit('length_of_sector must be equal to 4') output_to_file_buffer = '' output_to_file_buffer += Start_of_File_Record + '\n' mem_current = mem_start while mem_current &lt; mem_stop: # flush the garbage from the computer's target read buffer target.ser.flush() # run aux stuff that should run before the scope arms here reset_target(scope) # initialize STM32 after each reset prog.FindSTM() try: # reading of closed memory sector data = prog.stm32readMem(mem_current, length_of_sector) except Exception as message: message = str(message) if "Can't read port" in message: # print('Port silence') pass elif 'Unknown response. 0x11: 0x0' in message: # print('Crashed. Reload!') pass elif 'NACK 0x11' in message: # print('Firmware is closed!') pass else: # print('Unknown error:', message, scope.glitch.offset, scope.glitch.width, scope.glitch.ext_offset) pass else: data_to_out = data_dividing_from_256_to_32_bytes (data, mem_current) print(data_to_out) output_to_file_buffer += data_to_out mem_current += length_of_sector output_to_file_buffer += End_of_File_Record + '\n' send_to_file(output_to_file_buffer, File_name, directory)</span></span></code> </pre> <br><p>  Todos comentaron los mensajes <code>print()</code> despu√©s de la l√≠nea, <code>except Exception as</code> ayudan a monitorear el estado del MC al buscar los par√°metros √≥ptimos para el pulso de falla.  Para rastrear el estado espec√≠fico de MK, es suficiente descomentar el mensaje <code>print()</code> necesario. </p><br><p>  <strong>Resultados de lectura</strong> </p><br><p>  El video muestra la descarga del firmware al MK a trav√©s del programador ST-LINK, transfiriendo RDP al estado de protecci√≥n y luego leyendo el firmware: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CRfg9-1BV0k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Los siguientes errores pueden prevenir ataques exitosos de falla Vcc: </p><br><p>  ‚Ä¢ leer el sector incorrecto de la memoria; </p><br><p>  ‚Ä¢ eliminaci√≥n espont√°nea de firmware. </p><br><p>  La selecci√≥n precisa del momento del ataque al aumentar la frecuencia de ChipWhisperer ayudar√° a evitar tales errores. </p><br><p>  Despu√©s de desarrollar y depurar el algoritmo para leer el firmware protegido, realizamos una lectura de prueba del firmware del programador ST-LINK-V2.1, que funciona en el STM32F103CBT6 MK.  Unos pocos firmware, cosimos un MK STM32F103CBT6 "limpio" y lo instalamos en lugar del de f√°brica.  Como resultado, ST-LINK-V2.1 con el MK reemplazado funcion√≥ en modo normal, como si no hubiera sustituci√≥n. </p><br><p>  Tambi√©n intentamos realizar una serie de ataques contra STM32F303RCT7.  Este MK durante el ataque se comport√≥ de manera id√©ntica a STM32F103RBT6, pero la respuesta a la solicitud de memoria de lectura conten√≠a un byte igual a 0x00, que no coincid√≠a con el resultado que esper√°bamos.  La raz√≥n de este fracaso fue un principio m√°s complejo y desarrollado de organizar la protecci√≥n de estos MK. </p><br><p>  Hay dos estados de protecci√≥n en el STM32F1xx MK: la protecci√≥n est√° desactivada (Nivel 0) y activada (Nivel 1).  En modelos anteriores, hay tres estados de protecci√≥n: la protecci√≥n est√° deshabilitada (Nivel 0, RDP = 0x55AA), protecci√≥n de memoria flash y SRAM (Nivel 2, RDP = 0x33CC) y protecci√≥n de memoria flash solamente (Nivel 1, RDP toma cualquier valor que no sea de 0x55AA y 0x33CC).  Dado que el Nivel 1 puede tomar muchos valores RDP, establecer el Nivel 0 es bastante dif√≠cil.  Por otro lado, es posible reducir el nivel de protecci√≥n del Nivel 2 al Nivel 1 al derribar un bit en el byte RDP (que se muestra en la figura a continuaci√≥n), lo que permite el acceso a la memoria SRAM. </p><br><img src="https://habrastorage.org/webt/dj/by/ef/djbyefc1yji_gpevygy72yzvtjm.jpeg"><br><p>  <em>Comparaci√≥n de valores RDP para diferentes niveles de protecci√≥n de firmware</em> </p><br><p>  Solo queda entender c√≥mo un atacante puede aprovechar esto.  Por ejemplo, usando el m√©todo CBS (Cold-Boot Stepping) descrito en <a href="https://www.usenix.org/system/files/conference/woot17/woot17-paper-obermaier.pdf">este art√≠culo</a> .  Este m√©todo se basa en una instant√°nea escalonada del estado de la memoria SRAM (la frecuencia de cada instant√°nea estaba en el microsegundo) despu√©s de cargar el MC para obtener claves de cifrado, contrase√±as ocultas o cualquier otra informaci√≥n valiosa.  Los autores sugieren que el m√©todo CBS funcionar√° en todas las series STM32 MK. </p><br><p>  <strong>Conclusiones</strong> </p><br><p>  Para resumir nuestros experimentos.  Nos llev√≥ varios d√≠as completar un ataque de falla de Vcc utilizando los datos obtenidos de un estudio anterior (que se puede leer <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">aqu√≠</a> ).  Entonces, aprender a llevar a cabo tales ataques es bastante f√°cil. </p><br><p>  Los ataques de falla de Vcc son peligrosos porque son dif√≠ciles de defender.  Para reducir la probabilidad de realizar con √©xito tales ataques, se propone utilizar MK con un mayor nivel de protecci√≥n. </p><br><p> <a href="https://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p>  Raccoon Security es un equipo especial de expertos de STC Vulcan en el campo de la seguridad pr√°ctica de la informaci√≥n, criptograf√≠a, circuitos, ingenier√≠a inversa y desarrollo de software de bajo nivel. </p><br></div></div><p>Source: <a href="https://habr.com/ru/post/483732/">https://habr.com/ru/post/483732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483720/index.html">Lo que nos trajo Pandas 1.0</a></li>
<li><a href="../483722/index.html">Geoanal√≠tica en el comercio minorista, parte 1: automatizamos el proceso de elegir un lugar para un negocio. 2GIS + MS Azure + ML</a></li>
<li><a href="../483724/index.html">Trabaja con llantas personalizadas complejas Redd</a></li>
<li><a href="../483726/index.html">Vanilla JavaScript y HTML. Sin marcos. No hay bibliotecas No hay problema</a></li>
<li><a href="../483730/index.html">Programmers Union 2: Slippers dej√≥ de re√≠r y se puso pensativo</a></li>
<li><a href="../483734/index.html">¬øQu√© precio pagamos por usar async / await en JS / C # / Rust?</a></li>
<li><a href="../483736/index.html">B√∫squeda inversa de im√°genes: una gu√≠a de la agencia de detectives Bellingcat</a></li>
<li><a href="../483742/index.html">Busca errores como una forma de vida</a></li>
<li><a href="../483744/index.html">Venta de a√±o nuevo antiguo</a></li>
<li><a href="../483746/index.html">Estaci√≥n de puerta de enlace: paso a la l√≠nea lunar, acceso a la estaci√≥n marciana</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>