<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìú ‚è≥ üîê Estructuras vs. Clases üâë üë©‚Äçüç≥ üßëüèæ‚Äçü§ù‚Äçüßëüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde el principio, cuando comenc√© a programar, surgi√≥ la pregunta de qu√© usar para mejorar el rendimiento: estructura o clase; qu√© matrices son mejor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estructuras vs. Clases</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472290/">  Desde el principio, cuando comenc√© a programar, surgi√≥ la pregunta de qu√© usar para mejorar el rendimiento: estructura o clase;  qu√© matrices son mejores para usar y c√≥mo.  En cuanto a las estructuras, Apple agradece su uso, explicando que son mejores en la optimizaci√≥n, y toda la esencia del lenguaje Swift son las estructuras.  Pero hay quienes no est√°n de acuerdo con esto, porque puedes simplificar maravillosamente el c√≥digo heredando una clase de otra y trabajando con esa clase.  Para acelerar el trabajo con las clases, creamos diferentes modificadores y objetos que fueron optimizados espec√≠ficamente para las clases, y ya es dif√≠cil decir qu√© ser√° m√°s r√°pido y en qu√© caso. <br><br>  Para organizar todos los puntos en la "e", escrib√≠ varias pruebas que utilizan los enfoques habituales para el procesamiento de datos: pasar a un m√©todo, copiar, trabajar con matrices, etc.  Decid√≠ no sacar grandes conclusiones, todos decidir√°n por s√≠ mismos si vale la pena creer en las pruebas, podr√°n descargar el proyecto y ver√°n c√≥mo funcionar√° para usted, y tratar√°n de optimizar el funcionamiento de una prueba en particular.  Quiz√°s incluso saldr√°n nuevos chips que no mencion√©, o se usan tan raramente que simplemente no he o√≠do hablar de ellos. <br><a name="habracut"></a><br>  PD: comenc√© a trabajar en un art√≠culo sobre Xcode 10.3 y pens√© en tratar de comparar su velocidad con Xcode 11, pero a√∫n as√≠ el art√≠culo no se trata de comparar dos aplicaciones, sino de la velocidad de nuestras aplicaciones.  No tengo dudas de que el tiempo de ejecuci√≥n de las funciones disminuir√°, y lo que ha sido mal optimizado se volver√° m√°s r√°pido.  Como resultado, esper√© el nuevo Swift 5.1 y decid√≠ probar las hip√≥tesis en la pr√°ctica.  Que tengas una buena lectura. <br><br><h4>  Prueba 1: Comparar matrices en estructuras y clases </h4><br>  Supongamos que tenemos una clase y queremos colocar los objetos de esta clase en una matriz, la acci√≥n habitual en una matriz es recorrerla. <br><br>  En una matriz, cuando se usan clases en √©l y se trata de recorrerlo, el n√∫mero de enlaces aumenta, una vez completado, el n√∫mero de enlaces al objeto disminuir√°. <br><br>  Si pasamos por la estructura, en el momento en que el objeto es llamado por √≠ndice, se crear√° una copia del objeto, mirando la misma √°rea de memoria, pero marcada como inmutable.  Es dif√≠cil decir qu√© es m√°s r√°pido: aumentar el n√∫mero de enlaces a un objeto o crear un enlace a un √°rea en la memoria con la falta de la capacidad de cambiarlo.  Vamos a verlo en la pr√°ctica: <br><br><img src="https://habrastorage.org/webt/me/i5/2g/mei52ghwjxv_pg3c1toaoqachty.png"><br>  <i>Fig.</i>  <i>1: Comparaci√≥n de obtener una variable de matrices basadas en estructuras y clases</i> <br><br><h4>  Prueba 2. Comparar ContiguousArray versus Array </h4><br>  Lo que es m√°s interesante es comparar el rendimiento de una matriz (Array) con una matriz de referencia (ContiguousArray), que es necesaria espec√≠ficamente para trabajar con clases almacenadas en la matriz. <br><br>  Verifiquemos el rendimiento para los siguientes casos: <br><br>  Matriz contigua que almacena una estructura con tipo de valor <br>  Estructura de almacenamiento de matriz contigua con String <br>  Clase de almacenamiento ContiguousArray con tipo de valor <br>  Clase de almacenamiento ContiguousArray con String <br>  Estructura de almacenamiento de matriz con tipo de valor <br>  Estructura de almacenamiento de matriz con String <br>  Clase de almacenamiento de matriz con tipo de valor <br>  Clase de almacenamiento de matriz con String <br><br>  Dado que los resultados de la prueba (pruebas: pasar a una funci√≥n con la optimizaci√≥n en l√≠nea desactivada, pasar a una funci√≥n con la optimizaci√≥n en l√≠nea activada, eliminar elementos, agregar elementos, acceso secuencial a un elemento en un bucle) incluir√° una gran cantidad de pruebas (para 8 matrices de 5 pruebas cada una) , Dar√© los resultados m√°s significativos: <br><br><ol><li>  Si llama a una funci√≥n y le pasa una matriz, apagando en l√≠nea, entonces dicha llamada ser√° muy costosa (para las clases basadas en la Cadena de referencia, es 20,000 veces m√°s lenta, para las clases basadas en Valor, el tipo es 60,000 veces peor con el optimizador en l√≠nea apagado) . </li><li>  Si la optimizaci√≥n (en l√≠nea) funciona para usted, entonces se debe esperar la degradaci√≥n solo 2 veces, dependiendo de qu√© tipo de datos se agregue a qu√© matriz.  La √∫nica excepci√≥n fue el tipo de valor, envuelto en una estructura que se encuentra en la matriz contigua, sin degradaci√≥n del tiempo. </li><li>  Eliminaci√≥n: la extensi√≥n entre la matriz de referencia y la habitual era de aproximadamente el 20% (a favor de la matriz habitual). </li><li>  Anexar: al usar objetos envueltos en clases, ContiguousArray ten√≠a una velocidad aproximadamente un 20% m√°s r√°pida que Array con los mismos objetos, mientras que Array era m√°s r√°pido al trabajar con estructuras que ContiguousArray con estructuras. </li><li>  El acceso a los elementos de la matriz cuando se usan contenedores de estructuras result√≥ ser m√°s r√°pido que cualquier contenedor en las clases, incluido ContiguousArray (aproximadamente 500 veces m√°s r√°pido). </li></ol><br>  En la mayor√≠a de los casos, usar matrices regulares para trabajar con objetos es m√°s eficiente.  Utilizado antes, utilizamos m√°s. <br><br>  La optimizaci√≥n de bucle para matrices es servida por el inicializador de colecci√≥n diferida, que le permite recorrer toda la matriz solo una vez, incluso si usa varios filtros o mapas sobre los elementos de la matriz. <br><br>  Al utilizar las estructuras como una herramienta de optimizaci√≥n, existen dificultades, como el uso de tipos a los que se hace referencia internamente en la naturaleza: cadenas, diccionarios, matrices de referencia.  Luego, cuando una variable que almacena un tipo de referencia en s√≠ mismo se ingresa a una funci√≥n, se crea una referencia adicional para cada elemento que es una clase.  Esto tiene otro lado, un poco m√°s al respecto.  Podr√≠a intentar usar una clase contenedora sobre una variable.  Entonces, el n√∫mero de enlaces al pasar a la funci√≥n aumentar√° solo para ella, y el n√∫mero de enlaces a los valores dentro de la estructura seguir√° siendo el mismo.  En general, quiero ver cu√°ntas variables de un tipo de referencia deben estar en la estructura para que su rendimiento disminuya por debajo del rendimiento de las clases con los mismos par√°metros.  Hay un art√≠culo en la web llamado "¬°Deja de usar estructuras!" Que hace la misma pregunta y la responde.  Descargu√© el proyecto y decid√≠ averiguar qu√© sucede d√≥nde y en qu√© casos obtenemos estructuras lentas.  El autor muestra el bajo rendimiento de las estructuras en comparaci√≥n con las clases, argumentando que crear un nuevo objeto es mucho m√°s lento que aumentar la referencia al objeto es absurdo (por lo que siempre elimin√© la l√≠nea donde se crea un nuevo objeto en el bucle).  Pero si no creamos un enlace al objeto, sino que simplemente lo pasamos a una funci√≥n para trabajar con √©l, entonces la diferencia en el rendimiento ser√° muy insignificante.  Cada vez que ponemos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">l√≠nea</a> (nunca) en una funci√≥n, nuestra aplicaci√≥n debe ejecutarla y no crear c√≥digo en una cadena.  A juzgar por las pruebas, Apple logr√≥ que el objeto pasado a la funci√≥n se modificara ligeramente, para las estructuras el compilador cambia la mutabilidad y hace que el acceso a las propiedades no mutables del objeto sea lento.  Algo similar sucede en la clase, pero al mismo tiempo aumenta el n√∫mero de referencias al objeto.  Y ahora tenemos un objeto perezoso, todos sus campos tambi√©n son perezosos, y cada vez que llamamos a una variable de objeto, la inicializa.  En esto, las estructuras no tienen igual: cuando una funci√≥n llama a dos variables, la estructura del objeto es solo ligeramente inferior a la clase en velocidad;  cuando llamas a tres o m√°s, la estructura siempre ser√° m√°s r√°pida. <br><br><h4>  Prueba 3: compare el rendimiento de estructuras y clases que almacenan clases grandes </h4><br>  Tambi√©n cambi√© ligeramente el m√©todo en s√≠, que se llam√≥ cuando se agreg√≥ otra variable (de esta manera, se inicializaron tres variables en el m√©todo, y no dos, como en el art√≠culo), y para que no haya un desbordamiento Int, reemplac√© las operaciones en las variables con la suma y la resta.  Se agregaron m√©tricas de tiempo m√°s claras (en la captura de pantalla son segundos, pero no es tan importante para nosotros, entender las proporciones resultantes es importante), eliminar el marco Darwin (no lo uso en proyectos, tal vez en vano, no hay diferencias en las pruebas antes / despu√©s de agregar el marco en mi prueba), la inclusi√≥n de la m√°xima optimizaci√≥n y compilaci√≥n en la compilaci√≥n de lanzamiento (parece que esto ser√° m√°s honesto), y aqu√≠ est√° el resultado: <br><br><img src="https://habrastorage.org/webt/zv/q_/en/zvq_ens-bwgnuetcl53shkecjd0.png"><br>  <i>Fig.</i>  <i>2: Rendimiento de estructuras y clases del art√≠culo "Dejar de usar estructuras"</i> <br><br>  Las diferencias en los resultados de la prueba son insignificantes. <br><br><h4>  Prueba 4: Funci√≥n que acepta gen√©rico, protocolo y funci√≥n sin gen√©rico </h4><br>  Si tomamos una funci√≥n gen√©rica y pasamos dos valores all√≠, unidos solo por la capacidad de comparar estos valores (func min), entonces el c√≥digo de tres l√≠neas se convertir√° en un c√≥digo de ocho (como dice Apple).  Pero esto no siempre sucede, Xcode tiene m√©todos de optimizaci√≥n en los que si ve que se le pasan dos valores estructurales cuando llama a la funci√≥n, genera autom√°ticamente una funci√≥n que toma dos estructuras y ya no copia los valores. <br><br><img src="https://habrastorage.org/webt/zo/fd/2v/zofd2v5qz7q3dkhzdcp_srpspyg.png"><br>  <i>Fig.</i>  <i>3: Funci√≥n gen√©rica t√≠pica</i> <br><br>  Decid√≠ probar dos funciones: en la primera, se declara el tipo de datos Gen√©rico, la segunda acepta solo el Protocolo.  En la nueva versi√≥n del protocolo Swift 5.1, es incluso un poco m√°s r√°pido que el gen√©rico (antes de Swift 5.1 los protocolos eran 2 veces m√°s lentos), aunque seg√∫n Apple deber√≠a ser al rev√©s, pero cuando se trata de pasar por una matriz, ya tenemos que escribir, lo que se ralentiza Gen√©rico (pero siguen siendo geniales, porque son m√°s r√°pidos que los protocolos): <br><br><img src="https://habrastorage.org/webt/k-/ox/vr/k-oxvrhsx5mbw_osj7azkzu9x7y.png"><br>  <i>Fig.</i>  <i>4: Comparaci√≥n de funciones de host gen√©ricas y de protocolo.</i> <br><br><h4>  Prueba 5: compare la llamada del m√©todo principal y el m√©todo nativo y, al mismo tiempo, verifique la clase final para dicha llamada </h4><br>  Lo que siempre me interes√≥ es cu√°n lentamente funcionan las clases con un gran n√∫mero de padres, qu√© tan r√°pido una clase activa sus funciones y las de un padre.  En los casos en que estamos tratando de llamar a un m√©todo que toma una clase, el despacho din√°mico entra en juego.  Que es esto  Cada vez que se llama a un m√©todo o variable dentro de nuestra funci√≥n, se genera un mensaje pidi√©ndole al objeto esta variable o m√©todo.  El objeto, al recibir dicha solicitud, comienza a buscar el m√©todo en la tabla de despacho de su clase, y si se llam√≥ a una anulaci√≥n del m√©todo o variable, lo toma y lo devuelve, o llega recursivamente a la clase base. <br><br><img src="https://habrastorage.org/webt/tr/wz/i-/trwzi-l8v51yv4oftdl33a-30z4.png"><br>  <i>Fig.</i>  <i>5: llamadas a m√©todos de clase, para pruebas de despacho</i> <br><br>  Se pueden sacar varias conclusiones de la prueba anterior: cuanto mayor sea la clase de clases primarias, m√°s lenta funcionar√°, y que la diferencia de velocidad es tan peque√±a que puede descuidarse con seguridad, lo m√°s probable es que la optimizaci√≥n del c√≥digo haga que no haya diferencia en la velocidad.  En este ejemplo, el modificador de clase final no tiene una ventaja, por el contrario, el trabajo de la clase es a√∫n m√°s lento, posiblemente debido al hecho de que no se convierte en una funci√≥n realmente r√°pida. <br><br><h4>  Prueba 6: Llamar una variable con modificador final contra una variable de clase regular </h4><br>  Tambi√©n resultados muy interesantes al asignar el modificador final a una variable, puede usarlo cuando sepa con certeza que la variable no se reescribir√° en ning√∫n lugar de los herederos de la clase.  Intentemos poner el modificador final a una variable.  Si en nuestra prueba creamos solo una variable y llamamos una propiedad sobre ella, entonces se inicializar√≠a una vez (el resultado es de abajo).  Si creamos honestamente cada vez que un nuevo objeto y solicitamos su variable, la velocidad disminuir√° notablemente (el resultado est√° arriba): <br><br><img src="https://habrastorage.org/webt/ef/t7/d7/eft7d7u2wpc4htxcas5tiffnari.png"><br>  <i>Fig.</i>  <i>6: Llamar variable final</i> <br><br>  Obviamente, el modificador no fue en beneficio de la variable, y siempre es m√°s lento que su competidor. <br><br><h4>  Prueba 7: Problema de polimorfismo y protocolos para estructuras.  O el rendimiento de un contenedor existencial </h4><br>  Problema: si tomamos un protocolo que admita un determinado m√©todo y varias estructuras heredadas de este protocolo, ¬øqu√© pensar√° nuestro compilador cuando coloquemos estructuras con diferentes vol√∫menes de valores almacenados en una matriz, unidos por el protocolo original? <br><br>  Para resolver el problema de llamar a un m√©todo predefinido en los herederos, se utiliza el mecanismo de Tabla de Testigos de Protocolo.  Crea estructuras de shell que hacen referencia a los m√©todos necesarios. <br><br>  Para resolver el problema del almacenamiento de datos, se utiliza un contenedor Existencial.  Almacena en s√≠ mismo 5 celdas de informaci√≥n, cada una de 8 bytes.  En los primeros tres, se asigna espacio para los datos almacenados en la estructura (si no encajan, crea un enlace al mont√≥n en el que se almacenan los datos), el cuarto almacena informaci√≥n sobre los tipos de datos que se utilizan en la estructura y nos dice c√≥mo administrar estos datos. , el quinto contiene referencias a los m√©todos del objeto. <br><br><img src="https://habrastorage.org/webt/jh/tu/6c/jhtu6cgi7hcnllrybgfphk9gx-i.png"><br>  <i>Figura 7. Comparaci√≥n del rendimiento de una matriz que crea un enlace a un objeto y que lo contiene</i> <br><br>  Entre el primer y el segundo resultado, el n√∫mero de variables se triplic√≥.  En teor√≠a, deben colocarse en un contenedor, se almacenan en este contenedor y la diferencia de velocidad se debe al volumen de la estructura.  Curiosamente, si reduce el n√∫mero de variables en la segunda estructura, el tiempo de operaci√≥n no cambiar√°, es decir, el contenedor realmente almacena 3 o 2 variables, pero aparentemente, hay condiciones especiales para una variable que aumentan significativamente la velocidad.  La segunda estructura encaja perfectamente en el contenedor y difiere en volumen del tercero a la mitad, lo que da una fuerte degradaci√≥n en tiempo de ejecuci√≥n, en comparaci√≥n con otras estructuras. <br><br><h4>  Un poco de teor√≠a para optimizar tus proyectos </h4><br>  Los siguientes factores pueden influir en el rendimiento de las estructuras: <br><br><ul><li>  donde se almacenan sus variables (mont√≥n / pila); </li><li>  la necesidad de contar las referencias para propiedades; </li><li>  m√©todos de programaci√≥n (est√°tico / din√°mico); </li><li>  Copy-On-Write se usa solo por estructuras de datos que son tipos de referencia que fingen ser estructuras (String, Array, Set, Dictionary) debajo del cap√≥. </li></ul><br>  Vale la pena aclarar de inmediato que el m√°s r√°pido de todos ser√° aquellos objetos que almacenan propiedades en la pila, no use el conteo de referencias con el m√©todo est√°tico de examen m√©dico. <br><h4>  Que las clases son malas y peligrosas en comparaci√≥n con las estructuras </h4><br><br>  No siempre controlamos la copia de nuestros objetos, y si lo hacemos, podemos obtener demasiadas copias que ser√°n dif√≠ciles de administrar (creamos objetos en el proyecto que son responsables de formar la vista, por ejemplo). <br><br>  No son tan r√°pidos como las estructuras. <br><br>  Si tenemos un enlace a un objeto y estamos tratando de controlar nuestra aplicaci√≥n en un estilo de subprocesos m√∫ltiples, podemos obtener la condici√≥n de carrera cuando nuestro objeto se usa desde dos lugares diferentes (y esto no es tan dif√≠cil, porque un proyecto construido con Xcode siempre es un poco m√°s lento) que la versi√≥n de la tienda). <br><br>  Si tratamos de evitar la Condici√≥n de carrera, gastamos muchos recursos en Lock y nuestros datos, que comienzan a consumir recursos y perder tiempo en lugar de un procesamiento r√°pido y obtenemos objetos a√∫n m√°s lentos que los mismos construidos en las estructuras. <br><br>  Si hacemos todas las acciones anteriores en nuestros objetos (enlaces), entonces la probabilidad de puntos muertos imprevistos es alta. <br><br>  La complejidad del c√≥digo est√° aumentando debido a esto. <br><br>  M√°s c√≥digo = m√°s errores, ¬°siempre! <br><br><h4>  Conclusiones </h4><br>  Pens√© que las conclusiones de este art√≠culo son simplemente necesarias, porque no quiero leer el art√≠culo de vez en cuando, y una lista consolidada de puntos es simplemente necesaria.  Resumiendo las l√≠neas bajo las pruebas, quiero resaltar lo siguiente: <br><br><ol><li>  Las matrices se colocan mejor en una matriz. </li><li>  Si desea crear una matriz a partir de clases, es mejor elegir una matriz regular, ya que ContiguousArray rara vez ofrece ventajas y no son muy altas. </li><li>  La optimizaci√≥n en l√≠nea acelera el trabajo, no lo apague. </li><li>  El acceso a los elementos de la matriz siempre es m√°s r√°pido que el acceso a los elementos de la matriz contigua. </li><li>  Las estructuras son siempre m√°s r√°pidas que las clases (a menos, por supuesto, que habilite la optimizaci√≥n de todo el m√≥dulo u otra optimizaci√≥n similar). </li><li>  Al pasar un objeto a una funci√≥n y llamar a sus propiedades, a partir del tercero, la estructura es m√°s r√°pida que las clases. </li><li>  Cuando pasa un valor a una funci√≥n escrita para Gen√©rico y Protocolo, Gen√©rico ser√° m√°s r√°pido. </li><li>  Con la herencia de clases m√∫ltiples, la velocidad de la llamada a la funci√≥n se degrada. </li><li>  Las variables marcaron el trabajo final m√°s lentamente que los pimientos regulares. </li><li>  Si una funci√≥n acepta un objeto que combina varios objetos con el protocolo, funcionar√° r√°pidamente si solo se almacena una propiedad en √©l, y se degradar√° en gran medida al agregar m√°s propiedades. </li></ol><br>  Referencias <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">medium.com/@vhart/protocols-generics-and-existential-containers-wait-what-e2e698262ab1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">developer.apple.com/videos/play/wwdc2016/416</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">developer.apple.com/videos/play/wwdc2015/409</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">developer.apple.com/videos/play/wwdc2016/419</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">medium.com/commencis/stop-using-structs-e1be9a86376f</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Probar el c√≥digo fuente</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472290/">https://habr.com/ru/post/472290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472272/index.html">Un nuevo juego con un ambiente antiguo en Three.js. Parte 2</a></li>
<li><a href="../472274/index.html">SSH remoto: consejos y hacks</a></li>
<li><a href="../472278/index.html">Mi git commit favorito</a></li>
<li><a href="../472280/index.html">La tarea de determinar la presencia de una palma en un esc√°ner de venas</a></li>
<li><a href="../472288/index.html">9 extensiones de navegador √∫tiles para desarrolladores (lista para 2020)</a></li>
<li><a href="../472292/index.html">Bloqueo de contenido: el escenario mundial</a></li>
<li><a href="../472294/index.html">Crea juegos y videos en YouTube. Mi experimento de interacci√≥n y los ingresos de este</a></li>
<li><a href="../472296/index.html">Sistema de protecci√≥n contra fugas para lavadora</a></li>
<li><a href="../472298/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 385 (14-20 de octubre de 2019)</a></li>
<li><a href="../472300/index.html">Descenso de gradiente estoc√°stico (SGD) para la funci√≥n de p√©rdida logar√≠tmica (LogLoss) en un problema de clasificaci√≥n binaria</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>