<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¶ ğŸ‘½ ğŸ‘¨ğŸ½â€ğŸ« Spring Cache: dari menghubungkan caching dalam 1 menit hingga konfigurasi yang fleksibel dari manajer cache ğŸ‘©ğŸ¾â€ğŸš€ âœŠ ğŸ‘§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya dulu takut akan caching. Saya benar-benar tidak ingin memanjat dan mencari tahu apa itu, saya segera membayangkan beberapa kompartemen mesin hal-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Cache: dari menghubungkan caching dalam 1 menit hingga konfigurasi yang fleksibel dari manajer cache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465667/"> Saya dulu takut akan caching.  Saya benar-benar tidak ingin memanjat dan mencari tahu apa itu, saya segera membayangkan beberapa kompartemen mesin hal-hal perusahaan-luto yang hanya bisa ditentukan oleh pemenang olimpiade matematika.  Ternyata ini tidak benar.  Caching ternyata sangat sederhana, dapat dimengerti dan sangat mudah diimplementasikan dalam proyek apa pun. <br><br><img src="https://habrastorage.org/webt/1f/my/g2/1fmyg2ofjbgqmyf3lorqqkan85u.jpeg"><br><br>  Dalam posting ini, saya akan mencoba menjelaskan tentang caching sesederhana yang saya mengerti sekarang.  Anda akan belajar tentang cara menerapkan caching dalam 1 menit, cara cache dengan kunci, mengatur masa pakai cache, dan banyak hal lain yang perlu Anda ketahui jika Anda diminta untuk menembolok sesuatu di proyek kerja Anda, dan Anda tidak ingin mengacaukan wajah. <br><a name="habracut"></a><br>  Mengapa saya mengatakan "dipercayakan"?  Karena caching, sebagai suatu peraturan, masuk akal untuk diterapkan dalam proyek-proyek besar yang sarat muatan, dengan puluhan ribu permintaan per menit.  Dalam proyek semacam itu, agar tidak membebani database, mereka biasanya men-cache panggilan repositori.  Terutama jika diketahui bahwa data dari beberapa sistem master diperbarui pada frekuensi tertentu.  Kami sendiri tidak menulis proyek seperti itu, kami mengerjakannya.  Jika proyek ini kecil dan tidak mengancam kelebihan, maka, tentu saja, lebih baik tidak melakukan cache apa pun - selalu data segar selalu lebih baik daripada yang diperbarui secara berkala. <br><br>  Biasanya, dalam posting pelatihan, pembicara pertama merangkak di bawah tenda, mulai menggali ke dalam keberanian teknologi, yang banyak mengganggu pembaca, dan hanya kemudian, ketika dia membuka-buka setengah bagian artikel yang baik dan tidak mengerti apa-apa, ia memberitahu cara kerjanya.  Semuanya akan berbeda dengan kita.  Pertama, kami membuatnya bekerja, dan lebih baik, dengan sedikit usaha, dan hanya kemudian, jika Anda tertarik, Anda dapat melihat di bawah kap cache, mencari di dalam bin itu sendiri dan caching fine-tune.  Tetapi bahkan jika Anda tidak (dan ini dimulai dengan poin 6), caching Anda akan berfungsi seperti itu. <br><br>  Kami akan membuat proyek di mana kami akan menganalisis semua aspek caching yang saya janjikan.  Pada akhirnya, seperti biasa, akan ada tautan ke proyek itu sendiri. <br><br><h2>  0. Membuat proyek </h2><br>  Kami akan membuat proyek yang sangat sederhana di mana kami dapat mengambil entitas dari database.  Saya menambahkan Lombok, Spring Cache, Spring Data JPA, dan H2 ke proyek.  Meskipun, hanya Spring Cache yang bisa ditiadakan. <br><br><pre><code class="java hljs">plugins { id <span class="hljs-string"><span class="hljs-string">'org.springframework.boot'</span></span> version <span class="hljs-string"><span class="hljs-string">'2.1.7.RELEASE'</span></span> id <span class="hljs-string"><span class="hljs-string">'io.spring.dependency-management'</span></span> version <span class="hljs-string"><span class="hljs-string">'1.0.8.RELEASE'</span></span> id <span class="hljs-string"><span class="hljs-string">'java'</span></span> } group = <span class="hljs-string"><span class="hljs-string">'ru.xpendence'</span></span> version = <span class="hljs-string"><span class="hljs-string">'0.0.1-SNAPSHOT'</span></span> sourceCompatibility = <span class="hljs-string"><span class="hljs-string">'1.8'</span></span> configurations { compileOnly { extendsFrom annotationProcessor } } repositories { mavenCentral() } dependencies { implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-cache'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span> compileOnly <span class="hljs-string"><span class="hljs-string">'org.projectlombok:lombok'</span></span> runtimeOnly <span class="hljs-string"><span class="hljs-string">'com.h2database:h2'</span></span> annotationProcessor <span class="hljs-string"><span class="hljs-string">'org.projectlombok:lombok'</span></span> testImplementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span></span> }</code> </pre> <br>  Kami hanya akan memiliki satu entitas, sebut saja Pengguna. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"users"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@ToString</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"name"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"email"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String email; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String email)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.email = email; } }</code> </pre> <br>  Tambahkan repositori dan layanan: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserServiceImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UserRepository repository; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserServiceImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserRepository repository)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.repository = repository; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(user); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"getting user by id: {}"</span></span>, id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.findById(id) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EntityNotFoundException(<span class="hljs-string"><span class="hljs-string">"User not found by id "</span></span> + id)); } }</code> </pre> <br>  Ketika kita memasukkan metode layanan get (), kita menulisnya di log. <br><br>  Hubungkan ke proyek Spring Cache. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableCaching</span></span> <span class="hljs-comment"><span class="hljs-comment">// Spring Cache public class CacheApplication { public static void main(String[] args) { SpringApplication.run(CacheApplication.class, args); } }</span></span></code> </pre> <br>  Proyek sudah siap. <br><br><h2>  1. Caching hasil pengembalian </h2><br>  Apa yang dilakukan Spring Cache?  Spring Cache hanya cache hasil kembali untuk parameter input tertentu.  Mari kita periksa.  Kami akan menempatkan anotasi @Cacheable atas metode layanan get () untuk menembolok data yang dikembalikan.  Kami memberikan penjelasan ini dengan nama "pengguna" (kami akan menganalisis lebih lanjut mengapa hal ini dilakukan secara terpisah). <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(<span class="hljs-string"><span class="hljs-string">"users"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"getting user by id: {}"</span></span>, id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.findById(id) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EntityNotFoundException(<span class="hljs-string"><span class="hljs-string">"User not found by id "</span></span> + id)); }</code> </pre> <br>  Untuk memeriksa cara kerjanya, kami akan menulis tes sederhana. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractTest</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserServiceTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> UserService service; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ User user1 = service.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); User user2 = service.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Kolya"</span></span>, <span class="hljs-string"><span class="hljs-string">"kolya@mail.ru"</span></span>)); getAndPrint(user1.getId()); getAndPrint(user2.getId()); getAndPrint(user1.getId()); getAndPrint(user2.getId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAndPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"user found: {}"</span></span>, service.get(id)); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Penyimpangan kecil, mengapa saya biasanya menulis AbstractTest dan mewarisi semua tes darinya.</b> <div class="spoiler_text">  Jika kelas memiliki anotasi @SpringBootTest sendiri, konteksnya dinaikkan kembali untuk kelas tersebut setiap waktu.  Karena konteksnya dapat naik selama 5 detik, atau mungkin 40 detik, hal ini sangat menghambat proses pengujian.  Dalam hal ini, biasanya tidak ada perbedaan dalam konteks, dan ketika Anda menjalankan setiap kelompok tes dalam kelas yang sama, tidak perlu memulai kembali konteks.  Jika kita hanya menempatkan satu anotasi, katakanlah, pada kelas abstrak, seperti dalam kasus kami, ini memungkinkan kami untuk meningkatkan konteks hanya sekali. <br><br>  Oleh karena itu, saya lebih suka mengurangi jumlah konteks yang diangkat selama pengujian / perakitan, jika mungkin. <br></div></div><br>  Apa yang dilakukan tes kami?  Dia menciptakan dua pengguna dan kemudian menarik mereka keluar dari database 2 kali.  Seperti yang kita ingat, kita meletakkan anotasi @Cacheable, yang akan menembolok nilai yang dikembalikan.  Setelah menerima objek dari metode get (), kami menampilkan objek ke log.  Selain itu, kami mencatat informasi tentang setiap kunjungan oleh aplikasi ke metode get (). <br><br>  Jalankan tes.  Inilah yang kami dapatkan di konsol. <br><br><pre> <code class="java hljs">getting user by id: <span class="hljs-number"><span class="hljs-number">1</span></span> user found: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) getting user by id: <span class="hljs-number"><span class="hljs-number">2</span></span> user found: User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Kolya, email=kolya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) user found: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) user found: User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Kolya, email=kolya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru)</code> </pre> <br>  Seperti yang kita lihat, dua kali pertama kita benar-benar pergi ke metode get () dan benar-benar mendapatkan pengguna dari database.  Dalam semua kasus lain, tidak ada panggilan nyata ke metode ini, aplikasi mengambil data cache dengan kunci (dalam hal ini, ini id). <br><br><h2>  2. Deklarasi kunci caching </h2><br>  Ada beberapa situasi ketika beberapa parameter datang ke metode cache.  Dalam hal ini, mungkin perlu untuk menentukan parameter dimana caching akan terjadi.  Kami menambahkan contoh ke metode yang akan menyimpan entitas yang dirakit oleh parameter ke dalam database, tetapi jika entitas dengan nama yang sama sudah ada, kami tidak akan menyimpannya.  Untuk melakukan ini, kita akan mendefinisikan parameter nama sebagai kunci untuk caching.  Ini akan terlihat seperti ini: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(value = <span class="hljs-string"><span class="hljs-string">"users"</span></span>, key = <span class="hljs-string"><span class="hljs-string">"#name"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String email)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"creating user with parameters: {}, {}"</span></span>, name, email); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(name, email)); }</code> </pre> <br>  Mari kita tulis tes yang sesuai: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ createAndPrint(<span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan@mail.ru"</span></span>); createAndPrint(<span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan1122@mail.ru"</span></span>); createAndPrint(<span class="hljs-string"><span class="hljs-string">"Sergey"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan@mail.ru"</span></span>); log.info(<span class="hljs-string"><span class="hljs-string">"all entries are below:"</span></span>); service.getAll().forEach(u -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, u.toString())); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAndPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String email)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"created user: {}"</span></span>, service.create(name, email)); }</code> </pre> <br>  Kami akan mencoba membuat tiga pengguna, yang dua di antaranya namanya sama <br><br><pre> <code class="java hljs"> createAndPrint(<span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan@mail.ru"</span></span>); createAndPrint(<span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan1122@mail.ru"</span></span>);</code> </pre> <br>  dan untuk dua email yang akan cocok <br><br><pre> <code class="java hljs"> createAndPrint(<span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan@mail.ru"</span></span>); createAndPrint(<span class="hljs-string"><span class="hljs-string">"Sergey"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan@mail.ru"</span></span>);</code> </pre> <br>  Dalam metode pembuatan, kami mencatat setiap fakta bahwa metode tersebut dipanggil, dan juga, kami akan mencatat semua entitas yang dikembalikan metode ini kepada kami.  Hasilnya akan seperti ini: <br><br><pre> <code class="java hljs">creating user with parameters: Ivan, ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru created user: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Ivan, email=ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) created user: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Ivan, email=ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) creating user with parameters: Sergey, ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru created user: User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Sergey, email=ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) all entries are below: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Ivan, email=ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Sergey, email=ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru)</code> </pre> <br>  Kita melihat bahwa, pada kenyataannya, aplikasi itu memanggil metode 3 kali, dan masuk ke dalamnya hanya dua kali.  Setelah kunci cocok dengan metode, dan itu hanya mengembalikan nilai yang di-cache. <br><br><h2>  3. Caching paksa.  @CachePut </h2><br>  Ada situasi ketika kita ingin menembolok nilai kembali untuk beberapa entitas, tetapi pada saat yang sama, kita perlu memperbarui cache.  Untuk kebutuhan seperti itu, anotasi @CachePut ada.  Itu melewati aplikasi ke dalam metode, sambil memperbarui cache untuk nilai kembali, bahkan jika itu sudah di-cache. <br><br>  Tambahkan beberapa metode di mana kami akan menyelamatkan pengguna.  Kami akan menandai salah satunya dengan penjelasan @Cacheable biasa, yang kedua dengan @CachePut. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(value = <span class="hljs-string"><span class="hljs-string">"users"</span></span>, key = <span class="hljs-string"><span class="hljs-string">"#user.name"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createOrReturnCached</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"creating user: {}"</span></span>, user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(user); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@CachePut</span></span>(value = <span class="hljs-string"><span class="hljs-string">"users"</span></span>, key = <span class="hljs-string"><span class="hljs-string">"#user.name"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAndRefreshCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"creating user: {}"</span></span>, user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(user); }</code> </pre> <br>  Metode pertama hanya akan mengembalikan nilai-nilai yang di-cache, yang kedua akan memaksa cache untuk diperbarui.  Caching akan dilakukan menggunakan kunci # user.name.  Kami akan menulis tes yang sesuai. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAndRefresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ User user1 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"created user1: {}"</span></span>, user1); User user2 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"misha@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"created user2: {}"</span></span>, user2); User user3 = service.createAndRefreshCache(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"kolya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"created user3: {}"</span></span>, user3); User user4 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"petya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"created user4: {}"</span></span>, user4); }</code> </pre> <br>  Menurut logika yang telah dijelaskan, pertama kali pengguna dengan nama "Vasya" disimpan melalui metode createOrReturnCached (), kita akan menerima entitas yang di-cache, dan aplikasi tidak akan masuk ke metode itu sendiri.  Jika kita memanggil metode createAndRefreshCache (), entitas yang di-cache untuk kunci bernama "Vasya" akan ditimpa dalam cache.  Ayo jalankan tes dan lihat apa yang akan ditampilkan di konsol. <br><br><pre> <code class="java hljs">creating user: User(id=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) created user1: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) created user2: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) creating user: User(id=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, name=Vasya, email=kolya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) created user3: User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Vasya, email=kolya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) created user4: User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Vasya, email=kolya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru)</code> </pre> <br>  Kami melihat bahwa user1 telah berhasil menulis ke database dan cache.  Ketika kami mencoba merekam pengguna dengan nama yang sama lagi, kami mendapatkan hasil cache dari panggilan pertama (user2, yang idnya sama dengan user1, yang memberi tahu kami bahwa pengguna tidak ditulis, dan ini hanya cache).  Selanjutnya, kami menulis pengguna ketiga melalui metode kedua, yang, bahkan dengan hasil cache, masih memanggil metode dan menulis hasil baru ke cache.  Ini adalah user3.  Seperti yang bisa kita lihat, dia sudah memiliki id baru.  Setelah itu, kami memanggil metode pertama, yang mengambil cache baru yang ditambahkan oleh user3. <br><br><h2>  4. Penghapusan dari cache.  @CacheEvict </h2><br>  Terkadang menjadi sulit untuk memperbarui beberapa data dalam cache.  Sebagai contoh, suatu entitas telah dihapus dari database, tetapi masih dapat diakses dari cache.  Untuk menjaga konsistensi data, kita harus setidaknya tidak menyimpan data yang dihapus dalam cache. <br><br>  Tambahkan beberapa metode lagi ke layanan. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"deleting user by id: {}"</span></span>, id); repository.deleteById(id); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(<span class="hljs-string"><span class="hljs-string">"users"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteAndEvict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"deleting user by id: {}"</span></span>, id); repository.deleteById(id); }</code> </pre> <br>  Yang pertama hanya akan menghapus pengguna, yang kedua juga akan menghapusnya, tetapi kami akan menandainya dengan anotasi @CacheEvict.  Tambahkan tes yang akan membuat dua pengguna, setelah itu satu akan dihapus melalui metode sederhana, dan yang kedua melalui metode beranotasi.  Setelah itu, kita akan mendapatkan pengguna ini melalui metode get (). <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ User user1 = service.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user1.getId())); User user2 = service.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user2.getId())); service.delete(user1.getId()); service.deleteAndEvict(user2.getId()); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user1.getId())); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user2.getId())); }</code> </pre> <br>  Adalah logis bahwa karena pengguna kami sudah di-cache, penghapusan tidak akan mencegah kami dari mendapatkannya, karena itu di-cache.  Mari kita lihat log. <br><br><pre> <code class="java hljs">getting user by id: <span class="hljs-number"><span class="hljs-number">1</span></span> User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) getting user by id: <span class="hljs-number"><span class="hljs-number">2</span></span> User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) deleting user by id: <span class="hljs-number"><span class="hljs-number">1</span></span> deleting user by id: <span class="hljs-number"><span class="hljs-number">2</span></span> User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) getting user by id: <span class="hljs-number"><span class="hljs-number">2</span></span> javax.persistence.EntityNotFoundException: User not found by id <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Kita melihat bahwa aplikasi dengan aman pergi kedua kali ke metode get () dan Spring cache entitas ini.  Selanjutnya, kami menghapusnya melalui metode yang berbeda.  Kami menghapus yang pertama dengan cara biasa, dan nilai cache tetap, jadi ketika kami mencoba untuk mendapatkan pengguna di bawah id 1, kami berhasil.  Ketika kami mencoba untuk mendapatkan pengguna 2, metode ini mengembalikan EntityNotFoundException - tidak ada pengguna seperti itu di cache. <br><br><h2>  5. Pengaturan pengelompokan.  @Caching </h2><br>  Terkadang satu metode membutuhkan beberapa pengaturan caching.  Anotasi @Caching digunakan untuk tujuan ini.  Mungkin terlihat seperti ini: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Caching</span></span>( cacheable = { <span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(<span class="hljs-string"><span class="hljs-string">"users"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(<span class="hljs-string"><span class="hljs-string">"contacts"</span></span>) }, put = { <span class="hljs-meta"><span class="hljs-meta">@CachePut</span></span>(<span class="hljs-string"><span class="hljs-string">"tables"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@CachePut</span></span>(<span class="hljs-string"><span class="hljs-string">"chairs"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@CachePut</span></span>(value = <span class="hljs-string"><span class="hljs-string">"meals"</span></span>, key = <span class="hljs-string"><span class="hljs-string">"#user.email"</span></span>) }, evict = { <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(value = <span class="hljs-string"><span class="hljs-string">"services"</span></span>, key = <span class="hljs-string"><span class="hljs-string">"#user.name"</span></span>) } ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheExample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Ini adalah satu-satunya cara untuk mengelompokkan anotasi.  Jika Anda mencoba untuk menumpuk sesuatu seperti <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(<span class="hljs-string"><span class="hljs-string">"users"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(<span class="hljs-string"><span class="hljs-string">"meals"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(<span class="hljs-string"><span class="hljs-string">"contacts"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(<span class="hljs-string"><span class="hljs-string">"tables"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheExample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  maka IDEA akan memberi tahu Anda bahwa ini bukan masalahnya. <br><br><h2>  6. Konfigurasi yang fleksibel.  Cachemanager </h2><br>  Akhirnya, kami menemukan cache, dan berhenti menjadi sesuatu yang tidak bisa dipahami dan menakutkan bagi kami.  Sekarang mari kita lihat di bawah tenda dan lihat bagaimana kita dapat mengkonfigurasi caching secara umum. <br><br>  Untuk tugas seperti itu, ada CacheManager.  Itu ada dimanapun Spring Cache berada.  Ketika kami menambahkan anotasi @EnableCache, manajer cache seperti itu akan secara otomatis dibuat oleh Spring.  Kami dapat memverifikasi ini jika kami membungkus ApplicationContext secara otomatis dan membukanya di breakpoint.  Di antara tempat sampah lainnya, akan ada kacang cacheManager. <br><br><img src="https://habrastorage.org/webt/nc/bn/vp/ncbnvpwm57vw-2i9t7xpaiwr29s.png"><br><br>  Saya menghentikan aplikasi pada tahap ketika dua pengguna telah dibuat dan dimasukkan ke dalam cache.  Jika kita memanggil kacang yang kita butuhkan melalui Evaluasi Ekspresi, kita akan melihat bahwa memang ada kacang seperti itu, ia memiliki ConcurentMapCache dengan kunci "pengguna" dan nilai ConcurrentHashMap, yang sudah berisi pengguna yang di-cache. <br><br><img src="https://habrastorage.org/webt/7-/xt/s9/7-xts9jrjipidhtsls1nv4gr2o0.png"><br><br>  Kami, pada gilirannya, dapat membuat cache manager kami, dengan Habr dan programmer, dan kemudian menyempurnakannya sesuai selera kami. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"habrCacheManager"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CacheManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Tetap hanya memilih cache manager mana yang akan kita gunakan, karena ada banyak dari mereka.  Saya tidak akan mencantumkan semua manajer cache, itu akan cukup untuk mengetahui bahwa ada seperti: <br><br><ul><li>  <i><b>SimpleCacheManager</b></i> adalah pengelola cache paling sederhana, nyaman untuk dipelajari dan diuji. </li><li>  <i><b>ConcurrentMapCacheManager</b></i> - Lazily menginisialisasi instance yang dikembalikan untuk setiap permintaan.  Juga disarankan untuk menguji dan mempelajari cara bekerja dengan cache, serta untuk beberapa tindakan sederhana seperti kita.  Untuk pekerjaan serius dengan cache, implementasi di bawah ini direkomendasikan. </li><li>  <i><b>JCacheCacheManager</b></i> , <i><b>EhCacheCacheManager</b></i> , <i><b>CaffeineCacheManager</b></i> adalah manajer cache â€œmitra rekananâ€ yang serius yang dapat dikustomisasi secara fleksibel dan melakukan tugas dari serangkaian tindakan yang sangat luas. </li></ul><br>  Sebagai bagian dari postingan sederhana saya, saya tidak akan menjelaskan manajer cache dari tiga yang terakhir.  Sebagai gantinya, kami akan melihat beberapa aspek pengaturan pengelola cache menggunakan ConcurrentMapCacheManager sebagai contoh. <br><br>  Jadi, mari kita buat ulang manajer cache kita. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"habrCacheManager"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CacheManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentMapCacheManager(); }</code> </pre> <br>  Manajer cache kami sudah siap. <br><br><h2>  7. Pengaturan cache.  Waktu hidup, ukuran maksimum dan sebagainya. </h2><br>  Untuk melakukan ini, kita memerlukan perpustakaan Google Guava yang cukup populer.  Saya mengambil yang terakhir. <br><br><pre> <code class="java hljs">compile group: <span class="hljs-string"><span class="hljs-string">'com.google.guava'</span></span>, name: <span class="hljs-string"><span class="hljs-string">'guava'</span></span>, version: <span class="hljs-string"><span class="hljs-string">'28.1-jre'</span></span></code> </pre> <br>  Saat membuat pengelola cache, kami mendefinisikan kembali metode createConcurrentMapCache, di mana kami akan memanggil CacheBuilder dari Guava.  Dalam prosesnya, kami akan diminta untuk mengonfigurasi cache manager dengan menginisialisasi metode berikut: <br><br><ul><li>  maximumSize - ukuran maksimum dari nilai-nilai yang bisa disimpan oleh cache.  Menggunakan parameter ini, Anda dapat menemukan upaya untuk menemukan kompromi antara beban pada database dan JVM RAM. </li><li>  refreshAfterWrite - waktu setelah menulis nilai ke cache, setelah itu akan diperbarui secara otomatis. </li><li>  expireAfterAccess - nilai seumur hidup setelah panggilan terakhir untuk itu. </li><li>  expireAfterWrite - nilai seumur hidup setelah menulis ke cache.  Ini adalah parameter yang akan kita tentukan. </li></ul><br>  dan lainnya. <br><br>  Kami mendefinisikan dalam manajer masa pakai catatan.  Agar tidak menunggu lama, atur 1 detik. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"habrCacheManager"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CacheManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentMapCacheManager() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Cache </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createConcurrentMapCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentMapCache( name, CacheBuilder.newBuilder() .expireAfterWrite(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS) .build().asMap(), <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } }; }</code> </pre> <br>  Kami menulis tes yang sesuai dengan kasus ini. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ User user1 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user1.getId())); User user2 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user2.getId())); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000L</span></span>); User user3 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user3.getId())); }</code> </pre> <br>  Kami menyimpan beberapa nilai ke database, dan jika data di-cache, kami tidak menyimpan apa pun.  Pertama, kita menyimpan dua nilai, lalu kita menunggu 1 detik sampai cache mati, setelah itu kita menyimpan nilai lain. <br><br><pre> <code class="java hljs">creating user: User(id=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) getting user by id: <span class="hljs-number"><span class="hljs-number">1</span></span> User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) creating user: User(id=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) getting user by id: <span class="hljs-number"><span class="hljs-number">2</span></span> User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru)</code> </pre> <br>  Log menunjukkan bahwa pertama kami membuat pengguna, lalu kami mencoba yang lain, tetapi karena data di-cache, kami mendapatkannya dari cache (dalam kedua kasus, saat menyimpan dan ketika mendapatkan dari database).  Kemudian cache menjadi buruk, karena catatan memberi tahu kami tentang penghematan aktual dan penerimaan aktual pengguna. <br><br><h2>  8. Untuk meringkas </h2><br>  Cepat atau lambat, pengembang dihadapkan pada kebutuhan untuk mengimplementasikan caching dalam proyek.  Saya harap artikel ini membantu Anda memahami subjek dan melihat masalah caching dengan lebih berani. <br><br>  Github dari proyek di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/promoscow/cache</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465667/">https://habr.com/ru/post/id465667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465655/index.html">Berita dari dunia OpenStreetMap No. 474 (13/08/2019 - 08/08/2019)</a></li>
<li><a href="../id465657/index.html">Hukum Parkinson: Anda bisa mengalahkannya</a></li>
<li><a href="../id465659/index.html">Menanggapi artikel "Penaklukan Siberia oleh Moskow," atau Dua Puluh Tahun Kemudian</a></li>
<li><a href="../id465661/index.html">Apakah Anda juga punya teman seperti itu? Atau mungkin kamu?</a></li>
<li><a href="../id465663/index.html">FAQ Superjob API (Posting Pekerjaan)</a></li>
<li><a href="../id465669/index.html">Menghitung kecepatan unduhan di aplikasi Anda</a></li>
<li><a href="../id465673/index.html">Hedi Lamarr: penemu dari Hollywood</a></li>
<li><a href="../id465675/index.html">Bagaimana NASA peduli dengan keselamatan dan kecerdasan para astronotnya</a></li>
<li><a href="../id465677/index.html">Lupakan Walkman: itu semua tentang headphone</a></li>
<li><a href="../id465679/index.html">Apa yang dapat dilakukan arloji selain menunjukkan waktu dan cara memilih arloji pertama Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>