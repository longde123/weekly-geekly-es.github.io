<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèæ üîΩ üìØ Quando o correio √© entregue: combatendo a perda de notifica√ß√µes por push no iOS üë®üèæ‚ÄçüöÄ üõ©Ô∏è ü¶ì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por parte do usu√°rio, o cliente de email √© um aplicativo simples. Os desenvolvedores do Yandex.Mail at√© brincam que existem apenas tr√™s telas no aplic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quando o correio √© entregue: combatendo a perda de notifica√ß√µes por push no iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462507/">  Por parte do usu√°rio, o cliente de email √© um aplicativo simples.  Os desenvolvedores do Yandex.Mail at√© brincam que existem apenas tr√™s telas no aplicativo: uma lista de letras;  enviando uma carta;  sobre a tela. <br><br>  Mas muitas coisas interessantes est√£o acontecendo sob o cap√¥.  Como muitos aplicativos m√≥veis, o Mail usa notifica√ß√µes push para interagir com os usu√°rios.  Como muitos aplicativos iOS, o Mail perde algumas notifica√ß√µes devido √† natureza do Apple Push Notification Service. <br><br>  <strong>Asya Sviridenko</strong> , chefe do grupo iOS do Yandex.Mail, provar√° que, mesmo com as limita√ß√µes do sistema, a perda de notifica√ß√µes por push pode e deve ser combatida se forem cr√≠ticas para o seu aplicativo.  Isso vale para o Mail, porque as notifica√ß√µes por push de novas letras s√£o o que o usu√°rio instala o aplicativo.  Se, para o seu aplicativo, a entrega de notifica√ß√µes por push n√£o √© t√£o cr√≠tica, ainda √© interessante descobrir quais bicicletas o Yandex.Mail m√≥vel empilhou. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SVCMbPIuy8w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Trata-se de notifica√ß√£o remota, ou seja, notifica√ß√µes provenientes do servidor por meio de APNs (Apple Push Notification Service).  N√£o tocaremos nas notifica√ß√µes locais e falaremos sobre: <br><br><ul><li>  Como √© a API para trabalhar com notifica√ß√µes por push.  Considere um esquema de entrega de notifica√ß√£o por push e onde as perdas podem ocorrer nesse esquema. </li><li>  Como voc√™ decidiu lidar com as perdas no Yandex.Mail - a fila de notifica√ß√µes por push. </li><li>  Como registrar e que outras dificuldades podem encontrar. </li></ul><a name="habracut"></a><br><h2>  O que temos e onde perdemos </h2><br>  Agora, a API para trabalhar com notifica√ß√µes push √© uma coisa bastante poderosa que permite fazer muitas coisas interessantes.  Mas esse nem sempre foi o caso. <br><br><img src="https://habrastorage.org/webt/p6/ln/n1/p6lnn1nbbopnz4xr9k2xiuf1dre.jpeg"><br><br>  Anteriormente, as notifica√ß√µes por push eram exatamente assim - era um infeliz painel azul que aparecia na tela, bloqueava o trabalho com o aplicativo atual, n√£o permitia que nada fosse feito e depois desaparecia para sempre, e n√£o havia mais lembretes sobre isso. <br><br>  Tempo suficiente se passou desde ent√£o. <br><br><img src="https://habrastorage.org/webt/nq/kr/9j/nqkr9jbh2v4nwacrbhksoa1tpy0.jpeg"><br><br>  Para n√≥s, como desenvolvedores, <strong>tudo come√ßou no iOS 3</strong> quando as notifica√ß√µes por push foram disponibilizadas para bibliotecas de terceiros. <br><br>  <strong>O Notification Center apareceu no iOS 5</strong> e as notifica√ß√µes por push deixaram de ir a lugar nenhum; agora permanecem no Notification Center, onde podem ser visualizadas novamente. <br><br>  <strong>O IOS 6 introduziu N√£o perturbe</strong> .  O usu√°rio tem a oportunidade de definir o per√≠odo durante o qual ele n√£o deseja receber notifica√ß√µes. <br><br>  Essas mudan√ßas diziam respeito principalmente a como o usu√°rio pode trabalhar com notifica√ß√µes por push, como ele pode tornar sua vida mais confort√°vel e n√£o como os desenvolvedores podem influenciar as notifica√ß√µes. <br><br>  Para os desenvolvedores, um marco importante foi o <strong>iOS 8 e o surgimento da A√ß√£o de Notifica√ß√£o</strong> , que permitiu executar a√ß√µes espec√≠ficas para um aplicativo espec√≠fico por meio de notifica√ß√µes push. <br><br>  <strong>O IOS 10 apresenta a extens√£o de servi√ßo de notifica√ß√£o e a extens√£o de conte√∫do de notifica√ß√£o</strong> .  O primeiro permite modificar a notifica√ß√£o por push antes que ela seja mostrada ao usu√°rio.  O segundo √© mostrar alguma interface do usu√°rio por notifica√ß√£o por push na notifica√ß√£o por push, na qual, por exemplo, voc√™ pode exibir informa√ß√µes mais detalhadas.  No iOS 10, essa interface n√£o era clic√°vel - voc√™ pode assistir, n√£o pode toc√°-la. <br><br>  <strong>O IOS 11 introduziu as configura√ß√µes de privacidade da notifica√ß√£o</strong> .  Agora, o usu√°rio pode acessar as configura√ß√µes e indicar se deseja que o conte√∫do das notifica√ß√µes recebidas seja exibido.  Este √© um grande passo em dire√ß√£o √† seguran√ßa.  Foram necess√°rias apenas 8 vers√µes do iOS para entender que nem todos os usu√°rios desejam que informa√ß√µes pessoais apare√ßam repentinamente no iPhone deitado sobre a mesa. <br><br>  <strong>No iOS 12, tornou-se poss√≠vel agrupar notifica√ß√µes push</strong> por ID de segmento, e a interface do usu√°rio que recebemos no iOS 10 usando a extens√£o de conte√∫do de notifica√ß√£o tornou-se clic√°vel.  Agora voc√™ pode adicionar bot√µes e controles por gesto - tudo isso ajuda o usu√°rio a interagir com a interface do usu√°rio. <br><br><h2>  Notifica√ß√µes push hoje </h2><br>  Como voc√™ pode ver, as notifica√ß√µes por push percorreram um longo caminho e, hoje, com a ajuda delas, voc√™ pode realmente fazer muitas coisas. <br><br><h3>  Mensagens de texto e localiza√ß√£o </h3><br>  Como antes, podemos enviar mensagens de texto em uma notifica√ß√£o por push, mas agora voc√™ pode especificar adicionalmente chaves para localiza√ß√£o. <br><br><pre><code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"title"</span></span> : <span class="hljs-string"><span class="hljs-string">"New Mail"</span></span>, <span class="hljs-string"><span class="hljs-string">"subtitle-loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"alert_subtitle_localization_key"</span></span>, <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"alert_body_localization_key"</span></span>, } }</code> </pre> <br>  Se voc√™ especificar <code>subtitle-loc-key</code> e <code>loc-key</code> na notifica√ß√£o de carga √∫til, quando a notifica√ß√£o por push chegar ao dispositivo, os valores necess√°rios ser√£o encontrados no arquivo Localizable.string do aplicativo e o usu√°rio ver√° uma mensagem localizada. <br><br><h3>  Som e alerta cr√≠tico </h3><br>  Como antes, voc√™ pode adicionar sons √†s notifica√ß√µes de carga √∫til. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"sound"</span></span> : { <span class="hljs-string"><span class="hljs-string">"critical"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"bingbong.aiff"</span></span>, <span class="hljs-string"><span class="hljs-string">"volume"</span></span> : <span class="hljs-number"><span class="hljs-number">1.0</span></span>, } }</code> </pre> <br>  O IOS 12 tem um alerta cr√≠tico.  S√£o sons que ser√£o reproduzidos, mesmo que o usu√°rio esteja no modo N√£o perturbe. <br><br>  Normalmente, o usu√°rio n√£o precisa, por exemplo, de um aplicativo com uma assinatura de revista √† noite para informar que um novo n√∫mero foi lan√ßado.  Portanto, a Apple restringe aplicativos que podem usar alerta cr√≠tico.  Se o seu aplicativo trabalha com sa√∫de, seguran√ßa ou voc√™ acha que alerta cr√≠tico √© algo que pode realmente ajudar os usu√°rios a interagir com ele, escreva para a Apple.  Talvez eles permitam que voc√™ use essa funcionalidade. <br><br><h3>  Notifica√ß√µes silenciosas </h3><br>  O usu√°rio n√£o v√™ notifica√ß√µes silenciosas.  Eles chegam diretamente ao aplicativo, ativam e permitem executar algumas a√ß√µes para atualizar o aplicativo: envie uma solicita√ß√£o ao servidor, solicite dados em segundo plano, atualize dados do banco de dados, atualize a interface do usu√°rio para que, quando o usu√°rio entrar no aplicativo, ele veja dados atualizados. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"content-available"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">//   alert, sound  badge   payload }</span></span></code> </pre> <br>  Para que a notifica√ß√£o por push fique silenciosa, voc√™ deve especificar na carga √∫til: <code>"content-available" : 1</code> .  E n√£o especifique chaves de alerta, som e emblema na carga √∫til - elas s√£o completamente in√∫teis para notifica√ß√µes por push que n√£o ser√£o mostradas ao usu√°rio. <br><br><h3>  Agrupamento de notifica√ß√µes </h3><br>  Para agrupar mensagens, voc√™ deve especificar "ID da thread" na carga √∫til.  Pode ter v√°rios valores no mesmo aplicativo, se voc√™ deseja agrupar de maneiras diferentes: por contas, por destinat√°rios, por t√≥pico. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"thread-id"</span></span> : <span class="hljs-string"><span class="hljs-string">"any_thread_identifier"</span></span> }</code> </pre> <br>  Isso √© muito conveniente, porque agora as notifica√ß√µes por push n√£o ocupam todo o espa√ßo na tela bloqueada, mas s√£o agrupadas.  Se voc√™ ainda n√£o estiver usando essa funcionalidade, √© hora de come√ßar. <br><br><h3>  Altere a notifica√ß√£o antes de mostr√°-la </h3><br>  As notifica√ß√µes por push podem ser alteradas antes de serem exibidas.  Para fazer isso, voc√™ precisa adicionar a extens√£o de conte√∫do de notifica√ß√£o ao aplicativo e substituir o m√©todo <code>didReceive</code> .  Nesse m√©todo, voc√™ pode obter o conte√∫do da notifica√ß√£o e modific√°-lo. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"mutable-content"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: UNNotificationRequest, withContentHandler contentHandler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UNNotificationContent)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mutableContent = request.content.mutableCopy() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UNMutableNotificationContent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentHandler(request.content); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } mutableContent.subtitle = <span class="hljs-string"><span class="hljs-string">"Got it!"</span></span> contentHandler(mutableContent) }</code> </pre> <br>  Por exemplo, voc√™ pode enviar um link para o conte√∫do da m√≠dia na notifica√ß√£o, fazer o download do conte√∫do na Extens√£o e anexar o download √† notifica√ß√£o.  Depois disso, conclua a chamada com um novo contexto e mostre ao usu√°rio uma notifica√ß√£o por push estendida.  Voc√™ pode alterar o t√≠tulo, legenda etc. <br><br>  Outro caso interessante √© que voc√™ pode enviar uma notifica√ß√£o por push com um contexto criptografado, se desejar que os dados sejam protegidos adicionalmente e a Apple n√£o os tenha visto.  Na extens√£o de conte√∫do da notifica√ß√£o, voc√™ pode descriptograf√°-los e mostrar ao usu√°rio os dados j√° descriptografados. <br><br><h3>  Conte√∫do de notifica√ß√£o oculta </h3><br>  No iOS 11, tornou-se poss√≠vel ocultar o conte√∫do das notifica√ß√µes por push, e n√≥s, como desenvolvedores, n√£o podemos influenciar isso de forma alguma.  Se o usu√°rio marcou "Ocultar conte√∫do da notifica√ß√£o", de uma forma ou de outra, ele ficar√° oculto.  Tudo o que podemos fazer √© atrav√©s da UNNotificationCategory para especificar um espa√ßo reservado que ser√° exibido em vez do conte√∫do (por padr√£o, essa √© a notifica√ß√£o) e definir se o t√≠tulo ou a legenda ser√° exibido. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commentCategory = <span class="hljs-type"><span class="hljs-type">UNNotificationCategory</span></span>(identifier: <span class="hljs-string"><span class="hljs-string">"comment-category"</span></span>, actions: [], intentIdentifiers: [], hiddenPreviewsBodyPlaceholder: <span class="hljs-type"><span class="hljs-type">NSString</span></span>.localizedUserNotificationString(forKey:<span class="hljs-string"><span class="hljs-string">"COMMENT_KEY"</span></span>,arguments: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), options: [.hiddenPreviewsShowTitle])</code> </pre> <br><h3>  Etapas de notifica√ß√£o sem iniciar o aplicativo </h3><br>  Para executar a√ß√µes de notifica√ß√£o por push sem iniciar o pr√≥prio aplicativo, voc√™ precisa criar uma categoria e adicionar a√ß√£o a ela.  O identificador de categoria √© passado para o campo de categoria da notifica√ß√£o de carga √∫til.  Voc√™ pode conectar a√ß√µes diferentes a diferentes tipos de notifica√ß√µes. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"category"</span></span> : <span class="hljs-string"><span class="hljs-string">"message"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> action = <span class="hljs-type"><span class="hljs-type">UNNotificationAction</span></span>(identifier:<span class="hljs-string"><span class="hljs-string">"reply"</span></span>, title:<span class="hljs-string"><span class="hljs-string">"Reply"</span></span>, options:[]) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> category = <span class="hljs-type"><span class="hljs-type">UNNotificationCategory</span></span>(identifier: <span class="hljs-string"><span class="hljs-string">"message"</span></span>, actions: [action], minimalActions: [action], intentIdentifiers: [], options: []) <span class="hljs-type"><span class="hljs-type">UNUserNotificationCenter</span></span>.current().setNotificationCategories([category])</code> </pre> <br><h3>  Notifica√ß√µes ricas </h3><br>  Nesta extens√£o, voc√™ pode processar a√ß√µes adicionais adicionadas √† notifica√ß√£o por push e exibir a interface do usu√°rio personalizada. <br><br>  Para fazer isso, voc√™ precisa adicionar a extens√£o de conte√∫do de notifica√ß√£o ao aplicativo, definir uma classe que herda de UNNotificationContentExtension e trabalhar com ela como em um UIViewController regular. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UNNotificationContentExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userLabel: <span class="hljs-type"><span class="hljs-type">UILabel?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> notification: UNNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> content = notification.request.content <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = content.title <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userInfo = content.userInfo <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.userLabel?.text = userInfo[<span class="hljs-string"><span class="hljs-string">"video-user"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">String</span></span> } }</code> </pre> <br>  Se voc√™ estiver processando a√ß√µes personalizadas, √© importante lembrar que vale a pena atualizar essas a√ß√µes que voc√™ est√° mostrando ao usu√°rio.  N√£o √© necess√°rio tentar implementar a l√≥gica de neg√≥cios nesta extens√£o.  Envie uma solicita√ß√£o ao servidor por a√ß√£o com uma notifica√ß√£o por push no aplicativo principal e n√£o aqui.  Este local √© apenas para interface do usu√°rio. <br><br><h2>  Esquema de entrega de notifica√ß√£o por push </h2><br>  Veja o quanto voc√™ pode fazer com as notifica√ß√µes por push no iOS.  De vers√£o para vers√£o, temos cada vez mais novas funcionalidades, mas o esquema de entrega de notifica√ß√µes por push agora √© exatamente o mesmo que no iOS 3. <br><br><img src="https://habrastorage.org/webt/gt/pb/dd/gtpbdd_4eu403euuueyxscvk8bw.jpeg"><br><br>  Algu√©m poderia pensar que o esquema de entrega de notifica√ß√µes por push foi bom desde o in√≠cio, mas n√£o √©. <br><br>  Existem tr√™s n√≥s principais no esquema de entrega de notifica√ß√µes por push: <br><br><ul><li>  provedor que gera notifica√ß√µes push de carga √∫til; </li><li>  APNs - Apple Push Notification Service, que entrega uma notifica√ß√£o; </li><li>  dispositivo iOS e seu aplicativo. </li></ul><br>  Vou pular a parte sobre como se registrar, receber um token, para onde envi√°-lo.  Suponha que tenhamos tudo isso.  O que acontece depois? <br><br><ul><li>  O provedor gera uma carga √∫til e a envia para os APNs. </li><li>  APNs envia para o dispositivo. </li><li>  O usu√°rio v√™ uma mensagem push em seu dispositivo. </li></ul><br>  O Mail e muitos outros aplicativos usam um esquema avan√ßado de entrega de notifica√ß√µes por push.  √â adicionada a extens√£o do servi√ßo de notifica√ß√£o, que recebe notifica√ß√µes push com <code>"mutable-content" : 1</code> .  O provedor √© dividido em um servidor que lida com a l√≥gica de back-end do aplicativo e no pr√≥prio provedor, que gera carga √∫til e lida com assinaturas. <br><br>  No Yandex, o provedor que forma a carga √∫til √© chamado XIVA.  XIVA √© um banco de dados de assinatura.  O Mail usa o XIVA para trabalhar com notifica√ß√µes por push como uma biblioteca de terceiros. <br><br>  No Mail, o trabalho com assinaturas √© organizado de maneira n√£o trivial.  N√£o assinamos apenas o pedido de notifica√ß√µes, temos v√°rias contas.  Podemos assinar contas diferentes ou, dentro de uma conta, escolher quais pastas o usu√°rio deseja receber notifica√ß√µes e quais n√£o deseja.  XIVA lida com tudo isso.  Alguns outros servi√ßos Yandex tamb√©m funcionam com o XIVA: todas as informa√ß√µes sobre aplicativos, notifica√ß√µes, assinaturas e tokens s√£o armazenadas no XIVA. <br><br><h3>  Onde est√£o as perdas? </h3><br>  Existem quatro setas no esquema de entrega de notifica√ß√µes por push; perdas podem ocorrer em tr√™s dessas transi√ß√µes. <br><br>  <strong>Entre o servidor e o XIVA,</strong> podem ocorrer perdas no seguinte caso.  O usu√°rio recebeu uma carta, o servidor sabe disso, gera uma notifica√ß√£o e a envia para o XIVA.  Mas o XIVA pode perder essas informa√ß√µes, por exemplo, se um usu√°rio no aplicativo escolher "Inscrever-se" em uma pasta espec√≠fica enquanto estiver offline.  O XIVA n√£o receber√° informa√ß√µes sobre a assinatura da pasta e, quando chegar a carga, ela ser√° exclu√≠da e o usu√°rio n√£o ver√° a notifica√ß√£o. <br><br>  <strong>Entre XIVA e APNs</strong> , pode ocorrer perda de rede.  Dificilmente podemos afetar a rede, por isso n√£o vamos nos deter neste ponto. <br><br>  <strong>Entre APNs e extens√£o, ou APNS e iOS,</strong> se voc√™ n√£o estiver usando a extens√£o.  Este √© o tipo mais comum de perda.  Essas perdas ocorrem porque os APNs n√£o armazenam mais de um push por aplicativo no dispositivo.  Se, enquanto o usu√°rio estiver offline, ele receber v√°rias notifica√ß√µes, quando ficar online, ver√° apenas a √∫ltima mensagem. <br><br>  Essas s√£o as mesmas perdas que n√£o nos permitem garantir a entrega e dependemos de notifica√ß√µes por push.  A Apple escreve claramente que a entrega n√£o √© garantida. <br><br>  <strong>Entre o aplicativo Extension e o iOS,</strong> <strong><em>n√£o</em></strong> <strong>podem</strong> <strong><em>ocorrer</em></strong> <strong>perdas</strong> <strong>, e a Apple garante isso.</strong>  Se voc√™ usar a Extens√£o e substituir o m√©todo didReceiveContent pelo de conclus√£o, mesmo se voc√™ n√£o chamar essa conclus√£o, a notifica√ß√£o ser√° mostrada assim mesmo.  Isso √© importante lembrar.  Voc√™ n√£o pode cham√°-lo ou n√£o tem tempo para cham√°-lo, mas a notifica√ß√£o ser√° exibida sem nenhuma altera√ß√£o, na forma em que vem dos APNs. <br><br>  Veremos como lidamos com as perdas entre APNs e Extens√£o.  Mas se voc√™ precisar aumentar a capacidade de entrega de notifica√ß√µes por push, d√™ uma olhada em todo o esquema.  Verifique se h√° alguma perda no lado do servi√ßo, se o seu provedor interage normalmente com os APNs e assim por diante.  Verifique e me√ßa toda a cadeia e, em seguida, tire conclus√µes onde as perdas ocorrem mais e qual parte deste circuito deve ser modificada. <br><br><h2>  Fila de notifica√ß√£o por push </h2><br>  Nossa maneira de lidar com as perdas no pacote de APNs e extens√µes chamamos de fila de notifica√ß√£o por push. <br><br>  Se voc√™ compactar toda a hist√≥ria em uma frase, ser√°: <br><blockquote>  Se voc√™ perdeu a notifica√ß√£o por push, pode solicit√°-la novamente. </blockquote><br><img src="https://habrastorage.org/webt/mi/dl/c8/midlc81bedgy18xv4gzgmkyb7zo.jpeg"><br><br>  Em nosso esquema de entrega de notifica√ß√µes, todos os mesmos participantes s√£o: XIVA, APNs, Extens√£o.  Esquema simplificado funciona assim: <br><br><ul><li>  O XIVA numera as notifica√ß√µes por push que pretende enviar para os APNs e, somente ent√£o, envia as informa√ß√µes. </li><li>  O ramal recebe um n√∫mero de notifica√ß√£o por push 1 e, ap√≥s algum tempo, o n√∫mero 3. Ele entende que alguns dados est√£o ausentes. </li><li>  Envia para o XIVA uma solicita√ß√£o com a √∫ltima posi√ß√£o recebida, diff e solicita o envio dos dados ausentes novamente. </li><li>  O XIVA reenvia a notifica√ß√£o por push porque armazena o banco de dados de cargas e o banco de dados de assinatura.  Todas as assinaturas s√£o armazenadas por algum tempo e podem ser solicitadas novamente. </li><li>  Solicitamos novamente, recebemos uma notifica√ß√£o por push e temos no cliente todas as mensagens que o cliente deveria ter recebido. </li></ul><br>  O primeiro problema esperado √© notifica√ß√µes duplicadas.  Quando solicitamos uma mensagem da XIVA, n√£o sabemos o que est√° na fila para o envio, porque nos comunicamos com ela n√£o diretamente, mas por meio de APNs.  Suponha que vimos que algumas notifica√ß√µes estavam ausentes e enviamos uma solicita√ß√£o ao XIVA.  XIVA enviado via APNs de carga √∫til com uma notifica√ß√£o perdida.  Mas antes de receb√™-lo, recebemos outra carga √∫til e tamb√©m com um passe.  Eles perguntaram novamente - XIVA enviou novamente. <br><br>  Para que as notifica√ß√µes n√£o sejam duplicadas, usamos <strong>apns-collapse-id</strong> .  Essa configura√ß√£o permite que o lado do iOS recolha notifica√ß√µes push com o mesmo ID.  Se v√°rias notifica√ß√µes push com o mesmo apns-collapse-id tiverem chegado ao dispositivo, o iOS as recolher√° e o usu√°rio ver√° apenas uma notifica√ß√£o. <br><br><h3>  XIVA </h3><br>  Vou lhe contar como tudo funciona no XIVA, porque √© sempre curioso o que acontece no back-end. <br><br>  O XIVA existia antes da fila de notifica√ß√µes por push e era um banco de dados de assinatura.  √â importante que no banco de dados tudo tenha sido armazenado pelos usu√°rios: <br><br><ul><li>  A chave era <code>&lt;service, user&gt;</code> . </li><li>  A carga √∫til foi armazenada como valor (dados sobre cartas no caso do Mail). </li></ul><br>  O XIVA pegou os dados do banco de dados e os enviou para os APNs ou outro servi√ßo, pois funciona n√£o apenas com o iOS.  Decidimos reutiliz√°-lo. <br><br>  Viemos para a equipe de desenvolvimento do XIVA e realmente pedimos uma fila de notifica√ß√µes por push.  Em princ√≠pio, o XIVA j√° tinha tudo para isso: o banco de dados, TTL para cargas √∫teis, ou seja, eles n√£o s√£o exclu√≠dos imediatamente, podem ser encaminhados.  A √∫nica coisa que faltava era que era poss√≠vel configurar a fila de notifica√ß√µes por push como parte da implementa√ß√£o atual do XIVA - √© a numera√ß√£o de ponta a ponta. <br><br>  Para numera√ß√£o de passagem, as notifica√ß√µes por push devem ser numeradas por dispositivo e app_name.  Ou seja, a numera√ß√£o de ponta a ponta √© necess√°ria para um dispositivo espec√≠fico e para um aplicativo espec√≠fico, a fim de contar com ele no lado do cliente.  Fizemos o seguinte: reutilizamos o banco de dados XIVA, mas come√ßamos a gravar cargas √∫teis usando uma chave diferente.  Agora apns_queue atua como um servi√ßo, <code>device_id + app_name</code> como usu√°rio - os mesmos dados que precisam ser numerados no cliente, ou seja, <code>key: &lt;apns_queue, device_id + app_name&gt;</code> . <br><br>  Agora, o XIVA pega os dados do banco de dados principal e os coloca na fila quando precisa ser enviado.  Nesse momento, as cargas recebem uma nova numera√ß√£o, porque agora est√£o no mesmo banco de dados, mas com uma chave diferente.  J√° a partir de ent√£o o XIVA os retira e os envia pelos APNs.  No total, o cliente recebe a numera√ß√£o da carga √∫til necess√°ria. <br><br>  O cliente usa a extens√£o do servi√ßo de notifica√ß√£o. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: UNNotificationRequest, withContentHandler contentHandler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UNNotificationContent)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// . . . }</span></span></code> </pre> <br>  <code>didReceive</code> m√©todo <code>didReceive</code> e vemos o que veio do servidor.  N√≥s adicionamos <code>"mutable-content" : 1</code> a todas as notifica√ß√µes por push para que elas se enquadram na Extens√£o, pois, caso contr√°rio, n√£o podemos levar em considera√ß√£o nos c√°lculos. <br><br>  Al√©m disso, no c√≥digo dentro do m√©todo, h√° verifica√ß√µes cont√≠nuas: se a carga √∫til necess√°ria veio, se eles poderiam analis√°-la.  Se n√£o for analisado, essa mensagem n√£o ser√° do XIVA.  Se a mensagem n√£o for da XIVA, n√£o podemos continuar trabalhando com ela e simplesmente concluir a notifica√ß√£o com a notifica√ß√£o de APNs, n√£o realizamos c√°lculos. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payload = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payloadParser.parsePayload(from: request.content.userInfo) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     xiva contentHandler(request.content); return }</span></span></code> </pre> <br>  Registramos, verificamos se o deviceId mudou, pois sabemos que no iOS √© poss√≠vel.  Honestamente, n√£o encontramos uma altera√ß√£o no deviceId, mas apenas no caso de estarmos processando, porque se ela mudar, n√£o poderemos confiar nos n√∫meros do XIVA. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationReceived(with: payload) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastPositionDeviceId != deviceId { <span class="hljs-comment"><span class="hljs-comment">// deviceId ,    lastNotificationPosition = nil lastPositionDeviceId = deviceId }</span></span></code> </pre> <br>  Al√©m disso, examinamos se podemos receber os dados XIVA nessa carga, sejam eles ou n√£o.  Caso contr√°rio, chame contentHandler novamente. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xivaInfo = payload.xivaInfo <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentHandler(request.content); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  Se houver dados, verifique se o deviceId recebeu dados.  O XIVA envia um hash do dispositivo para a carga, se for verificado e corresponder, continuamos, n√£o, chamamos contentHandler. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> isHashCompatible(deviceId: deviceId, deviceIdHash: xivaInfo.deviceIdHash) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// payload device_id   device_id  contentHandler(request.content); return }</span></span></code> </pre> <br>  O pr√≥ximo bloco √© para ver se h√° uma posi√ß√£o salva: <br><br><ul><li>  Se n√£o temos a √∫ltima posi√ß√£o salva, ainda n√£o recebemos notifica√ß√µes e n√£o entramos no ramal ou, por algum motivo, desistimos.  Ent√£o n√£o h√° nada a ser feito para encontrar a diferen√ßa perdida, e novamente chamamos de conclus√£o. </li><li>  Se houver, siga em frente. </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastPos = lastNotificationPosition <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      lastNotificationPosition = xivaInfo.notificationPosition contentHandler(request.content); return }</span></span></code> </pre> <br>  Contamos o n√∫mero de notifica√ß√µes perdidas.  Se falta zero √© bom, n√£o perdemos nada. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> missedMessages = xivaInfo.notificationPosition - lastPos - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> missedMessages &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   push‚Äì     contentHandler(request.content); return }</span></span></code> </pre> <br>  Caso contr√°rio, extra√≠mos do XIVA os dados de posi√ß√£o - dessa mesma numera√ß√£o cont√≠nua.  Al√©m disso, analisamos se a quantidade de perda n√£o excede um determinado valor definido. <br><br><pre> <code class="swift hljs">lastNotificationPosition = xivaInfo.notificationPosition <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> missedMessages &lt;= repeatMaxCount <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,   contentHandler(buildNewNotification()); return }</span></span></code> </pre> <br>  Por que isso √© necess√°rio?  Suponha que o usu√°rio esteja offline por um longo tempo e, durante esse per√≠odo, uma centena de mensagens tenha sido acumulada.  Solicitaremos centenas inteiras (√© f√°cil para n√≥s), o XIVA enviar√° centenas inteiras e o usu√°rio receber√° todas as notifica√ß√µes.  Mesmo se os agruparmos por ID de thread (e os agruparmos), do mesmo modo, para cada notifica√ß√£o, essa Extens√£o ser√° chamada, todas as verifica√ß√µes ser√£o aprovadas.  Parece improv√°vel que o usu√°rio precise de todas as cem notifica√ß√µes.  Portanto, geramos uma notifica√ß√£o na qual escrevemos que voc√™ tem 100 mensagens perdidas, acessa o aplicativo e olha.  E mostramos ao usu√°rio exatamente esta mensagem, porque podemos substituir as notifica√ß√µes por push. <br><br>  Quando todas as verifica√ß√µes s√£o aprovadas, enviamos uma solicita√ß√£o √† XIVA: a √∫ltima posi√ß√£o que chegou at√© n√≥s e o n√∫mero de mensagens perdidas.  E olha: <br><br><ul><li>  Se o XIVA respondeu com √™xito: ‚ÄúEst√° tudo bem, enviarei os dados‚Äù, mostramos ao usu√°rio a notifica√ß√£o atual e aguardamos at√© que o XIVA envie todo o resto e o usu√°rio veja todas as mensagens perdidas. </li><li>  Se o XIVA responder com um erro, mostramos ao usu√°rio uma notifica√ß√£o personalizada de que ele perdeu mensagens que podem ser exibidas no aplicativo. </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.requestMissedNotifications(lastPosition: xivaInfo.notificationPosition, gap: missedMessages) { result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> result.onValue { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationProcessed(with: .success) contentHandler(request.content) }.onError { error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationProcessed(with: .failure(error)) contentHandler(buildNewNotification()) } }</code> </pre> <br>  Assim, a implementa√ß√£o no cliente se resume a um grande n√∫mero de verifica√ß√µes nas quais descobrimos se podemos trabalhar com os dados recebidos. <br><br><h2>  Log e outras dificuldades </h2><br>  Como voc√™ sabe, para garantir que a abordagem funcione bem, √© necess√°rio fazer logon.  Come√ßamos a coletar estat√≠sticas sobre um novo m√©todo para entregar notifica√ß√µes e comparar como a capacidade de entrega mudou. <br><br><h3>  Limita√ß√µes da extens√£o push </h3><br>  A primeira coisa que encontramos s√£o as restri√ß√µes de extens√£o push. <br><br>  <strong>Nem sempre √© chamado</strong> .  Se voc√™ desativar o desenho da notifica√ß√£o nas configura√ß√µes do aplicativo (a capacidade de receber uma notifica√ß√£o permanece ativada, mas todas as renderiza√ß√µes poss√≠veis est√£o desativadas), o Extension n√£o ser√° chamado - toda a l√≥gica com recontagens e, mais importante, o log n√£o ser√£o chamados.  N√£o conseguiremos descobrir o que √© mais importante para n√≥s - se o usu√°rio recebeu uma notifica√ß√£o. <br><br>  <strong>A extens√£o push tem um limite de tempo</strong> .  A documenta√ß√£o da Apple diz que em cerca de 30 segundos voc√™ precisar√° concluir a chamada com uma notifica√ß√£o modificada, caso contr√°rio, a notifica√ß√£o inicial ser√° exibida. <br><br>  Eu me pergunto como descobrimos isso.  Implementamos um recurso que chamamos de notifica√ß√µes push ‚Äúbonitas‚Äù, anexamos elementos de m√≠dia √†s notifica√ß√µes, alteramos o t√≠tulo, a legenda.  Durante o teste, algumas notifica√ß√µes por push ficaram lindas, enquanto o restante como patinhos feios permaneceu. <br><br>  Come√ßamos a observar a diferen√ßa entre essas notifica√ß√µes push e descobrimos que n√£o havia diferen√ßa, apenas para algumas que conseguimos chamar de conclus√£o, mas para outras n√£o. ,   , push-     ,     APNs. <br><br> <strong>  ‚Äî  </strong> . Apple ,  ,   push-extension, ,        ,     .   ,    12 . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apple Developer Forum</a>   ,   ,        .     ,     ‚Äî 10 . <br><br>     ,   .      AppMetrica.   , AppMetrica     ,   Extension   .      ,  -   . <br><br>     :    Extension   . <br><br><h3>   </h3><br>    push-extension    UserDefaults. ,    ,     AppMetrica. <br><br>     .      .   ,          ,      .          ,          .         ,   XIVA (  ),  ,   . <br><br>  ,  Notification Extension   iOS 10  ,       Extension,       ,     . <br><br> <strong> </strong> <strong>AppMetrica</strong> :      , push-extension      .  AppMetrica   push-,   ,             .   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppMetrica Push SDK</a> . <br><br> ,   .    ‚Äî   ,   .   ,   . <br><br><img src="https://habrastorage.org/webt/tg/k_/nk/tgk_nkvmus8kud-brgg6v9jvmhm.jpeg"><br><br>   ‚Äî   ,      ,     . <br><br>  ,     push-,   ,        ‚Äî   . <br><br>  ,  ,     .      , ‚Ä¶ <br><br><h2>  </h2><br>   :  , ,  .   ,  ?   -  ,     push-?  ,        ?    user experience   ? <br><br><blockquote>       ,       2‚Äì3‚Äì20  ? <br></blockquote><br> , ,  ,  ,  ,   ,  ,  .           ,      push-. ,     . <br><br><h2>  Sum√°rio </h2><br> <strong>Push-  iOS   .</strong>             ,    .. ,    . <br><br> <strong> push-  ( ) .</strong>       .  XIVA. ,     ,     . ,  ,      . ! <br><br> <strong>   push-extension.</strong>     ,    . ,   . <br><br> <strong>,     .</strong> ,     , ,    ,    -  . ,   push-           . , ,      ,      App Store,     ,   ! <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppsConf</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,     21  22      ,        ..        50 ,     .  1   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a>      ,       ‚Äî . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462507/">https://habr.com/ru/post/pt462507/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462493/index.html">DBMS multimodal - a base dos sistemas de informa√ß√£o modernos?</a></li>
<li><a href="../pt462495/index.html">Eventos digitais em Moscou de 05 a 11 de agosto</a></li>
<li><a href="../pt462501/index.html">Por que preciso da minha pr√≥pria autoridade de certifica√ß√£o</a></li>
<li><a href="../pt462503/index.html">Quais s√£o os ‚Äúsinais de ouro‚Äù do monitoramento e do SRE?</a></li>
<li><a href="../pt462505/index.html">N√£o me engane com sua programa√ß√£o funcional</a></li>
<li><a href="../pt462509/index.html">Product Fest - confer√™ncia de gerenciamento de produtos de TI √† qual voc√™ deseja ir</a></li>
<li><a href="../pt462511/index.html">Google Play Instant√¢neo. Refatora√ß√£o ao longo da vida</a></li>
<li><a href="../pt462513/index.html">Realoca√ß√£o: prepara√ß√£o, sele√ß√£o, desenvolvimento do territ√≥rio</a></li>
<li><a href="../pt462515/index.html">Erros ao trabalhar com o teclado do sistema</a></li>
<li><a href="../pt462519/index.html">O livro "Microsservi√ßos. Padr√µes de desenvolvimento e refatora√ß√£o ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>