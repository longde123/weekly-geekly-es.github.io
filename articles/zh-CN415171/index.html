<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖥️ 😘 📘 Go中的反射定律 🔐 🎒 🤲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我向您介绍语言创建者的文章“反射定律”的译文。 

 反思是程序探索自身结构的能力，尤其是通过类型。 这是元编程的一种形式，也是造成混乱的主要原因。 
 在Go中，反射被广泛使用，例如在test和fmt软件包中。 在本文中，我们将通过解释反射在Go中的工作原理来摆脱“魔力”。 

 类型和...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go中的反射定律</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415171/"> 哈Ha！ 我向您介绍语言创建者的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“反射定律”</a>的译文。 <br><br> 反思是程序探索自身结构的能力，尤其是通过类型。 这是元编程的一种形式，也是造成混乱的主要原因。 <br> 在Go中，反射被广泛使用，例如在test和fmt软件包中。 在本文中，我们将通过解释反射在Go中的工作原理来摆脱“魔力”。 <br><a name="habracut"></a><br><h3> 类型和接口 </h3><br> 由于反射基于类型系统，因此让我们重新了解Go中的类型知识。 <br>  Go是静态类型的。 每个变量在编译时只有一个固定的静态类型： <code>int, float32, *MyType, []byte</code> ...如果声明： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j MyInt</code> </pre> <br> 那么<code>i</code>的类型是<code>int</code>而<code>j</code>的类型是<code>MyInt</code> 。 变量<code>i</code>和<code>j</code>具有不同的静态类型，尽管它们具有相同的基本类型，但是如果不进行转换就无法将它们彼此分配。 <br><br> 接口是重要的类型类别之一，它们是固定的方法集。 接口可以存储任何特定（非接口）值，只要该值实现接口的方法即可。 一对著名的示例是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">io.Reader和io.Writer</a> ，它们是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">io包中</a>的Reader和Writer类型： <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Reader -  ,    Read(). type Reader interface { Read(p []byte) (n int, err error) } // Writer -  ,    Write(). type Writer interface { Write(p []byte) (n int, err error) }</span></span></code> </pre> <br> 据说，任何使用此签名实现<code>Read()</code>或<code>Write()</code>方法的<code>io.Writer</code>分别实现<code>io.Reader</code>或<code>io.Writer</code> 。 这意味着<code>io.Reader</code>类型的变量可以包含Read（）类型的任何值： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader r = os.Stdin r = bufio.NewReader(r) r = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(bytes.Buffer)</code> </pre> <br> 重要的是要了解可以为<code>r</code>分配实现<code>io.Reader</code>任何值。  Go是静态类型的，而静态类型<code>r</code>是<code>io.Reader</code> 。 <br><br> 接口类型的一个非常重要的例子是空接口： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}</code> </pre> <br> 它是∅方法的空集，并且可以通过任何值实现。 <br> 有人说Go接口是动态类型化的变量，但这是一个谬论。 它们是静态类型的：具有接口类型的变量始终具有相同的静态类型，并且尽管在运行时存储在接口变量中的值可以更改类型，但此值将始终满足接口。  （没有<code>undefined</code> ， <code>NaN</code>或其他破坏程序逻辑的东西。） <br><br> 必须理解这一点-反射和接口密切相关。 <br><br><h3> 接口的内部表示 </h3><br>  Russ Cox写了一篇详细的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客文章，</a>内容涉及在Go中设置界面。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于哈布雷的</a>文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">也不少</a> 。 无需重复整个故事，主要要点已提及。 <br><br> 接口类型变量具有一对：分配给该变量的特定值，以及该值的类型描述符。 更确切地说，值是实现接口的基本数据元素，类型描述了此元素的完整类型。 例如，之后 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader tty, err := os.OpenFile(<span class="hljs-string"><span class="hljs-string">"/dev/tty"</span></span>, os.O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } r = tty</code> </pre> <br>  <code>r</code>示意地包含一对<code>(, ) --&gt; (tty, *os.File)</code> 。 注意<code>*os.File</code>类型实现了<code>Read()</code>之外的方法； 即使接口值仅提供对Read（）方法的访问，该值也包含有关该值类型的所有信息。 这就是为什么我们可以做这样的事情： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w io.Writer w = r.(io.Writer)</code> </pre> <br> 此分配中的表达式是一个类型语句； 它声称<code>r</code>内的元素也实现了<code>io.Writer</code> ，因此我们可以将其分配给<code>w</code> 。 分配后， <code>w</code>将包含一对<code>(tty, *os.File)</code> 。 这与<code>r</code>对相同。 接口的静态类型确定可以在接口变量上调用哪些方法，尽管更广泛的方法集可以在内部具有特定值。 <br><br> 继续，我们可以执行以下操作： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> empty <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} empty = w</code> </pre> <br> 并且empty字段的empty值将再次包含同一对<code>(tty, *os.File)</code> 。 这很方便：空接口可以包含任何值以及我们从中需要的所有信息。 <br><br> 这里我们不需要类型断言，因为已知<code>w</code>满足空接口。 在将值从<code>Reader</code>传输到<code>Writer</code>的示例中，我们需要显式使用类型断言，因为<code>Writer</code>方法不是<code>Reader</code>的子集。 尝试转换与接口不匹配的值会引起恐慌。 <br><br> 一个重要的细节是，接口内的一对始终具有形式（值，特定类型），而不能具有形式（值，接口）。 接口不支持将接口作为值。 <br><br> 现在我们准备研究反思。 <br><br><h3>  <s>反射</s>的第一定律反映 </h3><br><ul><li> 反射从界面延伸到对象的反射。 </li></ul><br> 从根本上讲，反射只是一种检查存储在接口变量内的类型和值对的机制。 首先，我们需要了解两种类型： <code>reflect.Type</code>和<code>reflect.Value</code> 。 这两种类型提供对接口变量内容的访问，并分别由简单函数reflect.TypeOf（）和reflect.ValueOf（）返回。 它们从接口的含义中提取部分。  （此外， <code>reflect.Value</code>容易获得<code>reflect.Type</code> ，但是现在我们不要混合使用<code>Value</code>和<code>Type</code>的概念。） <br><br> 让我们从<code>TypeOf()</code>开始： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"reflect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, reflect.TypeOf(x)) }</code> </pre> <br> 程序将输出 <br> <code>type: float64</code> <br> <br> 该程序类似于将简单变量<code>float64 x</code>传递给<code>reflect.TypeOf()</code> 。 您看到界面了吗？ 它是-根据函数声明， <code>reflect.TypeOf()</code>接受一个空接口： <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TypeOf()  reflect.Type    . func TypeOf(i interface{}) Type</span></span></code> </pre> <br> 当我们调用<code>reflect.TypeOf(x)</code> ， <code>x</code>首先存储在一个空接口中，然后将其作为参数传递；  <code>reflect.TypeOf()</code>解压缩此空接口以恢复类型信息。 <br><br> 当然， <code>reflect.ValueOf()</code>函数会还原值（在下文中，我们将忽略模板，并专注于代码）： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, reflect.ValueOf(x).String())</code> </pre> <br> 将打印 <br> <code>value: &lt;float64 Value&gt;</code> <br>  （我们明确地调用<code>String()</code>方法，因为默认情况下，fmt包会解压缩以<code>reflect.Value</code>值并输出特定值。） <br>  <code>reflect.Type</code>和<code>reflect.Value</code>都有很多方法，使您可以探索和修改它们。 一个重要的示例是<code>reflect.Value</code>具有一个<code>Type()</code>方法，该方法返回值的类型。  <code>reflect.Type</code>和<code>reflect.Value</code>有一个<code>Kind()</code>方法，该方法返回一个常量，该常量指示要存储的原始元素： <code>Uint, Float64, Slice</code> ...这些常量在反射包中的枚举中声明。 名称为<code>Int()</code>和<code>Float()</code> <code>Value</code>方法使我们能够提取包含在其中的值（例如int64和float64）： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is float64:"</span></span>, v.Kind() == reflect.Float64) fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, v.Float())</code> </pre> <br> 将打印 <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: float64 kind <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> float64: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">3.4</span></span></code> </pre> <br> 还有一些方法，例如<code>SetInt()</code>和<code>SetFloat()</code> ，但是要使用它们，我们需要了解可沉降性，这是反射第三定律的主题。 <br><br> 反射库具有几个需要突出显示的属性。 首先，为了使API保持简单，“ getter”和“ setter” <code>Value</code>方法作用于可以包含值的最大类型：所有有<code>int64</code>整数的<code>int64</code> 。 也就是说， <code>Value</code>值的<code>Int()</code>方法返回<code>int64</code> ，而<code>SetInt()</code>值采用<code>int64</code> ； 可能需要转换为实际类型： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> = <span class="hljs-string"><span class="hljs-string">'x'</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is uint8: "</span></span>, v.Kind() == reflect.Uint8) x = <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>(v.Uint()) <span class="hljs-comment"><span class="hljs-comment">// v.Uint  uint64.</span></span></code> </pre> <br> 将是 <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> kind is <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br> 这里<code>v.Uint()</code>将返回<code>uint64</code> ，需要一个显式的类型声明。 <br><br> 第二个属性是对象的<code>Kind()</code>反映的是基本类型，而不是静态类型。 如果反射对象包含用户定义的整数类型的值，例如 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x MyInt = <span class="hljs-number"><span class="hljs-number">7</span></span> v := reflect.ValueOf(x) <span class="hljs-comment"><span class="hljs-comment">// v   Value.</span></span></code> </pre> <br>  <code>v.Kind() == reflect.Int</code> ，尽管<code>x</code>的静态类型是<code>MyInt</code> ，而不是<code>int</code> 。 换句话说， <code>MyInt</code> <code>Type()</code> <code>MyInt</code> ， <code>Kind()</code>无法将<code>int</code>与<code>MyInt</code>区分开。  <code>Kind</code>只能接受内置类型的值。 <br><br><h3>  <s>反射</s>第二定律反映 </h3><br><ul><li> 反射从反射对象延伸到界面。 </li></ul><br> 就像物理反射一样，Go中的反射也会产生相反的效果。 <br><br> 有了<code>reflect.Value</code> ，我们可以使用<code>Interface()</code>方法恢复接口的值； 该方法将类型和值信息打包回接口，并返回结果： <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Interface   v  interface{}. func (v Value) Interface() interface{}</span></span></code> </pre>  bvt <br> 例如： <br><br><pre> <code class="go hljs">y := v.Interface().(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>) <span class="hljs-comment"><span class="hljs-comment">// y   float64. fmt.Println(y)</span></span></code> </pre> <br> 打印由反射对象<code>v</code>表示的<code>float64</code>的值。 <br> 但是，我们可以做得更好。 如前面的示例一样， <code>fmt.Println()</code>和<code>fmt.Printf()</code>中的参数作为空接口传递，然后由fmt包在内部对其进行解压缩。 因此，正确打印<code>reflect.Value</code>内容所需<code>reflect.Value</code>就是将<code>Interface()</code>方法的结果传递给格式化的输出函数： <br><br><pre> <code class="go hljs">fmt.Println(v.Interface())</code> </pre> <br>  （为什么不使用<code>fmt.Println(v)</code> ？因为<code>v</code>的类型为<code>reflect.Value</code> ；我们希望获取包含在其中的值。）由于我们的值是<code>float64</code> ，因此，如果需要，我们甚至可以使用浮点格式： <br><br><pre> <code class="go hljs">fmt.Printf(<span class="hljs-string"><span class="hljs-string">"value is %7.1e\n"</span></span>, v.Interface())</code> </pre> <br> 将在特定情况下输出 <br> <code>3.4e+00</code> <br> <br> 同样，无需<code>v.Interface()</code>结果类型<code>v.Interface()</code>为<code>float64</code> ； 空接口值包含有关特定值的信息，而<code>fmt.Printf()</code>还原该值。 <br> 简而言之， <code>Interface()</code>方法与<code>ValueOf()</code>函数相反，但其结果始终是静态类型<code>interface{}</code> 。 <br><br> 重复：反射从接口值扩展到反射对象，反之亦然。 <br><br><h3>  <s>反射</s>第三定律反射 </h3><br><ul><li> 要更改反射对象，该值必须可设置。 </li></ul><br> 第三定律是最微妙和令人困惑的。 我们从第一个原则开始。 <br> 此代码无效，但值得关注。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br> 如果运行此代码，它将因紧急消息而崩溃，并显示一条关键消息： <br> <code>panic: reflect.Value.SetFloat   </code> <br> 问题不在于字面意义<code>7.1</code>没有得到解决。 这是<code>v</code>无法安装的内容。 可设置性是<code>reflect.Value</code>的属性，并非每个<code>reflect.Value</code>都有它。 <br>  <code>reflect.Value.CanSet()</code>方法<code>reflect.Value.CanSet()</code>正在设置<code>reflect.Value.CanSet()</code> ； 在我们的情况下： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br> 将打印： <br> <code>settability of v: false</code> <br> <br> 在非托管值上调用<code>Set()</code>方法时发生错误。 但是什么是可安装性？ <br><br> 可持续性有点像寻址能力，但是更严格。 这是反射对象可以更改用于创建反射对象的存储值的属性。 可持续性由反射对象包含源元素还是仅包含源元素来确定。 当我们写： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x)</code> </pre> <br> 我们将<code>x</code>的副本传递给<code>reflect.ValueOf()</code> ，因此将接口创建为<code>reflect.ValueOf()</code>的参数-这是<code>x</code>的副本，而不是<code>x</code>本身。 因此，如果声明： <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>)</code> </pre> <br> 如果执行，它将不会更新<code>x</code> ，尽管<code>v</code>看起来好像是从<code>x</code>创建的。 相反，他将更新存储在<code>v</code>值内的<code>x</code>的副本，并且<code>x</code>本身不会受到影响。 禁止这样做以免引起问题，可安装性是用于防止问题的属性。 <br><br> 这似乎并不奇怪。 这是穿不寻常衣服的普遍情况。 考虑将<code>x</code>传递给函数： <br> <code>f(x)</code> <br> <br> 我们不希望<code>f()</code>能够更改<code>x</code> ，因为我们传递了<code>x</code>值的副本，而不是<code>x</code>本身。 如果我们希望<code>f()</code>直接更改<code>x</code> ，则必须将指向<code>x</code>的指针传递给我们的函数： <br> <code>f(&amp;x)</code> <br> <br> 这是直接且熟悉的，并且反射的工作方式与此类似。 如果要使用反射来更改<code>x</code> ，则必须为反射库提供指向要更改的值的指针。 <br><br> 来吧 首先，我们照常初始化<code>x</code> ，然后创建一个指向它的<code>reflect.Value p</code> 。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> p := reflect.ValueOf(&amp;x) <span class="hljs-comment"><span class="hljs-comment">//   x. fmt.Println("type of p:", p.Type()) fmt.Println("settability of p:", p.CanSet())</span></span></code> </pre> <br> 将输出 <br> <code>type of p: *float64 <br> settability of p: false</code> <br> <br> 不能设置反射对象<code>p</code> ，但是它不是我们要设置的<code>p</code> ，而是指针<code>*p</code> 。 为了获得<code>p</code>指向的内容，我们调用<code>Value.Elem()</code>方法，该方法通过指针间接获取值，并将结果存储在<code>reflect.Value v</code> ： <br><br><pre> <code class="go hljs">v := p.Elem() fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br> 现在<code>v</code>是一个可安装的对象； <br> <code>settability of v: true</code> <br> 并且由于它表示<code>x</code> ，我们最终可以使用<code>v.SetFloat()</code>来更改<code>x</code>的值： <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) fmt.Println(v.Interface()) fmt.Println(x)</code> </pre> <br> 结论如预期 <br> <code>7.1 <br> 7.1</code> <br>  Reflect可能很难理解，但是它确实可以完成语言的工作，尽管可以借助<code>reflect.Type</code>和<code>reflect.Type</code>来隐藏正在发生的事情。 请记住， <code>reflection.Value</code>需要变量的地址才能对其进行更改。 <br><br><h3> 结构体 </h3><br> 在我们之前的示例中， <code>v</code>不是指针，而是从其派生的。 创建这种情况的一种常见方法是使用反射来更改结构字段。 只要有了结构的地址，就可以更改其字段。 <br><br> 这是一个简单的示例，它分析结构<code>t</code>的值。 我们使用结构的地址创建一个反射对象，以便以后对其进行修改。 然后将typeOfT设置为其类型，并使用简单的方法调用遍历字段（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关详细说明，</a>请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">软件包</a> ）。 请注意，我们正在从结构类型中提取字段名称，但是字段本身是常规的<code>reflect.Value</code> 。 <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } t := T{<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-string"><span class="hljs-string">"skidoo"</span></span>} s := reflect.ValueOf(&amp;t).Elem() typeOfT := s.Type() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; s.NumField(); i++ { f := s.Field(i) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%d: %s %s = %v\n"</span></span>, i, typeOfT.Field(i).Name, f.Type(), f.Interface()) }</code> </pre> <br> 程序将输出 <br> <code>0: A int = 23 <br> 1: B string = skidoo</code> <br> 这里显示了有关可安装性的另一点：大写字母<code>T</code>字段的名称（已导出），因为只能设置导出的字段。 <br> 由于<code>s</code>包含可安装的反射对象，因此我们可以更改结构字段。 <br><br><pre> <code class="go hljs">s.Field(<span class="hljs-number"><span class="hljs-number">0</span></span>).SetInt(<span class="hljs-number"><span class="hljs-number">77</span></span>) s.Field(<span class="hljs-number"><span class="hljs-number">1</span></span>).SetString(<span class="hljs-string"><span class="hljs-string">"Sunset Strip"</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"t is now"</span></span>, t)</code> </pre> <br> 结果： <br> <code>t is now {77 Sunset Strip}</code> <br> 如果更改程序以便从<code>t</code>而不是<code>&amp;t</code>创建<code>&amp;t</code> ，则对<code>SetInt()</code>和<code>SetString()</code>的调用<code>SetInt()</code>紧急方式结束，因为无法设置字段<code>t</code> 。 <br><br><h3> 结论 </h3><br> 回顾反射定律： <br><br><ul><li> 反射从界面延伸到对象的反射。 </li><li> 反射从对象的反射延伸到界面。 </li><li> 要更改反射对象，必须设置该值。 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">罗伯·派克</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rob Pike）</a>发表。 <br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/2q/04/ha/2q04hardrnhhnrnuyb6dk0quvue.png" width="350"></a> </div> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415171/">https://habr.com/ru/post/zh-CN415171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415159/index.html">DevOps会议DevOops 2018的公告</a></li>
<li><a href="../zh-CN415163/index.html">在俄罗斯某些地方受特别保护和特别屏蔽的制药厂中的无线网络</a></li>
<li><a href="../zh-CN415165/index.html">Node.js 10.5版本：开箱即用的多线程</a></li>
<li><a href="../zh-CN415167/index.html">公开课“ Java多线程。 基本同步原语»</a></li>
<li><a href="../zh-CN415169/index.html">压缩和重复数据删除：使用ZxPowerstore winter减少邮件归档和备份的大小</a></li>
<li><a href="../zh-CN415175/index.html">增广世博会成员访谈</a></li>
<li><a href="../zh-CN415177/index.html">欢迎光临</a></li>
<li><a href="../zh-CN415181/index.html">[叶卡捷琳堡，公告]分析师Mitap-有关第一位分析师和CBAP，指标，公共部门和分析师类型的信息</a></li>
<li><a href="../zh-CN415183/index.html">自定义脚本的跨浏览器Web扩展第1部分</a></li>
<li><a href="../zh-CN415185/index.html">3CX WebMeeting免费视频会议：功能概述</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>