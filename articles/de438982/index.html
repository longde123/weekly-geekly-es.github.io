<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏻 ⭕️ 🐫 Kubernetes-Handbuch, Teil 1: Anwendungen, Microservices und Container ‼️ 👨‍👧 👨🏾‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auf unsere Bitte hin hat Habr den Kubernetes- Hub erstellt und wir freuen uns, die erste Veröffentlichung darin zu veröffentlichen. Abonnieren! 
 Kube...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes-Handbuch, Teil 1: Anwendungen, Microservices und Container</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/438982/"><blockquote>  Auf unsere Bitte hin hat Habr den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes-</a> Hub erstellt und wir freuen uns, die erste Veröffentlichung darin zu veröffentlichen.  Abonnieren! </blockquote><br>  Kubernetes ist einfach.  Warum zahlen mir Banken viel Geld für die Arbeit in diesem Bereich, während jeder diese Technologie in nur wenigen Stunden beherrschen kann? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/d3/4l/ic/d34licaikjsxfxisetkc9arcpdi.jpeg"></a> <br><a name="habracut"></a><br>  Wenn Sie Zweifel haben, dass Kubernetes so schnell erlernt werden kann, empfehle ich Ihnen, es selbst zu versuchen.  Nachdem Sie dieses Material beherrschen, können Sie die Anwendung basierend auf Microservices im Kubernetes-Cluster ausführen.  Ich kann dies garantieren, da ich Kubernetes gerade durch die hier verwendete Methodik für die Arbeit mit unseren Kunden schule.  Was unterscheidet dieses Handbuch von anderen?  In der Tat - viele Dinge.  Die meisten dieser Materialien beginnen also mit einer Erklärung einfacher Dinge - Konzepte von Kubernetes und Funktionen des kubectl-Teams.  Die Autoren dieser Materialien glauben, dass ihr Leser mit Anwendungsentwicklung, Microservices und Docker-Containern vertraut ist.  Wir werden den anderen Weg gehen.  Lassen Sie uns zunächst darüber sprechen, wie eine Anwendung basierend auf Microservices auf einem Computer ausgeführt wird.  Betrachten Sie dann die Zusammenstellung von Containerbildern für jeden Mikrodienst.  Danach lernen wir Kubernetes kennen und analysieren die Bereitstellung einer Microservice-basierten Anwendung in einem von Kubernetes verwalteten Cluster. <br><br>  Ein solcher Ansatz mit einer schrittweisen Herangehensweise an Kubernetes vermittelt die Tiefe des Verständnisses, das einem gewöhnlichen Menschen widerfährt, um zu verstehen, wie einfach alles in Kubernetes angeordnet ist.  Kubernetes ist natürlich eine einfache Technologie, vorausgesetzt, jeder, der sie lernen möchte, weiß, wo und wie sie verwendet wird. <br><br>  Lassen Sie uns nun ohne weiteres an die Arbeit gehen und über die Anwendung sprechen, mit der wir arbeiten werden. <br><br><h2>  <font color="#3AC1EF">Experimentelle Anwendung</font> </h2><br>  Unsere Anwendung wird nur eine Funktion ausführen.  Es akzeptiert als Eingabe einen Satz und führt dann unter Verwendung der Textanalyse eine Stimmungsanalyse dieses Satzes durch, wobei eine Schätzung der emotionalen Einstellung des Verfassers des Satzes zu einem bestimmten Objekt erhalten wird. <br><br>  So sieht das Hauptfenster dieser Anwendung aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/7e1/415/6747e14151585819867c880f52fa9d21.gif"></div><br>  <i><font color="#999999">Webanwendung zur Analyse der Textstimmung</font></i> <br><br>  Aus technischer Sicht besteht die Anwendung aus drei Mikrodiensten, von denen jeder eine bestimmte Reihe von Aufgaben löst: <br><br><ul><li>  SA-Frontend ist ein Nginx-Webserver, der statische React-Dateien bereitstellt. </li><li>  SA-WebApp ist eine Java-basierte Webanwendung, die Anforderungen vom Front-End verarbeitet. </li><li>  SA-Logic ist eine Python-Anwendung, die eine Analyse der Textstimmung durchführt. </li></ul><br>  Es ist wichtig zu beachten, dass Microservices nicht isoliert existieren.  Sie setzen die Idee der "Aufgabentrennung" um, müssen jedoch miteinander interagieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/f93/0c0/94bf930c03220c1eec6957a0f7308046.gif"></div><br>  <i><font color="#999999">Anwendungsdatenströme</font></i> <br><br>  In der obigen Abbildung sehen Sie die nummerierten Stufen des Systems und veranschaulichen die Datenflüsse in der Anwendung.  Analysieren wir sie: <br><br><ol><li> Der Browser fordert die Datei <code>index.html</code> vom Server an (der seinerseits das React-Anwendungspaket herunterlädt). </li><li>  Der Benutzer interagiert mit der Anwendung. Dadurch wird eine auf Spring basierende Webanwendung aufgerufen. </li><li>  Die Webanwendung leitet die Anforderung zur Textanalyse an die Python-Anwendung weiter. </li><li>  Die Python-Anwendung analysiert die Tonalität des Textes und gibt das Ergebnis als Antwort auf die Anforderung zurück. </li><li>  Die Spring-Anwendung sendet eine Antwort an die React-Anwendung (und zeigt dem Benutzer wiederum das Ergebnis der Textanalyse an). </li></ol><br>  Den Code für alle diese Anwendungen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Ich empfehle Ihnen, dieses Repository jetzt in sich selbst zu kopieren, da noch viele interessante Experimente damit vor uns liegen. <br><br><h2>  <font color="#3AC1EF">Starten einer Microservice-basierten Anwendung auf einem lokalen Computer</font> </h2><br>  Damit die Anwendung funktioniert, müssen alle drei Microservices ausgeführt werden.  Beginnen wir mit dem süßesten von ihnen - mit der Front-End-Anwendung. <br><br><h3>  <font color="#3AC1EF">▍Konfigurieren Reagieren Sie auf die lokale Entwicklung</font> </h3><br>  Um die React-Anwendung ausführen zu können, müssen Sie die Plattformen Node.js und NPM auf Ihrem Computer installieren.  Nachdem Sie dies alles installiert haben, gehen Sie über das Terminal zum <code>sa-frontend</code> Projektordner und führen Sie den folgenden Befehl aus: <br><br><pre> <code class="plaintext hljs">npm install</code> </pre> <br>  Dank der Ausführung dieses Befehls werden Abhängigkeiten der React-Anwendung, deren Einträge sich in der Datei <code>package.json</code> befinden, in den Ordner <code>node_modules</code> geladen.  Führen Sie den folgenden Befehl aus, nachdem die Abhängigkeiten in denselben Ordner heruntergeladen wurden: <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Das ist alles.  Jetzt wird die React-Anwendung ausgeführt. Der Zugriff darauf kann über die Adresse <code>localhost:3000</code> im Browser erfolgen.  Sie können etwas in seinem Code ändern.  Sie werden die Auswirkungen dieser Änderungen sofort im Browser sehen.  Dies ist möglich durch den sogenannten "heißen" Austausch von Modulen.  Dank dessen wird die Front-End-Entwicklung zu einer einfachen und unterhaltsamen Aufgabe. <br><br><h3>  <font color="#3AC1EF">▍Vorbereitung einer React-Anwendung für die Ausgabe an die Produktion</font> </h3><br>  Für die tatsächliche Verwendung der React-Anwendung müssen wir sie in eine Reihe statischer Dateien konvertieren und sie über einen Webserver an Clients weitergeben. <br><br>  Um die React-Anwendung erneut über das Terminal zu erstellen, <code>sa-frontend</code> Ordner <code>sa-frontend</code> und führen Sie den folgenden Befehl aus: <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> <br>  Dadurch wird ein <code>build</code> Verzeichnis im Projektordner erstellt.  Es enthält alle statischen Dateien, die für die Funktion der React-Anwendung erforderlich sind. <br><br><h3>  <font color="#3AC1EF">▍Servieren statischer Dateien mit Nginx-Tools</font> </h3><br>  Zuerst müssen Sie den Nginx-Webserver installieren und ausführen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier können</a> Sie es herunterladen und Anweisungen zur Installation und zum Start finden.  Anschließend müssen Sie den Inhalt des Ordners <code>sa-frontend/build</code> Ordner <code>[your_nginx_installation_dir]/html</code> . <br><br>  Bei diesem Ansatz ist die beim Erstellen der React-Anwendung generierte Datei <code>index.html</code> <code>[your_nginx_installation_dir]/html/index.html</code> .  Dies ist die Datei, die der Nginx-Server standardmäßig beim Zugriff ausgibt.  Der Server ist so konfiguriert, dass er Port <code>80</code> <code>[your_nginx_installation_dir]/conf/nginx.conf</code> . Sie können ihn jedoch nach Bedarf konfigurieren, indem Sie die Datei <code>[your_nginx_installation_dir]/conf/nginx.conf</code> . <br><br>  Öffnen Sie nun Ihren Browser und gehen Sie zu <code>localhost:80</code> .  Sie sehen die Seite Anwendung reagieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a50/b83/f39/a50b83f390ff0434ef817f357a041941.png"></div><br>  <i><font color="#999999">Von Nginx Server bereitgestellte Anwendung reagieren</font></i> <br><br>  Wenn Sie jetzt etwas in das Feld <code>Type your sentence</code> eingeben eingeben und auf die Schaltfläche <code>Send</code> klicken, geschieht nichts.  Wenn Sie sich jedoch die Konsole ansehen, werden dort Fehlermeldungen angezeigt.  Um genau zu verstehen, wo diese Fehler auftreten, analysieren wir den Anwendungscode. <br><br><h3>  <font color="#3AC1EF">▍Analyse des Front-End-Anwendungscodes</font> </h3><br>  <code>App.js</code> wir uns den Code der Datei <code>App.js</code> , können wir sehen, dass durch Klicken auf die Schaltfläche <code>Send</code> die Methode <code>analyzeSentence()</code> wird.  Der Code für diese Methode ist unten angegeben.  Beachten Sie gleichzeitig, dass für jede Zeile, für die ein Kommentar des Formulars <code># </code> vorhanden ist, eine Erklärung unter dem Code angegeben wird.  Auf die gleiche Weise werden wir andere Codeteile analysieren. <br><br><pre> <code class="plaintext hljs">analyzeSentence() {   fetch('http://localhost:8080/sentiment', {  // #1       method: 'POST',       headers: {           'Content-Type': 'application/json'       },       body: JSON.stringify({                      sentence: this.textField.getValue()})// #2   })       .then(response =&gt; response.json())       .then(data =&gt; this.setState(data));  // #3 }</code> </pre> <br>  <b>1.</b> URL, unter der die POST-Anforderung ausgeführt wird.  Es versteht sich, dass diese Adresse eine Anwendung enthält, die auf solche Anforderungen wartet. <br><br>  <b>2.</b> Der an die Anwendung gesendete Anfragetext.  Hier ist ein Beispiel für einen Anfragetext: <br><br><pre> <code class="plaintext hljs">{   sentence: "I like yogobella!" }</code> </pre> <br>  <b>3.</b> Nach Erhalt einer Antwort auf die Anforderung wird der Status der Komponente aktualisiert.  Dadurch wird die Komponente erneut gerendert.  Wenn wir Daten empfangen (dh ein JSON-Objekt, das die eingegebenen Daten und die berechnete Textbewertung enthält), geben wir die <code>Polarity</code> , da die entsprechenden Bedingungen erfüllt sind.  So beschreiben wir die Komponente: <br><br><pre> <code class="plaintext hljs">const polarityComponent = this.state.polarity !== undefined ?   &lt;Polarity sentence={this.state.sentence}             polarity={this.state.polarity}/&gt; :   null;</code> </pre> <br>  Der Code scheint ziemlich gut zu funktionieren.  Was ist hier denn falsch?  Wenn Sie davon ausgehen, dass an der Adresse, an die die Anwendung versucht, eine POST-Anfrage zu senden, bis jetzt nichts diese Anfrage annehmen und verarbeiten kann, haben Sie absolut Recht.  Um Anforderungen zu verarbeiten, die an der Adresse <code>http://localhost:8080/sentiment</code> ankommen, müssen wir eine Webanwendung ausführen, die auf Spring basiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/848/f16/5a3/848f165a308f9ae73ffd3f8186b23aee.png"></div><br>  <i><font color="#999999">Wir benötigen eine Spring-Anwendung, die eine POST-Anfrage annehmen kann.</font></i> <br><br><h3>  <font color="#3AC1EF">▍Richten Sie eine Spring-basierte Webanwendung ein</font> </h3><br>  Zum Bereitstellen der Spring-Anwendung benötigen Sie JDK8 und Maven sowie ordnungsgemäß konfigurierte Umgebungsvariablen.  Nachdem Sie dies alles installiert haben, können Sie weiter an unserem Projekt arbeiten. <br><br><h3>  <font color="#3AC1EF">▍Verpacken der Anwendung in eine JAR-Datei</font> </h3><br>  Gehen Sie mit dem Terminal zum Ordner <code>sa-webapp</code> und geben Sie den folgenden Befehl ein: <br><br><pre> <code class="plaintext hljs">mvn install</code> </pre> <br>  Nach Ausführung dieses Befehls wird das <code>target</code> im Ordner <code>sa-webapp</code> .  Es wird eine Java-Anwendung in einer JAR-Datei enthalten sein, die durch <code>sentiment-analysis-web-0.0.1-SNAPSHOT.jar</code> . <br><br><h3>  <font color="#3AC1EF">▍Starten Sie die Java-Anwendung</font> </h3><br>  Gehen Sie zum Zielordner und starten Sie die Anwendung mit dem folgenden Befehl: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar</code> </pre> <br>  Während der Ausführung dieses Befehls tritt ein Fehler auf.  Um das Problem zu beheben, können wir die Ausnahmeinformationen in den Stack-Trace-Daten analysieren: <br><br><pre> <code class="plaintext hljs">Error creating bean with name 'sentimentController': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'sa.logic.api.url' in value "${sa.logic.api.url}"</code> </pre> <br>  Das Wichtigste für uns ist hier die Erwähnung der Unmöglichkeit, die Bedeutung von <code>sa.logic.api.url</code> .  Analysieren wir den Code, in dem der Fehler auftritt. <br><br><h3>  <font color="#3AC1EF">▍ Analyse des Java-Anwendungscodes</font> </h3><br>  Hier ist das Code-Snippet, in dem der Fehler auftritt. <br><br><pre> <code class="plaintext hljs">@CrossOrigin(origins = "*") @RestController public class SentimentController {   @Value("${sa.logic.api.url}")    // #1   private String saLogicApiUrl;   @PostMapping("/sentiment")   public SentimentDto sentimentAnalysis(       @RequestBody SentenceDto sentenceDto)   {       RestTemplate restTemplate = new RestTemplate();       return restTemplate.postForEntity(               saLogicApiUrl + "/analyse/sentiment",    // #2               sentenceDto, SentimentDto.class)               .getBody();   } }</code> </pre> <br><ol><li>  S <code>entimentController</code> verfügt über ein <code>saLogicApiUrl</code> Feld.  Sein Wert wird durch die Eigenschaft <code>sa.logic.api.url</code> . </li><li>  Die Zeichenfolge <code>saLogicApiUrl</code> mit dem Wert <code>/analyse/sentiment</code> verkettet.  Zusammen bilden sie eine Adresse für den Zugriff auf einen Mikrodienst, der eine Textanalyse durchführt. </li></ol><br><h3>  <font color="#3AC1EF">▍Stellen Sie den Eigenschaftswert ein</font> </h3><br>  Im Frühjahr ist die Standardquelle für Eigenschaftswerte die Datei <code>application.properties</code> , die sich unter <code>sa-webapp/src/main/resources</code> .  Die Verwendung ist jedoch nicht die einzige Möglichkeit, Eigenschaftswerte festzulegen.  Sie können dies mit einem Befehl wie dem folgenden tun: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=WHAT.IS.THE.SA.LOGIC.API.URL</code> </pre> <br>  Der Wert dieser Eigenschaft sollte auf die Adresse unserer Python-Anwendung verweisen. <br><br>  Durch die Konfiguration teilen wir der Spring-Webanwendung mit, wohin sie zum Ausführen von Textanalyseanforderungen gehen muss. <br><br>  Um unser Leben nicht zu verkomplizieren, entscheiden wir, dass die Python-Anwendung bei <code>localhost:5000</code> verfügbar sein wird, und versuchen, sie nicht zu vergessen.  Infolgedessen sieht der Befehl zum Starten der Spring-Anwendung folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=http://localhost:5000</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/445/815/30d44581533865907366e867c029124e.png"></div><br>  <i><font color="#999999">Unserem System fehlt eine Python-Anwendung</font></i> <br><br>  Jetzt müssen wir nur noch die Python-Anwendung starten und das System funktioniert wie erwartet. <br><br><h3>  <font color="#3AC1EF">▍Konfigurieren einer Python-Anwendung</font> </h3><br>  Um eine Python-Anwendung ausführen zu können, müssen Python 3 und Pip installiert sein und Sie müssen die entsprechenden Umgebungsvariablen korrekt festlegen. <br><br><h3>  <font color="#3AC1EF">▍Installation von Abhängigkeiten</font> </h3><br>  Gehen Sie zum Projektordner <code>sa-logic/sa</code> und führen Sie die folgenden Befehle aus: <br><br><pre> <code class="plaintext hljs">python -m pip install -r requirements.txt python -m textblob.download_corpora</code> </pre> <br><h3>  <font color="#3AC1EF">▍Starten Sie die Anwendung</font> </h3><br>  Nach der Installation der Abhängigkeiten können wir die Anwendung starten: <br><br><pre> <code class="plaintext hljs">python sentiment_analysis.py</code> </pre> <br>  Nach Ausführung dieses Befehls werden wir über Folgendes informiert: <br><br><pre> <code class="plaintext hljs">* Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</code> </pre> <br>  Dies bedeutet, dass die Anwendung ausgeführt wird und auf Anfragen bei <code>localhost:5000/</code> wartet <code>localhost:5000/</code> <br><br><h3>  <font color="#3AC1EF">▍ Code-Forschung</font> </h3><br>  Betrachten Sie den Python-Anwendungscode, um zu verstehen, wie er auf Anforderungen reagiert: <br><br><pre> <code class="plaintext hljs">from textblob import TextBlob from flask import Flask, request, jsonify app = Flask(__name__)                                   #1 @app.route("/analyse/sentiment", methods=['POST'])      #2 def analyse_sentiment():   sentence = request.get_json()['sentence']           #3   polarity = TextBlob(sentence).sentences[0].polarity #4   return jsonify(                                     #5       sentence=sentence,       polarity=polarity   ) if __name__ == '__main__':   app.run(host='0.0.0.0', port=5000)                #6</code> </pre> <br><ol><li>  Initialisieren eines <code>Flask</code> . </li><li>  Festlegen der Adresse zum Ausführen von POST-Anforderungen. </li><li>  Abrufen der Satzeigenschaft aus dem Anforderungshauptteil. </li><li>  Initialisieren des anonymen <code>TextBlob</code> Objekts und <code>TextBlob</code> des <code>polarity</code> für den ersten Satz im Anforderungshauptteil (in unserem Fall ist dies der einzige Satz, der zur Analyse übergeben wird). </li><li>  Die Rückgabe der Antwort, in deren Hauptteil der Text des Vorschlags und der dafür berechnete <code>polarity</code> enthalten sind. </li><li>  Starten der Flask-Anwendung, die unter der Adresse <code>0.0.0.0:5000</code> verfügbar <code>0.0.0.0:5000</code> (Sie können auch mit einem Design des Formulars <code>localhost:5000</code> zugreifen). </li></ol><br>  Jetzt werden die Microservices ausgeführt, aus denen die Anwendung besteht.  Sie sind so konfiguriert, dass sie miteinander interagieren.  So sieht das Anwendungsdiagramm in dieser Arbeitsphase aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75a/fcc/135/75afcc1352ed237efaf0a2280c2df295.png"></div><br>  <i><font color="#999999">Alle Microservices, aus denen sich die Anwendung zusammensetzt, werden in einen gesunden Zustand versetzt.</font></i> <br><br>  Bevor Sie fortfahren, öffnen Sie jetzt die React-Anwendung in einem Browser und versuchen Sie, einen Vorschlag damit zu analysieren.  Wenn alles richtig gemacht wurde, sehen Sie nach dem Klicken auf die Schaltfläche <code>Send</code> die Analyseergebnisse unter dem Textfeld. <br><br>  Im nächsten Abschnitt werden wir darüber sprechen, wie unsere Microservices in Docker-Containern ausgeführt werden.  Dies ist erforderlich, um die Anwendung für den Start im Kubernetes-Cluster vorzubereiten. <br><br><h2>  <font color="#3AC1EF">Docker-Container</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes</a> ist ein System zur Automatisierung der Bereitstellung, Skalierung und Verwaltung von Anwendungen in Containern.  Es wird auch als "Container Orchestrator" bezeichnet.  Wenn Kubernetes mit Containern arbeitet, müssen wir diese Container zuerst erwerben, bevor wir dieses System verwenden können.  Aber zuerst sprechen wir darüber, was Container sind.  Die vielleicht beste Antwort auf die Frage, was es ist, finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zu Docker: <br><br>  <i>Ein Container-Image ist ein leichtes, eigenständiges, ausführbares Paket, das eine Art Anwendung enthält, die alles enthält, was Sie zum Ausführen benötigen: Anwendungscode, Laufzeit, Systemtools und Bibliotheken, Einstellungen.</i>  <i>Containerisierte Programme können in Linux- und Windows-Umgebungen verwendet werden und funktionieren unabhängig von der Infrastruktur immer gleich.</i> <br><br>  Dies bedeutet, dass Container auf jedem Computer ausgeführt werden können, einschließlich Produktionsservern, und in jeder Umgebung funktionieren die darin enthaltenen Anwendungen auf die gleiche Weise. <br><br>  Betrachten Sie ein Beispiel für die Bereitstellung einer React-Anwendung mithilfe einer virtuellen Maschine und eines Containers, um die Funktionen von Containern zu untersuchen und sie mit anderen Methoden zum Starten von Anwendungen zu vergleichen. <br><br><h3>  <font color="#3AC1EF">▍Serving Reaktive statische Anwendungsdateien mithilfe einer virtuellen Maschine</font> </h3><br>  Beim Versuch, die Wartung statischer Dateien mithilfe virtueller Maschinen zu organisieren, treten folgende Nachteile auf: <br><br><ol><li>  Ineffiziente Ressourcennutzung, da jede virtuelle Maschine ein vollwertiges Betriebssystem ist. </li><li>  Plattformabhängig.  Was auf einem bestimmten lokalen Computer funktioniert, funktioniert möglicherweise nicht auf einem Produktionsserver. </li><li>  Langsame und ressourcenintensive Skalierung einer Lösung auf der Basis einer virtuellen Maschine. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c26/927/523/c26927523b6072ce65bfaf8b01a1e330.png"></div><br>  <i><font color="#999999">Nginx Static Server Webserver, der auf einer virtuellen Maschine ausgeführt wird</font></i> <br><br>  Wenn Container verwendet werden, um ein ähnliches Problem zu lösen, können im Vergleich zu virtuellen Maschinen die folgenden Stärken festgestellt werden: <br><br><ol><li>  Effiziente Ressourcennutzung: Arbeiten mit dem Betriebssystem mithilfe von Docker. </li><li>  Plattformunabhängigkeit.  Ein Container, den ein Entwickler auf seinem Computer ausführen kann, funktioniert überall. </li><li>  Leichte Bereitstellung durch Verwendung von Bildebenen. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28b/593/b01/28b593b01ce003c246843d9c9f2bd05f.png"></div><br>  <i><font color="#999999">Nginx Static Server Webserver, der in einem Container ausgeführt wird</font></i> <br><br>  Wir haben virtuelle Maschinen und Container nur in wenigen Punkten verglichen, aber selbst dies reicht aus, um die Stärken der Container zu spüren.  Weitere Informationen zu Docker-Containern finden Sie hier. <br><br><h3>  <font color="#3AC1EF">▍ Zusammenstellen eines Container-Images für eine React-Anwendung</font> </h3><br>  Der Hauptbaustein des Docker-Containers ist die Docker- <code>Dockerfile</code> .  Machen Sie am Anfang dieser Datei eine Aufzeichnung des Grundabbilds des Containers, und enthalten Sie dann eine Folge von Anweisungen, die die Reihenfolge angeben, in der der Container erstellt wird, um die Anforderungen einer bestimmten Anwendung zu erfüllen. <br><br>  Bevor wir mit der <code>Dockerfile</code> Datei arbeiten, erinnern wir uns daran, was wir getan haben, um die React-Anwendungsdateien für den Upload auf den Nginx-Server vorzubereiten: <br><br><ol><li>  Erstellen Sie ein React-Anwendungspaket ( <code>npm run build</code> ). </li><li>  Nginx-Server starten. </li><li>  Kopieren Sie den Inhalt des <code>build</code> Verzeichnisses aus dem Projektordner <code>sa-frontend</code> in den <code>nginx/html</code> . </li></ol><br>  Unten sehen Sie die Parallelen zwischen dem Erstellen des Containers und den oben auf dem lokalen Computer ausgeführten Aktionen. <br><br><h3>  <font color="#3AC1EF">▍Erstellen einer Docker-Datei für SA-Frontend</font> </h3><br>  Die Anweisungen, die in der <code>Dockerfile</code> für die <code>SA-Frontend</code> Anwendung enthalten sein werden, bestehen nur aus zwei Befehlen.  Tatsache ist, dass das Nginx-Entwicklungsteam ein Basis- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Image</a> für Nginx erstellt hat, mit dem wir unser Image erstellen werden.  Hier sind die zwei Schritte, die wir beschreiben müssen: <br><br><ol><li>  Die Basis des Bildes benötigen Sie, um das Bild von Nginx zu erstellen. </li><li>  Der Inhalt des Ordners <code>sa-frontend/build</code> muss in den <code>nginx/html</code> kopiert werden. </li></ol><br>  Wenn wir von dieser Beschreibung zur <code>Dockerfile</code> , <code>Dockerfile</code> sie folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">FROM nginx COPY build /usr/share/nginx/html</code> </pre> <br>  Wie Sie sehen können, ist hier alles sehr einfach, während sich der Inhalt der Datei sogar als gut lesbar und verständlich herausstellt.  Diese Datei weist das System an, das <code>nginx</code> Image mit allem, was bereits vorhanden ist, aufzunehmen und den Inhalt des <code>build</code> Verzeichnisses in das Verzeichnis <code>nginx/html</code> kopieren. <br><br>  Hier haben Sie möglicherweise eine Frage dazu, woher ich weiß, wo genau ich Dateien aus dem <code>build</code> Ordner kopieren muss <code>build</code> dh woher der Pfad <code>/usr/share/nginx/html</code> stammt.  In der Tat, und es gibt nichts Kompliziertes.  Tatsache ist, dass die relevanten Informationen in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung des</a> Bildes zu finden sind. <br><br><h3>  <font color="#3AC1EF">▍Erstellen eines Bildes und Hochladen in das Repository</font> </h3><br>  Bevor wir mit dem fertigen Image arbeiten können, müssen wir es an das Image-Repository senden.  Zu diesem Zweck verwenden wir die kostenlose Cloud-Plattform zum Hosten von Docker Hub-Images.  In dieser Phase der Arbeit müssen Sie Folgendes tun: <br><br><ol><li>  Installieren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker</a> . </li><li>  Registrieren Sie sich auf der Docker Hub-Website. </li><li>  Melden Sie sich beim Konto an, indem Sie den folgenden Befehl im Terminal ausführen: <br><br><pre> <code class="plaintext hljs">docker login -u="$DOCKER_USERNAME" -p="$DOCKER_PASSWORD"</code> </pre> </li></ol><br>  Jetzt müssen Sie das Terminal verwenden, um zum <code>sa-frontend</code> Verzeichnis zu <code>sa-frontend</code> und dort den folgenden Befehl auszuführen: <br><br><pre> <code class="plaintext hljs">docker build -f Dockerfile -t $DOCKER_USER_ID/sentiment-analysis-frontend .</code> </pre> <br>  Im Folgenden muss in ähnlichen Befehlen <code>$DOCKER_USER_ID</code> auf dem Docker Hub durch Ihren Benutzernamen ersetzt werden.  Zum Beispiel könnte dieser Teil des Befehls folgendermaßen aussehen: <code>rinormaloku/sentiment-analysis-frontend</code> . <br><br>  Gleichzeitig kann dieser Befehl durch Entfernen von <code>-f Dockerfile</code> verkürzt werden, da diese Datei bereits in dem Ordner vorhanden ist, in dem wir diesen Befehl ausführen. <br><br>  Um das fertige Image an das Repository zu senden, benötigen wir den folgenden Befehl: <br><br><pre> <code class="plaintext hljs">docker push $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>  Überprüfen Sie nach der Ausführung die Liste Ihrer Repositorys im Docker Hub, um festzustellen, ob das Image erfolgreich an die Cloud gesendet wurde. <br><br><h3>  <font color="#3AC1EF">▍Startcontainer</font> </h3><br>  Jetzt kann jeder ein Bild herunterladen und ausführen, das als <code>$DOCKER_USER_ID/sentiment-analysis-frontend</code> .  Dazu müssen Sie die folgende Befehlsfolge ausführen: <br><br><pre> <code class="plaintext hljs">docker pull $DOCKER_USER_ID/sentiment-analysis-frontend docker run -d -p 80:80 $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>  Jetzt wird der Container gestartet und wir können weiterarbeiten und die anderen benötigten Bilder erstellen.  Bevor wir fortfahren, <code>80:80</code> wir <code>80:80</code> Konstrukt an, das sich im Image- <code>80:80</code> befindet und möglicherweise unverständlich erscheint. <br><br><ul><li>  Die erste Nummer <code>80</code> ist die Host-Port-Nummer (dh der lokale Computer). </li><li>  Die zweite Nummer <code>80</code> ist der Port des Containers, an den die Anforderung umgeleitet werden soll. </li></ul><br>  Betrachten Sie die folgende Abbildung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/775/394/6cd/7753946cde3287113b82f00921ced889.png"></div><br>  <i><font color="#999999">Portweiterleitung</font></i> <br><br>  Das System leitet Anforderungen vom <code>&lt;hostPort&gt;</code> an den <code>&lt;containerPort&gt;</code> <code>&lt;hostPort&gt;</code> .  Das heißt, der Zugriff auf Port <code>80</code> Computers wird auf Port <code>80</code> Containers umgeleitet. <br><br>  Da Port <code>80</code> auf dem lokalen Computer geöffnet <code>80</code> , können Sie von diesem Computer aus auf <code>localhost:80</code> auf die Anwendung zugreifen.  Wenn Ihr System Docker nicht unterstützt, können Sie die Anwendung auf der virtuellen <code>&lt;docker-machine ip&gt;:80</code> ausführen, deren Adresse wie folgt aussieht: <code>&lt;docker-machine ip&gt;:80</code> .  Um die IP-Adresse der virtuellen <code>docker-machine ip</code> herauszufinden, können Sie den <code>docker-machine ip</code> . <br><br>  Zu diesem Zeitpunkt sollten Sie nach dem erfolgreichen Start des Frontend-Anwendungscontainers in der Lage sein, seine Seite in einem Browser zu öffnen. <br><br><h3>  <font color="#3AC1EF">▍ .dockerignore-Datei</font> </h3><br>  Beim Sammeln des Images der <code>SA-Frontend</code> Anwendung konnten wir feststellen, dass dieser Prozess extrem langsam ist.  Dies geschieht aufgrund der Tatsache, dass der Build-Kontext des Images an den Docker-Daemon gesendet werden muss.  Das Verzeichnis, das den Build-Kontext darstellt, wird durch das letzte Argument des <code>docker build</code> .  In unserem Fall steht am Ende dieses Befehls ein Punkt.  Dies führt dazu, dass die folgende Struktur in den Assemblykontext aufgenommen wird: <br><br><pre> <code class="plaintext hljs">sa-frontend: |   .dockerignore |   Dockerfile |   package.json |   README.md +---build +---node_modules +---public \---src</code> </pre> <br>  Von allen hier vorhandenen Ordnern benötigen wir jedoch nur den <code>build</code> Ordner.  Alles andere herunterzuladen ist Zeitverschwendung.  Builds können beschleunigt werden, indem Docker mitgeteilt wird, welche Verzeichnisse ignoriert werden sollen.  Dazu benötigen wir eine <code>.dockerignore</code> Datei.  Wenn Sie mit der <code>.gitignore</code> Datei vertraut sind, wird <code>.gitignore</code> die Struktur dieser Datei sicherlich bekannt vorkommen.  Es werden Verzeichnisse aufgelistet, die das Image-Assembly-System möglicherweise ignoriert.  In unserem Fall sieht der Inhalt dieser Datei folgendermaßen aus: <br><br><pre> <code class="plaintext hljs">node_modules src public</code> </pre> <br>  Die <code>.dockerignore</code> Datei muss sich im selben Ordner wie die <code>Dockerfile</code> Datei <code>Dockerfile</code> .  Das Zusammenstellen des Bildes dauert nun einige Sekunden. <br><br>  Schauen wir uns nun die Java-Anwendung an. <br><br><h3> <font color="#3AC1EF">▍    Java-</font> </h3><br>  ,           .       . <br><br>   <code>Dockerfile</code> ,      <code>sa-webapp</code> .      ,         ,     <code>ENV</code>  <code>EXPOSE</code> : <br><br><pre> <code class="plaintext hljs">ENV SA_LOGIC_API_URL http://localhost:5000 … EXPOSE 8080</code> </pre> <br>   <code>ENV</code>       Docker.  ,       URL    API ,   . <br><br>   <code>EXPOSE</code>   Docker  ,    .          .   ,   <code>Dockerfile</code>   <code>SA-Frontend</code>   .      ,  ,     ,    <code>Dockerfile</code> . <br><br>           ,    .           —       <code>README.md</code>   <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">▍    Python-</font> </h3><br>       <code>Dockerfile</code>   <code>sa-logic</code> ,         .               ,  ,        ,     <code>README.md</code>   <code>sa-logic</code> . <br><br><h3> <font color="#3AC1EF">▍  </font> </h3><br>     - ,    ?    .   . <br><br><ol><li>    <code>sa-logic</code>       <code>5050</code> : <br><br><pre> <code class="plaintext hljs">docker run -d -p 5050:5000 $DOCKER_USER_ID/sentiment-analysis-logic</code> </pre> </li><li>    <code>sa-webapp</code>       <code>8080</code> .  ,    ,   Python-     Java-,    <code>SA_LOGIC_API_URL</code> : <br><br><pre> <code class="plaintext hljs">$ docker run -d -p 8080:8080 -e SA_LOGIC_API_URL='http://&lt;container_ip or docker machine ip&gt;:5000' $DOCKER_USER_ID/sentiment-analysis-web-app</code> </pre> </li></ol><br>      ,   IP-     Docker —    <a href="">README</a> . <br><br>    <code>sa-frontend</code> : <br><br><pre> <code class="plaintext hljs">docker run -d -p 80:80 $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>     ,       <code>localhost:80</code>   . <br><br>    ,       <code>sa-webapp</code> ,        Docker,     <code>App.js</code>   <code>sa-frontend</code> ,  IP-      <code>analyzeSentence()</code> ,      .         . <br><br>       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/71e/87a/79671e87adea76c8873cac180e2fe8c0.png"></div><br> <i><font color="#999999">   </font></i> <br><br><h2> <font color="#3AC1EF">:    Kubernetes?</font> </h2><br>      <code>Dockerfile</code> ,   ,         Docker.  ,     ,   <code>.dockerignore</code> .         Docker.          ,   Kubernetes.          .      : <br> ,   -      .       .  ,   <code>sa-webapp</code>  <code>sa-logic</code>     .   ,    ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438982/">https://habr.com/ru/post/de438982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438972/index.html">Das Gehirn von innen (Visualisierung des Durchgangs des Musters durch das künstliche neuronale Netzwerkmodell)</a></li>
<li><a href="../de438974/index.html">Virtuelle Realität hilft bei psychischen Störungen</a></li>
<li><a href="../de438976/index.html">Das Buch "Frühling. Alle Designmuster »</a></li>
<li><a href="../de438978/index.html">Immer und überall lernen! Podcasts für Entwickler in englischer Sprache</a></li>
<li><a href="../de438980/index.html">Spring Boot 2: Was ist neu?</a></li>
<li><a href="../de438984/index.html">Kubernetes-Handbuch, Teil 2: Erstellen und Arbeiten mit einem Cluster</a></li>
<li><a href="../de438986/index.html">React Tutorial Teil 14: Workshop zu klassenbasierten Komponenten, Komponentenstatus</a></li>
<li><a href="../de438988/index.html">React Tutorial Teil 15: Komponentenstatus-Workshops</a></li>
<li><a href="../de438992/index.html">Entwicklertagebuch oder schlechte Entscheidungen</a></li>
<li><a href="../de438994/index.html">Intel Xeon W-3175X, ein heißer Schlagzeuger. Testen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>