<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèΩ üßúüèº üëü GraphQL y Golang üêï üé´ üîõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La tecnolog√≠a GraphQL en los √∫ltimos a√±os, despu√©s de que la compa√±√≠a Facebook la transfiri√≥ a la categor√≠a de c√≥digo abierto, se ha vuelto muy popula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GraphQL y Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444346/">  La tecnolog√≠a GraphQL en los √∫ltimos a√±os, despu√©s de que la compa√±√≠a Facebook la transfiri√≥ a la categor√≠a de c√≥digo abierto, se ha vuelto muy popular.  El autor del material, cuya traducci√≥n publicamos hoy, dice que trat√≥ de trabajar con GraphQL en Node.js y, por su propia experiencia, estaba convencido de que esta tecnolog√≠a, gracias a sus notables capacidades y simplicidad, no atrae tanta atenci√≥n accidentalmente.  Recientemente, mientras participaba en un nuevo proyecto, cambi√≥ de Node.js a Golang.  Luego decidi√≥ probar la colaboraci√≥n de Golang y GraphQL. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/jp/qa/qv/jpqaqvlt5xh7d7mlhwpxvvwhptq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Informaci√≥n preliminar</font> </h2><br>  Puede aprender de la definici√≥n oficial de GraphQL que este es un lenguaje de consulta para la API y un tiempo de ejecuci√≥n para ejecutar tales consultas en los datos existentes.  GraphQL proporciona una descripci√≥n completa y comprensible de los datos en una determinada API, permite a los clientes solicitar exactamente la informaci√≥n que necesitan, y nada m√°s, simplifica el desarrollo de la API con el tiempo y brinda a los desarrolladores herramientas poderosas. <br><br>  No hay muchas bibliotecas GraphQL para Golang.  En particular, prob√© bibliotecas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Thunder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">graphql</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">graphql-go</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gqlgen</a> .  Debo se√±alar que lo mejor de todo lo que prob√© fue la biblioteca gqlgen. <br><br>  La biblioteca gqlgen todav√≠a est√° en beta, al momento de escribir este material era la versi√≥n <a href="">0.7.2</a> .  La biblioteca est√° evolucionando r√°pidamente.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> puede conocer los planes para su desarrollo.  Ahora el patrocinador oficial de gqlgen es el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">99designs</a> , lo que significa que esta biblioteca, posiblemente, se desarrollar√° a√∫n m√°s r√°pido que antes.  Los principales desarrolladores de esta biblioteca son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vektah</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">neelance</a> , mientras que neelance, adem√°s, funciona en la biblioteca graphql-go. <br><br>  Hablemos de la biblioteca gqlgen con el supuesto de que ya tiene conocimientos b√°sicos de GraphQL. <br><br><h2>  <font color="#3AC1EF">Caracter√≠sticas de Gqlgen</font> </h2><br>  En la descripci√≥n de gqlgen, puede encontrar lo que tenemos ante nosotros es una biblioteca para crear r√°pidamente servidores GraphQL estrictamente tipados en Golang.  Esta frase me parece muy prometedora, ya que significa que cuando trabaje con esta biblioteca no me encontrar√© con algo como la <code>map[string]interface{}</code> , ya que aqu√≠ se utiliza un enfoque basado en una escritura estricta. <br><br>  Adem√°s, esta biblioteca utiliza un enfoque basado en un esquema de datos.  Esto significa que las API se describen utilizando el lenguaje de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">definici√≥n de esquema</a> GraphQL.  Este lenguaje tiene sus propias potentes herramientas de generaci√≥n de c√≥digo que crean autom√°ticamente c√≥digo GraphQL.  En este caso, el programador solo puede implementar la l√≥gica b√°sica de los m√©todos de interfaz correspondientes. <br><br>  Este art√≠culo est√° dividido en dos partes.  El primero est√° dedicado a los m√©todos b√°sicos de trabajo y el segundo a los avanzados. <br><br><h2>  <font color="#3AC1EF">Los principales m√©todos de trabajo: configuraci√≥n, solicitudes para recibir y cambiar datos, suscripciones</font> </h2><br>  Nosotros, como aplicaci√≥n experimental, utilizaremos un sitio donde los usuarios pueden publicar videos, agregar capturas de pantalla y revisiones, buscar videos y ver listas de registros asociados con otros registros.  Comencemos a trabajar en este proyecto: <br><br><pre> <code class="go hljs">mkdir -p $GOPATH/src/github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/</code> </pre> <br>  Cree el siguiente archivo de esquema de datos ( <code>schema.graphql</code> ) en el directorio ra√≠z del proyecto: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User {   id: ID!   name: String!   email: String! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video {   id: ID!   name: String!   description: String!   user: User!   url: String!   createdAt: Timestamp!   screenshots: [Screenshot]   related(limit: Int = <span class="hljs-number"><span class="hljs-number">25</span></span>, offset: Int = <span class="hljs-number"><span class="hljs-number">0</span></span>): [Video!]! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Screenshot {   id: ID!   videoId: ID!   url: String! } input NewVideo {   name: String!   description: String!   userId: ID!   url: String! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Mutation {   createVideo(input: NewVideo!): Video! } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Query {   Videos(limit: Int = <span class="hljs-number"><span class="hljs-number">25</span></span>, offset: Int = <span class="hljs-number"><span class="hljs-number">0</span></span>): [Video!]! } scalar Timestamp</code> </pre> <br>  Aqu√≠ se describen los modelos de datos b√°sicos, una mutaci√≥n ( <code>Mutation</code> , descripci√≥n de la solicitud de cambio de datos), que se utiliza para publicar nuevos archivos de video en el sitio, y una consulta ( <code>Query</code> ) para obtener una lista de todos los archivos de video.  Lea m√°s sobre el esquema GraphQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Adem√°s, aqu√≠ declaramos uno de nuestros propios tipos de datos escalares.  No estamos satisfechos con los 5 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipos de</a> datos escalares est√°ndar ( <code>Int</code> , <code>Float</code> , <code>String</code> , <code>Boolean</code> e <code>ID</code> ) que se encuentran en GraphQL. <br><br>  Si necesita usar sus propios tipos, puede declararlos en <code>schema.graphql</code> (en nuestro caso, este tipo es <code>Timestamp</code> ) y proporcionar sus definiciones en el c√≥digo.  Al usar la biblioteca gqlgen, debe proporcionar m√©todos para ordenar y desarmar para todos sus propios tipos escalares y configurar la asignaci√≥n usando <code>gqlgen.yml</code> . <br><br>  Cabe se√±alar que en la √∫ltima versi√≥n de la biblioteca hubo un cambio importante.  A saber, se elimin√≥ la dependencia de los archivos binarios compilados.  Por lo tanto, el archivo <code>scripts/gqlgen.go</code> debe agregarse al proyecto <code>scripts/gqlgen.go</code> siguiente contenido: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// +build ignore package main import "github.com/99designs/gqlgen/cmd" func main() { cmd.Execute() }</span></span></code> </pre> <br>  Despu√©s de eso, debe inicializar <code>dep</code> : <br><br><pre> <code class="go hljs">dep init</code> </pre> <br>  Ahora es el momento de aprovechar las capacidades de generaci√≥n de c√≥digo de la biblioteca.  Le permiten crear todo el c√≥digo aburrido repetitivo, que, sin embargo, no se puede llamar completamente desinteresado.  Para iniciar el mecanismo de generaci√≥n autom√°tica de c√≥digo, ejecute el siguiente comando: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> init</code> </pre> <br>  Como resultado de su ejecuci√≥n, se crear√°n los siguientes archivos: <br><br><ul><li>  <code>gqlgen.yml</code> : archivo de configuraci√≥n para gestionar la generaci√≥n de c√≥digo. <br></li><li>  <code>generated.go</code> : c√≥digo generado. <br></li><li>  <code>models_gen.go</code> : todos los modelos y tipos de datos del esquema proporcionado. <br></li><li>  <code>resolver.go</code> : aqu√≠ estar√° el c√≥digo que crea el programador. <br></li><li>  <code>server/server.go</code> : punto de entrada con <code>http.Handler</code> para iniciar el servidor GraphQL. <br></li></ul><br>  Observe el modelo generado para el tipo de <code>Video</code> (archivo <code>generated_video.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> User        User  <span class="hljs-string"><span class="hljs-string">`json:"user"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>  <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> Screenshots []*Screenshot <span class="hljs-string"><span class="hljs-string">`json:"screenshots"`</span></span> Related     []Video  <span class="hljs-string"><span class="hljs-string">`json:"related"`</span></span> }</code> </pre> <br>  Aqu√≠ puede ver que la <code>ID</code> es una cadena, <code>CreatedAt</code> tambi√©n es una cadena.  Otros modelos relacionados se configuran en consecuencia.  Sin embargo, en aplicaciones reales esto no es necesario.  Si est√° utilizando cualquier tipo de datos SQL, entonces necesita, por ejemplo, que el campo <code>ID</code> sea, seg√∫n la base de datos utilizada, un tipo <code>int</code> o <code>int64</code> . <br><br>  Por ejemplo, uso PostgreSQL en esta aplicaci√≥n de demostraci√≥n, por lo que, por supuesto, necesito que el campo <code>ID</code> sea ‚Äã‚Äãde tipo <code>int</code> y <code>CreatedAt</code> tipo <code>time.Time</code> .  Esto lleva al hecho de que necesitamos definir nuestro propio modelo y decirle a gqlgen que necesitamos usar nuestro modelo en lugar de generar uno nuevo.  Aqu√≠ est√° el contenido del archivo <code>models.go</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> Description <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>    <span class="hljs-string"><span class="hljs-string">`json:"description"`</span></span> User        User <span class="hljs-string"><span class="hljs-string">`json:"user"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   time.Time <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> Related     []Video } <span class="hljs-comment"><span class="hljs-comment">//    int  ID func MarshalID(id int) graphql.Marshaler { return graphql.WriterFunc(func(w io.Writer) {   io.WriteString(w, strconv.Quote(fmt.Sprintf("%d", id))) }) } //        func UnmarshalID(v interface{}) (int, error) { id, ok := v.(string) if !ok {   return 0, fmt.Errorf("ids must be strings") } i, e := strconv.Atoi(id) return int(i), e } func MarshalTimestamp(t time.Time) graphql.Marshaler { timestamp := t.Unix() * 1000 return graphql.WriterFunc(func(w io.Writer) {   io.WriteString(w, strconv.FormatInt(timestamp, 10)) }) } func UnmarshalTimestamp(v interface{}) (time.Time, error) { if tmpStr, ok := v.(int); ok {   return time.Unix(int64(tmpStr), 0), nil } return time.Time{}, errors.TimeStampError }</span></span></code> </pre> <br>  Le decimos a la biblioteca que debe usar estos modelos (archivo <code>gqlgen.yml</code> ): <br><br><pre> <code class="go hljs">schema: - schema.graphql exec: filename: generated.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> model: filename: models_gen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> resolver: filename: resolver.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Resolver models: Video:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.Video ID:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.ID Timestamp:   model: github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.Timestamp</code> </pre> <br>  El punto de todo esto es que ahora tenemos nuestras propias definiciones para <code>ID</code> y <code>Timestamp</code> con m√©todos para calcular y desglosar y asignarlos en el archivo <code>gqlgen.yml</code> .  Ahora que el usuario proporciona la cadena como <code>ID</code> , el m√©todo <code>UnmarshalID()</code> convierte esa cadena en un entero.  Al enviar una respuesta, el m√©todo <code>MarshalID()</code> convierte el n√∫mero en una cadena.  Lo mismo sucede con <code>Timestamp</code> o con cualquier otro tipo escalar declarado por el programador. <br><br>  Ahora es el momento de implementar la l√≥gica de la aplicaci√≥n.  Abra el archivo <code>resolver.go</code> y agregue descripciones de mutaciones y consultas en √©l.  Ya existe un c√≥digo repetitivo generado autom√°ticamente que debemos llenar de significado.  Aqu√≠ est√° el c√≥digo para este archivo: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *mutationResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, input NewVideo)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.Video, error)</span></span></span></span> { newVideo := api.Video{   URL:         input.URL,   Name:        input.Name,   CreatedAt:   time.Now().UTC(), } rows, err := dal.LogAndQuery(r.db, <span class="hljs-string"><span class="hljs-string">"INSERT INTO videos (name, url, user_id, created_at) VALUES($1, $2, $3, $4) RETURNING id"</span></span>,   input.Name, input.URL, input.UserID, newVideo.CreatedAt) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || !rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;newVideo.ID); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.IsForeignKeyError(err) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, errors.UserNotExist   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.Video{}, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newVideo, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *queryResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Videos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, limit *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, offset *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]api.Video, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> video api.Video <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> videos []api.Video rows, err := dal.LogAndQuery(r.db, <span class="hljs-string"><span class="hljs-string">"SELECT id, name, url, created_at, user_id FROM videos ORDER BY created_at desc limit $1 offset $2"</span></span>, limit, offset) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close();   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;video.ID, &amp;video.Name, &amp;video.URL, &amp;video.CreatedAt, &amp;video.UserID); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {     errors.DebugPrintf(err)     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.InternalServerError   }   videos = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(videos, video) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> videos, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Ahora probemos la mutaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/a2c/01f/f7ba2c01f766ebc31ed90880376136f1.png"></div>  <i><font color="#999999">Mutaci√≥n createVideo</font></i> <br><br>  Funciona!  Pero, ¬øpor qu√© no hay nada en la informaci√≥n del usuario (objeto de <code>user</code> )?  Cuando se trabaja con GraphQL, se aplican conceptos similares a la carga "perezosa" (perezosa) y "codiciosa" (ansiosa).  Dado que este sistema es extensible, debe especificar qu√© campos deben rellenarse "con avidez" y cu√°les son "perezosos". <br><br>  Le suger√≠ al equipo de la organizaci√≥n donde trabajo la siguiente "regla de oro" que se aplica al trabajar con gqlgen: "No incluya en el modelo los campos que deben cargarse solo si el cliente los solicita". <br><br>  En nuestro caso, necesito descargar datos sobre videoclips relacionados (e incluso informaci√≥n del usuario) solo si el cliente solicita estos campos.  Pero como incluimos estos campos en el modelo, gqlgen supone que proporcionamos estos datos al recibir informaci√≥n sobre el video.  Como resultado, ahora tenemos estructuras vac√≠as. <br><br>  A veces sucede que se necesita un cierto tipo de datos cada vez, por lo que no es pr√°ctico descargarlo usando una solicitud por separado.  Para esto, para mejorar el rendimiento, puede usar algo como las uniones SQL.  Una vez (esto, sin embargo, no se aplica al ejemplo considerado aqu√≠), necesitaba cargar sus metadatos junto con el video.  Estas entidades fueron almacenadas en diferentes lugares.  Como resultado, si mi sistema recibi√≥ una solicitud para descargar un video, ten√≠a que hacer otra solicitud para obtener metadatos.  Pero, dado que conoc√≠a este requisito (es decir, sab√≠a que el cliente y el video y sus metadatos siempre son necesarios en el lado del cliente), prefer√≠ usar la t√©cnica de carga codiciosa para mejorar el rendimiento. <br><br>  Reescribamos el modelo y generemos el c√≥digo gqlgen nuevamente.  Para no complicar la historia, solo escribimos m√©todos para el campo de <code>user</code> (archivo <code>models.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Video <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID          <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"id"`</span></span> Name        <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> Description <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>    <span class="hljs-string"><span class="hljs-string">`json:"description"`</span></span> UserID      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"-"`</span></span> URL         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"url"`</span></span> CreatedAt   time.Time <span class="hljs-string"><span class="hljs-string">`json:"createdAt"`</span></span> }</code> </pre> <br>  <code>UserID</code> una <code>UserID</code> <code>User</code> y eliminamos la estructura de <code>User</code> .  Ahora regenere el c√≥digo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -v</code> </pre> <br>  Gracias a este comando, se crear√°n los siguientes m√©todos de interfaz para resolver estructuras indefinidas.  Adem√°s, deber√° determinar lo siguiente en el solucionador (archivo <code>generated.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> VideoResolver <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { User(ctx context.Context, obj *api.Video) (api.User, error) Screenshots(ctx context.Context, obj *api.Video) ([]*api.Screenshot, error) Related(ctx context.Context, obj *api.Video, limit *<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, offset *<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) ([]api.Video, error) }</code> </pre> <br>  Aqu√≠ est√° la definici√≥n (archivo <code>resolver.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *videoResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, obj *api.Video)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.User, error)</span></span></span></span> { rows, _ := dal.LogAndQuery(r.db,<span class="hljs-string"><span class="hljs-string">"SELECT id, name, email FROM users where id = $1"</span></span>, obj.UserID) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.User{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user api.User <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {   errors.DebugPrintf(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api.User{}, errors.InternalServerError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Ahora, los resultados de la prueba de mutaci√≥n se ver√°n como se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25a/41d/aaa/25a41daaa86b8db5407bd432312c3028.png"></div><br>  <i><font color="#999999">Mutaci√≥n createVideo</font></i> <br><br>  Lo que acabamos de discutir son los fundamentos de GraphQL, habiendo dominado cu√°les, ya puedes escribir algo por tu cuenta.  Sin embargo, antes de sumergirse en experimentos con GraphQL y Golang, ser√° √∫til hablar sobre las suscripciones, que est√°n directamente relacionadas con lo que estamos haciendo aqu√≠. <br><br><h3>  <font color="#3AC1EF">‚ñç Suscripciones</font> </h3><br>  GraphQL proporciona la capacidad de suscribirse a los cambios de datos que ocurren en tiempo real.  La biblioteca gqlgen permite, en tiempo real, usar sockets web, para trabajar con eventos de suscripci√≥n. <br><br>  La suscripci√≥n debe describirse en el archivo <code>schema.graphql</code> .  As√≠ es como se ve la descripci√≥n para suscribirse a un evento de publicaci√≥n de video: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subscription {   videoPublished: Video! }</code> </pre> <br>  Ahora, ejecute la generaci√≥n autom√°tica de c√≥digo nuevamente: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run scripts/gqlgen.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -v</code> </pre> <br>  Como ya se mencion√≥, durante la creaci√≥n autom√°tica de c√≥digo en el archivo <code>generated.go</code> , se crea una interfaz que debe implementarse en el reconocedor.  En nuestro caso, se ve as√≠ (archivo <code>resolver.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> videoPublishedChannel <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { videoPublishedChannel = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video{} } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> subscriptionResolver <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ *Resolver } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *subscriptionResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VideoPublished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> api.Video, error)</span></span></span></span> { id := randx.String(<span class="hljs-number"><span class="hljs-number">8</span></span>) videoEvent := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> api.Video, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   &lt;-ctx.Done() }() videoPublishedChannel[id] = videoEvent <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> videoEvent, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *mutationResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, input NewVideo)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.Video, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ... for _, observer := range videoPublishedChannel {   observer &lt;- newVideo } return newVideo, nil }</span></span></code> </pre> <br>  Ahora, al crear un nuevo video, debe activar un evento.  En nuestro ejemplo, esto se hace en la l√≠nea <code>for _, observer := range videoPublishedChannel</code> . <br><br>  Ahora es el momento de verificar su suscripci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/d7f/42b/f71d7f42b147f59d227a25e577ef57fb.gif"></div><br>  <i><font color="#999999">Verificar suscripci√≥n</font></i> <br><br>  GraphQL, por supuesto, tiene ciertas capacidades valiosas, pero como dicen, no todo lo que brilla es oro.  Es decir, estamos hablando del hecho de que alguien que usa GraphQL debe ocuparse de la autorizaci√≥n, la complejidad de las solicitudes, el almacenamiento en cach√©, el problema de las solicitudes N + 1, la limitaci√≥n de la velocidad de ejecuci√≥n de consultas y algunas otras cosas.  De lo contrario, un sistema desarrollado con GraphQL puede enfrentar una seria ca√≠da en el rendimiento. <br><br><h2>  <font color="#3AC1EF">T√©cnicas avanzadas: autenticaci√≥n, cargadores de datos, complejidad de consultas</font> </h2><br>  Cada vez que leo manuales como este, tengo la sensaci√≥n de que, despu√©s de dominarlos, aprendo todo lo que necesito saber sobre cierta tecnolog√≠a y tengo la capacidad de resolver problemas de cualquier complejidad. <br><br>  Pero cuando comienzo a trabajar en mis propios proyectos, generalmente me encuentro con situaciones imprevistas que parecen errores del servidor o solicitudes que se han estado ejecutando durante a√±os, o como algunas otras situaciones de punto muerto.  Como resultado, para hacer esto, tengo que profundizar en lo que recientemente parec√≠a perfectamente entendible.  En este mismo manual, espero que esto se pueda evitar.  Es por eso que en esta secci√≥n veremos algunas t√©cnicas avanzadas para trabajar con GraphQL. <br><br><h3>  <font color="#3AC1EF">‚ñç Autenticaci√≥n</font> </h3><br>  Cuando trabajamos con la API REST, tenemos un sistema de autenticaci√≥n y herramientas de autorizaci√≥n est√°ndar cuando trabajamos con un determinado punto final.  Pero cuando se usa GraphQL, solo se usa un punto final, por lo tanto, las tareas de autenticaci√≥n se pueden resolver usando directivas de esquema.  Edite el archivo <code>schema.graphql</code> la siguiente manera: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Mutation {   createVideo(input: NewVideo!): Video! @isAuthenticated } directive @isAuthenticated on FIELD_DEFINITION</code> </pre> <br>  Creamos la directiva <code>isAuthenticated</code> y la aplicamos a la suscripci√≥n <code>createVideo</code> .  Despu√©s de la pr√≥xima sesi√≥n de generaci√≥n autom√°tica de c√≥digo, debe definir una definici√≥n para esta directiva.  Ahora las directivas se implementan en forma de m√©todos de estructuras, y no en forma de interfaces, por lo que debemos describirlas.  Edit√© el c√≥digo generado autom√°ticamente ubicado en el archivo <code>server.go</code> y cre√© un m√©todo que devuelve la configuraci√≥n GraphQL para el archivo <code>server.go</code> .  Aqu√≠ est√° el archivo <code>resolver.go</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRootResolvers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { c := Config{   Resolvers: &amp;Resolver{     db: db,   }, } <span class="hljs-comment"><span class="hljs-comment">//   c.Directives.IsAuthenticated = func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {   ctxUserID := ctx.Value(UserIDCtxKey)   if ctxUserID != nil {     return next(ctx)   } else {     return nil, errors.UnauthorisedError   } } return c }</span></span></code> </pre> <br>  Aqu√≠ est√° el archivo <code>server.go</code> : <br><br><pre> <code class="go hljs">rootHandler:= dataloaders.DataloaderMiddleware(   db,   handler.GraphQL(     go_graphql_demo.NewExecutableSchema(go_graphql_demo.NewRootResolvers(db)   ) ) http.Handle(<span class="hljs-string"><span class="hljs-string">"/query"</span></span>, auth.AuthMiddleware(rootHandler))</code> </pre> <br>  Leemos la <code>ID</code> usuario del contexto.  ¬øNo te parece extra√±o?  ¬øC√≥mo lleg√≥ este significado al contexto y por qu√© incluso apareci√≥ en el contexto?  El hecho es que gqlgen proporciona contextos de solicitud solo a nivel de implementaci√≥n, por lo que no tenemos forma de leer ning√∫n dato de solicitud HTTP, como encabezados o cookies, en reconocedores o directivas.  Como resultado, debe agregar sus propios mecanismos intermedios al sistema, recibir estos datos y ponerlos en contexto. <br><br>  Ahora necesitamos describir nuestro propio mecanismo de autenticaci√≥n intermedio para obtener datos de autenticaci√≥n de la solicitud y verificarlo. <br><br>  No se define l√≥gica aqu√≠.  En cambio, para los datos de autorizaci√≥n, con fines de demostraci√≥n, la <code>ID</code> usuario simplemente se pasa aqu√≠.  Este mecanismo se combina en <code>server.go</code> con un nuevo m√©todo de carga de configuraci√≥n. <br><br>  Ahora la descripci√≥n de la directiva tiene sentido.  No procesamos solicitudes de usuarios no autorizados en el c√≥digo de middleware, ya que dichas solicitudes ser√°n procesadas por la directiva.  As√≠ es como se ve. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f6/a26/09c/6f6a2609cec8936c024fd68c7ed30096.png"></div><br>  <i><font color="#999999">Trabajar con un usuario no autorizado.</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/b92/378/267b923783521a82738973f82600a2a4.png"></div><br>  <i><font color="#999999">Trabajar con un usuario autorizado</font></i> <br><br>  Al trabajar con directivas de esquema, incluso puede pasar argumentos: <br><br><pre> <code class="go hljs">directive @hasRole(role: Role!) on FIELD_DEFINITION enum Role { ADMIN USER }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Cargadores de datos</font> </h3><br>  Me parece que todo esto parece bastante interesante.  Descarga datos cuando los necesita.  Los clientes tienen la capacidad de administrar datos; exactamente lo que se necesita se toma del almacenamiento.  Pero todo tiene un precio. <br><br>  ¬øCu√°l es el precio a pagar por estas oportunidades?  Echa un vistazo a los registros de descarga de todos los videos.  Es decir, estamos hablando del hecho de que tenemos 8 videos y 5 usuarios. <br><br><pre> <code class="go hljs">query{ Videos(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>){   name   user{     name   } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/7c1/b5c/5627c1b5c34f74aec26381f8b0431147.png"></div><br>  <i><font color="#999999">Detalles de descarga de video</font></i> <br><br><pre> <code class="go hljs">Query: Videos : SELECT id, name, description, url, created_at, user_id FROM videos ORDER BY created_at desc limit $<span class="hljs-number"><span class="hljs-number">1</span></span> offset $<span class="hljs-number"><span class="hljs-number">2</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span> Resolver: User : SELECT id, name, email FROM users where id = $<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  ¬øQu√© est√° pasando aqu√≠?  ¬øPor qu√© hay 9 solicitudes (1 solicitud est√° asociada con la tabla de video y 8 - con la tabla de usuario)?  Se ve horrible  Mi coraz√≥n casi se detuvo cuando pens√© que nuestra API existente tendr√≠a que ser reemplazada por esto ... Es cierto, los cargadores de datos pueden hacer frente por completo a este problema. <br><br>  Esto se conoce como el problema N + 1. Estamos hablando del hecho de que hay una consulta para obtener todos los datos y para cada pieza de datos (N) habr√° otra consulta en la base de datos. <br><br>  Este es un problema muy serio cuando se trata de rendimiento y recursos: aunque estas solicitudes son paralelas, agotan los recursos del sistema. <br><br>  Para resolver este problema, utilizaremos la biblioteca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">carga</a> de datos del autor de la biblioteca gqlgen.  Esta biblioteca le permite generar c√≥digo Go.  Primero, genere un cargador de datos para la entidad <code>User</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get github.com/vektah/dataloaden dataloaden github.com/ridhamtarpara/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-graphql-demo/api.User</code> </pre> <br>  Tenemos a nuestra disposici√≥n el archivo <code>userloader_gen.go</code> , que tiene m√©todos como <code>Fetch</code> , <code>LoadAll</code> y <code>Prime</code> . <br><br>  Ahora, para obtener resultados generales, necesitamos definir el m√©todo <code>Fetch</code> (archivo <code>dataloader.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataloaderMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB, next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> {   userloader := UserLoader{     wait : <span class="hljs-number"><span class="hljs-number">1</span></span> * time.Millisecond,     maxBatch: <span class="hljs-number"><span class="hljs-number">100</span></span>,     fetch: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*api.User, []error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlQuery <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ids) == <span class="hljs-number"><span class="hljs-number">1</span></span> {         sqlQuery = <span class="hljs-string"><span class="hljs-string">"SELECT id, name, email from users WHERE id = ?"</span></span>       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         sqlQuery = <span class="hljs-string"><span class="hljs-string">"SELECT id, name, email from users WHERE id IN (?)"</span></span>       }       sqlQuery, arguments, err := sqlx.In(sqlQuery, ids)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {         log.Println(err)       }       sqlQuery = sqlx.Rebind(sqlx.DOLLAR, sqlQuery)       rows, err := dal.LogAndQuery(db, sqlQuery, arguments...)       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> rows.Close();       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {         log.Println(err)       }       userById := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]*api.User{}       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() {         user:= api.User{}         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {           errors.DebugPrintf(err)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []error{errors.InternalServerError}         }         userById[user.ID] = &amp;user       }       users := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*api.User, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ids))       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, id := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ids {         users[i] = userById[id]         i++       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> users, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>     },   }   ctx := context.WithValue(r.Context(), CtxKey, &amp;userloader)   r = r.WithContext(ctx)   next.ServeHTTP(w, r) }) }</code> </pre> <br>  Aqu√≠ esperamos 1 ms.  antes de ejecutar la solicitud y recopilar las solicitudes en paquetes de hasta 100 solicitudes.  Ahora, en lugar de ejecutar una solicitud para cada usuario individualmente, el cargador esperar√° el tiempo especificado antes de acceder a la base de datos.  A continuaci√≥n, debe cambiar la l√≥gica del reconocedor reconfigur√°ndola utilizando la solicitud para usar el cargador de datos (archivo <code>resolver.go</code> ): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *videoResolver)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, obj *api.Video)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api.User, error)</span></span></span></span> { user, err := ctx.Value(dataloaders.CtxKey).(*dataloaders.UserLoader).Load(obj.UserID) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *user, err }</code> </pre> <br>  As√≠ es como se ven los registros despu√©s de eso en una situaci√≥n similar a la descrita anteriormente: <br><br><pre> <code class="go hljs">Query: Videos : SELECT id, name, description, url, created_at, user_id FROM videos ORDER BY created_at desc limit $<span class="hljs-number"><span class="hljs-number">1</span></span> offset $<span class="hljs-number"><span class="hljs-number">2</span></span> Dataloader: User : SELECT id, name, email from users WHERE id IN ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>, $<span class="hljs-number"><span class="hljs-number">3</span></span>, $<span class="hljs-number"><span class="hljs-number">4</span></span>, $<span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br>  Aqu√≠ solo se ejecutan dos consultas a la base de datos, como resultado, todos est√°n contentos.  Es interesante observar que solo se env√≠an 5 identificadores de usuario a la solicitud, aunque se solicitan datos para 8 videos.  Esto sugiere que el cargador de datos elimina registros duplicados. <br><br><h3> <font color="#3AC1EF">‚ñç </font> </h3><br> GraphQL   API  ,    .    ,   API   DOS-. <br><br>     ,     . <br><br>   <code>Video</code>  ,   .      GraphQL  <code>Video</code> .           .   ‚Äî  . <br><br>  ,      ‚Äî   : <br><br><pre> <code class="go hljs">{ Videos(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){   name   url   related(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){     name     url     related(limit: <span class="hljs-number"><span class="hljs-number">10</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){       name       url       related(limit: <span class="hljs-number"><span class="hljs-number">100</span></span>, offset: <span class="hljs-number"><span class="hljs-number">0</span></span>){         name         url       }     }   } } }</code> </pre> <br>           100,        .  (, , )    ,         . <br><br>  gqlgen      ,     .     ,       ( <code>handler.ComplexityLimit(300)</code>   )   GraphQL     (300   ).  ,     ( <code>server.go</code> ): <br><br><pre> <code class="go hljs">rootHandler:= dataloaders.DataloaderMiddleware( db, handler.GraphQL(   go_graphql_demo.NewExecutableSchema(go_graphql_demo.NewRootResolvers(db)),   handler.ComplexityLimit(<span class="hljs-number"><span class="hljs-number">300</span></span>) ), )</code> </pre> <br>       ,   ,        .        12.   ,       ,   ,      ( ,  ,  ,   ,     ).    <code>resolver.go</code> : <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRootResolvers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config</span></span></span></span> { c := Config{   Resolvers: &amp;Resolver{     db: db,   }, } <span class="hljs-comment"><span class="hljs-comment">//  countComplexity := func(childComplexity int, limit *int, offset *int) int {   return *limit * childComplexity } c.Complexity.Query.Videos = countComplexity c.Complexity.Video.Related = countComplexity //   c.Directives.IsAuthenticated = func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {   ctxUserID := ctx.Value(UserIDCtxKey)   if ctxUserID != nil {     return next(ctx)   } else {     return nil, errors.UnauthorisedError   } } return c }</span></span></code> </pre> <br>     ,     ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/702/045/d0a7020450bf5115f69c6a1ba61beca4.png"></div><br> <i><font color="#999999">    </font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/057/fec/7e3/057fec7e30f98b63aed8bbb6aec5193f.png"></div><br> <i><font color="#999999">      </font></i> <br><br>       ,   ,   <code>related</code>  . , , ,      ,             . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br> ,        ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .         .       ,     ,      . <br><br>  <b>Estimados lectores!</b>     GraphQL  ,   Go? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444346/">https://habr.com/ru/post/444346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444336/index.html">Listas de captura r√°pida: ¬øcu√°l es la diferencia entre enlaces d√©biles, fuertes y no propios?</a></li>
<li><a href="../444338/index.html">Encapsulaci√≥n en Python 3</a></li>
<li><a href="../444340/index.html">Caracter√≠sticas del uso del tipo de datos Symbol en JavaScript</a></li>
<li><a href="../444342/index.html">Desarrollar aplicaciones JavaScript simples y modernas utilizando Webpack y tecnolog√≠as web avanzadas</a></li>
<li><a href="../444344/index.html">10 pasos para un proyecto exitoso de Python</a></li>
<li><a href="../444348/index.html">¬øEn qu√© se diferencian los componentes funcionales de React de los componentes basados ‚Äã‚Äãen clases?</a></li>
<li><a href="../444350/index.html">Por alguna raz√≥n, MVP (producto m√≠nimo viable) no se inicia</a></li>
<li><a href="../444352/index.html">Kontur.Kampus: te invitamos a un campamento estudiantil gratuito de desarrollo industrial cerca de San Petersburgo</a></li>
<li><a href="../444356/index.html">Tutorial de React Parte 24: Lecci√≥n de los segundos formularios</a></li>
<li><a href="../444358/index.html">Enumerable: c√≥mo generar un valor comercial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>