<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛕 🗺️ 👂🏼 Schlacht von MERGE. Chronik mit Schlussfolgerungen und Moral 💹 👨🏻‍💼 👫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einige Wochen vor dem wichtigen Commit-Festival - dem letzten vor der feature freeze Version von PostgreSQL 11 - sahen sich die Hacker- Newsletter, di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schlacht von MERGE. Chronik mit Schlussfolgerungen und Moral</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/412605/"> Einige Wochen vor dem wichtigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit-Festival</a> - dem letzten vor der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>feature freeze</code></a> Version von <b>PostgreSQL 11</b> - sahen sich die <b>Hacker-</b> Newsletter, die den Chipsatz im linken Paket komprimierten, den <b>MERGE-</b> Thriller an.  Der Thriller-Regisseur und CEO von <b>2ndQuadrant, <i>Simon Riggs</i></b> , versuchte mit beeindruckender Ausdauer und Einfallsreichtum, einen Patch zu veröffentlichen, der die Syntax des MERGE-Befehls in die Version implementiert.  Riggs ist seit 2009 ein Comedian und mit dem Status eines Comedians können Sie Patches selbst genehmigen.  Er wurde von nicht weniger angesehenen PostgreSQL-Komitees und Veteranen abgelehnt.  Die Leidenschaften brodelten klar und implizit, es kam nicht einmal zu direkten Beleidigungen - eine überraschende Tatsache für Stammgäste in vielen Inlandsforen.  Bis zur Klärung der Frage blieb jedoch eine gewisse Spannung bestehen, und es gibt nichts zu streiten. <a name="habracut"></a><br><br>  Aber Leidenschaften sind Leidenschaften (sie werden weiter besprochen), und ich möchte die Essenz dieses völlig weit hergeholten Problems leidenschaftslos herausarbeiten. <br><br><img src="https://habrastorage.org/webt/t5/zc/ra/t5zcramwnjffszncwjkkkl9xt2g.jpeg"><br><h3>  Draußen verschmelzen </h3><br>  Wenn es vollständig vereinfacht ist, ist die Sache folgende: Wir haben 2 Tabellen mit denselben Feldern und unterschiedlichen Daten.  Nehmen Sie Namen und Alter an.  Wir müssen sie zu einem kombinieren.  Es wäre jedoch notwendig zu entscheiden, was mit den Persönlichkeiten in beiden Tabellen geschehen soll.  Höchstwahrscheinlich wollen wir alles in der Final Table und aktualisieren die Informationen auf übereinstimmende Personen.  Es ist klar, dass dies auch in dieser Umgebung eine sehr häufige Aufgabe ist.  Es kann ohne <code>MERGE</code> gelöst werden, eine komplexe Anfrage stellen, Sie können Trigger verwenden und so weiter.  Aber es ist unpraktisch.  Die nicht-kanonische Version von MERGE, die UPSERT (UPdate + inSERT) heißt, löst dieses Problem jedoch. <br><br>  Der MERGE-Operator befindet sich im SQL-2003-Standard und ist in SQL-2008 bereits in seiner ganzen Pracht.  Es ist in Oracle, DB2 und in MS SQL implementiert, was bedeutet, dass das Fehlen von MERGE diejenigen verärgert, die erwägen, von diesen DBMS auf PostgreSQL umzusteigen.  Simon Riggs 'sehnsüchtiger Wunsch, so schnell wie möglich, bereits in PostgreSQL 11, wurde von den Wünschen der Kunden von 2ndQuadrant angetrieben und nicht von Ehrgeiz oder Streit. <br><br>  Tatsächlich verfügt MERGE über umfangreiche Funktionen. Die Daten müssen nicht aus Tabellen entnommen werden, insbesondere nicht aus ähnlichen Strukturen. <br><br>  Die Befehlssyntax lautet wie folgt: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tablename <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> table_reference <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> column1 = value1 [, column2 = value2 ...] <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (column1 [, column2 ...]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (value1 [, value2 ...]);</code> </pre> <br>  Sie können jedoch Folgendes tun: <br><br><pre> <code class="hljs powershell">MERGE <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">hint</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">INTO</span></span></span></span> <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">schema</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">.</span></span></span><span class="hljs-function">] {</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table</span></span></span></span> | view} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">table_alias</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USING</span></span></span></span> { subquery | <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">schema</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">.</span></span></span><span class="hljs-function">] { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table</span></span></span></span> | view}} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">table_alias</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ON</span></span></span></span> ( condition ) [ <span class="hljs-type"><span class="hljs-type">merge_update_clause</span></span> ] [ <span class="hljs-type"><span class="hljs-type">merge_insert_clause</span></span> ] [ <span class="hljs-type"><span class="hljs-type">error_logging_clause</span></span> ] ;</code> </pre> <br>  Diese Syntax ist in Oracle implementiert.  Mit anderen Worten, dann führt MERGE Aktionen aus, mit denen die Datensätze in der Zieltabelle target_table_name mithilfe von data_source in einem einzelnen SQL-Befehl geändert werden. Je nach den Bedingungen kann INSERT, UPDATE oder DELETE in Bezug auf die Datensätze in target_table_name ausgeführt werden.  In diesem Fall kann target_table_name eine Ansicht sein, und data_source kann eine Reihe von <b>Tabellen oder Ansichten sein, die das Ergebnis einer Unterabfrage sind</b> . <br><br>  Zunächst führt die <code>MERGE</code> einen <code>left outer join</code> für die <code>data_source</code> mit dem <code>target_table_name</code> , wobei 0 oder mehr Kandidatenänderungsdatensätze vorgeschlagen werden.  <code>WHEN</code> Klauseln werden in der angegebenen Reihenfolge berechnet.  Sobald die Bedingung erfüllt ist, wird die entsprechende Aktion ausgeführt.  Schlüsselwörter <code>WHEN [NOT] MATCH THEN</code> sind in <code>SQL</code> nicht sehr verbreitet, daher erinnern wir Sie daran, dass dies ein Steuerelementkonstrukt wie <code>if-else</code> in anderen Sprachen ist.  <code>MERGE</code> <code>target_table_name</code> <code>DELETE</code> in Bezug auf <code>target_table_name</code> genauso wie <code>UPDATE, INSERT</code> oder <code>DELETE</code> , nur die Syntax des gesamten Befehls ist unterschiedlich. <br><br>  Eine Klausel mit <code>ON</code> muss eine Verbindung zu allen Spalten des Primärschlüssels herstellen. Wenn andere Spalten angegeben werden, muss ein eindeutiger Index verwendet werden, damit die <code>[NOT] MATCHED</code> sofort die Aktionen für den Kandidatendatensatz bestimmen, um die Interaktion mit anderen Transaktionen auszuschließen. <br><br>  <code>MERGE</code> deterministischer Befehl: Sie können denselben Datensatz nicht mehrmals im selben MERGE-Befehl aktualisieren. <br>  Ein Beispiel: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> CustomerAccount CA <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> RecentTransactions T <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> T.CustomerId = CA.CustomerId <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Balance = Balance + TransactionValue <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (CustomerId, Balance) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (T.CustomerId, T.TransactionValue);</code> </pre> <br>  oder mit einer Unterabfrage: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bonuses D <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employee_id, salary, department_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">80</span></span>) S <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (D.employee_id = S.employee_id) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> D.bonus = D.bonus + S.salary*<span class="hljs-number"><span class="hljs-number">.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (S.salary &gt; <span class="hljs-number"><span class="hljs-number">8000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (D.employee_id, D.bonus) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (S.employee_id, S.salary*<span class="hljs-number"><span class="hljs-number">.01</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (S.salary &lt;= <span class="hljs-number"><span class="hljs-number">8000</span></span>);</code> </pre> <br>  In <b>IBM DB2</b> funktioniert auch <b>die</b> Syntax.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie sie sagen</a> , "unter der Haube" wird dies ähnlich wie beim <code>UPDATE FROM</code> Konstrukt gemacht. <br>  Seit 2008 hat <b>MS SQL</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auch</a> <code>MERGE</code> . <br><br>  Aber selbst hinter einer einzigen Standardsyntax beginnt das Problem der Auswahl aus einer beträchtlichen Anzahl von Mechanismen und Implementierungsmethoden.  Das Team sollte auf verschiedenen Ebenen der Transaktionsisolation mit unterschiedlichen Sperralgorithmen arbeiten und sich auf wettbewerbsintensive oder weniger wettbewerbsfähige Betriebsarten konzentrieren.  Und um diese komplizierte Logik zu implementieren, müssen Sie, wie Sie vielleicht vermuten, viele DBMS-Komponenten berühren. <br><br><h3>  UPSERT, Pseudo-MERGE </h3><br>  Es ist klar, dass DBMS-Entwickler nach Kompromisslösungen suchten und sich weigerten, die Standardsyntax buchstäblich zu reproduzieren.  Das Plus dieses Ansatzes ist die Freiheit.  Sie können organische Mechanismen verwenden, die für ein bestimmtes DBMS organisch sind. Sie können die Implementierung für Aufgaben optimieren, die Sie für Ihre Benutzer als am relevantesten erachten. <br><br>  In <b>MySQL</b> gibt es beispielsweise einen <code>REPLACE</code> Befehl, der wie <code>INSERT</code> funktioniert. Wenn jedoch die neuen und alten Zeilen im <code>PRIMARY KEY</code> oder <code>UNIQUE</code> Index dieselben Werte haben, wird die alte Zeile vor dem Einfügen der neuen Zeile gelöscht.  Es gibt aber auch <code>INSERT ... ON DUPLICATE KEY UPDATE</code> wo <code>INSERT</code> und <code>UPDATE</code> auftreten (anstelle von <code>DELETE</code> in <code>REPLACE</code> ).  Das ist <code>UPSERT</code> .  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es gibt</a> <code>INSERT IGNORE</code> , das das Einfügen einfach nicht durchführt, ohne unter bestimmten Einschränkungen einen Fehler (aber eine Warnung) in der <code>INSERT IGNORE</code> . <br><br><h3>  Chroniken von PG MERGE </h3><br>  In der PostgreSQL-Community begann das Gespräch über MERGE im Jahr 2005, als Jaime Casanova fragte, <i>ob jemand in der Community mit der Entwicklung von</i> <code>MERGE</code> .  <i>Peter Eisentraut</i> <a href="">schlug vor, zu diskutieren,</a> <i>ob es sich lohnen würde, eine MERGE-Option für PostgreSQL zu entwickeln: eine ähnliche Implementierung in MySQL, oder es wäre besser, Ihre Bemühungen auf eine Oracle-Version des <code>MERGE</code> Typs zu lenken, die eine <code>MERGE</code> Funktionalität aufweist.</i>  <i>Lohnt es sich jedoch, Anstrengungen in diese Richtung zu unternehmen?</i> <br><br>  Inmitten einer kurzen Diskussion erscheint der Protagonist dieser Erzählung <i>Simon Riggs</i> mit den Worten: <br>  <i>MERGE ist sowohl für OLTP-Systeme als auch für DW (Data Warehouse - Data Warehouses, dh analytische Anwendungen, bei denen komplexe Abfragen, aber nicht zu wettbewerbsfähige Umgebungen und Daten selten aktualisiert werden und wenn sie aktualisiert werden, normalerweise in großen Blöcken, nützlich. &lt;...&gt; Wir können MERGE als eine Variante von COPY FROM implementieren, es wird sehr cool sein.</i> <br><br>  Alle sind sich einig: Ja, cool.  Genauer gesagt, fast alles: <i>Stephen Frost</i> : <i>Ich glaube, ich bin nicht der einzige, der sagt, dass ich einen vollwertigen, konformen MERGE-Standard brauche.</i> <br><br>  Bruce Momjian hat einen anderen, pragmatischeren Vorschlag: <i>Es scheint mir, dass wir</i> <i>einige Optionen, die wir implementieren können,</i> <i>in</i> <code>MERGE</code> <i>implementieren müssen, und im Rest werden wir einen Fehler geben (und in Fällen, in denen es notwendig sein wird, die gesamte Tabelle zu blockieren).</i>  <i>Und nachdem wir Feedback von Benutzern erhalten haben, werden wir überlegen, was als nächstes zu tun ist.</i> <br><br>  Aber bisher passiert nichts. <br><br><h3>  Das Eis ist gebrochen </h3><br>  Im Jahr <b>2008 forderte</b> <i>Simon Riggs</i> erneut auf, sich mit MERGE zu befassen - welche der Möglichkeiten zu wählen (zu diesem Zeitpunkt erschien bereits eine neue Version von MERGE im SQL-2008-Standard, soweit es sich um einen Entwurf handelte).  Er malt ausführlich die aktuelle Implementierung von Oracle, IBM und MS SQL sowie die alternative Syntax von MySQL und Teradata.  Und wenig später erwähnt er bereits den <b>Beginn der Arbeit im 2. Quadranten</b> in dieser Richtung. <br><br>  Peter Eisentraut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schreibt in seinem Blog</a> : <i>Natürlich ist Riggs einer der qualifiziertesten Spezialisten, er kann die Arbeit an der Implementierung von MERGE leiten.</i> <br><br>  Aber hier kommt die erste unerwartete Wendung: Ein <b>Student</b> ist in das Problem involviert - ein Teilnehmer an der Entwicklung des <b>GSoC-</b> Programms, <b>dh</b> Google Summer of Code.  Sein Name ist <i>Boxuan Bxzhai</i> - ich <i>nehme</i> nicht an, den Nachnamen zu transkribieren.  Bald schreibt er, dass die Arbeit fast erledigt ist. <br><br>  Aber fast zählt nicht.  <i>Greg Smith</i> von 2ndQuadrant (d. H. Simon Riggs Verbündeter) schreibt: <br>  <i>Wir haben also einen Patch im Code, der ein halbes Dutzend schwerwiegender ungelöster Probleme enthält.</i>  <i>Ich schweige über die Kleinen.</i>  <i>Die Probleme sind zu tief, um den Code für das Commitfest fertigzustellen.</i>  <i>Inzwischen ist seit langem nichts mehr von Boxuan zu hören.</i>  <i>Wir könnten ihm helfen, aber wo ist er?</i>  <i>Wer weiß Bescheid?</i> <br><br>  Eine Diskussion über Implementierungspfade wird <b>2014</b> wieder aufgeflammt, aber es passiert wieder nichts: Es gibt keinen Code. <br><br>  Schließlich schreibt <i>Simon Riggs</i> bereits <b>2017</b> : <br>  <i>Ich arbeite an Code, um <code>MERGE</code> für <b>PostgreSQL</b> Version <b>11 zu übernehmen</b> .</i>  <i>Wir verwenden dieselben Mechanismen, die dem bereits funktionierenden <code>INSERT ON CONFLICT</code> zugrunde <code>INSERT ON CONFLICT</code> , sodass keine Änderungen an der Infrastruktur erforderlich sind. Grundsätzlich wird nur die Syntax zusätzlich zu den verfügbaren implementiert.</i>  <i>Aber ich schreibe meinen Code von Grund auf neu, ich verwende keine früheren Entwicklungen.</i> <br><br>  Wir sprechen über Peter Geoghegan ( <b>VMware</b> ), der zu diesem Zeitpunkt bereits in 9.5 alternativer <code>INSERT .. ON CONFLICT UPDATE</code> Syntax <code>INSERT .. ON CONFLICT UPDATE</code> , anders als der SQL-Standard, aber immer noch mit <code>MERGE</code> und <code>REPLACE</code> in MySQL verbunden. <br><br>  Zuerst wurde Simons Arbeit mit Ausrufen von Nizza Arbeit getroffen!  Obwohl <i>Robert Haas</i> unterstützend ist, warnt er vor möglichen Serialisierungsanomalien.  <code>INSERT .. ON CONFLICT UPDATE</code> mit <code>INSERT .. ON CONFLICT UPDATE</code> umzugehen <code>INSERT .. ON CONFLICT UPDATE</code> , ohne MERGE an der Basis, ist es irgendwie ruhiger. <br><br>  PostgreSQL <code>UPSERT</code> Autor <code>UPSERT</code> selbst: <br>  <i>Ich würde den <code>MERGE</code> <code>ON CONFLICT DO UPDATE</code> und <code>MERGE</code> nicht mischen.</i>  <i>&lt;...&gt; Zum Laden großer Datenmengen ( <code>bulk load</code> ) würde ich beispielsweise den <code>merge join</code> Algorithmus verwenden.</i>  <i>&lt;...&gt; Im Allgemeinen <code>MERGE</code> die Vorteile von <code>MERGE</code> damit zusammen, dass normale Verbindungen dort auf die übliche Weise funktionieren: <code>nested loop, hash, merge</code> .</i>  <i>Und in <code>INSERT … ON CONFLICT</code> gibt es überhaupt keine Joins.</i> <br><br>  Haas: <i>Wie Peter denke ich, dass auf diese Weise eine so starke Sperre bei der Ausführung einer <code>DML</code> Anfrage <code>DML</code> aussieht.</i>  <i>Es ist unwahrscheinlich, dass sich jemand darüber freut, dass nur eine Person gleichzeitig mit <code>MERGE</code> arbeiten kann.</i> <br><br>  Für Neugierige: Geigan zerlegt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> die Feinheiten und <code>UPSERT</code> Unterschiede zwischen <code>MERGE</code> und <code>MERGE</code> (wir speichern die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">archivierte Korrespondenz von</a> PostgreSQL auf unserer Website). <br><br>  Simon widersetzt sich.  Er appelliert an die jüngste Geschichte.  Zum Thema Abschnitt sagten sie auch "eine neue Syntax, nichts weiter".  Aber es stellte sich als sehr nützliche Sache heraus.  <i>Aber ich habe nicht vor, sofort alles zu realisieren, was in MERGE ist.</i>  <i>Wir werden das Gleiche tun wie bei der Partitionierung - wir teilen die Entwicklung in Phasen ein.</i> <br><br>  Und noch ein Argument ist meiner Meinung nach sehr überzeugend: <i>Gut.</i>  <i>Aber lass uns wählen.</i>  <i>Ich schlage eine praktische Option vor.</i>  <i><b>10 Jahre werden bald</b> vom ersten ernsthaften Versuch kommen, <code>MERGE</code> zu entwickeln.</i>  <i>Ist es nicht an der Zeit, etwas zu tun, um eine nützliche Lösung zu finden, anstatt auf weitere 10 Jahre der perfekten Lösung zu warten?</i>  <i>Vorausgesetzt, es existiert überhaupt.</i> <br><br>  Schließlich kommt der Patch in der Community an.  Welches Datum?  Stellen Sie sich bitte vor.  Nein, sie haben es nicht erraten: Simon schickt ihn am 30. Dezember 2017.  Und legt fest, dass dies ein WIP-Patch ist, dh Work in Progress - ein Patch in Arbeit. <br><br>  Simon, Januar: <br>  <i>Der Patch wird ohne spezielle Fehler abgeschlossen.</i>  <i><b>1200 Codezeilen</b> plus Tests und Dokumentation.</i>  <i>Ich werde ihn für dieses Commitfest verpflichten, und wir werden die RLS- (Row Level Security - Schutz auf Aufzeichnungsebene) und Partitionierungsunterstützung später abschließen.</i> <br><br><h3>  Kaste der Ausschüsse </h3><br>  Hier müssen wir einen Schritt beiseite treten und die Rolle des Kommissars in der Gemeinde erklären.  Die Funktionen des Beauftragten, dh desjenigen, der befugt ist, den Patch in der nächsten Version zu akzeptieren, haben sich historisch geändert.  Es war einmal, als es nur wenige Entwickler gab, das Recht, sich zu verpflichten, wurde großzügig verteilt.  Zum Beispiel erhielt der berühmte (auf einem ganz anderen Gebiet) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Julian Assange</b></a> den Titel eines Kommandanten, der nur sechs Patches verfasste.  Jetzt ist es nicht einfach, Kommissar zu werden. Auf der Liste von ein paar Dutzend Personen stehen keine Emporkömmlinge.  Boyus Momdjan ( <b>EnterpriseDB</b> ) hat 13.363 Commits, Tom Lane (Tom Lane, <b>Crunchy Data</b> ) 13127, Robert Haas ( <b>EnterpriseDB</b> ) - 2074. Der <b>einzige Committer aus Russland</b> ist <i>übrigens Fedor Sigaev</i> (Teodor Sigaev, <b>Postgres Professional</b> ) mit seinen 383 Commits .  Simon Riggs selbst hat 449 von ihnen. Ich wiederhole: Er hat als Kommissar genug Autorität, um Patches zu nehmen und zu begehen - seine und seine Mitarbeiter.  Eine andere Sache ist, dass es sich kaum lohnt, dies zu tun, indem man offen die Meinungen anderer führender Leuchtenkomitees vernachlässigt.  Sie können auch den Status eines Kommissars entziehen, aber zumindest werden sie <code>revert</code> Patch zurücksetzen. <br><br><h3>  Bruch im Kampf </h3><br>  Natürlich finden sie in dem "hoffnungslosen" Patch, der im Allgemeinen hastig erstellt wurde, neue Fehler.  Neue Versionen rollen als Antwort. <br><br>  Ende Januar erscheint ein neuer Charakter: der Entwickler von 2ndQuadrant <i>Pavan</i> (sein Name ist jeder mit Namen; vollständig Pavan Deolasee).  Jetzt hat es die Community mit einem Tandem zu tun: Pavan sendet neue Versionen und bedankt sich für die Kritik, und Simon bricht sie mit einem bemerkenswerten Marketingdruck. <br><br>  Haas: <i>Ich denke nicht, dass es sich lohnt, einseitige Entscheidungen über den Ausschluss von Funktionen zu treffen, die überall funktionieren.</i>  <i>Wenn wir uns einig sind, dass einige Funktionen nicht in diesem Patch enthalten sind, ist dies eine Sache.</i>  <i>Und es ist völlig anders, dass in den Kommentaren zu diesem Anlass alle ihre Uneinigkeit zum Ausdruck brachten.</i>  <i>Und wir haben tatsächlich nicht gehört, warum diese Funktionen ausgeschlossen werden sollten.</i> <br><br>  Die Logik wurde wie folgt dargestellt: <br><br><ul><li>  a priori gibt es ernsthafte Probleme, weil sie nur in den Entwicklungen im Stil des "Kavallerieangriffs" liegen können. </li><li>  Die Unterstützung selbst wichtiger Funktionen wie der neuen Partitionierung in den Versionen 10-11, CTE (Common Table Expressions = WITH-Abfragen) oder RLS (Row Level Security) kann auch dann abgeschlossen werden, wenn der Patch in der aktuellen Version akzeptiert wurde, jedoch nur, wenn die vorgeschlagene Architektur für den Aufbau auf der Oberseite geeignet ist ihre gewünschte Funktionalität. </li></ul><br>  Der zweite Peter Geigan formuliert dies: <br>  <i>Normalerweise achte ich auf die <b>Unterstützung verschiedener Funktionen, da dies die allgemeine Überzeugung stärkt, dass das Design so gestaltet ist, wie es sollte</b> .</i>  <i>Und wenn solche Probleme durch die Unterstützung von <code>WITH</code> Ausdrücken [ <code>CTE</code> ] verursacht werden, komme ich auf die Idee, dass die zugrunde liegende Architektur so ist, dass sie hier und da Probleme verursacht.</i> <br><br>  In der Zwischenzeit nähert sich die Stunde X (das letzte Komiteefest) und die Wolken über MERGE ziehen auf.  Es ist nicht so, dass die Gründerväter speziell ernsthafte Probleme in der Architektur der Patches von Simon und dann Pavan suchten.  Ich musste nicht nach Problemen suchen, sie öffneten sich bereitwillig. <br><br><h3>  Die Auflösung nähert sich </h3><br>  Die Handlung beschleunigt sich.  Trotz der coolen Haltung anderer Komitees zu seinem Unternehmen beschließt Simon <b>am 2. April</b> , den <b>Befehl nach dem SQL: 2016-</b> Patch zu übernehmen, fügt die Dateien hinzu, Depesz (Hubert Lubachevsky) schafft es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, ihn</a> auf seinem Blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzukündigen</a> , aber am selben Tag rollt Simon alles zurück, weil Fehler. <br><br>  Legen Sie am nächsten Tag erneut fest, indem Sie <code>WITH</code> Unterstützung hinzufügen. <br><br>  Als Reaktion darauf sind die Vorwürfe wirklich schwerwiegend.  <i>Andres Freund</i> ( <b>EnterpriseDB</b> ) schreibt: <br>  <i>Die Architektur für MERGE im Parser und im Executor hat mich nicht zuverlässig beeindruckt.</i>  <i>Das Erstellen versteckter Verknüpfungen während der Parsing-Analyse ist eine wirklich schlechte Idee.</i>  <i>Diese Struktur des Executors muss komplett geändert werden.</i> <br><br>  Tom Lane: <br>  <i>Das Design des Analysebaums ist schwach.</i> <br><br><br><br>  <i>Sie überladen die <code>InsertStmt</code> Funktion, fährt er fort, sie führt <code>INSERT</code> überhaupt nicht aus, hat aber zufällig die gleichen Felder wie das ursprüngliche.</i>  <i>Und nicht alle, aber einige.</i>  <i>Das ist schlecht, es führt zu Verwirrung.</i> <br><br>  <i>Fügen</i> wir Beobachtungen von <i>Fedor Sigayev hinzu</i> : <br>  <i>Im Parser wurden <code>MERGE</code> bezogene <code>INSERT</code> Knoten <code>MERGE</code> , die mit einer Reihe zusätzlicher Felder aufgehängt waren.</i>  <i>Wenn Sie sich den Ausführungsplan in <code>ANALIZE</code> , werden Sie nicht sofort verstehen, ob es sich um ein reguläres <code>INSERT</code> oder um <code>MERGE</code> : <code>MERGE</code> zu verstehen, müssen Sie sich zusätzliche Felder ansehen.</i> <br><br><br>  Simon, ruhig: <i>OK, wir werden das ändern und morgen eine neue Datei senden</i> . <br>  Haas: <i>Ich stimme Peter zu.</i>  <i>Die Wahl der Architektur ist erfolglos.</i> <br><br>  Simon gibt nicht auf.  <b>Als</b> Reaktion auf die Kritik an Tom Lane begeht der <b>6. April</b> einen neuen Patch in der im Parser geänderten Fassung. <br><br><h3>  Verhandlung und Kapitulation </h3><br>  Bruce Momjan <b>6. April</b> : <br>  <i>Ich möchte darauf hinweisen, dass die Leute Sie nicht gebeten haben, hart zu arbeiten, um dringend etwas zu reparieren.</i>  <i>Sie haben dich gebeten, den Patch zurückzuziehen.</i>  <i>Sie können natürlich hart arbeiten und hoffen, dass sie ihre Meinung ändern, aber auch hier haben sie Sie nicht danach gefragt.</i> <br><br>  Simon: <i>Wenn Tom [Lane] und Andres [Freund] in den verbleibenden Tagen immer noch das Gefühl haben, dass ihre Befürchtungen nicht zerstreut wurden, werde ich <b>den Patch gerne</b> ohne weiteres zurücksetzen.</i> <br><br>  Tom Lane: <i>Ich stimme immer noch dafür, dass der Patch zurückgesetzt wird.</i>  <i>Selbst wenn er jetzt perfekt wäre, haben die Menschen jetzt keine Zeit, sich davon zu überzeugen - bis hin zu anderen dringenden Angelegenheiten.</i> <br><br>  Das ist alles. <br><br>  Simon sagte OK und der Kampf bei <code>MERGE</code> vorbei.  Alle Patches wurden zurückgepumpt, das Thema wurde auf das nächste Commitfest mit dem Status "Warten auf den Abschluss des Autors" verschoben.  Die Teilnehmer der Show schlossen Frieden. <br><br><img src="https://habrastorage.org/webt/ad/zw/ry/adzwryarovhxoldwxewpneljyms.jpeg"><br>  Nach der Korrespondenz der letzten Wochen scheint jedoch eine gewisse Spannung bestehen zu bleiben. <br><br><h3>  Versprochene Moral </h3><br><ul><li>  Glücklicherweise verfügt die PostgreSQL-Community über natürliche und formale Mechanismen für das (fast) konfliktfreie Screening von Versuchen unreifer Lösungen.  Auch wenn sie von angesehenen Entwicklern im Rang eines Unternehmensleiters geschlagen werden, dessen Beitrag zur Entwicklung von PostgreSQL enorm ist.  Und Kunden, denen es an Funktionalität mangelt, drängen auf Investitionen. </li><li>  Leider bleibt die Community oft stehen.  Es ist träge bei der Annahme selbst eindeutig relevanter Entwicklungen.  Manchmal ist irrationaler Perfektionismus enthalten.  Die Erfahrung von Postgres Professional, wo ich arbeite, bestätigt dies.  Wir haben 3 Jahre lang einen großen und wichtigen Patch mit <b>INCLUDE-Indizes erstellt</b> .  Eine nützliche Reihe von Patches für die Arbeit mit <b>JSON / JSONB</b> wartet noch.  Der Ausdruck "Gib der Gemeinde deine Entwicklung" bedeutet <b>nicht wirklich Geben, sondern Schlagen</b> : Der Gast wird mit offenen Armen begrüßt und in die Quarantäne geführt. </li></ul><br>  PS: <i>Haftungsausschluss des Autors</i> : Wir wollten nur ein Stück Gemeinschaftsleben zeigen.  Alle Namensübereinstimmungen sind zufällig :) <br>  PPS: Samurai <i>Natalia Levshina</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412605/">https://habr.com/ru/post/de412605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412591/index.html">Jetpack bauen: Der 29. Mai ist Wendell Moores Gedenktag</a></li>
<li><a href="../de412593/index.html">Neue Produkte, Plattformen und All-as-a-Service: HPE-Webinare</a></li>
<li><a href="../de412595/index.html">Bericht des Club of Rome 2018, Kapitel 1.1.2: „Finanzierung“</a></li>
<li><a href="../de412597/index.html">Jeff Bezos wird eine Kolonie auf der Oberfläche des Mondes bauen</a></li>
<li><a href="../de412603/index.html">Seltsame PHP-Aussagen</a></li>
<li><a href="../de412607/index.html">Umkehrbare Lötstation HI-END Klasse</a></li>
<li><a href="../de412609/index.html">10 Tipps zur Produktivität in CLion, einer plattformübergreifenden C / C ++ - IDE</a></li>
<li><a href="../de412611/index.html">Was haben effektive Bergbau- und Spieltheorie gemeinsam?</a></li>
<li><a href="../de412613/index.html">Ganzzahlige Arithmetik. Teilen Sie durch Runden des Ergebnisses. Teil 1</a></li>
<li><a href="../de412615/index.html">Vorhandensein eines Routenziels in BGP-Ankündigungen zwischen PE und CE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>