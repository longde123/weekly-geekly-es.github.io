<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘Š ğŸ¤´ğŸ¾ ğŸ¤›ğŸ» Kata kunci ini dalam JavaScript. Lengkap * manual ğŸ¤™ğŸ½ ğŸ¯ ğŸ˜“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Kemungkinan besar, saya melewatkan sesuatu, tetapi saya yakin komentar akan mengatakan ini kepada saya 

 Saya menulis artikel ini untuk kebutuhan p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kata kunci ini dalam JavaScript. Lengkap * manual</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464163/">  <i>* Kemungkinan besar, saya melewatkan sesuatu, tetapi saya yakin komentar akan mengatakan ini kepada saya</i> <br><br>  Saya menulis artikel ini untuk kebutuhan pribadi saya.  Direncanakan bahwa itu akan berisi jawaban atas semua pertanyaan yang diajukan siswa kepada saya mengenai topik ini.  Jika ini berguna untuk orang lain - hebat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/2da/271/b5a2da27174296bd7352ea961789cd7e.jpg" alt="gambar"></div><br>  Konten <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesalahpahaman tentang ini</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara menentukan nilai ini</a> </li></ol><a name="habracut"></a><br><a name="intro"></a><h3>  Pendahuluan </h3><br>  Kata <code>this</code> adalah salah satu fitur yang paling membingungkan dari bahasa JavaScript.  Berasal dari Jawa, itu dimaksudkan untuk membantu dalam implementasi OOP.  Saya menulis di Jawa untuk beberapa waktu, dan saya harus mengatakan bahwa selama ini, mungkin saya pernah meragukan apa <code>this</code> sama dengan di tempat tertentu dalam kode.  Dalam JavaScript, keraguan semacam itu dapat muncul setiap hari - setidaknya sampai saat Anda mempelajari beberapa aturan sederhana namun tidak jelas. <br><br><a name="heresy"></a><h3>  Kesalahpahaman tentang <code>this</code> </h3><br>  Ada beberapa kesalahpahaman umum tentang kata kunci ini.  Saya ingin segera mengusir mereka sebelum saya sampai ke titik. <br><br>  <b>ini adalah konteks leksikal.</b> <br><br>  Kesan ini sering muncul di kalangan pemula.  Tampaknya bagi mereka bahwa <code>this</code> adalah objek di mana, seperti properti, semua variabel dalam cakupan ini disimpan.  Kesalahpahaman ini bermula dari fakta bahwa dalam satu kasus tertentu, secara kasar, memang demikian.  Jika kita berada di level tertinggi, maka <code>this</code> sama dengan <code>window</code> (dalam hal skrip biasa di browser).  Dan seperti yang kita ketahui, semua variabel yang dideklarasikan di tingkat atas tersedia sebagai properti <code>window</code> . <br><br>  Secara umum, ini tidak benar.  Ini mudah diverifikasi. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-string"><span class="hljs-string">"     ,   "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a); } test(); <span class="hljs-comment"><span class="hljs-comment">//  ,   </span></span></code> </pre><br>  <b>ini adalah objek yang dimiliki metode ini</b> <br><br>  Sekali lagi, ini benar dalam banyak kasus tertentu, tetapi tidak selalu.  Yang penting adalah bagaimana fungsi dipanggil, dan bukan apakah itu adalah properti dari beberapa objek.  Ini dapat dimengerti bahkan dari logika yang sangat sederhana: anggap fungsi yang sama adalah properti dari dua objek secara bersamaan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: f }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: f };</code> </pre><br>  Jadi benda mana yang akan menjadi miliknya ini? <br><br>  Penting!  Bahkan jika suatu objek dibuat menggunakan kelas ES6, ini tidak menjamin sama sekali bahwa metodenya akan selalu memiliki <code>this</code> .  Jangan tertipu oleh kemiripan dengan kelas dari bahasa "normal". <br><br>  <b>ini adalah teknik Jedi yang, sekali dipelajari, perlu digunakan di mana-mana</b> <br><br>  Sebaiknya hindari penggunaan <code>this</code> jika memungkinkan.  Satu-satunya kasus ketika sepenuhnya dibenarkan adalah OOP.  Di tempat lain, menggunakan <code>this</code> bukan hanya jahat, tetapi biasanya terlalu banyak membingungkan kode.  Pada dasarnya, <code>this</code> adalah argumen tambahan, â€œminus yang pertamaâ€ pada fungsi, yang diteruskan ke sana dengan cara yang rumit dan tidak jelas bagi pemula.  Dengan probabilitas tinggi, itu bisa digantikan oleh argumen yang biasa, dan itu hanya akan menjadi lebih baik. <br><br><a name="howto"></a><h3>  Cara menentukan nilai ini </h3><br>  Di sini saya akan mencoba untuk memberikan algoritma yang ketat dan ringkas yang bahkan seorang programmer yang tidak berpengalaman akan dapat memahami apa yang sama dengan ini dalam kasus khusus.  Penjelasan lebih verbal akan disembunyikan di bawah spoiler, sehingga tidak mengacaukan ruang visual. <br><br><ol><li>  <b>Apakah kita di dalam suatu fungsi?</b> <br><br><ul><li>  <b>Ya:</b> lihat item berikutnya. </li><li>  <b>Tidak:</b> <code>this</code> sama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek global</a> . </li></ul><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text">  Dalam kode tingkat atas (tidak di dalam fungsi apa pun), <code>this</code> selalu merujuk ke objek global.  Dalam kasus skrip reguler di browser, ini adalah objek <code>window</code> .  Tetapi secara umum, ada kasus yang berbeda. <br></div></div></li><li>  <b>Apakah kita di dalam fungsi panah?</b> <br><br><ul><li>  <b>Ya:</b> nilai <code>this</code> sama dengan di fungsi satu tingkat lebih tinggi (mis. Yang berisi ini).  Kembali ke langkah sebelumnya dan ulangi algoritme untuknya.  Jika fungsi tidak terkandung dalam yang lain, <code>this</code> adalah objek global. </li><li>  <b>Tidak:</b> lihat paragraf berikutnya. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text">  Salah satu fitur utama fungsi panah adalah apa yang disebut "leksikal <code>this</code> ".  Ini berarti bahwa nilai <code>this</code> dalam fungsi panah ditentukan semata-mata oleh di mana (dalam konteks leksikal apa) itu dibuat, dan tidak bergantung pada bagaimana ia selanjutnya disebut.  Terkadang ini bukan yang kita butuhkan, tetapi lebih sering membuat fungsi panah sangat mudah dan dapat diprediksi. <br></div></div></li><li>  <b>Apakah fungsi ini disebut sebagai konstruktor (menggunakan operator baru)?</b> <br><br><ul><li>  <b>Ya:</b> <code>this</code> merujuk ke objek baru yang "sedang dibangun". </li><li>  <b>Tidak:</b> lihat paragraf berikutnya. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text">  Mungkin ada baiknya secara terpisah menentukan kasus ketika datang ke konstruktor dari kelas ES6 yang diwarisi.  Kemudian, sebelum memanggil <code>super()</code> , <code>this</code> tidak memiliki nilai (mengaksesnya akan menyebabkan kesalahan), dan setelah memanggil <code>super()</code> itu sama dengan objek baru dari kelas induk. <br></div></div></li><li>  <b>Apakah fungsi ini dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bind</a> ?</b> <br><br><ul><li>  <b>Ya:</b> nilai <code>this</code> sama dengan nilai argumen pertama yang kami sampaikan ke metode <code>bind</code> saat membuat fungsi ini. </li><li>  <b>Tidak:</b> lihat paragraf berikutnya. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text">  Metode <code>bind</code> membuat salinan fungsi, memperbaikinya dan, opsional, beberapa argumen pertama untuk itu.  Bahkan, ini menciptakan tidak hanya salinan fungsi, tetapi, saya kutip, "objek BoundFunction eksotis".  Eksotismenya dimanifestasikan, khususnya, di mana oleh seruan berulang untuk <code>bind</code> kita tidak bisa lagi mengubah <code>this</code> .  Oleh karena itu, secara tegas, jawaban dalam paragraf ini harus dirumuskan sebagai berikut: jika demikian, maka <code>this</code> sama dengan argumen pertama dari <i>panggilan pertama untuk</i> <code>bind</code> , yang mengarah pada penciptaan fungsi ini. <br></div></div></li><li>  <b>Apakah fungsi ini disahkan di suatu tempat sebagai panggilan balik atau penangan?</b> <br><br><ul><li>  <b>Ya:</b> Tuhan sendiri yang tahu apa yang akan sama dengan ini ketika dipanggil.  Baca dokumentasi untuk hal yang menyebabkannya. </li><li>  <b>Tidak:</b> lihat paragraf berikutnya. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text">  Untuk fungsi non-panah dan terikat, nilai <code>this</code> tergantung pada keadaan di mana ia dipanggil.  Jika Anda tidak menyebutnya secara pribadi, tetapi meneruskannya di suatu tempat, maka nilai <code>this</code> dapat atau tidak dapat diganti dengan nilai yang tidak diketahui untuk Anda. <br><br>  Contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">`use strict`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'keydown'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }); <span class="hljs-comment"><span class="hljs-comment">//    this === document.    DOM- this  currentTarget [1, 2, 3].forEach(function(){ console.log(this); }); //         ,  undefined. ?     .</span></span></code> </pre></div></div></li><li>  <b>Fungsi ini disebut menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apply</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">call</a> ?</b> <br><br><ul><li>  <b>Ya:</b> dalam hal ini, <code>this</code> sama dengan argumen pertama yang diteruskan ke metode yang sesuai. </li><li>  <b>Tidak:</b> lihat paragraf berikutnya. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text">  Cara lain untuk mengatur <code>this</code> secara eksplisit.  Lebih tepatnya, dua.  Namun, dalam hal <code>this</code> ada perbedaan antara <code>apply</code> dan <code>call</code> , satu-satunya perbedaan adalah bagaimana sisa argumen dilewatkan. <br></div></div></li><li>  <b>Apakah fungsi ini diperoleh sebagai nilai properti objek dan segera dipanggil?</b> <br><br><ul><li>  <b>Ya:</b> <code>this</code> sama dengan objek di atas. </li><li>  <b>Tidak:</b> lihat paragraf berikutnya. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text">  Sebenarnya, dari mekanisme ini (dan juga dari pengalaman bekerja dengan bahasa lain) kaki tumbuh kepercayaan bahwa " <code>this</code> adalah objek yang metodenya kita namakan."  Mungkin saya hanya akan menulis kodenya. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: object1.method } object1.method(); <span class="hljs-comment"><span class="hljs-comment">//    object1 -           object1['method'](); //  .        object2.method(); //    object2 -  " ",      ,        </span></span></code> </pre></div></div></li><li>  <b>Apakah kode dijalankan dalam mode ketat?</b>  <b>('gunakan ketat', modul ES6)</b> <br><br><ul><li>  <b>Ya:</b> <code>this</code> sama dengan <code>undefined</code> . </li><li>  <b>Tidak:</b> <code>this</code> sama dengan objek global. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text">  Jika kita sampai pada titik ini, maka <code>this</code> tidak diatur oleh mekanisme yang memungkinkannya diatur.  Ada berbagai kesalahpahaman tentang bagaimana hal ini dapat ditularkan.  Misalnya, selama wawancara mereka sering mengatakan hal seperti itu kepada saya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); })(); <span class="hljs-comment"><span class="hljs-comment">//      } } obj.test(); //  ,     obj.  </span></span></code> </pre><br>  Atau, seperti yang saya katakan di bagian "kesalahpahaman", banyak orang berpikir bahwa jika suatu fungsi adalah metode objek yang dibuat menggunakan kelas ES6, maka ini akan selalu sama dengan objek ini di dalamnya.  Ini juga tidak benar. <br><br>  Jadi, jika kita sampai pada titik ini, maka keadaan lain memanggil fungsi kita tidak masalah.  Dan semuanya bermuara pada apakah kita dalam mode ketat atau tidak. <br><br>  Secara historis, sebagai "default" <code>this</code> , objek global diteruskan ke fungsi tersebut.  Pendekatan ini kemudian diakui sebagai tidak aman.  ES5 memperkenalkan mode ketat yang memperbaiki banyak masalah dari versi ECMAScript sebelumnya.  Itu disertakan dengan arahan 'gunakan ketat' di awal file atau fungsi.  Dalam mode ini, nilai "default" <code>this</code> tidak <code>undefined</code> . <br><br>  Dalam modul ES6, mode ketat diaktifkan secara default. <br><br>  Ada juga mekanisme lain untuk memasukkan mode ketat, misalnya, di NodeJS, mode ketat untuk semua file dapat diaktifkan dengan <code>--use-strict</code> . <br></div></div><br></li></ol><br>  Itu, secara umum, itu saja.  Menentukan nilai <code>this</code> , tentu saja, tidak sesederhana yang kita inginkan, tetapi tidak sesulit kelihatannya.  Pelajari algoritma ini sebagai tabel perkalian - dan Anda tidak akan pernah mengalami masalah dengan <code>this</code> lagi.  Hal-hal seperti itu. <br><br>  Pengguna PS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Aingis</a> menyarankan bahwa ketika menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan</a> konstruksi, objek yang diteruskan ke dalamnya sebagai konteks menggantikan objek global.  Mungkin saya tidak akan memasukkan ini ke dalam classifier saya, karena kesempatan untuk bertemu di 2019+ agak kecil.  Tetapi bagaimanapun juga, ini adalah hal yang menarik. <br><br>  Pengguna PPS, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">rqrqrqrq,</a> menyarankan bahwa yang <code>new</code> prioritas lebih tinggi daripada yang <code>bind</code> .  Revisi yang sesuai untuk classifier telah dibuat.  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464163/">https://habr.com/ru/post/id464163/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464147/index.html">CMake: kasus ketika proyek tidak termaafkan kualitas kodenya</a></li>
<li><a href="../id464149/index.html">Kisah monolit</a></li>
<li><a href="../id464151/index.html">Victor Vyalichkin: â€œKebebasan, kesetaraan, persaudaraan hanya ada di OpenStreetMap, di mana semuanya selalu terlihatâ€</a></li>
<li><a href="../id464155/index.html">AI membantu mempelajari hewan di Afrika</a></li>
<li><a href="../id464161/index.html">SPAM dan GDRP - bagaimana melakukan milis "di sana"?</a></li>
<li><a href="../id464165/index.html">Habr Weekly # 14 / Tentang aturan komunikasi dalam obrolan grup, monopoli, dan perlindungan anak-anak dari informasi berbahaya</a></li>
<li><a href="../id464169/index.html">Untuk berdebat: setelah membaca sampai akhir, Anda akan memahami bagaimana dan mengapa tepatnya GC bekerja</a></li>
<li><a href="../id464171/index.html">Keamanan Pembaruan Perangkat Lunak</a></li>
<li><a href="../id464173/index.html">"Galai terkutuk", atau tempat kaki tumbuh dari rengekan kantor</a></li>
<li><a href="../id464177/index.html">Buku "Kotlin. Pemrograman untuk para profesional "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>