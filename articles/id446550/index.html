<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎉 🤹🏻 ✊ Masalah pola koordinator dan apa yang harus dilakukan RouteComposer dengannya 🦔 🧑🏽‍🤝‍🧑🏻 🍧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya melanjutkan serangkaian artikel tentang perpustakaan RouteComposer yang kami gunakan, dan hari ini saya ingin berbicara tentang pola Koordinator....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Masalah pola koordinator dan apa yang harus dilakukan RouteComposer dengannya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446550/"><p>  Saya melanjutkan serangkaian artikel tentang perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RouteComposer</a> yang kami gunakan, dan hari ini saya ingin berbicara tentang pola Koordinator.  Saya diminta untuk menulis artikel ini dengan diskusi tentang salah satu artikel tentang pola tersebut. Koordinator di sini di Habré. </p><br><p>  Pola Koordinator, yang diperkenalkan belum lama ini, semakin populer di kalangan pengembang iOS, dan, secara umum, jelas mengapa.  Karena alat-alat di luar kotak yang disediakan <strong>UIKit</strong> bukan kekacauan universal. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/304/47d/bd8/30447dbd8d2a0a39a34f7f6946a02383.png" alt="gambar"></p><a name="habracut"></a><br><p>  Saya telah mengajukan pertanyaan tentang fragmentasi cara saya menyusun tampilan pengontrol pada stack, dan untuk menghindari pengulangan, Anda dapat membacanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p> Mari kita jujur.  Pada suatu titik, Epole menyadari bahwa dengan meletakkan pengontrol di pusat pengembangan aplikasi, ia tidak menawarkan cara yang masuk akal untuk membuat atau mentransfer data di antara mereka, dan, setelah mempercayakan solusi untuk masalah ini kepada pengembang, itu di-autocompleted dari Xcode, dan mungkin ke pengembang UISearchConnroller, di beberapa titik memperkenalkan storyboard dan segues kepada kami.  Kemudian, Epolus menyadari bahwa dia menulis aplikasi yang hanya terdiri dari 2 layar saja, dan pada iterasi berikutnya dia menyarankan kemungkinan memecah storyboard menjadi beberapa komponen, karena Xcode mulai crash ketika storyboard mencapai ukuran tertentu.  Segues telah berubah seiring dengan konsep ini, dalam beberapa iterasi yang tidak terlalu kompatibel satu sama lain.  Dukungan mereka dijahit dengan ketat ke dalam kelas <code>UIViewController</code> besar, dan, pada akhirnya, kami mendapatkan apa yang kami dapatkan.  Ini dia: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"showDetail"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath = tableView.indexPathForSelectedRow { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = objects[indexPath.row] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSDate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> controller = (segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>).topViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> controller.detailItem = object controller.navigationItem.leftBarButtonItem = splitViewController?.displayModeButtonItem controller.navigationItem.leftItemsSupplementBackButton = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } }</code> </pre> <br><p>  Jumlah siaran gaya dalam blok kode ini luar biasa, seperti halnya konstanta string di storyboard itu sendiri, untuk melacak Xcode mana yang tidak menawarkan sarana sama sekali.  Dan keinginan sekecil apa pun untuk mengubah sesuatu dalam proses navigasi akan memungkinkan Anda untuk mengkompilasi proyek tanpa usaha apa pun dan itu akan crash dengan bang in runtime tanpa peringatan sedikit pun dari Xcode.  Berikut adalah WYSIWYG pada akhirnya ternyata.  Apa yang Anda lihat adalah apa yang Anda dapatkan. </p><br><p>  Anda dapat berdebat lama tentang pesona panah abu-abu ini di storyboard yang seharusnya menunjukkan kepada seseorang koneksi di antara layar, tetapi, seperti yang telah ditunjukkan oleh praktik saya, saya sengaja mewawancarai beberapa pengembang yang akrab dari perusahaan yang berbeda, segera setelah proyek tumbuh melampaui 5-6 layar, orang-orang mencoba menemukan solusi yang lebih dapat diandalkan dan akhirnya mulai menjaga struktur tumpukan pengontrol tampilan di kepalaku.  Dan jika dukungan untuk iPad dan model navigasi lainnya atau dukungan untuk dorongan ditambahkan, maka semuanya menyedihkan di sana. </p><br><p>  Sejak itu, beberapa upaya telah dilakukan untuk memecahkan masalah ini, beberapa di antaranya menghasilkan kerangka kerja yang terpisah, beberapa di pola arsitektur yang terpisah, sejak membuat pengontrol tampilan di dalam pengontrol tampilan membuat potongan kode yang besar dan kikuk ini bahkan lebih. </p><br><p>  Mari kita kembali ke pola Koordinator.  Untuk alasan yang jelas, Anda tidak akan menemukan deskripsinya di Wikipedia karena itu bukan pola pemrograman / desain standar.  Alih-alih, ini adalah semacam abstraksi, yang menyarankan untuk menyembunyikan di bawah kap semua kode "jelek" ini untuk membuat dan memasukkan lilitan pengendali baru pada tumpukan, menyimpan referensi ke wadah pengontrol dan mendorong data di antara pengontrol.  Artikel yang paling cocok menggambarkan proses ini saya sebut artikel di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">raywenderlich.com</a> .  Itu mulai menjadi populer setelah konferensi NSSpain 2015, ketika masyarakat umum diberitahu tentang hal itu.  Secara lebih rinci apa yang diceritakan dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Saya akan menjelaskan secara singkat apa itu sebelum melanjutkan. </p><br><p>  Pola Koordinator dalam semua interpretasi kira-kira cocok dengan gambar ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/554/4bb/f95/5544bbf95415d233060a7e4d515ff58d.png"></p><br><p>  Artinya, koordinator adalah protokol </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre> <br><p>  Dan semua kode jelek seharusnya disembunyikan di fungsi <code>start</code> .  Koordinator, di samping itu, dapat memiliki tautan ke koordinator anak, yaitu, mereka memiliki beberapa kemampuan komposisi, dan, misalnya, Anda dapat mengganti satu implementasi dengan yang lain.  Artinya, kedengarannya cukup elegan. </p><br><p>  Namun, kegilaan dimulai segera: </p><br><ol><li>  Beberapa implementasi mengusulkan untuk mengubah Koordinator dari pola pembangkit tertentu menjadi sesuatu yang lebih masuk akal, mengawasi tumpukan pengontrol dan <em>menjadikannya delegasi wadah</em> , misalnya, <code>UINavigationController</code> , untuk memproses mengklik tombol Kembali atau geser kembali dan hapus koordinator anak.  Untuk alasan alami, hanya satu objek yang dapat menjadi delegasi, yang membatasi kontrol wadah itu sendiri dan mengarah pada fakta bahwa logika ini terletak pada koordinator, atau menciptakan kebutuhan untuk mendelegasikan logika ini lebih jauh kepada seseorang yang berada jauh di bawah daftar. </li><li>  Seringkali logika untuk membuat pengontrol berikutnya <em>tergantung pada logika bisnis</em> .  Misalnya, untuk menuju ke layar berikutnya, pengguna harus masuk ke sistem.  Jelas, ini adalah proses asinkron, yang termasuk menghasilkan beberapa layar perantara dengan formulir login, proses login itu sendiri dapat berakhir dengan sukses atau tidak.  Untuk menghindari mengubah Koordinator menjadi Koordinator Massive (mirip dengan Massive View Controller), kita perlu dekomposisi.  Artinya, Anda perlu membuat Koordinator Koordinator. </li><li>  Masalah lain yang dihadapi oleh koordinator adalah bahwa mereka pada dasarnya adalah pembungkus untuk pengontrol tampilan wadah seperti <code>UINavigationController</code> , <code>UITabBarController</code> dan sebagainya.  Dan seseorang harus menyediakan <em>tautan ke pengontrol ini</em> .  Jika dengan koordinator anak semuanya menjadi kurang jelas, maka dengan koordinator awal rantai, tidak semuanya begitu sederhana.  Plus, ketika mengubah navigasi, misalnya untuk tes A / B, refactoring dan adaptasi dari koordinator tersebut menghasilkan sakit kepala yang terpisah.  Apalagi jika jenis wadahnya berubah. </li><li>  Semua ini menjadi lebih rumit ketika aplikasi mulai mendukung <em>acara eksternal</em> yang menghasilkan pengontrol tampilan.  Seperti pemberitahuan push atau tautan universal (pengguna mengklik tautan dalam surat itu dan melanjutkan di layar aplikasi yang sesuai).  Di sini timbul ketidakpastian lain yang pola Koordinatornya tidak memiliki jawaban yang pasti.  Anda harus tahu persis layar mana yang sedang digunakan pengguna untuk menunjukkan kepadanya layar berikutnya yang diminta oleh peristiwa eksternal. <br>  Contoh paling sederhana adalah aplikasi obrolan yang terdiri dari 3 layar - daftar obrolan, obrolan itu sendiri yang didorong ke dalam navigasi pengontrol daftar obrolan dan layar pengaturan ditampilkan secara moderen.  Pengguna dapat berada di salah satu layar ini ketika ia menerima pemberitahuan push dan mengetuknya.  Dan di sini ketidakpastian dimulai, jika dia ada dalam daftar obrolan, Anda perlu memulai obrolan dengan pengguna khusus ini, jika dia sudah ada dalam obrolan, maka Anda perlu beralih, dan jika dia sudah dalam obrolan dengan pengguna ini, maka jangan lakukan apa-apa dan perbarui, jika pengguna aktif layar pengaturan - itu, tampaknya Anda harus menutup dan mengikuti langkah-langkah sebelumnya.  Atau mungkin tidak menutup dan hanya menunjukkan obrolan secara moderat atas pengaturan?  Dan jika pengaturannya di tab lain, dan bukan modal?  Ini <code>if/else</code> mulai tersebar di koordinator atau pergi ke Mega-Coordinator lain dalam bentuk sepotong spageti.  Selain itu, ini merupakan iterasi aktif pada tumpukan tampilan pengontrol dan upaya untuk menentukan di mana pengguna saat ini, atau upaya untuk membangun beberapa jenis aplikasi yang memantau status mereka, tetapi ini bukan tugas yang mudah, hanya berdasarkan pada sifat tumpukan pengendali tampilan itu sendiri. </li><li>  Dan ceri pada kue itu adalah <em>gangguan UIKit</em> .  Contoh sepele: <code>UITabBarController</code> dengan <code>UINavigationController</code> di tab kedua dengan beberapa <code>UIViewController</code> lainnya.  Pengguna di tab pertama menyebabkan peristiwa tertentu yang mengharuskan pengalihan tab dan <code>UINavigationController</code> pengontrol tampilan lain ke <code>UINavigationController</code> .  Semua ini perlu dilakukan hanya dalam urutan seperti itu.  Jika pengguna belum pernah membuka tab kedua sebelum ini dan <code>UINavigationController</code> tidak dipanggil di <code>viewDidLoad</code> metode <code>push</code> tidak akan berfungsi hanya menyisakan pesan tidak jelas di konsol.  Artinya, koordinator tidak bisa hanya menjadi pendengar peristiwa dalam contoh ini, mereka harus bekerja dalam urutan tertentu.  Jadi mereka harus memiliki pengetahuan satu sama lain.  Dan ini sudah bertentangan dengan pernyataan pertama dari pola Koordinator, bahwa koordinator tidak tahu apa-apa tentang koordinator pembangkit dan hanya terhubung dengan yang anak-anak.  Dan juga membatasi pertukaran mereka. </li></ol><br><p>  Daftar ini dapat dilanjutkan, tetapi secara umum jelas bahwa pola Koordinator adalah solusi yang agak terbatas dan skalabel.  Jika Anda melihatnya tanpa kacamata merah muda, maka itu adalah cara penguraian bagian dari logika, yang biasanya ditulis di dalam <code>UIViewController</code> besar-besaran, ke dalam kelas lain.  Semua upaya untuk membuatnya lebih dari sekadar beberapa pabrik generatif dan memperkenalkan logika lain di sana tidak berakhir dengan baik. </p><br><p>  Perlu dicatat bahwa ada perpustakaan berdasarkan pola ini, yang, dengan satu atau lain cara, memungkinkan untuk mengurangi sebagian kerugian di atas.  Saya akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyebutkan XCoordinator</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxFlow</a> . </p><br><h2 id="chto-sdelali-my">  Apa yang telah kita lakukan </h2><br><p>  Setelah bermain dalam proyek yang kami dapatkan dari tim lain untuk dukungan dan pengembangan, dengan koordinator dan <em>Router</em> "buyut" mereka yang disederhanakan dalam pendekatan arsitektur <em>VIPER</em> , kami kembali ke pendekatan yang bekerja dengan baik dalam proyek besar sebelumnya di perusahaan kami.  Pendekatan ini tidak memiliki nama.  Itu terletak di permukaan.  Ketika kami memiliki waktu luang, itu dikompilasi ke perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RouteComposer</a> terpisah yang sepenuhnya menggantikan koordinator dan terbukti lebih fleksibel. </p><br><p>  Apa pendekatan ini?  Dalam hal itu, untuk mengandalkan stack (tree) saya memutar controller seperti apa adanya.  Agar tidak membuat entitas yang tidak perlu yang perlu dipantau.  Jangan menyimpan atau melacak kondisi. </p><br><p>  Mari kita lihat entitas <em>UIKit lebih</em> dekat dan coba cari tahu apa yang kita miliki di garis bawah dan apa yang bisa kita kerjakan: </p><br><ol><li>  <strong>Tumpukan pengontrol</strong> adalah pohon.  Ada pengontrol tampilan root yang memiliki pengontrol tampilan anak.  Pengontrol tampilan yang disajikan secara digital adalah kasus khusus pengontrol tampilan anak, karena mereka juga memiliki pengikatan pada pengontrol tampilan yang dihasilkan.  Semuanya tersedia di luar kotak. </li><li>  Saya perlu membuat entitas pengontrol.  Mereka semua memiliki konstruktor yang berbeda, mereka dapat dibuat menggunakan file Xib atau Storyboards.  Mereka memiliki parameter input yang berbeda.  Tetapi mereka bersatu dalam hal bahwa mereka perlu diciptakan.  Jadi, di sini kita dapat menggunakan pola <strong>Pabrik</strong> , yang tahu cara membuat pengontrol tampilan yang diinginkan.  Setiap pabrik mudah ditutup dengan unit test yang komprehensif dan tidak tergantung pada yang lain. </li><li>  Kami membagi pengontrol tampilan menjadi 2 kelas: 1. Hanya melihat pengontrol, 2. <strong>Pengontrol tampilan kontainer (Container View Controller)</strong> .  Pengontrol tampilan wadah berbeda dari yang biasa di mana mereka dapat mengandung pengontrol tampilan anak - juga wadah atau yang sederhana.  Pengontrol tampilan seperti itu tersedia di luar kotak: <code>UINavigationController</code> , <code>UITabBarController</code> dan sebagainya, tetapi juga dapat dibuat oleh pengguna.  Jika kita mengabaikannya, kita dapat menemukan properti berikut di semua wadah: 1. Mereka memiliki daftar semua pengontrol yang dikandungnya.  2. Satu atau lebih pengontrol saat ini terlihat.  3. Mereka mungkin diminta untuk membuat salah satu dari pengontrol ini terlihat.  Ini semua yang dapat <em>dilakukan oleh</em> pengontrol <em>UIKit</em> .  Mereka hanya memiliki metode berbeda untuk ini.  Tetapi hanya ada 3 tugas. </li><li>  Untuk menyematkan view controller buatan pabrik, metode tampilan induk dari controller adalah <code>UINavigationController.pushViewController(...)</code> , <code>UITabBarController.selectedViewController = ...</code> , <code>UIViewController.present(...)</code> dan sebagainya.  Anda mungkin memperhatikan bahwa 2 pengontrol tampilan selalu diperlukan, satu sudah ada di stack, dan satu lagi yang perlu disematkan di stack.  Bungkus ini dalam pembungkus dan sebut itu <strong>Aksi (Aksi)</strong> .  Setiap tindakan mudah ditutup dengan unit test yang komprehensif dan masing-masing independen dari yang lain. </li><li>  Dari penjelasan di atas, ternyata dengan menggunakan entitas yang telah disiapkan, Anda dapat membangun rantai konfigurasi <em>Factory -&gt; Action -&gt; Factory -&gt; Action -&gt; Factory</em> dan, setelah menyelesaikannya, Anda dapat membangun pohon tampilan pengontrol dari kompleksitas apa pun.  Anda hanya perlu menentukan titik masuk.  Titik input ini biasanya berupa <em>rootViewController yang</em> dimiliki oleh <em>UIWindow</em> atau pengontrol tampilan saat ini, yang merupakan cabang paling ekstrim dari pohon.  Artinya, konfigurasi seperti itu ditulis dengan benar sebagai: <strong>Memulai ViewController -&gt; Action -&gt; Factory -&gt; ... -&gt; Factory</strong> . </li><li>  Selain konfigurasi, Anda akan memerlukan beberapa entitas yang tahu cara memulai dan membangun konfigurasi yang disediakan.  Kami akan menyebutnya <strong>Router</strong> .  Tidak memiliki status, tidak memiliki tautan apa pun.  Ini memiliki satu metode yang konfigurasi dilewatkan dan secara berurutan melakukan langkah-langkah konfigurasi. </li><li>  Tambahkan tanggung jawab ke router dengan menambahkan kelas <strong>Interceptors</strong> ke rantai konfigurasi.  Interceptors dimungkinkan dari 3 jenis: 1. Diluncurkan sebelum memulai navigasi.  Kami menghapus tugas otentikasi pengguna di sistem dan tugas asinkron lainnya di dalamnya.  2. Jalankan pada saat pembuatan view controller untuk mengatur nilai.  3. Dilakukan setelah navigasi dan melakukan berbagai tugas analitis.  Setiap entitas mudah dicakup oleh unit test dan tidak tahu bagaimana ia akan digunakan dalam konfigurasi.  Dia hanya memiliki satu tanggung jawab dan dia memenuhinya.  Yaitu, konfigurasi untuk navigasi yang kompleks mungkin terlihat seperti <strong>[Tugas Pra-Navigasi ...] -&gt; Memulai ViewController -&gt; Action -&gt; (Factory + [ContextTask ...]) -&gt; ... -&gt; (Factory + [ContextTask ...]) -&gt; [Post NavigationTask ...]</strong> .  Artinya, semua tugas akan dilakukan oleh router secara berurutan, berkinerja pada gilirannya kecil, entitas atom mudah dibaca. </li><li>  Tugas terakhir yang tidak dapat diselesaikan dengan konfigurasi tetap - ini adalah keadaan aplikasi saat ini.  Bagaimana jika kita perlu membangun bukan seluruh rantai konfigurasi, tetapi hanya sebagian saja, karena sebagian pengguna melewatinya?  Pertanyaan ini selalu dapat dijawab dengan jelas oleh pohon pengontrol tampilan.  Karena jika bagian dari rantai sudah dibangun, itu sudah ada di pohon.  Ini berarti bahwa jika setiap pabrik dalam rantai dapat menjawab pertanyaan apakah itu dibangun atau tidak, maka router akan dapat memahami bagian rantai yang mana yang perlu diselesaikan.  Tentu saja, ini bukan tugas pabrik, jadi entitas atom lain diperkenalkan - <strong>Finder,</strong> dan konfigurasi apa pun tampak seperti ini: <strong>[Tugas Pra-navigasi ...] -&gt; Memulai ViewController -&gt; Action -&gt; (Finder / Pabrik + [ContextTask ...]) -&gt; ... -&gt; (Finder / Pabrik + [ContextTask ...]) -&gt; [Post NavigationTask ...]</strong> .  Jika router mulai membacanya dari akhir, maka salah satu Pencari akan memberitahunya bahwa itu sudah dibangun, dan router dari titik ini akan mulai membangun rantai kembali.  Jika tidak satu pun dari mereka menemukan dirinya di pohon, maka Anda perlu membangun seluruh rantai dari pengontrol awal. <br><img src="https://habrastorage.org/getpro/habr/post_images/f50/a64/213/f50a64213fa1654fbde33e53b31f4e43.gif" alt="gambar"></li><li>  Konfigurasi harus diketik dengan kuat.  Oleh karena itu, setiap entitas bekerja dengan hanya satu jenis tampilan pengontrol, satu jenis data dan konfigurasi sepenuhnya bergantung pada kemampuan swift untuk bekerja dengan jenis <strong>terkait</strong> .  Kami ingin mengandalkan kompiler, bukan pada runtime.  Pengembang dapat dengan sengaja melemahkan pengetikan, tetapi tidak sebaliknya. </li></ol><br><p>  Contoh konfigurasi seperti itu: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productScreen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>(finder: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFinder</span></span>(), factory: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFactory</span></span>()) .add(<span class="hljs-type"><span class="hljs-type">LoginInterceptor</span></span>&lt;<span class="hljs-type"><span class="hljs-type">UUID</span></span>&gt;()) <span class="hljs-comment"><span class="hljs-comment">// Have to specify the context type till https://bugs.swift.org/browse/SR-8719 is fixed .add(ProductViewControllerContextTask()) .add(ProductViewControllerPostTask(analyticsManager: AnalyticsManager.sharedInstance)) .using(UINavigationController.push()) .from(NavigationControllerStep()) .using(GeneralActions.presentModally()) .from(GeneralStep.current()) .assemble()</span></span></code> </pre> <br><p>  Item yang dijelaskan di atas mencakup seluruh perpustakaan dan menjelaskan pendekatannya.  Yang tersisa bagi kami adalah menyediakan konfigurasi berantai yang akan dijalankan router saat pengguna mengklik tombol atau peristiwa eksternal terjadi.  Jika ini adalah berbagai jenis perangkat, misalnya iPhone atau iPad, maka kami akan menyediakan konfigurasi transisi yang berbeda menggunakan polimorfisme.  Jika kita memiliki pengujian A / B, hal yang sama.  Kita tidak perlu memikirkan keadaan aplikasi pada saat memulai navigasi, kita perlu memastikan bahwa konfigurasi ditulis dengan benar pada awalnya, dan kami yakin bahwa router akan membangunnya. </p><br><p>  Pendekatan yang dideskripsikan lebih rumit daripada abstraksi atau pola tertentu, tetapi kami belum menghadapi masalah di mana itu tidak akan cukup.  Tentu saja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RouteComposer</a> memerlukan beberapa studi dan pemahaman tentang cara kerjanya.  Namun, ini jauh lebih mudah daripada mempelajari dasar-dasar AutoLayout atau RunLoop.  Tidak ada matematika yang lebih tinggi. </p><br><p>  Pustaka, serta implementasi router yang disediakan untuknya, tidak menggunakan trik objektif dengan runtime dan sepenuhnya mengikuti semua konsep Cocoa Touch, hanya membantu memecah proses komposisi menjadi langkah-langkah dan mengeksekusi mereka dalam urutan yang diberikan.  Perpustakaan diuji dengan versi iOS 9 hingga 12. </p><br><p>  Rincian lebih lanjut dapat ditemukan di artikel sebelumnya: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komposisi UIViewControllers dan navigasi di antara mereka (dan tidak hanya) / majalah geek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh konfigurasi UIViewControllers menggunakan RouteComposer / geek magazine</a> </p><br><p>  Terima kasih atas perhatian anda  Saya akan dengan senang hati menjawab pertanyaan di komentar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446550/">https://habr.com/ru/post/id446550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446536/index.html">Antrian dan JMeter: Pertukaran dengan Penerbit dan Pelanggan</a></li>
<li><a href="../id446538/index.html">PhotoGuru beralih ke "sisi gelap" dan "lebih bijaksana"</a></li>
<li><a href="../id446544/index.html">Microsoft memperluas Program Azure IP Advantage dengan manfaat IP baru untuk inovator dan startup Azure IoT</a></li>
<li><a href="../id446546/index.html">Microsoft Memperluas Azure IP Advantage dengan Manfaat IP Baru untuk Inovator dan Startup Azure IoT</a></li>
<li><a href="../id446548/index.html">Analisis statistik tentang kampanye iklan - buat metrik baru di DataFrame (python)</a></li>
<li><a href="../id446552/index.html">Bekerja dengan Perintah APDU Menggunakan Contoh EToken</a></li>
<li><a href="../id446554/index.html">Program residen Yandex, atau How to back-end yang berpengalaman menjadi insinyur-ML</a></li>
<li><a href="../id446558/index.html">Struktur Data Eksotis: Modifikasi Merkle Patricia Trie</a></li>
<li><a href="../id446560/index.html">"Courtesy Exchange": inti dari konflik antara dua perusahaan streaming paling terkenal</a></li>
<li><a href="../id446562/index.html">Asynchrony dalam pemrograman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>