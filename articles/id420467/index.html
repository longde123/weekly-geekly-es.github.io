<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏿 🌙 👨‍👦 Wrapper C ++ untuk "semua" Sistem Operasi Real-Time untuk CortexM4 🤴🏿 📑 ✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya sudah berbicara tentang bagaimana Anda dapat menggunakan FreeRtos untuk proyek yang ditulis dalam C ++ dalam artikel STM32, C ++ dan FreeRTOS. Pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wrapper C ++ untuk "semua" Sistem Operasi Real-Time untuk CortexM4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420467/"><img src="https://habrastorage.org/webt/s0/2o/ve/s02ovegatxm9x39z6c8x_5fydki.png" alt="gambar"><br><br>  Saya sudah berbicara tentang bagaimana Anda dapat menggunakan FreeRtos untuk proyek yang ditulis dalam C ++ dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STM32, C ++ dan FreeRTOS.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan dari awal.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a>  Sejak itu, sebanyak 3 tahun telah berlalu, saya benar-benar menua, kehilangan banyak koneksi saraf, jadi saya memutuskan untuk mengguncang masa lalu untuk memulihkan koneksi ini dan menyapu bungkusnya untuk RTOS populer "apa pun".  Ini tentu saja sebuah lelucon, saya sengaja memberi tanda kutip pada "semua orang", tetapi ada beberapa kebenaran dalam setiap lelucon. <br><a name="habracut"></a><br>  Jadi, apa tugasnya dan mengapa itu relevan?  Saat ini, ada satu juta sistem operasi berbeda yang ditulis dalam C - Saya tidak ingin memilih untuk setiap selera, dibayar, gratis, kecil, besar ... Tetapi untuk proyek di mana saya berpartisipasi, semua chip dari sistem operasi yang berbeda ini tidak diperlukan, fungsionalitas dasar seperti tugas sudah cukup , acara, pemberitahuan tugas, bagian penting, mutex, dan semaphore (meskipun saya mencoba untuk tidak menggunakannya), antrian.  Dan semua ini diperlukan dalam bentuk yang cukup sederhana, tanpa embel-embel. <br><br>  Menurut pendapat saya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>OSRV MAX</b></a> domestik, ditulis dalam C ++, sangat cocok untuk proyek saya dan itu menyenangkan untuk menggunakannya. <br><br>  Tetapi yang menarik adalah bahwa perangkat kami harus mematuhi standar IEC_61508, salah satu persyaratannya adalah <i>Aplikasi E.29 dari perpustakaan target yang terbukti digunakan</i> .  Baik, atau dengan kata-kata sederhana, jika Anda membuat perangkat untuk memenuhi level <u>SIL3</u> , maka silakan (Disarankan Lebih Tinggi) menggunakan perpustakaan yang sesuai dengan tingkat ini dan telah teruji oleh waktu. <br><br>  Mengenai tugas kami, ini berarti dimungkinkan untuk menggunakan <b>MAX MAX RTOS</b> untuk perangkat semacam itu, tetapi poin keandalan tidak akan ditambahkan.  Oleh karena itu, produsen RTOS membuat versi khusus dari sistem operasi mereka yang mematuhi standar IEC_61508, misalnya, <i>FreeRTOS</i> memiliki klon <i>SafeRTOS</i> , dan <i>embo</i> memiliki klon <i>embos-Aman</i> , tentu saja produsen menghasilkan uang yang sangat baik untuk ini, karena lisensi untuk OS ini berharga beberapa ribu, atau bahkan puluhan seribu dolar. <br><br>  Ngomong-ngomong, contoh yang baik adalah kompiler IAR, lisensi yang harganya sekitar $ 1.500, tetapi versi Bersertifikat IAR sudah menelan biaya sekitar 10.000 dolar, meskipun saya memeriksa beberapa proyek - file keluaran dari versi tanpa sertifikat dan dengan sertifikat benar-benar identik.  Nah, Anda mengerti bahwa Anda perlu membayar untuk perdamaian. <br><br>  Jadi, pertama kami menggunakan <i>satu sistem operasi</i> , kemudian saya mulai menggunakan <i>FreeRTOS</i> untuk kebutuhan saya, kemudian kami beralih ke yang <i>lain</i> , secara umum, kami terus menerus harus menulis ulang kode yang sudah jadi.  Selain itu, saya ingin terlihat cantik dan sederhana, sehingga siapa pun dapat memahami dengan kode apa yang terjadi, maka dukungan kode akan menjadi pekerjaan sederhana bagi siswa dan praktisi, dan guru akan dapat terus bekerja pada perangkat inovatif, daripada memahami tumpukan mie .  Secara umum, saya ingin melihat fosil seperti ini: <br><br><img src="https://habrastorage.org/webt/rc/2z/_k/rc2z_kzdcpu6isdhwojtbbi4wac.png" alt="gambar"><br><br>  Yah, atau semacamnya ... <br><br><img src="https://habrastorage.org/webt/f7/li/48/f7li48lkaylpglvyjr-tiekmxai.png" alt="gambar"><br><br>  Oleh karena itu, saya memutuskan untuk menulis pembungkus yang cocok dengan <i>FreeRTOS</i> dan mengatakan <i>embos,</i> well, untuk semua orang juga :) dan untuk memulainya, saya menentukan apa yang benar-benar saya butuhkan untuk kebahagiaan total: <br><br><ul><li>  Tugasnya </li><li>  Bagian kritis </li><li>  Pemberitahuan acara dan tugas </li><li>  Semaphores dan Mutex </li><li>  Antrian </li></ul><br>  Pembungkusnya harus ideologis <u>SIL3</u> , dan level ini membebankan banyak hal yang Direkomendasikan Tinggi, dan jika Anda mengikutinya sepenuhnya, ternyata lebih baik tidak menulis kode sama sekali. <br><br>  Tetapi kenyataan bahwa standar mengatur banyak aturan, atau lebih tepatnya rekomendasi, tidak berarti bahwa mereka tidak dapat dilanggar - Anda bisa, tetapi Anda harus mengikuti rekomendasi sebanyak mungkin untuk mendapatkan poin lebih banyak.  Karena itu, saya memutuskan beberapa batasan penting: <br><br><ul><li>  <b>tidak ada makro</b> , well, kecuali untuk perlindungan terhadap pemasukan ganda file header.  Makro itu jahat, jika Anda menghitung berapa banyak waktu yang dihabiskan untuk mencari kesalahan yang terkait dengan makro, ternyata alam semesta tidak begitu tua, dan seberapa banyak kebaikan yang dapat dilakukan selama waktu ini, mungkin lebih baik untuk melarang mereka di tingkat legislatif, karena torrents melarang atau ambil bonus untuk setiap makro yang Anda tulis </li><li>  <b>jangan gunakan pointer</b> , tentu saja bila memungkinkan.  Orang bisa mencoba untuk tidak menggunakannya sama sekali, tetapi masih ada tempat di mana tanpa mereka tidak ada cara.  Bagaimanapun, pengguna bungkus, jika mungkin, seharusnya tidak tahu apa itu pointer, karena ia hanya mendengar tentang mereka dari kakeknya, karena sekarang ia bekerja secara eksklusif dengan tautan </li><li>  <b>tidak menggunakan alokasi memori dinamis</b> - semuanya jelas, hanya menggunakan timbunan timbunan, pertama, kebutuhan cadangan RAM untuk timbunan ini, dan kedua, dengan seringnya menggunakan timbunan, itu didefragmentasi dan objek-objek baru dibuat lebih lama dan lebih lama lebih lama.  Karena itu, pada <i>kenyataannya,</i> saya mengkonfigurasi <i>FreeRTOS</i> hanya pada memori yang dialokasikan secara statis dengan menetapkan <i>configSUPPORT_STATIC_ALLOCATION 1</i> .  Tetapi jika Anda ingin bekerja dalam mode default.  Dan secara default, <i>FreeRTOS</i> menggunakan memori yang dialokasikan secara dinamis untuk membuat elemen OS, kemudian hanya mengatur <i>configSUPPORT_STATIC_ALLOCATION 0</i> , dan <br>  <i>configSUPPORT_DYNAMIC_ALLOCATION 1</i> dan jangan lupa untuk menghubungkan implementasi Mallocs dan Callocs Anda sendiri dari manajer memori, misalnya, file ini adalah FreeRtos / portable / MemMang / heap_1.c.  Tetapi perlu diingat bahwa Anda harus mengalokasikan RAM dengan cadangan untuk banyak, karena Anda tidak akan dapat menghitung jumlah persis RAM yang dibutuhkan, dengan semua pengaturan (Idle aktif, tugas pengatur waktu program aktif, dua tugas saya, antrian, ukuran antrian untuk timer 10 dan seterusnya, katakanlah itu jelas bukan pengaturan yang paling optimal) yang berfungsi ketika saya mengalokasikan memori seperti ini: <br><blockquote>  7 357 byte dari memori kode hanya baca <br>  535 byte memori data hanya baca <br>  6.053 byte memori data readwrite </blockquote><br>  Alokasi memori statis "sedikit" lebih ringkas: <br><blockquote>  7.329 byte dari memori kode hanya baca <br>  535 byte memori data hanya baca <br>  3.877 byte memori data readwrite </blockquote><br>  Anda mungkin berpikir, "luar biasa ... sendiri," tetapi sekarang kami tidak tertarik dengan pertanyaan yang dirumuskan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Saya mengalokasikan sebanyak 3KB ke sistem operasi dan meluncurkan hanya 3 tugas dengan tumpukan 128B, dan untuk beberapa alasan sudah tidak cukup memori untuk keempat"</a> , Dalam situasi ini, saya sengaja melakukannya, untuk kejelasan, untuk menunjukkan perbedaan antara alokasi memori dinamis dan statis dengan pengaturan yang sama. <br></li><li>  <b>jangan melemparkan tipe</b> , jika memungkinkan.  Jenis ghosting ke jenis lain itu sendiri berarti fakta bahwa ada sesuatu yang salah dalam desain, tetapi seperti biasa, kadang-kadang Anda masih harus melemparkannya untuk kenyamanan (misalnya, enum harus dilemparkan ke bilangan bulat), dan kadang-kadang Anda tidak dapat melakukannya tanpa ini, tetapi ini harus dihindari. </li><li>  <b>kesederhanaan dan kenyamanan</b> .  Untuk pengguna bungkus, semua kesulitan harus disembunyikan, jadi hidupnya bukan minyak, dan dia belum ingin menyulitkannya - dia menciptakan tugas, mengimplementasikan semua yang diperlukan di dalamnya, memulainya dan pergi untuk menikmati hidup. </li></ul><br>  Kami akan mulai dari ini, jadi kami menetapkan sendiri tugas untuk membuat tugas (ternyata langsung dari seri "dilarang untuk melarang"). <br><br><h2>  Pembuatan tugas </h2><br>  Dengan penelitian panjang, para ilmuwan Inggris ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang RTOS dari Colin Walls. Artikel # 4. Tugas, pengalihan konteks dan interupsi</a> ) (omong-omong, jika Anda tidak tahu, perakit untuk ARM juga ditemukan oleh ilmuwan Inggris, sesuatu yang saya tidak terkejut juga sekali :)), dan para ilmuwan Inggris menemukan bahwa untuk sebagian besar "semua" RTOS tugas memiliki <i>nama</i> , <i>tumpukan</i> , <i>ukuran tumpukan</i> , <i>"unit kontrol"</i> , <i>pengidentifikasi atau penunjuk ke "unit kontrol"</i> , <i>prioritas</i> , <i>fungsi yang dilakukan dalam tugas</i> .  Itu saja, dan itu mungkin untuk menjejalkan semuanya ke dalam kelas, tapi itu benar jika kami menulis OS dengan Anda, tetapi kami melakukan pembungkus, jadi tidak ada gunanya menyimpan semua hal ini dalam pembungkus, semua ini akan <u>dilakukan</u> untuk Anda oleh ideologi <u>SIL3</u> OS kami selesai.  Bahkan, kita hanya perlu <i>fungsi yang dieksekusi dalam tugas</i> dan <i>struktur yang menyimpan "unit kontrol"</i> , yang diisi saat membuat tugas dan <i>pengidentifikasi tugas</i> .  Oleh karena itu, kelas tugas, sebut saja <i>Utas,</i> dapat terlihat sangat sederhana: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: tTaskHandle taskHandle ; tTaskContext context ; } ;</code> </pre> <br>  Saya hanya ingin mendeklarasikan kelas tugas saya di mana saya bisa mengimplementasikan semua yang diperlukan dan kemudian meneruskan pointer ke objek kelas ini ke pembungkus, yang akan membuat tugas menggunakan RTOS API di mana ia akan meluncurkan metode <i>Execute ()</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTask</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Thread { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//do something.. } } ; using tMyTaskStack = std::array&lt;OsWrapper::tStack, static_cast&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; inline static tMyTaskStack Stack; //!C++17 } ; MyTask myDesiredTask int main() { Rtos::CreateThread(myTask, MyTask::Stack.data(), "myTask") ; }</span></span></code> </pre> <br>  Dalam "semua" RTOS, agar tugas yang akan dibuat, perlu untuk memberikan pointer ke fungsi yang akan diluncurkan oleh penjadwal.  Dalam kasus kami, ini adalah fungsi <i>Execute ()</i> , tapi saya tidak bisa melewatkan pointer ke metode ini, karena ini tidak statis.  Oleh karena itu, kami melihat bagaimana tugas dibuat di API "semua" OS dan perhatikan bahwa kami dapat membuat tugas dengan meneruskan parameter ke fungsi tugas, misalnya, untuk <i>embos</i> ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OS_TASK_CreateEx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OS_TASK* pTask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pName, OS_PRIO Priority, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*pRoutine)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pVoid ), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OS_STACKPTR *pStack, OS_UINT StackSize, OS_UINT TimeSlice, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span></span>;</code> </pre><br>  <b>void * pContext</b> - ini adalah kunci solusinya.  Mari kita memiliki metode statis, sebuah penunjuk yang akan kita lewati sebagai penunjuk ke metode yang disebut oleh penjadwal, dan sebagai parameter kita akan meneruskan penunjuk ke objek tipe <i>Thread di</i> mana kita dapat memanggil metode <i>Execute ()</i> secara langsung.  Inilah saat ketika tidak ada cara tanpa pointer dan dilemparkan ke tipe, tetapi kode ini akan disembunyikan dari pengguna: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pContext )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Thread*&gt;(pContext)-&gt;Execute() ; }</code> </pre> <br>  Yaitu  seperti algoritma operasi, scheduler meluncurkan metode <i>Run</i> , pointer ke objek tipe <i>Thread</i> dilewatkan ke metode <i>Run</i> .  Metode <i>Jalankan</i> secara langsung memanggil metode <i>Execute ()</i> , objek spesifik dari kelas <i>Thread</i> , yang hanya merupakan implementasi tugas kami. <br><br>  Masalahnya hampir selesai, sekarang kita perlu menerapkan metode.  Semua OS memiliki API yang berbeda, jadi untuk mengimplementasikan, misalnya, fungsi pembuatan tugas untuk <i>embos,</i> Anda harus memanggil metode <i>OS_TASK_CreateEx (..) yang</i> kosong, dan untuk <i>FreeRTOS</i> dalam mode alokasi memori dinamis, ini adalah <i>xTaskCreate (..)</i> dan meskipun mereka memiliki satu dan esensi yang sama sama, tetapi sintaks dan parameternya berbeda.  Tapi kami tidak ingin menjalankan melalui file dan menulis kode untuk setiap metode kelas setiap kali untuk OS baru, jadi kami perlu entah bagaimana memasukkan ini ke dalam satu file dan ... jalankan dalam bentuk makro.  Hebat, tapi berhenti, saya melarang makro untuk diri saya sendiri - saya perlu pendekatan yang berbeda. <br><br>  Hal paling sederhana yang terpikir oleh saya adalah membuat file terpisah untuk setiap OS dengan fungsi sebaris.  Jika kita ingin menggunakan OS lain, kita hanya perlu mengimplementasikan masing-masing fungsi ini menggunakan API OS ini.  File <b>rtosFreeRtos.cpp</b> berikut ini ternyata <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtos.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//For FreeRTOS functions prototypes #include &lt;FreeRTOS.h&gt; //For xTaskCreate #include &lt;task.h&gt; namespace OsWrapper { void wCreateThread(Thread &amp; thread, const char * pName, ThreadPriority prior,const tU16 stackDepth, tStack *pStack) { #if (configSUPPORT_STATIC_ALLOCATION == 1) if (pStack != nullptr) { thread.handle = xTaskCreateStatic(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), pStack, &amp;thread.taskControlBlock); } #else thread.handle = (xTaskCreate(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), &amp;thread.handle) == pdTRUE) ? thread.handle : nullptr ; #endif }</span></span></span></span></code> </pre><br>  File untuk embOS <b>rtosEmbOS.cpp</b> mungkin terlihat persis <b>sama</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtos.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//For embOS functions prototypes #include &lt;rtos.h&gt; namespace OsWrapper { void wCreateThread(Thread &amp;thread, const char * pName, ThreadPriority prior,const tU16 stackDepth, tStack *pStack) { constexpr OS_UINT timeSliceNull = 0 ; if (pStack != nullptr) { OS_CreateTaskEx(&amp;(thread.handle), pName, static_cast&lt;OS_PRIO&gt;(prior), Rtos::Run, pStack, ((stackSize == 0U) ? sizeof(pStack) : stackSize), timeSliceNull, &amp;thread) ; } }</span></span></span></span></code> </pre> <br>  Jenis sistem operasi yang berbeda juga berbeda, terutama struktur konteks tugas, jadi mari kita buat file rtosdefs.hpp dengan alias pembungkus kita sendiri. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;FreeRTOS.h&gt; //For TaskHandle_t namespace OsWrapper { using tTaskContext = StaticTask_t; using tTaskHandle = TaskHandle_t; using tStack = StackType_t ; }</span></span></span></span></code> </pre><br>  Untuk <i>EmbOS,</i> mungkin terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;rtos.h&gt; //For OS_TASK namespace OsWrapper { using tTaskContext = OS_TASK; using tTaskHandle = OS_TASK; using tStack = tU16 //   void,      tU16 ; }</span></span></span></span></code> </pre><br>  Akibatnya, untuk perubahan di bawah RTOS lainnya, cukup membuat perubahan hanya di dua file ini rtosdefs.cpp dan rtos.cpp.  Sekarang kelas <i>Thread</i> dan <i>Rtos</i> terlihat seperti gambar c <br><br><img src="https://habrastorage.org/webt/gp/wq/zl/gpwqzlgnristquzlrcdbxyfm9ro.png" alt="gambar"><br><br><h2>  Meluncurkan OS dan menyelesaikan tugas </h2><br>  Untuk Cortex M4, "semua" OS menggunakan 3 interupsi, <i>pengingat</i> <i>waktu</i> <i>Sistem</i> , <i>panggilan Layanan Sistem melalui instruksi SWI</i> , <i>Permintaan yang dapat ditunda untuk gangguan layanan sistem</i> , yang terutama ditemukan untuk RTOS.  Beberapa RTOS juga menggunakan interupsi sistem lain, tetapi ini akan cukup untuk sebagian besar "semua" OS.  Dan jika tidak, maka dimungkinkan untuk menambahkan, jadi tentukan saja tiga penangan untuk interupsi ini dan untuk memulai RTOS kita perlu metode start yang lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSvcInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSvInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSysTickInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  Hal pertama yang saya butuhkan dan tanpanya saya tidak bisa hidup, apa yang saya impikan adalah mekanisme pemberitahuan untuk tugas.  Saya umumnya menyukai pemrograman yang digerakkan oleh Acara, jadi saya harus segera mengimplementasikan pembungkus untuk memberi tahu tugas. <br><br>  Semuanya ternyata cukup sederhana, OS apa pun bisa melakukannya, well, kecuali mungkin <i>uc-OS-II</i> dan <i>III</i> , meskipun mungkin saya tidak membacanya dengan baik, tetapi, menurut saya, mekanisme acara umumnya rumit, tetapi oh well, "semuanya" adalah sisanya mereka pasti bisa. <br><br>  Untuk memberi tahu tugas, Anda hanya perlu mengirim acara bukan ke kekosongan, tetapi khusus untuk tugas tersebut, untuk ini, metode pemberitahuan harus memiliki penunjuk ke konteks tugas atau pengidentifikasi tugas.  Saya hanya menyimpan ini di kelas <i>Thread</i> , yang berarti bahwa kelas Thread juga harus memiliki metode peringatan.  Seharusnya ada metode untuk menunggu peringatan.  Pada saat yang sama, kami menambahkan metode <i>Tidur (..)</i> , yang menjeda pelaksanaan tugas panggilan.  Sekarang kedua kelas terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/ie/r_/35/ier_35fgsut4a_gf_ismmm91tuk.png" alt="gambar"><br><br><div class="spoiler">  <b class="spoiler_title">rtos.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : Rtos.hpp * * Details : Rtos class is used to create tasks, work with special Rtos * functions and also it contains a special static method Run. In this method * the pointer on Thread should be pass. This method is input point as * the task of Rtos. In the body of the method, the method of concrete Thread * will run. *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"thread.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// for Thread #include "../../Common/susudefs.hpp" #include "FreeRtos/rtosdefs.hpp" namespace OsWrapper { extern void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *) ; extern void wStart() ; extern void wHandleSvcInterrupt() ; extern void wHandleSvInterrupt() ; extern void wHandleSysTickInterrupt() ; extern void wEnterCriticalSection(); extern void wLeaveCriticalSection(); class Rtos { public: static void CreateThread(Thread &amp;thread , tStack * pStack = nullptr, const char * pName = nullptr, ThreadPriority prior = ThreadPriority::normal, const tU16 stackDepth = static_cast&lt;tU16&gt;(StackDepth::minimal)) ; static void Start() ; static void HandleSvcInterrupt() ; static void HandleSvInterrupt() ; static void HandleSysTickInterrupt() ; friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); private: //cstat !MISRAC++2008-7-1-2 To prevent reinterpet_cast in the CreateTask static void Run(void *pContext ) { static_cast&lt;Thread*&gt;(pContext)-&gt;Execute() ; } } ; } ; #endif // __RTOS_HPP</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">thread.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : thread.hpp * * Details : Base class for any Taskis which contains the pure virtual * method Execute(). Any active classes which will have a method for running as * a task of RTOS should inherit the Thread and override the Execute() method. * For example: * class MyTask : public OsWrapper::Thread * { * public: * virtual void Execute() override { * while(true) { * //do something.. * } * } ; * *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FreeRtos/rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> namespace OsWrapper { extern void wSleep(const tTime) ; extern void wSleepUntil(tTime &amp;, const tTime) ; extern tTime wGetTicks() ; extern void wSignal(tTaskHandle const &amp;, const tTaskEventMask) ; extern tTaskEventMask wWaitForSignal(const tTaskEventMask, tTime) ; constexpr tTaskEventMask defaultTaskMaskBits = 0b010101010 ; enum class ThreadPriority { clear = 0, lowest = 10, belowNormal = 20, normal = 30, aboveNormal = 80, highest = 90, priorityMax = 255 } ; enum class StackDepth: tU16 { minimal = 128U, medium = 256U, big = 512U, biggest = 1024U }; class Thread { public: virtual void Execute() = 0 ; inline tTaskHandle GetTaskHanlde() const { return handle; } static void Sleep(const tTime timeOut = 1000ms) { wSleep(timeOut) ; }; inline void Signal(const tTaskEventMask mask = defaultTaskMaskBits) { wSignal(handle, mask); }; inline tTaskEventMask WaitForSignal(tTime timeOut = 1000ms, const tTaskEventMask mask = defaultTaskMaskBits) { return wWaitForSignal(mask, timeOut) ; } friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); private: tTaskHandle handle ; tTaskContext context ; } ; } ; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __THREAD_HPP</span></span></span></span></code> </pre><br></div></div><br>  Saya mulai mengimplementasikannya, dan di sini masalah pertama sedang menunggu saya, ternyata "ada" OS memanggil fungsinya dari interupsi dengan cara yang berbeda.  Misalnya, <i>FreeRTOS</i> memiliki implementasi khusus fungsi untuk mengeksekusinya dari interupsi, misalnya, jika ada fungsi <i>xTaskNotify (..)</i> , maka Anda tidak dapat memanggilnya dari interrupt, tetapi Anda perlu memanggil <i>xTaskNotifyFromISR (..)</i> . <br>  Untuk <i>embOS,</i> jika Anda memanggil fungsi apa pun dari interupsi, silakan gunakan <i>OS_InInterrupt ()</i> saat memasukkan interupsi dan <i>OS_LeaveInterrupt ()</i> saat keluar.  Saya harus membuat kelas <i>InterruptEntry</i> , yang hanya memiliki konstruktor dan destruktor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> OsWrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wEnterInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wLeaveInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterruptEntry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterruptEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ wEnterInterrupt() ; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> ~InterruptEntry() { wLeaveInterrupt() ; } } ; } ;</code> </pre> <br>  Anda bisa menggunakannya seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Button::HandleInterrupt() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OsWrapper::InterruptEntry ie; EXTI-&gt;PR = EXTI_PR_PR13 ; myDesiredTask.Signal(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> myDesiredTask::Execute() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WaitForSignal(<span class="hljs-number"><span class="hljs-number">100000</span></span>ms) == defaultTaskMaskBits) { GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; } } } ;</code> </pre> <br>  Jelas, untuk <i>FreeRTOS,</i> baik konstruktor maupun destruktor akan kosong.  Dan untuk pemberitahuan, Anda dapat menggunakan fungsi <i>xTaskNotifyFromISR (..)</i> , yang dari mana pun namanya, sedikit overhead, tetapi apa yang tidak dapat Anda lakukan demi universalitas.  Tentu saja Anda dapat membuat metode terpisah untuk panggilan dari interupsi, tetapi untuk sekarang saya memutuskan untuk melakukannya secara universal. <br>  Trik yang sama dengan <i>InterruptEntry</i> dapat dilakukan dengan bagian kritis: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> OsWrapper{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CriticalSection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CriticalSection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ wEnterCriticalSection() ; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> ~CriticalSection() { wLeaveCriticalSection() ; } } ; } ;</code> </pre> <br>  Sekarang cukup tambahkan implementasi fungsi menggunakan <i>FreeRtos</i> API ke file dan jalankan cek, meskipun Anda tidak bisa menjalankannya, jadi jelas bahwa itu akan berhasil :) <br><div class="spoiler">  <b class="spoiler_title">rtosFreeRtos.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : rtosFreeRtos.cpp * * Details : This file containce implementation of functions of concrete * FreeRTOS to support another RTOS create the same file with the * same functions but another name&lt; for example rtosEmbOS.cpp and * implement these functions using EmbOS API. * *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../thread.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../mutex.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../rtos.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../event.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; namespace OsWrapper { /***************************************************************************** * Function Name: wCreateThread * Description: Creates a new task and passes a parameter to the task. The * function should call appropriate RTOS API function to create a task. * * Assumptions: RTOS API create task function should get a parameter to pass the * paramete to task. * Some RTOS does not use pStack pointer so it should be set to nullptr * * Parameters: [in] thread - refernce on Thread object * [in] pName - name of task * [in] prior - task priority * [in] stackDepth - size of Stack * [in] pStack - pointer on task stack * Returns: No ****************************************************************************/ void wCreateThread(Thread &amp; thread, const char * pName, ThreadPriority prior, const tU16 stackDepth, tStack *pStack) { #if (configSUPPORT_STATIC_ALLOCATION == 1) if (pStack != nullptr) { thread.handle = xTaskCreateStatic(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), pStack, &amp;thread.context); } #else thread.handle = (xTaskCreate(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), &amp;thread.handle) == pdTRUE) ? thread.handle : nullptr ; #endif } /***************************************************************************** * Function Name: wStart() * Description: Starts the RTOS scheduler * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wStart() { vTaskStartScheduler() ; } /***************************************************************************** * Function Name: wHandleSvcInterrupt() * Description: Handle of SVC Interrupt. The function should call appropriate * RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSvcInterrupt() { vPortSVCHandler() ; } /***************************************************************************** * Function Name: wHandleSvInterrupt() * Description: Handle of SV Interrupt. The function should call appropriate * RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSvInterrupt() { xPortPendSVHandler() ; } /***************************************************************************** * Function Name: wHandleSysTickInterrupt() * Description: Handle of System Timer Interrupt. The function should call * appropriate RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSysTickInterrupt() { xPortSysTickHandler() ; } /***************************************************************************** * Function Name: wSleep() * Description: Suspends the calling task for a specified period of time, * or waits actively when called from main() * * Assumptions: No * Parameters: [in] timeOut - specifies the time interval in system ticks * Returns: No ****************************************************************************/ void wSleep(const tTime timeOut) { vTaskDelay(timeOut) ; } /***************************************************************************** * Function Name: wEnterCriticalSection() * Description: Basic critical section implementation that works by simply * disabling interrupts * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wEnterCriticalSection() { taskENTER_CRITICAL() ; } /***************************************************************************** * Function Name: wLeaveCriticalSection() * Description: Leave critical section implementation that works by simply * enabling interrupts * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wLeaveCriticalSection() { taskEXIT_CRITICAL() ; } /**************************************************************************** * Function Name: wEnterInterrupt() * Description: Some RTOS requires to inform the kernel that interrupt code * is executing * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wEnterInterrupt() { } /**************************************************************************** * Function Name: wLeaveInterrupt() * Description: Some RTOS requires to inform that the end of the interrupt r * outine has been reached; executes task switching within ISR * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wLeaveInterrupt() { } /**************************************************************************** * Function Name: wSignal() * Description: Signals event(s) to a specified task * * Assumptions: No * Parameters: [in] taskHandle - Reference to the task structure * [in] mask - The event bit mask containing the event bits, * which shall be signaled. * Returns: No ****************************************************************************/ void wSignal(tTaskHandle const &amp;taskHandle, const tTaskEventMask mask) { BaseType_t xHigherPriorityTaskWoken = pdFALSE ; xTaskNotifyFromISR(taskHandle, mask, eSetBits, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR( xHigherPriorityTaskWoken ) ; } /**************************************************************************** * Function Name: wWaitForSignal() * Description: Waits for the specified events for a given time, and clears * the event memory when the function returns * * Assumptions: No * Parameters: [in] mask - The event bit mask containing the event bits, * which shall be waited for * [in] timeOut - Maximum time in system ticks waiting for events * to be signaled. * Returns: Set bits ****************************************************************************/ tTaskEventMask wWaitForSignal(const tTaskEventMask mask, tTime timeOut) { uint32_t ulNotifiedValue = 0U ; xTaskNotifyWait( 0U, std::numeric_limits&lt;uint32_t&gt;::max(), &amp;ulNotifiedValue, timeOut); return (ulNotifiedValue &amp; mask) ; } /**************************************************************************** * Function Name: wCreateEvent() * Description: Create an Event object * * Assumptions: No * Parameters: [in] event - reference on tEvent object * * Returns: Handle of created Event ****************************************************************************/ tEventHandle wCreateEvent(tEvent &amp;event) { #if (configSUPPORT_STATIC_ALLOCATION == 1) return xEventGroupCreateStatic(&amp;event); #else return xEventGroupCreate(); #endif } /**************************************************************************** * Function Name: wDeleteEvent() * Description: Create an Event object * * Assumptions: No * Parameters: [in] eventHandle - reference on tEventHandle object * * Returns: No ****************************************************************************/ void wDeleteEvent(tEventHandle &amp;eventHandle) { vEventGroupDelete(eventHandle); } /**************************************************************************** * Function Name: wSignalEvent() * Description: Sets an resumes tasks which are waiting at the event object * * Assumptions: No * Parameters: [in] event - reference on eventHandle object * [in] mask - The event bit mask containing the event bits, * which shall be signaled * * Returns: No ****************************************************************************/ void wSignalEvent(tEventHandle const &amp;eventHandle, const tEventBits mask) { BaseType_t xHigherPriorityTaskWoken = pdFALSE; xEventGroupSetBitsFromISR(eventHandle, mask, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR(xHigherPriorityTaskWoken) ; } /**************************************************************************** * Function Name: wWaitEvent() * Description: Waits for an event and suspends the task for a specified time * or until the event has been signaled. * * Assumptions: No * Parameters: [in] event - Reference on eventHandle object * [in] mask - The event bit mask containing the event bits, * which shall be signaled * [in] timeOut - Maximum time in RTOS system ticks until the * event must be signaled. * [in] mode - Indicate mask bit behaviour * * Returns: Set bits ****************************************************************************/ tEventBits wWaitEvent(tEventHandle const &amp;eventHandle, const tEventBits mask, const tTime timeOut, OsWrapper::EventMode mode) { BaseType_t xWaitForAllBits = pdFALSE ; if (mode == OsWrapper::EventMode::waitAnyBits) { xWaitForAllBits = pdFALSE; } return xEventGroupWaitBits(eventHandle, mask, pdTRUE, xWaitForAllBits, timeOut) ; } /**************************************************************************** * Function Name: wCreateMutex() * Description: Create an mutex. Mutexes are used for managing resources by * avoiding conflicts caused by simultaneous use of a resource. The resource * managed can be of any kind: a part of the program that is not reentrant, a * piece of hardware like the display, a flash prom that can only be written to * by a single task at a time, a motor in a CNC control that can only be * controlled by one task at a time, and a lot more. * * Assumptions: No * Parameters: [in] mutex - Reference on tMutex structure * [in] mode - Indicate mask bit behaviour * * Returns: Mutex handle ****************************************************************************/ tMutexHandle wCreateMutex(tMutex &amp;mutex) { #if (configSUPPORT_STATIC_ALLOCATION == 1) return xSemaphoreCreateMutexStatic(&amp;mutex) ; #else return xSemaphoreCreateMutex(); #endif } /**************************************************************************** * Function Name: wDeleteMutex() * Description: Delete the mutex. * * Assumptions: No * Parameters: [in] mutex - handle of mutex * * Returns: Mutex handle ****************************************************************************/ void wDeleteMutex(tMutexHandle &amp;handle) { vSemaphoreDelete(handle) ; } /**************************************************************************** * Function Name: wLockMutex() * Description: Claim the resource * * Assumptions: No * Parameters: [in] handle - handle of mutex * [in] timeOut - Maximum time until the mutex should be available * * Returns: true if resource has been claimed, false if timeout is expired ****************************************************************************/ bool wLockMutex(tMutexHandle const &amp;handle, tTime timeOut) { return static_cast&lt;bool&gt;(xSemaphoreTake(handle, timeOut)) ; } /**************************************************************************** * Function Name: wUnLockMutex() * Description: Releases a mutex currently in use by a task * * Assumptions: No * Parameters: [in] handle - handle of mutex * * Returns: No ****************************************************************************/ void wUnLockMutex(tMutexHandle const &amp;handle) { BaseType_t xHigherPriorityTaskWoken = pdFALSE ; xSemaphoreGiveFromISR(handle, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR( xHigherPriorityTaskWoken ) ; } /**************************************************************************** * Function Name: wSleepUntil() * Description: Suspends the calling task until a specified time, or waits * actively when called from main() * * Assumptions: No * Parameters: [in] last - Refence to a variable that holds the time at which * the task was last unblocked. The variable must be initialised * with the current time prior to its first use * [in] timeOut - Time to delay until, the task will be unblocked * at time * * Returns: No ****************************************************************************/ void wSleepUntil(tTime &amp; last, const tTime timeOut) { vTaskDelayUntil( &amp;last, timeOut) ; } /**************************************************************************** * Function Name: wGetTicks() * Description: Returns the current system time in ticks as a native integer * value * * Assumptions: No * Parameters: No * * Returns: Current system time in ticks ****************************************************************************/ tTime wGetTicks() { return xTaskGetTickCount(); } }</span></span></span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/4a/sm/mm/4asmmm71hosjm510maad5hcadrm.png" alt="gambar"><br><br><h2>  Kami terus memperbaiki tugas </h2><br>  Tugas sekarang memiliki hampir semua yang Anda butuhkan, kami menambahkan metode Sleep ().  Metode ini menjeda tugas untuk waktu tertentu.  Dalam kebanyakan kasus, ini sudah cukup, tetapi jika Anda membutuhkan waktu yang ditentukan dengan jelas, maka Sleep () dapat membawa Anda masalah.  Misalnya, Anda ingin melakukan perhitungan dan mengedipkan LED dan melakukannya tepat setiap 100 ms <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyTask::Execute() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { DoCalculation(); <span class="hljs-comment"><span class="hljs-comment">//It takes about 10ms Led1.Toggle() ; Sleep(100ms) ; } }</span></span></code> </pre><br>  Kode ini akan berkedip LED setiap 110 ms.  Tetapi Anda ingin sekali setiap 100 ms, Anda dapat secara kasar menghitung waktu perhitungan dan menempatkan Sleep (90 ms).  Tetapi bagaimana jika waktu perhitungan tergantung pada parameter input, maka berkedip tidak akan menjadi deterministik sama sekali.  Untuk kasus seperti itu di "semua" OS, ada metode khusus, seperti DelayUntil ().  Ini bekerja pada prinsip ini - pertama Anda perlu mengingat nilai saat ini dari tick tick dari sistem operasi, kemudian tambahkan ke nilai ini jumlah ticks yang Anda butuhkan untuk menjeda tugas, segera setelah tick tick mencapai nilai ini, tugas dibuka kuncinya.  Dengan demikian, tugas akan dikunci tepat ke nilai yang Anda tetapkan dan LED Anda akan berkedip persis setiap 100 ms, terlepas dari durasi perhitungan. <br>  Mekanisme ini diimplementasikan secara berbeda di sistem operasi yang berbeda, tetapi memiliki satu algoritma.  Akibatnya, mekanisme, katakanlah, diterapkan pada FreeRTOS, akan disederhanakan menjadi negara yang ditunjukkan pada gambar berikut: <br><br><img src="https://habrastorage.org/webt/tg/n1/hb/tgn1hba-pczt2p5b0dzy0kut-ua.png" alt="gambar"><br><br>  Seperti yang Anda lihat pembacaan keadaan awal dari tick tick pada sistem operasi terjadi sebelum memasuki loop tak terbatas, dan kita perlu menemukan sesuatu untuk mengimplementasikannya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Templat</a> desain tersedia untuk membantu. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode templat</a> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diimplementasikan dengan sangat sederhana, kita hanya perlu menambahkan metode non-virtual, di mana pertama kita memanggil metode yang membaca dan mengingat penghitung tik dari sistem operasi, dan kemudian kita memanggil metode virtual Execute (), yang akan diimplementasikan dalam turunan, yaitu. </font><font style="vertical-align: inherit;">dalam implementasi tugas Anda. </font><font style="vertical-align: inherit;">Karena kami tidak memerlukan metode ini untuk pengguna (ini hanya tambahan), kami akan menyembunyikannya di bagian pribadi.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rtos</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ lastWakeTime = wGetTicks() ; Execute(); } ... tTime lastWakeTime = <span class="hljs-number"><span class="hljs-number">0</span></span>ms ; ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, dalam metode Run statis kelas Rtos, sekarang akan perlu untuk memanggil bukan Execute (), tetapi metode Run () dari objek Thread. </font><font style="vertical-align: inherit;">Kami baru saja membuat kelas Rtos ramah untuk mengakses metode Run () pribadi di kelas Thread.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pContext )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Thread*&gt;(pContext)-&gt;Run() ; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya batasan untuk metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SleepUntil ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah </font><font style="vertical-align: inherit;">tidak dapat diterapkan bersama dengan metode lain yang memblokir tugas. </font><font style="vertical-align: inherit;">Atau, untuk menyelesaikan masalah bekerja bersama-sama dengan metode lain yang memblokir tugas, akan mungkin untuk menambahkan metode memperbarui penghitung centang yang diingat dari sistem, dan memanggilnya sebelum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SleepUntil ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi untuk saat ini kami hanya menjaga nuansa ini dalam pikiran. </font><font style="vertical-align: inherit;">Versi ekstrem dari kelas terlihat seperti pada gambar berikut:</font></font><br><img src="https://habrastorage.org/webt/aw/nx/ts/awnxtsvd-odgyfaagkl3egc_tvs.png" alt="gambar"><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : thread.hpp * * Details : Base class for any Taskis which contains the pure virtual * method Execute(). Any active classes which will have a method for running as * a task of RTOS should inherit the Thread and override the Execute() method. * For example: * class MyTask : public OsWrapper::Thread * { * public: * virtual void Execute() override { * while(true) { * //do something.. * } * } ; * * Author : Sergey Kolody *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FreeRtos/rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> namespace OsWrapper { extern void wSleep(const tTime) ; extern void wSleepUntil(tTime &amp;, const tTime) ; extern tTime wGetTicks() ; extern void wSignal(tTaskHandle const &amp;, const tTaskEventMask) ; extern tTaskEventMask wWaitForSignal(const tTaskEventMask, tTime) ; constexpr tTaskEventMask defaultTaskMaskBits = 0b010101010 ; enum class ThreadPriority { clear = 0, lowest = 10, belowNormal = 20, normal = 30, aboveNormal = 80, highest = 90, priorityMax = 255 } ; enum class StackDepth: tU16 { minimal = 128U, medium = 256U, big = 512U, biggest = 1024U }; class Thread { public: virtual void Execute() = 0 ; inline tTaskHandle GetTaskHanlde() const { return handle; } static void Sleep(const tTime timeOut = 1000ms) { wSleep(timeOut) ; }; void SleepUntil(const tTime timeOut = 1000ms) { wSleepUntil(lastWakeTime, timeOut); }; inline void Signal(const tTaskEventMask mask = defaultTaskMaskBits) { wSignal(handle, mask); }; inline tTaskEventMask WaitForSignal(tTime timeOut = 1000ms, const tTaskEventMask mask = defaultTaskMaskBits) { return wWaitForSignal(mask, timeOut) ; } friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); friend class Rtos ; private: tTaskHandle handle ; tTaskContext context ; tTime lastWakeTime = 0ms ; void Run() { lastWakeTime = wGetTicks() ; Execute(); } } ; } ; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __THREAD_HPP</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rtos.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : Rtos.hpp * * Details : Rtos class is used to create tasks, work with special Rtos * functions and also it contains a special static method Run. In this method * the pointer on Thread should be pass. This method is input point as * the task of Rtos. In the body of the method, the method of concrete Thread * will run. *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"thread.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// for Thread #include "../../Common/susudefs.hpp" #include "FreeRtos/rtosdefs.hpp" namespace OsWrapper { extern void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *) ; extern void wStart() ; extern void wHandleSvcInterrupt() ; extern void wHandleSvInterrupt() ; extern void wHandleSysTickInterrupt() ; extern void wEnterCriticalSection(); extern void wLeaveCriticalSection(); class Rtos { public: static void CreateThread(Thread &amp;thread , tStack * pStack = nullptr, const char * pName = nullptr, ThreadPriority prior = ThreadPriority::normal, const tU16 stackDepth = static_cast&lt;tU16&gt;(StackDepth::minimal)) ; static void Start() ; static void HandleSvcInterrupt() ; static void HandleSvInterrupt() ; static void HandleSysTickInterrupt() ; friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); friend class Thread ; private: //cstat !MISRAC++2008-7-1-2 To prevent reinterpet_cast in the CreateTask static void Run(void *pContext ) { static_cast&lt;Thread*&gt;(pContext)-&gt;Run() ; } } ; } ; #endif // __RTOS_HPP</span></span></span></span></code> </pre><br></div></div><br><br><h2>  Acara </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi tugas sedang dibuat, adalah mungkin untuk mengirim acara ke sana, tapi saya ingin mengimplementasikan acara yang dapat dikirim bukan ke tugas tertentu, tetapi untuk pelanggan yang memutuskan untuk menunggu acara ini. </font><font style="vertical-align: inherit;">Secara kasar, kita perlu menerapkan pembungkus atas Acara.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, mekanisme acara menyiratkan banyak pilihan, Anda dapat mengirim acara dengan mengatur bit, dan beberapa tugas dapat menunggu beberapa bit untuk diatur, yang lain untuk mengatur yang lain, Anda dapat mengharapkan semuanya sekaligus, Anda dapat menghapus bit setelah acara diterima, singkatnya ada banyak pilihan, tetapi dalam pekerjaan saya, saya perlu mengirim dan menerima acara dan membuang semua bit. </font><font style="vertical-align: inherit;">Namun, Anda masih perlu menawarkan antarmuka sederhana untuk mendukung fungsionalitas tambahan. </font><font style="vertical-align: inherit;">Dengan struktur acara, mereka mirip dengan tugas, mereka juga memiliki konteks tertentu yang perlu disimpan dan pengidentifikasi, saya juga ingin acara tersebut dikonfigurasi untuk menunggu waktu dan topeng, jadi saya menambahkan dua bidang pribadi lagi. </font></font><br><br><img src="https://habrastorage.org/webt/gv/na/8k/gvna8ktlrzvrposxbpwhzpn0keq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda bisa menggunakannya seperti ini:</font></font><br><br><pre> <code class="cpp hljs">OsWrapper::Event event{<span class="hljs-number"><span class="hljs-number">10000</span></span>ms, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  ,    10000ms,    0    1. void SomeTask::Execute() { while(true) { using OsWrapper::operator""ms ; Sleep(1000ms); event.Signal() ; //      0   1. Sleep(1000ms); event.SetMaskBits(4) //    2. event.Signal() ; //      2. } } ; void AnotherTask::Execute() { while(true) { using namespace::OsWrapper ; //,      ,    10000ms if ((event.Wait() &amp; defaultTaskMaskBits) != 0) { GPIOC-&gt;ODR ^= (1 &lt;&lt; 5) ; } } } ;</span></span></code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mutex, Semaphores dan Antrian </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya, ketika saya menulis artikel ini, saya belum mengimplementasikannya, tetapi seperti yang dijanjikan saya mengembangkan mutexes dan kotak email, sumbernya ada di sini: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub OsWrapper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Contoh menggunakan kotak surat adalah sebagai berikut:</font></font><br><pre> <code class="cpp hljs">OsWrapper::MailBox&lt;tU32, <span class="hljs-number"><span class="hljs-number">10</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    10   int void ReceiveTask::Execute() { tU32 item; while(true) { using OsWrapper::operator""ms ; if (queue.Get(item, 10000ms)) { //    GPIOC-&gt;ODR ^= (1 &lt;&lt; 9); } } } ; void SendTask::Execute() { tU32 item = 0U; while(true) { queue.Put(item); item ++; SleepUntil(1000ms); } } ;</span></span></code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cara menggunakan semua bisnis ini </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dasarnya dibuat untuk memahami bagaimana semua ini dapat digunakan, saya memberikan sepotong kecil kode yang melakukan hal berikut: Tugas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LedTask</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berkedip LED tepat 2 detik, dan setiap 2 detik itu mengirim sinyal ke tugas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">myTask</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menunggu 10 detik untuk acara segera setelah acara telah tiba, dia berkedip LED lain. Secara umum, sebagai hasilnya, dua LED berkedip setiap 2 detik sekali. Saya tidak langsung memberi tahu tugas itu, tetapi melakukannya melalui </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acara</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Apakah ini solusi luar biasa untuk mengedipkan dua LED :)</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OsWrapper::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>ms ; OsWrapper::Event event{<span class="hljs-number"><span class="hljs-number">10000</span></span>ms, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTask</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OsWrapper::Thread { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.Wait() != <span class="hljs-number"><span class="hljs-number">0</span></span>) { GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tMyTaskStack = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;OsWrapper::tStack, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tMyTaskStack Stack; <span class="hljs-comment"><span class="hljs-comment">//C++17   IAR 8.30 } ; class LedTask : public OsWrapper::Thread { public: virtual void Execute() override { while(true) { GPIOC-&gt;ODR ^= (1 &lt;&lt; 5) ; using OsWrapper::operator""ms ; SleepUntil(2000ms); event.Signal() ; } } using tLedStack = std::array&lt;OsWrapper::tStack, static_cast&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; inline static tLedStack Stack; //C++17   IAR 8.30 } ; MyTask myTask; LedTask ledTask; int main() { using namespace OsWrapper ; Rtos::CreateThread(myTask, MyTask::Stack.data(), "myTask", ThreadPriority::lowest, MyTask::Stack.size()) ; Rtos::CreateThread(ledTask, LedTask::Stack.data()) ; Rtos::Start(); return 0; }</span></span></code> </pre> <br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya berani mengungkapkan pandangan subjektif saya tentang masa depan firmware untuk mikrokontroler. Saya percaya bahwa C ++ akan datang dan cepat atau lambat semakin banyak sistem operasi akan muncul yang menyediakan antarmuka C ++. Produsen sekarang perlu menulis ulang atau membungkus semuanya dalam C ++. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari sudut pandang ini, saya akan merekomendasikan menggunakan RTOS yang ditulis dalam C ++, misalnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RTOS MAX yang</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditunjukkan di atas </font><font style="vertical-align: inherit;">, berapa banyak waktu yang dapat menyelamatkan Anda, Anda bahkan tidak bisa membayangkan, karena masih ada fitur unik seperti, misalnya, sarana interaksi tugas, berjalan pada mikrokontroler yang berbeda. Jika dia juga memiliki sertifikat keamanan, maka tidak akan ada solusi yang lebih baik.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi sementara itu, sebagian besar dari kita menggunakan OS Sishna tradisional, Anda dapat menggunakan pembungkus sebagai awal untuk transisi ke masa depan yang bahagia dengan C ++ :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mengumpulkan proyek uji kecil di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Saya harus mengutak-atik pengaturannya, itu masih tidak cukup dimaksudkan untuk mengembangkan perangkat lunak untuk mikrokontroler, dan hampir tidak berteman dengan IAR toolchain, tetapi bagaimanapun, ternyata untuk mengkompilasi, tautan ke format elf, dikonversi ke format hex, flash, dan mulai debugging menggunakan Gdb. Dan itu sepadan - itu hanya lingkungan yang sangat baik, dan itu mengoreksi kesalahan saat bepergian, dan jika Anda perlu mengubah tanda tangan metode, kemudian refactoring dalam 2 detik, dan secara umum Anda tidak perlu berpikir lagi, dia akan mengatakan pada dirinya sendiri di mana seharusnya, apa yang lebih baik untuk membuat atau memberi nama parameter . Saya bahkan mendapat kesan bahwa pembungkus itu sendiri ditulis oleh Clion. Secara umum, ketika semua bug yang terkait dengan rantai alat IAR diperbaiki, Anda dapat mengambilnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi dengan cara kuno, saya membuat proyek untuk IAR untuk versi 8.30.1, di atasnya saya memeriksa cara kerjanya. Digunakan peralatan berikut:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XNUCLEO-F411RE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ST-Link Debugger. </font><font style="vertical-align: inherit;">Namun, sekali lagi, lihat bagaimana debugging terlihat di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - yah, bagus, tapi masih bermasalah :) </font></font><br><br><img src="https://habrastorage.org/webt/tx/m_/e8/txm_e8pms1viazgy6cypd-kjj3q.png" alt="gambar"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyek </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAR</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat Anda ambil di sini: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyek IAR 8.30.1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sementara ini adalah versi yang tidak lengkap, tanpa antrian dan semafor, saya lebih lengkap Saya akan meletakkannya di github ketika tangan saya mencapai, waktu untuk belajar dimulai dan waktu akan sangat kecil, Tapi saya pikir ini sudah dapat digunakan untuk proyek-proyek kecil bersama dengan FreeRtos.</font></font><br><br>  Z.Y.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang dijanjikan pada </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Proyek</font></a><font style="vertical-align: inherit;"> Wrapper GitHub</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420467/">https://habr.com/ru/post/id420467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420457/index.html">Ikhtisar Perangkat Lunak Pencetakan 3D Simplify3D</a></li>
<li><a href="../id420459/index.html">Ikon dengan penghitung di bilah alat atas: contoh berbagai pendekatan untuk satu tugas</a></li>
<li><a href="../id420461/index.html">10 kutipan dari desainer yang buruk</a></li>
<li><a href="../id420463/index.html">ICO sepatutnya dalam penurunan, tetapi mereka memiliki kesempatan untuk berubah</a></li>
<li><a href="../id420465/index.html">Variabel nginx dengan njs: sederhana, tidak menyakitkan dan melalui JavaScript</a></li>
<li><a href="../id420469/index.html">Fitur menggunakan Druid pada contoh Classmates</a></li>
<li><a href="../id420471/index.html">Tiga laporan teknis RIT 2018 oleh Plesk</a></li>
<li><a href="../id420473/index.html">Buku untuk eksekutif pemula atau mengapa sangat penting untuk dibaca</a></li>
<li><a href="../id420475/index.html">Perbandingan mesin pemotong laser Raylogic 11G dan Raylogic V12</a></li>
<li><a href="../id420477/index.html">Ulasan HyperX Cloud Stinger Core: headset karakter yang ringan dan kasar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>