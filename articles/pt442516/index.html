<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüéì ü§πüèæ üßëüèø‚Äçü§ù‚ÄçüßëüèΩ Guia do Pandas para an√°lise de big data üßîüèΩ üßòüèæ üì¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao usar a biblioteca do pandas para analisar pequenos conjuntos de dados, cujo tamanho n√£o excede 100 megabytes, o desempenho raramente se torna um pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia do Pandas para an√°lise de big data</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442516/"> Ao usar a biblioteca do pandas para analisar pequenos conjuntos de dados, cujo tamanho n√£o excede 100 megabytes, o desempenho raramente se torna um problema.  Mas quando se trata do estudo de conjuntos de dados, cujos tamanhos podem atingir v√°rios gigabytes, problemas de desempenho podem levar a um aumento significativo na dura√ß√£o da an√°lise de dados e at√© a incapacidade de realizar an√°lises devido √† falta de mem√≥ria. <br><br>  Embora ferramentas como o Spark possam processar com efici√™ncia grandes conjuntos de dados (de centenas de gigabytes a v√°rios terabytes), para utilizar totalmente seus recursos, voc√™ geralmente precisa de um hardware bastante poderoso e caro.  E, em compara√ß√£o com os pandas, eles n√£o diferem em ricos conjuntos de ferramentas para limpeza, pesquisa e an√°lise de dados de alta qualidade.  Para conjuntos de dados de tamanho m√©dio, √© melhor tentar usar pandas com mais efici√™ncia, em vez de mudar para outras ferramentas. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/gd/jg/60/gdjg60abxgti2otxocpd0ct2uci.jpeg"></a> <br><br>  No material, cuja tradu√ß√£o publicamos hoje, falaremos sobre as peculiaridades de trabalhar com mem√≥ria ao usar pandas e como reduzir o consumo de mem√≥ria em quase 90%, selecionando os tipos de dados apropriados armazenados nas colunas das estruturas de dados da tabela do <code>DataFrame</code> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Trabalhando com dados em jogos de beisebol</font> </h2><br>  Trabalharemos com dados dos jogos de beisebol da Major League coletados ao longo de 130 anos e retirados do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Retrosheet</a> . <br><br>  Inicialmente, esses dados foram apresentados como 127 arquivos CSV, mas os combinamos em um conjunto de dados usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">csvkit</a> e adicionamos, como a primeira linha da tabela resultante, uma linha com nomes de colunas.  Se desejar, voc√™ pode fazer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o</a> download da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nossa vers√£o</a> desses dados e experiment√°-los, lendo o artigo. <br><br>  Vamos come√ßar importando um conjunto de dados e dando uma olhada nas cinco primeiras linhas.  Voc√™ pode encontr√°-los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta</a> tabela, no <code>   </code> folha do <code>   </code> . <br><br><pre> <code class="plaintext hljs">import pandas as pd gl = pd.read_csv('game_logs.csv') gl.head()</code> </pre> <br>  Abaixo est√£o as informa√ß√µes sobre as colunas mais importantes da tabela com esses dados.  Se voc√™ quiser ler as explica√ß√µes para todas as colunas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> pode encontrar um dicion√°rio de dados para todo o conjunto de dados. <br><br><ul><li>  <code>date</code> - data do jogo. </li><li>  <code>v_name</code> - O nome da equipe convidada. </li><li>  <code>v_league</code> - Liga da equipe visitante. </li><li>  <code>h_name</code> - O nome do time da casa. </li><li>  <code>h_league</code> - A liga dos times da casa. </li><li>  <code>v_score</code> - Pontos da equipe visitante. </li><li>  <code>h_score</code> - Pontos da equipe da casa. </li><li>  <code>v_line_score</code> - Um resumo dos pontos da equipe de convidados, por exemplo - <code>010000(10)00</code> . </li><li>  <code>h_line_score</code> - Um resumo dos pontos da equipe da casa, por exemplo - <code>010000(10)0X</code> . </li><li>  <code>park_id</code> - O identificador do campo em que o jogo foi jogado. </li><li>  <code>attendance</code> - O n√∫mero de espectadores. </li></ul><br>  Para descobrir informa√ß√µes gerais sobre o objeto <code>DataFrame</code> , voc√™ pode usar o m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DataFrame.info ()</a> .  Gra√ßas a esse m√©todo, voc√™ pode aprender sobre o tamanho de um objeto, sobre tipos de dados e sobre o uso de mem√≥ria. <br><br>  Por padr√£o, os pandas, por uma quest√£o de economia de tempo, <code>DataFrame</code> informa√ß√µes aproximadas sobre o uso de mem√≥ria pelo <code>DataFrame</code> .  Como estamos interessados ‚Äã‚Äãem informa√ß√µes precisas, definiremos o par√¢metro <code>memory_usage</code> como <code>'deep'</code> . <br><br><pre> <code class="plaintext hljs">gl.info(memory_usage='deep')</code> </pre> <br>  Aqui est√£o as informa√ß√µes que conseguimos obter: <br><br><pre> <code class="plaintext hljs">&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 171907 entries, 0 to 171906 Columns: 161 entries, date to acquisition_info dtypes: float64(77), int64(6), object(78) memory usage: 861.6 MB</code> </pre> <br>  Como se viu, temos 171.907 linhas e 161 colunas.  A biblioteca do pandas detectou automaticamente os tipos de dados.  Existem 83 colunas com dados num√©ricos e 78 colunas com objetos.  As colunas de objeto s√£o usadas para armazenar dados de sequ√™ncia e nos casos em que a coluna cont√©m dados de tipos diferentes. <br><br>  Agora, para entender melhor como voc√™ pode otimizar o uso da mem√≥ria com este <code>DataFrame</code> , vamos falar sobre como o pandas armazena dados na mem√≥ria. <br><br><h2>  <font color="#3AC1EF">Visualiza√ß√£o interna de um DataFrame</font> </h2><br>  Dentro dos pandas, as colunas de dados s√£o agrupadas em blocos com valores do mesmo tipo.  Aqui est√° um exemplo de como as 12 primeiras colunas de um <code>DataFrame</code> s√£o armazenadas em pandas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c70/c63/d35c70c635289a5cecc520c58e662e9a.png"></div><br>  <i><font color="#999999">Representa√ß√£o interna de diferentes tipos de dados em pandas</font></i> <br><br>  Voc√™ pode perceber que os blocos n√£o armazenam informa√ß√µes sobre o nome da coluna.  Isso ocorre porque os blocos s√£o otimizados para armazenar os valores dispon√≠veis nas c√©lulas da tabela do objeto <code>DataFrame</code> .  A classe <code>BlockManager</code> √© respons√°vel por armazenar informa√ß√µes sobre a correspond√™ncia entre os √≠ndices de linha e coluna do conjunto de dados e o que √© armazenado em blocos do mesmo tipo de dados.  Ele desempenha o papel de uma API que fornece acesso a dados b√°sicos.  Quando lemos, editamos ou <code>DataFrame</code> valores, a classe <code>DataFrame</code> interage com a classe <code>BlockManager</code> para converter nossos pedidos em chamadas de fun√ß√£o e m√©todo. <br><br>  Cada tipo de dados possui uma classe especializada no m√≥dulo <code>pandas.core.internals</code> .  Por exemplo, o pandas usa a classe <code>ObjectBlock</code> para representar blocos que cont√™m colunas de string e a classe <code>FloatBlock</code> para representar blocos que cont√™m colunas que <code>FloatBlock</code> n√∫meros de ponto flutuante.  Para blocos que representam valores num√©ricos que se parecem com n√∫meros inteiros ou n√∫meros de ponto flutuante, o pandas combina as colunas e as armazena como a <code>ndarray</code> dados <code>ndarray</code> biblioteca NumPy.  Essa estrutura de dados √© baseada na matriz C, os valores s√£o armazenados em um bloco cont√≠nuo de mem√≥ria.  Gra√ßas a esse esquema de armazenamento de dados, o acesso aos fragmentos de dados √© muito r√°pido. <br><br>  Como dados de tipos diferentes s√£o armazenados separadamente, examinamos o uso de mem√≥ria de diferentes tipos de dados.  Vamos come√ßar com o uso m√©dio de mem√≥ria para diferentes tipos de dados. <br><br><pre> <code class="plaintext hljs">for dtype in ['float','int','object']:   selected_dtype = gl.select_dtypes(include=[dtype])   mean_usage_b = selected_dtype.memory_usage(deep=True).mean()   mean_usage_mb = mean_usage_b / 1024 ** 2   print("Average memory usage for {} columns: {:03.2f} MB".format(dtype,mean_usage_mb))</code> </pre> <br>  Como resultado, verifica-se que os indicadores m√©dios de uso de mem√≥ria para dados de diferentes tipos s√£o assim: <br><br><pre> <code class="plaintext hljs">Average memory usage for float columns: 1.29 MB Average memory usage for int columns: 1.12 MB Average memory usage for object columns: 9.53 MB</code> </pre> <br>  Essas informa√ß√µes nos fazem entender que a maior parte da mem√≥ria √© gasta em 78 colunas armazenando valores de objetos.  Falaremos mais sobre isso mais tarde, mas agora vamos pensar se podemos melhorar o uso de mem√≥ria com colunas que armazenam dados num√©ricos. <br><br><h2>  <font color="#3AC1EF">Subtipos</font> </h2><br>  Como j√° dissemos, os pandas representam valores num√©ricos como estruturas de dados <code>ndarray</code> NumPy e os armazenam em blocos cont√≠guos de mem√≥ria.  Esse modelo de armazenamento de dados permite economizar mem√≥ria e acessar rapidamente valores.  Como os pandas representam cada valor do mesmo tipo usando o mesmo n√∫mero de bytes, e <code>ndarray</code> estruturas <code>ndarray</code> armazenam informa√ß√µes sobre o n√∫mero de valores, os pandas podem <code>ndarray</code> r√°pida e com precis√£o a quantidade de mem√≥ria consumida por colunas que armazenam valores num√©ricos. <br><br>  Muitos tipos de dados nos pandas t√™m muitos subtipos que podem usar menos bytes para representar cada valor.  Por exemplo, o tipo <code>float</code> possui os subtipos <code>float16</code> , <code>float64</code> e <code>float64</code> .  O n√∫mero no nome do tipo indica o n√∫mero de bits que o subtipo usa para representar os valores.  Por exemplo, nos subtipos listados abaixo, 2, 4, 8 e 16 bytes s√£o usados ‚Äã‚Äãrespectivamente para armazenamento de dados.  A tabela a seguir mostra os subtipos dos tipos de dados mais usados ‚Äã‚Äãnos pandas. <br><table><tbody><tr><td>  <sup>Uso de mem√≥ria, bytes</sup> <sup><br></sup> </td><td>  <sup>N√∫mero do ponto flutuante</sup> <sup><br></sup> </td><td>  <sup>Inteiro</sup> <sup><br></sup> </td><td>  <sup>Inteiro n√£o assinado</sup> <sup><br></sup> </td><td>  <sup>Data e hora</sup> <sup><br></sup> </td><td>  <sup>Valor booleano</sup> <sup><br></sup> </td><td width="75">  <sup>Object</sup> <sup><br></sup> </td></tr><tr><td>  <sup>1</sup> <sup><br></sup> </td><td></td><td>  <sup>int8</sup> <sup><br></sup> </td><td>  <sup>uint8</sup> <sup><br></sup> </td><td></td><td>  <sup>bool</sup> <sup><br></sup> </td><td></td></tr><tr><td>  <sup>2</sup> <sup><br></sup> </td><td>  <sup>float16</sup> <sup><br></sup> </td><td>  <sup>int16</sup> <sup><br></sup> </td><td>  <sup>uint16</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>4</sup> <sup><br></sup> </td><td>  <sup>float32</sup> <sup><br></sup> </td><td>  <sup>int32</sup> <sup><br></sup> </td><td>  <sup>uint32</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>8</sup> <sup><br></sup> </td><td>  <sup>float64</sup> <sup><br></sup> </td><td>  <sup>int64</sup> <sup><br></sup> </td><td>  <sup>uint64</sup> <sup><br></sup> </td><td>  <sup>datetime64</sup> <sup><br></sup> </td><td></td><td></td></tr><tr><td>  <sup>Capacidade de mem√≥ria vari√°vel</sup> <sup><br></sup> </td><td></td><td></td><td></td><td></td><td></td><td>  <sup>objeto</sup> <sup><br></sup> </td></tr></tbody></table><br>  Um valor do tipo <code>int8</code> usa 1 byte (8 bits) para armazenar um n√∫mero e pode representar 256 valores bin√°rios (pot√™ncia de 2 a 8).  Isso significa que esse subtipo pode ser usado para armazenar valores no intervalo de -128 a 127 (incluindo 0). <br><br>  Para verificar os valores m√≠nimo e m√°ximo adequados para armazenamento usando cada subtipo de n√∫mero inteiro, voc√™ pode usar o m√©todo <code>numpy.iinfo()</code> .  Considere um exemplo: <br><br><pre> <code class="plaintext hljs">import numpy as np int_types = ["uint8", "int8", "int16"] for it in int_types:   print(np.iinfo(it))</code> </pre> <br>  Ao executar esse c√≥digo, obtemos os seguintes dados: <br><br><pre> <code class="plaintext hljs">Machine parameters for uint8 --------------------------------------------------------------- min = 0 max = 255 --------------------------------------------------------------- Machine parameters for int8 --------------------------------------------------------------- min = -128 max = 127 --------------------------------------------------------------- Machine parameters for int16 --------------------------------------------------------------- min = -32768 max = 32767 ---------------------------------------------------------------</code> </pre> <br>  Aqui voc√™ pode prestar aten√ß√£o √† diferen√ßa entre os tipos <code>uint</code> (n√∫mero inteiro n√£o assinado) e <code>int</code> (n√∫mero inteiro assinado).  Ambos os tipos t√™m a mesma capacidade, mas, ao armazenar apenas valores positivos em colunas, os tipos n√£o assinados permitem um uso mais eficiente da mem√≥ria. <br><br><h2>  <font color="#3AC1EF">Otimiza√ß√£o do armazenamento de dados num√©ricos usando subtipos</font> </h2><br>  A fun√ß√£o <code>pd.to_numeric()</code> pode ser usada para converter tipos num√©ricos de forma descendente.  Para selecionar colunas inteiras, usamos o m√©todo <code>DataFrame.select_dtypes()</code> , depois as otimizamos e comparamos o uso de mem√≥ria antes e depois da otimiza√ß√£o. <br><br><pre> <code class="plaintext hljs">#     ,   , #   ,      . def mem_usage(pandas_obj):   if isinstance(pandas_obj,pd.DataFrame):       usage_b = pandas_obj.memory_usage(deep=True).sum()   else: #     ,     DataFrame,   Series       usage_b = pandas_obj.memory_usage(deep=True)   usage_mb = usage_b / 1024 ** 2 #       return "{:03.2f} MB".format(usage_mb) gl_int = gl.select_dtypes(include=['int']) converted_int = gl_int.apply(pd.to_numeric,downcast='unsigned') print(mem_usage(gl_int)) print(mem_usage(converted_int)) compare_ints = pd.concat([gl_int.dtypes,converted_int.dtypes],axis=1) compare_ints.columns = ['before','after'] compare_ints.apply(pd.Series.value_counts)</code> </pre> <br>  Aqui est√° o resultado de um estudo do consumo de mem√≥ria: <br><br> <code>7.87 MB <br> 1.48 MB</code> <br> <table><tbody><tr><td></td><td>  Para <br></td><td>  Depois <br></td></tr><tr><td>  uint8 <br></td><td>  NaN <br></td><td>  5.0 <br></td></tr><tr><td>  uint32 <br></td><td>  NaN <br></td><td>  1.0 <br></td></tr><tr><td>  int64 <br></td><td>  6.0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Como resultado, voc√™ pode observar uma queda no uso de mem√≥ria de 7,9 para 1,5 megabytes, ou seja, reduzimos o consumo de mem√≥ria em mais de 80%.  O impacto geral dessa otimiza√ß√£o no <code>DataFrame</code> original, no entanto, n√£o √© particularmente forte, pois possui muito poucas colunas inteiras. <br><br>  Vamos fazer o mesmo com colunas contendo n√∫meros de ponto flutuante. <br><br><pre> <code class="plaintext hljs">gl_float = gl.select_dtypes(include=['float']) converted_float = gl_float.apply(pd.to_numeric,downcast='float') print(mem_usage(gl_float)) print(mem_usage(converted_float)) compare_floats = pd.concat([gl_float.dtypes,converted_float.dtypes],axis=1) compare_floats.columns = ['before','after'] compare_floats.apply(pd.Series.value_counts)</code> </pre> <br>  O resultado √© o seguinte: <br><br> <code>100.99 MB <br> 50.49 MB</code> <br> <table><tbody><tr><td></td><td>  Para <br></td><td>  Depois <br></td></tr><tr><td>  float32 <br></td><td>  NaN <br></td><td>  77,0 <br></td></tr><tr><td>  float64 <br></td><td>  77,0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Como resultado, todas as colunas que armazenavam n√∫meros de ponto flutuante com o tipo de dados <code>float64</code> agora armazenam n√∫meros do tipo <code>float32</code> , o que nos deu uma redu√ß√£o de 50% no uso de mem√≥ria. <br><br>  Crie uma c√≥pia do <code>DataFrame</code> original, use essas colunas num√©ricas otimizadas em vez daquelas que estavam originalmente presentes nela e observe o uso geral da mem√≥ria ap√≥s a otimiza√ß√£o. <br><br><pre> <code class="plaintext hljs">optimized_gl = gl.copy() optimized_gl[converted_int.columns] = converted_int optimized_gl[converted_float.columns] = converted_float print(mem_usage(gl)) print(mem_usage(optimized_gl))</code> </pre> <br>  Aqui est√° o que temos: <br><br> <code>861.57 MB <br> 804.69 MB</code> <br> <br>  Embora <code>DataFrame</code> significativamente o consumo de mem√≥ria por colunas que armazenam dados num√©ricos, em geral, em todo o <code>DataFrame</code> , o consumo de mem√≥ria diminuiu apenas 7%.  A otimiza√ß√£o do armazenamento de tipos de objetos pode se tornar uma fonte de melhoria muito mais s√©ria de uma situa√ß√£o. <br><br>  Antes de fazermos essa otimiza√ß√£o, veremos mais de perto como as strings s√£o armazenadas nos pandas e comparamos com a maneira como os n√∫meros s√£o armazenados aqui. <br><br><h2>  <font color="#3AC1EF">Compara√ß√£o de mecanismos para armazenar n√∫meros e seq√º√™ncias de caracteres</font> </h2><br>  O tipo de <code>object</code> representa valores usando objetos de seq√º√™ncia de caracteres Python.  Isso ocorre em parte porque o NumPy n√£o suporta a representa√ß√£o de valores de string ausentes.  Como o Python √© uma linguagem interpretada de alto n√≠vel, ele n√£o fornece ao programador ferramentas para ajustar como os dados s√£o armazenados na mem√≥ria. <br><br>  Essa limita√ß√£o leva ao fato de que as seq√º√™ncias de caracteres n√£o s√£o armazenadas em fragmentos cont√≠guos da mem√≥ria; sua representa√ß√£o na mem√≥ria √© fragmentada.  Isso leva a um aumento no consumo de mem√≥ria e a uma desacelera√ß√£o na velocidade de trabalho com valores de sequ√™ncia.  Cada elemento da coluna que armazena o tipo de dados do objeto, de fato, √© um ponteiro que cont√©m o "endere√ßo" no qual o valor real est√° localizado na mem√≥ria. <br><br>  A seguir, √© apresentado um diagrama baseado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste</a> material que compara o armazenamento de dados num√©ricos usando os tipos de dados NumPy e o armazenamento de strings usando os tipos de dados internos do Python. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/66f/54b/d8066f54b091531c120b94c90f698236.png"></div><br>  <i><font color="#999999">Armazenando dados num√©ricos e de sequ√™ncia</font></i> <br><br>  Aqui voc√™ pode lembrar que, em uma das tabelas acima, foi mostrado que uma quantidade vari√°vel de mem√≥ria √© usada para armazenar dados de tipos de objetos.  Embora cada ponteiro ocupe 1 byte de mem√≥ria, cada valor espec√≠fico da string ocupa a mesma quantidade de mem√≥ria que seria usada para armazenar uma √∫nica string no Python.  Para confirmar isso, usaremos o m√©todo <code>sys.getsizeof()</code> .  Primeiro, d√™ uma olhada nas linhas individuais e, em seguida, no objeto pandas da <code>Series</code> que armazena os dados da string. <br><br>  Ent√£o, primeiro examinamos as linhas usuais: <br><br><pre> <code class="plaintext hljs">from sys import getsizeof s1 = 'working out' s2 = 'memory usage for' s3 = 'strings in python is fun!' s4 = 'strings in python is fun!' for s in [s1, s2, s3, s4]:   print(getsizeof(s))</code> </pre> <br>  Aqui, os dados de uso da mem√≥ria s√£o assim: <br><br> <code>60 <br> 65 <br> 74 <br> 74</code> <br> <br>  Agora vamos ver como √© o uso de strings no objeto <code>Series</code> : <br><br><pre> <code class="plaintext hljs">obj_series = pd.Series(['working out',                         'memory usage for',                         'strings in python is fun!',                         'strings in python is fun!']) obj_series.apply(getsizeof)</code> </pre> <br>  Aqui temos o seguinte: <br><br><pre> <code class="plaintext hljs">0    60 1    65 2    74 3    74 dtype: int64</code> </pre> <br>  Aqui voc√™ pode ver que os tamanhos das linhas armazenadas nos objetos pandas da <code>Series</code> s√£o semelhantes aos seus tamanhos ao trabalhar com eles no Python e ao represent√°-los como entidades separadas. <br><br><h2>  <font color="#3AC1EF">Otimiza√ß√£o do armazenamento de dados de tipo de objeto usando vari√°veis ‚Äã‚Äãcateg√≥ricas</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vari√°veis ‚Äã‚Äãcateg√≥ricas</a> apareceram no pandas vers√£o 0.15.  O tipo correspondente, <code>category</code> , usa valores inteiros em seus mecanismos internos, em vez dos valores originais armazenados nas colunas da tabela.  O Pandas usa um dicion√°rio separado que define a correspond√™ncia dos valores inteiro e inicial.  Essa abordagem √© √∫til quando as colunas cont√™m valores de um conjunto limitado.  Quando os dados armazenados em uma coluna s√£o convertidos para o tipo de <code>category</code> , o pandas usa o subtipo <code>int</code> , que permite o uso mais eficiente da mem√≥ria e √© capaz de representar todos os valores exclusivos encontrados na coluna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f5/48d/59c/1f548d59c9b41fd906d038c19d3a2da2.png"></div><br>  <i><font color="#999999">Dados de origem e dados categ√≥ricos usando o subtipo int8</font></i> <br><br>  Para entender exatamente onde podemos usar dados categ√≥ricos para reduzir o consumo de mem√≥ria, descobrimos o n√∫mero de valores exclusivos nas colunas que armazenam os valores dos tipos de objeto: <br><br><pre> <code class="plaintext hljs">gl_obj = gl.select_dtypes(include=['object']).copy() gl_obj.describe()</code> </pre> <br>  Voc√™ pode encontrar o que temos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta</a> tabela, na folha <code>    </code> . <br><br>  Por exemplo, na coluna <code>day_of_week</code> , que √© o dia da semana em que o jogo foi disputado, existem valores 171907.  Entre eles, apenas 7 s√£o √∫nicos.  No geral, uma simples olhada neste relat√≥rio √© suficiente para entender que alguns valores √∫nicos s√£o usados ‚Äã‚Äãem muitas colunas para representar os dados de aproximadamente 172.000 jogos. <br><br>  Antes de fazermos a otimiza√ß√£o em escala real, vamos selecionar uma coluna que armazena dados do objeto, pelo menos <code>day_of_week</code> , e ver o que acontece no programa quando ele √© convertido em um tipo categ√≥rico. <br><br>  Como j√° mencionado, esta coluna cont√©m apenas 7 valores exclusivos.  Para convert√™-lo em um tipo categ√≥rico, usamos o m√©todo <code>.astype()</code> . <br><br><pre> <code class="plaintext hljs">dow = gl_obj.day_of_week print(dow.head()) dow_cat = dow.astype('category') print(dow_cat.head())</code> </pre> <br>  Aqui est√° o que temos: <br><br><pre> <code class="plaintext hljs">0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: object 0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: category Categories (7, object): [Fri, Mon, Sat, Sun, Thu, Tue, Wed]</code> </pre> <br>  Como voc√™ pode ver, embora o tipo da coluna tenha sido alterado, os dados armazenados nela parecem os mesmos de antes.  Agora vamos ver o que est√° acontecendo dentro do programa. <br><br>  No c√≥digo a seguir, usamos o atributo <code>Series.cat.codes</code> para descobrir quais valores inteiros o tipo de <code>category</code> usa para representar cada dia da semana: <br><br><pre> <code class="plaintext hljs">dow_cat.head().cat.codes</code> </pre> <br>  Conseguimos descobrir o seguinte: <br><br><pre> <code class="plaintext hljs">0    4 1    0 2    2 3    1 4    5 dtype: int8</code> </pre> <br>  Aqui voc√™ pode ver que cada valor exclusivo recebe um valor inteiro e que a coluna agora √© do tipo <code>int8</code> .  N√£o h√° valores ausentes, mas se fosse esse o caso, -1 seria usado para indicar esses valores. <br><br>  Agora vamos comparar o consumo de mem√≥ria antes e depois de converter a coluna <code>day_of_week</code> no tipo de <code>category</code> . <br><br><pre> <code class="plaintext hljs">print(mem_usage(dow)) print(mem_usage(dow_cat))</code> </pre> <br>  Aqui est√° o resultado: <br><br> <code>9.84 MB <br> 0.16 MB</code> <br> <br>  Como voc√™ pode ver, foram consumidos inicialmente 9,84 megabytes de mem√≥ria e, ap√≥s a otimiza√ß√£o, apenas 0,16 megabytes, o que significa uma melhoria de 98% nesse indicador.  Observe que o trabalho com esta coluna provavelmente demonstra um dos cen√°rios de otimiza√ß√£o mais lucrativos quando apenas 7 valores exclusivos s√£o usados ‚Äã‚Äãem uma coluna contendo aproximadamente 172.000 elementos. <br><br>  Embora a id√©ia de converter todas as colunas para esse tipo de dados pare√ßa atraente, antes de fazer isso, considere os efeitos colaterais negativos dessa convers√£o.  Portanto, o ponto mais negativo dessa transforma√ß√£o √© a impossibilidade de executar opera√ß√µes aritm√©ticas em dados categ√≥ricos.  Isso tamb√©m se aplica a opera√ß√µes aritm√©ticas comuns e ao uso de m√©todos como <code>Series.min()</code> e <code>Series.max()</code> sem primeiro converter os dados em um tipo de n√∫mero real. <br><br>  Devemos limitar o uso do tipo de <code>category</code> a principalmente colunas que armazenam dados do tipo de <code>object</code> , nos quais menos de 50% dos valores s√£o √∫nicos.  Se todos os valores em uma coluna forem exclusivos, o uso do tipo de <code>category</code> aumentar√° o n√≠vel de uso da mem√≥ria.  Isso se deve ao fato de que na mem√≥ria voc√™ precisa armazenar, al√©m dos c√≥digos de categoria num√©ricos, os valores originais da string.  Detalhes sobre restri√ß√µes de tipo de <code>category</code> podem ser encontrados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> do pandas. <br><br>  Vamos criar um loop que itere sobre todas as colunas que armazenam dados do tipo de <code>object</code> , descobre se o n√∫mero de valores exclusivos nas colunas excede 50% e, nesse caso, os converte na <code>category</code> tipo. <br><br><pre> <code class="plaintext hljs">converted_obj = pd.DataFrame() for col in gl_obj.columns:   num_unique_values = len(gl_obj[col].unique())   num_total_values = len(gl_obj[col])   if num_unique_values / num_total_values &lt; 0.5:       converted_obj.loc[:,col] = gl_obj[col].astype('category')   else:       converted_obj.loc[:,col] = gl_obj[col]</code> </pre> <br>  Agora compare o que aconteceu ap√≥s a otimiza√ß√£o com o que aconteceu antes: <br><br><pre> <code class="plaintext hljs">print(mem_usage(gl_obj)) print(mem_usage(converted_obj)) compare_obj = pd.concat([gl_obj.dtypes,converted_obj.dtypes],axis=1) compare_obj.columns = ['before','after'] compare_obj.apply(pd.Series.value_counts)</code> </pre> <br>  Temos o seguinte: <br><br> <code>752.72 MB <br> 51.67 MB</code> <br> <table><tbody><tr><td></td><td>  Para <br></td><td>  Depois <br></td></tr><tr><td>  objeto <br></td><td>  78,0 <br></td><td>  NaN <br></td></tr><tr><td>  categoria <br></td><td>  NaN <br></td><td>  78,0 <br></td></tr></tbody></table><br>           <code>category</code> ,     ,          , ,      ,     ,    ,  ,     . <br><br>  ,  ,     ,    <code>object</code> ,   752   52 ,    93%.     ,          .  ,       ,   ,  ,     891 . <br><br><pre> <code class="plaintext hljs">optimized_gl[converted_obj.columns] = converted_obj mem_usage(optimized_gl)</code> </pre> <br>     : <br><br> <code>'103.64 MB'</code> <br> <br>  .     - .    ,       <code>datetime</code> , ,  ,        . <br><br><pre> <code class="plaintext hljs">date = optimized_gl.date print(mem_usage(date)) date.head()</code> </pre> <br>       : <br><br> <code>0.66 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0    18710504 1    18710505 2    18710506 3    18710508 4    18710509 Name: date, dtype: uint32</code> </pre> <br>  ,               <code>uint32</code> . -       <code>datetime</code>     ,         64 .       <code>datetime</code> ,  ,  ,          . <br><br>      <code>to_datetime()</code> ,  <code>format</code>    ,      <code>YYYY-MM-DD</code> . <br><br><pre> <code class="plaintext hljs">optimized_gl['date'] = pd.to_datetime(date,format='%Y%m%d') print(mem_usage(optimized_gl)) optimized_gl.date.head()</code> </pre> <br>    : <br><br> <code>104.29 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0   1871-05-04 1   1871-05-05 2   1871-05-06 3   1871-05-08 4   1871-05-09 Name: date, dtype: datetime64[ns]</code> </pre> <br><h2> <font color="#3AC1EF">    </font> </h2><br>            <code>DataFrame</code> .        , , ,   ,  ,  ,  ,  .       ,        .    ,     ,     ,     .        ,        ,      <code>DataFrame</code> ,   . <br><br>  ,             .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pandas.read_csv()</a>   ,   . ,  <code>dtype</code>  ,   ,   ,   ,     ‚Äî  NumPy. <br><br>      ,          ,   .         ,      . <br><br><pre> <code class="plaintext hljs">dtypes = optimized_gl.drop('date',axis=1).dtypes dtypes_col = dtypes.index dtypes_type = [i.name for i in dtypes.values] column_types = dict(zip(dtypes_col, dtypes_type)) #    161 ,  #  10  /   #     preview = first2pairs = {key:value for key,value in list(column_types.items())[:10]} import pprint pp = pp = pprint.PrettyPrinter(indent=4) pp.pprint(preview)     : {   'acquisition_info': 'category',   'h_caught_stealing': 'float32',   'h_player_1_name': 'category',   'h_player_9_name': 'category',   'v_assists': 'float32',   'v_first_catcher_interference': 'float32',   'v_grounded_into_double': 'float32',   'v_player_1_id': 'category',   'v_player_3_id': 'category',   'v_player_5_id': 'category'}</code> </pre> <br>          ,      ,    . <br><br>    - : <br><br><pre> <code class="plaintext hljs">read_and_optimized = pd.read_csv('game_logs.csv',dtype=column_types,parse_dates=['date'],infer_datetime_format=True) print(mem_usage(read_and_optimized)) read_and_optimized.head()</code> </pre> <br>       : <br><br> <code>104.28 MB</code> <br> <br>    ,     <code>   </code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br>  ,    <code>   </code>  <code>   </code> ,     ,  ,       .      pandas       861.6   104.28 ,     88% . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br> ,  ,    ,     .     . <br><br><pre> <code class="plaintext hljs">optimized_gl['year'] = optimized_gl.date.dt.year games_per_day = optimized_gl.pivot_table(index='year',columns='day_of_week',values='date',aggfunc=len) games_per_day = games_per_day.divide(games_per_day.sum(axis=1),axis=0) ax = games_per_day.plot(kind='area',stacked='true') ax.legend(loc='upper right') ax.set_ylim(0,1) plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b2/699/6a2/3b26996a26b73e9a3ce87f3ff22dcf34.png"></div><br> <i><font color="#999999">,    </font></i> <br><br>  ,  1920-      ,  ,    50 ,        . <br><br>  ,  ,    ,      50 ,   . <br><br>    ,      . <br><br><pre> <code class="plaintext hljs">game_lengths = optimized_gl.pivot_table(index='year', values='length_minutes') game_lengths.reset_index().plot.scatter('year','length_minutes') plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6d/6db/5d2/a6d6db5d2e6bdb7330ac8a0ff2a6febd.png"></div><br> <i><font color="#999999"> </font></i> <br><br>   ,   1940-         . <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>            pandas,         ,     <code>DataFrame</code> ,   90%.       : <br><br><ul><li>       ,   ,   ,    , . </li><li>        . </li></ul><br>  ,            , ,         ,    ,  ,       pandas,    ,    . <br><br>  <b>Caros leitores!</b>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">eugene_bb</a> .    -  ,    ‚Äî    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442516/">https://habr.com/ru/post/pt442516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442504/index.html">Proxy PHP Xdebug: quando os recursos padr√£o do Xdebug n√£o s√£o suficientes</a></li>
<li><a href="../pt442506/index.html">A R√∫ssia √© punida pelo com√©rcio ilegal de dados pessoais?</a></li>
<li><a href="../pt442508/index.html">Como o udalenka acelera a inova√ß√£o no GitLab</a></li>
<li><a href="../pt442512/index.html">Customiza√ß√£o do Django ORM no exemplo do ZomboDB</a></li>
<li><a href="../pt442514/index.html">Sistemas distribu√≠dos. Padr√µes de design. Resenha</a></li>
<li><a href="../pt442518/index.html">As 10 melhores t√©cnicas de hackers na Web em 2018</a></li>
<li><a href="../pt442520/index.html">Case. Economizando 300 000 p. por m√™s em publicidade contextual</a></li>
<li><a href="../pt442522/index.html">RL Intuitivo (Aprendizagem por Refor√ßo): Introdu√ß√£o ao Crit√©rio de Atores de Vantagem (A2C)</a></li>
<li><a href="../pt442524/index.html">Como aumentar a seguran√ßa nos sistemas de identifica√ß√£o pessoal e controle de acesso</a></li>
<li><a href="../pt442526/index.html">A hist√≥ria dos toca-fitas sovi√©ticos (parte dois): o boom do Walkmen, um gadget para a KGB e gravadores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>