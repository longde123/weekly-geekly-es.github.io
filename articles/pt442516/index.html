<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎓 🤹🏾 🧑🏿‍🤝‍🧑🏽 Guia do Pandas para análise de big data 🧔🏽 🧘🏾 📢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao usar a biblioteca do pandas para analisar pequenos conjuntos de dados, cujo tamanho não excede 100 megabytes, o desempenho raramente se torna um pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia do Pandas para análise de big data</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442516/"> Ao usar a biblioteca do pandas para analisar pequenos conjuntos de dados, cujo tamanho não excede 100 megabytes, o desempenho raramente se torna um problema.  Mas quando se trata do estudo de conjuntos de dados, cujos tamanhos podem atingir vários gigabytes, problemas de desempenho podem levar a um aumento significativo na duração da análise de dados e até a incapacidade de realizar análises devido à falta de memória. <br><br>  Embora ferramentas como o Spark possam processar com eficiência grandes conjuntos de dados (de centenas de gigabytes a vários terabytes), para utilizar totalmente seus recursos, você geralmente precisa de um hardware bastante poderoso e caro.  E, em comparação com os pandas, eles não diferem em ricos conjuntos de ferramentas para limpeza, pesquisa e análise de dados de alta qualidade.  Para conjuntos de dados de tamanho médio, é melhor tentar usar pandas com mais eficiência, em vez de mudar para outras ferramentas. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/gd/jg/60/gdjg60abxgti2otxocpd0ct2uci.jpeg"></a> <br><br>  No material, cuja tradução publicamos hoje, falaremos sobre as peculiaridades de trabalhar com memória ao usar pandas e como reduzir o consumo de memória em quase 90%, selecionando os tipos de dados apropriados armazenados nas colunas das estruturas de dados da tabela do <code>DataFrame</code> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Trabalhando com dados em jogos de beisebol</font> </h2><br>  Trabalharemos com dados dos jogos de beisebol da Major League coletados ao longo de 130 anos e retirados do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Retrosheet</a> . <br><br>  Inicialmente, esses dados foram apresentados como 127 arquivos CSV, mas os combinamos em um conjunto de dados usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">csvkit</a> e adicionamos, como a primeira linha da tabela resultante, uma linha com nomes de colunas.  Se desejar, você pode fazer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o</a> download da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nossa versão</a> desses dados e experimentá-los, lendo o artigo. <br><br>  Vamos começar importando um conjunto de dados e dando uma olhada nas cinco primeiras linhas.  Você pode encontrá-los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta</a> tabela, no <code>   </code> folha do <code>   </code> . <br><br><pre> <code class="plaintext hljs">import pandas as pd gl = pd.read_csv('game_logs.csv') gl.head()</code> </pre> <br>  Abaixo estão as informações sobre as colunas mais importantes da tabela com esses dados.  Se você quiser ler as explicações para todas as colunas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> pode encontrar um dicionário de dados para todo o conjunto de dados. <br><br><ul><li>  <code>date</code> - data do jogo. </li><li>  <code>v_name</code> - O nome da equipe convidada. </li><li>  <code>v_league</code> - Liga da equipe visitante. </li><li>  <code>h_name</code> - O nome do time da casa. </li><li>  <code>h_league</code> - A liga dos times da casa. </li><li>  <code>v_score</code> - Pontos da equipe visitante. </li><li>  <code>h_score</code> - Pontos da equipe da casa. </li><li>  <code>v_line_score</code> - Um resumo dos pontos da equipe de convidados, por exemplo - <code>010000(10)00</code> . </li><li>  <code>h_line_score</code> - Um resumo dos pontos da equipe da casa, por exemplo - <code>010000(10)0X</code> . </li><li>  <code>park_id</code> - O identificador do campo em que o jogo foi jogado. </li><li>  <code>attendance</code> - O número de espectadores. </li></ul><br>  Para descobrir informações gerais sobre o objeto <code>DataFrame</code> , você pode usar o método <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DataFrame.info ()</a> .  Graças a esse método, você pode aprender sobre o tamanho de um objeto, sobre tipos de dados e sobre o uso de memória. <br><br>  Por padrão, os pandas, por uma questão de economia de tempo, <code>DataFrame</code> informações aproximadas sobre o uso de memória pelo <code>DataFrame</code> .  Como estamos interessados ​​em informações precisas, definiremos o parâmetro <code>memory_usage</code> como <code>'deep'</code> . <br><br><pre> <code class="plaintext hljs">gl.info(memory_usage='deep')</code> </pre> <br>  Aqui estão as informações que conseguimos obter: <br><br><pre> <code class="plaintext hljs">&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 171907 entries, 0 to 171906 Columns: 161 entries, date to acquisition_info dtypes: float64(77), int64(6), object(78) memory usage: 861.6 MB</code> </pre> <br>  Como se viu, temos 171.907 linhas e 161 colunas.  A biblioteca do pandas detectou automaticamente os tipos de dados.  Existem 83 colunas com dados numéricos e 78 colunas com objetos.  As colunas de objeto são usadas para armazenar dados de sequência e nos casos em que a coluna contém dados de tipos diferentes. <br><br>  Agora, para entender melhor como você pode otimizar o uso da memória com este <code>DataFrame</code> , vamos falar sobre como o pandas armazena dados na memória. <br><br><h2>  <font color="#3AC1EF">Visualização interna de um DataFrame</font> </h2><br>  Dentro dos pandas, as colunas de dados são agrupadas em blocos com valores do mesmo tipo.  Aqui está um exemplo de como as 12 primeiras colunas de um <code>DataFrame</code> são armazenadas em pandas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c70/c63/d35c70c635289a5cecc520c58e662e9a.png"></div><br>  <i><font color="#999999">Representação interna de diferentes tipos de dados em pandas</font></i> <br><br>  Você pode perceber que os blocos não armazenam informações sobre o nome da coluna.  Isso ocorre porque os blocos são otimizados para armazenar os valores disponíveis nas células da tabela do objeto <code>DataFrame</code> .  A classe <code>BlockManager</code> é responsável por armazenar informações sobre a correspondência entre os índices de linha e coluna do conjunto de dados e o que é armazenado em blocos do mesmo tipo de dados.  Ele desempenha o papel de uma API que fornece acesso a dados básicos.  Quando lemos, editamos ou <code>DataFrame</code> valores, a classe <code>DataFrame</code> interage com a classe <code>BlockManager</code> para converter nossos pedidos em chamadas de função e método. <br><br>  Cada tipo de dados possui uma classe especializada no módulo <code>pandas.core.internals</code> .  Por exemplo, o pandas usa a classe <code>ObjectBlock</code> para representar blocos que contêm colunas de string e a classe <code>FloatBlock</code> para representar blocos que contêm colunas que <code>FloatBlock</code> números de ponto flutuante.  Para blocos que representam valores numéricos que se parecem com números inteiros ou números de ponto flutuante, o pandas combina as colunas e as armazena como a <code>ndarray</code> dados <code>ndarray</code> biblioteca NumPy.  Essa estrutura de dados é baseada na matriz C, os valores são armazenados em um bloco contínuo de memória.  Graças a esse esquema de armazenamento de dados, o acesso aos fragmentos de dados é muito rápido. <br><br>  Como dados de tipos diferentes são armazenados separadamente, examinamos o uso de memória de diferentes tipos de dados.  Vamos começar com o uso médio de memória para diferentes tipos de dados. <br><br><pre> <code class="plaintext hljs">for dtype in ['float','int','object']:   selected_dtype = gl.select_dtypes(include=[dtype])   mean_usage_b = selected_dtype.memory_usage(deep=True).mean()   mean_usage_mb = mean_usage_b / 1024 ** 2   print("Average memory usage for {} columns: {:03.2f} MB".format(dtype,mean_usage_mb))</code> </pre> <br>  Como resultado, verifica-se que os indicadores médios de uso de memória para dados de diferentes tipos são assim: <br><br><pre> <code class="plaintext hljs">Average memory usage for float columns: 1.29 MB Average memory usage for int columns: 1.12 MB Average memory usage for object columns: 9.53 MB</code> </pre> <br>  Essas informações nos fazem entender que a maior parte da memória é gasta em 78 colunas armazenando valores de objetos.  Falaremos mais sobre isso mais tarde, mas agora vamos pensar se podemos melhorar o uso de memória com colunas que armazenam dados numéricos. <br><br><h2>  <font color="#3AC1EF">Subtipos</font> </h2><br>  Como já dissemos, os pandas representam valores numéricos como estruturas de dados <code>ndarray</code> NumPy e os armazenam em blocos contíguos de memória.  Esse modelo de armazenamento de dados permite economizar memória e acessar rapidamente valores.  Como os pandas representam cada valor do mesmo tipo usando o mesmo número de bytes, e <code>ndarray</code> estruturas <code>ndarray</code> armazenam informações sobre o número de valores, os pandas podem <code>ndarray</code> rápida e com precisão a quantidade de memória consumida por colunas que armazenam valores numéricos. <br><br>  Muitos tipos de dados nos pandas têm muitos subtipos que podem usar menos bytes para representar cada valor.  Por exemplo, o tipo <code>float</code> possui os subtipos <code>float16</code> , <code>float64</code> e <code>float64</code> .  O número no nome do tipo indica o número de bits que o subtipo usa para representar os valores.  Por exemplo, nos subtipos listados abaixo, 2, 4, 8 e 16 bytes são usados ​​respectivamente para armazenamento de dados.  A tabela a seguir mostra os subtipos dos tipos de dados mais usados ​​nos pandas. <br><table><tbody><tr><td>  <sup>Uso de memória, bytes</sup> <sup><br></sup> </td><td>  <sup>Número do ponto flutuante</sup> <sup><br></sup> </td><td>  <sup>Inteiro</sup> <sup><br></sup> </td><td>  <sup>Inteiro não assinado</sup> <sup><br></sup> </td><td>  <sup>Data e hora</sup> <sup><br></sup> </td><td>  <sup>Valor booleano</sup> <sup><br></sup> </td><td width="75">  <sup>Object</sup> <sup><br></sup> </td></tr><tr><td>  <sup>1</sup> <sup><br></sup> </td><td></td><td>  <sup>int8</sup> <sup><br></sup> </td><td>  <sup>uint8</sup> <sup><br></sup> </td><td></td><td>  <sup>bool</sup> <sup><br></sup> </td><td></td></tr><tr><td>  <sup>2</sup> <sup><br></sup> </td><td>  <sup>float16</sup> <sup><br></sup> </td><td>  <sup>int16</sup> <sup><br></sup> </td><td>  <sup>uint16</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>4</sup> <sup><br></sup> </td><td>  <sup>float32</sup> <sup><br></sup> </td><td>  <sup>int32</sup> <sup><br></sup> </td><td>  <sup>uint32</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>8</sup> <sup><br></sup> </td><td>  <sup>float64</sup> <sup><br></sup> </td><td>  <sup>int64</sup> <sup><br></sup> </td><td>  <sup>uint64</sup> <sup><br></sup> </td><td>  <sup>datetime64</sup> <sup><br></sup> </td><td></td><td></td></tr><tr><td>  <sup>Capacidade de memória variável</sup> <sup><br></sup> </td><td></td><td></td><td></td><td></td><td></td><td>  <sup>objeto</sup> <sup><br></sup> </td></tr></tbody></table><br>  Um valor do tipo <code>int8</code> usa 1 byte (8 bits) para armazenar um número e pode representar 256 valores binários (potência de 2 a 8).  Isso significa que esse subtipo pode ser usado para armazenar valores no intervalo de -128 a 127 (incluindo 0). <br><br>  Para verificar os valores mínimo e máximo adequados para armazenamento usando cada subtipo de número inteiro, você pode usar o método <code>numpy.iinfo()</code> .  Considere um exemplo: <br><br><pre> <code class="plaintext hljs">import numpy as np int_types = ["uint8", "int8", "int16"] for it in int_types:   print(np.iinfo(it))</code> </pre> <br>  Ao executar esse código, obtemos os seguintes dados: <br><br><pre> <code class="plaintext hljs">Machine parameters for uint8 --------------------------------------------------------------- min = 0 max = 255 --------------------------------------------------------------- Machine parameters for int8 --------------------------------------------------------------- min = -128 max = 127 --------------------------------------------------------------- Machine parameters for int16 --------------------------------------------------------------- min = -32768 max = 32767 ---------------------------------------------------------------</code> </pre> <br>  Aqui você pode prestar atenção à diferença entre os tipos <code>uint</code> (número inteiro não assinado) e <code>int</code> (número inteiro assinado).  Ambos os tipos têm a mesma capacidade, mas, ao armazenar apenas valores positivos em colunas, os tipos não assinados permitem um uso mais eficiente da memória. <br><br><h2>  <font color="#3AC1EF">Otimização do armazenamento de dados numéricos usando subtipos</font> </h2><br>  A função <code>pd.to_numeric()</code> pode ser usada para converter tipos numéricos de forma descendente.  Para selecionar colunas inteiras, usamos o método <code>DataFrame.select_dtypes()</code> , depois as otimizamos e comparamos o uso de memória antes e depois da otimização. <br><br><pre> <code class="plaintext hljs">#     ,   , #   ,      . def mem_usage(pandas_obj):   if isinstance(pandas_obj,pd.DataFrame):       usage_b = pandas_obj.memory_usage(deep=True).sum()   else: #     ,     DataFrame,   Series       usage_b = pandas_obj.memory_usage(deep=True)   usage_mb = usage_b / 1024 ** 2 #       return "{:03.2f} MB".format(usage_mb) gl_int = gl.select_dtypes(include=['int']) converted_int = gl_int.apply(pd.to_numeric,downcast='unsigned') print(mem_usage(gl_int)) print(mem_usage(converted_int)) compare_ints = pd.concat([gl_int.dtypes,converted_int.dtypes],axis=1) compare_ints.columns = ['before','after'] compare_ints.apply(pd.Series.value_counts)</code> </pre> <br>  Aqui está o resultado de um estudo do consumo de memória: <br><br> <code>7.87 MB <br> 1.48 MB</code> <br> <table><tbody><tr><td></td><td>  Para <br></td><td>  Depois <br></td></tr><tr><td>  uint8 <br></td><td>  NaN <br></td><td>  5.0 <br></td></tr><tr><td>  uint32 <br></td><td>  NaN <br></td><td>  1.0 <br></td></tr><tr><td>  int64 <br></td><td>  6.0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Como resultado, você pode observar uma queda no uso de memória de 7,9 para 1,5 megabytes, ou seja, reduzimos o consumo de memória em mais de 80%.  O impacto geral dessa otimização no <code>DataFrame</code> original, no entanto, não é particularmente forte, pois possui muito poucas colunas inteiras. <br><br>  Vamos fazer o mesmo com colunas contendo números de ponto flutuante. <br><br><pre> <code class="plaintext hljs">gl_float = gl.select_dtypes(include=['float']) converted_float = gl_float.apply(pd.to_numeric,downcast='float') print(mem_usage(gl_float)) print(mem_usage(converted_float)) compare_floats = pd.concat([gl_float.dtypes,converted_float.dtypes],axis=1) compare_floats.columns = ['before','after'] compare_floats.apply(pd.Series.value_counts)</code> </pre> <br>  O resultado é o seguinte: <br><br> <code>100.99 MB <br> 50.49 MB</code> <br> <table><tbody><tr><td></td><td>  Para <br></td><td>  Depois <br></td></tr><tr><td>  float32 <br></td><td>  NaN <br></td><td>  77,0 <br></td></tr><tr><td>  float64 <br></td><td>  77,0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Como resultado, todas as colunas que armazenavam números de ponto flutuante com o tipo de dados <code>float64</code> agora armazenam números do tipo <code>float32</code> , o que nos deu uma redução de 50% no uso de memória. <br><br>  Crie uma cópia do <code>DataFrame</code> original, use essas colunas numéricas otimizadas em vez daquelas que estavam originalmente presentes nela e observe o uso geral da memória após a otimização. <br><br><pre> <code class="plaintext hljs">optimized_gl = gl.copy() optimized_gl[converted_int.columns] = converted_int optimized_gl[converted_float.columns] = converted_float print(mem_usage(gl)) print(mem_usage(optimized_gl))</code> </pre> <br>  Aqui está o que temos: <br><br> <code>861.57 MB <br> 804.69 MB</code> <br> <br>  Embora <code>DataFrame</code> significativamente o consumo de memória por colunas que armazenam dados numéricos, em geral, em todo o <code>DataFrame</code> , o consumo de memória diminuiu apenas 7%.  A otimização do armazenamento de tipos de objetos pode se tornar uma fonte de melhoria muito mais séria de uma situação. <br><br>  Antes de fazermos essa otimização, veremos mais de perto como as strings são armazenadas nos pandas e comparamos com a maneira como os números são armazenados aqui. <br><br><h2>  <font color="#3AC1EF">Comparação de mecanismos para armazenar números e seqüências de caracteres</font> </h2><br>  O tipo de <code>object</code> representa valores usando objetos de seqüência de caracteres Python.  Isso ocorre em parte porque o NumPy não suporta a representação de valores de string ausentes.  Como o Python é uma linguagem interpretada de alto nível, ele não fornece ao programador ferramentas para ajustar como os dados são armazenados na memória. <br><br>  Essa limitação leva ao fato de que as seqüências de caracteres não são armazenadas em fragmentos contíguos da memória; sua representação na memória é fragmentada.  Isso leva a um aumento no consumo de memória e a uma desaceleração na velocidade de trabalho com valores de sequência.  Cada elemento da coluna que armazena o tipo de dados do objeto, de fato, é um ponteiro que contém o "endereço" no qual o valor real está localizado na memória. <br><br>  A seguir, é apresentado um diagrama baseado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste</a> material que compara o armazenamento de dados numéricos usando os tipos de dados NumPy e o armazenamento de strings usando os tipos de dados internos do Python. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/66f/54b/d8066f54b091531c120b94c90f698236.png"></div><br>  <i><font color="#999999">Armazenando dados numéricos e de sequência</font></i> <br><br>  Aqui você pode lembrar que, em uma das tabelas acima, foi mostrado que uma quantidade variável de memória é usada para armazenar dados de tipos de objetos.  Embora cada ponteiro ocupe 1 byte de memória, cada valor específico da string ocupa a mesma quantidade de memória que seria usada para armazenar uma única string no Python.  Para confirmar isso, usaremos o método <code>sys.getsizeof()</code> .  Primeiro, dê uma olhada nas linhas individuais e, em seguida, no objeto pandas da <code>Series</code> que armazena os dados da string. <br><br>  Então, primeiro examinamos as linhas usuais: <br><br><pre> <code class="plaintext hljs">from sys import getsizeof s1 = 'working out' s2 = 'memory usage for' s3 = 'strings in python is fun!' s4 = 'strings in python is fun!' for s in [s1, s2, s3, s4]:   print(getsizeof(s))</code> </pre> <br>  Aqui, os dados de uso da memória são assim: <br><br> <code>60 <br> 65 <br> 74 <br> 74</code> <br> <br>  Agora vamos ver como é o uso de strings no objeto <code>Series</code> : <br><br><pre> <code class="plaintext hljs">obj_series = pd.Series(['working out',                         'memory usage for',                         'strings in python is fun!',                         'strings in python is fun!']) obj_series.apply(getsizeof)</code> </pre> <br>  Aqui temos o seguinte: <br><br><pre> <code class="plaintext hljs">0    60 1    65 2    74 3    74 dtype: int64</code> </pre> <br>  Aqui você pode ver que os tamanhos das linhas armazenadas nos objetos pandas da <code>Series</code> são semelhantes aos seus tamanhos ao trabalhar com eles no Python e ao representá-los como entidades separadas. <br><br><h2>  <font color="#3AC1EF">Otimização do armazenamento de dados de tipo de objeto usando variáveis ​​categóricas</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Variáveis ​​categóricas</a> apareceram no pandas versão 0.15.  O tipo correspondente, <code>category</code> , usa valores inteiros em seus mecanismos internos, em vez dos valores originais armazenados nas colunas da tabela.  O Pandas usa um dicionário separado que define a correspondência dos valores inteiro e inicial.  Essa abordagem é útil quando as colunas contêm valores de um conjunto limitado.  Quando os dados armazenados em uma coluna são convertidos para o tipo de <code>category</code> , o pandas usa o subtipo <code>int</code> , que permite o uso mais eficiente da memória e é capaz de representar todos os valores exclusivos encontrados na coluna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f5/48d/59c/1f548d59c9b41fd906d038c19d3a2da2.png"></div><br>  <i><font color="#999999">Dados de origem e dados categóricos usando o subtipo int8</font></i> <br><br>  Para entender exatamente onde podemos usar dados categóricos para reduzir o consumo de memória, descobrimos o número de valores exclusivos nas colunas que armazenam os valores dos tipos de objeto: <br><br><pre> <code class="plaintext hljs">gl_obj = gl.select_dtypes(include=['object']).copy() gl_obj.describe()</code> </pre> <br>  Você pode encontrar o que temos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta</a> tabela, na folha <code>    </code> . <br><br>  Por exemplo, na coluna <code>day_of_week</code> , que é o dia da semana em que o jogo foi disputado, existem valores 171907.  Entre eles, apenas 7 são únicos.  No geral, uma simples olhada neste relatório é suficiente para entender que alguns valores únicos são usados ​​em muitas colunas para representar os dados de aproximadamente 172.000 jogos. <br><br>  Antes de fazermos a otimização em escala real, vamos selecionar uma coluna que armazena dados do objeto, pelo menos <code>day_of_week</code> , e ver o que acontece no programa quando ele é convertido em um tipo categórico. <br><br>  Como já mencionado, esta coluna contém apenas 7 valores exclusivos.  Para convertê-lo em um tipo categórico, usamos o método <code>.astype()</code> . <br><br><pre> <code class="plaintext hljs">dow = gl_obj.day_of_week print(dow.head()) dow_cat = dow.astype('category') print(dow_cat.head())</code> </pre> <br>  Aqui está o que temos: <br><br><pre> <code class="plaintext hljs">0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: object 0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: category Categories (7, object): [Fri, Mon, Sat, Sun, Thu, Tue, Wed]</code> </pre> <br>  Como você pode ver, embora o tipo da coluna tenha sido alterado, os dados armazenados nela parecem os mesmos de antes.  Agora vamos ver o que está acontecendo dentro do programa. <br><br>  No código a seguir, usamos o atributo <code>Series.cat.codes</code> para descobrir quais valores inteiros o tipo de <code>category</code> usa para representar cada dia da semana: <br><br><pre> <code class="plaintext hljs">dow_cat.head().cat.codes</code> </pre> <br>  Conseguimos descobrir o seguinte: <br><br><pre> <code class="plaintext hljs">0    4 1    0 2    2 3    1 4    5 dtype: int8</code> </pre> <br>  Aqui você pode ver que cada valor exclusivo recebe um valor inteiro e que a coluna agora é do tipo <code>int8</code> .  Não há valores ausentes, mas se fosse esse o caso, -1 seria usado para indicar esses valores. <br><br>  Agora vamos comparar o consumo de memória antes e depois de converter a coluna <code>day_of_week</code> no tipo de <code>category</code> . <br><br><pre> <code class="plaintext hljs">print(mem_usage(dow)) print(mem_usage(dow_cat))</code> </pre> <br>  Aqui está o resultado: <br><br> <code>9.84 MB <br> 0.16 MB</code> <br> <br>  Como você pode ver, foram consumidos inicialmente 9,84 megabytes de memória e, após a otimização, apenas 0,16 megabytes, o que significa uma melhoria de 98% nesse indicador.  Observe que o trabalho com esta coluna provavelmente demonstra um dos cenários de otimização mais lucrativos quando apenas 7 valores exclusivos são usados ​​em uma coluna contendo aproximadamente 172.000 elementos. <br><br>  Embora a idéia de converter todas as colunas para esse tipo de dados pareça atraente, antes de fazer isso, considere os efeitos colaterais negativos dessa conversão.  Portanto, o ponto mais negativo dessa transformação é a impossibilidade de executar operações aritméticas em dados categóricos.  Isso também se aplica a operações aritméticas comuns e ao uso de métodos como <code>Series.min()</code> e <code>Series.max()</code> sem primeiro converter os dados em um tipo de número real. <br><br>  Devemos limitar o uso do tipo de <code>category</code> a principalmente colunas que armazenam dados do tipo de <code>object</code> , nos quais menos de 50% dos valores são únicos.  Se todos os valores em uma coluna forem exclusivos, o uso do tipo de <code>category</code> aumentará o nível de uso da memória.  Isso se deve ao fato de que na memória você precisa armazenar, além dos códigos de categoria numéricos, os valores originais da string.  Detalhes sobre restrições de tipo de <code>category</code> podem ser encontrados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> do pandas. <br><br>  Vamos criar um loop que itere sobre todas as colunas que armazenam dados do tipo de <code>object</code> , descobre se o número de valores exclusivos nas colunas excede 50% e, nesse caso, os converte na <code>category</code> tipo. <br><br><pre> <code class="plaintext hljs">converted_obj = pd.DataFrame() for col in gl_obj.columns:   num_unique_values = len(gl_obj[col].unique())   num_total_values = len(gl_obj[col])   if num_unique_values / num_total_values &lt; 0.5:       converted_obj.loc[:,col] = gl_obj[col].astype('category')   else:       converted_obj.loc[:,col] = gl_obj[col]</code> </pre> <br>  Agora compare o que aconteceu após a otimização com o que aconteceu antes: <br><br><pre> <code class="plaintext hljs">print(mem_usage(gl_obj)) print(mem_usage(converted_obj)) compare_obj = pd.concat([gl_obj.dtypes,converted_obj.dtypes],axis=1) compare_obj.columns = ['before','after'] compare_obj.apply(pd.Series.value_counts)</code> </pre> <br>  Temos o seguinte: <br><br> <code>752.72 MB <br> 51.67 MB</code> <br> <table><tbody><tr><td></td><td>  Para <br></td><td>  Depois <br></td></tr><tr><td>  objeto <br></td><td>  78,0 <br></td><td>  NaN <br></td></tr><tr><td>  categoria <br></td><td>  NaN <br></td><td>  78,0 <br></td></tr></tbody></table><br>           <code>category</code> ,     ,          , ,      ,     ,    ,  ,     . <br><br>  ,  ,     ,    <code>object</code> ,   752   52 ,    93%.     ,          .  ,       ,   ,  ,     891 . <br><br><pre> <code class="plaintext hljs">optimized_gl[converted_obj.columns] = converted_obj mem_usage(optimized_gl)</code> </pre> <br>     : <br><br> <code>'103.64 MB'</code> <br> <br>  .     - .    ,       <code>datetime</code> , ,  ,        . <br><br><pre> <code class="plaintext hljs">date = optimized_gl.date print(mem_usage(date)) date.head()</code> </pre> <br>       : <br><br> <code>0.66 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0    18710504 1    18710505 2    18710506 3    18710508 4    18710509 Name: date, dtype: uint32</code> </pre> <br>  ,               <code>uint32</code> . -       <code>datetime</code>     ,         64 .       <code>datetime</code> ,  ,  ,          . <br><br>      <code>to_datetime()</code> ,  <code>format</code>    ,      <code>YYYY-MM-DD</code> . <br><br><pre> <code class="plaintext hljs">optimized_gl['date'] = pd.to_datetime(date,format='%Y%m%d') print(mem_usage(optimized_gl)) optimized_gl.date.head()</code> </pre> <br>    : <br><br> <code>104.29 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0   1871-05-04 1   1871-05-05 2   1871-05-06 3   1871-05-08 4   1871-05-09 Name: date, dtype: datetime64[ns]</code> </pre> <br><h2> <font color="#3AC1EF">    </font> </h2><br>            <code>DataFrame</code> .        , , ,   ,  ,  ,  ,  .       ,        .    ,     ,     ,     .        ,        ,      <code>DataFrame</code> ,   . <br><br>  ,             .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pandas.read_csv()</a>   ,   . ,  <code>dtype</code>  ,   ,   ,   ,     —  NumPy. <br><br>      ,          ,   .         ,      . <br><br><pre> <code class="plaintext hljs">dtypes = optimized_gl.drop('date',axis=1).dtypes dtypes_col = dtypes.index dtypes_type = [i.name for i in dtypes.values] column_types = dict(zip(dtypes_col, dtypes_type)) #    161 ,  #  10  /   #     preview = first2pairs = {key:value for key,value in list(column_types.items())[:10]} import pprint pp = pp = pprint.PrettyPrinter(indent=4) pp.pprint(preview)     : {   'acquisition_info': 'category',   'h_caught_stealing': 'float32',   'h_player_1_name': 'category',   'h_player_9_name': 'category',   'v_assists': 'float32',   'v_first_catcher_interference': 'float32',   'v_grounded_into_double': 'float32',   'v_player_1_id': 'category',   'v_player_3_id': 'category',   'v_player_5_id': 'category'}</code> </pre> <br>          ,      ,    . <br><br>    - : <br><br><pre> <code class="plaintext hljs">read_and_optimized = pd.read_csv('game_logs.csv',dtype=column_types,parse_dates=['date'],infer_datetime_format=True) print(mem_usage(read_and_optimized)) read_and_optimized.head()</code> </pre> <br>       : <br><br> <code>104.28 MB</code> <br> <br>    ,     <code>   </code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br>  ,    <code>   </code>  <code>   </code> ,     ,  ,       .      pandas       861.6   104.28 ,     88% . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br> ,  ,    ,     .     . <br><br><pre> <code class="plaintext hljs">optimized_gl['year'] = optimized_gl.date.dt.year games_per_day = optimized_gl.pivot_table(index='year',columns='day_of_week',values='date',aggfunc=len) games_per_day = games_per_day.divide(games_per_day.sum(axis=1),axis=0) ax = games_per_day.plot(kind='area',stacked='true') ax.legend(loc='upper right') ax.set_ylim(0,1) plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b2/699/6a2/3b26996a26b73e9a3ce87f3ff22dcf34.png"></div><br> <i><font color="#999999">,    </font></i> <br><br>  ,  1920-      ,  ,    50 ,        . <br><br>  ,  ,    ,      50 ,   . <br><br>    ,      . <br><br><pre> <code class="plaintext hljs">game_lengths = optimized_gl.pivot_table(index='year', values='length_minutes') game_lengths.reset_index().plot.scatter('year','length_minutes') plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6d/6db/5d2/a6d6db5d2e6bdb7330ac8a0ff2a6febd.png"></div><br> <i><font color="#999999"> </font></i> <br><br>   ,   1940-         . <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>            pandas,         ,     <code>DataFrame</code> ,   90%.       : <br><br><ul><li>       ,   ,   ,    , . </li><li>        . </li></ul><br>  ,            , ,         ,    ,  ,       pandas,    ,    . <br><br>  <b>Caros leitores!</b>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">eugene_bb</a> .    -  ,    —    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442516/">https://habr.com/ru/post/pt442516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442504/index.html">Proxy PHP Xdebug: quando os recursos padrão do Xdebug não são suficientes</a></li>
<li><a href="../pt442506/index.html">A Rússia é punida pelo comércio ilegal de dados pessoais?</a></li>
<li><a href="../pt442508/index.html">Como o udalenka acelera a inovação no GitLab</a></li>
<li><a href="../pt442512/index.html">Customização do Django ORM no exemplo do ZomboDB</a></li>
<li><a href="../pt442514/index.html">Sistemas distribuídos. Padrões de design. Resenha</a></li>
<li><a href="../pt442518/index.html">As 10 melhores técnicas de hackers na Web em 2018</a></li>
<li><a href="../pt442520/index.html">Case. Economizando 300 000 p. por mês em publicidade contextual</a></li>
<li><a href="../pt442522/index.html">RL Intuitivo (Aprendizagem por Reforço): Introdução ao Critério de Atores de Vantagem (A2C)</a></li>
<li><a href="../pt442524/index.html">Como aumentar a segurança nos sistemas de identificação pessoal e controle de acesso</a></li>
<li><a href="../pt442526/index.html">A história dos toca-fitas soviéticos (parte dois): o boom do Walkmen, um gadget para a KGB e gravadores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>