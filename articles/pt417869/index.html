<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì∑ ‚ôªÔ∏è üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ Como depurar o WebRTC üèñÔ∏è üòò üë®‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na Voximplant, usamos o WebRTC desde o seu in√≠cio: primeiro como uma alternativa ao Flash para chamadas de voz e v√≠deo e depois como uma substitui√ß√£o ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como depurar o WebRTC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/417869/">  Na Voximplant, usamos o WebRTC desde o seu in√≠cio: primeiro como uma alternativa ao Flash para chamadas de voz e v√≠deo e depois como uma substitui√ß√£o completa.  A tecnologia percorreu um caminho longo e doloroso de desenvolvimento, apenas recentemente todos os principais navegadores come√ßaram a apoi√°-la, h√° dificuldades com a transfer√™ncia de tela, v√°rios fluxos de v√≠deo e, √†s vezes, o navegador trava simplesmente se voc√™ desligar e ativar o fluxo de v√≠deo.  A experi√™ncia acumulada nos permite traduzir artigos interessantes para Habr, e hoje passamos a palavra para Xilysys, de Lee Xavier, que ir√° falar sobre chamadas de depura√ß√£o (v√≠deo) no Chrome, Firefox, Safari e Edge.  Depurar o WebRTC n√£o √© f√°cil, temos at√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instru√ß√µes</a> especiais para remover logs em navegadores populares.  E o que Lee tem - voc√™ descobrir√° sob o corte (spoiler: muito de tudo, incluindo o WireShark). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/yz/h0/cfyzh02gdgxjvmew9ifyv8p9iju.jpeg"></div><a name="habracut"></a><br><h2>  O lado sombrio do WebRTC </h2><br>  Enquanto trabalhava na Xirsys, vi alguns aplicativos muito legais que usavam o WebRTC.  Mas enquanto um pequeno grupo de desenvolvedores cria coisas de alta tecnologia, a maioria dos programadores n√£o consegue nem come√ßar a usar o WebRTC.  Porque  E tudo √© simples.  Isso √© complicado. <br><br>  Muitos de n√≥s estamos familiarizados com um aplicativo Web t√≠pico.  Esse aplicativo possui um cliente que envia solicita√ß√µes e um servidor que responde a essas solicita√ß√µes.  Um processo simples, linear e facilmente previs√≠vel.  Se algo der errado, geralmente sabemos onde procurar os logs e o que poderia acontecer.  Mas com o WebRTC, nem tudo √© t√£o simples. <br><br><h2>  Assincronia </h2><br>  Se voc√™ j√° escreveu um aplicativo multithread, provavelmente conhece a dor de cabe√ßa que esse desenvolvimento oferece.  Voos, mem√≥ria ruim - mas na maioria das vezes s√£o apenas erros dif√≠ceis de encontrar. <br><br>  O WebRTC √© de natureza ass√≠ncrona.  E isso n√£o √© de todo a simples assincronia AJAX.  Para fazer uma analogia, existem v√°rias solicita√ß√µes AJAX iniciadas simultaneamente que tentam reconciliar dados em dois computadores.  Isso ainda √© entretenimento. <br><br><h2>  Campo minado de desvio NAT </h2><br>  A cria√ß√£o de aplicativos da Web se resume ao desenvolvimento de algo que √© executado no servidor e responde √†s solicita√ß√µes.  A pior coisa que pode acontecer √© a porta que n√£o est√° aberta no IPTables.  √â tratado em 2 minutos.  Voc√™ n√£o pode dizer sobre o WebRTC. <br><br>  Servidores da Web, nem mesmo o software, mas o hardware, s√£o dispositivos com endere√ßos IP p√∫blicos.  Eles s√£o feitos para serem acess√≠veis de qualquer lugar.  E o WebRTC √© feito para enviar e receber dados dos computadores dos usu√°rios.  Que geralmente t√™m um endere√ßo IP 192.168, algo que n√£o queima com o desejo de responder a solicita√ß√µes de rede. <br><br>  Os autores do WebRTC sabem disso; portanto, o mecanismo classificar√° diferentes m√©todos de conex√£o, na tentativa de estabelecer uma conex√£o entre dois computadores que n√£o s√£o muito projetados para isso. <br><br><h2>  Por onde come√ßar a depura√ß√£o </h2><br>  Neste artigo, falo sobre as ferramentas b√°sicas para resolver os problemas mais populares.  Mas antes disso, vamos ver como o WebRTC geralmente estabelece uma conex√£o. <br><br><h2>  Como o WebRTC estabelece uma conex√£o </h2><br>  Todas as conex√µes WebRTC requerem uma pequena ajuda do protocolo de sinaliza√ß√£o.  "Pouca ajuda" √© seu pr√≥prio servidor e protocolo com o qual o chamador poder√° se comunicar com a pessoa para quem est√° ligando antes de estabelecer uma conex√£o ponto a ponto. <br><br>  O WebRTC usar√° o protocolo de sinaliza√ß√£o para transmitir informa√ß√µes sobre endere√ßos IP, a capacidade de capturar e reproduzir voz e v√≠deo, topologia de rede e dados transmitidos. <br><br>  O protocolo comumente usado √© COMET (ou SIP - nota do tradutor) e soquetes da web.  O WebRTC n√£o limita os desenvolvedores a nada, ent√£o voc√™ pode usar o que quiser, pelo menos transferir dados atrav√©s do Bloco de Notas e copiar e colar (feito em uma das oficinas, funciona - novamente um tradutor).  A sinaliza√ß√£o conectada aos dois computadores permite iniciar uma conex√£o j√° via WebRTC. <br><br><h4>  Oferta e resposta </h4><br>  As conex√µes WebRTC usam "oferta" e "resposta": <br><br><ol><li>  O iniciador da conex√£o cria e passa para a "oferta" do outro lado. </li><li>  A outra parte recebe uma "oferta", cria uma "resposta" e a devolve. </li><li>  O iniciador da conex√£o recebe uma "resposta". </li></ol><br>  Isso est√° na teoria.  Na pr√°tica, a troca de cortesias n√£o parece t√£o simples. <br><br><ol><li>  Antes de transmitir a "oferta", o iniciador de conex√£o cria uma inst√¢ncia do <b>RTCPeerConnection</b> e recebe dele o pacote de texto "SDP" (Session Description Protocol) usando <b>rtcPeerConnection.createOffer ()</b> ;  Este pacote descreve a capacidade de receber / transmitir voz e v√≠deo para o navegador. </li><li>  O conte√∫do do pacote SDP √© definido como "descri√ß√£o do lado local da conex√£o" usando <b>rtcPeerConnection.setLocalDescription ()</b> . </li><li>  O pacote √© enviado para o outro lado, onde seu conte√∫do √© definido como "a descri√ß√£o do outro lado da conex√£o" usando <b>rtcPeerConnection.setRemoteDescription ()</b> . </li><li>  No outro lado da conex√£o, seu pr√≥prio pacote SDP √© criado usando <b>rtcPeerConnection.createAnswer ()</b> , seu conte√∫do √© definido como a "descri√ß√£o do lado local da conex√£o". </li><li>  O pacote √© passado para o iniciador de conex√£o, que define seu conte√∫do como "uma descri√ß√£o do outro lado da conex√£o". </li></ol><br>  E somente depois de todas as a√ß√µes, as duas partes conectadas conhecem os recursos uma da outra para receber e enviar voz / v√≠deo. <br><br><h4>  Candidatos a ICE </h4><br>  Mas a capacidade de trabalhar com a m√≠dia n√£o √© suficiente.  Afinal, as partes contratantes ainda n√£o disseram nada sobre o estado da rede. <br><br>  Voc√™ pode descobrir quais codecs de v√≠deo o navegador suporta e se h√° uma c√¢mera no laptop quase instantaneamente.  Leva tempo para descobrir seu endere√ßo IP externo e a l√≥gica da opera√ß√£o NAT, e informa√ß√µes sobre o status da rede s√£o trocadas √† medida que essas informa√ß√µes s√£o recebidas. <br><br>  Gra√ßas √† tecnologia Trickle ICE (n√£o suportada por todos os navegadores - nota do tradutor), a conex√£o entre dois dispositivos WebRTC pode ser estabelecida a qualquer momento - assim que um "candidato" adequado for encontrado. <br><br>  O desenvolvedor deve se inscrever no evento <b>onicecandidate</b> (todas em min√∫sculas!) E passar os pacotes SDP recebidos para o outro lado, onde precisam ser transmitidos pelo WebRTC usando o m√©todo <b>addIceCandidate</b> (e aqui, surpresa, letra mai√∫scula).  Funciona nos dois sentidos. <br><br><h2>  Liga√ß√£o </h2><br>  O WebRTC usa coisas como STUN (Utilit√°rios de Traversal de Sess√£o para NAT) e TURN (Traversal Using Relay around NAT) para estabelecer uma conex√£o.  Parece assustador, mas na realidade existem apenas dois protocolos de rede. <br><br><h4>  Servidor STUN </h4><br>  O primeiro dos dois protocolos √© um pouco mais complicado que o servidor de eco.  Quando os participantes da conex√£o desejam descrever como se conectar a eles, precisam do endere√ßo IP p√∫blico.  E provavelmente n√£o ser√° o endere√ßo IP do computador, os dispositivos p√∫blicos raramente s√£o alocados aos dispositivos do usu√°rio.  Toda a tecnologia NAT foi inventada para n√£o isolar.  Para descobrir ainda o seu endere√ßo p√∫blico, o navegador faz uma solicita√ß√£o ao servidor STUN.  Passando pelo NAT, o pacote de rede altera seu endere√ßo de retorno para p√∫blico.  Ap√≥s receber o pacote com a solicita√ß√£o, o servidor STUN copia o endere√ßo de retorno do pacote para sua carga e envia o pacote de volta.  Ao passar pelo NAT na dire√ß√£o oposta, o pacote perde seu endere√ßo IP p√∫blico, mas uma c√≥pia desse endere√ßo permanece na carga √∫til, na qual o WebRTC pode l√™-lo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/vo/8r/qhvo8rafhc4akmapxnb7vtni2pe.png"></div><br><h2>  TURN server </h2><br>  O servidor TURN usa a extens√£o de protocolo STUN.  Os mesmos pacotes, cabe√ßalhos e mais uma coisa nova: <b>comando</b> .  O servidor √© um proxy: os dois clientes se conectam a ele atrav√©s da porta de <b>aloca√ß√£o</b> UDP e transmitem seus dados atrav√©s do servidor. <br><br>  Os servidores TURN s√£o projetados de forma que o iniciador da conex√£o tenha mais recursos que o outro lado.  Isso leva a um efeito interessante quando uma chamada atrav√©s de um servidor TURN √© bem-sucedida ou n√£o, dependendo de quem est√° ligando para quem (lembre-se de todo o tradutor de notas do Skype). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/07/j6/qq/07j6qqsbyc7fod_yx2vuk_9zctu.png"></div><br><h2>  Depura√ß√£o </h2><br>  Ent√£o, voc√™ leu este par√°grafo.  Estamos felizes com o tradutor e lembre-se de que o artigo trata da depura√ß√£o do WebRTC.  Mas tudo o que foi dito acima √© o m√≠nimo necess√°rio, sem o qual voc√™ nem pode come√ßar.  Mas se voc√™ come√ßar, e voc√™ n√£o tiver sorte desumana, ela ser√° quebrada. <br><br>  Vai quebrar de muitas maneiras diferentes.  O primeiro √© a falta de conectividade.  Voc√™ passou as configura√ß√µes do servidor STUN e TURN para os dois WebRTCs, ajudou-os a trocar candidatos de ofertas, respostas e ICE, mas n√£o h√° v√≠deo ou voz.  Por onde come√ßar?  Com problemas de reprodu√ß√£o local. <br><br><h2>  Depura√ß√£o local do WebRTC </h2><br>  Como escrevi acima, o principal trabalho do WebRTC ocorre no lado do navegador.  Os servidores STUN e TURN s√£o incrivelmente simples, portanto, a maioria dos problemas ocorre no seu c√≥digo JavaScript, executado em dois navegadores.  Triste, mas √© verdade.  Por outro lado, se a coisa mais interessante acontecer localmente nos navegadores, voc√™ ter√° amplas oportunidades para depura√ß√£o! <br><br>  A primeira coisa a verificar √© a sua sinaliza√ß√£o.  √â o seu c√≥digo que transmite a configura√ß√£o do √°udio com v√≠deo (oferta, resposta) e informa√ß√µes sobre configura√ß√µes de rede (candidatos a gelo) entre navegadores.  Voc√™ precisa verificar quais pacotes foram enviados, quais receberam e transmitiram o WebRTC: <br><br><ul><li>  o outro lado da conex√£o recebeu uma oferta?  O iniciador da conex√£o recebeu uma resposta?  Uma conex√£o n√£o ser√° estabelecida sem essa troca m√≠nima de comodidades; </li><li>  O WebRTC nas duas extremidades da conex√£o passou os pacotes com os candidatos a ICE?  Voc√™ trocou esses pacotes e os passou de volta para o lado oposto usando <b>addIceCandidate</b> ? </li><li>  se tudo correu bem com a troca de pacotes, o manipulador de eventos <b>onaddstream</b> foi <b>chamado</b> e voc√™ instalou o objeto resultante em um elemento HTML para reproduzir v√≠deo (ou √°udio)? </li></ul><br>  Se a troca de pacotes n√£o for suspeita, voc√™ poder√° se aprofundar nos detalhes da sess√£o. <br><br><h2>  Protocolo de descri√ß√£o da sess√£o </h2><br>  Os pacotes de oferta, resposta e candidato a ICE s√£o criados pelo WebRTC no formato de texto SDP.  √Ä primeira vista, o conte√∫do dos pacotes parece assustador, mas com um pouco de prepara√ß√£o, voc√™ pode obter muitos benef√≠cios deles durante a depura√ß√£o.  A Wikipedia descreve o SDP muito bem, mas achei uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descri√ß√£o melhor</a> para voc√™. <br><br>  O campo mais importante nos pacotes SDK ICE candidatos √© <b>tip</b> .  Para o WebRTC, um campo pode ter um dos tr√™s valores: <br><br><ul><li>  tipo host; </li><li>  typ srflx; </li><li>  tipo rel√©. </li></ul><br><h4>  tipo host </h4><br>  O tipo de <b>host</b> especifica o candidato a ICE para uma conex√£o de √°rea local (o WebRTC enumera v√°rios candidatos na esperan√ßa de estabelecer uma conex√£o, n√£o se sabe com anteced√™ncia qual deles ser√° apresentado - nota pelo tradutor).  Essa conex√£o n√£o requer um servidor STUN ou TURN, pois os dispositivos na rede local geralmente podem estabelecer conex√µes de rede diretamente.  Ao depurar a partir da rede local, basta verificar e depurar a transmiss√£o de pacotes do <b>host</b> e garantir que os dispositivos possam enviar pacotes UDP entre si.  Embora existam exce√ß√µes, na pr√°tica eu vi configura√ß√µes de rede nas quais o navegador precisava de um servidor TURN para se conectar ... a si pr√≥prio. <br><br><h4>  typ srflx </h4><br>  A combina√ß√£o de letras ‚Äúsrflx‚Äù significa ‚ÄúServer Reflexive‚Äù e marca os candidatos √† conex√£o usando um endere√ßo IP externo, onde um servidor STUN √© suficiente para conex√£o (usando a tecnologia de penetra√ß√£o NAT, que √© bem-sucedida em cerca de 80% dos casos, observe o tradutor). <br><br><h4>  tipo rel√© </h4><br>  "Relay" marca a conex√£o atrav√©s de um servidor TURN, que quase sempre √© bem-sucedido.  √â importante lembrar que o WebRTC n√£o √© necess√°rio para criar exatamente tr√™s pacotes diferentes com o campo "typ";  como os candidatos s√£o selecionados depende da implementa√ß√£o do WebRTC em uma vers√£o espec√≠fica do navegador. <br><br><h2>  Testando a conectividade do dispositivo </h2><br>  O Google oferece um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aplicativo da web</a> dedicado para testar conex√µes WebRTC no seu dispositivo.  Abra a p√°gina, clique no bot√£o "Iniciar" e o c√≥digo JavaScript tentar√° estabelecer uma conex√£o com o servidor do Google usando sinaliza√ß√£o, os servidores STUN e TURN do Google. <br><br><h2>  WebRTC Internals </h2><br>  Voc√™ examinou todos os pacotes, verificou o c√≥digo, tudo parece correto, mas n√£o funciona?  Nesses casos, o Google forneceu ao navegador Chrome uma se√ß√£o especial que mostra os elementos internos do WebRTC durante a configura√ß√£o da conex√£o e alguns gr√°ficos bonitos no caso de uma conex√£o bem-sucedida.  Para usar, abra um link t√©cnico especial no navegador: <br><br> <code>chrome://webrtc-internals</code> <br> <br>  Se voc√™ j√° possui um aplicativo usando o WebRTC aberto, ver√° imediatamente um monte de dados t√©cnicos.  Caso contr√°rio, basta abrir outra guia e h√° algo nela que usa o WebRTC.  A guia exibe todas as chamadas para o objeto <b>RTCPeerConnection</b> e permite ver em tempo real como a conex√£o √© estabelecida. <br><br><h2>  Configura√ß√£o do ICE </h2><br>  No topo da p√°gina est√° a sequ√™ncia ICE que foi usada para inicializar a conex√£o.  Se um erro foi cometido durante sua forma√ß√£o, isso ser√° imediatamente vis√≠vel (pela "linha ICE", o autor se refere √† configura√ß√£o do objeto RTCPeerConnection com uma lista de servidores STUN e TURN (o objeto 'iceServers') - observa√ß√£o pelo tradutor).  Talvez n√£o haja uma lista de servidores?  Voc√™ deve configurar o objeto RTCPeerConnection antes de fazer a primeira chamada para <b>createOffer</b> ou <b>createAnswer</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/hz/xo/lohzxoou7x8sbrhqfwuruhcwsw4.png"></div><br><h2>  Eventos RTCPeerConnection </h2><br>  A pr√≥xima se√ß√£o interna mostra as chamadas para os m√©todos <b>RTCPeerConnection</b> e os eventos recebidos do objeto em ordem cronol√≥gica.  Os erros s√£o cuidadosamente destacados em vermelho.  Observe que o <b>addIceCandidateFailed</b> vermelho geralmente n√£o √© sinal de erro e a conex√£o pode ser estabelecida normalmente.  Se a conex√£o for bem-sucedida, o √∫ltimo evento na lista ser√° um evento <b>iceconnectionstatechange</b> com o valor <b>complete</b> . <br><br><h2>  Se√ß√£o 'estat√≠sticas' </h2><br>  A pr√≥xima se√ß√£o √© relevante quando a conex√£o √© estabelecida com sucesso.  Ele cont√©m estat√≠sticas de dados transmitidos e atrasos na rede.  As duas op√ß√µes mais interessantes s√£o: <b>ssrc</b> e <b>bweforvideo</b> . <br><br><ul><li>  <b>ssrc</b> , "Stream Source", marca cada uma das suas faixas de √°udio e v√≠deo.  Exibe estat√≠sticas de dados e par√¢metros transmitidos, como <b>tempo de ida e volta</b> ; </li><li>  <b>bweforvideo</b> , BandWidth Estimate, exibe a largura do canal de rede usado. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/9e/wt/te9ewt2nl26jhbezdqj3_rkr8d4.png"></div><br><h2>  Fun√ß√£o GetStats </h2><br>  Freq√ºentemente, voc√™ n√£o poder√° acessar a p√°gina interna.  Por exemplo, quando ocorre um problema com seu usu√°rio.  Nesse caso, voc√™ pode obter os mesmos dados mostrados na p√°gina interna chamando o m√©todo <b>getStats</b> no objeto <b>RTCPeerConnection</b> .  Este m√©todo configura uma fun√ß√£o de retorno de chamada que o WebRTC chamar√° sempre que algo interessante acontecer.  A fun√ß√£o chamada obt√©m um objeto com os campos que a p√°gina interna exibe: <br><br><pre> <code class="javascript hljs">rtcPeerConnection.getStats(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"lostpackets"</span></span>).innerText = stats.packetsLost; });</code> </pre><br>  Outra ferramenta √∫til √© o evento <b>oniceconnectionstatechange</b> de um objeto <b>RTCPeerConnection</b> .  O manipulador de eventos receber√° informa√ß√µes sobre o andamento da conex√£o.  Poss√≠veis op√ß√µes: <br><br><ul><li>  <b>novo</b> : o WebRTC espera candidatos do segundo lado da conex√£o, que devem ser adicionados usando o m√©todo <b>addIceCandidate</b> ; </li><li>  <b>verifica√ß√£o</b> : o WebRTC recebeu candidatos do segundo lado da conex√£o, os compara com os locais e itera sobre as op√ß√µes; </li><li>  <b>conectado</b> : um par adequado de candidatos √© selecionado e a conex√£o √© estabelecida.  Vale ressaltar que, depois disso, os candidatos poder√£o continuar a comparecer, de acordo com o protocolo Trickle ICE; </li><li>  <b>conclu√≠do</b> : todos os candidatos s√£o recebidos e a conex√£o √© estabelecida. </li><li>  <b>desconectado</b> : a conex√£o est√° <b>desconectada</b> .  Em canais inst√°veis, o WebRTC √© capaz de se reconectar, monitoramos o sinalizador <b>conectado</b> ; </li><li>  <b>fechado</b> : a conex√£o est√° desconectada e o WebRTC n√£o funciona mais com ela. </li></ul><br>  Se a conex√£o terminou no estado de <b>falha</b> , podemos examinar os candidatos recebidos de ambos os lados e entender por que a conex√£o falhou.  Por exemplo, se um lado forneceu <b>candidatos a</b> <b>host</b> e <b>srflx</b> , o outro lado <b>hospedou</b> e <b>retransmitiu</b> , mas os dispositivos estavam em redes diferentes. <br><br><h2>  Ret√¢ngulo preto em vez de v√≠deo </h2><br>  Geralmente, h√° uma situa√ß√£o em que a conex√£o √© estabelecida, o som √© transmitido, mas, em vez do v√≠deo, um ou ambos os participantes t√™m um ret√¢ngulo preto.  Na maioria das vezes, isso acontece se voc√™ atribuir o objeto de v√≠deo recebido a um elemento HTML antes que a conex√£o fa√ßa a transi√ß√£o para o estado <b>conclu√≠do</b> . <br><br><h2>  Como cutucar uma varinha fora </h2><br>  Al√©m do <b>pr√≥prio</b> objeto <b>RTCPeerConnection</b> e dos internos exibidos pelo navegador, voc√™ pode usar ferramentas de an√°lise de pacotes de rede, como o Wireshark.  Essas ferramentas podem exibir pacotes de protocolos WebRTC usados.  Por exemplo, o Wireshark mostrar√° o conte√∫do dos pacotes STUN na janela principal e voc√™ poder√° filtr√°-los digitando a palavra-chave ‚Äústun‚Äù no campo de filtro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c4/89/jf/c489jf68awl5u25fah6xnv8piee.png"></div><br>  O que ver nas respostas do servidor?  Se voc√™ vir apenas respostas com o tipo de <b>Liga√ß√£o</b> , isso significa que apenas STUN (conversa de IP externo) √© suportada e o WebRTC pode oferecer apenas candidatos <b>srflx</b> .  Se as respostas contiverem pacotes espec√≠ficos para TURN, <b>Allocation</b> e <b>CreatePermission</b> , o WebRTC ter√° a oportunidade de tentar se conectar atrav√©s de um servidor proxy.  O analisador de pacotes marca uma <b>aloca√ß√£o</b> bem-sucedida e malsucedida.  Se n√£o houver nenhum √™xito, provavelmente os par√¢metros de acesso incorretos aos servidores TURN (que quase sempre protegem com um nome de usu√°rio e senha - a nota do tradutor) s√£o passados. <br><br>  Se houver um pacote <b>CreatePermission Success Response</b> no log, podemos assumir que tudo est√° bem com as configura√ß√µes STUN e TURN.  E se tamb√©m houver um pacote <b>ChannelBind</b> , foi poss√≠vel estabelecer uma conex√£o com o servidor TURN em alta velocidade. <br><br><h2>  Cellular Issues </h2><br>  Na minha pr√°tica, muitas solu√ß√µes WebRTC que estabelecem uma conex√£o WiFi n√£o podem se conectar via 3G / 4G.  Uma aplica√ß√£o lan√ßada em um dispositivo m√≥vel √© mais dif√≠cil de depurar: n√£o temos um analisador de pacotes t√£o simples como o Wireshark e o Safari n√£o pode mostrar os internos do WebRTC.  A l√≥gica sugere que, se o aplicativo funciona bem via WiFi, o problema n√£o est√° no aplicativo em si, mas na comunica√ß√£o celular.  Como depurar?  Pegue um laptop e conecte um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dongle 3G</a> a ele.  Portanto, voc√™ possui um analisador de pacotes e logs convenientes com os quais pode encontrar a raiz de todos os problemas em um tempo razo√°vel. <br><br><h2>  Conclus√µes </h2><br>  Depurar o WebRTC n√£o √© f√°cil, mas se voc√™ pesquisar bem na Internet, poder√° encontrar muitos artigos e exemplos.  Se voc√™ trabalha no campo das comunica√ß√µes em tempo real, recomendo que voc√™ leia as especifica√ß√µes RFC dos protocolos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STUN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TURN</a> e tecnologia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WebRTC</a> .  Os documentos s√£o grandes, mas as informa√ß√µes contidas neles ajudam a tomar decis√µes confi√°veis ‚Äã‚Äãe a responder √† pergunta "por que n√£o soa"? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417869/">https://habr.com/ru/post/pt417869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417859/index.html">Integra√ß√£o 3CX com Microsoft Dynamics 365</a></li>
<li><a href="../pt417861/index.html">Padr√£o prim√°rio sem fim</a></li>
<li><a href="../pt417863/index.html">Crian√ßas a pedir em breve? Conselho de √âtica do Reino Unido autoriza engenharia gen√©tica de embri√µes humanos</a></li>
<li><a href="../pt417865/index.html">Acessibilidade Android - um lobo em pele de cordeiro? Palestra Yandex</a></li>
<li><a href="../pt417867/index.html">Como avaliar a dura√ß√£o de um projeto de TI e quando n√£o vale a pena fazer nada</a></li>
<li><a href="../pt417871/index.html">Na linha de chegada do turismo suborbital</a></li>
<li><a href="../pt417873/index.html">Maneiras de criar janelas pop-up</a></li>
<li><a href="../pt417875/index.html">Saindo do SPA da toca do coelho com trilhos modernos</a></li>
<li><a href="../pt417877/index.html">Como o Tinder (ligeiramente) oculta sua localiza√ß√£o</a></li>
<li><a href="../pt417879/index.html">Como fazer exames da Microsoft gratuitamente [por exemplo, uma competi√ß√£o recente]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>