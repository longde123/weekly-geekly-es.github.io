<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèæ ‚ú® üî† Wiederholen fehlgeschlagener HTTP-Anforderungen in Angular ü•ó üòò üåï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Organisation des Zugriffs auf Serverdaten ist die Grundlage f√ºr fast jede einseitige Anwendung. Alle dynamischen Inhalte in solchen Anwendungen we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wiederholen fehlgeschlagener HTTP-Anforderungen in Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459302/">  Die Organisation des Zugriffs auf Serverdaten ist die Grundlage f√ºr fast jede einseitige Anwendung.  Alle dynamischen Inhalte in solchen Anwendungen werden vom Backend heruntergeladen. <br><br>  In den meisten F√§llen arbeiten HTTP-Anforderungen an den Server zuverl√§ssig und geben das gew√ºnschte Ergebnis zur√ºck.  In einigen Situationen k√∂nnen Anforderungen jedoch fehlschlagen. <br><br>  Stellen Sie sich vor, wie jemand mit Ihrer Website √ºber einen Zugangspunkt in einem Zug arbeitet, der mit einer Geschwindigkeit von 200 Stundenkilometern durch das Land f√§hrt.  Die Netzwerkverbindung in diesem Szenario kann langsam sein, aber Serveranforderungen erf√ºllen ihre Aufgabe trotzdem. <br><br>  Aber was ist, wenn der Zug in den Tunnel f√§hrt?  Es besteht eine hohe Wahrscheinlichkeit, dass die Verbindung zum Internet unterbrochen wird und die Webanwendung den Server nicht "erreichen" kann.  In diesem Fall muss der Benutzer die Anwendungsseite neu laden, nachdem der Zug den Tunnel verlassen und die Internetverbindung wiederhergestellt wurde. <br><br>  Das Neuladen der Seite kann sich auf den aktuellen Status der Anwendung auswirken.  Dies bedeutet, dass der Benutzer beispielsweise die Daten verlieren kann, die er in das Formular eingegeben hat. <br><br>  Anstatt sich einfach mit der Tatsache abzustimmen, dass eine bestimmte Anfrage nicht erfolgreich war, ist es besser, sie mehrmals zu wiederholen und dem Benutzer eine entsprechende Benachrichtigung anzuzeigen.  Wenn der Benutzer bei diesem Ansatz feststellt, dass die Anwendung versucht, das Problem zu l√∂sen, wird er die Seite h√∂chstwahrscheinlich nicht neu laden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/tq/jn/st/tqjnsttqoifuf4p9-rnt_g1dfwg.jpeg"></a> <br><br>  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, widmet sich der Analyse verschiedener M√∂glichkeiten, erfolglose Anfragen in Angular-Anwendungen zu wiederholen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Wiederholen Sie fehlgeschlagene Anforderungen</font> </h2><br>  Lassen Sie uns eine Situation reproduzieren, auf die ein Benutzer, der von einem Zug aus im Internet arbeitet, m√∂glicherweise st√∂√üt.  Wir erstellen ein Backend, das die Anforderung w√§hrend der ersten drei Zugriffsversuche falsch verarbeitet und erst ab dem vierten Versuch Daten zur√ºckgibt. <br>  Normalerweise erstellen wir mit Angular einen Service, verbinden den <code>HttpClient</code> und verwenden ihn, um Daten vom Backend abzurufen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      catchError((</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      })    );  } }</span></span></code> </pre> <br>  Hier gibt es nichts Besonderes.  Wir schlie√üen das Angular <code>HttpClient</code> Modul an und f√ºhren eine einfache GET-Anfrage aus.  Wenn die Anforderung einen Fehler zur√ºckgibt, f√ºhren wir einen Code aus, um ihn zu verarbeiten, und geben ein leeres <code>Observable</code> (beobachtbares Objekt) zur√ºck, um dar√ºber zu informieren, was die Anforderung ausgel√∂st hat.  Dieser Code sagt sozusagen: "Es ist ein Fehler aufgetreten, aber alles ist in Ordnung, ich kann damit umgehen." <br><br>  Die meisten Anwendungen f√ºhren HTTP-Anforderungen auf diese Weise aus.  Im obigen Code wird die Anforderung nur einmal ausgef√ºhrt.  Danach gibt es entweder vom Server empfangene Daten zur√ºck oder ist nicht erfolgreich. <br><br>  Wie kann ich die Anforderung wiederholen, wenn der Endpunkt <code>/greet</code> nicht verf√ºgbar ist oder einen Fehler zur√ºckgibt?  Vielleicht gibt es eine passende RxJS-Anweisung?  Nat√ºrlich existiert es.  RxJS hat Operatoren f√ºr alles. <br><br>  Das erste, was in dieser Situation in den Sinn kommt, ist die <code>retry</code> .  Schauen wir uns die Definition an: ‚ÄûGibt ein Observable zur√ºck, das das urspr√ºngliche Observable mit Ausnahme von <code>error</code> wiedergibt.  Wenn das urspr√ºngliche Observable einen <code>error</code> aufruft, abonniert diese Methode das urspr√ºngliche Observable erneut, anstatt den Fehler zu verbreiten. <br><br>  Die maximale Anzahl von Neuabonnements ist auf die <code>count</code> beschr√§nkt (dies ist der numerische Parameter, der an die Methode √ºbergeben wird). " <br><br>  Die <code>retry</code> sehr √§hnlich zu dem, was wir brauchen.  Also lasst es uns in unsere Kette einbetten. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError, retry, shareReplay} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      retry(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">),      </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">catchError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      }),      shareReplay()    );  } }</span></span></code> </pre> <br>  Wir haben den <code>retry</code> erfolgreich verwendet.  Schauen wir uns an, wie sich dies auf das Verhalten der HTTP-Anforderung auswirkt, die in der experimentellen Anwendung ausgef√ºhrt wird.  <a href="">Hier ist</a> eine gro√üe GIF-Datei, die den Bildschirm dieser Anwendung und die Registerkarte Netzwerk der Browser-Entwicklertools zeigt.  Weitere solche Demonstrationen finden Sie hier. <br><br>  Unsere Anwendung ist sehr einfach.  Es wird nur eine HTTP-Anfrage gestellt, wenn auf die Schaltfl√§che <code>PING THE SERVER</code> geklickt wird. <br><br>  Wie bereits erw√§hnt, gibt das Backend einen Fehler zur√ºck, wenn die ersten drei Versuche ausgef√ºhrt werden, eine Anforderung an es auszuf√ºhren, und wenn eine vierte Anforderung eingeht, gibt es eine normale Antwort zur√ºck. <br><br>  Auf der Registerkarte "Tool" des Netzwerkentwicklers k√∂nnen Sie sehen, dass die <code>retry</code> die ihr zugewiesene Aufgabe l√∂st und die Ausf√ºhrung der fehlgeschlagenen Anforderung dreimal wiederholt.  Der letzte Versuch ist erfolgreich, die Anwendung erh√§lt eine Antwort, eine entsprechende Meldung erscheint auf der Seite. <br><br>  Das alles ist sehr gut.  Jetzt kann die Anwendung fehlgeschlagene Anforderungen wiederholen. <br><br>  Dieses Beispiel kann jedoch noch verbessert werden.  Bitte beachten Sie, dass jetzt wiederholte Anforderungen unmittelbar nach der Ausf√ºhrung von Anforderungen ausgef√ºhrt werden, die nicht erfolgreich sind.  Dieses Verhalten des Systems wird in unserer Situation keinen gro√üen Nutzen bringen - wenn der Zug in den Tunnel f√§hrt und die Internetverbindung f√ºr eine Weile unterbrochen wird. <br><br><h2>  <font color="#3AC1EF">Verz√∂gerte Wiederholung fehlgeschlagener Anforderungen</font> </h2><br>  Der Zug, der in den Tunnel gefahren ist, verl√§sst ihn nicht sofort.  Er verbringt einige Zeit dort.  Daher m√ºssen wir den Zeitraum "verl√§ngern", in dem wir wiederholte Anforderungen an den Server ausf√ºhren.  Sie k√∂nnen dies tun, indem Sie Wiederholungen verschieben. <br><br>  Dazu m√ºssen wir den Prozess der Ausf√ºhrung wiederholter Anforderungen besser steuern.  Wir m√ºssen in der Lage sein, Entscheidungen dar√ºber zu treffen, wann genau Anfragen wiederholt werden sollen.  Dies bedeutet, dass die F√§higkeiten des <code>retry</code> f√ºr uns nicht mehr ausreichen.  Daher wenden wir uns erneut der Dokumentation zu RxJS zu. <br><br>  Die Dokumentation enth√§lt eine Beschreibung der <code>retryWhen</code> , die uns zu passen scheint.  In der Dokumentation wird Folgendes beschrieben: ‚ÄûGibt ein Observable zur√ºck, das das urspr√ºngliche Observable mit Ausnahme des <code>error</code> .  Wenn das urspr√ºngliche Observable einen <code>error</code> aufruft, l√∂st diese Methode Throwable aus, was den Fehler verursacht hat. Das Observable wird vom <code>notifier</code> .  Wenn dieses Observable " <code>complete</code> oder " <code>error</code> aufruft, ruft diese Methode " <code>complete</code> oder " <code>error</code> im untergeordneten Abonnement auf.  Andernfalls wird diese Methode das urspr√ºngliche Observable erneut abonnieren. " <br><br>  Ja, die Definition ist nicht einfach.  Beschreiben wir dasselbe in einer zug√§nglicheren Sprache. <br><br>  Die <code>retryWhen</code> akzeptiert einen R√ºckruf, der eine Observable zur√ºckgibt.  Das zur√ºckgegebene Observable entscheidet anhand einiger Regeln, wie sich der Operator <code>retryWhen</code> verh√§lt.  So <code>retryWhen</code> der Operator <code>retryWhen</code> : <br><br><ul><li>  Es funktioniert nicht mehr und gibt einen Fehler aus, wenn das zur√ºckgegebene Observable einen Fehler ausl√∂st. </li><li>  Es wird beendet, wenn das zur√ºckgegebene Observable den Abschluss meldet. </li><li>  In anderen F√§llen wiederholt das Observable, wenn es erfolgreich zur√ºckkehrt, die Ausf√ºhrung des urspr√ºnglichen Observable </li></ul><br>  Ein R√ºckruf wird nur aufgerufen, wenn das urspr√ºngliche Observable zum ersten Mal einen Fehler ausl√∂st. <br><br>  Jetzt k√∂nnen wir dieses Wissen verwenden, um mithilfe der RxJS- <code>retryWhen</code> einen Mechanismus f√ºr verz√∂gerte Wiederholungen f√ºr eine fehlgeschlagene Anforderung zu erstellen. <br><br><pre> <code class="plaintext hljs">retryWhen((errors: Observable&lt;any&gt;) =&gt; errors.pipe(    delay(delayMs),    mergeMap(error =&gt; retries-- &gt; 0 ? of(error) : throwError(getErrorMessage(maxEntry))    )) )</code> </pre> <br>  Wenn die urspr√ºngliche Observable, bei der es sich um unsere HTTP-Anforderung handelt, einen Fehler zur√ºckgibt, wird die Anweisung <code>retryWhen</code> .  Im R√ºckruf haben wir Zugriff auf den Fehler, der den Fehler verursacht hat.  Wir verschieben <code>errors</code> , reduzieren die Anzahl der Wiederholungsversuche und geben eine neue Observable zur√ºck, die einen Fehler ausl√∂st. <br><br>  Basierend auf den Regeln der <code>retryWhen</code> diese Observable <code>retryWhen</code> Anforderung, da sie <code>retryWhen</code> .  Wenn die Wiederholung mehrmals nicht erfolgreich ist und der Wert der <code>retries</code> auf 0 sinkt, beenden wir die Aufgabe mit einem Fehler, der beim Ausf√ºhren der Anforderung aufgetreten ist. <br><br>  Gro√üartig!  Anscheinend k√∂nnen wir den obigen Code verwenden und den <code>retry</code> in unserer Kette durch ihn ersetzen.  Aber hier machen wir etwas langsamer. <br><br>  Wie <code>retries</code> mit den variablen <code>retries</code> ?  Diese Variable enth√§lt den aktuellen Status des fehlgeschlagenen Anforderungswiederholungssystems.  Wo wird sie angek√ºndigt?  Wann wird der Zustand zur√ºckgesetzt?  Der Staat muss innerhalb des Streams verwaltet werden, nicht au√üerhalb. <br><br><h3>  <font color="#3AC1EF">‚ñçErstellen Sie Ihre eigene delayRetry-Anweisung</font> </h3><br>  Wir k√∂nnen das Problem der Zustandsverwaltung l√∂sen und die Lesbarkeit des Codes verbessern, indem wir den obigen Code als separaten RxJS-Operator schreiben. <br><br>  Es gibt verschiedene M√∂glichkeiten, eigene RxJS-Operatoren zu erstellen.  Welche Methode verwendet werden soll, h√§ngt davon ab, wie der jeweilige Operator strukturiert ist. <br><br>  Unser Operator basiert auf bestehenden RxJS-Operatoren.  Infolgedessen k√∂nnen wir auf einfachste Weise unsere eigenen Operatoren erstellen.  In unserem Fall ist der RxJs-Operator nur eine Funktion mit der folgenden Signatur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt;</code> </pre> <br>  Diese Anweisung nimmt das urspr√ºngliche Observable und gibt ein anderes Observable zur√ºck. <br><br>  Da unser Operator dem Benutzer erlaubt, anzugeben, wie oft wiederholte Anforderungen ausgef√ºhrt werden sollen und wie oft sie ausgef√ºhrt werden m√ºssen, m√ºssen wir die obige Funktionsdeklaration in eine Factory-Funktion <code>delayMs</code> , die <code>delayMs</code> (Verz√∂gerung zwischen <code>maxRetry</code> ) und <code>maxRetry</code> ( maximale Anzahl von Wiederholungen). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt; }</code> </pre> <br>  Wenn Sie einen Operator erstellen m√∂chten, der nicht auf vorhandenen Operatoren basiert, m√ºssen Sie auf die Behandlung von Fehlern und Abonnements achten.  Dar√ºber hinaus m√ºssen Sie die <code>Observable</code> Klasse erweitern und die <code>Observable</code> implementieren. <br><br>  Wenn Sie interessiert sind, schauen Sie <a href="">hier</a> . <br><br>  Schreiben wir also basierend auf den obigen Codefragmenten unseren eigenen RxJs-Operator. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delayedRetry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        delay(delayMs),        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error) : throwError(getErrorMessage(maxRetry))        ))      )    ); }</code> </pre> <br>  Gro√üartig.  Jetzt k√∂nnen wir diesen Operator in den Client-Code importieren.  Wir werden es verwenden, wenn wir eine HTTP-Anfrage ausf√ºhren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span><span class="hljs-string">/greet`</span></span>).pipe(        delayedRetry(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>),        catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error);            <span class="hljs-comment"><span class="hljs-comment">//               return EMPTY;        }),        shareReplay()    );</span></span></code> </pre> <br>  Wir haben den Operator <code>delayedRetry</code> in die Kette <code>delayedRetry</code> und die Zahlen 1000 und 3 als Parameter √ºbergeben. Der erste Parameter legt die Verz√∂gerung in Millisekunden zwischen den Versuchen fest, wiederholte Anforderungen zu stellen.  Der zweite Parameter bestimmt die maximale Anzahl wiederholter Anforderungen. <br><br>  Starten Sie die Anwendung neu und <a href="">sehen Sie sich</a> an, wie der neue Operator funktioniert. <br><br>  Nach der Analyse des Verhaltens des Programms mit den Tools des Browser-Entwicklers k√∂nnen wir feststellen, dass sich die Ausf√ºhrung wiederholter Versuche, die Anforderung auszuf√ºhren, um eine Sekunde verz√∂gert.  Nach Erhalt der richtigen Antwort auf die Anfrage wird im Anwendungsfenster eine entsprechende Meldung angezeigt. <br><br><h2>  <font color="#3AC1EF">Exponentielle Anfrage d√∂sen</font> </h2><br>  Lassen Sie uns die Idee der verz√∂gerten Wiederholung fehlgeschlagener Anforderungen entwickeln.  Bisher haben wir die Ausf√ºhrung jeder wiederholten Anforderung immer gleichzeitig verz√∂gert. <br><br>  Hier sprechen wir dar√ºber, wie die Verz√∂gerung nach jedem Versuch erh√∂ht werden kann.  Der erste Versuch, die Anforderung erneut zu versuchen, erfolgt nach einer Sekunde, der zweite nach zwei Sekunden, der dritte nach drei. <br><br>  Erstellen Sie eine neue Anweisung, <code>retryWithBackoff</code> , die dieses Verhalten implementiert. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up.`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_BACKOFF = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retryWithBackoff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES, backoffMs = DEFAULT_BACKOFF</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {              <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backoffTime = delayMs + (maxRetry - retries) * backoffMs;              <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error).pipe(delay(backoffTime));            }            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> throwError(getErrorMessage(maxRetry));          }        )))); }</code> </pre> <br>  Wenn Sie diesen Operator in der Anwendung verwenden und testen, k√∂nnen Sie <a href="">sehen,</a> wie sich die Verz√∂gerung bei der Ausf√ºhrung der wiederholten Anforderung nach jedem neuen Versuch erh√∂ht. <br><br>  Nach jedem Versuch warten wir eine bestimmte Zeit, wiederholen die Anfrage und verl√§ngern die Wartezeit.  Nachdem der Server die richtige Antwort auf die Anfrage zur√ºckgegeben hat, wird hier wie √ºblich eine Meldung im Anwendungsfenster angezeigt. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Durch das Wiederholen fehlgeschlagener HTTP-Anforderungen werden Anwendungen stabiler.  Dies ist besonders wichtig, wenn sehr wichtige Abfragen ausgef√ºhrt werden, ohne die Daten, √ºber die die Anwendung nicht normal arbeiten kann.  Dies k√∂nnen beispielsweise Konfigurationsdaten sein, die die Adressen der Server enthalten, mit denen die Anwendung interagieren muss. <br><br>  In den meisten Szenarien reicht die RxJs-Wiederholungsanweisung nicht aus, um ein zuverl√§ssiges Wiederholungssystem f√ºr fehlgeschlagene Anforderungen bereitzustellen.  Die <code>retryWhen</code> gibt dem Entwickler ein h√∂heres Ma√ü an Kontrolle √ºber wiederholte Anforderungen.  Hier k√∂nnen Sie das Intervall f√ºr wiederholte Anforderungen konfigurieren.  Aufgrund der F√§higkeiten dieses Operators ist es m√∂glich, ein verz√∂gertes Wiederholungsschema oder exponentiell verz√∂gerte Wiederholungen zu implementieren. <br><br>  Bei der Implementierung von Verhaltensmustern, die f√ºr die Wiederverwendung in RxJS-Ketten geeignet sind, wird empfohlen, diese als neue Operatoren zu formatieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/kreuzerk/">Hier ist das</a> Repository, aus dem der Code in diesem Artikel verwendet wurde. <br><br>  <b>Liebe Leser!</b>  Wie l√∂sen Sie das Problem, dass fehlgeschlagene HTTP-Anforderungen erneut versucht werden? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459302/">https://habr.com/ru/post/de459302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459292/index.html">Testautomatisierung f√ºr mobile Anwendungen: Toolvergleich</a></li>
<li><a href="../de459294/index.html">Was ist wichtiger: eine Programmiersprache kennen oder ein Gesch√§ftsproblem l√∂sen k√∂nnen?</a></li>
<li><a href="../de459296/index.html">JavaScript Preis 2019</a></li>
<li><a href="../de459298/index.html">Winkel: Status im Jahr 2019</a></li>
<li><a href="../de459300/index.html">Quasar 1.0: Ein neues n√ºtzliches Tool f√ºr Vue-Entwickler und nicht nur f√ºr sie</a></li>
<li><a href="../de459304/index.html">Angular Pitfall Bypass und Zeitersparnis</a></li>
<li><a href="../de459306/index.html">Server-Rendering in einer Umgebung ohne Server</a></li>
<li><a href="../de459308/index.html">SEO funktioniert 2019 nicht?</a></li>
<li><a href="../de459310/index.html">Testautomatisierungstools oder mobiler Steroidtester</a></li>
<li><a href="../de459312/index.html">Lieber Agile, ich habe es satt, so zu tun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>