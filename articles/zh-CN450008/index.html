<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏽 👨🏽‍🏫 🍘 使用PVS-Studio分析仪查找LLVM 8中的错误 🕉️ 👩‍🍳 🤽🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="自从使用我们的PVS-Studio分析仪对LLVM项目代码进行最后一次验证以来，已经过去了两年多的时间。 让我们确保PVS-Studio分析仪仍然是检测错误和潜在漏洞的领先工具。 为此，请检查并找到LLVM 8.0.0发行版中的新错误。 

 要写的文章 
 老实说，我不想写这篇文章。 写一个我们已...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用PVS-Studio分析仪查找LLVM 8中的错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/450008/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f2/8d4/5bf/2f28d45bf369270d9330bfbe2ea78f00.png" alt="PVS-Studio和LLVM 8.0.0"></div><br> 自从使用我们的PVS-Studio分析仪对LLVM项目代码进行最后一次验证以来，已经过去了两年多的时间。 让我们确保PVS-Studio分析仪仍然是检测错误和潜在漏洞的领先工具。 为此，请检查并找到LLVM 8.0.0发行版中的新错误。 <br><a name="habracut"></a><br><h2> 要写的文章 </h2><br> 老实说，我不想写这篇文章。 写一个我们已经反复测试过的项目（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1、2、3</a> ）是没有意思的。 最好写些新东西，但我别无选择。 <br><br> 每次发行新版本的LLVM或更新<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Clang Static Analyzer时</a> ，我们的邮件中都会出现以下问题： <br><br>  <i>瞧，新版本的Clang静态分析器已学会查找新错误！</i>  <i>在我看来，使用PVS-Studio的相关性正在下降。</i>  <i>Clang发现比以往更多的错误，并追赶了PVS-Studio的功能。</i>  <i>您如何看待？</i> <br><br> 为此，我一直想以一种精神来回答： <br><br>  <b>我们也不是闲着！</b> 我们大大提高了PVS-Studio分析仪的功能。 因此，请放心，我们将继续保持领先地位。 <br><br> 不幸的是，这是一个错误的答案。 没有任何证据。 这就是为什么我现在写这篇文章。 因此，LLVM项目再次经过测试，并发现了许多错误。 我现在将演示那些对我来说似乎很有趣的内容。  Clang静态分析器无法找到这些错误（或者这样做非常不便）。 而且我们可以。 我在一晚上找到并写下了所有这些错误。 <br><br> 但是这篇文章的写作拖了好几个星期。 我不能强迫自己以文字:)来安排所有这些内容。 <br><br> 顺便说一句，如果您对PVS-Studio分析仪中使用哪些技术来检测错误和潜在的漏洞感兴趣，那么我建议您熟悉本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a> 。 <br><br><h2> 新旧诊断 </h2><br> 如前所述，大约两年前，LLVM项目再次得到验证，发现的错误已得到纠正。 现在，本文将介绍错误的新部分。 为什么会发现新的错误？ 这有3个原因： <br><br><ol><li>  LLVM项目已开发，其中的旧代码已更改，然后出现了新的代码。 自然，修改和编写的代码中会出现新的错误。 这很好地说明了应该定期进行静态分析，而不是逐案进行。 我们的文章很好地展示了PVS-Studio分析仪的功能，但这与提高代码质量和降低修复错误的成本无关。 定期使用静态代码分析器！ </li><li> 我们正在定稿并改进现有的诊断程​​序。 因此，分析仪可以检测到先前检查中未发现的错误。 </li><li>  PVS-Studio推出了2年前还没有的新诊断程序。 我决定将它们分为一个单独的部分，以清楚地展示PVS-Studio的发展。 </li></ol><br><h2> 通过2年前的诊断发现的缺陷 </h2><br>  <b>片段N1：复制粘贴</b> <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldUpgradeX86Intrinsic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function *F, StringRef Name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Name == <span class="hljs-string"><span class="hljs-string">"addcarryx.u32"</span></span> || <span class="hljs-comment"><span class="hljs-comment">// Added in 8.0 .... Name == "avx512.mask.cvtps2pd.128" || // Added in 7.0 Name == "avx512.mask.cvtps2pd.256" || // Added in 7.0 Name == "avx512.cvtusi2sd" || // Added in 7.0 Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name == "sse2.pmulu.dq" || // Added in 7.0 Name == "sse41.pmuldq" || // Added in 7.0 Name == "avx2.pmulu.dq" || // Added in 7.0 .... }</span></span></code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V501</a> [CWE-570]在“ ||”的左侧和右侧有相同的子表达式“ Name.startswith（“ avx512.mask.permvar。”）” 操作员。 自动升级.cpp 73 <br><br> 请仔细检查该名称是否以子字符串“ avx512.mask.permvar。”开头。 在第二个测试中，他们显然想写些其他东西，但忘记修复复制的文本。 <br><br>  <b>片段N2：错字</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CXNameRefFlags { CXNameRange_WantQualifier = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, CXNameRange_WantTemplateArgs = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, CXNameRange_WantSinglePiece = <span class="hljs-number"><span class="hljs-number">0x4</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnnotateTokensWorker::HandlePostPonedChildCursor( CXCursor Cursor, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> StartTokenIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> flags = CXNameRange_WantQualifier | CXNameRange_WantQualifier; .... }</code> </pre> <br>  PVS-Studio警告：V501在“ |”的左侧和右侧有相同的子表达式“ CXNameRange_WantQualifier” 操作员。  CIndex.cpp 7245 <br><br> 由于输入错误， <i>两次使用</i>了相同的命名常量<i>CXNameRange_WantQualifier</i> 。 <br><br>  <b>片段N3：对操作员优先级的困惑</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PPCTTIImpl::getVectorInstrCost(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Opcode, Type *Val, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Index) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V502</a> [CWE-783]也许'？：'运算符的工作方式与预期的不同。  '？：'运算符的优先级低于'=='运算符。  PPCTargetTransformInfo.cpp 404 <br><br> 我认为这是一个非常美丽的错误。 是的，我知道我对美感很奇怪:)。 <br><br> 现在，根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">运算符</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优先级</a> ，表达式计算如下： <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; (Index == ST-&gt;isLittleEndian())) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br> 从实际的角度来看，这种情况没有意义，因为可以将其简化为： <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian())</code> </pre> <br> 这是一个明显的错误。  0/1最有可能希望与<i>Index</i>变量进行比较。 要修复代码，请在三元运算符周围添加方括号： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == (ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre> <br> 顺便说一下，三元运算符非常危险并且会引发逻辑错误。 请非常小心，不要贪婪地加上括号。 我在“害怕运算符？：并将其括在括号中”一章中对此主题进行了更详细的讨论。 <br><br>  <b>片段N4，N5：空指针</b> <br><br><pre> <code class="cpp hljs">Init *TGParser::ParseValue(Record *CurRec, RecTy *ItemType, IDParseMode Mode) { .... TypedInit *LHS = dyn_cast&lt;TypedInit&gt;(Result); .... LHS = dyn_cast&lt;TypedInit&gt;( UnOpInit::get(UnOpInit::CAST, LHS, StringRecTy::get()) -&gt;Fold(CurRec)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LHS) { Error(PasteLoc, Twine(<span class="hljs-string"><span class="hljs-string">"can't cast '"</span></span>) + LHS-&gt;getAsString() + <span class="hljs-string"><span class="hljs-string">"' to string"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V522</a> [CWE-476]可能会取消引用空指针“ LHS”。  TGParser.cpp 2152 <br><br> 如果<i>LHS</i>指针为空，则应发出警告。 但是，这将取消引用此非常为空的指针： <i>LHS-&gt; getAsString（）</i> 。 <br><br> 当错误隐藏在错误处理程序中时，这是一种非常典型的情况，因为没有人在测试它们。 静态分析器会检查所有可访问的代码，无论使用频率如何。 这是一个很好的例子，说明静态分析如何补充其他测试和错误保护技术。 <br><br> 下面的代码对<i>RHS</i>指针进行了类似的处理：V522 [CWE-476]可能会取消引用空指针“ RHS”。  TGParser.cpp 2186 <br><br>  <b>片段N6：移动后使用光标</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; ExtractBlocks(....) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; ProgClone = CloneModule(BD.getProgram(), VMap); .... BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= MiscompiledFunctions.clear(); for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) { Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first); // &lt;= assert(NewF &amp;&amp; "Function not found??"); MiscompiledFunctions.push_back(NewF); } .... }</span></span></code> </pre> <br>  PVS-Studio警告：V522 [CWE-476]可能会取消引用空指针“ ProgClone”。 错误编译.cpp 601 <br><br> 首先， <i>ProgClone</i>智能指针不再拥有该对象： <br><br><pre> <code class="cpp hljs">BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone));</code> </pre> <br> 实际上，现在<i>ProgClone</i>是空指针。 因此，空指针的解引用应该在下面进行： <br><br><pre> <code class="cpp hljs">Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first);</code> </pre> <br> 但是，实际上，这不会发生！ 请注意，循环实际上并未运行。 <br><br> 首先，将清除<i>MiscompiledFunctions</i>容器： <br><br><pre> <code class="cpp hljs">MiscompiledFunctions.clear();</code> </pre> <br> 接下来，在循环条件中使用此容器的大小： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, e = MisCompFunctions.size(); i != e; ++i) {</code> </pre> <br> 很容易看到循环没有开始。 我认为这也是一个错误，应该以不同的方式编写代码。 <br><br> 看来我们遇到了非常著名的错误校验！ 一个错误掩饰了另一个:)。 <br><br>  <b>片段N7：移动后使用光标</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; TestOptimizer(BugDriver &amp;BD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Test, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Safe) { outs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Optimizing functions being tested: "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Optimized = BD.runPassesOn(Test.get(), BD.getPassesToRun()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Optimized) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Error running this sequence of passes"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" on the input program!\n"</span></span>; BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Test)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= BD.EmitProgressBitcode(*Test, "pass-error", false); // &lt;= if (Error E = BD.debugOptimizerCrash()) return std::move(E); return false; } .... }</span></span></code> </pre> <br>  PVS-Studio警告：V522 [CWE-476]可能会取消引用空指针“测试”。 错误编译cpp 709 <br><br> 同样的情况。 首先，对象的内容被移动，然后就好像什么都没发生一样被使用。 在C ++中出现了运动的语义之后，我越来越在程序代码中看到这种情况。 为此，我喜欢C ++语言！ 射击自己的腿的方法越来越多。  PVS-Studio分析仪将始终可以工作:)。 <br><br>  <b>片段N8：空指针</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FunctionDumper::dump(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PDBSymbolTypeFunctionArg &amp;Symbol) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TypeId = Symbol.getTypeId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type = Symbol.getSession().getSymbolById(TypeId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  PVS-Studio警告：V522 [CWE-476]可能会取消引用空指针“类型”。  233.第233章 <br><br> 除错误处理程序外，通常不测试用于调试打印输出的功能。 摆在我们面前的就是这种情况。 该功能正在等待用户，而不是解决他的问题，而将被迫对其进行修复。 <br><br> 正确地： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>;</code> </pre> <br>  <b>片段N9：空指针</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SearchableTableEmitter::collectTableEntries( GenericTable &amp;Table, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Record *&gt; &amp;Items) { .... RecTy *Ty = resolveTypes(Field.RecType, TI-&gt;getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Ty) <span class="hljs-comment"><span class="hljs-comment">// &lt;= PrintFatalError(Twine("Field '") + Field.Name + "' of table '" + Table.Name + "' has incompatible type: " + Ty-&gt;getAsString() + " vs. " + // &lt;= TI-&gt;getType()-&gt;getAsString()); .... }</span></span></code> </pre> <br>  PVS-Studio警告：V522 [CWE-476]可能会取消引用空指针“ Ty”。  SearchableTableEmitter.cpp 614 <br><br> 我认为，因此一切都清楚，不需要解释。 <br><br>  <b>片段N10：错别字</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FormatTokenLexer::tryMergeCSharpNullConditionals() { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Identifier = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Question = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... Identifier-&gt;ColumnWidth += Question-&gt;ColumnWidth; Identifier-&gt;Type = Identifier-&gt;Type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= Tokens.erase(Tokens.end() - 1); return true; }</span></span></code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V570</a>为其分配了“标识符-&gt;类型”变量。 格式令牌Lexer.cpp 249 <br><br> 给自己分配一个变量是没有意义的。 他们最有可能想写： <br><br><pre> <code class="cpp hljs">Identifier-&gt;Type = Question-&gt;Type;</code> </pre> <br>  <b>片段N11：可疑的中断</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SystemZOperand::print(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindToken: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Token:"</span></span> &lt;&lt; getToken(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindReg: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Reg:"</span></span> &lt;&lt; SystemZInstPrinter::getRegisterName(getReg()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V622</a> [CWE-478]考虑检查“ switch”声明。 第一个“ case”运算符可能会丢失。 系统ZAsmParser.cpp 652 <br><br> 开始时有一个非常可疑的<i>break</i>语句。 你忘了在这里写别的东西吗？ <br><br>  <b>片段N12：解引用后检查指针</b> <br><br><pre> <code class="cpp hljs">InlineCost AMDGPUInliner::getInlineCost(CallSite CS) { Function *Callee = CS.getCalledFunction(); Function *Caller = CS.getCaller(); TargetTransformInfo &amp;TTI = TTIWP-&gt;getTTI(*Callee); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> llvm::InlineCost::getNever(<span class="hljs-string"><span class="hljs-string">"undefined callee"</span></span>); .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V595</a> [CWE-476]在针对nullptr对其进行验证之前，已使用了“被<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调用方</a> ”指针。 检查行：172，174。AMDGPUInline.cpp 172 <br><br>  <i>调用getTTI</i>函数时，将取消引用开头的<i>Callee</i>指针。 <br><br> 然后发现应该检查此指针是否具有<i>nullptr</i>相等性： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration())</code> </pre> <br> 但是为时已晚... <br><br>  <b>片段N13-N ...：取消引用后检查指针</b> <br><br> 先前代码片段中讨论的情况并非唯一。 她在这里找到： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeDoubleFP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallInst *CI, IRBuilder&lt;&gt; &amp;B, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isBinary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isPrecise = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... Function *CalleeFn = CI-&gt;getCalledFunction(); StringRef CalleeNm = CalleeFn-&gt;getName(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= AttributeList CalleeAt = CalleeFn-&gt;getAttributes(); if (CalleeFn &amp;&amp; !CalleeFn-&gt;isIntrinsic()) { // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio警告：V595 [CWE-476]在针对nullptr对其进行验证之前，已使用了'CalleeFn'指针。 检查行：1079、1081。SimplifyLibCalls.cpp 1079 <br><br> 在这里： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Sema::InstantiateAttrs(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MultiLevelTemplateArgumentList &amp;TemplateArgs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Decl *Tmpl, Decl *New, LateInstantiatedAttrVec *LateAttrs, LocalInstantiationScope *OuterMostScope) { .... NamedDecl *ND = dyn_cast&lt;NamedDecl&gt;(New); CXXRecordDecl *ThisContext = dyn_cast_or_null&lt;CXXRecordDecl&gt;(ND-&gt;getDeclContext()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(), ND &amp;&amp; ND-&gt;isCXXInstanceMember()); // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio警告：V595 [CWE-476]在针对nullptr对其进行验证之前，已使用了'ND'指针。 检查行：532、534。SemaTemplateInstantiateDecl.cpp 532 <br><br> 在这里： <br><br><ul><li>  V595 [CWE-476]在针对nullptr对其进行验证之前，已使用了“ U”指针。 检查行：404、407。DWARFFormValue.cpp 404 </li><li>  V595 [CWE-476]在针对nullptr进行验证之前，已使用了'ND'指针。 检查行：2149，2151。SemaTemplateInstantiate.cpp 2149 </li></ul><br> 然后，研究编号为V595的警告对我来说就没有兴趣了。 因此，除了这里列出的错误之外，我不知道是否还有其他类似的错误。 最有可能的。 <br><br>  <b>N17，N18片段：可疑移位</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processLogicalImmediate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Imm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;Encoding)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Size = RegSize; .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V629</a> [CWE-190]考虑检查'〜（大小-1）&lt;&lt; 1'表达式。  32位值的位移，随后扩展为64位类型。  260 AArch64AddressingModes.h <br><br> 也许这不是一个错误，并且代码完全按预期工作。 但这显然是一个非常可疑的地方，需要对其进行检查。 <br><br> 假设<i>Size</i>变量为16，然后计划编写代码以获取<i>NImms</i>变量中的值的代码的作者： <br><br>  11111111111111111111111111111111111111111111111111111111111111100000000 <br><br> 但是，实际上，结果是： <br><br>  0000000000000000000000000000000000000000001111111111111111111111111100000 <br><br> 事实是所有计算都是使用32位无符号类型进行的。 而且只有这样，此32位无符号类型才会隐式扩展为<i>uint64_t</i> 。 在这种情况下，最高有效位将为零。 <br><br> 您可以解决这种情况： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br> 相似的情况：V629 [CWE-190]考虑检查'Immr &lt;&lt; 6'表达式。  32位值的位移，随后扩展为64位类型。  AArch64AddressingModes.h 269 <br><br>  <b>片段N19：缺少</b> <b><i>else</i></b> <b>关键字</b> <b>吗？</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AMDGPUAsmParser::cvtDPP(MCInst &amp;Inst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OperandVector &amp;Operands) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Op.isReg() &amp;&amp; Op.Reg.RegNo == AMDGPU::VCC) { <span class="hljs-comment"><span class="hljs-comment">// VOP2b (v_add_u32, v_sub_u32 ...) dpp use "vcc" token. // Skip it. continue; } if (isRegOrImmWithInputMods(Desc, Inst.getNumOperands())) { // &lt;= Op.addRegWithFPInputModsOperands(Inst, 2); } else if (Op.isDPPCtrl()) { Op.addImmOperands(Inst, 1); } else if (Op.isImm()) { // Handle optional arguments OptionalIdx[Op.getImmTy()] = I; } else { llvm_unreachable("Invalid operand type"); } .... }</span></span></code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V646</a> [CWE-670]考虑检查应用程序的逻辑。 可能缺少“ else”关键字。  AMDGPUAsmParser.cpp 5655 <br><br> 这里没有错误。 由于第一个<i>if</i>的then块以<i>continue</i>结束，因此<i>else</i>关键字是否存在并不重要。 在任何情况下，代码都将相同。 但是，缺少<i>其他元素</i>会使代码更加晦涩和危险。 如果将来<i>继续</i>消失，那么代码将以完全不同的方式开始工作。 我认为，最好添加<i>else</i> 。 <br><br>  <b>片段N20：四个相同类型的错别字</b> <br><br><pre> <code class="cpp hljs">LLVM_DUMP_METHOD <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Symbol::dump(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUndefined()) Result += <span class="hljs-string"><span class="hljs-string">"(undef) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakDefined()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-def) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakReferenced()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-ref) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isThreadLocalValue()) Result += <span class="hljs-string"><span class="hljs-string">"(tlv) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SymbolKind::GlobalSymbol: Result + Name.str(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case SymbolKind::ObjectiveCClass: Result + "(ObjC Class) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCClassEHType: Result + "(ObjC Class EH) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCInstanceVariable: Result + "(ObjC IVar) " + Name.str(); // &lt;= break; } OS &lt;&lt; Result; }</span></span></code> </pre> <br>  PVS-Studio警告： <br><br><ul><li>  V655 [CWE-480]字符串已连接，但未使用。 考虑检查“ Result + Name.str（）”表达式。  Symbol.cpp 32 </li><li>  V655 [CWE-480]字符串已连接，但未使用。 考虑检查'Result +“（ObjC Class）” + Name.str（）'表达式。  Symbol.cpp 35 </li><li>  V655 [CWE-480]字符串已连接，但未使用。 考虑检查'Result +“（ObjC Class EH）” + Name.str（）'表达式。  Symbol.cpp 38 </li><li>  V655 [CWE-480]字符串已连接，但未使用。 考虑检查“结果+“（ObjC IVar）” + Name.str（）”表达式。  Symbol.cpp 41 </li></ul><br> 偶然地，使用+运算符代替+ =运算符。 结果是毫无意义的设计。 <br><br>  <b>片段N21：未定义的行为</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReqFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;StringRef, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;FeaturesMap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Record *&gt; &amp;ReqFeatures)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;R : ReqFeatures) { StringRef AsmCondString = R-&gt;getValueAsString(<span class="hljs-string"><span class="hljs-string">"AssemblerCondString"</span></span>); SmallVector&lt;StringRef, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; Ops; SplitString(AsmCondString, Ops, <span class="hljs-string"><span class="hljs-string">","</span></span>); assert(!Ops.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"AssemblerCondString cannot be empty"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Op : Ops) { assert(!Op.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Empty operator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FeaturesMap.find(Op) == FeaturesMap.end()) FeaturesMap[Op] = FeaturesMap.size(); } } }</code> </pre> <br> 尝试自己找到危险代码。 这是一张分散注意力的图片，以便不要立即查看答案： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5d/183/d4e/d5d183d4e2d3107bc512e52d893fda25.png" alt="嗯..."></div><br><br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V708</a> [CWE-758]使用了危险的构造：'FeaturesMap [Op] = <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FeatureMap.size</a> （）'，其中'FeaturesMap'是'map'类。 这可能导致不确定的行为。  RISCVCompressInstEmitter.cpp 490 <br><br> 问题行： <br><br><pre> <code class="cpp hljs">FeaturesMap[Op] = FeaturesMap.size();</code> </pre> <br> 如果找不到<i>Op</i>元素，则会在映射中创建一个新元素，并将该映射中的元素数量写入该映射中。 只是不清楚在添加新元素之前还是之后将调用<i>size</i>函数。 <br><br>  <b>片段N22-N24：重新分配</b> <br><br><pre> <code class="cpp hljs">Error MachOObjectFile::checkSymbolTable() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MachO::nlist STE = getSymbolTableEntry(SymDRI); NType = STE.n_type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= NType = STE.n_type; // &lt;= NSect = STE.n_sect; NDesc = STE.n_desc; NStrx = STE.n_strx; NValue = STE.n_value; } .... }</span></span></code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V519</a> [CWE-563]连续两次为'NType'变量分配值。 也许这是一个错误。 检查行：1663、1664。MachOObjectFile.cpp 1664 <br><br> 我认为这里没有真正的错误。 只是多余的重复分配。 但是仍然是一个错误。 <br><br> 类似地： <br><br><ul><li>  V519 [CWE-563]连续两次为'B.NDesc'变量分配值。 也许这是一个错误。 检查行：1488、1489。llvm-nm.cpp 1489 </li><li>  V519 [CWE-563]连续两次为变量分配值。 也许这是一个错误。 检查行：59，61。coff2yaml.cpp 61 </li></ul><br>  <b>片段N25-N27：更多重新分配</b> <br><br> 现在考虑稍微不同的重新分配选项。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Vectorizer::vectorizeLoadChain( ArrayRef&lt;Instruction *&gt; Chain, SmallPtrSet&lt;Instruction *, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; *InstructionsProcessed) { .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Alignment = getAlignment(L0); .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> NewAlign = getOrEnforceKnownAlignment(L0-&gt;getPointerOperand(), StackAdjustedAlignment, DL, L0, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, &amp;DT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NewAlign != <span class="hljs-number"><span class="hljs-number">0</span></span>) Alignment = NewAlign; Alignment = NewAlign; .... }</code> </pre> <br>  PVS-Studio警告：V519 [CWE-563]'Alignment'变量连续两次被赋值。 也许这是一个错误。 检查行：1158、1160。LoadStoreVectorizer.cpp 1160 <br><br> 这是一个非常奇怪的代码，似乎包含逻辑错误。 首先，根据条件为<i>Alignment</i>变量分配一个值。 然后再次进行分配，但是现在没有任何验证。 <br><br> 在这里可以看到类似的情况： <br><br><ul><li>  V519 [CWE-563]'效果'变量连续两次被赋值。 也许这是一个错误。 检查行：152，165。WebAssemblyRegStackify.cpp 165 </li><li>  V519 [CWE-563]'ExpectNoDerefChunk'变量已连续两次分配值。 也许这是一个错误。 检查行：4970，4973。SemaType.cpp 4973 </li></ul><br>  <b>片段N28：始终为真实条件</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrefixes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct InternalInstruction* insn)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byte = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> nextByte; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byte == <span class="hljs-number"><span class="hljs-number">0xf3</span></span> &amp;&amp; (nextByte == <span class="hljs-number"><span class="hljs-number">0x88</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0x89</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc6</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc7</span></span>)) { insn-&gt;xAcquireRelease = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextByte != <span class="hljs-number"><span class="hljs-number">0x90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// PAUSE instruction support // &lt;= break; } .... }</span></span></code> </pre> <br>  PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">警告</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V547</a> [CWE-571]表达式'nextByte！= 0x90'始终为true。  X86DisassemblerDecoder.cpp 379 <br><br> 验证没有意义。  <i>nextByte</i>变量始终不等于<i>0x90</i> ，这是从上一次检查得出的。 这是某种逻辑错误。 <br><br>  <b>片段N29-N ...：始终为真/假条件</b> <br><br> 分析仪发出很多警告，表明整个条件（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V547</a> ）或部分条件（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V560</a> ）始终为真或假。 这些通常不是真正的错误，而只是草率的代码，宏部署的结果等。 但是，查看所有这些警告还是有道理的，因为有时会出现真正的逻辑错误。 例如，这段代码是可疑的： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DecodeStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeGPRPairRegisterClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MCInst &amp;Inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegNo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Decoder)</span></span></span><span class="hljs-function"> </span></span>{ DecodeStatus S = MCDisassembler::Success; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RegNo &gt; <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCDisassembler::Fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((RegNo &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) || RegNo == <span class="hljs-number"><span class="hljs-number">0xe</span></span>) S = MCDisassembler::SoftFail; .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V560</a> [CWE-570]条件表达式的一部分始终为false：RegNo == 0xe。  ARMDisassembler.cpp 939 <br><br> 常数0xE是​​十进制系统中的值14。 检查<i>RegNo == 0xe</i>没有意义，因为如果<i>RegNo&gt; 13</i> ，则该函数将完成其执行。 <br><br> 还有许多其他警告，其标识符为V547和V560，但与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V595一样</a> ，我对研究这些警告不感兴趣。 很显然，我有足够的材料来撰写文章：)。 因此，不知道使用PVS-Studio在LLVM中可以检测到多少这种类型的错误。 <br><br> 我将举一个例子来说明为什么研究这些响应很无聊。 分析仪发出以下代码警告是绝对正确的。 但这不是一个错误。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> UnwrappedLineParser::parseBracedList(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ContinueOnSemicolons, tok::TokenKind ClosingBraceKind) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasError = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... HasError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ContinueOnSemicolons) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !HasError; .... }</code> </pre> <br>  PVS-Studio警告：V547 [CWE-570]表达式'！HasError'始终为false。  UnwrappedLineParser.cpp 1635 <br><br>  <b>片段N30：可疑回报</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isImplicitlyDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MachineRegisterInfo &amp;MRI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MachineRegisterInfo::def_instr_iterator It = MRI.def_instr_begin(Reg), E = MRI.def_instr_end(); It != E; ++It) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*It).isImplicitDef(); } .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V612</a> [CWE-670]循环内无条件的“返回”。  R600OptimizeVectorRegisters.cpp 63 <br><br> 这要么是一个错误，要么是一个特定的技巧，旨在向程序员阅读代码提供解释。 这种设计对我没有任何解释，看起来非常可疑。 最好不要这样写：)。 <br><br> 你累吗 然后时间做茶或咖啡。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/f86/58f/8a2f8658fdacb0dde918807666d1cd39.png" alt="咖啡"></div><br><br><h2> 新诊断程序检测到的缺陷 </h2><br> 我认为30次触发旧诊断就足够了。 现在让我们看看通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先前</a>检查后在分析仪中出现的新诊断程序可以发现有趣的事情。 在此期间，总共向C ++分析器添加了66个通用诊断程序。 <br><br>  <b>片段N31：无法访问的代码</b> <br><br><pre> <code class="cpp hljs">Error CtorDtorRunner::run() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> CtorDtorMap = ES.lookup(JITDylibSearchList({{&amp;JD, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}}), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Names), NoDependenciesToRegister, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CtorDtorMap.takeError(); CtorDtorsByPriority.clear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V779</a> [CWE-561]检测<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不到</a>代码。 可能存在错误。  ExecutionUtils.cpp 146 <br><br> 如您所见， <i>if语句的</i>两个分支都以对<i>return语句</i>的调用结尾。 因此， <i>CtorDtorsByPriority</i>容器<i>将</i>永远不会被<i>清空</i> 。 <br><br>  <b>片段N32：无法访问的代码</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LLParser::ParseSummaryEntry() { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Lex.getKind()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_gv: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseGVEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_module: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseModuleEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_typeid: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; // &lt;= default: return Error(Lex.getLoc(), "unexpected summary kind"); } Lex.setIgnoreColonInIdentifiers(false); // &lt;= return false; }</span></span></code> </pre> <br>  PVS-Studio警告：V779 [CWE-561]检测不到代码。 可能存在错误。  LLParser.cpp 835 <br><br> 一个有趣的情况。 让我们看看这个地方的开头： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br> 乍看之下，似乎没有错误。 看来<i>break</i>语句在这里是多余的，您可以简单地将其删除。 但是，并非一切都那么简单。 <br><br> 分析仪在线上生成警告： <br><br><pre> <code class="cpp hljs">Lex.setIgnoreColonInIdentifiers(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br> 确实，此代码不可访问。  <i>switch中的</i>所有情况都以对<i>return语句</i>的调用结尾。 现在，毫无意义的孤独<i>休息</i>看起来并没有那么有害！ 也许其中一个分支应该以<i>中断</i>结尾，而不是以<i>返回</i>结尾？ <br><br>  <b>片段N33：高位的意外化</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStubAlignment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Arch == Triple::systemz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; RuntimeDyldImpl::emitSection(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjectFile &amp;Obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SectionRef &amp;Section, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCode) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> DataSize = Section.getSize(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StubBufSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V784</a>位掩码的大小小于第一个操作数的大小。 这将导致丢失更高的位。 运行系统Dyld.cpp 815 <br><br> 请注意， <i>getStubAlignment</i>函数返回<i>无符号</i>类型。 如果我们假设函数返回值8，则我们将计算表达式的值： <br><br>  〜（getStubAlignment（）-1） <br><br>  〜（8u-1） <br><br>  0xFFFFFFF8u <br><br> 现在注意， <i>DataSize</i>变量具有64位无符号类型。 事实证明，在操作DataSize＆0xFFFFFFF88时，所有32个高位将被复位。 很有可能，这不是程序员想要的。 我怀疑他想计算：DataSize＆0xFFFFFFFFFFFFFFFFFFF8u。 <br><br> 要解决该错误，您应该这样编写： <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(getStubAlignment()) - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br> 大概： <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1U</span></span>LL);</code> </pre> <br>  <b>片段N34：显式转换失败</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scaleShuffleMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Scale, ArrayRef&lt;T&gt; Mask, SmallVectorImpl&lt;T&gt; &amp;ScaledMask)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; Scale &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Unexpected scaling factor"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumElts = Mask.size(); ScaledMask.assign(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(NumElts * Scale), <span class="hljs-number"><span class="hljs-number">-1</span></span>); .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1028</a> [CWE-190]可能的溢出。 考虑将'NumElts * Scale'运算符的操作数强制转换为'size_t'类型，而不是结果。  1577年 <br><br> 显式类型转换用于在乘以<i>int</i>类型的变量时防止溢出。 但是，此处的显式转换不能防止溢出。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，将对变量进行乘法运算，然后才将32位乘法结果扩展为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size_t</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段N35：复制粘贴失败</font></font></b> <br><br><pre> <code class="cpp hljs">Instruction *InstCombiner::visitFCmpInst(FCmpInst &amp;I) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op0, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op0, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return &amp;I; } .... }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V778</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [CWE-682]找到了两个类似的代码片段。</font><font style="vertical-align: inherit;">也许这是一个错字，应该使用“ Op1”变量而不是“ Op0”。</font><font style="vertical-align: inherit;">InstCombineCompares.cpp 5507 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种新的有趣的诊断方法揭示了以下情况：复制了一段代码，并且其中的一些名称开始更改，但没有在一个地方纠正。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，在第二个块中，他们将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改</font><font style="vertical-align: inherit;">为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是在一个地方，他们没有解决它。</font><font style="vertical-align: inherit;">最有可能的是，它应该这样写：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op1-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段N36：变量混乱</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode; Status() : Mask(<span class="hljs-number"><span class="hljs-number">0</span></span>), Mode(<span class="hljs-number"><span class="hljs-number">0</span></span>){}; Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { Mode &amp;= Mask; }; .... };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1001</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [CWE-563]分配了'Mode'变量，但在功能结束时未使用。</font><font style="vertical-align: inherit;">SIModeRegister.cpp 48 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为函数参数提供与类成员相同的名称非常危险。</font><font style="vertical-align: inherit;">很容易感到困惑。</font><font style="vertical-align: inherit;">摆在我们面前的就是这种情况。</font><font style="vertical-align: inherit;">此表达式没有意义：</font></font><br><br><pre> <code class="cpp hljs">Mode &amp;= Mask;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数的参数会更改。</font><font style="vertical-align: inherit;">就是这样。</font><font style="vertical-align: inherit;">该参数不再使用。</font><font style="vertical-align: inherit;">最有可能的是，必须这样写：</font></font><br><br><pre> <code class="cpp hljs">Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Mode &amp;= Mask; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段N37：变量混乱</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionBase</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SymbolTableSection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SectionBase { .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SymbolTableSection::addSymbol(Twine Name, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Bind, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Type, SectionBase *DefinedIn, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Visibility, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Shndx, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size) { .... Sym.Value = Value; Sym.Visibility = Visibility; Sym.Size = Size; Sym.Index = Symbols.size(); Symbols.emplace_back(llvm::make_unique&lt;Symbol&gt;(Sym)); Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V1001 [CWE-563]分配了'Size'变量，但在功能结束时未使用。</font><font style="vertical-align: inherit;">Object.cpp 424 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情况与上一个类似。</font><font style="vertical-align: inherit;">应该写成：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize;</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">片段N38-N47：指针忘记检查</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之前，我们研究了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V595</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">诊断</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">触发的</font></a><font style="vertical-align: inherit;">示例</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">其本质是指针在开始时被取消引用，然后才进行检查。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的年轻诊断功能</font><font style="vertical-align: inherit;">与其含义相反，但也可以检测到很多错误。</font><font style="vertical-align: inherit;">它标识了在开始时检查了指针，然后又忘记了检查指针的情况。</font><font style="vertical-align: inherit;">考虑在LLVM内部发现的此类情况。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGEPCost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type *PointeeType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *Ptr, ArrayRef&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *&gt; Operands)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= assert(....); BaseGV = dyn_cast&lt;GlobalValue&gt;(Ptr-&gt;stripPointerCasts()); } bool HasBaseReg = (BaseGV == nullptr); auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType()); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V1004 [CWE-476]在针对nullptr进行验证之后，不安全地使用了'Ptr'指针。</font><font style="vertical-align: inherit;">检查行：729，738。TargetTransformInfoImpl.h 738 </font><i><font style="vertical-align: inherit;">Ptr</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">可以为</font><i><font style="vertical-align: inherit;">nullptr</font></i><font style="vertical-align: inherit;">，如检查所示：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是，下面的指针在没有事先验证的情况下被取消引用： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 考虑另一种类似的情况。 </font></font><br><br><pre> <code class="cpp hljs">llvm::DISubprogram *CGDebugInfo::getFunctionFwdDeclOrStub(GlobalDecl GD, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Stub) { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *FD = dyn_cast&lt;FunctionDecl&gt;(GD.getDecl()); SmallVector&lt;QualType, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; ArgTypes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FD) <span class="hljs-comment"><span class="hljs-comment">// &lt;= for (const ParmVarDecl *Parm : FD-&gt;parameters()) ArgTypes.push_back(Parm-&gt;getType()); CallingConv CC = FD-&gt;getType()-&gt;castAs&lt;FunctionType&gt;()-&gt;getCallConv(); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V1004 [CWE-476]在针对nullptr对其进行验证之后，不安全地使用了“ FD”指针。</font><font style="vertical-align: inherit;">检查行：3228、3231。CGDebugInfo.cpp 3231 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意指针</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我确信问题很明显，不需要任何特殊说明。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computePolynomialFromPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value &amp;Ptr, Polynomial &amp;Result, Value *&amp;BasePtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL)</span></span></span><span class="hljs-function"> </span></span>{ PointerType *PtrTy = dyn_cast&lt;PointerType&gt;(Ptr.getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PtrTy) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= Result = Polynomial(); BasePtr = nullptr; } unsigned PointerBits = DL.getIndexSizeInBits(PtrTy-&gt;getPointerAddressSpace()); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V1004 [CWE-476]在针对nullptr进行了验证之后，“ PtrTy”指针被不安全地使用。</font><font style="vertical-align: inherit;">检查行：960、965。InterleavedLoadCombinePass.cpp 965 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何保护自己免受此类错误的侵害？</font><font style="vertical-align: inherit;">请仔细检查代码，并使用PVS-Studio静态分析器定期检查代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带其他带有此类错误的代码段是没有意义的。</font><font style="vertical-align: inherit;">我只会在文章中留下警告列表：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004 [CWE-476]在针对nullptr进行验证之后，不安全地使用了“ Expr”指针。</font><font style="vertical-align: inherit;">检查行：1049、1078。DebugInfoMetadata.cpp 1078</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004 [CWE-476]在针对nullptr对其进行验证之后，不安全地使用了'PI'指针。</font><font style="vertical-align: inherit;">检查行：733、753。LegacyPassManager.cpp 753</font></font></li><li> V1004 [CWE-476] The 'StatepointCall' pointer was used unsafely after it was verified against nullptr. Check lines: 4371, 4379. Verifier.cpp 4379 </li><li> V1004 [CWE-476] The 'RV' pointer was used unsafely after it was verified against nullptr. Check lines: 2263, 2268. TGParser.cpp 2268 </li><li> V1004 [CWE-476] The 'CalleeFn' pointer was used unsafely after it was verified against nullptr. Check lines: 1081, 1096. SimplifyLibCalls.cpp 1096 </li><li> V1004 [CWE-476] The 'TC' pointer was used unsafely after it was verified against nullptr. Check lines: 1819, 1824. Driver.cpp 1824 </li></ul><br> <b> N48-N60:  ,   (  )</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutator&gt; createISelMutator() { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutationStrategy&gt;&gt; Strategies; Strategies.emplace_back( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectorIRStrategy(InjectorIRStrategy::getDefaultOps())); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1023</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [CWE-460]通过“ emplace_back”方法将没有所有者的指针添加到“策略”容器中。发生异常时会发生内存泄漏。 llvm-isel-fuzzer.cpp 58 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要将项添加到像</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: vector &lt;std :: unique_ptr &lt;X &gt;&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样的容器的末尾，</font><font style="vertical-align: inherit;">您不能只写</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxx.push_back（新X）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为没有从</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X *</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐式转换</font><i><font style="vertical-align: inherit;">： ：unique_ptr &lt;X&gt;</font></i><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种常见的解决方案是编写</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxx.emplace_back（新X）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为它可以编译：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emplace_back</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">直接从参数构造元素，因此可以使用显式构造函数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这不安全。</font><font style="vertical-align: inherit;">如果向量已满，则分配内存。</font><font style="vertical-align: inherit;">内存重新分配操作可能会失败，导致</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抛出std :: bad_alloc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异常</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，指针将丢失，并且创建的对象将永远不会被删除。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个安全的解决方案是创建</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将在向量尝试重新分配内存之前拥有指针：</font></font><br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从C ++ 14开始，您可以使用'std :: make_unique'： </font></font><br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;X&gt;())</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种类型的缺陷对于LLVM并不重要。</font><font style="vertical-align: inherit;">如果无法分配内存，则编译器将停止工作。</font><font style="vertical-align: inherit;">但是，对于具有较长</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正常运行时间的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用程序，</font><font style="vertical-align: inherit;">如果内存分配失败，该</font><font style="vertical-align: inherit;">应用程序</font><font style="vertical-align: inherit;">无法结束，那么这可能是一个令人讨厌的错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，尽管此代码不会对LLVM造成实际威胁，但我发现谈论此错误模式和PVS-Studio分析仪学会检测到它很有用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此类型的其他警告：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1023 [CWE-460]通过'emplace_back'方法将没有所有者的指针添加到'Passes'容器中。</font><font style="vertical-align: inherit;">发生异常时会发生内存泄漏。</font><font style="vertical-align: inherit;">PassManager.h 546</font></font></li><li> V1023 [CWE-460] A pointer without owner is added to the 'AAs' container by the 'emplace_back' method. A memory leak will occur in case of an exception. AliasAnalysis.h 324 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Entries' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DWARFDebugFrame.cpp 519 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AllEdges' container by the 'emplace_back' method. A memory leak will occur in case of an exception. CFGMST.h 268 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'VMaps' container by the 'emplace_back' method. A memory leak will occur in case of an exception. SimpleLoopUnswitch.cpp 2012 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Records' container by the 'emplace_back' method. A memory leak will occur in case of an exception. FDRLogBuilder.h 30 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'PendingSubmodules' container by the 'emplace_back' method. A memory leak will occur in case of an exception. ModuleMap.cpp 810 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Objects' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DebugMap.cpp 88 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 60 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 685 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 686 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 688 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 689 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 690 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 691 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 692 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 693 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 694 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Operands' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 1911 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Stash' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2100 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Matchers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2702 </li></ul><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总共我发出了60条警告，此后我停了下来。 PVS-Studio分析仪在LLVM中是否检测到其他任何缺陷？是的，有。但是，当我写出这篇文章的代码片段时，已经是傍晚了，或者甚至是晚上，我决定是时候结束了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">希望您对此感兴趣，并且希望尝试使用PVS-Studio分析仪。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此页面</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上下载分析仪并获得试用版密钥</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最重要的是，定期使用静态分析。</font><font style="vertical-align: inherit;">为了普及静态分析方法和PVS-Studio而进行</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的一次性检查</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是正常情况。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">祝您提高代码的质量和可靠性！</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您想与说英语的读者分享这篇文章，请使用以下链接：Andrey Karpov。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用PVS-Studio在LLVM 8中查找错误</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450008/">https://habr.com/ru/post/zh-CN450008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449998/index.html">常见问题解答：旅行者极客在旅行之前需要了解哪些疫苗</a></li>
<li><a href="../zh-CN450000/index.html">（从右到左（通过窥镜</a></li>
<li><a href="../zh-CN450002/index.html">使用PVS-Studio查找LLVM 8中的错误</a></li>
<li><a href="../zh-CN450004/index.html">快速的C / C ++缓存，线程安全</a></li>
<li><a href="../zh-CN450006/index.html">冷水机组数据中心冷却：选择哪种冷却液？</a></li>
<li><a href="../zh-CN450010/index.html">照片的存储，备份和分类</a></li>
<li><a href="../zh-CN450016/index.html">从头开始创建正式的验证系统。 第1部分：PHP和Python中的字符虚拟机</a></li>
<li><a href="../zh-CN450018/index.html">一个数学二人组映射了无限的最小表面区域</a></li>
<li><a href="../zh-CN450020/index.html">硅谷来到堪萨斯州的学童。 这导致了抗议。</a></li>
<li><a href="../zh-CN450024/index.html">关于GOST R 34.11-2012哈希函数的开源实现及其对GOST R 34.10-2012电子签名的影响</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>