<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûó üë®üèΩ‚Äçüé§ üôÖüèº C # es un lenguaje de bajo nivel? üëÜüèæ üà≤ üíê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Soy un gran admirador de todo lo que hace Fabien Sanglard , me gusta su blog y le√≠ sus dos libros de principio a fin (descritos en un reciente podcast...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # es un lenguaje de bajo nivel?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443804/"> Soy un gran admirador de todo lo que hace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fabien Sanglard</a> , me gusta su blog y le√≠ sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libros de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">principio</a> a fin (descritos en un reciente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">podcast de Hansleminutes</a> ). <br><br>  Fabien recientemente escribi√≥ una gran publicaci√≥n en la que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descifr√≥ un</a> rastreador de rayos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diminutos</a> , desofuscando el c√≥digo y explicando las matem√°ticas fant√°sticamente.  ¬°Realmente recomiendo tomarse el tiempo de leer esto! <br><br>  ¬øPero me hizo preguntarme <i><b>si es posible portar este c√≥digo de C ++ a C #</b></i> ?  Como √∫ltimamente tuve que escribir mucho C ++ en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajo principal</a> , pens√© que podr√≠a probarlo. <br><br>  Pero lo que es m√°s importante, ¬øquer√≠a tener una mejor idea de <b>si C # es un lenguaje de bajo nivel</b> ? <br><a name="habracut"></a><br>  Una pregunta ligeramente diferente, pero relacionada: ¬øcu√°nto es C # adecuado para la "programaci√≥n del sistema"?  Sobre este tema, realmente recomiendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la excelente publicaci√≥n de Joe Duffy de 2013</a> . <br><br><h1>  Puerto de l√≠nea </h1><br>  Comenc√© simplemente portando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo C ++ desofuscado</a> l√≠nea por l√≠nea a C #.  Fue bastante simple: ¬°parece que la verdad todav√≠a se dice que C # es C ++++! <br><br>  El ejemplo muestra la estructura de datos principal: 'vector', aqu√≠ hay una comparaci√≥n, C ++ a la izquierda, C # a la derecha: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f14/ecc/cbd/f14ecccbd0091486caf57fc43fb2ac7f.png"></a> <br><br>  Por lo tanto, hay algunas diferencias sint√°cticas, pero como .NET le permite definir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sus propios tipos de valor</a> , pude obtener la misma funcionalidad.  Esto es importante porque tratar el "vector" como una estructura significa que podemos obtener una mejor "localidad de datos" y no necesitamos involucrar al recolector de basura .NET, porque los datos se enviar√°n a la pila (s√≠, s√© que esto es un detalle de implementaci√≥n). <br><br>  Para obtener m√°s informaci√≥n sobre <code>structs</code> o "tipos de valor" en .NET, consulte aqu√≠: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mont√≥n versus pila, tipo de valor versus tipo de referencia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tipos de valor versus tipos de referencia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Memoria en .NET: d√≥nde</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La verdad sobre los tipos de valor</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La pila es un detalle de implementaci√≥n, primera parte</a> </li></ul><br>  En particular, en la √∫ltima publicaci√≥n de Eric Lippert, encontramos una cita tan √∫til que deja en claro qu√© son realmente los "tipos de valor": <br><br><blockquote>  Por supuesto, el hecho m√°s importante sobre los tipos de valores <b>no son los detalles de implementaci√≥n, <i>c√≥mo se asignan</i></b> , sino m√°s bien el <i>significado sem√°ntico original del</i> "tipo de valor", <b>es decir, que <i>siempre se copia "por valor"</i></b> .  Si la informaci√≥n de asignaci√≥n fuera importante, los llamar√≠amos "tipos de mont√≥n" y "tipos de pila".  Pero en la mayor√≠a de los casos no importa.  La mayor√≠a de las veces, la sem√°ntica de la copia y la identificaci√≥n son relevantes. </blockquote><br>  Ahora veamos c√≥mo se ven algunos otros m√©todos en comparaci√≥n (de nuevo C ++ a la izquierda, C # a la derecha), primero <code>RayTracing(..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d0/3c5/277/4d03c5277ffa4f1e73462dab4edc7dd0.png"></a> <br><br>  Entonces <code>QueryDatabase (..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2fc/c17/839/2fcc17839a00bfc619e14c7323e28f52.png"></a> <br><br>  (vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la publicaci√≥n de Fabian</a> para obtener una explicaci√≥n de lo que hacen estas dos funciones) <br><br>  Pero, de nuevo, el hecho es que C # hace que sea muy f√°cil escribir c√≥digo C ++.  En este caso, la palabra clave <code>ref</code> nos ayuda m√°s, lo que nos permite pasar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">valor por referencia</a> .  Hemos utilizado las llamadas a m√©todos de <code>ref</code> durante bastante tiempo, pero recientemente, se han realizado esfuerzos para resolver la <code>ref</code> otro lugar: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ref devoluci√≥n y ref local</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Serie C # 7, parte 9: estructura de referencia</a> </li></ul><br>  Ahora, a <i>veces,</i> usar <code>ref</code> mejorar√° el rendimiento, porque entonces la estructura no necesita copiarse, vea los puntos de referencia en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n de Adam Stinix</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Trampas de rendimiento ref locales y ref retornos en C #"</a> para obtener m√°s informaci√≥n. <br><br>  Pero lo m√°s importante es que dicho script proporciona a nuestro puerto C # el mismo comportamiento que el c√≥digo fuente de C ++.  Aunque quiero se√±alar que los llamados "enlaces administrados" no son exactamente lo mismo que los "punteros", en particular, no podr√° realizar operaciones aritm√©ticas en ellos, vea m√°s sobre esto aqu√≠: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ref return no es un puntero</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Punteros gestionados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los enlaces no son direcciones</a> </li></ul><br><h2>  Rendimiento </h2><br>  Por lo tanto, el c√≥digo fue bien portado, pero el rendimiento tambi√©n es importante.  Especialmente en el rastreador, que puede calcular el marco durante varios minutos.  El c√≥digo C ++ contiene la variable <code>sampleCount</code> , que controla la calidad de imagen final, con <code>sampleCount = 2</code> siguiente manera: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/17e/e2d/10a17ee2df5205f5fa8bd138693bc4a6.png"><br><br>  ¬°Obviamente no es muy realista! <br><br>  Pero cuando llegas a <code>sampleCount = 2048</code> , todo se ve <i>mucho</i> mejor: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/304/4b2/14d/3044b214da9027dd34dcbc19fdc75d2f.png"><br><br>  Pero comenzar con <code>sampleCount = 2048</code> lleva <b>mucho</b> tiempo, por lo que todas las dem√°s ejecuciones se realizan con un valor de <code>2</code> para cumplir al menos un minuto.  Cambiar <code>sampleCount</code> solo afecta el n√∫mero de iteraciones del bucle de c√≥digo m√°s externo, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> explicaci√≥n para obtener una explicaci√≥n. <br><br><h3>  Resultados despu√©s de un puerto de l√≠nea "ingenuo" </h3><br>  Para comparar sustancialmente C ++ y C #, utilic√© la herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">time-windows</a> , este es el puerto del comando <code>time</code> unix.  Los resultados iniciales se ve√≠an as√≠: <br><br><table><thead><tr><th></th><th>  C ++ (VS 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) </th></tr></thead><tbody><tr><td>  Tiempo (seg) </td><td>  47,40 </td><td>  80,14 </td><td>  78,02 </td></tr><tr><td>  En el n√∫cleo (seg.) </td><td>  0,14 (0,3%) </td><td>  0,72 (0,9%) </td><td>  0.63 (0.8%) </td></tr><tr><td>  En espacio de usuario (seg.) </td><td>  43,86 (92,5%) </td><td>  73,06 (91,2%) </td><td>  70,66 (90,6%) </td></tr><tr><td>  N√∫mero de errores de falla de p√°gina </td><td>  1143 </td><td>  4818 </td><td>  5945 </td></tr><tr><td>  Conjunto de trabajo (KB) </td><td>  4232 </td><td>  13 624 </td><td>  17 052 </td></tr><tr><td>  Memoria Extruida (KB) </td><td>  95 </td><td>  172 </td><td>  154 </td></tr><tr><td>  Memoria no preventiva </td><td>  7 7 </td><td>  14 </td><td>  16 </td></tr><tr><td>  Archivo de intercambio (KB) </td><td>  1460 </td><td>  10 936 </td><td>  11 024 </td></tr></tbody></table><br>  Inicialmente, vemos que el c√≥digo C # es un poco m√°s lento que la versi√≥n C ++, pero est√° mejorando (ver m√°s abajo). <br><br>  Pero primero veamos qu√© nos hace el .NET JIT incluso con este puerto "ingenuo" l√≠nea por l√≠nea.  Primero, hace un buen trabajo al incorporar m√©todos de ayuda m√°s peque√±os.  Esto se puede ver en el resultado de la excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta Inlining Analyzer</a> (verde = incorporado): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cc/484/0a5/4cc4840a53f18362d3b4f3a4249fb2d5.png"></a> <br><br>  Sin embargo, no incorpora todos los m√©todos, por ejemplo, debido a la complejidad, <code>QueryDatabase(..)</code> omite <code>QueryDatabase(..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9e2/648/da2/9e2648da2a8ae7df5f94ceb77771c0ab.png"></a> <br><br>  Otra caracter√≠stica del compilador .NET Just-In-Time (JIT) es la conversi√≥n de llamadas a m√©todos espec√≠ficos a las instrucciones correspondientes de la CPU.  Podemos ver esto en acci√≥n con la funci√≥n de shell <code>sqrt</code> , aqu√≠ est√° el c√≥digo fuente de C # (tenga en cuenta la llamada a <code>Math.Sqrt</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); }</span></span></code> </pre> <br>  Y aqu√≠ est√° el c√≥digo de ensamblador que genera .NET JIT: no hay llamada a <code>Math.Sqrt</code> y se <code>Math.Sqrt</code> la instrucci√≥n de procesador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vsqrtsd</a> : <br><br><pre> <code class="plaintext hljs">; Assembly listing for method Program:sqrtf(float):float ; Emitting BLENDED_CODE for X64 CPU with AVX - Windows ; Tier-1 compilation ; optimized code ; rsp based frame ; partially interruptible ; Final local variable assignments ; ; V00 arg0 [V00,T00] ( 3, 3 ) float -&gt; mm0 ;# V01 OutArgs [V01 ] ( 1, 1 ) lclBlk ( 0) [rsp+0x00] "OutgoingArgSpace" ; ; Lcl frame size = 0 G_M8216_IG01: vzeroupper G_M8216_IG02: vcvtss2sd xmm0, xmm0 vsqrtsd xmm0, xmm0 vcvtsd2ss xmm0, xmm0 G_M8216_IG03: ret ; Total bytes of code 16, prolog size 3 for method Program:sqrtf(float):float ; ============================================================</code> </pre> <br>  (para obtener este problema, siga <a href="">estas instrucciones</a> , use el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complemento VS2019 "Disasmo"</a> o mire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SharpLab.io</a> ) <br><br>  Estos reemplazos tambi√©n se conocen como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intr√≠nsecos</a> , y en el siguiente c√≥digo podemos ver c√≥mo los genera el JIT.  Este fragmento muestra la asignaci√≥n solo para <code>AMD64</code> , pero el JIT tambi√©n apunta a <code>X86</code> , <code>ARM</code> y <code>ARM64</code> , el m√©todo completo <a href="">aqu√≠</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Compiler::IsTargetIntrinsic(CorInfoIntrinsics intrinsicId) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_TARGET_AMD64_) || (defined(_TARGET_X86_) &amp;&amp; !defined(LEGACY_BACKEND)) switch (intrinsicId) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// AMD64/x86 has SSE2 instructions to directly compute sqrt/abs and SSE4.1 // instructions to directly compute round/ceiling/floor. // // </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> Because the x86 backend only targets SSE for floating-point code, // it does not treat Sine, Cosine, or Round as intrinsics (JIT32 // implemented those intrinsics as x87 instructions). If this poses // a CQ problem, it may be necessary to change the implementation of // the helper calls to decrease call overhead or switch back to the // x87 instructions. This is tracked by #7097. case CORINFO_INTRINSIC_Sqrt: case CORINFO_INTRINSIC_Abs: return true; case CORINFO_INTRINSIC_Round: case CORINFO_INTRINSIC_Ceiling: case CORINFO_INTRINSIC_Floor: return compSupports(InstructionSet_SSE41); default: return false; } ... }</span></span></span></span></code> </pre> <br>  Como puede ver, algunos m√©todos se implementan como <code>Sqrt</code> y <code>Abs</code> , mientras que otros utilizan funciones de tiempo de ejecuci√≥n de C ++, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">powf</a> . <br><br>  Todo este proceso est√° muy bien explicado en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"¬øC√≥mo se implementa Math.Pow () en .NET Framework?"</a>  , tambi√©n se puede ver en la fuente CoreCLR: <br><br><ul><li>  Implementaci√≥n de <code><a href="">COMSingle::Pow</a></code> , es decir, el m√©todo que se ejecuta si se <code>MathF.Pow(..)</code> desde el c√≥digo C # <br></li><li>  Mapeo en la <a href="">implementaci√≥n del m√©todo de tiempo de ejecuci√≥n C</a> <br></li><li>  Versi√≥n multiplataforma <a href="">de implementaci√≥n de powf</a> que proporciona el mismo comportamiento en todo el sistema operativo </li></ul><br><h3>  Resultados despu√©s de simples mejoras de rendimiento </h3><br>  Me pregunto si puede mejorar de inmediato el ingenuo puerto de l√≠nea por puerto.  Despu√©s de algunos perfiles, hice dos cambios principales: <br><br><ul><li>  Eliminar la inicializaci√≥n de matriz en l√≠nea </li><li>  Reemplazar las funciones de <code>Math.XXX(..)</code> con an√°logos de <code>MathF.()</code> </li></ul><br>  Estos cambios se explican con m√°s detalle a continuaci√≥n. <br><br><h4>  Eliminar la inicializaci√≥n de matriz en l√≠nea </h4><br>  Para obtener m√°s informaci√≥n sobre por qu√© esto es necesario, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta excelente respuesta de desbordamiento de pila</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Andrei Akinshin</a> , junto con puntos de referencia y c√≥digo de ensamblador.  Llega a la siguiente conclusi√≥n: <br><br><blockquote>  <b>Conclusi√≥n</b> <br><br><ul><li>  <i><b>¬ø.NET almacena en cach√© las matrices locales codificadas?</b></i>  Como los que ponen el compilador de Roslyn en metadatos. </li><li>  <i><b>En este caso, habr√° gastos generales?</b></i>  Desafortunadamente, s√≠: para cada llamada, JIT copiar√° el contenido de la matriz de los metadatos, lo que lleva m√°s tiempo en comparaci√≥n con una matriz est√°tica.  El tiempo de ejecuci√≥n tambi√©n selecciona objetos y crea tr√°fico en la memoria. </li><li>  <i><b>¬øHay alguna necesidad de preocuparse por esto?</b></i>  Posiblemente  Si este es un m√©todo activo y desea alcanzar un buen nivel de rendimiento, debe usar una matriz est√°tica.  Si este es un m√©todo fr√≠o que no afecta el rendimiento de la aplicaci√≥n, probablemente necesite escribir un c√≥digo fuente "bueno" y colocar la matriz en el √°rea del m√©todo. </li></ul></blockquote><br>  Puede ver los cambios realizados en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta diferencia</a> . <br><br><h4>  Uso de funciones MathF en lugar de Math </h4><br>  En segundo lugar, y lo m√°s importante, mejor√© significativamente el rendimiento al hacer los siguientes cambios: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / MathF.Sqrt(q % q)); } #else public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); } #endif</span></span></span></span></code> </pre> <br>  Comenzando con .NET Standard 2.1, existen implementaciones concretas de funciones matem√°ticas comunes <code>float</code> .  Est√°n ubicados en la clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">System.MathF</a> .  Para obtener m√°s informaci√≥n sobre esta API y su implementaci√≥n, consulte aqu√≠: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nueva API matem√°tica con precisi√≥n simple</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Agregue funciones matem√°ticas con precisi√≥n simple</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proporcionar un conjunto de pruebas unitarias para nuevas API de matem√°ticas de precisi√≥n simple</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">System.Math y System.MathF deben implementarse en c√≥digo administrado, no como FCALL para el tiempo de ejecuci√≥n de C</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mover Math.Abs ‚Äã‚Äã(doble) y Math.Abs ‚Äã‚Äã(flotante) para implementar en c√≥digo administrado</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dise√±o y proceso para agregar herramientas integradas espec√≠ficas de la plataforma a .NET</a> </li></ul><br>  Despu√©s de estos cambios, la diferencia en el rendimiento del c√≥digo C # y C ++ se redujo a aproximadamente un 10%: <br><br><table><thead><tr><th></th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC OFF </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  Tiempo (seg) </td><td>  41,38 </td><td>  58,89 </td><td>  46.04 </td><td>  44,33 </td></tr><tr><td>  En el n√∫cleo (seg.) </td><td>  0,05 (0,1%) </td><td>  0,06 (0,1%) </td><td>  0,14 (0,3%) </td><td>  0.13 (0.3%) </td></tr><tr><td>  En espacio de usuario (seg.) </td><td>  41,19 (99,5%) </td><td>  58,34 (99,1%) </td><td>  44,72 (97,1%) </td><td>  44.03 (99.3%) </td></tr><tr><td>  N√∫mero de errores de falla de p√°gina </td><td>  1119 </td><td>  4749 </td><td>  5776 </td><td>  5661 </td></tr><tr><td>  Conjunto de trabajo (KB) </td><td>  4136 </td><td>  13,440 </td><td>  16,788 </td><td>  16,652 </td></tr><tr><td>  Memoria Extruida (KB) </td><td>  89 </td><td>  172 </td><td>  150 </td><td>  150 </td></tr><tr><td>  Memoria no preventiva </td><td>  7 7 </td><td>  13 </td><td>  16 </td><td>  16 </td></tr><tr><td>  Archivo de intercambio (KB) </td><td>  1428 </td><td>  10 904 </td><td>  10 960 </td><td>  11 044 </td></tr></tbody></table><br>  TC: compilaci√≥n multinivel, compilaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escalonada</a> ( <i>supongo</i> que se habilitar√° de forma predeterminada en .NET Core 3.0) <br><br>  Para completar, aqu√≠ est√°n los resultados de varias ejecuciones: <br><br><table><thead><tr><th>  Correr </th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC OFF </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  TestRun-01 </td><td>  41,38 </td><td>  58,89 </td><td>  46.04 </td><td>  44,33 </td></tr><tr><td>  TestRun-02 </td><td>  41,19 </td><td>  57,65 </td><td>  46,23 </td><td>  45,96 </td></tr><tr><td>  TestRun-03 </td><td>  42,17 </td><td>  62,64 </td><td>  46,22 </td><td>  48,73 </td></tr></tbody></table><br>  <b>Nota</b> : la diferencia entre .NET Core y .NET Framework se debe a la falta de la API de MathF en .NET Framework 4.7.2, para obtener m√°s informaci√≥n, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el ticket de soporte .Net Framework (4.8?) Para netstandard 2.1</a> . <br><br><h1>  Incrementar a√∫n m√°s la productividad </h1><br>  ¬°Estoy seguro de que el c√≥digo a√∫n se puede mejorar! <br><br>  Si est√° interesado en resolver la diferencia de rendimiento, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ est√° el c√≥digo C #</a> .  A modo de comparaci√≥n, puede ver el c√≥digo de ensamblador de C ++ desde el excelente servicio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compiler Explorer</a> . <br><br>  Finalmente, si eso ayuda, aqu√≠ est√° la salida del generador de perfiles de Visual Studio con una pantalla de "ruta caliente" (despu√©s de las mejoras de rendimiento descritas anteriormente): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b78/3df/2e6/b783df2e692b62f492b78c8e7affcbf4.png"></a> <br><br><h1>  ¬øC # es un lenguaje de bajo nivel? </h1><br>  O m√°s espec√≠ficamente: <br><br><blockquote>  <b><b>¬øQu√© caracter√≠sticas del lenguaje de la funcionalidad C # / F # / VB.NET o BCL / Runtime significan programaci√≥n de "bajo nivel" *?</b></b> </blockquote><br>  * S√≠, entiendo que "bajo nivel" es un t√©rmino subjetivo. <br><br>  <b>Nota:</b> cada desarrollador de C # tiene su propia idea de cu√°l es el "nivel bajo", los programadores de C ++ o Rust dar√°n por sentado estas funciones. <br><br>  Aqu√≠ est√° la lista que hice: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ref devoluciones y ref locales</a> <br><ul><li>  ‚ÄúPasar y regresar por referencia para evitar copiar grandes estructuras.  ¬°Los tipos y la memoria seguros pueden ser incluso <b>m√°s r√°pidos</b> que los inseguros! </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo inseguro en .NET</a> <br><ul><li>  ‚ÄúEl lenguaje central de C #, como se defini√≥ en cap√≠tulos anteriores, es muy diferente de C y C ++ en que carece de punteros como tipo de datos.  En cambio, C # proporciona enlaces y la capacidad de crear objetos gobernados por el recolector de basura.  Este dise√±o, combinado con otras caracter√≠sticas, hace que C # sea un lenguaje mucho m√°s seguro que C o C ++ ". </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Punteros gestionados en .NET</a> <br><ul><li>  ‚ÄúHay otro tipo de puntero en el CLR: un puntero administrado.  Se puede definir como un tipo m√°s general de enlace que puede apuntar a otras ubicaciones, y no solo al comienzo del objeto ". </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C # 7 Series, Parte 10: Span &lt;T&gt; y Universal Memory Management</a> <br><ul><li>  "System.Span &lt;T&gt; es solo un tipo de pila ( <code>ref struct</code> ) que envuelve todos los patrones de acceso a la memoria; es un tipo de acceso universal y continuo a la memoria.  Podemos imaginar una implementaci√≥n de Span con una referencia ficticia y una longitud que acepte los tres tipos de acceso a memoria ". </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compatibilidad ("Gu√≠a de programaci√≥n de C #")</a> <br><ul><li>  ".NET Framework proporciona interoperabilidad con c√≥digo no administrado a trav√©s de servicios de invocaci√≥n de plataforma, el <code>System.Runtime.InteropServices</code> , compatibilidad C ++ y compatibilidad COM (interoperabilidad COM)". </li></ul></li></ul><br>  Tambi√©n lanc√© un grito en Twitter y obtuve muchas m√°s opciones para su inclusi√≥n en la lista: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ben Adams</a> : "Herramientas integradas para plataformas (Instrucciones de CPU)" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mark Gravell</a> : ‚ÄúSIMD via Vector (que va bien con Span) es * bastante * bajo;  .NET Core deber√≠a (¬øpronto?) Ofrecer herramientas integradas de CPU directas para un uso m√°s expl√≠cito de instrucciones espec√≠ficas de CPU " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mark Gravell</a> : "JIT de gran alcance: cosas como elisi√≥n de rango en matrices / intervalos, as√≠ como el uso de reglas por estructura T para eliminar grandes fragmentos de c√≥digo que JIT sabe con certeza que no est√°n disponibles para esa T o en su CPU (BitConverter.IsLittleEndian, Vector.IsHardwareAccelerated, etc.) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kevin Jones</a> : "Mencionar√≠a especialmente las clases <code>MemoryMarshal</code> e <code>Unsafe</code> , y tal vez algunas otras cosas en los <code>System.Runtime.CompilerServices</code> " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Theodoros Chatsigiannakis</a> : "Tambi√©n puedes incluir <code>__makeref</code> y el resto" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">damageboy</a> : "¬øLa capacidad de generar din√°micamente c√≥digo que coincida exactamente con la entrada esperada, dado que este √∫ltimo solo se conocer√° en tiempo de ejecuci√≥n y puede cambiar peri√≥dicamente?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Robert Hacken</a> : "Emisi√≥n din√°mica de IL" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Victor Baybekov</a> : ‚ÄúStackalloc no fue mencionado.  Tambi√©n es posible escribir IL puro (no din√°mico, por lo tanto, se guarda en una llamada de funci√≥n), por ejemplo, use <code>ldftn</code> cach√© y llame a trav√©s de <code>calli</code> .  Hay una plantilla de proyecto en VS2017 que hace que esto sea trivial al sobrescribir los m√©todos extern + MethodImplOptions.ForwardRef + ilasm.ex ¬ª <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Victor Baybekov</a> : "MethodImplOptions.AggressiveInlining tambi√©n" activa la programaci√≥n de bajo nivel "en el sentido de que le permite escribir c√≥digo de alto nivel con muchos m√©todos peque√±os y a√∫n controlar el comportamiento de JIT para obtener un resultado optimizado.  De lo contrario, copie y pegue cientos de m√©todos LOC ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ben Adams</a> : "¬øUsa las mismas convenciones de llamadas (ABI) que en la plataforma base y p / invoca para la interacci√≥n?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Victor Baibekov</a> : ‚ÄúAdem√°s, como mencion√≥ #fsharp, tiene una <code>inline</code> que funciona desde el nivel IL hasta el JIT, por lo tanto, se consider√≥ importante a nivel del idioma.  C # esto no es suficiente (hasta ahora) para lambdas, que siempre son llamadas virtuales, y las soluciones son a menudo extra√±as (gen√©ricos limitados) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexandre Mutel</a> : ‚ÄúNuevo SIMD integrado, postprocesamiento de Unsafe Utility class / IL (por ejemplo, personalizado, Fody, etc.).  Para C # 8.0, punteros de funci√≥n pr√≥ximos ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexandre Mutel</a> : "Con respecto a IL, F # admite directamente IL en un idioma, por ejemplo" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OmariO</a> : ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BinaryPrimitives</a> .  Nivel bajo, pero seguro " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Koji Matsui</a> : ‚Äú¬øQu√© tal tu propio ensamblador incorporado?  Es dif√≠cil tanto para el kit de herramientas como para el tiempo de ejecuci√≥n, pero puede reemplazar la soluci√≥n p / invoke actual e implementar el c√≥digo incrustado, si lo hay " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Frank A. Kruger</a> : "Ldobj, stobj, initobj, initblk, cpyblk" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conrad Coconut</a> : ‚Äú¬øQuiz√°s transmitir el almacenamiento local?  Tampones de tama√±o fijo?  Probablemente deber√≠as mencionar las restricciones no administradas y los tipos blittable :) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sebastiano Mandala</a> : ‚ÄúSolo una peque√±a adici√≥n a todo lo que se dijo: ¬øqu√© tal algo simple, como organizar estructuras y c√≥mo llenar y alinear la memoria y ordenar campos puede afectar el rendimiento de la cach√©?  Esto es algo que yo mismo debo explorar ". <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nino Floris</a> : "Las constantes integradas a trav√©s de readonlyspan, stackalloc, finalizadores, WeakReference, delegados abiertos, MethodImplOptions, MemoryBarriers, TypedReference, varargs, SIMD, Unsafe.AsRef, pueden establecer los tipos de estructuras exactamente de acuerdo con el dise√±o (utilizado para TaskAwaiter y su versi√≥n)" </li></ul><br>  <b>Entonces, al final, dir√≠a que C # ciertamente le permite escribir c√≥digo que se parece a C ++, y en combinaci√≥n con las bibliotecas de tiempo de ejecuci√≥n y de clase base proporciona muchas funciones de bajo nivel.</b> <br><br><h1>  Lectura adicional </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Plantillas para C # de alto rendimiento.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Federico Andres Lois</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de rendimiento n.¬∫ 6: diccionario chino-ingl√©s</a> (desde 2005, dos blogueros de Microsoft han estado luchando en la batalla del rendimiento de C ++ contra C #) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de rendimiento n.¬∫ 6: conclusi√≥n, exploraci√≥n espacial</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øCu√°nto m√°s r√°pido es C ++ que C #?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Optimizaci√≥n de C # administrado y c√≥digo C ++ nativo</a> (2005) </li></ul><br>  Unity Burst Compiler: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo hizo Unity (un subconjunto) de C # tan r√°pido como C ++</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unity Burst Compiler: optimizaci√≥n de rendimiento f√°cil</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Daily Pathtracer, Parte 3: C # y Unity Burst</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++, C # y Unity</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sum√©rgete en el compilador Burst - Unite LA</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443804/">https://habr.com/ru/post/443804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443786/index.html">An√°lisis del segundo concurso de cuestionarios de Android del stand de HeadHunter en Mobius 2018 Mosc√∫</a></li>
<li><a href="../443788/index.html">Los fundamentos del enrutamiento est√°tico en Mikrotik RouterOS</a></li>
<li><a href="../443792/index.html">Errores t√≠picos al trabajar con PostgreSQL. Parte 2</a></li>
<li><a href="../443794/index.html">Las principales direcciones para las nuevas empresas de TI en el campo de las ventas de bienes ra√≠ces</a></li>
<li><a href="../443798/index.html">Hacks de Zotero: almacenamiento sincronizado ilimitado y su uso sin problemas con rmarkdown</a></li>
<li><a href="../443808/index.html">An√°lisis de ni√±as con baja responsabilidad social (a cargo de Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../443810/index.html">¬øCu√°nto ganan los desarrolladores de diferentes calificaciones, 2018?</a></li>
<li><a href="../443812/index.html">C√≥mo implementar un lenguaje de programaci√≥n en JavaScript. Parte 2: Int√©rprete</a></li>
<li><a href="../443814/index.html">Dar es mi "negocio anterior"</a></li>
<li><a href="../443816/index.html">El Ministerio de Comunicaciones insiste en un solo operador 5G</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>