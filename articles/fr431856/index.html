<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛫 📊 🤚🏽 Extension de l'éditeur Unity avec la fenêtre de l'éditeur, l'objet scriptable et l'éditeur personnalisé 🥞 🧕 🏀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! Je m'appelle Grisha et je suis le fondateur de CGDevs. Aujourd'hui, je veux parler des extensions de l'éditeur et parler de l'un de me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Extension de l'éditeur Unity avec la fenêtre de l'éditeur, l'objet scriptable et l'éditeur personnalisé</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431856/"> Bonjour à tous!  Je m'appelle Grisha et je suis le fondateur de CGDevs.  Aujourd'hui, je veux parler des extensions de l'éditeur et parler de l'un de mes projets, que j'ai décidé de publier dans OpenSource. <br><br>  L'unité est un excellent outil, mais elle a un petit problème.  Pour un débutant, afin de créer une pièce simple (une boîte avec des fenêtres), il faut soit maîtriser la modélisation 3D, soit essayer d'assembler quelque chose à partir de quads.  Récemment, il est devenu ProBuilder entièrement gratuit, mais c'est également un package de modélisation 3D simplifié.  Je voulais un outil simple qui nous permettrait de créer rapidement des environnements comme des pièces avec des fenêtres et de corriger les UV.  Il y a longtemps, j'ai développé un plug-in pour Unity, qui vous permet de prototyper rapidement des environnements comme des appartements et des pièces à l'aide d'un dessin 2D, et maintenant j'ai décidé de le mettre dans OpenSource.  À l'aide de son exemple, nous analyserons comment vous pouvez développer l'éditeur et quels outils existent pour cela.  Si vous êtes intéressé, bienvenue au chat.  Un lien vers le projet à la fin, comme toujours, est joint. <br><br><img src="https://habrastorage.org/webt/e_/oy/lr/e_oylrvnh0iqwprqfu2g_5amfxe.png"><br><a name="habracut"></a><br>  Unity3d dispose d'une boîte à outils suffisamment large pour étendre les capacités de l'éditeur.  Grâce à des classes telles que <i>EditorWindow</i> , ainsi que les fonctionnalités de l' <i>inspecteur personnalisé</i> , du <i>tiroir de propriétés</i> et de <i>TreeView</i> (+ <i>UIElements</i> devraient apparaître bientôt), il est facile de créer vos cadres de différents degrés de complexité au-dessus de l'unité. <br><br>  Aujourd'hui, nous allons parler de l'une des approches que j'ai utilisées pour développer ma solution et de quelques problèmes intéressants auxquels j'ai dû faire face. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mvN5O4LtMZo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  La solution est basée sur l'utilisation de trois classes, telles que <i>EditorWindow</i> (toutes les fenêtres supplémentaires), <i>ScriptableObject</i> (stockage de données) et <i>CustomEditor</i> (fonctionnalité d'inspecteur supplémentaire pour Scriptable Object). <br><br>  Lors du développement d'extensions d'éditeur, il est important d'essayer de respecter le principe selon lequel les développeurs Unity utiliseront l'extension, de sorte que les interfaces doivent être claires, natives et intégrées dans le flux de travail Unity. <br><br>  Parlons de tâches intéressantes. <br><br>  Pour créer un prototype, nous devons d'abord apprendre à dessiner des dessins à partir desquels nous générerons notre environnement.  Pour ce faire, nous avons besoin d'une fenêtre EditorWindow spéciale, dans laquelle nous afficherons tous les dessins.  En principe, il serait possible de dessiner dans SceneView, mais l'idée initiale était que lors de la finalisation de la solution, vous souhaitiez peut-être ouvrir plusieurs dessins en même temps.  En général, la création d'une fenêtre séparée dans une unité est une tâche assez simple.  Cela peut être trouvé dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuels Unity.</a>  Mais la grille de dessin est une tâche plus intéressante.  Il y a plusieurs problèmes à ce sujet. <br><br>  <b>Unity a plusieurs styles qui affectent les couleurs des fenêtres.</b> <br><br>  Le fait est que la plupart des personnes utilisant la version Pro d'Unity utilisent un thème sombre, et seule la version claire est disponible dans la version gratuite.  Cependant, les couleurs utilisées dans l'éditeur de dessin ne doivent pas fusionner avec l'arrière-plan.  Ici, vous pouvez trouver deux solutions.  La difficulté est de créer votre propre version des styles, de la vérifier et de changer la palette de la version de l'unité.  Et la chose simple est de remplir l'arrière-plan de la fenêtre avec une certaine couleur.  Dans le développement, il a été décidé d'utiliser une méthode simple.  Un exemple de la façon dont cela peut être fait est d'appeler un tel code dans la méthode OnGUI. <br><br><div class="spoiler">  <b class="spoiler_title">Une certaine couleur</b> <div class="spoiler_text"><pre><code class="cs hljs">GUI.color = BgColor; GUI.DrawTexture(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, maxSize), EditorGUIUtility.whiteTexture); GUI.color = Color.white;</code> </pre> <br></div></div><br><br>  En substance, nous venons de dessiner la texture de couleur BgColor sur toute la fenêtre. <br><br><img src="https://habrastorage.org/webt/vy/oz/vg/vyozvgmtlmv5ureag8qpthzfpik.png"><br><br>  <b>Dessinez et déplacez la grille</b> <br><br>  Ici, plusieurs problèmes ont été révélés à la fois.  Tout d'abord, vous deviez saisir votre système de coordonnées.  Le fait est que pour un travail correct et pratique, nous devons recalculer les coordonnées GUI de la fenêtre dans les coordonnées de la grille.  Pour cela, deux méthodes de conversion ont été implémentées (essentiellement, ce sont deux matrices TRS peintes) <br><br><div class="spoiler">  <b class="spoiler_title">Conversion des coordonnées de fenêtre en coordonnées d'écran</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GUIToGrid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vec</span></span></span><span class="hljs-function">)</span></span> { Vector2 newVec = ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(vec.x, -vec.y) - <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(_ParentWindow.position.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, -_ParentWindow.position.height / <span class="hljs-number"><span class="hljs-number">2</span></span>)) * _Zoom + <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(_Offset.x, -_Offset.y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newVec.RoundCoordsToInt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GridToGUI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vec</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(vec.x - _Offset.x, -vec.y - _Offset.y) ) / _Zoom + <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(_ParentWindow.position.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, _ParentWindow.position.height / <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre><br></div></div><br><br>  où <i>_ParentWindow</i> est la fenêtre dans laquelle nous allons dessiner la grille, <i>_Offset</i> est la position actuelle de la grille et <i>_Zoom</i> est le degré d'approximation. <br><br>  Deuxièmement, pour tracer les lignes, nous avons besoin de la méthode <i>Handles.DrawLine</i> .  La classe Handles possède de nombreuses méthodes utiles pour le rendu de graphiques simples dans les fenêtres de l'éditeur, l'inspecteur ou SceneView.  Au moment du développement du plugin (Unity 5.5), <i>Handles.DrawLine</i> - allouait de la mémoire et fonctionnait généralement assez lentement.  Pour cette raison, le nombre de lignes possibles pour le rendu a été limité par la constante <i>CELLS_IN_LINE_COUNT</i> , et le "niveau LOD" a également été créé au zoom pour obtenir des images par seconde acceptables dans l'éditeur. <br><br><div class="spoiler">  <b class="spoiler_title">Dessin de la grille</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawLODLines</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gridColor = SkinManager.Instance.CurrentSkin.GridColor; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step0 = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) Mathf.Pow(<span class="hljs-number"><span class="hljs-number">10</span></span>, level); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> halfCount = step0 * CELLS_IN_LINE_COUNT / <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = halfCount * DEFAULT_CELL_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offsetX = ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (_Offset.x / DEFAULT_CELL_SIZE)) / (step0 * step0) * step0; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offsetY = ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (_Offset.y / DEFAULT_CELL_SIZE)) / (step0 * step0) * step0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = -halfCount; i &lt;= halfCount; i += step0) { Handles.color = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(gridColor.r, gridColor.g, gridColor.b, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>); Handles.DrawLine( GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(-length + offsetX * DEFAULT_CELL_SIZE, (i + offsetY) * DEFAULT_CELL_SIZE)), GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(length + offsetX * DEFAULT_CELL_SIZE, (i + offsetY) * DEFAULT_CELL_SIZE)) ); Handles.DrawLine( GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((i + offsetX) * DEFAULT_CELL_SIZE, -length + offsetY * DEFAULT_CELL_SIZE)), GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((i + offsetX) * DEFAULT_CELL_SIZE, length + offsetY * DEFAULT_CELL_SIZE)) ); } offsetX = (offsetX / (<span class="hljs-number"><span class="hljs-number">10</span></span> * step0)) * <span class="hljs-number"><span class="hljs-number">10</span></span> * step0; offsetY = (offsetY / (<span class="hljs-number"><span class="hljs-number">10</span></span> * step0)) * <span class="hljs-number"><span class="hljs-number">10</span></span> * step0; ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = -halfCount; i &lt;= halfCount; i += step0 * <span class="hljs-number"><span class="hljs-number">10</span></span>) { Handles.color = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(gridColor.r, gridColor.g, gridColor.b, <span class="hljs-number"><span class="hljs-number">1</span></span>); Handles.DrawLine( GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(-length + offsetX * DEFAULT_CELL_SIZE, (i + offsetY) * DEFAULT_CELL_SIZE)), GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(length + offsetX * DEFAULT_CELL_SIZE, (i + offsetY) * DEFAULT_CELL_SIZE)) ); Handles.DrawLine( GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((i + offsetX) * DEFAULT_CELL_SIZE, -length + offsetY * DEFAULT_CELL_SIZE)), GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((i + offsetX) * DEFAULT_CELL_SIZE, length + offsetY * DEFAULT_CELL_SIZE)) ); } }</code> </pre><br></div></div><br><br>  Presque tout est prêt pour la grille.  Son mouvement est décrit très simplement.  _Le décalage est essentiellement la position actuelle de la «caméra». <br><br><div class="spoiler">  <b class="spoiler_title">Mouvement de grille</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 dv</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = _Offset.x + dv.x * _Zoom; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = _Offset.y + dv.y * _Zoom; _Offset.x = x; _Offset.y = y; }</code> </pre> <br></div></div><br><br>  Dans le projet lui-même, vous pouvez vous familiariser avec le code de la fenêtre en général et voir comment les boutons peuvent être ajoutés à la fenêtre. <br><br>  Nous allons plus loin.  En plus d'une fenêtre séparée pour dessiner des dessins, nous devons en quelque sorte stocker les dessins eux-mêmes.  Le moteur de sérialisation Unity interne, l'objet scriptable, est idéal pour cela.  En fait, il vous permet de stocker les classes décrites comme actifs dans le projet, ce qui est très pratique et natif pour de nombreux développeurs d'unités.  Par exemple, la partie de la classe Appartement qui est chargée de stocker les informations de disposition en général <br><br><div class="spoiler">  <b class="spoiler_title">Partie de la classe Appartement</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Apartment</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> fields public float Height; public bool IsGenerateOutside; public Material OutsideMaterial; public Texture PlanImage; [SerializeField] private List&lt;Room&gt; _Rooms; [SerializeField] private Rect _Dimensions; private Vector2[] _DimensionsPoints = new Vector2[4]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span></span></code> </pre> <br></div></div><br><br>  Dans l'éditeur, cela ressemble à ceci dans la version actuelle: <br><br><img src="https://habrastorage.org/webt/h1/hh/9o/h1hh9oc8lin8nh3ztjvjqbi0hb0.png"><br><br>  Ici, bien sûr, CustomEditor a déjà été appliqué, mais néanmoins, vous pouvez remarquer que des paramètres tels que _Dimensions, Height, IsGenerateOutside, OutsideMaterial et PlanImage sont affichés dans l'éditeur. <br><br>  Tous les champs publics et les champs marqués avec [SerializeField] sont sérialisés (c'est-à-dire enregistrés dans un fichier dans ce cas).  Cela aide beaucoup si vous devez enregistrer des dessins, mais lorsque vous travaillez avec ScriptableObject et toutes les ressources de l'éditeur, vous devez vous rappeler qu'il est préférable d'appeler la méthode AssetDatabase.SaveAssets () pour enregistrer l'état des fichiers.  Sinon, les modifications ne seront pas enregistrées.  Si vous ne sauvegardez pas le projet avec vos mains. <br><br>  Nous allons maintenant analyser partiellement la classe ApartmentCustomInspector et son fonctionnement. <br><br><div class="spoiler">  <b class="spoiler_title">Classe ApartmentCustomInspector</b> <div class="spoiler_text"><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">CustomEditor(typeof(Apartment))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ApartmentCustomInspector</span></span> : <span class="hljs-title"><span class="hljs-title">Editor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Apartment _ThisApartment; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Rect _Dimensions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _ThisApartment = (Apartment) target; _Dimensions = _ThisApartment.Dimensions; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnInspectorGUI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TopButtons(); _ThisApartment.Height = EditorGUILayout.FloatField(<span class="hljs-string"><span class="hljs-string">"Height (cm)"</span></span>, _ThisApartment.Height); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dimensions = EditorGUILayout.Vector2Field(<span class="hljs-string"><span class="hljs-string">"Dimensions (cm)"</span></span>, _Dimensions.size).RoundCoordsToInt(); _ThisApartment.PlanImage = (Texture) EditorGUILayout.ObjectField(_ThisApartment.PlanImage, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Texture), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); _ThisApartment.IsGenerateOutside = EditorGUILayout.Toggle(<span class="hljs-string"><span class="hljs-string">"Generate outside (Directional Light)"</span></span>, _ThisApartment.IsGenerateOutside); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_ThisApartment.IsGenerateOutside) _ThisApartment.OutsideMaterial = (Material) EditorGUILayout.ObjectField( <span class="hljs-string"><span class="hljs-string">"Outside Material"</span></span>, _ThisApartment.OutsideMaterial, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Material), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); GenerateButton(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dimensionsRect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(-dimensions.x / <span class="hljs-number"><span class="hljs-number">2</span></span>, -dimensions.y / <span class="hljs-number"><span class="hljs-number">2</span></span>, dimensions.x, dimensions.y); _Dimensions = dimensionsRect; _ThisApartment.Dimensions = _Dimensions; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TopButtons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GUILayout.BeginHorizontal(); CreateNewBlueprint(); OpenBlueprint(); GUILayout.EndHorizontal(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateNewBlueprint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button( <span class="hljs-string"><span class="hljs-string">"Create new"</span></span> )) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> manager = ApartmentsManager.Instance; manager.SelectApartment(manager.CreateOrGetApartment(<span class="hljs-string"><span class="hljs-string">"New Apartment"</span></span> + GUID.Generate())); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenBlueprint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button( <span class="hljs-string"><span class="hljs-string">"Open in Builder"</span></span> )) { ApartmentsManager.Instance.SelectApartment(_ThisApartment); ApartmentBuilderWindow.Create(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button( <span class="hljs-string"><span class="hljs-string">"Generate Mesh"</span></span> )) { MeshBuilder.GenerateApartmentMesh(_ThisApartment); } } }</code> </pre> <br></div></div><br>  CustomEditor est un outil très puissant qui vous permet de résoudre avec élégance de nombreuses tâches typiques pour l'extension de l'éditeur.  Associé à ScriptableObject, il vous permet de créer des extensions d'éditeur simples, pratiques et intuitives.  Cette classe est un peu plus compliquée que l'ajout de boutons, car vous pouvez voir dans la classe d'origine que le champ List_Rooms privé [SerializeField] est en cours de sérialisation.  L'afficher dans l'inspecteur, d'une part, à rien, et d'autre part - cela peut entraîner des bogues imprévus et des états de dessin.  La méthode OnInspectorGUI est responsable du rendu de l'inspecteur, et si vous avez juste besoin d'ajouter des boutons, vous pouvez y appeler la méthode DrawDefaultInspector () et tous les champs seront dessinés. <br><br>  Les champs et boutons nécessaires sont ensuite dessinés manuellement.  La classe EditorGUILayout elle-même possède de nombreuses implémentations pour une grande variété de types de champs pris en charge par l'unité.  Mais le rendu des boutons dans Unity est implémenté dans la classe GUILayout.  Comment fonctionne le traitement par pression sur un bouton dans ce cas.  OnInspectorGUI - exécute la saisie de la souris pour chaque événement (mouvement de la souris, clics de souris à l'intérieur de la fenêtre de l'éditeur, etc.). Si l'utilisateur clique sur le bouton dans la zone, la méthode renvoie true et traite les méthodes qui se trouvent à l'intérieur du if 'décrit par vous. a.  Pour un exemple: <br><br><div class="spoiler">  <b class="spoiler_title">Bouton de génération de maillage</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button( <span class="hljs-string"><span class="hljs-string">"Generate Mesh"</span></span> )) { MeshBuilder.GenerateApartmentMesh(_ThisApartment); } }</code> </pre> <br></div></div><br>  Lorsque vous cliquez sur le bouton Générer un maillage, la méthode statique est appelée, qui est responsable de la génération d'un maillage d'une disposition spécifique. <br><br>  En plus de ces mécanismes de base utilisés pour développer l'éditeur Unity, je voudrais mentionner séparément un outil très simple et très pratique, dont, pour une raison quelconque, beaucoup oublient - Sélection.  La sélection est une classe statique qui vous permet de sélectionner les objets nécessaires dans l'inspecteur et ProjectView. <br><br>  Pour sélectionner un objet, il vous suffit d'écrire Selection.activeObject = MyAwesomeUnityObject.  Et la meilleure partie est qu'il fonctionne avec ScriptableObject.  Dans ce projet, il est chargé de sélectionner un dessin et des pièces dans une fenêtre avec des dessins. <br><br>  Merci de votre attention!  J'espère que l'article et le projet vous seront utiles et que vous apprendrez quelque chose de nouveau par vous-même dans l'une des approches pour développer l'éditeur Unity.  Et comme toujours - un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien vers le projet GitHub</a> , où vous pouvez voir l'ensemble du projet.  Il est encore un peu humide, mais néanmoins il permet déjà de faire des plans en 2D simplement et rapidement. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431856/">https://habr.com/ru/post/fr431856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431842/index.html">0xc00007b ou installation de pilotes sous le programme</a></li>
<li><a href="../fr431846/index.html">GeekBrains commence à préparer des développeurs Python à pile complète</a></li>
<li><a href="../fr431848/index.html">Comme j'ai écrit le plus gros script pour Altium Designer</a></li>
<li><a href="../fr431850/index.html">Heisenbug 2018 Moscou: diffusion en ligne gratuite, fête et bien plus encore</a></li>
<li><a href="../fr431854/index.html">Cohérence des données dans les systèmes fortement chargés</a></li>
<li><a href="../fr431858/index.html">Mitap Sbertekh à Rostov-sur-le-Don</a></li>
<li><a href="../fr431860/index.html">Sur les options du pilote Linux ou comment j'ai passé le week-end</a></li>
<li><a href="../fr431862/index.html">Mitap Sbertekh à Iekaterinbourg</a></li>
<li><a href="../fr431864/index.html">PVS-Studio ROI: comment ne pas perdre des millions (version provisoire de l'article)</a></li>
<li><a href="../fr431866/index.html">Idées fausses des programmeurs sur les noms - avec des exemples</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>