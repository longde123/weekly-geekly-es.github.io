<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•£ üë®üèΩ‚Äçüî¨ üê® ¬øQu√© es el alias estricto y por qu√© deber√≠a importarnos? Parte 2 ü§±üèª üî≤ üéöÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(O mecanograf√≠a, comportamiento vago y alineaci√≥n, ¬°Dios m√≠o!) 

 Amigos, queda muy poco tiempo antes del lanzamiento de un nuevo hilo en el curso "C ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øQu√© es el alias estricto y por qu√© deber√≠a importarnos? Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443602/">  <b><i>(O mecanograf√≠a, comportamiento vago y alineaci√≥n, ¬°Dios m√≠o!)</i></b> <br><br>  Amigos, queda muy poco tiempo antes del lanzamiento de un nuevo hilo en el curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"C ++ Developer"</a> .  Es hora de publicar una traducci√≥n de la segunda parte del material, que informa sobre lo que est√° escribiendo un juego de palabras. <br><br>  <b>¬øQu√© es una tipificaci√≥n de juego de palabras?</b> <br><br>  Hemos llegado al punto en que podemos preguntarnos por qu√© podr√≠amos necesitar seud√≥nimos.  Por lo general, para la implementaci√≥n de juegos de palabras, tk.  Los m√©todos utilizados con frecuencia violan las estrictas reglas de alias. <br><br><img src="https://habrastorage.org/webt/dz/u-/cd/dzu-cdwp2tjct7bc-stnxfnptpe.png"><br><br>  A veces queremos evitar el sistema de tipos e interpretar el objeto como otro tipo.  Reinterpretar un segmento de memoria como otro tipo se llama <i>juego de palabras</i> .  Los juegos de palabras son √∫tiles para tareas que requieren acceso a la representaci√≥n base de un objeto para ver, transportar o manipular los datos proporcionados.  √Åreas t√≠picas donde podemos encontrar el uso de juegos de palabras: compiladores, serializaci√≥n, c√≥digo de red, etc. <a name="habracut"></a><br>  Tradicionalmente, esto se lograba tomando la direcci√≥n del objeto, convirti√©ndolo en un puntero al tipo al que queremos interpretar, y luego accediendo al valor, o en otras palabras, usando alias.  Por ejemplo: <br><br><pre><code class="bash hljs">int x = 1 ; //   C <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = (<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*)&amp;x ; //   //  C++ <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = reinterpret_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*&gt;(&amp;x) ; //   <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( ‚Äú%f\n‚Äù, *fp ) ;</code> </pre> <br>  Como vimos anteriormente, este es un alias inaceptable, esto causar√° un comportamiento indefinido.  Pero tradicionalmente, los compiladores no usaban reglas de alias estrictas, y este tipo de c√≥digo generalmente solo funcionaba, y los desarrolladores, desafortunadamente, est√°n acostumbrados a permitir tales cosas.  Un m√©todo alternativo com√∫n de tipeo es a trav√©s de la uni√≥n, que es v√°lida en C, pero causar√° un comportamiento indefinido en C ++ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ver ejemplo</a> ): <br><br><pre> <code class="bash hljs">union u1 { int n; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f; } ; union u1 u; uf = 1.0f; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n‚Äù, un ); // UB(undefined behaviour)  C++ ‚Äún is not the active member‚Äù</span></span></code> </pre> <br>  Esto es inaceptable en C ++, y algunos creen que las uniones est√°n destinadas √∫nicamente a implementar tipos de variantes, y consideran que usar uniones para escribir juegos de palabras es un abuso. <br><br>  <b>¬øC√≥mo implementar un juego de palabras?</b> <br><br>  El m√©todo est√°ndar bendecido para escribir juegos de palabras en C y C ++ es memcpy.  Esto puede parecer un poco complicado, pero el optimizador necesita reconocer el uso de memcpy para el juego de palabras, optimizarlo y generar un registro para registrar el movimiento.  Por ejemplo, si sabemos que int64_t tiene el mismo tama√±o que el doble: <br><br><pre> <code class="bash hljs">static_assert( sizeof( double ) == sizeof( int64_t ) ); // C++17   </code> </pre> <br>  Podemos usar <code>memcpy</code> : <br><br><pre> <code class="bash hljs">void func1( double d ) { std::int64_t n; std::memcpy(&amp;n, &amp;d, sizeof d); //‚Ä¶</code> </pre><br>  Con un nivel suficiente de optimizaci√≥n, cualquier compilador moderno decente genera un c√≥digo id√©ntico al m√©todo reinterpret_cast mencionado anteriormente o al m√©todo de uni√≥n para obtener un juego de palabras.  Al estudiar el c√≥digo generado, vemos que solo usa el registro mov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> ). <br><br>  <b>Tipos de juegos de palabras y matrices</b> <br><br>  Pero, ¬øqu√© sucede si queremos implementar el juego de palabras de una matriz de caracteres sin signo en una serie de int sin signo y luego realizar una operaci√≥n en cada valor int sin signo?  Podemos usar memcpy para convertir una matriz de caracteres sin signo en un tipo int sin nombre temporal.  El optimizador a√∫n podr√° ver todo a trav√©s de memcpy y optimizar tanto el objeto temporal como la copia, y trabajar directamente con los datos subyacentes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> ): <br><br><pre> <code class="bash hljs">//  ,    int foo( unsigned int x ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x ; } // ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = 0; std::memcpy( &amp;ui, &amp;p[index], sizeof(unsigned int) ); result += foo( ui ) ; } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre><br>  En este ejemplo, tomamos <code>char*p</code> , suponemos que apunta a varios fragmentos de <code>sizeof(unsigned int)</code> , interpretamos cada fragmento de datos como <code>unsigned int</code> , calculamos <code>foo()</code> para cada fragmento del juego de palabras, sumamos el resultado y devolvemos el valor final . <br><br>  El ensamblaje para el cuerpo del bucle muestra que el optimizador convierte el cuerpo en acceso directo a la matriz base de caracteres <code>unsigned int</code> como un <code>unsigned int</code> , y lo agrega directamente a <code>eax</code> : <br><br><pre> <code class="bash hljs">add eax, dword ptr [rdi + rcx]</code> </pre> <br>  El mismo c√≥digo, pero usando <code>reinterpret_cast</code> para implementar un juego de palabras (viola el alias estricto): <br><br><pre> <code class="bash hljs">// ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = *reinterpret_cast&lt;unsigned int*&gt;(&amp;p[index]); result += foo( ui ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre> <br>  <b>C ++ 20 y bit_cast</b> <br><br>  En C ++ 20, tenemos <code>bit_cast</code> , que proporciona una forma f√°cil y segura de interpretar, y tambi√©n se puede usar en el contexto de <code>constexpr</code> . <br><br>  El siguiente es un ejemplo de c√≥mo usar <code>bit_cast</code> para interpretar un entero sin signo en un <code>float</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> ): <br><br><pre> <code class="bash hljs">std::cout &lt;&lt; bit_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>&gt;(0x447a0000) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ; //,  sizeof(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) == sizeof(unsigned int)</code> </pre> <br>  En el caso de que los tipos To y From no tengan el mismo tama√±o, esto requiere que usemos una estructura intermedia.  Utilizaremos una estructura que contenga una matriz de caracteres m√∫ltiplos de <code>sizeof(unsigned int)</code> (se supone un 4-byte unsigned int) como tipo From y <code>unsigned int</code> como To. Tipo: <br><br><pre> <code class="bash hljs">struct uint_chars { unsigned char arr[sizeof( unsigned int )] = {} ; //  sizeof( unsigned int ) == 4 }; //  len  4 int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { uint_chars f; std::memcpy( f.arr, &amp;p[index], sizeof(unsigned int)); unsigned int result = bit_cast&lt;unsigned int&gt;(f); result += foo( result ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result ; }</code> </pre> <br>  Desafortunadamente, necesitamos este tipo intermedio: esta es la limitaci√≥n actual de <code>bit_cast</code> . <br><br>  <b>Alineaci√≥n</b> <br><br>  En ejemplos anteriores, vimos que la violaci√≥n de las estrictas reglas de alias puede conducir a la exclusi√≥n del almacenamiento durante la optimizaci√≥n.  La violaci√≥n del alias estricto tambi√©n puede conducir a la violaci√≥n de los requisitos de alineaci√≥n.  Tanto los est√°ndares C como C ++ dicen que los objetos est√°n sujetos a requisitos de alineaci√≥n que limitan el lugar donde los objetos pueden colocarse (en la memoria) y, por lo tanto, ser accesibles.  <i>C11 secci√≥n 6.2.8 Estados de alineaci√≥n de objetos</i> : <br><br>  Los tipos completos de objetos tienen requisitos de alineaci√≥n que imponen restricciones en las direcciones en las que se pueden colocar objetos de este tipo.  La alineaci√≥n es un valor entero definido por la implementaci√≥n que representa el n√∫mero de bytes entre direcciones consecutivas en las que se puede colocar este objeto.  El tipo de objeto impone un requisito de alineaci√≥n en cada objeto de este tipo: se puede solicitar una alineaci√≥n m√°s estricta utilizando la <code>_Alignas</code> . <br><br>  <b>El est√°ndar del proyecto C ++ 17 en la secci√≥n 1 [basic.align]</b> : <br><br>  Los tipos de objeto tienen requisitos de alineaci√≥n (6.7.1, 6.7.2) que imponen restricciones en las direcciones en las que se puede colocar un objeto de este tipo.  La alineaci√≥n es un valor entero definido por la implementaci√≥n que representa el n√∫mero de bytes entre direcciones consecutivas en las que se puede colocar un objeto determinado.  Un tipo de objeto impone un requisito de alineaci√≥n en cada objeto de este tipo;  Se puede solicitar una alineaci√≥n m√°s estricta utilizando el especificador de alineaci√≥n (10.6.2). <br><br>  Tanto C99 como C11 indican expl√≠citamente que una conversi√≥n que da como resultado un puntero no alineado es un comportamiento indefinido, secci√≥n 6.3.2.3.  <i>Punteros</i> dice: <br><blockquote>  Un puntero a un objeto o tipo parcial se puede convertir en un puntero a otro objeto o tipo parcial.  Si el puntero resultante no est√° alineado correctamente para el tipo de puntero, el comportamiento es indefinido.  ... <br></blockquote>  Aunque C ++ no es tan obvio, creo que esta oraci√≥n del p√°rrafo 1 <code>[basic.align]</code> suficiente: <br><blockquote>  ... El tipo de objeto impone un requisito de alineaci√≥n en cada objeto de este tipo;  ... </blockquote>  <i><b>Ejemplo</b></i> <br><br>  Entonces supongamos: <br><br><ul><li>  alignof (char) y alignof (int) son 1 y 4 respectivamente </li><li>  sizeof (int) es 4 </li></ul><br>  Por lo tanto, interpretar una matriz de caracteres de tama√±o 4 como <code>int</code> viola el alias estricto y tambi√©n puede violar los requisitos de alineaci√≥n si la matriz tiene una alineaci√≥n de 1 o 2 bytes. <br><br><pre> <code class="bash hljs">char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; //        1  2  int x = *reinterpret_cast&lt;int*&gt;(arr); // Undefined behavior  </code> </pre> <br>  Lo que puede resultar en un rendimiento reducido o error de bus en algunas situaciones.  Mientras que usar alignas para forzar la misma alineaci√≥n para una matriz en int evitar√° que se rompan los requisitos de alineaci√≥n: <br><br><pre> <code class="bash hljs">alignas(alignof(int)) char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; int x = *reinterpret_cast&lt;int*&gt;(arr);</code> </pre> <br>  <i><b>Atomicidad</b></i> <br><br>  Otro castigo inesperado para el acceso desequilibrado es que viola la atomicidad de algunas arquitecturas.  Los almacenes at√≥micos pueden no parecer at√≥micos para otros hilos en x86 si no est√°n alineados. <br><br>  <b>Capturar infracciones estrictas de alias</b> <br><br>  No tenemos muchas buenas herramientas para rastrear alias estricto en C ++.  Las herramientas que tenemos detectar√°n algunos casos de violaciones y algunos casos de carga y almacenamiento incorrectos. <br><br>  gcc usando los <code>-fstrict-aliasing</code> y <code>-Wstrict-aliasing</code> puede detectar algunos casos, aunque no sin falsos positivos / problemas.  Por ejemplo, los siguientes casos generar√°n una advertencia en gcc ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> ): <br><br><pre> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.f; //   ,   TIS ,         <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(&amp;a))); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;int*&gt;(&amp;f)));</code> </pre> <br>  aunque no captar√° este caso adicional ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> ): <br><br><pre> <code class="bash hljs">int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(p)));</code> </pre><br>  Aunque el <code>clang</code> resuelve estas banderas, no parece implementar realmente la advertencia. <br><br>  Otra herramienta que tenemos es ASan, que puede detectar la grabaci√≥n y el almacenamiento desalineados.  Aunque no son violaciones directas de alias estricto, este es un resultado bastante com√∫n.  Por ejemplo, los siguientes casos generar√°n errores de tiempo de ejecuci√≥n durante el ensamblaje usando clang usando <code>-fsanitize=address</code> <br><br><pre> <code class="bash hljs">int *x = new int[2]; // 8 : [0,7]. int *u = (int*)((char*)x + 6); //     x    *u = 1; //    [6-9] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *u ); //    [6-9]</code> </pre> <br>  La √∫ltima herramienta que recomiendo es espec√≠fica para C ++ y, de hecho, no es solo una herramienta, sino tambi√©n una pr√°ctica de codificaci√≥n que no permite la conversi√≥n al estilo C. Tanto <code>gcc</code> como <code>clang</code> realizar√°n diagn√≥sticos para <code>-Wold-style-cast</code> C usando <code>-Wold-style-cast</code> .  Esto obligar√° a los juegos de palabras indefinidos a utilizar reinterpret_cast.  En general, <code>reinterpret_cast</code> deber√≠a ser una se√±al para un an√°lisis m√°s completo del c√≥digo. <br>  Tambi√©n es m√°s f√°cil buscar en la base de c√≥digo <code>reinterpret_cast</code> para realizar una auditor√≠a. <br><br>  Para C, tenemos todas las herramientas que ya est√°n descritas, y tambi√©n tenemos <code>tis-interpreter</code> , un analizador est√°tico que analiza exhaustivamente el programa para un gran subconjunto de C. Dadas las versiones C del ejemplo anterior, donde el uso de -fstrict-aliasing omite un caso ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> ) <br><br><pre> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.0 ; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)&amp;a)); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((int*)&amp;f)); int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)p));</code> </pre><br>  El int√©rprete TIS puede interceptar los tres, el siguiente ejemplo llama al n√∫cleo TIS como int√©rprete TIS (la salida se edita por brevedad): <br><br><pre> <code class="bash hljs">./bin/tis-kernel -sa example1.c ... example1.c:9:[sa] warning: The pointer (short *)(&amp; a) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int. ... example1.c:10:[sa] warning: The pointer (int *)(&amp; f) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>. Callstack: main ... example1.c:15:[sa] warning: The pointer (short *)p has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int.</code> </pre> <br>  Y finalmente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TySan</a> , que est√° en desarrollo.  Este desinfectante agrega informaci√≥n de verificaci√≥n de tipo al segmento de memoria secundaria y verifica los accesos para determinar si violan las reglas de alias.  La herramienta deber√≠a ser capaz de rastrear todas las violaciones de alias, pero puede tener una gran sobrecarga en tiempo de ejecuci√≥n. <br><br>  <b>Conclusi√≥n</b> <br><br>  Aprendimos sobre las reglas de alias en C y C ++, lo que significa que el compilador espera que sigamos estrictamente estas reglas y aceptemos las consecuencias de no cumplirlas.  Hemos aprendido algunas herramientas que pueden ayudarnos a identificar algunos abusos de seud√≥nimo.  Hemos visto que el uso habitual de aliasing es un juego de palabras de tipificaci√≥n.  Tambi√©n aprendimos c√≥mo implementarlo correctamente. <br><br>  Los optimizadores est√°n mejorando gradualmente el an√°lisis de alias basado en tipos y ya est√°n rompiendo algunos c√≥digos que se basan en violaciones estrictas de alias.  Podemos esperar que las optimizaciones mejoren y rompan a√∫n m√°s c√≥digo que antes funcionaba. <br><br>  Tenemos m√©todos compatibles est√°ndar listos para interpretar tipos.  A veces, para las construcciones de depuraci√≥n, estos m√©todos deben ser abstracciones libres.  Tenemos varias herramientas para detectar violaciones graves de alias, pero para C ++ solo detectar√°n una peque√±a parte de los casos, y para C usando el int√©rprete tis podemos rastrear la mayor√≠a de las violaciones. <br><br>  Gracias a quienes comentaron sobre este art√≠culo: JF Bastien, Christopher Di Bella, Pascal Quoc, Matt P. Dziubinski, Patrice Roy y Olafur Vaage <br>  Por supuesto, al final, todos los errores pertenecen al autor. <br><br>  As√≠ que la traducci√≥n de un material bastante grande ha llegado a su fin, la primera parte de la cual se puede leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Y tradicionalmente lo invitamos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la jornada de puertas abiertas</a> , que se llevar√° a cabo el 14 de marzo por el jefe del departamento de desarrollo de tecnolog√≠a en Rambler &amp; Co - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dmitry Shebordaev.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443602/">https://habr.com/ru/post/443602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443588/index.html">El profesor del Instituto de Tecnolog√≠a de Massachusetts revela el futuro de las pr√≥tesis en TED</a></li>
<li><a href="../443590/index.html">Ciencia de datos: predicci√≥n de eventos empresariales para mejorar el servicio</a></li>
<li><a href="../443592/index.html">RFID front end ISO 11785 est√°ndar de un antiguo receptor de FM y desechos de elevador</a></li>
<li><a href="../443594/index.html">La encrucijada de las pruebas y la arquitectura: una entrevista con Neil Ford</a></li>
<li><a href="../443600/index.html">Las mejores y peores tendencias del MWC 2019</a></li>
<li><a href="../443604/index.html">M√ìVIL PRIMERO: Hackathon en OZON</a></li>
<li><a href="../443606/index.html">Jenkins para Android con Docker</a></li>
<li><a href="../443608/index.html">Smart Home / Actualizaciones en Lazurite</a></li>
<li><a href="../443612/index.html">Usamos viejos discos duros malos</a></li>
<li><a href="../443614/index.html">YouTrack 2019.1: seleccione paneles √°giles, campos de tarjetas personalizables en paneles √°giles y m√°s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>