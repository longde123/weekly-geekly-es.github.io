<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆔 🐪 🔃 Spring Boot上的TDD应用程序：微调测试并使用上下文 🤛🏿 🙌🏼 🧒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本系列的第三篇文章以及主要系列的一个小分支-这次，我将展示Spring Integration Testing库如何工作以及它是如何工作的，在测试开始时会发生什么，以及如何微调应用程序及其测试环境。 


 Hixon10 注释提示我写这篇文章，内容涉及如何在集成测试中使用真实的基础，例如Postg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Boot上的TDD应用程序：微调测试并使用上下文</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446184/"><p>本系列的第三篇文章以及主要系列的一个小分支-这次，我将展示Spring Integration Testing库如何工作以及它是如何工作的，在测试开始时会发生什么，以及如何微调应用程序及其测试环境。 </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Hixon10</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">注释</a>提示我写这篇文章，内容涉及如何在集成测试中使用真实的基础，例如Postgres。 评论作者建议使用便利的全包式库<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Embedded-database-spring-test</a> 。 并且我已经在代码中添加了一个段落和一个使用示例，但是后来我想到了。 当然，使用现成的库是正确且良好的，但是如果目标是<em>了解如何</em>为Spring应用程序<em>编写测试</em> ，那么展示如何自己实现相同的功能将更加有用。 首先，这是谈论<strong>Spring Test</strong>内幕的重要原因。 其次，我相信您不能依赖第三方库，如果您不了解它们在内部的排列方式，只会导致强化技术“魔术”神话。 </p><br><p> 这次将没有用户功能，但将有一个需要解决的问题- <em>我想在随机端口上启动真实数据库并将应用程序自动连接到该临时数据库，并且在测试后我停止并删除数据库。</em> </p><br><p> 首先，按照惯例，有些理论。 对于不太熟悉bin，上下文，配置概念的人们，我建议您刷新知识，例如，在我的文章The <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spring / Habr</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反面</a> 。 </p><br><h1 id="spring-test"> 春季测试 </h1><br><p>  Spring Test是Spring框架中包含的库之一，实际上，有关集成测试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的文档部分中</a>描述的所有内容都与此相关。 该库解决的四个主要任务是： </p><br><ul><li> 管理Spring IoC容器及其在测试之间的缓存 </li><li> 提供测试类的依赖注入 </li><li> 提供适合集成测试的事务管理 </li><li> 提供一组基类，以帮助开发人员编写集成测试 </li></ul><br><p> 我强烈建议您阅读官方文档，其中包含许多有用和有趣的内容。 在这里，我将快速介绍一些实用的提示，以帮助您牢记。 </p><br><h1 id="zhiznennyy-cikl-testa"> 测试生命周期 </h1><br><p><img src="https://habrastorage.org/webt/si/oq/ed/sioqedpwtepmojxgj2fqzcyy-d0.jpeg"><br> 测试的生命周期如下所示： </p><br><ol><li>测试框架的扩展（用于JUnit 4的<code>SpringExtension</code>和用于JUnit 5的<code>SpringExtension</code> ）调用Test Context Bootstrapper </li><li>  Boostrapper创建<code>TestContext</code>存储测试和应用程序当前状态的主类 </li><li>  <code>TestContext</code>设置不同的钩子（例如在测试之前启动事务，在测试之后回滚），将依赖项注入测试类（测试类上的所有<code>@Autowired</code>字段）并创建上下文 </li><li> 使用<em>上下文加载器</em>创建<em>上下文</em> -它采用应用程序的基本配置，并将其与测试配置合并（重叠的属性，配置文件，容器，初始化程序等）。 </li><li> 使用完整描述应用程序的复合键（一组容器，属性等）缓存上下文。 </li><li> 试运行 </li></ol><br><blockquote> 实际上，所有管理测试的工作都是通过<code>spring-test</code> ，而<code>Spring Boot Test</code>又会添加几个帮助器类，例如熟悉的<code>@DataJpaTest</code>和<code>@SpringBootTest</code>和有用的实用程序（如<code>TestPropertyValues</code>来动态更改上下文属性。 它还允许您将应用程序作为真实的Web服务器或模拟环境（无法通过HTTP访问）运行，使用<code>@MockBean</code>等擦除系统组件非常方便。 </blockquote><br><h1 id="keshirovanie-konteksta"> 上下文缓存 </h1><br><p> 集成测试中引起很多问题和误解的一个非常晦涩的主题之一可能是测试之间的<strong>上下文缓存</strong> （请参阅上面的第5段）及其对测试速度的影响。 我经常听到的一个评论是，集成测试“缓慢”并且“为每个测试运行应用程序”。 因此，它们确实可以运行-但并非每次测试都可以。 每个上下文（即应用程序实例）将得到最大程度的重用，即 如果10个测试使用相同的应用程序配置，则该应用程序将对所有10个测试启动一次。 应用程序的“相同配置”是什么意思？ 对于Spring Test，这意味着Bean，配置类，概要文件，属性等的集合未更改。 实际上，这意味着，例如，这两个测试将使用相同的上下文： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ActiveProfiles</span></span>(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@TestPropertySource</span></span>(<span class="hljs-string"><span class="hljs-string">"foo=bar"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstTest</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ActiveProfiles</span></span>(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@TestPropertySource</span></span>(<span class="hljs-string"><span class="hljs-string">"foo=bar"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondTest</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><blockquote> 缓存中的上下文数限制为32-此外，根据LRSU原理，将从缓存中删除其中一个上下文。 </blockquote><p> 是什么可以阻止Spring Test重用缓存中的上下文并创建一个新的上下文？ </p><br><p>  <strong>@DirtiesContext</strong> <br> 最简单的选项是，如果测试带有注释标记，则不会缓存上下文。 如果测试更改了应用程序的状态并且您想“重置”它，这将很有用。 </p><br><p>  <strong>@MockBean</strong> <br> 一个非常不明显的选项，我什至单独渲染了它-@MockBean用可以通过Mockito测试的模拟代替了上下文中的真实bean（在以下文章中，我将展示如何使用它）。 关键是该注释<em>更改了</em>应用程序中<em>的bean集合，</em>并强制Spring Test创建新的上下文。 例如，如果我们以前面的示例为例，将在此处创建两个上下文： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ActiveProfiles</span></span>(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@TestPropertySource</span></span>(<span class="hljs-string"><span class="hljs-string">"foo=bar"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstTest</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ActiveProfiles</span></span>(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@TestPropertySource</span></span>(<span class="hljs-string"><span class="hljs-string">"foo=bar"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@MockBean</span></span> CakeFinder cakeFinderMock; }</code> </pre> <br><p>  <strong>@TestPropertySource</strong> <br> 任何属性更改都会自动更改缓存键，并创建一个新的上下文。 </p><br><p>  <strong>@ActiveProfiles</strong> <br> 更改活动配置文件也会影响缓存。 </p><br><p>  <strong>@ContextConfiguration</strong> <br> 当然，任何配置更改也将创建新的上下文。 </p><br><h1 id="zapuskaem-bazu"> 我们开始基地 </h1><br><p> 因此，现在借助所有这些知识，我们将尝试 <del> 起飞 </del> 了解如何以及在何处可以运行数据库。 这里没有一个正确的答案，它取决于要求，但是您可以想到两个选择： </p><br><ol><li> 在类中的所有测试之前运行一次。 </li><li> 为每个缓存的上下文（可能多个类）运行一个随机实例和一个单独的数据库。 </li></ol><br><p> 根据要求，您可以选择任何选项。 如果以我为例，Postgres相对较快地启动，并且第二个选项看起来合适，那么第一个选项可能适合更困难的事情。 </p><br><blockquote> 第一个选项不依赖于Spring，而是依赖于测试框架。 例如，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对JUnit 5</a>进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">扩展</a> 。 </blockquote><p> 如果将有关测试库，上下文和缓存的所有知识放到一起，则任务归结为以下内容： <em>创建新的应用程序上下文时，需要在随机端口上运行数据库并将连接数据传输到上下文</em> 。 </p><br><p>  <code>ApplicationContextInitializer</code>接口负责在Spring中启动之前对上下文执行操作。 </p><br><h1 id="applicationcontextinitializer">  ApplicationContextInitializer </h1><br><p> 该接口只有一个<code>initialize</code>方法，该方法在“启动”上下文之前（即在调用<code>refresh</code>方法之前）执行，并且允许您对上下文进行更改-添加容器，属性。 </p><br><p> 就我而言，该类如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmbeddedPostgresInitializer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContextInitializer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericApplicationContext</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GenericApplicationContext applicationContext)</span></span></span><span class="hljs-function"> </span></span>{ EmbeddedPostgres postgres = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmbeddedPostgres(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { String url = postgres.start(); TestPropertyValues values = TestPropertyValues.of( <span class="hljs-string"><span class="hljs-string">"spring.test.database.replace=none"</span></span>, <span class="hljs-string"><span class="hljs-string">"spring.datasource.url="</span></span> + url, <span class="hljs-string"><span class="hljs-string">"spring.datasource.driver-class-name=org.postgresql.Driver"</span></span>, <span class="hljs-string"><span class="hljs-string">"spring.jpa.hibernate.ddl-auto=create"</span></span>); values.applyTo(applicationContext); applicationContext.registerBean(EmbeddedPostgres.class, () -&gt; postgres, beanDefinition -&gt; beanDefinition.setDestroyMethodName(<span class="hljs-string"><span class="hljs-string">"stop"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } } }</code> </pre> <br><p> 发生的第一件事是从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">yandex-qatools / postgresql嵌入式</a>库启动嵌入式Postgres。 然后，创建一组属性-新启动的基础的JDBC URL，驱动程序类型和方案的Hibernate行为（自动创建）。 一个不明显的事情就是<code>spring.test.database.replace=none</code>这就是告诉我们的数据，我们不必尝试连接到嵌入式数据库（例如H2），也不需要替换DataSource bin（这是可行的）。 </p><br><p> 另外一个要点是<code>application.registerBean(…)</code> 。 通常，此bean当然不能注册-如果没有人在应用程序中使用它，则不是特别需要。 仅需要注册来指定销毁上下文时Spring将调用的destroy方法，在我的情况下，此方法将调用<code>postgres.stop()</code>并停止数据库。 </p><br><p> 总的来说，魔术就结束了，如果有的话。 现在，我将在测试上下文中注册此初始化程序： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(initializers = EmbeddedPostgresInitializer.class) ...</code> </pre> <br><p> 甚至为了方便起见，您可以创建自己的注释，因为我们都喜欢注释！ </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.TYPE) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(initializers = EmbeddedPostgresInitializer.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> EmbeddedPostgresTest { }</code> </pre> <br><p> 现在，任何由<code>@EmbeddedPostgrestTest</code>注释的测试都将在一个随机端口上启动一个具有随机名称的数据库，将Spring配置为连接到该数据库，并在测试结束时将其停止。 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EmbeddedPostgresTest</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaCakeFinderTestWithEmbeddedPostgres</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><h1 id="zaklyuchenie"> 结论 </h1><br><p> 我想证明在Spring中没有神秘的魔术，只有很多“智能”和灵活的内部机制，但是知道了它们，您就可以完全控制测试和应用程序本身。 通常，在战斗项目中，我不会激励每个人编写用于设置测试集成环境的方法和类，如果有现成的解决方案，则可以采用。 尽管如果整个方法是5行代码，那么可能会不必要地将依赖项拖到项目中，尤其是不了解实现。 </p><br><h1 id="ssylki-na-ostalnye-stati-serii"> 指向本系列其他文章的链接 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何在Spring Boot的主干或测试驱动的开发应用程序中构建金字塔</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spring Boot上的TDD应用程序：使用数据库</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446184/">https://habr.com/ru/post/zh-CN446184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446162/index.html">如何成为“智能大三”。 个人经历</a></li>
<li><a href="../zh-CN446172/index.html">限制消息API VK-怎么办</a></li>
<li><a href="../zh-CN446174/index.html">PHP中的Yandex.Alice和Telegram机器人具有单一功能</a></li>
<li><a href="../zh-CN446176/index.html">使用机器学习方法在视频流中进行坦克识别（在Elbrus和Baikal平台上有+2个视频）</a></li>
<li><a href="../zh-CN446180/index.html">MongoDB绝对是正确的选择吗？</a></li>
<li><a href="../zh-CN446186/index.html">埃隆·马斯克（Elon Musk）如何在特斯拉（Tesla）的队伍中摧毁线人，这是怎么回事</a></li>
<li><a href="../zh-CN446188/index.html">现在是表情符号URL的时间了吗？</a></li>
<li><a href="../zh-CN446190/index.html">我的家庭自动化系统。 创建操作系统映像</a></li>
<li><a href="../zh-CN446192/index.html">历史记录备份：您可能没有听说过的七位发明家</a></li>
<li><a href="../zh-CN446194/index.html">新Galatea或为科幻小说改编机器人女孩动画</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>