<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèæ üíû ü§úüèΩ Toda la verdad sobre RTOS. Art√≠culo # 14. Secciones de memoria: introducci√≥n y servicios b√°sicos. üòä üßõüèº üå¶Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las secciones de memoria se mencionaron anteriormente en uno de los art√≠culos anteriores (# 6), donde se realiz√≥ una comparaci√≥n con la funci√≥n est√°nd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Art√≠culo # 14. Secciones de memoria: introducci√≥n y servicios b√°sicos.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426425/"><img src="https://habrastorage.org/webt/nh/9i/nk/nh9inkxdyuljdn4wesz0e-lpjhg.jpeg"><br><br>  Las secciones de memoria se mencionaron anteriormente en uno de los art√≠culos anteriores (# 6), donde se realiz√≥ una comparaci√≥n con la funci√≥n est√°ndar del lenguaje C <b>malloc ()</b> .  Una partici√≥n es una regi√≥n de memoria obtenida de un grupo de particiones (grupo de memoria).  Compartir memoria proporciona una forma flexible de asignar y liberar memoria de manera confiable y determinista. <br><a name="habracut"></a><br>  Art√≠culos anteriores de la serie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructuras de datos de tareas y llamadas de API no compatibles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios para trabajar con tareas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas: configuraci√≥n e introducci√≥n a la API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: funciones avanzadas y preservaci√≥n del contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nucleus SE: dise√±o interno y despliegue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N√∫cleo SE: Introducci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros servicios RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci√≥n de tareas y sincronizaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci√≥n.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> <br><h2>  Usando secciones </h2><br>  En Nucleus SE, las agrupaciones de particiones se configuran en el momento de la creaci√≥n.  Una sola aplicaci√≥n puede tener hasta 16 grupos de particiones.  Si no est√°n configurados, las estructuras de datos y las llamadas de servicio relacionadas con estos grupos no se incluir√°n en la aplicaci√≥n. <br><br>  Un grupo de particiones es un √°rea de memoria dividida en un cierto n√∫mero de bloques de un tama√±o fijo.  El desarrollador tiene control total sobre el tama√±o y el n√∫mero de particiones en cada grupo.  Las tareas pueden solicitar secciones asignadas de memoria y recibir un puntero al √°rea de almacenamiento y no deben escribir datos fuera de la secci√≥n asignada.  Cualquier secci√≥n puede liberar una secci√≥n al pasar un puntero a una funci√≥n API.  Una solicitud para asignar una partici√≥n cuando no hay particiones libres puede provocar un error o una suspensi√≥n de la solicitud, dependiendo de los par√°metros de llamada API seleccionados y la configuraci√≥n de Nucleus SE. <br><br><h2>  Configurar particiones de memoria </h2><br><h3>  N√∫mero de agrupaciones de partici√≥n </h3><br>  Como con la mayor√≠a de los objetos de Nucleus SE, la configuraci√≥n del grupo de particiones se realiza principalmente utilizando la directiva <b>#define</b> en <b>nuse_config.h</b> .  El par√°metro principal es <b>NUSE_PARTITION_POOL_NUMBER</b> , que determina cu√°ntos grupos de particiones se definen en la aplicaci√≥n.  El valor predeterminado es 0 (es decir, no se usan grupos de particiones), el desarrollador puede establecer cualquier valor de 0 a 16. Otros valores conducir√°n a un error de compilaci√≥n, que se detect√≥ durante la verificaci√≥n en <b>nuse_config_check.h</b> (se incluye en <b>nuse_config.c</b> , y , por lo tanto, compila con este m√≥dulo), lo que lleva a la compilaci√≥n de la directiva <b>#error</b> . <br><br>  Elegir un valor distinto de cero es una forma prioritaria de activar grupos de particiones.  Esto lleva a la definici√≥n de estructuras de datos y a la asignaci√≥n del tama√±o apropiado.  Las estructuras de datos en la ROM deben inicializarse con los valores apropiados que describen cada grupo de particiones.  M√°s detalles sobre las estructuras de datos estar√°n en el pr√≥ximo art√≠culo.  Esta selecci√≥n tambi√©n activa la configuraci√≥n de la API. <br><br><h3>  Activar llamadas API </h3><br>  Cada funci√≥n API (llamada de utilidad) en Nucleus SE se activa mediante la directiva <b>#define</b> en <b>nuse_config.h</b> .  Para los grupos de particiones, estos incluyen: <br><br>  <b>NUSE_PARTITION_ALLOCATE</b> <br>  <b>NUSE_PARTITION_DEALLOCATE</b> <br>  <b>NUSE_PARTITION_POOL_INFORMATION</b> <br>  <b>NUSE_PARTITION_POOL_COUNT</b> <br><br>  Por defecto, todos est√°n configurados en <b>FALSO</b> , deshabilitando as√≠ cada llamada de servicio y evitando la inclusi√≥n de un c√≥digo de implementaci√≥n.  Para configurar los grupos de particiones en la aplicaci√≥n, debe seleccionar las llamadas API necesarias y establecer las directivas correspondientes en <b>TRUE</b> . <br><br>  Lo siguiente es un extracto del archivo predeterminado <b>nuse_config.h</b> : <br><br><img src="https://habrastorage.org/webt/gm/ih/_b/gmih_baxfyopw1op4ujx2t2fzue.jpeg"><br><br>  Si la funci√≥n API Partition Pools est√° activada, pero los pools no est√°n configurados, se produce un error de compilaci√≥n (a excepci√≥n de <b>NUSE_Partition_Pool_Count ()</b> , que siempre est√° habilitado).  Si su c√≥digo usa una llamada API que no ha sido activada, se producir√° un error de dise√±o porque el c√≥digo de implementaci√≥n no se incluy√≥ en la aplicaci√≥n. <br><br><h2>  Partition Pool Utility Calls </h2><br>  Nucleus RTOS admite siete llamadas de utilidad relacionadas con grupos de particiones, que proporcionan la siguiente funcionalidad: <br><br><table><tbody><tr><th>  <b>Descripci√≥n Funcional</b> </th><th>  <b>N√∫cleo RTOS</b> </th><th>  <b>N√∫cleo SE</b> </th></tr><tr><td>  Selecci√≥n de secci√≥n </td><td>  <b>NU_Allocate_Partition ()</b> </td><td>  <b>NUSE_Partition_Allocate ()</b> </td></tr><tr><td>  Lanzamiento de secci√≥n </td><td>  <b>NU_Deallocate_Partition ()</b> </td><td>  <b>NUSE_Partition_Deallocate ()</b> </td></tr><tr><td>  Proporcionar informaci√≥n <br>  sobre un grupo de particiones particular </td><td>  <b>NU_Partition_Pool_Information ()</b> </td><td>  <b>NUSE_Partition_Pool_Information ()</b> </td></tr><tr><td>  Devuelve el valor de la cantidad (actualmente) configurada <br>  grupos de aplicaciones </td><td>  <b>NU_Established_Partition_Pools ()</b> </td><td>  <b>NUSE_Partition_Pool_Count ()</b> </td></tr><tr><td>  Agregar (crear) un nuevo grupo de particiones a la aplicaci√≥n </td><td>  <b>NU_Create_Partition_Pool ()</b> </td><td>  No implementado </td></tr><tr><td>  Cambiar (eliminar) un grupo de particiones de una aplicaci√≥n </td><td>  <b>NU_Delete_Partition_Pool ()</b> </td><td>  No implementado </td></tr><tr><td>  Devoluci√≥n de punteros a todos los grupos de particiones actualmente existentes en la aplicaci√≥n </td><td>  <b>NU_Partition_Pool_Pointers ()</b> </td><td>  No implementado </td></tr></tbody></table><br>  La implementaci√≥n de cada llamada se discutir√° en detalle. <br><br>  Vale la pena se√±alar que ni Nucleus RTOS ni Nucleus SE tienen una funci√≥n de reinicio.  Esto se hace a prop√≥sito.  Muy a menudo, una tarea asigna una secci√≥n y pasa un puntero a otra tarea (que luego puede liberarla).  Si vuelve a cargar el grupo de particiones, todas las particiones se marcar√°n como no utilizadas, sin embargo, no hay ning√∫n mecanismo para supervisar y notificar todas las tareas que pueden usar particiones. <br><br><h2>  Servicios de partici√≥n y liberaci√≥n </h2><br>  Las operaciones fundamentales con los grupos de particiones son la asignaci√≥n de particiones en el grupo (es decir, marcar la partici√≥n como utilizada y devolver su direcci√≥n) y liberar la partici√≥n (es decir, la partici√≥n se marca como no utilizada).  Nucleus RTOS y Nucleus SE proporcionan dos llamadas API b√°sicas para estas operaciones, que se describen a continuaci√≥n. <br><br><h3>  Selecci√≥n de secci√≥n </h3><br>  Llamar a la API de Nucleus RTOS para asignar una partici√≥n es muy flexible, lo que permite a los desarrolladores pausar tareas por un per√≠odo de tiempo indefinido o sin un tiempo de espera si la operaci√≥n no se puede completar de inmediato, por ejemplo, cuando intenta asignar una partici√≥n de un grupo en el que todas las particiones ya est√°n distribuidas.  Nucleus SE proporciona el mismo servicio, solo detener las tareas es opcional y no se implementa un tiempo de espera. <br><br><h3>  Nucleus RTOS API Call to Partition </h3><br>  Prototipo de llamada: <br><br>  <b>ESTADO NU_Allocate_Partition (NU_PARTITION_POOL * pool, VOID ** return_pointer, UNSIGNED suspend));</b> <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_NO_PARTITION</b> : no hay secciones disponibles; <br>  <b>NU_INVALID_POOL</b> : puntero de agrupaci√≥n de particiones no v√°lido; <br>  <b>NU_INVALID_POINTER</b> : pas√≥ un puntero nulo a los datos devueltos ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> : se realiz√≥ un intento de suspender una tarea desde un hilo no asociado con la tarea; <br>  <b>NU_TIMEOUT</b> : no hay particiones disponibles, incluso despu√©s de la suspensi√≥n durante el per√≠odo de espera especificado; <br>  <b>NU_POOL_DELETED</b> : el grupo de particiones se elimin√≥ cuando se suspendi√≥ la tarea. <br><br><h3>  Llamada de Nucleus SE API para resaltar una partici√≥n </h3><br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada: <br><br>  <b>ESTADO NUSE_Partition_Allocate (grupo NUSE_PARTITION_POOL, ADDR * return_pointer, U8 suspendido);</b> <br><br>  Par√°metros: <br><br>  <b>pool</b> - √≠ndice (ID) del pool de particiones usado; <br>  <b>return_pointer</b> : puntero a una variable de tipo <b>ADDR</b> , que toma la direcci√≥n de la secci√≥n seleccionada; <br>  <b>suspender</b> : par√°metro para pausar la tarea; puede tomar los valores <b>NUSE_NO_SUSPEND</b> o <b>NUSE_SUSPEND</b> . <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_NO_PARTITION</b> : no hay secciones disponibles; <br>  <b>NUSE_INVALID_POOL</b> : √≠ndice de agrupaci√≥n de particiones no v√°lido; <br>  <b>NUSE_INVALID_POINTER</b> : pas√≥ un puntero nulo a los datos devueltos ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND:</b> se realiz√≥ un intento de suspender una tarea desde un subproceso no asociado con la tarea o cuando las API de bloqueo estaban deshabilitadas. <br><br><h3>  Implementaci√≥n de asignaci√≥n de partici√≥n en Nucleus SE </h3><br>  El c√≥digo de funci√≥n API <b>NUSE_Partition_Allocate</b> se selecciona mediante compilaci√≥n condicional despu√©s de verificar los par√°metros, dependiendo de si la llamada API a bloquear (suspender tareas) est√° activada o no.  A continuaci√≥n, consideraremos por separado estas dos opciones. <br><br>  Si las llamadas de bloqueo est√°n desactivadas, la llamada API es bastante simple: <br><br><img src="https://habrastorage.org/webt/se/0i/fx/se0ifxxbybhe2mjp5owlfc2zrr0.jpeg"><br><br>  Primero, se verifica la disponibilidad de particiones gratuitas.  Si no hay tales particiones, se devuelve un error ( <b>NUSE_NO_PARTITION</b> ).  Luego hay una enumeraci√≥n de secciones, durante la cual los primeros bytes se verifican para valores cero (lo que indica que la secci√≥n no se usa).  Cuando se encuentra dicha partici√≥n, se le asigna el indicador "usado", que incluye el √≠ndice del grupo de particiones (consulte "Liberar la partici√≥n" a continuaci√≥n) y devuelve un puntero al siguiente byte (el comienzo del √°rea de datos real).  Las explicaciones sobre las estructuras de datos de los grupos de particiones se presentar√°n en el siguiente art√≠culo en la secci√≥n Estructuras de datos. <br><br>  Si el bloqueo est√° activado, el c√≥digo para esta llamada API se vuelve un poco m√°s complicado: <br><br><img src="https://habrastorage.org/webt/y_/os/bd/y_osbdsgsaqfon1cm0351zzxbxq.jpeg"><br><br>  El c√≥digo est√° encerrado en un <b>bucle do ... while</b> que contin√∫a ejecut√°ndose mientras el par√°metro de pausa sea <b>NUSE_SUSPEND</b> . <br><br>  Si no hay particiones disponibles y el par√°metro de pausa es <b>NUSE_NO_SUSPEND</b> , la llamada a la API se detiene y devuelve <b>NUSE_NO_PARTITION</b> .  Si el par√°metro de pausa se estableci√≥ en <b>NUSE_SUSPEND</b> , la tarea se detiene.  Al regresar (por ejemplo, cuando se reanuda una tarea), el valor de retorno de <b>NUSE_SUCCESS</b> indica que la tarea se reanud√≥ porque la secci√≥n de memoria se liber√≥ y el c√≥digo vuelve al comienzo del bucle.  Dado que no hay funciones de API para recargar los grupos de particiones, las tareas no se pueden reanudar por otras razones, sino por la estabilidad de bloquear otros tipos de objetos, el proceso de validaci√≥n <b>NUSE_Task_Blocking_Return []</b> se conserva. <br><br><h3>  Lanzamiento de secci√≥n </h3><br>  El lanzamiento de la secci√≥n en Nucleus RTOS y Nucleus SE lo vuelve a poner a disposici√≥n.  Antes del lanzamiento, no verifica si esta secci√≥n es utilizada por alguna tarea o no, el programador de la aplicaci√≥n es responsable de esto.  Solo se necesita un puntero a un √°rea de datos para liberar una secci√≥n. <br><br><h3>  Nucleus RTOS API Call to Free Partition </h3><br>  Prototipo de llamada: <br><br>  <b>ESTADO NU_Deallocate_Partition (VOID * partici√≥n);</b> <br><br>  Par√°metros: <br><br>  <b>partici√≥n</b> : un puntero al √°rea de datos (devuelto por la funci√≥n <b>NU_Allocate_Partition ()</b> ) de la partici√≥n que se va a liberar; <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_POINTER</b> : puntero de secci√≥n NULL o no indica que se haya usado una secci√≥n v√°lida. <br><br><h3>  Llamada de Nucleus SE API a partici√≥n libre </h3><br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada: <br><br>  <b>ESTADO NUSE_Partition_Deallocate (partici√≥n ADDR);</b> <br><br>  Par√°metros: <br><br>  <b>partici√≥n</b> : un puntero al √°rea de datos (devuelto por la funci√≥n <b>NUSE_Partition_Allocate ()</b> ) de la partici√≥n a liberar <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_POINTER</b> : el puntero de secci√≥n es nulo ( <b>NULL</b> ) o no indica una secci√≥n v√°lida utilizada <br><br><h3>  Implementaci√≥n </h3><br>  En lugar de implementar usando las funciones API de bloqueo y no bloqueo, la funci√≥n <b>NUSE_Partition_Deallocate ()</b> simplemente contiene una secci√≥n compilada condicionalmente que es responsable de desbloquear las tareas.  Este c√≥digo implementa la liberaci√≥n de secciones: <br><br><img src="https://habrastorage.org/webt/sz/ro/zl/szrozlvg_xc8hbpeqmthmmdbm7a.jpeg"><br><br>  Primero, el √≠ndice de secci√≥n se recupera del byte de estado.  Luego, el estado de la partici√≥n cambia a "no utilizado", el contador de particiones usadas disminuye y la funci√≥n informa la finalizaci√≥n exitosa de la operaci√≥n. <br><br>  Si el bloqueo est√° activado, el siguiente c√≥digo se utiliza para reanudar las tareas que esperan el grupo de particiones disponible: <br><br><img src="https://habrastorage.org/webt/9k/jm/3w/9kjm3wbdcj1lj6ruhimnhm67xva.jpeg"><br><br>  Si las tareas se bloquearon al asignar particiones en este grupo, se reanuda la primera tabla. <br><br>  En el pr√≥ximo art√≠culo, hablaremos sobre llamadas API adicionales relacionadas con particiones de memoria, as√≠ como estructuras de datos relacionadas. <br><br>  <b>Sobre el autor:</b> Colin Walls ha trabajado en la industria electr√≥nica durante m√°s de treinta a√±os, dedicando la mayor parte de su tiempo al firmware.  Ahora es ingeniero de firmware en Mentor Embedded (una divisi√≥n de Mentor Graphics).  Colin Walls a menudo habla en conferencias y seminarios, autor de numerosos art√≠culos t√©cnicos y dos libros sobre firmware.  Vive en el Reino Unido. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426425/">https://habr.com/ru/post/es426425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426415/index.html">Fintech-digest: control de digitalizaci√≥n por parte del Banco Central, salario de criptomonedas, tarjeta Mir en forma de pulseras y llaveros</a></li>
<li><a href="../es426417/index.html">Pavel 2.0: consultor reptiloide en JS, node.js con sockets y telefon√≠a</a></li>
<li><a href="../es426419/index.html">M√©todos de sobrecarga o puente prohibidos en Java</a></li>
<li><a href="../es426421/index.html">EHCI humanamente en ruso</a></li>
<li><a href="../es426423/index.html">mmWave en tel√©fonos inteligentes: c√≥mo Qualcomm hizo posible lo imposible</a></li>
<li><a href="../es426427/index.html">Cosas √∫tiles para "cosas": una peque√±a selecci√≥n con precios bajos</a></li>
<li><a href="../es426429/index.html">Instalaci√≥n de FreeSWITCH 1.8 en Debian 9 (Raspbian Stretch, la imagen b√°sica del sistema MajorDoMo Smart Home en Rasbperri Pi)</a></li>
<li><a href="../es426431/index.html">Desmontaje del motor de novela visual Qlie</a></li>
<li><a href="../es426433/index.html">Deliciosa SMM para el restaurante.</a></li>
<li><a href="../es426435/index.html">Los mejores especialistas son los que yo mismo prepar√©: un curso de prueba de juegos de los expertos de Mail.Ru Group</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>