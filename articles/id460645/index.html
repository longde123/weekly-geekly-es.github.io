<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗳️ 🎒 🍍 Berbuat baik berbuat jahat: menulis kode jahat dengan Go, Bagian 1 🚽 🧘🏿 ☺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tips Buruk untuk Programer Go 


 Setelah beberapa dekade pemrograman di Jawa, beberapa tahun terakhir saya terutama bekerja pada Go. Bekerja dengan G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berbuat baik berbuat jahat: menulis kode jahat dengan Go, Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460645/"><h4>  <i>Tips Buruk untuk Programer Go</i> </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/1c9/72b/d9b/1c972bd9b185f33a0348abfd7d81e470.png" alt="gambar"><br><br>  Setelah beberapa dekade pemrograman di Jawa, beberapa tahun terakhir saya terutama bekerja pada Go.  Bekerja dengan Go itu bagus, terutama karena kodenya sangat mudah diikuti.  Java telah menyederhanakan model pemrograman C ++ dengan menghapus banyak pewarisan, manajemen memori manual, dan overloading operator.  Go melakukan hal yang sama, terus bergerak menuju gaya pemrograman yang sederhana dan dapat dipahami, sepenuhnya menghapus warisan dan kelebihan fungsi.  Kode sederhana adalah kode yang dapat dibaca, dan kode yang dapat dibaca adalah kode yang didukung.  Dan ini bagus untuk perusahaan dan karyawan saya. <br><br>  Seperti dalam semua budaya, pengembangan perangkat lunak memiliki legenda sendiri, cerita yang diceritakan kembali oleh pendingin air.  Kita semua telah mendengar tentang pengembang yang, alih-alih berfokus untuk menciptakan produk yang berkualitas, terpaku untuk melindungi pekerjaan mereka sendiri dari orang luar.  Mereka tidak memerlukan kode yang didukung, karena itu berarti orang lain akan dapat memahami dan memodifikasinya.  Apakah mungkin on Go?  Apakah mungkin membuat kode Go begitu rumit?  Saya akan katakan segera - ini bukan tugas yang mudah.  Mari kita lihat opsi yang mungkin. <br><a name="habracut"></a><br>  Anda berpikir: “ <i>Seberapa banyak Anda bisa mendapatkan kode dalam bahasa pemrograman?</i>  <i>Apakah mungkin untuk menulis kode mengerikan di Go sehingga penulisnya menjadi sangat diperlukan di perusahaan?</i>  »Jangan khawatir.  Ketika saya masih mahasiswa, saya memiliki proyek di mana saya mendukung kode Lisp-e orang lain yang ditulis oleh seorang mahasiswa pascasarjana.  Bahkan, ia berhasil menulis kode Fortran-e menggunakan Lisp.  Kode tersebut terlihat seperti ini: <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> add-mult-pi (<span class="hljs-name"><span class="hljs-name">in1</span></span> in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> a in1) (<span class="hljs-name"><span class="hljs-name">setq</span></span> b in2) (<span class="hljs-name"><span class="hljs-name">setq</span></span> c (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> d (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">3.1415</span></span> c) d )</code> </pre> <br>  Ada puluhan file kode seperti itu.  Dia benar-benar mengerikan dan sekaligus brilian.  Saya menghabiskan waktu berbulan-bulan untuk mencari tahu.  Dibandingkan dengan ini, menulis kode buruk di Go hanya meludah. <br><br>  Ada banyak cara untuk membuat kode Anda tidak didukung, tetapi kami hanya akan melihat beberapa.  Untuk melakukan kejahatan, Anda harus terlebih dahulu belajar berbuat baik.  Oleh karena itu, pertama-tama kita melihat bagaimana programmer "baik" Go menulis, dan kemudian kita melihat bagaimana melakukan yang sebaliknya. <br><br><h3>  Kemasan buruk </h3><br>  Paket adalah topik praktis untuk memulai.  Bagaimana kode organisasi dapat merusak keterbacaan? <br><br>  Di Go, nama paket digunakan untuk merujuk ke entitas yang diekspor (misalnya, ` <i>fmt.Println`</i> <i>atau` http.RegisterFunc`</i> ).  Karena kita dapat melihat nama paketnya, programmer Go yang “baik” memastikan bahwa nama ini menggambarkan apa entitas yang diekspor.  Kita seharusnya tidak memiliki paket util, karena nama seperti ` <i>util.JSONMarshal`</i> tidak akan bekerja untuk kita - kita <i>perlu` json.Marshal`</i> . <br><br>  Pengembang "baik" Go juga tidak membuat paket terpisah untuk DAO atau model.  Bagi mereka yang tidak terbiasa dengan istilah ini, DAO adalah " <i>objek akses data</i> " - lapisan kode yang berinteraksi dengan database Anda.  Saya dulu bekerja untuk sebuah perusahaan di mana 6 layanan Java mengimpor perpustakaan DAO yang sama untuk mengakses database yang sama, yang mereka bagikan, karena " <i>... yah, Anda tahu, layanan-layanan mikro adalah sama ...</i> ". <br><br>  Jika Anda memiliki paket terpisah dengan semua DAO Anda, maka kemungkinan besar Anda akan mendapatkan ketergantungan melingkar antar paket, yang dilarang di Go.  Dan jika Anda memiliki beberapa layanan yang menyertakan paket DAO ini sebagai perpustakaan, Anda juga dapat menghadapi situasi di mana perubahan dalam satu layanan mengharuskan memperbarui semua layanan Anda, jika tidak, sesuatu akan rusak.  Ini disebut monolith terdistribusi dan sangat sulit untuk diperbarui. <br><br>  Ketika Anda tahu bagaimana pengemasan seharusnya bekerja dan apa yang memperburuknya, “mulai melayani kejahatan” menjadi sederhana.  Mengatur kode Anda dengan buruk dan memberikan nama buruk paket Anda.  Pecah kode Anda menjadi paket-paket seperti <i>model</i> , <i>util</i> dan <i>dao</i> .  Jika Anda benar-benar ingin mulai membuat kekacauan, cobalah membuat paket untuk menghormati kucing Anda atau warna favorit Anda.  Ketika orang dihadapkan dengan dependensi siklik atau monolit terdistribusi karena mencoba menggunakan kode Anda, Anda harus mendesah, memutar mata, dan memberi tahu mereka bahwa mereka hanya melakukan kesalahan ... <br><br><h3>  Antarmuka yang tidak pantas </h3><br>  Sekarang semua paket kami rusak, kita bisa beralih ke antarmuka.  Antarmuka di Go tidak seperti antarmuka dalam bahasa lain.  Fakta bahwa Anda tidak secara eksplisit menyatakan bahwa jenis ini mengimplementasikan antarmuka pada awalnya tampaknya tidak signifikan, tetapi pada kenyataannya itu benar-benar membalikkan konsep antarmuka. <br><br>  Dalam sebagian besar bahasa dengan tipe abstrak, antarmuka didefinisikan sebelum atau pada saat yang sama dengan implementasi.  Anda harus melakukan ini setidaknya untuk pengujian.  Jika Anda tidak membuat antarmuka terlebih dahulu, Anda tidak bisa memasukkannya nanti tanpa merusak semua kode yang menggunakan kelas ini.  Karena Anda harus menulis ulang dengan tautan ke antarmuka, bukan tipe tertentu. <br><br>  Untuk alasan ini, kode Java sering memiliki antarmuka layanan raksasa dengan banyak metode.  Kelas yang mengimplementasikan antarmuka ini kemudian menggunakan metode yang mereka butuhkan dan mengabaikan sisanya.  Tes menulis dimungkinkan, tetapi Anda menambahkan tingkat abstraksi tambahan, dan saat menulis tes, Anda sering menggunakan alat untuk menghasilkan implementasi metode-metode yang tidak Anda butuhkan. <br><br>  Di Go, antarmuka implisit menentukan metode mana yang perlu Anda gunakan.  Kode memiliki antarmuka, bukan sebaliknya.  Bahkan jika Anda menggunakan tipe dengan banyak metode yang ditentukan di dalamnya, Anda dapat menentukan antarmuka yang hanya mencakup metode yang Anda butuhkan.  Kode lain yang menggunakan bidang terpisah dari jenis yang sama akan menentukan antarmuka lain yang hanya mencakup fungsionalitas yang diperlukan.  Biasanya, antarmuka ini hanya memiliki beberapa metode. <br><br>  Ini membuatnya lebih mudah untuk memahami kode Anda, karena deklarasi metode tidak hanya menentukan data apa yang dibutuhkan, tetapi juga secara akurat menunjukkan fungsionalitas apa yang akan digunakan.  Ini adalah salah satu alasan mengapa pengembang Go yang baik mengikuti saran: " <i>Terima antarmuka, kembalikan struktur</i> ." <br><br>  Tetapi hanya karena ini adalah praktik yang baik tidak berarti Anda harus melakukan itu ... <br>  Cara terbaik untuk membuat antarmuka Anda "jahat" adalah kembali ke prinsip-prinsip menggunakan antarmuka dari bahasa lain, mis.  Tentukan antarmuka terlebih dahulu sebagai bagian dari kode yang dipanggil.  Tentukan antarmuka besar dengan banyak metode yang digunakan oleh semua klien layanan.  Tidak jelas metode apa yang benar-benar dibutuhkan.  Ini menyulitkan kode, dan komplikasi, seperti yang Anda tahu, adalah teman terbaik seorang programmer "jahat". <br><br><h3>  Pass pointer tumpukan </h3><br>  Sebelum menjelaskan apa artinya ini, Anda perlu sedikit berfilsafat.  Jika Anda mengalihkan perhatian dan berpikir, setiap program tertulis melakukan hal yang sama.  Ini menerima data, memprosesnya, dan kemudian mengirim data yang diproses ke lokasi lain.  Begitulah, terlepas dari apakah Anda menulis sistem penggajian, menerima permintaan HTTP dan mengembalikan halaman web, atau bahkan memeriksa joystick untuk melacak klik tombol - program memproses data. <br><br>  Jika kita melihat program dengan cara ini, hal terpenting yang harus dilakukan adalah memastikan bahwa mudah bagi kita untuk memahami bagaimana data dikonversi.  Dan jadi itu praktik yang baik untuk menjaga data tidak berubah selama mungkin selama program.  Karena data yang tidak berubah adalah data yang mudah dilacak. <br><br>  Di Go, kami memiliki tipe referensi dan tipe nilai.  Perbedaan antara keduanya adalah apakah variabel mengacu pada salinan data atau ke lokasi data dalam memori.  Pointer, irisan, peta, saluran, antarmuka, dan fungsi adalah tipe referensi, dan yang lainnya adalah tipe nilai.  Jika Anda menetapkan variabel tipe nilai ke variabel lain, itu membuat salinan nilai;  mengubah satu variabel tidak mengubah nilai lainnya. <br><br>  Menetapkan satu variabel dari tipe referensi ke variabel lain dari tipe referensi berarti keduanya memiliki area memori yang sama, jadi jika Anda mengubah data yang ditunjuk pertama, Anda mengubah data yang ditunjuk kedua.  Ini berlaku untuk variabel lokal dan parameter fungsi. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  a := 1 b := a b = 2 fmt.Println(a, b) // prints 1 2 //  c := &amp;a *c = 3 fmt.Println(a, b, *c) // prints 3 2 3 }</span></span></code> </pre> <br>  Pengembang Kind Go ingin membuatnya lebih mudah untuk memahami bagaimana data dikumpulkan.  Mereka mencoba menggunakan tipe nilai sebagai parameter fungsi sesering mungkin.  Tidak ada cara di Go untuk menandai bidang dalam struktur atau parameter fungsi sebagai final.  Jika suatu fungsi menggunakan parameter nilai, mengubah parameter tidak akan mengubah variabel dalam fungsi panggilan.  Yang bisa dilakukan fungsi yang dipanggil adalah mengembalikan nilai ke fungsi panggilan.  Jadi, jika Anda mengisi struktur dengan memanggil fungsi dengan parameter nilai, Anda tidak perlu takut untuk mentransfer data ke struktur, karena Anda memahami dari mana setiap bidang dalam struktur berasal. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>,i*<span class="hljs-number"><span class="hljs-number">2</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := Foo{} fA = getA() fB = getB(fA) <span class="hljs-comment"><span class="hljs-comment">//  ,    f fmt.Println(f) }</span></span></code> </pre> <br>  Nah, bagaimana kita menjadi "jahat"?  Sangat sederhana - membalikkan model ini. <br><br>  Alih-alih memanggil fungsi yang mengembalikan nilai yang diinginkan, Anda meneruskan pointer ke struktur dalam fungsi dan memungkinkan mereka untuk membuat perubahan pada struktur.  Karena setiap fungsi memiliki strukturnya sendiri, satu-satunya cara untuk mengetahui bidang mana yang berubah adalah dengan melihat seluruh kode.  Anda mungkin juga memiliki dependensi implisit antara fungsi - fungsi 1 mentransfer data yang dibutuhkan oleh fungsi 2.  Namun dalam kode itu sendiri, tidak ada yang menunjukkan bahwa Anda harus memanggil fungsi 1 terlebih dahulu.  Jika Anda membangun struktur data Anda dengan cara ini, Anda dapat yakin bahwa tidak ada yang akan mengerti apa yang dilakukan kode Anda. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Foo <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *Foo)</span></span></span></span> { fA = <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-comment"><span class="hljs-comment">//   fA! func setB(f *Foo) { fB = fmt.Sprintf("%d", fA*2) } func main() { f := Foo{} setA(&amp;f) setB(&amp;f) // ,  setA  setB //    ? fmt.Println(f) }</span></span></code> </pre> <br><h3>  Permukaan panik </h3><br>  Sekarang kita mulai menangani kesalahan.  Anda mungkin berpikir bahwa menulis program yang menangani kesalahan sekitar 75% buruk, dan saya tidak akan mengatakan bahwa Anda salah.  Kode Go sering diisi dengan penanganan kesalahan head-to-toe.  Dan tentu saja, akan lebih mudah untuk memprosesnya tidak secara langsung.  Kesalahan terjadi, dan menanganinya adalah hal yang membedakan profesional dari pemula.  Penanganan kesalahan yang lambat menyebabkan program tidak stabil yang sulit untuk di-debug dan sulit untuk dipelihara.  Terkadang menjadi seorang programmer yang “baik” berarti “menyusahkan”. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User, error)</span></span></span></span> { rows, err := dus.DB.Query(<span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> err = rows.Scan(&amp;name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } err = rows.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{}, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Banyak bahasa, seperti C ++, Python, Ruby, dan Java, menggunakan pengecualian untuk menangani kesalahan.  Jika terjadi kesalahan, pengembang dalam bahasa ini melempar atau melempar pengecualian, mengharapkan beberapa kode untuk menanganinya.  Tentu saja, program mengharapkan bahwa klien menyadari kemungkinan kesalahan dilemparkan ke lokasi tertentu sehingga dimungkinkan untuk melempar pengecualian.  Karena, kecuali (dengan tidak ada permainan kata-kata) Java memeriksa pengecualian, tidak ada dalam tanda tangan metode dalam bahasa atau fungsi untuk menunjukkan bahwa pengecualian dapat terjadi.  Jadi, bagaimana pengembang tahu pengecualian mana yang perlu dikhawatirkan?  Mereka memiliki dua opsi: <br><br><ul><li>  Pertama, mereka dapat membaca semua kode sumber dari semua perpustakaan yang dipanggil oleh kode mereka, dan semua perpustakaan yang memanggil perpustakaan yang disebut, dll. </li><li>  Kedua, mereka bisa mempercayai dokumentasinya.  Saya mungkin bias, tetapi pengalaman pribadi tidak memungkinkan saya untuk sepenuhnya mempercayai dokumentasi. </li></ul><br>  Jadi, bagaimana kita membawa kejahatan ini?  Menyalahgunakan panik ( <i>panik</i> ) dan pemulihan ( <i>pulih</i> ), tentu saja!  Panik dirancang untuk situasi seperti "drive jatuh" atau "kartu jaringan meledak."  Tapi tidak untuk itu - "seseorang melewati string, bukan int". <br><br>  Sayangnya, yang lain, "pengembang yang kurang tercerahkan" akan mengembalikan kesalahan dari kode mereka.  Karena itu, inilah fungsi pembantu kecil dari PanicIfErr.  Gunakan itu untuk mengubah kesalahan pengembang lain menjadi panik. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicIfErr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } }</code> </pre> <br>  Anda dapat menggunakan PanicIfErr untuk membungkus kesalahan orang lain, kompres kode.  Tidak ada lagi penanganan kesalahan yang buruk!  Kesalahan apa pun sekarang menjadi panik.  Sangat produktif! <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dus DBUserService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadEvil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span></span> { rows, err := dus.DB.Query( <span class="hljs-string"><span class="hljs-string">"SELECT name FROM USERS WHERE ID = ?"</span></span>, id) PanicIfErr(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !rows.Next() { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"no user for id %d"</span></span>, id)) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PanicIfErr(rows.Scan(&amp;name)) PanicIfErr(rows.Close()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User{Id: id, Name: name} }</code> </pre> <br>  Anda dapat menempatkan pemulihan di suatu tempat lebih dekat ke awal program, mungkin di <i>middleware</i> Anda sendiri.  Dan kemudian katakan bahwa Anda tidak hanya memproses kesalahan, tetapi juga membuat pembersih kode orang lain.  Melakukan kejahatan dengan berbuat baik adalah jenis kejahatan terbaik. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PanicMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">", - ."</span></span>) } }() h.ServeHTTP(rw, req) } ) }</code> </pre> <br><h3>  Mengatur efek samping </h3><br>  Selanjutnya kita akan membuat efek samping.  Ingat, pengembang Go yang “baik” ingin memahami bagaimana data melewati program.  Cara terbaik untuk mengetahui data yang dilaluinya adalah dengan mengatur dependensi eksplisit dalam aplikasi.  Bahkan entitas yang berhubungan dengan antarmuka yang sama dapat sangat bervariasi dalam perilaku.  Misalnya, kode yang menyimpan data dalam memori, dan kode yang mengakses database untuk pekerjaan yang sama.  Namun, ada cara untuk menginstal dependensi di Go tanpa panggilan eksplisit. <br><br>  Seperti banyak bahasa lain, Go memiliki cara untuk secara ajaib mengeksekusi kode tanpa memohonnya secara langsung.  Jika Anda membuat fungsi yang disebut init tanpa parameter, itu akan secara otomatis mulai ketika paket dimuat.  Dan, untuk lebih membingungkan, jika dalam satu file ada beberapa fungsi dengan nama init atau beberapa file dalam satu paket, semuanya akan mulai. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Account <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UserId <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"   ,     init()"</span></span>) }</code> </pre> <br>  Fungsi init sering dikaitkan dengan impor kosong.  Go memiliki cara khusus untuk mendeklarasikan impor, yang terlihat seperti `import _“ github.com / lib / pq`.  Ketika Anda menetapkan pengidentifikasi nama kosong untuk paket yang diimpor, metode init berjalan di dalamnya, tetapi tidak menunjukkan pengidentifikasi paket apa pun.  Untuk beberapa perpustakaan Go - seperti driver basis data atau format gambar - Anda harus memuatnya dengan mengaktifkan impor paket kosong, hanya untuk memanggil fungsi init sehingga paket dapat mendaftarkan kodenya. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { db, err := sql.Open( <span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, <span class="hljs-string"><span class="hljs-string">"postgres://jon@localhost/evil?sslmode=disable"</span></span>) }</code> </pre><br>  Dan ini jelas merupakan opsi "jahat".  Saat Anda menggunakan inisialisasi, kode yang berfungsi secara ajaib benar-benar di luar kendali pengembang.  Praktik terbaik tidak merekomendasikan menggunakan fungsi inisialisasi - ini adalah fitur yang tidak jelas, mereka membingungkan kode, dan mereka mudah disembunyikan di perpustakaan. <br><br>  Dengan kata lain, fungsi init ideal untuk tujuan jahat kita.  Alih-alih secara eksplisit mengkonfigurasi atau mendaftarkan entitas dalam paket, Anda dapat menggunakan inisialisasi dan fungsi impor kosong untuk mengonfigurasi status aplikasi Anda.  Dalam contoh ini, kami membuat akun tersedia untuk seluruh aplikasi melalui registri, dan paket itu sendiri ditempatkan di registri menggunakan fungsi init. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> account <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubAccountService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a StubAccountService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBalance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(accountId </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { registry.Register(<span class="hljs-string"><span class="hljs-string">"account"</span></span>, StubAccountService{}) }</code> </pre> <br>  Jika Anda ingin menggunakan akun, masukkan impor kosong ke program Anda.  Itu tidak harus menjadi kode utama atau terkait - itu hanya harus "suatu tempat."  Ini sihir! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/account"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/example/registry"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Balancer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetBalance(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := registry.Get(<span class="hljs-string"><span class="hljs-string">"account"</span></span>).(Balancer) money := a.GetBalance(<span class="hljs-number"><span class="hljs-number">12345</span></span>) }</code> </pre> <br>  Jika Anda menggunakan init di perpustakaan untuk mengonfigurasi dependensi, Anda akan segera melihat bahwa pengembang lain bingung bagaimana dependensi ini diinstal dan bagaimana mengubahnya.  Dan tidak ada yang akan lebih bijaksana daripada Anda. <br><br><h3>  Konfigurasi yang rumit </h3><br>  Masih banyak hal yang bisa kita lakukan dengan konfigurasi.  Jika Anda adalah pengembang Go yang “baik”, Anda ingin mengisolasi konfigurasi dari program lainnya.  Dalam fungsi utama (), Anda mendapatkan variabel dari lingkungan dan mengubahnya ke nilai yang diperlukan untuk komponen yang terkait satu sama lain secara eksplisit.  Komponen Anda tidak tahu apa-apa tentang file konfigurasi, atau apa sifatnya.  Untuk komponen sederhana, Anda mengatur properti publik, dan untuk yang lebih kompleks, Anda dapat membuat fungsi pabrik yang menerima informasi konfigurasi dan mengembalikan komponen yang dikonfigurasi dengan benar. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, err := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"error reading config file: %v"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) prefix := m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) maker := account.NewMaker(prefix) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Maker <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { prefix <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m Maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMaker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prefix </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maker</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Maker{prefix: prefix} }</code> </pre> <br>  Tetapi pengembang "jahat" tahu bahwa lebih baik menyebarkan informasi tentang konfigurasi di seluruh program.  Alih-alih memiliki satu fungsi dalam paket yang mendefinisikan nama dan tipe nilai untuk paket Anda, gunakan fungsi yang mengambil konfigurasi seperti apa adanya dan mengubahnya sendiri. <br><br>  Jika ini tampaknya terlalu "jahat", gunakan fungsi init untuk memuat file properti dari dalam paket Anda dan atur nilainya sendiri.  Tampaknya Anda membuat kehidupan pengembang lain lebih mudah, tetapi Anda dan saya tahu ... <br><br>  Menggunakan fungsi init, Anda dapat mendefinisikan properti baru di bagian belakang kode, dan tidak ada yang akan menemukannya sampai mereka masuk ke produksi dan semuanya jatuh, karena sesuatu tidak akan masuk ke salah satu dari puluhan file properti yang diperlukan untuk menjalankan.  Jika Anda ingin lebih banyak lagi "kekuatan jahat", Anda dapat menyarankan membuat wiki untuk melacak semua properti di semua perpustakaan dan "lupa" secara berkala menambahkan yang baru.  Sebagai Penjaga Properti, Anda menjadi satu-satunya orang yang dapat menjalankan perangkat lunak. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m maker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Account</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Account{Name: name, Id: m.prefix + <span class="hljs-string"><span class="hljs-string">"-12345"</span></span>} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Maker maker <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { b, _ := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"account.json"</span></span>) m := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{} json.Unmarshal(b, &amp;m) Maker.prefix = m[<span class="hljs-string"><span class="hljs-string">"account.prefix"</span></span>].(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) }</code> </pre> <br><h3>  Kerangka kerja fungsionalitas </h3><br>  Akhirnya, kita sampai pada topik kerangka kerja vs perpustakaan.  Perbedaannya sangat halus.  Ini bukan hanya tentang ukuran;  Anda dapat memiliki perpustakaan besar dan kerangka kerja kecil.  Kerangka kerja memanggil kode Anda saat Anda memanggil kode perpustakaan sendiri.  Kerangka kerja mengharuskan Anda untuk menulis kode dengan cara tertentu, apakah itu penamaan metode Anda sesuai dengan aturan tertentu, atau bahwa mereka sesuai dengan antarmuka tertentu, atau memaksa Anda untuk mendaftarkan kode Anda dalam kerangka kerja.  Kerangka kerja memiliki persyaratan sendiri untuk semua kode Anda.  Artinya, secara umum, kerangka kerja memerintahkan Anda. <br><br>  Go mendorong penggunaan perpustakaan karena perpustakaan terhubung.  Meskipun, tentu saja, masing-masing perpustakaan mengharapkan data untuk dikirimkan dalam format tertentu, Anda dapat menulis beberapa kode penghubung untuk mengubah output dari satu perpustakaan menjadi input untuk yang lain. <br>  Sulit untuk mendapatkan kerangka kerja untuk bekerja bersama dengan mulus karena setiap kerangka kerja ingin kontrol penuh atas siklus hidup kode.  Seringkali satu-satunya cara untuk membuat kerangka kerja untuk bekerja bersama adalah untuk kerangka kerja penulis untuk bersatu dan dengan jelas mengatur saling mendukung.     « »     —   ,     . <br><br><h3>     </h3><br>   ,      .          «»,     «»   «». </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460645/">https://habr.com/ru/post/id460645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460633/index.html">Detail Implementasi untuk RSTP dan Redundansi Perpanjangan Cincin Kepemilikan</a></li>
<li><a href="../id460635/index.html">CLRium # 6: Concurrency & Parallelism. Dua hari: dari prosesor ke async / menunggu</a></li>
<li><a href="../id460637/index.html">Kontrol lampu pada ZigBee</a></li>
<li><a href="../id460641/index.html">YouTokenToMe: alat untuk tokenisasi cepat teks dari Tim VKontakte</a></li>
<li><a href="../id460643/index.html">Distribusi titik-titik pada bola yang seragam</a></li>
<li><a href="../id460647/index.html">Memecahkan pekerjaan dengan pwnable.kr 05 - passcode. Tabel tautan prosedur penulisan ulang melalui kerentanan format string</a></li>
<li><a href="../id460651/index.html">Pertemuan Society of Anonymous Testers: TMS, pemantauan pemantauan, penilaian kualitas pencarian dan tes iOS asli</a></li>
<li><a href="../id460655/index.html">Bagaimana saya mematahkan Telegram</a></li>
<li><a href="../id460659/index.html">Menggunakan Pipa untuk Pivoting</a></li>
<li><a href="../id460661/index.html">Semua yang perlu Anda ketahui tentang Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>