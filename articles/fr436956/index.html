<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏿 🥞 🔱 Sur la question des changements, des signes et de la vitesse MK 👩🏾‍🤝‍👩🏻 🧛🏾 🐂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Trouvez une raison à tout et vous comprendrez beaucoup" 
 Peut-être que mes lecteurs habituels (enfin, il se peut qu'ils ne le soient pas) se souvien...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sur la question des changements, des signes et de la vitesse MK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436956/"><h3>  "Trouvez une raison à tout et vous comprendrez beaucoup" </h3><br>  Peut-être que mes lecteurs habituels (enfin, il se peut qu'ils ne le soient pas) se souviennent que dans mon article, j'étais perplexe que l'attribut unsigned ait été utilisé pour décrire les registres des périphériques externes.  Dans les commentaires, il a été suggéré que cela a été fait pour éviter un comportement indéfini pendant les quarts de travail et j'ai accepté.  Comme je l'ai découvert récemment, il y a une autre raison à cette utilisation de l'attribut et il peut être appliqué non seulement aux registres, mais aussi aux variables ordinaires. <br><br>  Nous commençons donc. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Pour commencer, une petite introduction au fer</b> <div class="spoiler_text">  En tant que plate-forme cible, nous considérerons un MK 8 bits sans batterie (c'est une tentative si pathétique de cacher le nom compromis AVR), qui a les commandes matérielles suivantes: <br><br>  <b>lsl / lsr</b> décalage gauche / droite logique, le bit bas / haut est effacé; <br>  <b>rol / ror</b> décalage cyclique gauche / droite par transfert (décalage 9 bits); <br>  <b>asr</b> décalage arithmétique vers la droite, le bit le plus significatif (signé) est stocké (nous faisons attention au fait que réaliser ce type de décalage vers la gauche est généralement impossible en principe). <br><br>  Toutes ces commandes sont exécutées sur l'opérande d'octet et sont la base de l'implémentation de tous les autres décalages possibles.  Par exemple, un décalage de mot (2 octets rh, rl) avec un signe à droite de 1 chiffre est implémenté par la séquence suivante: <br><br>  <b>asr rh;</b>  <b>ror rl;</b> <br></div></div><br>  Considérons un exemple de code simple et le code assembleur correspondant pour MK avec le système de commande AVR, comme toujours, obtenu sur godbolt.org.  (implique que l'optimisation est activée et que la variable se trouve dans le registre r24) <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> byte; byte = byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><pre> <code class="cpp hljs">clr r25 sbrc r24,<span class="hljs-number"><span class="hljs-number">7</span></span> com r25 lsl r24 rol r25</code> </pre> <br>  et voir que l'opération prend cinq équipes? <br><br>  Remarque: Si quelqu'un dans les commentaires vous dit comment organiser ce fragment (et les suivants) en 2 colonnes, je vous en serai reconnaissant. <br><br>  On peut voir dans le code assembleur que la variable d'octet se développe en un type entier (16 bits) dans les trois premières commandes, et dans les deux suivantes, le nombre à deux octets est en fait décalé - c'est en quelque sorte étrange, pour dire le moins. <br><br>  Décaler vers la droite n'est pas mieux <br><br><pre> <code class="cpp hljs">byte = byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; clr r25 sbrc r24,<span class="hljs-number"><span class="hljs-number">7</span></span> com r25 asr r25 ror r24</code> </pre> <br>  - les cinq mêmes équipes.  Pendant ce temps, il est évident qu'en fait, pour effectuer la dernière opération, vous avez besoin d'une seule commande <br><br><pre> <code class="cpp hljs">sr r24</code> </pre> <br>  et pour la première opération plus.  J'ai déclaré à plusieurs reprises que le compilateur crée actuellement du code assembleur pas pire qu'un programmeur (bien qu'il s'agisse d'un système de commande ARM), surtout si vous l'aidez un peu, et soudain, un tel problème.  Mais essayez d'aider le compilateur à créer le code correct, peut-être s'agit-il de mélanger les types dans une opération de décalage et d'essayer <br><br><pre> <code class="cpp hljs">byte = byte &gt;&gt; (<span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  - n'a pas aidé, à partir du mot "complètement", mais l'option <br><br><pre> <code class="cpp hljs"> byte=(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  donne un résultat légèrement meilleur <br><br><pre> <code class="cpp hljs">ldi r25,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) asr r25 ror r24</code> </pre> <br>  - trois équipes, puisque l'extension à l'ensemble occupe désormais une équipe - c'est mieux, bien que pas parfait, la même image pour <br><br><pre> <code class="cpp hljs">byte=(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  - trois équipes.  Eh bien, pour ne pas écrire de transtypages supplémentaires, nous rendons la variable elle-même non signée <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byteu;</code> </pre> <br>  et BINGO - le code assembleur répond pleinement à nos attentes <br><br><pre> <code class="cpp hljs">byteu = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; lsr r24</code> </pre> <br>  Il est étrange à quel point il semblerait, quelle différence, d'indiquer immédiatement le type correct d'une variable, ou de l'amener directement à une opération - mais il s'avère qu'il y a une différence. <br><br>  D'autres études ont montré que le code assembleur prend en compte le type de variable auquel le résultat est attribué, car <br><br><pre> <code class="cpp hljs">byteu = byte &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  fonctionne bien et produit un minimum de code, et l'option <br><br><pre> <code class="cpp hljs">byte = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  ne peut pas se passer de trois équipes. <br><br>  Certes, un tel comportement est décrit dans le standard de la langue, je demande à ceux qui savent dans le commentaire, mais encore une fois je déclarerai fièrement que "les Tchouktches ne sont pas un lecteur" et je continuerai l'histoire. <br><br>  Donc, une telle technique n'a pas aidé à décaler vers la droite - comme auparavant, il y avait 3 équipes (enfin. Ce qui n'est pas 5, comme pour la version avec signe) et je n'ai pas pu améliorer le résultat en aucune façon. <br>  Mais dans tous les cas, on voit que les opérations de décalage avec un numéro non signé sont effectuées plus rapidement qu'avec son adversaire.  Par conséquent, si nous n'allons pas traiter le bit le plus significatif d'un nombre comme un signe (et dans le cas des registres, c'est généralement le cas), nous devons certainement ajouter l'attribut unsigned, ce que nous ferons à l'avenir. <br><br>  Il s'avère qu'avec les décalages en général, tout est extrêmement intéressant, commençons à augmenter le nombre de positions lors du décalage vers la gauche et en regardant les résultats: &lt;&lt; 1 prend 1 cycle d'horloge, &lt;&lt; 2 - 2, &lt;&lt; 3 - 3, 4 - 2 de manière inattendue, le compilateur a appliqué une optimisation délicate <br><br><pre> <code class="cpp hljs">swap r24 andi r24,lo8(<span class="hljs-number"><span class="hljs-number">-16</span></span>)</code> </pre> <br>  où la commande s <b>wap</b> permute deux quartets dans un octet.  En outre, sur la base de la dernière optimisation &lt;&lt; 5 - 3, &lt;&lt; 6 - 4, &lt;&lt; 7 - 3 encore une fois de manière inattendue, il existe une autre optimisation <br><br><pre> <code class="cpp hljs">ror r24 clr r24 ror r24</code> </pre> <br>  le bit de transfert est utilisé, &lt;&lt; 8 - 0 mesure, car il s'avère juste 0, il est inutile de chercher plus loin. <br><br>  Soit dit en passant, voici une tâche intéressante pour vous - pour combien de temps minimum vous pouvez effectuer une opération <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> byteu; byteu = byteu &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  ce qui traduit 0x1234 en 0x2340.  La solution évidente consiste à exécuter deux fois 4 commandes <br><br><pre> <code class="cpp hljs">lsl rl rol rh</code> </pre> <br>  conduit à 4 * 2 = 8 mesures, je suis rapidement venu avec une option <br><br><pre> <code class="cpp hljs">swap rl ; <span class="hljs-number"><span class="hljs-number">1243</span></span> swap rh ; <span class="hljs-number"><span class="hljs-number">2143</span></span> andi rh,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2043</span></span> mov tmp,rl andi tmp,<span class="hljs-number"><span class="hljs-number">0x0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rh,tmp ; <span class="hljs-number"><span class="hljs-number">2343</span></span> andi rl,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2340</span></span></code> </pre> <br>  qui nécessite 7 mesures et un registre intermédiaire.  Ainsi, le compilateur génère un code de 6 commandes et aucun registre intermédiaire - cool, oui. <br><br><div class="spoiler">  <b class="spoiler_title">Je cache ce code sous le spoiler - essayez de trouver une solution vous-même.</b> <div class="spoiler_text">  Astuce: dans le jeu de commandes MK, il y a une commande OU EXCLUSIF ou un <b>montant total</b> DEUX <br><br><div class="spoiler">  <b class="spoiler_title">Le voici, ce merveilleux code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">swap rl ; <span class="hljs-number"><span class="hljs-number">1243</span></span> swap rh ; <span class="hljs-number"><span class="hljs-number">2143</span></span> andi rh,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">2043</span></span> eor rh,rl ; <span class="hljs-number"><span class="hljs-number">6343</span></span> andi r2l,<span class="hljs-number"><span class="hljs-number">0xf0</span></span> ; <span class="hljs-number"><span class="hljs-number">6340</span></span> eor rh,rl ; <span class="hljs-number"><span class="hljs-number">2340</span></span></code> </pre> <br></div></div><br>  Je tire juste un plaisir esthétique de ce fragment. <br></div></div><br>  En règle générale, pour les nombres 16 bits, la différence entre le code pour les numéros signés et non signés disparaissait lorsqu'il était déplacé vers la gauche, c'est étrange comme ça. <br><br>  Revenons à nos octets et commençons à nous déplacer vers la droite.  Comme nous nous en souvenons, pour un octet signé, nous avons 5 cycles d'horloge, pour un octet non signé - 3 et ce temps ne peut pas être réduit.  Ou tout de même, vous pouvez - oui, vous pouvez, mais c'est une manière très étrange (GCC avec optimisations activées - "c'est un endroit très étrange"), à savoir <br><br><pre> <code class="cpp hljs">byteu = (byteu &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7F</span></span>;</code> </pre> <br>  qui génère exactement une commande pour les deux variantes du signe.  Convient et option <br><br><pre> <code class="cpp hljs"> byteu = (byteu &amp; <span class="hljs-number"><span class="hljs-number">0xFE</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  mais seulement pour un numéro non signé, avec un numéro signé, tout devient encore plus déprimant - 7 mesures, nous continuons donc à explorer uniquement la première option. <br><br>  Je ne peux pas dire que je comprends ce qui se passe, car il est évident que la multiplication logique (&amp;) par une telle constante après un tel décalage n'a aucun sens (et ce n'est pas le cas), mais la présence de l'opération &amp; affecte le code du décalage lui-même.  "Vous voyez le gopher - non - et je ne vois pas, mais il l'est." <br><br>  Les décalages de 2 et ainsi de suite ont montré qu'il est important de payer le bit de signe, mais le nombre est initialement non signé, en général, des ordures sont obtenues, "mais ça marche", est la seule chose qui puisse être dite à ce sujet. <br><br>  Néanmoins, il est sûr de dire que l'interprétation du contenu des registres et de la mémoire comme des nombres non signés vous permet d'effectuer un certain nombre d'opérations (par exemple, des décalages ou une extension d'une valeur) avec eux plus rapidement et génère un code plus compact, il peut donc être fortement recommandé pour l'écriture de programmes pour MK, sauf indication contraire (l'interprétation comme un nombre est familier) n'est pas une condition préalable. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436956/">https://habr.com/ru/post/fr436956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436946/index.html">Reconnaissance aux rayons X: précision = 0,84, rappel = 0,96. Avons-nous besoin de plus de médecins?</a></li>
<li><a href="../fr436948/index.html">L'avenir des infrastructures des centres de données</a></li>
<li><a href="../fr436950/index.html">Startups au CES 2019: première partie</a></li>
<li><a href="../fr436952/index.html">Par souci d'argent: recherche et exploitation des vulnérabilités dans les terminaux de paiement mobiles</a></li>
<li><a href="../fr436954/index.html">Événements numériques à Moscou du 21 janvier au 27 janvier</a></li>
<li><a href="../fr436958/index.html">Le bot de poker stratégique Libratus adapté aux simulations militaires</a></li>
<li><a href="../fr436960/index.html">Testez-moi si vous le pouvez. Les développeurs YML rêvent-ils de tester ansible?</a></li>
<li><a href="../fr436962/index.html">Open source populaire - première partie: 3 outils pour travailler avec des données</a></li>
<li><a href="../fr436964/index.html">«Rostelecom. DataTalks "- un cours de conférences gratuites sur l'ingénierie et la gestion des données</a></li>
<li><a href="../fr436966/index.html">Optimisation du site Web pour GooglePage Speed ​​(toutes les fonctionnalités sont prises en compte après sa mise à jour) Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>