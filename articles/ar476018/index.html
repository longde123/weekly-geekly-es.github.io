<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚠 👨🏼‍🚀 💇🏻 كيف يعمل الرفرفة 🍎 👨‍👩‍👦‍👦 👧🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="كيف ترفرف فعلا العمل؟ 


 ما هي الحاجيات ، العناصر ، BuildContext ، RenderOject ، الارتباطات؟ .. 


 الصعوبة: مبتدئ 
 دخول 


 في العام الماضي ( ملاحظ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كيف يعمل الرفرفة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476018/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/xo/f8/wq/xof8wqtuioee7o5ztrhyyb7hriq.png"></p><br><p style=";text-align:right;direction:rtl">  كيف ترفرف فعلا العمل؟ </p><br><p style=";text-align:right;direction:rtl">  ما هي الحاجيات ، العناصر ، BuildContext ، RenderOject ، الارتباطات؟ .. </p><br><p style=";text-align:right;direction:rtl">  الصعوبة: <em>مبتدئ</em> </p><br><h1 id="vstuplenie" style=";text-align:right;direction:rtl">  دخول </h1><br><p style=";text-align:right;direction:rtl">  في العام الماضي ( <em>ملاحظة: في عام 2018</em> ) ، عندما بدأت رحلتي إلى عالم رائع من Flutter ، كان هناك القليل جدًا من المعلومات على الإنترنت مقارنة بما هي عليه اليوم.  الآن ، على الرغم من حقيقة أنه قد تم بالفعل كتابة الكثير من المواد ، يتحدث جزء صغير منها عن كيفية عمل Flutter بالفعل. </p><br><p style=";text-align:right;direction:rtl">  ما هي الحاجيات ( <em>الحاجيات</em> ) ، العناصر ( <em>العناصر</em> ) ، BuildContext؟  لماذا يرفرف بسرعة؟  لماذا في بعض الأحيان أنها لا تعمل كما هو متوقع؟  ما هي الأشجار ولماذا هم في حاجة؟ </p><br><p style=";text-align:right;direction:rtl">  في 95٪ من الحالات عند كتابة طلب ، سوف تتعامل فقط مع التطبيقات المصغّرة لعرض شيء ما أو التفاعل معه.  لكن ألم تتسائل أبدًا كيف يعمل هذا السحر في الداخل؟  كيف يعرف النظام موعد تحديث الشاشة والأجزاء التي يجب تحديثها؟ </p><br><p style=";text-align:right;direction:rtl">  <strong>المحتويات:</strong> </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">دخول</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 1: الخلفية</a> <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قليلا عن الجهاز</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">واجهة بين الرمز والجهاز</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إدارة رفرفة الإطار رفرفة المحرك تقديم</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">RenderView و RenderObject</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ربط التهيئة</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">SchedulerBinding</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لفتة ملزمة</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">العارض ملزم</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الحاجيات ملزمة</a> <a name="habracut"></a></li></ul></li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 2. من الحاجيات إلى بكسل</a> <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">التكوين غير قابل للتغيير</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الهيكل الهرمي للحاجيات</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الغابات وراء الأشجار</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">فهم العنصر في شجرة</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">3 فئات من الحاجيات</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أنواع العناصر</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كيف تعمل عناصر واجهة المستخدم الرسومية معًا</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">onDrawFrame ()</a> </li></ul></li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 3: التعامل مع الإيماءات</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء 4: الرسوم المتحركة</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الصورة كاملة</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">BuildContext</a> <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كيف يمكن أن يكون BuildContext؟</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">للمتعة</a> </li></ul></li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">استنتاج</a> </li></ul><br><h1 id="chast-1-predystoriya" style=";text-align:right;direction:rtl">  الجزء 1: الخلفية </h1><br><p style=";text-align:right;direction:rtl">  يقدم الجزء الأول من المقالة بعض المفاهيم الأساسية التي سيتم استخدامها في الجزء الثاني من المادة وتساعد على فهم أفضل للرفرفة. </p><br><h2 id="nemnogo-ob-ustroystve" style=";text-align:right;direction:rtl">  قليلا عن الجهاز </h2><br><p style=";text-align:right;direction:rtl">  لنبدأ من النهاية ونعود إلى الأساسيات. </p><br><p style=";text-align:right;direction:rtl">  عندما تنظر إلى جهازك أو بتعبير أدق إلى التطبيق الذي يعمل على جهازك ، فإنك ترى الشاشة فقط. </p><br><p style=";text-align:right;direction:rtl">  في الواقع ، كل ما تراه هو البيكسلات ، التي تشكل معًا صورة ثنائية الأبعاد ، وعندما تلمس الشاشة بإصبعك ، يتعرف الجهاز فقط على وضع إصبعك على الزجاج. </p><br><p style=";text-align:right;direction:rtl">  كل سحر التطبيق (من وجهة نظر مرئية) في معظم الحالات هو تحديث هذه الصورة على أساس التفاعلات التالية: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  مع شاشة الجهاز ( <em>على سبيل المثال ، إصبع على الزجاج</em> ) </li><li style=";text-align:right;direction:rtl">  مع الشبكة ( <em>على سبيل المثال ، التواصل مع الخادم</em> ) </li><li style=";text-align:right;direction:rtl">  بمرور الوقت ( <em>مثل الرسوم المتحركة</em> ) </li><li style=";text-align:right;direction:rtl">  مع أجهزة الاستشعار الخارجية الأخرى </li></ul><br><p style=";text-align:right;direction:rtl">  يتم توفير رؤية الصورة على الشاشة بواسطة الأجهزة (العرض) ، والتي تقوم بانتظام بتحديث العرض (عادةً 60 مرة في الثانية).  وهذا ما يسمى "معدل التحديث" ويتم التعبير عنها بالهرتز (Hertz). </p><br><p style=";text-align:right;direction:rtl">  تتلقى الشاشة معلومات للعرض من GPU (وحدة معالجة الرسومات) ، وهي دائرة إلكترونية متخصصة تم تحسينها وتصميمها لتكوين صور بسرعة من بعض البيانات (المضلعات والقوام).  يُطلق على عدد المرات في الثانية التي يستطيع فيها معالج الرسومات إنشاء "صورة" (= مخزن مؤقت للإطار) لعرضه وإرساله إلى الجهاز باسم معدل الإطار ( <em>ملاحظة: معدل الإطارات</em> ).  يتم قياس ذلك باستخدام كتلة من الإطارات في الثانية ( <em>مثل 60 إطارًا في الثانية أو 60 إطارًا في الثانية</em> ). </p><br><p style=";text-align:right;direction:rtl">  قد تسألني لماذا بدأت هذه المقالة مع مفاهيم صورة ثنائية الأبعاد معروضة بواسطة وحدة معالجة الرسومات / جهاز استشعار الزجاج الفعلي ، وما هو الاتصال مع الأدوات الذكية Flutter؟ </p><br><p style=";text-align:right;direction:rtl">  أعتقد أنه سيكون من الأسهل فهم كيفية عمل Flutter بالفعل إذا نظرنا إليها من وجهة النظر هذه ، لأن أحد الأهداف الرئيسية لتطبيق Flutter هو إنشاء هذه الصورة ثنائية الأبعاد والسماح لها بالتفاعل معها.  أيضًا لأنه في Flutter ، صدق أو لا تصدق ، يرجع كل شيء تقريبًا إلى الحاجة إلى تحديث الشاشة بسرعة وفي الوقت المناسب! </p><br><h2 id="interfeys-mezhdu-kodom-i-ustroystvom" style=";text-align:right;direction:rtl">  واجهة بين الرمز والجهاز </h2><br><p style=";text-align:right;direction:rtl">  على أي حال ، فإن جميع المهتمين بـ Flutter شاهدوا بالفعل الصورة التالية التي تصف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">بنية</a> Flutter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">عالية المستوى</a> . </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/i0/tp/fo/i0tpfoumlz1ultkyzqywfm9-osa.png"></p><br><p style=";text-align:right;direction:rtl">  عندما نكتب تطبيق Flutter باستخدام Dart ، سنظل على مستوى <em>Flutter Framework</em> (مظلل باللون الأخضر). </p><br><p style=";text-align:right;direction:rtl">  يتفاعل <em>Flutter Framework</em> مع <em>Flutter Engine</em> (باللون الأزرق) من خلال طبقة تجريدية تسمى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">Window</a> .  يوفر هذا المستوى من التجريد عددًا من واجهات برمجة التطبيقات للتفاعل غير المباشر مع الجهاز. </p><br><p style=";text-align:right;direction:rtl">  من خلال هذا المستوى من التجريد أيضًا ، يقوم <em>Flutter Engine</em> بإخطار <em>Flutter Framework</em> عندما: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يحدث حدث مهم على مستوى الجهاز (تغيير الاتجاه ، تغيير الإعدادات ، مشكلة الذاكرة ، حالة تشغيل التطبيق ...) </li><li style=";text-align:right;direction:rtl">  يحدث بعض الأحداث على مستوى الزجاج (= لفتة) </li><li style=";text-align:right;direction:rtl">  قناة منصة يرسل بعض البيانات </li><li style=";text-align:right;direction:rtl">  ولكن أيضًا بشكل أساسي عندما يكون <strong>Flutter Engine جاهزًا لتقديم إطار جديد</strong> </li></ul><br><h2 id="upravlenie-flutter-framework-renderingom-flutter-engine" style=";text-align:right;direction:rtl">  إدارة رفرفة الإطار رفرفة المحرك تقديم </h2><br><p style=";text-align:right;direction:rtl">  من الصعب تصديق ذلك ، لكن هذا صحيح.  باستثناء في بعض الحالات ( <em>انظر أدناه</em> ) ، لا يتم تنفيذ أي كود <em>Flutter Framework</em> دون بدء تقديم <em>Flutter Engine</em> . </p><br><p style=";text-align:right;direction:rtl">  استثناءات: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لفتة / لفتة (= حدث على الزجاج) </li><li style=";text-align:right;direction:rtl">  رسائل النظام الأساسي (= الرسائل التي تم إنشاؤها بواسطة جهاز ، مثل GPS) </li><li style=";text-align:right;direction:rtl">  رسائل الجهاز (= الرسائل المتعلقة بتغيير في حالة الجهاز ، على سبيل المثال ، الاتجاه ، التطبيق المرسل في الخلفية ، تنبيهات الذاكرة ، إعدادات الجهاز ...) </li><li style=";text-align:right;direction:rtl">  ردود المستقبل أو HTTP </li></ul><br><p style=";text-align:right;direction:rtl">  <em>(بيننا ، يمكنك تطبيق تغيير مرئي بالفعل دون الاتصال من محرك Flutter ، لكن هذا غير <strong>مستحسن</strong> )</em> </p><br><p style=";text-align:right;direction:rtl">  أنت تسألني: "إذا تم تنفيذ نوع من التعليمات البرمجية المتعلقة <em>بالإيماءة</em> وتسبب في تغيير مرئي ، أو إذا كنت تستخدم <em>مؤقتًا</em> لتعيين وتيرة المهمة التي تؤدي إلى تغييرات مرئية (على سبيل المثال ، الرسوم المتحركة) ، فكيف يعمل؟" </p><br><p style=";text-align:right;direction:rtl">  إذا كنت ترغب في حدوث تغيير مرئي أو تنفيذ بعض التعليمات البرمجية على أساس مؤقت ، فأنت بحاجة إلى إخبار <em>محرك Flutter Engine</em> بأنه يجب رسم شيء ما. </p><br><p style=";text-align:right;direction:rtl">  عادةً ما يتم تحديث <em>Flutter Engine</em> في المرة القادمة ، فإنه يستدعي <em>Flutter Framework</em> لتنفيذ بعض التعليمات البرمجية ، ويوفر في النهاية مشهدًا جديدًا للتقديم. </p><br><p style=";text-align:right;direction:rtl">  لذلك ، فإن السؤال المهم هو كيف ينظم محرك Flutter كل سلوك التطبيق بناءً على العرض. </p><br><p style=";text-align:right;direction:rtl">  للحصول على فكرة عن الآليات الداخلية ، انظر إلى الرسوم المتحركة التالية: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/zu/7s/ig/zu7sigrkekrmz8ha_83cvr88ynk.gif"></p><br><p style=";text-align:right;direction:rtl">  شرح موجز (ستأتي التفاصيل لاحقًا): </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يمكن لبعض الأحداث الخارجية (الإيماءات ، واستجابات المتشعب ، وما إلى ذلك) أو حتى العقود المستقبلية تشغيل المهام التي تجعل من الضروري تحديث العرض.  يتم إرسال الرسالة المقابلة إلى <em>محرك الرفرفة</em> (= <em>جدول الإطار</em> ) </li><li style=";text-align:right;direction:rtl">  عندما يكون <em>Flutter Engine</em> جاهزًا لبدء تحديث التقديم ، فإنه ينشئ طلبًا <em>لبدء الإطار</em> </li><li style=";text-align:right;direction:rtl">  يتم اعتراض طلب <em>إطار</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">البداية هذا من قبل Flutter</a> <em>Framework</em> ، والذي يؤدي المهام المرتبطة بشكل رئيسي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">بالعلامات</a> (على سبيل المثال ، الرسوم المتحركة) </li><li style=";text-align:right;direction:rtl">  يمكن لهذه المهام إعادة إنشاء طلب التقديم لاحقًا (على سبيل المثال: الحركة لم تكمل تنفيذها ، ولإكمالها ، ستحتاج إلى الحصول على <em>إطار بيغن</em> آخر في مرحلة لاحقة) </li><li style=";text-align:right;direction:rtl">  بعد ذلك ، يرسل <em>Flutter Engine</em> <em>إطار رسم</em> ، والذي يتم اعتراضه بواسطة <em>Flutter Framework</em> ، والذي سيبحث عن أي مهام متعلقة بتحديث التصميم من حيث البنية والحجم </li><li style=";text-align:right;direction:rtl">  بعد الانتهاء من جميع هذه المهام ، ينتقل إلى المهام المرتبطة بتحديث المخطط من حيث العرض </li><li style=";text-align:right;direction:rtl">  إذا كان هناك شيء ما على الشاشة يجب رسمه ، فسيتم إرسال مشهد جديد ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">مشهد</a> ) للتصور إلى <em>محرك Flutter</em> ، والذي سيؤدي إلى تحديث الشاشة </li><li style=";text-align:right;direction:rtl">  يقوم <em>Flutter Framework بعد ذلك</em> بتنفيذ جميع المهام التي سيتم تنفيذها بعد التقديم (= عمليات رد PostFrame) وأي مهام أخرى لاحقة لا تتعلق بالتقديم </li><li style=";text-align:right;direction:rtl">  ... وهذه العملية تبدأ من جديد </li></ul><br><h2 id="renderview-i-renderobject" style=";text-align:right;direction:rtl">  RenderView و RenderObject </h2><br><p style=";text-align:right;direction:rtl">  قبل الغوص في تفاصيل سير العمل ، حان الوقت لتقديم مفهوم <em>شجرة التقديم</em> . </p><br><p style=";text-align:right;direction:rtl">  كما ذكرنا سابقًا ، سيتم تحويل كل شيء في النهاية إلى وحدات بكسل سيتم عرضها على الشاشة ، <em>وسيحول إطار عمل الرفرفة</em> <em>الأدوات</em> التي نستخدمها لتطوير التطبيق إلى كتل بصرية سيتم عرضها على الشاشة. </p><br><p style=";text-align:right;direction:rtl">  تتوافق هذه الأجزاء المرئية مع كائنات تسمى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">RenderObject</a> ، والتي تستخدم في: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تحديد مساحة معينة من الشاشة من حيث الحجم والموقع والهندسة ، وكذلك من حيث <em>"المحتوى المقدم"</em> </li><li style=";text-align:right;direction:rtl">  تحديد مناطق الشاشة التي يمكن أن تتأثر بالإيماءات (= لمسة إصبع) </li></ul><br><p style=";text-align:right;direction:rtl">  تشكل مجموعة من جميع <em>RenderObjects</em> شجرة تدعى <em>Render Tree</em> .  في الجزء العلوي من هذه الشجرة (= <em>الجذر</em> ) نجد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">RenderView</a> . </p><br><p style=";text-align:right;direction:rtl">  يوفر <em>RenderView</em> سطحًا مشتركًا لكائنات <em>Render Tree</em> وهو إصدار خاص من <em>RenderObject</em> . </p><br><p style=";text-align:right;direction:rtl">  بصريا ، يمكننا تمثيل كل هذا على النحو التالي: <br><img src="https://habrastorage.org/webt/yi/aq/6v/yiaq6vvo9ssed0qtewkftfwrmpy.png"></p><br><p style=";text-align:right;direction:rtl">  ستتم مناقشة العلاقة بين <em>Widget</em> و <em>RenderObject</em> لاحقًا.  في غضون ذلك ، حان الوقت للتعمق قليلاً ... </p><br><h2 id="inicializaciya-bindings" style=";text-align:right;direction:rtl">  ربط التهيئة </h2><br><p style=";text-align:right;direction:rtl"> عند بدء تشغيل تطبيق <code>runApp(Widget app)</code> ، تسمى الوظيفة <code>main()</code> أولاً ، والتي تستدعي في <code>runApp(Widget app)</code> طريقة تشغيل <code>runApp(Widget app)</code> . </p><br><p style=";text-align:right;direction:rtl">  عندما يتم <code>runApp()</code> طريقة <code>runApp()</code> <em>Flutter Framework</em> بتهيئة الواجهات بينه وبين <em>محرك Flutter</em> .  تسمى هذه واجهات <strong>الربط</strong> ( <em>ملاحظة: الربط</em> ). </p><br><p style=";text-align:right;direction:rtl">  <strong>مقدمة إلى الارتباطات</strong> </p><br><p style=";text-align:right;direction:rtl">  الروابط مصممة لتكون الرابط بين الإطار ومحرك الرفرفة.  فقط من خلال الارتباطات يمكن تبادل البيانات بين <em>Flutter Framework</em> و <em>Flutter Engine</em> . <br>  <em>(هناك استثناء واحد فقط لهذه القاعدة -</em> RenderView <em>، لكننا سنناقش هذا لاحقًا).</em> </p><br><p style=";text-align:right;direction:rtl">  كل رابط مسؤول عن معالجة مجموعة من المهام والإجراءات والأحداث المحددة ، مجمعة حسب مجال النشاط. </p><br><p style=";text-align:right;direction:rtl">  في وقت كتابة هذا التقرير ، كان لدى <em>Flutter Framework</em> 8 روابط. </p><br><p style=";text-align:right;direction:rtl">  أدناه 4 منها التي سيتم النظر فيها في هذه المقالة: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <em>SchedulerBinding</em> </li><li style=";text-align:right;direction:rtl">  <em>لفتة ملزمة</em> </li><li style=";text-align:right;direction:rtl">  <em>العارض ملزم</em> </li><li style=";text-align:right;direction:rtl">  <em>الحاجيات ملزمة</em> </li></ul><br><p style=";text-align:right;direction:rtl">  للتأكد من اكتمالها ، سأذكر الأربعة المتبقية: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <em>ServicesBinding</em> : مسؤول عن معالجة الرسائل المرسلة بواسطة <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">قناة النظام الأساسي</a></em> </li><li style=";text-align:right;direction:rtl">  <em>PaintingBinding</em> : مسؤولة عن معالجة ذاكرة التخزين المؤقت للصور </li><li style=";text-align:right;direction:rtl">  <em>SemanticsBinding</em> : مخصص للتنفيذ اللاحق لكل ما يتعلق بالدلالات </li><li style=";text-align:right;direction:rtl">  <em>TestWidgetsFlutterBinding</em> : يستخدم من قبل مكتبة اختبار عنصر واجهة المستخدم </li></ul><br><p style=";text-align:right;direction:rtl">  يمكنك أيضًا ذكر <em>WidgetsFlutterBinding</em> ، لكن هذا ليس ملزماً حقًا ، ولكنه نوع من <em>"مُهيئ الربط"</em> . </p><br><p style=";text-align:right;direction:rtl">  يوضح الرسم البياني التالي التفاعل بين الروابط ، والتي سأنظر فيها بعد ذلك ، <em>ومحرك الرفرفة</em> . </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/ws/ph/x_/wsphx_tme3caqf0qimfk0wxur9g.png"></p><br><p style=";text-align:right;direction:rtl">  دعنا ننظر إلى كل من هذه الروابط "الأساسية". </p><br><h3 id="schedulerbinding" style=";text-align:right;direction:rtl">  SchedulerBinding </h3><br><p style=";text-align:right;direction:rtl">  هذا الربط له مسؤوليتان رئيسيتان: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  قل <em>Flutter Engine</em> : <em>"مهلا! في المرة القادمة عندما لا تكون مشغولاً ، استيقظي حتى أتمكن من العمل قليلاً وأخبرك بما تريد تقديمه ، أو إذا كنت بحاجة إلى الاتصال بي لاحقًا ..."</em> </li><li style=";text-align:right;direction:rtl">  استمع إلى مثل هذه <em>"الصحوات المزعجة"</em> والرد عليها (انظر أدناه) </li></ul><br><p style=";text-align:right;direction:rtl">  متى تطلب خدمة <em>SchedulerBinding</em> <em>مكالمة إيقاظ</em> ؟ </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  عندما يجب أن <em>يعمل المؤشر على علامة</em> جديدة </p><br><p style=";text-align:right;direction:rtl">  على سبيل المثال ، لديك رسم متحرك ، يمكنك تشغيله.  يتم اقتصاص الرسوم المتحركة باستخدام <em>Ticker</em> ، والذي يتم استدعاؤه على فترات منتظمة (= <em>علامة</em> ) لإجراء <em>رد اتصال</em> .  من أجل إطلاق <em>رد</em> اتصال من هذا القبيل ، نحتاج إلى إخبار <em>محرك Flutter</em> بحيث يستيقظ لنا أثناء التحديث التالي (= <em>Begin Frame</em> ).  سيؤدي هذا إلى تشغيل رد الاتصال <em>المؤشر</em> لإكمال مهمته.  إذا كان لا يزال يتعين على <em>المؤشر</em> متابعة التنفيذ ، فسوف يقوم في نهاية المهمة باستدعاء <em>SchedulerBinding</em> لجدولة إطار آخر. </p><br></li><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  عندما لتحديث العرض </p><br><p style=";text-align:right;direction:rtl">  على سبيل المثال ، نحتاج إلى إجراء حدث يؤدي إلى تغيير مرئي (على سبيل المثال: تحديث لون جزء من الشاشة ، التمرير ، إضافة / إزالة شيء من الشاشة) ، لهذا نحتاج إلى اتخاذ الخطوات اللازمة لعرض الصورة المحدثة في النهاية على الشاشة.  في هذه الحالة ، عند حدوث مثل هذا التغيير ، يقوم <em>Flutter Framework</em> باستدعاء <em>SchedulerBinding</em> لجدولة إطار آخر باستخدام <em>Flutter Engine</em> .  <em>(في وقت لاحق سوف نرى كيف يعمل هذا في الواقع)</em> </p><br></li></ul><br><h3 id="gesturebinding" style=";text-align:right;direction:rtl">  لفتة ملزمة </h3><br><p style=";text-align:right;direction:rtl">  يستمع هذا الربط إلى التفاعل مع المحرك من حيث <em>"الإصبع"</em> (= <em>لفتة</em> ). </p><br><p style=";text-align:right;direction:rtl">  وبصفة خاصة ، يكون مسؤولاً عن تلقي البيانات المتعلقة <em>بالإصبع</em> وعن تحديد الجزء (الأجزاء) من الشاشة التي تعمل بها الإيماءات.  ثم يخطر وفقا لذلك / من هذه الأجزاء. </p><br><h3 id="rendererbinding" style=";text-align:right;direction:rtl">  العارض ملزم </h3><br><p style=";text-align:right;direction:rtl">  هذا الربط هو الرابط بين <em>Flutter Engine</em> و <em>Render Tree</em> .  هي المسؤولة عن: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  الاستماع إلى الأحداث التي تم إنشاؤها بواسطة المحرك للإبلاغ عن التغييرات التي يطبقها المستخدم من خلال إعدادات الجهاز التي تؤثر على المؤثرات المرئية و / أو الدلالات </li><li style=";text-align:right;direction:rtl">  رسالة إلى المحرك حول التغييرات التي سيتم تطبيقها على الشاشة </li></ul><br><p style=";text-align:right;direction:rtl">  لتوفير التغييرات التي سيتم عرضها على الشاشة ، يكون <em>RendererBinding</em> مسؤولاً عن إدارة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">PipelineOwner</a> وتهيئة <strong>RenderView</strong> . </p><br><p style=";text-align:right;direction:rtl">  <em>PipelineOwner</em> هي نوع من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">الأوركسترا</a> التي تعرف ما يجب القيام به مع <em>RenderObject</em> وفقًا <em>للمكون</em> ، وتنسق هذه الإجراءات. </p><br><h3 id="widgetsbinding" style=";text-align:right;direction:rtl">  الحاجيات ملزمة </h3><br><p style=";text-align:right;direction:rtl">  يستمع هذا الربط إلى التغييرات التي يطبقها المستخدم من خلال إعدادات الجهاز التي تؤثر على اللغة (= <em>الإعدادات المحلية</em> ) <em>والدلالات</em> . </p><br><blockquote style=";text-align:right;direction:rtl">  <em>ملاحظة صغيرة</em> <br><br>  <em>أفترض أنه في مرحلة لاحقة من تطور</em> Flutter ، <em>سيتم نقل جميع الأحداث المتعلقة بالدلالات إلى</em> SemanticsBinding <em>، ولكن في وقت كتابة هذا التقرير ، لم تكن هذه هي الحالة.</em> </blockquote><p style=";text-align:right;direction:rtl">  بالإضافة إلى ذلك ، فإن <em>WidgetsBinding</em> هو الرابط بين الحاجيات <em>ومحرك الرفرفة</em> .  هي المسؤولة عن: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إدارة عملية معالجة التغييرات هيكل القطعة </li><li style=";text-align:right;direction:rtl">  تقديم دعوة </li></ul><br><p style=";text-align:right;direction:rtl">  تتم معالجة التغييرات في هيكل الحاجيات باستخدام <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">BuildOwner</a> . </p><br><p style=";text-align:right;direction:rtl">  <em>يقوم BuildOwner</em> بتتبع الأدوات التي تحتاج إلى إعادة <em>إنشائها</em> ، ويتعامل مع المهام الأخرى التي تنطبق على بنية عنصر واجهة المستخدم ككل. </p><br><h1 id="chast-2-ot-vidzhetov-k-pikselyam" style=";text-align:right;direction:rtl">  الجزء 2. من الحاجيات إلى بكسل </h1><br><p style=";text-align:right;direction:rtl">  الآن وقد تعلمنا أساسيات العمل الداخلي <em>لـ Flutter</em> ، فقد حان الوقت للتحدث عن التطبيقات المصغّرة. </p><br><p style=";text-align:right;direction:rtl">  في جميع وثائق Flutter ، سوف تقرأ أن جميع <em>الحاجيات</em> (الحاجيات). </p><br><p style=";text-align:right;direction:rtl">  هذا صحيح تقريبا.  ولكي أكون أكثر دقة ، أود أن أقول: </p><br><blockquote style=";text-align:right;direction:rtl">  من جانب المطور ، يتم كل ما يتعلق بواجهة المستخدم من حيث التخطيط والتفاعل باستخدام التطبيقات المصغرة. </blockquote><p style=";text-align:right;direction:rtl">  لماذا الكثير من الدقة؟  إلى جانب حقيقة أن <em>القطعة</em> تتيح للمطور تحديد جزء من الشاشة من حيث الحجم والمحتوى والتخطيط والتفاعل ، إلا <strong>أن</strong> هناك ما هو أكثر من ذلك بكثير.  فما هي <em>القطعة</em> حقا؟ </p><br><h2 id="neizmenyaemaya-konfiguraciya" style=";text-align:right;direction:rtl">  التكوين غير قابل للتغيير </h2><br><p style=";text-align:right;direction:rtl">  إذا نظرت إلى شفرة مصدر <em>Flutter</em> ، ستلاحظ التعريف التالي لفئة <em>القطعة</em> . </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.key })</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Key key; ... }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ماذا يعني هذا؟ </p><br><p style=";text-align:right;direction:rtl">  يعد التعليق التوضيحي <strong>"immutable"</strong> مهمًا للغاية ويخبرنا أن <strong>أي متغير في فئة</strong> <strong>عنصر</strong> <strong>واجهة المستخدم يجب أن يكون نهائيًا</strong> ، بمعنى آخر: "يتم تعريفه <strong>وتعيينه مرة واحدة لكل شخص</strong> ."  وبالتالي ، بعد إنشاء مثيل ، لن تتمكن القطعة بعد الآن من تغيير متغيراتها الداخلية. </p><br><blockquote style=";text-align:right;direction:rtl">  <em>نظرًا لأن القطعة غير قابلة للتغيير ، يمكن اعتبارها تكوينًا ثابتًا.</em> </blockquote><br><h2 id="ierarhicheskaya-struktura-vidzhetov" style=";text-align:right;direction:rtl">  الهيكل الهرمي للحاجيات </h2><br><p style=";text-align:right;direction:rtl">  عندما تقوم بالتصميم باستخدام Flutter ، فإنك تحدد بنية شاشتك (شاشات) باستخدام عناصر واجهة مستخدم مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SafeArea( child: Scaffold( appBar: AppBar( title: Text(<span class="hljs-string"><span class="hljs-string">'My title'</span></span>), ), body: Container( child: Center( child: Text(<span class="hljs-string"><span class="hljs-string">'Centered Text'</span></span>), ), ), ), ); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يستخدم هذا المثال 7 الحاجيات التي تشكل معا بنية هرمية.  مخطط مبسط للغاية على أساس هذا الرمز هو كما يلي: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/f2/ke/dt/f2kedtux7_ot2issfzbv64n3uak.png"></p><br><p style=";text-align:right;direction:rtl">  كما ترون ، فإن الرسم البياني المقدم يشبه شجرة ، حيث <em>SafeArea</em> هو جذرها. </p><br><h2 id="les-za-derevyami" style=";text-align:right;direction:rtl">  الغابات وراء الأشجار </h2><br><p style=";text-align:right;direction:rtl">  كما تعلمون بالفعل ، يمكن أن يكون عنصر واجهة المستخدم عبارة عن تجميع لعناصر واجهة المستخدم الأخرى.  كمثال ، يمكنك تعديل الكود السابق كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyOwnWidget(); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يفترض هذا الخيار أن الأداة <em>"MyOwnWidget"</em> نفسها ستعرض <em>SafeArea</em> ، <em>سقالة</em> .  لكن الشيء الأكثر أهمية في هذا المثال هو ذلك </p><br><blockquote style=";text-align:right;direction:rtl">  يمكن <em>لعنصر واجهة المستخدم</em> أن يمثل ورقة أو عقدة في شجرة ، أو حتى الشجرة نفسها ، أو لم لا ، غابة من الأشجار ... </blockquote><br><h2 id="ponimanie-element-v-dereve" style=";text-align:right;direction:rtl">  فهم <em>العنصر</em> في شجرة </h2><br><p style=";text-align:right;direction:rtl">  ما علاقة هذا به؟ </p><br><p style=";text-align:right;direction:rtl">  كما سيظهر لاحقًا ، لكي تتمكن من إنشاء وحدات بكسل تشكل الصورة المعروضة على الجهاز ، يجب أن يعرف <em>Flutter</em> بالتفصيل جميع الأجزاء الصغيرة التي تتكون منها الشاشة ، ولتحديد جميع الأجزاء ، فإنه يحتاج إلى معرفة <strong>توسيع</strong> جميع عناصر واجهة المستخدم. </p><br><p style=";text-align:right;direction:rtl">  لتوضيح هذه النقطة ، ضع في اعتبارك مبدأ الدمية المتداخلة: عندما تغلق ، ترى دمية واحدة فقط ، ولكنها تحتوي على دمية أخرى ، والتي بدورها تحتوي على دمية أخرى وهكذا ... </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/9x/kq/lb/9xkqlbngsofs0w7m71rx2yucnzy.png"></p><br><p style=";text-align:right;direction:rtl">  عندما يوسع <em>Flutter</em> جميع الأدوات <em>(جزء من الشاشة)</em> ، سيكون الأمر مثل الحصول على جميع الدمى <em>(جزء من الكل)</em> . </p><br><p style=";text-align:right;direction:rtl">  تُظهر الصورة أدناه جزءًا من الهيكل الهرمي النهائي لعناصر الواجهة المطابقة للرمز السابق.  باللون الأصفر ، قمت بتمييز عناصر واجهة المستخدم التي تم ذكرها في الكود سابقًا ، بحيث يمكنك تعريفها في الشجرة النهائية. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/mp/lw/-o/mplw-oisztyx_zvwf8kvpl2tpog.png"></p><br><blockquote style=";text-align:right;direction:rtl">  <strong><em>توضيح مهم</em></strong> <br><br>  <em>لغة "Widget tree" موجودة فقط لسهولة الفهم ، لأن المبرمجين يستخدمون عناصر واجهة تعامل المستخدم ، ولكن لا توجد شجرة عنصر واجهة مستخدم في Flutter!</em> <br><br>  <em>في الواقع ، سيكون من الأصح قول "شجرة العناصر"</em> </blockquote><p style=";text-align:right;direction:rtl">  لقد حان الوقت لتقديم مفهوم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">العنصر</a> . </p><br><blockquote style=";text-align:right;direction:rtl">  <em><strong>كل</strong> عنصر واجهة مستخدم لديه عنصر <strong>واحد</strong> .</em>  <em>ترتبط العناصر مع بعضها البعض وتشكل شجرة.</em>  <em>لذلك ، <strong>العنصر</strong> هو إشارة إلى شيء في الشجرة.</em> </blockquote><p style=";text-align:right;direction:rtl">  بادئ ذي بدء ، فكر في عنصر كعقدة لها أصل وربما طفل.  من خلال الربط بينهما من خلال علاقة <em>الوالدين والطفل</em> ، نحصل على بنية شجرة. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/bd/cx/t4/bdcxt4slijkhhc5j0fnipnauyey.png"></p><br><p style=";text-align:right;direction:rtl">  كما ترون ، يشير العنصر إلى عنصر واجهة مستخدم واحد ، <strong>ويمكن أن</strong> يشير أيضًا إلى <em>RenderObject</em> . </p><br><blockquote style=";text-align:right;direction:rtl">  <em>حتى أفضل ... يشير العنصر إلى عنصر واجهة المستخدم الذي <strong>أنشأ</strong> هذا العنصر!</em> </blockquote><p style=";text-align:right;direction:rtl">  لنلخص: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا توجد شجرة عنصر واجهة مستخدم ، ولكن هناك شجرة عنصر </li><li style=";text-align:right;direction:rtl">  يتم إنشاء عناصر بواسطة الحاجيات. </li><li style=";text-align:right;direction:rtl">  يشير العنصر إلى عنصر واجهة المستخدم الذي قام بإنشائه. </li><li style=";text-align:right;direction:rtl">  العناصر المرتبطة بالعلاقات الأم </li><li style=";text-align:right;direction:rtl">  قد يكون عنصر "طفل". </li><li style=";text-align:right;direction:rtl">  يمكن أن تشير العناصر أيضًا إلى <em>RenderObject.</em> </li></ul><br><blockquote style=";text-align:right;direction:rtl">  <em>تحدد <strong>العناصر</strong> كيفية ارتباط أجزاء الكتل المعروضة ببعضها البعض.</em> </blockquote><p style=";text-align:right;direction:rtl">  لكي نتخيل بشكل أفضل أين يتناسب مفهوم <em>العنصر</em> ، دعنا ننظر إلى التمثيل المرئي التالي: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/x5/vb/jt/x5vbjtq_5fhuyhvc2s7jnt7pbai.png"></p><br><p style=";text-align:right;direction:rtl">  كما ترى ، فإن شجرة العنصر هي العلاقة الفعلية بين عناصر واجهة <em>التعامل</em> و <em>RenderObjects</em> . </p><br><p style=";text-align:right;direction:rtl">  ولكن لماذا تقوم <em>القطعة</em> بإنشاء <em>عنصر</em> ؟ </p><br><h2 id="3-kategorii-vidzhetov" style=";text-align:right;direction:rtl">  3 فئات من الحاجيات </h2><br><p style=";text-align:right;direction:rtl">  في Flutter ، يتم تقسيم التطبيقات المصغّرة إلى 3 فئات ، وأنا أسميها شخصيًا على النحو التالي <em>(ولكن هذه هي طريقتي فقط لتصنيفها)</em> : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  الوكيل </p><br><p style=";text-align:right;direction:rtl">  تتمثل المهمة الرئيسية لهذه الأدوات المصغّرة في تخزين بعض المعلومات (التي يجب أن تكون في متناول الأدوات المصغّرة) ، وهي جزء من بنية الشجرة استنادًا إلى الوكيل.  مثال على هذه الحاجيات هو <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">InheritedWidget</a></strong> أو <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">LayoutId</a></strong> . </p><br><p style=";text-align:right;direction:rtl">  لا تشارك هذه التطبيقات المصغّرة بشكل مباشر في تكوين واجهة المستخدم ، ولكنها تستخدم للحصول على المعلومات التي يمكن أن توفرها. </p><br></li><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  العارض </p><br><p style=";text-align:right;direction:rtl">  ترتبط هذه الحاجيات مباشرةً بتخطيط الشاشة ، لأنها تحدد (أو تستخدم لتحديد) <em>الحجم</em> <em>والموضع</em> <em>والعرض</em> .  الأمثلة النموذجية هي: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">الصف</a></strong> ، <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">العمود</a></strong> ، <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">المكدس</a></strong> ، وكذلك <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">الحشو</a></strong> ، <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">المحاذاة</a></strong> ، <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">العتامة</a></strong> ، <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">RawImage</a></strong> ... </p><br></li><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  عنصر </p><br><p style=";text-align:right;direction:rtl">  هذه هي الأدوات المصغرة الأخرى التي لا تقدم مباشرة المعلومات النهائية المتعلقة بالأحجام والمواقع والمظهر ، بل هي البيانات (أو النصائح) التي سيتم استخدامها للحصول على المعلومات النهائية للغاية.  يشار إلى هذه الحاجيات عادة باسم المكونات. </p><br><p style=";text-align:right;direction:rtl">  أمثلة: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">RaisedButton</a></strong> ، <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">سقالة</a></strong> ، <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">نص</a></strong> ، <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">GestureDetector</a></strong> ، <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">حاوية</a></strong> ... </p><br></li></ul><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/oe/j0/j7/oej0j75h_3ycogohqdckq5e03im.png"></p><br><p style=";text-align:right;direction:rtl">  يسرد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">ملف PDF</a> معظم الأدوات المصنفة حسب الفئة. </p><br><p style=";text-align:right;direction:rtl">  لماذا هذا الفصل مهم؟  لأنه استنادًا إلى فئة عنصر واجهة المستخدم ، يرتبط نوع العنصر المقابل بـ ... </p><br><h2 id="tipy-elementov" style=";text-align:right;direction:rtl">  أنواع العناصر </h2><br><p style=";text-align:right;direction:rtl">  هناك عدة أنواع من العناصر: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/or/au/yc/orauycfegkvfnjlmjws4x4ftpuw.png"></p><br><p style=";text-align:right;direction:rtl">  كما ترون في الصورة أعلاه ، تنقسم العناصر إلى نوعين رئيسيين: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  ComponentElement </p><br><p style=";text-align:right;direction:rtl">  هذه العناصر ليست مسؤولة <strong>بشكل مباشر</strong> عن تقديم أي جزء من الشاشة. </p><br></li><li style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  RenderObjectElement </p><br><p style=";text-align:right;direction:rtl">  هذه العناصر مسؤولة عن أجزاء من الصورة المعروضة على الشاشة. </p><br></li></ul><br><p style=";text-align:right;direction:rtl">  ! ممتاز  الكثير من المعلومات ، لكن ما علاقة كل هذا ببعضه البعض ولماذا من المثير للاهتمام التحدث عنه؟ </p><br><h2 id="kak-vidzhety-i-elementy-rabotayut-vmeste" style=";text-align:right;direction:rtl">  كيف تعمل عناصر واجهة المستخدم الرسومية معًا </h2><br><blockquote style=";text-align:right;direction:rtl">  <em>في Flutter ، تعتمد جميع الميكانيكا على إبطال عنصر أو تقديم renderObject.</em> </blockquote><p style=";text-align:right;direction:rtl">  يمكن إبطال العنصر بالطرق التالية: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  باستخدام <code>setState</code> ، الذي يبطل <strong>StatefulElement</strong> بأكمله (لاحظ أنني لا أقول عن قصد <em>StatefulWidget</em> ) </li><li style=";text-align:right;direction:rtl">  من خلال الإشعارات التي تتم معالجتها بواسطة <strong>proxyElement</strong> (على سبيل المثال ، InheritedWidget) ، والتي تبطل أي <em>عنصر</em> يعتمد على هذا <em>proxyElement</em> </li></ul><br><p style=";text-align:right;direction:rtl">  نتيجة <em>الإبطال</em> هي ظهور رابط <em>للعنصر</em> المقابل في قائمة العناصر <strong>القذرة</strong> . </p><br><p style=";text-align:right;direction:rtl">  يعني <em>إبطال renderObject</em> أن بنية العناصر لا تتغير على الإطلاق ، ولكن هناك تغيير على مستوى <em>renderObject</em> ، على سبيل المثال: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تغيير حجمها ، والموقف ، والهندسة ... </li><li style=";text-align:right;direction:rtl">  يجب إعادة طلاء شيء ما ، على سبيل المثال ، عندما تقوم فقط بتغيير لون الخلفية ونمط الخط ... </li></ul><br><p style=";text-align:right;direction:rtl">  نتيجة هذا <em>الإبطال</em> هي ارتباط إلى <em>renderObject</em> المطابق في قائمة كائنات العرض <em>(renderObjects)</em> التي تحتاج إلى إعادة بناء أو إعادة طلاؤها. </p><br><p style=";text-align:right;direction:rtl">  بغض النظر عن نوع الإبطال ، يسمى <strong>SchedulerBinding</strong> (تذكر هذا؟) لطلب <strong>محرك Flutter</strong> لجدولة إطار جديد. </p><br><p style=";text-align:right;direction:rtl">  هذه هي بالضبط اللحظة التي يستيقظ فيها " <em>Flutter Engine</em> " على " <em>المجدول الزمني</em> " ويحدث كل السحر ... </p><br><h2 id="ondrawframe" style=";text-align:right;direction:rtl">  onDrawFrame () </h2><br><p style=";text-align:right;direction:rtl">  في وقت سابق من هذه المقالة ، لاحظنا أن <em>SchedulerBinding</em> يتحمل مسؤوليتين رئيسيتين ، أحدهما استعداده للتعامل مع الطلبات المقدمة من <em>Flutter Engine</em> المتعلقة بإعادة إنشاء الإطار.  هذه هي اللحظة المثالية للتركيز على هذا. </p><br><p style=";text-align:right;direction:rtl">  يوضح الرسم البياني التسلسل الجزئي أدناه ما يحدث عندما يتلقى <em>SchedulerBinding</em> طلب <em>onDrawFrame ()</em> من <em>محرك</em> <em>Flutter</em> . </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/b8/mz/ba/b8mzbav2krwuwat0ibyvd5gngs4.png"></p><br><p style=";text-align:right;direction:rtl">  <strong>الخطوة 1. العناصر</strong> </p><br><p style=";text-align:right;direction:rtl">  <em>يسمى WidgetsBinding</em> ، وهذا الربط يأخذ في الاعتبار التغييرات المرتبطة بالعناصر.  يستدعي <em>WidgetsBinding</em> أسلوب <em>buildScope الخاص</em> بالكائن <em>buildOwner</em> ، لأن <strong>BuildOwner</strong> مسؤول عن معالجة شجرة العنصر.  تمر هذه الطريقة بقائمة العناصر <em>القذرة</em> وتطلب <strong>إعادة بنائها</strong> . </p><br><p style=";text-align:right;direction:rtl">  المبادئ الرئيسية لأسلوب <code>rebuild()</code> ) هي: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يوجد طلب لإعادة بناء العنصر (سيستغرق ذلك معظم الوقت) ، استدعاء الأسلوب <code>build()</code> لعنصر واجهة المستخدم الذي يشير إليه هذا العنصر (= أسلوب <code>Widget build (BuildContext context) {...}</code> ).  ستُرجع طريقة <code>build()</code> عنصر واجهة مستخدم جديد </li><li style=";text-align:right;direction:rtl">  إذا لم يكن للعنصر "أطفال" ، فسيتم إنشاء عنصر للعنصر الجديد (انظر أدناه) ( <em>ملاحظة: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">inflateWidget</a></em> ) ، وإلا </li><li style=";text-align:right;direction:rtl">  تتم مقارنة عنصر واجهة تعامل المستخدم الجديد مع العنصر المشار إليه بواسطة عنصر العنصر <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إذا كانت قابلة للتبديل (= <em>نفس نوع عنصر واجهة المستخدم ومفتاحه</em> ) ، فسيحدث التحديث ويتم حفظ الطفل. </li><li style=";text-align:right;direction:rtl">  إذا لم تكن قابلة للتبديل ، فسيتم تجاهل الطفل (تقريبًا) ويتم إنشاء عنصر لعنصر واجهة المستخدم الجديد </li></ul></li><li style=";text-align:right;direction:rtl">  يتم تثبيت هذا العنصر الجديد كطفل للعنصر.  ( <em>محمّل)</em> = مدرج في شجرة العناصر) </li></ol><br><p style=";text-align:right;direction:rtl">  ستحاول الرسوم المتحركة التالية جعل هذا الشرح أكثر وضوحًا. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/71/91/xc/7191xcnbg00lbho_ol_9vaczdca.gif"></p><br><p style=";text-align:right;direction:rtl">  <strong>ملاحظة على الحاجيات والعناصر</strong> </p><br><p style=";text-align:right;direction:rtl">  بالنسبة لعنصر واجهة تعامل مستخدم جديد ، يتم إنشاء عنصر من <em>نوع معين</em> يتوافق مع <em>فئة</em> عنصر واجهة <em>تعامل المستخدم</em> ، وهو: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <em>InheritedWidget</em> -&gt; <em>InheritedElement</em> </li><li style=";text-align:right;direction:rtl">  <em>StatefulWidget</em> -&gt; <em>StatefulElement</em> </li><li style=";text-align:right;direction:rtl">  <em>StatelessWidget</em> -&gt; <em>StatelessElement</em> </li><li style=";text-align:right;direction:rtl">  <em>InheritedModel</em> -&gt; <em>InheritedModelElement</em> </li><li style=";text-align:right;direction:rtl">  <em>InheritedNotifier</em> -&gt; <em>InheritedNotifierElement</em> </li><li style=";text-align:right;direction:rtl">  <em>LeafRenderObjectWidget</em> -&gt; <em>LeafRenderObjectElement</em> </li><li style=";text-align:right;direction:rtl">  <em>SingleChildRenderObjectWidget</em> -&gt; <em>SingleChildRenderObjectElement</em> </li><li style=";text-align:right;direction:rtl">  <em>MultiChildRenderObjectWidget</em> -&gt; <em>MultiChildRenderObjectElement</em> </li><li style=";text-align:right;direction:rtl">  <em>ParentDataWidget</em> -&gt; <em>ParentDataElement</em> </li></ul><br><p style=";text-align:right;direction:rtl">  كل من هذه الأنواع من العناصر لديها سلوكها الخاص.  على سبيل المثال: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  ستقوم <em>StatefulElement</em> باستدعاء طريقة <code>widget.createState()</code> عند التهيئة ، والتي ستنشئ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">حالة</a> <code>widget.createState()</code> بالعنصر </li><li style=";text-align:right;direction:rtl">  عندما يتم تثبيت عنصر من النوع <em>RenderObjectElement</em> ، فإنه ينشئ <em>RenderObject</em> .  ستتم إضافة <em>renderObject</em> هذه إلى <em>Render Tree</em> وترتبط بالعنصر. </li></ul><br><p style=";text-align:right;direction:rtl">  <strong>الخطوة 2. renderObjects</strong> </p><br><p style=";text-align:right;direction:rtl">  الآن بعد الانتهاء من جميع الإجراءات المرتبطة بالعناصر <em>القذرة</em> ، فإن <em>Element Tree</em> مستقرة.  لذلك حان الوقت للنظر في عملية التصور. </p><br><p style=";text-align:right;direction:rtl">  نظرًا لأن <em>RendererBinding</em> مسؤول عن تقديم <em>Render Tree</em> ، فإن <em>WidgetsBinding</em> تستدعي طريقة <code>drawFrame</code> <em>RendererBinding</em> . </p><br><p style=";text-align:right;direction:rtl">  يوضح الرسم التخطيطي الجزئي أدناه تسلسل الإجراءات المنفذة أثناء طلب <em>drawFrame ()</em> . </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/dp/sw/v3/dpswv3gszlwj3f_zwsak0xq91k0.png"></p><br><p style=";text-align:right;direction:rtl">  في هذه الخطوة ، يتم تنفيذ الإجراءات التالية: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <em>يُطلب من</em> كل <em>renderObject</em> موسومة <em>إنشاءها</em> (أي حساب حجمها وهندستها) </li><li style=";text-align:right;direction:rtl">  يتم إعادة رسم كل <em>renderObject التي</em> تحمل علامة " <em>need redrawing</em> " باستخدام طريقة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">الطبقة</a> الخاصة بها </li><li style=";text-align:right;direction:rtl">  يتم تكوين المشهد الناتج وإرساله إلى <em>محرك Flutter</em> ، بحيث يقوم الأخير بنقله إلى شاشة الجهاز </li><li style=";text-align:right;direction:rtl">  أخيرًا ، يتم أيضًا تحديث الدلالات وإرسالها إلى <em>محرك Flutter</em> </li></ul><br><p style=";text-align:right;direction:rtl">  في نهاية سير العمل ، يتم تحديث شاشة الجهاز. </p><br><h1 id="chast-3-obrabotka-zhestov" style=";text-align:right;direction:rtl">  الجزء 3: التعامل مع الإيماءات </h1><br><p style=";text-align:right;direction:rtl">  تتم معالجة الإيماءات (= <em>الأحداث المتعلقة بالإصبع على الزجاج</em> ) باستخدام <em>GestureBinding</em> . </p><br><p style=";text-align:right;direction:rtl">  عندما يرسل <em>Flutter Engine</em> معلومات حول حدث لفتة من خلال <em>window.onPointerDataPacket</em> API ، يقوم <strong>GestureBinding</strong> باعتراضه ، ويقوم ببعض التخزين المؤقت ، و: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يحول الإحداثيات المقدمة من <em>Flutter Engine</em> لمطابقة <strong>نسبة بكسل الجهاز</strong> ، ثم </li><li style=";text-align:right;direction:rtl">  يسترجع من <em>renderView</em> قائمة بجميع <em>RenderObjects</em> الموجودة في جزء من الشاشة المتعلقة بإحداثيات الحدث </li><li style=";text-align:right;direction:rtl">  ثم <em>يتكرر من</em> خلال القائمة الناتجة من <em>renderObjects</em> ويرسل حدثًا ذا صلة إلى كل منهم </li><li style=";text-align:right;direction:rtl">  إذا كان <em>renderObject</em> "يستمع" للأحداث من هذا النوع ، فإنه <em>يعالجها</em> </li></ol><br><p style=";text-align:right;direction:rtl">  نأمل الآن أن أفهم مدى أهمية <em>renderObjects</em> . </p><br><h1 id="chast-4-animacii" style=";text-align:right;direction:rtl">  الجزء 4: الرسوم المتحركة </h1><br><p style=";text-align:right;direction:rtl">  هذا الجزء من المقالة يدور حول مفهوم <strong>الرسوم المتحركة</strong> وفهم عميق لل <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">Ticker</a></strong> . </p><br><p style=";text-align:right;direction:rtl">  عند العمل مع الرسوم المتحركة ، عادة ما تستخدم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">AnimationController</a> أو أي عنصر واجهة مستخدم للرسوم المتحركة ( <em>ملاحظة: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">AnimatedCrossFade</a></em> ). </p><br><p style=";text-align:right;direction:rtl">  في <em>Flutter ،</em> يشير كل ما يتعلق بالرسوم المتحركة إلى <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">Ticker</a></em> .  عندما يكون النشاط نشطًا ، يكون لدى مهمة واحدة فقط: "يطلب من برنامج <em>جدولة</em> الربط تسجيل رد اتصال <em>وإبلاغ محرك Flutter بتنبيهه</em> عند ظهور رد اتصال جديد."  عندما يكون <em>محرك Flutter</em> جاهزًا ، فإنه يستدعي <em>جدولة</em> <em>الربط من</em> خلال طلب: " <em>onBeginFrame</em> ".  <em>SchedulerBinding</em> يصل إلى قائمة رد الاتصال <em>شريط</em> وتنفيذ كل واحدة. </p><br><p style=";text-align:right;direction:rtl">  <em>يتم</em> اعتراض كل <em>علامة من</em> قبل وحدة تحكم "مهتمة" لمعالجتها.  إذا كانت الرسوم المتحركة كاملة ، فسيتم "تعطيل" <em>المؤشر</em> ، وإلا يطلب <em>المؤشر</em> <em>جدولة</em> <em>ملزمة</em> لجدولة رد اتصال جديد.  وهلم جرا ... </p><br><h1 id="polnaya-kartina" style=";text-align:right;direction:rtl">  الصورة كاملة </h1><br><p style=";text-align:right;direction:rtl">  لقد تعلمنا الآن كيف يعمل <em>الرفرفة</em> : </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/5s/tw/w7/5stww7o_izlc6ywpnkmcfkkllbk.png"></p><br><h1 id="buildcontext" style=";text-align:right;direction:rtl">  BuildContext </h1><br><p style=";text-align:right;direction:rtl">  أخيرًا ، عد إلى الرسم البياني الذي يعرض أنواع العناصر المختلفة ، والنظر في توقيع <em>العنصر</em> الجذر: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DiagnosticableTree</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BuildContext</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p style=";text-align:right;direction:rtl">  نرى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">BuildContext</a> الشهيرة جدا!  لكن ما هذا؟ </p><br><p style=";text-align:right;direction:rtl">  <strong>BuildContext</strong> هي واجهة تقوم بتعريف عدد من الأساليب والطرق التي يمكن تنفيذها بواسطة عنصر.  في الغالب <em>يتم</em> استخدام <em>BuildContext</em> في أسلوب <code>build()</code> لـ <em>StatelessWidget</em> أو <em>State</em> for <em>StatefulWidget</em> . </p><br><blockquote style=";text-align:right;direction:rtl">  <em><strong>BuildContext</strong> ليس سوى <strong>العنصر</strong> نفسه ، والذي يطابق</em> <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <em>يتم تحديث عنصر واجهة المستخدم (داخل أساليب <code>builder</code> أو <code>builder</code> )</em> </li><li style=";text-align:right;direction:rtl">  <em>StatefulWidget المقترن بالحالة التي تشير فيها إلى متغير السياق.</em> </li></ul><br></blockquote><p style=";text-align:right;direction:rtl">  هذا يعني أن معظم المطورين يعملون باستمرار مع العناصر دون حتى معرفة ذلك. </p><br><h2 id="naskolko-poleznym-mozhet-byt-buildcontext" style=";text-align:right;direction:rtl">  كيف يمكن أن يكون BuildContext؟ </h2><br><p style=";text-align:right;direction:rtl">  <em>BuildContext</em>  ,   ,      ,  <em>BuildContext</em>   ,  : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">     <em>RenderObject</em> ,   (,     <em>Renderer</em> ,  -) </li><li style=";text-align:right;direction:rtl">   <em>RenderObject</em> </li><li style=";text-align:right;direction:rtl">   .     ,     <code>of</code> (, <code>MediaQuery.of(context)</code> , <code>Theme.of(context)</code> …) </li></ul><br><h2 id="zabavy-radi" style=";text-align:right;direction:rtl">   </h2><br><p style=";text-align:right;direction:rtl"> ,   ,  <em>BuildContext</em> –  <em></em> ,         .  <strong> </strong>   <em>StatelessWidget</em>   ,      <em>StatefulWidget</em> ,    <code>setState()</code> ,    <em>BuildContext</em> . </p><br><blockquote style=";text-align:right;direction:rtl"> <strong></strong> <br> <strong>,    !</strong> <br><br>    – ,  <em>StatelessWidget</em>   . <br>       , ,  <em>StatefulWidget</em> . </blockquote><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ runApp(MaterialApp(home: TestPage(),)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// final because a Widget is immutable (remember?) final bag = {"first": true}; @override Widget build(BuildContext context){ return Scaffold( appBar: AppBar(title: Text('Stateless ??')), body: Container( child: Center( child: GestureDetector( child: Container( width: 50.0, height: 50.0, color: bag["first"] ? Colors.red : Colors.blue, ), onTap: (){ bag["first"] = !bag["first"]; // // This is the trick // (context as Element).markNeedsBuild(); } ), ), ), ); } }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl"> <em> ,    <code>setState()</code> ,         : <code>_element.markNeedsBuild()</code> .</em> </p><br><h1 id="zaklyuchenie" style=";text-align:right;direction:rtl">  استنتاج </h1><br><p style=";text-align:right;direction:rtl">  : "   ".   ,      ,    <em>Flutter</em> ,   ,    ,   ,      .  ,  ,   <em>Widget</em> , <em>Element</em> , <em>BuildContext</em> , <em>RenderObject</em> ,     .   ,       . </p><br><p style=";text-align:right;direction:rtl">     .       . </p><br><p style=";text-align:right;direction:rtl"> PS  ,          () . <br> PSS       <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">Flutter internals</a></strong>  Didier Boelens,           ) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar476018/">https://habr.com/ru/post/ar476018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar476000/index.html">تحديثات منشئ نموذج ML.NET</a></li>
<li><a href="../ar476002/index.html">خبرة في العثور على وظيفة طالب دكتوراه في ألمانيا</a></li>
<li><a href="../ar476004/index.html">مدير المشروع - أسطورة أم حقيقة؟ أو لماذا هو مطلوب في مجال المؤثرات البصرية؟</a></li>
<li><a href="../ar476006/index.html">أساطير وأساطير منشئي SOC ، أو 3 مفاهيم خاطئة حول مراكز لرصد الهجمات الإلكترونية والاستجابة لها</a></li>
<li><a href="../ar476008/index.html">MOSDROID Meetup: الاتصال بالبث</a></li>
<li><a href="../ar476022/index.html">واجهة محل Vue: رفع الواجهة الخلفية</a></li>
<li><a href="../ar476024/index.html">أفضل بنية لـ MVP: متراصة ، الخدمية ، الخدمات المصغرة أو بدون خادم؟ .. الجزء الأول</a></li>
<li><a href="../ar476026/index.html">Cool Life Hacks للعمل مع WSL (نظام Windows الفرعي لنظام التشغيل Linux)</a></li>
<li><a href="../ar476032/index.html">Brunner Elektronik - من نظام CAD إلى قمرة القيادة</a></li>
<li><a href="../ar476034/index.html">والأكثر عوزًا هو الصقر البريجن</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>