<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš ğŸ¤½ ğŸ“… Pengalaman dalam mengimplementasikan otomasi dalam proses pengujian manual pada contoh aplikasi Android ğŸ™ğŸ¿ ğŸ¤µğŸ¾ ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penguji yang baik dengan kemampuan berpikir kritis tidak dapat sepenuhnya diganti oleh otomatisasi. Membuatnya bekerja lebih efisien itu mudah. Dengan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman dalam mengimplementasikan otomasi dalam proses pengujian manual pada contoh aplikasi Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434252/">  <i>Penguji yang baik dengan kemampuan berpikir kritis tidak dapat sepenuhnya diganti oleh otomatisasi.</i>  <i>Membuatnya bekerja lebih efisien itu mudah.</i>  <i>Dengan keyakinan ini, saya pergi ke departemen pengujian kami dengan tugas baru, di mana kami, bersama dengan Pavel, mengambil implementasinya.</i>  <i>Mari kita lihat apa yang terjadi.</i> <br><br>  Bersama dengan mitra kami, kami secara aktif mengembangkan, menguji dan mendukung serangkaian aplikasi untuk berbagai platform: Android, iOS, Windows.  Aplikasi sedang aktif dikembangkan, bersamaan dengan peningkatan volume pengujian, terutama regresi. <br><br>  Kami memutuskan untuk mencoba memfasilitasi dan mempercepat pengujian dengan mengotomatisasi sebagian besar skenario pengujian.  Pada saat yang sama, kami tidak ingin sepenuhnya meninggalkan proses pengujian manual, melainkan memodifikasinya. <br><br>  Implementasi pendekatan ini dimulai dengan salah satu aplikasi Android, yang akan saya bicarakan.  Artikel ini akan menarik bagi penulis pemula tes UI, terutama untuk aplikasi seluler, serta mereka yang ingin mengotomatisasi proses pengujian manual sampai batas tertentu. <br><br>  Ayo pergi! <a name="habracut"></a><br><br><h2>  Titik awal </h2><br>  Untuk setiap platform, kami memiliki beberapa platform serupa yang melakukan proses bisnis aplikasi utama yang sama.  Namun, mereka berbeda satu sama lain dalam satu set fungsi bantu kecil, dibuat di bawah merek yang berbeda tergantung pada pelanggan (karena itu antarmuka berubah dari aplikasi ke aplikasi), dan proses bisnis dapat disesuaikan dengan menambahkan langkah-langkah tambahan. <br><br>  Kami dihadapkan dengan masalah-masalah tertentu yang perlu ditangani.  Kesulitan serupa mungkin timbul dalam situasi yang berbeda dari kita.  Misalnya, jika Anda memiliki satu aplikasi besar dengan logika bisnis yang sulit, ditumbuhi banyak tes. <br><br><h4>  Masalah # 1: banyak tes regresi </h4><br>  Seperangkat skenario pengujian untuk setiap aplikasi secara bersamaan serupa dan berbeda satu sama lain, yang berkontribusi pada peningkatan regresi dan membuatnya bahkan lebih membosankan.  Namun, Anda perlu menguji semua aplikasi secara individual. <br><br>  Menimbang bahwa aplikasi yang sudah berjalan diperbarui secara berkala, dan di masa depan hanya akan ada lebih banyak lagi, jumlah total tes akan bertambah. <br><br><h4>  Masalah nomor 2: Anda perlu menguji pada semua versi OS seluler </h4><br>  Persyaratan penting adalah ketersediaan aplikasi seluler kami pada berbagai versi sistem operasi.  Misalnya, dalam kasus Android pada saat penulisan, ini adalah level API dari 17 hingga 28. <br><br>  Idealnya, kita harus menguji pada setiap versi Android, yang semakin memperumit regresi kita.  Proses pengujian langsung aplikasi memperoleh rutin tambahan yang dikalikan dengan jumlah perangkat: menginstal dan menjalankan aplikasi, membawanya ke keadaan semula setelah setiap tes individu, penghapusan.  Pada saat yang sama, memelihara pertanian perangkat Anda sendiri cukup padat karya. <br><br><h4>  Solusi: mengintegrasikan otomatisasi ke dalam proses pengujian manual </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ts/gc/pf/tsgcpf5ughy1cerkbpdpkkuqxww.jpeg"></div><br>  Tugas khas otomatisasi uji adalah mengotomatiskan uji regresi.  Jadi kami ingin meningkatkan efisiensi proses pengujian hari ini dan mencegah kemungkinan konsekuensi pertumbuhan besok. <br><br>  Pada saat yang sama, kami sangat menyadari bahwa tidak mungkin dan tidak perlu untuk sepenuhnya menghapus pengujian manual dengan otomatisasi.  Pemikiran kritis dan mata manusia sulit untuk digantikan dengan sesuatu.  Ada artikel bagus tentang hal ini di blog Michael Bolton, The <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">End of Manual Testing</a> (atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> dari Anna Rodionova). <br><br>  Kami pikir akan bermanfaat untuk memiliki satu set tes otomatis yang mencakup bagian-bagian aplikasi yang stabil, dan di masa depan tes tertulis untuk bug ditemukan dan fungsionalitas baru.  Pada saat yang sama, kami ingin mengaitkan autotest dengan test suites yang ada dalam sistem manajemen pengujian kami (kami menggunakan TestRail), dan juga memungkinkan penguji untuk dengan mudah menjalankan autotest pada perangkat fisik cloud (kami memilih Firebase Test Lab sebagai infrastruktur cloud). <br><br>  Untuk memulai dan mencoba, kami mengambil salah satu aplikasi Android kami.  Penting untuk mempertimbangkan bahwa jika solusinya berhasil, praktik terbaiknya dapat diterapkan ke aplikasi kami yang lain, termasuk pada platform lain. <br><br>  Apa yang ingin kita dapatkan sebagai hasilnya: <br><br><ol><li>  Otomatisasi pengujian regresi. </li><li>  Integrasi dengan sistem manajemen pengujian. </li><li>  Kemungkinan dimulainya autotest manual berparameter pada perangkat cloud. </li><li>  Kemungkinan menggunakan kembali solusi di masa depan. </li></ol><br>  Selanjutnya, saya akan secara terpisah berbicara tentang implementasi masing-masing poin ini dengan sedikit perendaman dalam komponen teknis. <br><br><h2>  Skema implementasi solusi umum </h2><br>  Tapi pertama-tama, garis besar umum dari apa yang kita dapatkan: <br><br><img src="https://habrastorage.org/webt/k3/dc/yf/k3dcyf4d-az9yt4ce0dqgseko6m.png" alt="gambar"><br><br>  Tes otomatis berjalan dalam dua cara: <br><br><ol><li>  Dari CI setelah menggabungkan atau menarik permintaan untuk dikuasai. </li><li>  Penguji secara manual dari antarmuka web Jenkins Job. </li></ol><br>  Dalam hal peluncuran manual, penguji harus menunjukkan jumlah bangunan yang sesuai, atau mengunduh 2 APK dari komputer: dengan aplikasi dan dengan tes.  Metode ini diperlukan agar Anda dapat menjalankan tes yang diperlukan kapan saja di perangkat apa pun yang tersedia. <br><br>  Selama pengujian, hasilnya dikirim ke TestRail.  Ini terjadi dengan cara yang sama seperti jika tester melakukan tes secara manual dan memasukkan hasilnya dengan cara yang akrab baginya. <br><br>  Jadi, kami meninggalkan proses pengujian manual yang sudah ada, tetapi menambahkan otomatisasi padanya, yang melakukan serangkaian tes tertentu.  Penguji "mengambil" apa yang dilakukan secara otomatis, dan: <br><br><ul><li>  melihat hasil uji kasus pada setiap perangkat yang dipilih; </li><li>  dapat memeriksa ulang setiap test case secara manual; </li><li>  melakukan uji kasus yang belum diotomatisasi, atau tidak dapat dioptimalkan karena alasan apa pun; </li><li>  membuat keputusan akhir pada uji coba saat ini. </li></ul><br>  Sekarang mari kita beralih ke deskripsi implementasi yang dijanjikan. <br><br><h2>  1. Tes otomatis </h2><br><h4>  Alat-alatnya </h4><br>  Kami menggunakan 3 alat untuk berinteraksi dengan antarmuka pengguna: <br><br><ul><li>  Espresso </li><li>  Barista. </li><li>  Pengotomasi UI. </li></ul><br>  Alat utama dan yang kami mulai adalah Espresso.  Argumen utama yang mendukung pilihannya adalah fakta bahwa Espresso memungkinkan Anda untuk menguji menggunakan metode kotak putih, menyediakan akses ke Instrumentasi Android.  Kode tes dalam proyek yang sama dengan kode aplikasi. <br><br>  Akses ke kode aplikasi Android diperlukan untuk memanggil metode dalam pengujian.  Kita dapat menyiapkan aplikasi kita untuk tes tertentu terlebih dahulu dengan menjalankannya dalam kondisi yang tepat.  Kalau tidak, kita perlu mencapai keadaan ini melalui antarmuka, yang menghilangkan tes atomitas, membuatnya tergantung satu sama lain, dan hanya memakan banyak waktu. <br><br>  Selama implementasi, alat lain ditambahkan ke Espresso - UI Automator.  Kedua kerangka kerja adalah bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan Dukungan Pengujian Android Google</a> .  Menggunakan Automator UI, kita dapat berinteraksi dengan berbagai dialog sistem atau, misalnya, Notification Drawer. <br><br>  Dan yang terakhir di gudang kami adalah kerangka kerja Barista.  Ini adalah pembungkus Espresso, menghemat kode boilerplate saat menerapkan tindakan pengguna umum. <br><br>  Mengingat keinginan untuk dapat menggunakan kembali solusi di aplikasi lain, penting untuk dicatat bahwa alat yang terdaftar dimaksudkan khusus untuk aplikasi Android.  Jika Anda tidak memerlukan akses ke kode aplikasi yang sedang diuji, maka mungkin Anda akan lebih suka menggunakan kerangka kerja yang berbeda.  Misalnya, Appium yang sangat populer saat ini.  Meskipun Anda juga dapat mencoba untuk mendapatkan kode aplikasi dengan bantuan backdoors, yang merupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> bagus di blog Badoo.  Pilihan ada di tangan Anda. <br><br><h4>  Implementasi </h4><br>  Sebagai pola desain, kami memilih Pengujian Robot, yang diusulkan oleh Jake Wharton dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> eponymous.  Ide pendekatan ini mirip dengan pola desain Objek Halaman yang umum digunakan dalam pengujian sistem web.  Bahasa pemrogramannya adalah Java. <br><br>  Untuk setiap fragmen independen dari aplikasi, kelas robot khusus dibuat di mana logika bisnis diterapkan.  Interaksi dengan masing-masing elemen fragmen dijelaskan dalam metode terpisah.  Selain itu, semua pernyataan yang dilakukan dalam fragmen ini juga dijelaskan di sini. <br><br>  Pertimbangkan contoh sederhana.  Fragmen yang dijelaskan berisi beberapa bidang untuk memasukkan data dan tombol tindakan: <br><br><img src="https://habrastorage.org/webt/po/-a/il/po-ail1n2mqlusukvegg9ry1tdm.png" alt="gambar"><br><br>  Kode tes fungsi masuk itu sendiri: <br><br><img src="https://habrastorage.org/webt/s2/ot/sd/s2otsd2q-li_26a9vkx_-s_9__g.png" alt="gambar"><br><br>  Di sini kita memeriksa skenario positif ketika data otentikasi yang dimasukkan sudah benar.  Data itu sendiri diserahkan ke tes input, atau nilai standar digunakan.  Dengan demikian, tester memiliki kemampuan untuk membuat parameter dalam hal data uji. <br><br>  Struktur ini pertama-tama memberikan tes keterbacaan yang sangat baik ketika seluruh skrip dibagi menjadi langkah-langkah utama eksekusi.  Kami juga sangat menyukai gagasan mentransfer pernyataan ke metode individual dari robot yang sesuai.  Penegasan menjadi langkah yang sama, tanpa memutus rantai umum, dan tes Anda masih tidak tahu apa-apa tentang aplikasi tersebut. <br><br>  Dalam laporan tersebut di atas, Jake Wharton memberikan implementasi di Kotlin, di mana itu terbatas.  Kami sudah mencobanya di proyek lain dan kami sangat menyukainya. <br><br><h2>  2. Integrasi dengan sistem manajemen pengujian </h2><br>  Sebelum pengenalan otomatisasi, kami melakukan semua pengujian kami dalam sistem manajemen pengujian TestRail.  Berita baiknya adalah ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TestRail API yang</a> cukup bagus, yang dengannya kami dapat menghubungkan kasus uji yang sudah ada dalam sistem dengan autotest. <br><br>  Selama uji coba menggunakan JUnit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RunListener</a> , berbagai peristiwa ditangkap, seperti <code>testRunStarted</code> , <code>testFailure</code> , <code>testFinished</code> , di mana kami mengirim hasilnya ke TestRail.  Jika Anda menggunakan AndroidJUnitRunner, maka ia perlu memberi tahu tentang RunListener Anda dengan cara tertentu, yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a> <br><br>  Anda juga perlu berkomunikasi dengan berbagai entitas TestRail dengan ID mereka.  Jadi, untuk menghubungkan tes dengan test case yang sesuai, kami membuat penjelasan sederhana <code>@CaseId</code> , yang penggunaannya diperlihatkan dalam contoh implementasi pengujian di atas. <br><br>  Kode untuk mengimplementasikan anotasi itu sendiri: <br><br><img src="https://habrastorage.org/webt/oq/pz/2m/oqpz2mc9f_lfnujvzaj2ohpuicc.png" alt="gambar"><br><br>  Tetap hanya untuk mendapatkan nilainya di tempat yang tepat dari Deskripsi: <br><br><img src="https://habrastorage.org/webt/4h/bb/wa/4hbbwa2srlfwol2yies25mm07a8.png" alt="gambar"><br><br><h2>  3. Mulai otomatis dari pengujian otomatis pada perangkat cloud </h2><br><h4>  Parameterisasi Startup dalam Pekerjaan Jenkins </h4><br>  Untuk mengatur awal autotest secara manual, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenkins Job Free-style</a> .  Opsi ini dipilih karena perusahaan telah memiliki beberapa pengalaman dengan pekerjaan serupa dengan Jenkins Job di bidang lain, khususnya dengan insinyur DevOps, yang dengan senang hati mereka bagi. <br><br>  Jenkins Job mengeksekusi skrip berdasarkan data yang ditransfer dari antarmuka web.  Dengan demikian, parameterisasi dari uji coba dilaksanakan.  Dalam kasus kami, skrip Bash memulai peluncuran pengujian pada perangkat cloud Firebase. <br><br>  Parameterisasi meliputi: <br><br><ul><li>  Memilih APK yang diinginkan dengan menentukan jumlah bangunan yang sesuai atau mengunduhnya secara manual. </li><li>  Masukkan semua jenis data uji. </li><li>  Memasukkan data khusus tambahan untuk TestRail. </li><li>  Pilih perangkat fisik berbasis cloud tempat pengujian akan dijalankan dari daftar yang tersedia di Firebase Test Lab. </li><li>  Pemilihan test kit untuk dilakukan. </li></ul><br>  Mari kita lihat bagian halaman web dari Pekerjaan Jenkins kami menggunakan contoh antarmuka pemilihan perangkat dan suite tes: <br><br><img src="https://habrastorage.org/webt/lm/d9/_p/lmd9_pih-p4lu5i_7gd6d2rcazc.png" alt="gambar"><br><br>  Setiap elemen tempat Anda dapat memasukkan atau memilih data diimplementasikan oleh plugin Jenkins khusus.  Misalnya, antarmuka pemilihan perangkat dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Plugin Pilihan Aktif</a> .  Menggunakan skrip asyik dari Firebase, daftar perangkat yang tersedia diperoleh, yang kemudian ditampilkan dalam formulir yang diinginkan di halaman web. <br><br>  Setelah semua data yang diperlukan telah dimasukkan, skrip yang sesuai diluncurkan, kemajuan yang dapat kita amati di bagian Output Konsol: <br><br><img src="https://habrastorage.org/webt/vo/ie/ul/voieulwwrlhexdhsxpw2wwg-qga.png" alt="gambar"><br><br>  Dari sini, penguji yang memulai uji coba dapat pergi ke TestRail atau ke Firebase console menggunakan URL yang diterima, yang berisi banyak informasi berguna tentang menjalankan tes pada setiap perangkat yang dipilih. <br><br><h4>  Matriks Tes Akhir di Firebase Test Lab </h4><br>  Matriks perangkat di Firebase berisi distribusi tes oleh perangkat yang menjalankannya: <br><br><img src="https://habrastorage.org/webt/um/bs/5w/umbs5w2ehvo69ih127ep8i6ulvo.png" alt="gambar"><br><br>  Untuk setiap perangkat, Anda dapat melihat log lengkap, video uji coba, berbagai indikator kinerja.  Selain itu, Anda dapat mengakses semua file yang mungkin telah dibuat selama pelaksanaan tes.  Kami menggunakan ini untuk mengunduh indikator cakupan pengujian dari perangkat. <br><br>  Kami memilih Firebase, karena kami telah menggunakan layanan ini untuk menyelesaikan masalah lain, dan kami puas dengan kebijakan penetapan harga.  Jika Anda memenuhi 30 menit waktu murni untuk pengujian per hari, maka Anda tidak perlu membayar sama sekali.  Ini mungkin menjadi alasan tambahan mengapa penting untuk hanya dapat menjalankan tes tertentu. <br><br>  Anda mungkin lebih memilih infrastruktur cloud lain yang juga cocok dengan proses pengujian Anda. <br><br><h2>  4. Menggunakan kembali </h2><br>  Bagaimana semua ini bisa digunakan di masa depan?  Dari sudut pandang basis kode, solusi ini hanya berlaku untuk aplikasi Android.  Misalnya, selama implementasi, kami telah menambahkan kelas pembantu <code>EspressoExtensions</code> dan <code>UiAutomatorExtensions</code> , di mana kami merangkum berbagai opsi untuk berinteraksi dengan antarmuka dan menunggu elemen siap.  Ini juga termasuk kelas RunListener, yang bertanggung jawab untuk integrasi dengan TestRail.  Kami telah menempatkan mereka dalam modul terpisah dan menggunakannya untuk mengotomatiskan aplikasi lain. <br><br>  Jika kita berbicara tentang platform lain, maka pengalaman yang didapat bisa sangat berguna untuk membangun dan mengimplementasikan proses serupa.  Kami secara aktif melakukan ini di area iOS dan sedang memikirkan Windows. <br><br><h2>  Kesimpulan </h2><br>  Ada banyak opsi untuk menerapkan dan menggunakan uji otomasi.  Kami berpendapat bahwa otomasi terutama merupakan alat yang dirancang untuk memfasilitasi proses tradisional pengujian "manusia", dan bukan untuk memberantasnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434252/">https://habr.com/ru/post/id434252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434236/index.html">Jaringan saraf dengan amuba memecahkan masalah salesman keliling untuk 8 kota</a></li>
<li><a href="../id434238/index.html">Intel OpenVINO di Raspberry Pi: Panen 2018</a></li>
<li><a href="../id434244/index.html">Saya pedagang algo ibu: mencari kerangka kerja gratis untuk menguji hipotesis dan meluncurkan dalam mode pertempuran (Python)</a></li>
<li><a href="../id434246/index.html">Apple mengkonfirmasi beberapa kapal iPad Pro sedikit melengkung, tetapi mengatakan tidak apa-apa</a></li>
<li><a href="../id434250/index.html">Tren keamanan jaringan 2019</a></li>
<li><a href="../id434254/index.html">Mengejar yang terbaik</a></li>
<li><a href="../id434258/index.html">Magang musim dingin untuk pengembang seluler di Redmadrobot</a></li>
<li><a href="../id434260/index.html">Microsoft mengadakan kontes Agen AI di Minecraft</a></li>
<li><a href="../id434262/index.html">Menulis dan menyusun album untuk Linux (Ubuntu 16.04, Ardour, Hydrogen, Kontakt)</a></li>
<li><a href="../id434264/index.html">Intel â„ 2018. Hasil tahun ini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>