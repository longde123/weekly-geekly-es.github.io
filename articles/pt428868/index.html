<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∑ üçø ‚ô£Ô∏è JARs de v√°rias vers√µes - Ruim ou Bom? üõ∑ üëâüèΩ ü§üüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De um tradutor: estamos trabalhando ativamente na tradu√ß√£o da plataforma nos trilhos do Java 11 e estamos pensando em como desenvolver bibliotecas Jav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JARs de v√°rias vers√µes - Ruim ou Bom?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/428868/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/cn/ee/cmcnee4gyidm3xbo-0fl1fatdme.png"></div><br><p>  <em>De um tradutor: estamos trabalhando ativamente na tradu√ß√£o da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plataforma</a> nos trilhos do Java 11 e estamos pensando em como desenvolver bibliotecas Java eficientemente (como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YARG</a> ), levando em considera√ß√£o os recursos do Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8/11,</a> para que voc√™ n√£o precise criar ramifica√ß√µes e lan√ßamentos separados.</em>  <em>Uma solu√ß√£o poss√≠vel √© um JAR de v√°rias vers√µes, mas nem tudo √© tranquilo.</em> </p><br><p>  O Java 9 inclui uma nova op√ß√£o de tempo de execu√ß√£o Java, denominada JARs com v√°rias libera√ß√µes.  Esta √© talvez uma das inova√ß√µes mais controversas da plataforma.  <em>TL; DR: consideramos esta uma solu√ß√£o incorreta para um problema s√©rio</em> .  Neste post, explicaremos por que pensamos assim e tamb√©m mostraremos como criar um JAR, se voc√™ realmente quiser. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JARs multi-release</a> , ou MR JARs, √© um novo recurso da plataforma Java, introduzido no JDK 9. Aqui descreveremos em detalhes os riscos significativos associados ao uso dessa tecnologia e como criar JARs multi-release usando Gradle, se voc√™ ainda quiser. </p><br><p>  De fato, um JAR com v√°rias vers√µes √© um arquivo Java que inclui v√°rias variantes da mesma classe para trabalhar com vers√µes diferentes do tempo de execu√ß√£o.  Por exemplo, se voc√™ estiver trabalhando no JDK 8, o ambiente Java usar√° a vers√£o da classe para o JDK 8 e, no Java 9, ser√° usada a vers√£o do Java 9. Da mesma forma, se a vers√£o for criada para uma libera√ß√£o futura do Java 10, o tempo de execu√ß√£o utilizar√° essa vers√£o em vez da vers√£o para Java 9 ou a vers√£o padr√£o (Java 8). </p><br><p>  Sob o gato, entendemos o dispositivo do novo formato JAR e descobrimos se isso √© tudo. </p><a name="habracut"></a><br><h2 id="kogda-ispolzovat-multi-release-jars">  Quando usar JARs com v√°rias libera√ß√µes </h2><br><ul><li>  Tempo de execu√ß√£o otimizado.  Esta √© uma solu√ß√£o para o problema que muitos desenvolvedores enfrentam: ao desenvolver um aplicativo, n√£o se sabe em qual ambiente ele ser√° executado.  No entanto, para algumas vers√µes do tempo de execu√ß√£o, voc√™ pode incorporar vers√µes gen√©ricas da mesma classe.  Suponha que voc√™ queira exibir o n√∫mero da vers√£o do Java no qual o aplicativo est√° sendo executado.  Para Java 9, voc√™ pode usar o m√©todo Runtime.getVersion.  No entanto, este √© um novo m√©todo dispon√≠vel apenas no Java 9+.  Se voc√™ precisar de outros tempos de execu√ß√£o, por exemplo, Java 8, precisar√° analisar a propriedade java.version.  Como resultado, voc√™ ter√° 2 implementa√ß√µes diferentes de uma fun√ß√£o. </li><li><p>  APIs conflitantes: a resolu√ß√£o de conflitos entre APIs tamb√©m √© um problema comum.  Por exemplo, voc√™ precisa oferecer suporte a dois tempos de execu√ß√£o, mas em um deles a API foi preterida.  Existem 2 solu√ß√µes comuns para esse problema: </p><br><ol><li>  O primeiro √© reflex√£o.  Por exemplo, voc√™ pode especificar a interface VersionProvider, depois 2 classes espec√≠ficas Java8VersionProvider e Java9VersionProvider e carregar a classe correspondente no tempo de execu√ß√£o (√© engra√ßado que, para escolher entre duas classes, voc√™ precise analisar o n√∫mero da vers√£o!).  Uma das op√ß√µes para esta solu√ß√£o √© criar uma √∫nica classe com v√°rios m√©todos chamados usando reflex√£o. </li><li>  Uma solu√ß√£o mais avan√ßada √© usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">al√ßas de m√©todo sempre</a> que poss√≠vel.  Muito provavelmente, o reflexo lhe parecer√° inibit√≥rio e desconfort√°vel e, em geral, do jeito que √©. </li></ol><br></li></ul><br><h2 id="izvestnye-alternativy-podhodu-multi-release-jars">  Alternativas conhecidas para JARs de libera√ß√£o m√∫ltipla </h2><br><p> A segunda maneira, mais simples e compreens√≠vel, √© criar 2 arquivos diferentes para diferentes tempos de execu√ß√£o.  Em teoria, voc√™ cria duas implementa√ß√µes da mesma classe no IDE e compilar, testar e empacot√°-las corretamente em 2 artefatos diferentes √© a tarefa do sistema de constru√ß√£o.  Esta √© uma abordagem que tem sido usada na goiaba ou no Spock h√° muitos anos.  Mas tamb√©m √© necess√°rio para idiomas como o Scala.  E tudo porque existem tantas op√ß√µes para o compilador e o tempo de execu√ß√£o que a compatibilidade bin√°ria se torna quase inating√≠vel. </p><br><p>  Mas existem muitos outros motivos para usar arquivos JAR separados: </p><br><ul><li>  JAR √© apenas uma maneira de embalar. </li></ul><br><p>  √© um artefato de montagem que inclui classes, mas isso n√£o √© tudo: recursos, como regra, tamb√©m s√£o inclu√≠dos no arquivo morto.  A embalagem, como a manipula√ß√£o de recursos, tem um pre√ßo.  A equipe da Gradle visa melhorar a qualidade da compila√ß√£o e reduzir o tempo de espera para o desenvolvedor compilar resultados, testes e o processo de compila√ß√£o em geral.  Se o arquivo morto aparecer no processo muito cedo, um ponto de sincroniza√ß√£o desnecess√°rio ser√° criado.  Por exemplo, para compilar classes dependentes da API, a √∫nica coisa necess√°ria s√£o os arquivos .class.  N√£o s√£o necess√°rios arquivos jar nem recursos no jar.  Da mesma forma, apenas os arquivos e recursos de Grade s√£o necess√°rios para executar os testes Gradle.  Para o teste, n√£o h√° necessidade de criar um jar.  S√≥ ser√° necess√°rio para um usu√°rio externo (ou seja, ao publicar).  Mas se a cria√ß√£o de um artefato se tornar obrigat√≥ria, algumas tarefas n√£o poder√£o ser executadas em paralelo e todo o processo de montagem ser√° inibido.  Se para pequenos projetos isso n√£o √© cr√≠tico, para projetos corporativos de grande escala esse √© o principal fator de desacelera√ß√£o. </p><br><ul><li>  √© muito mais importante que, sendo um artefato, um jar-archive n√£o possa transportar informa√ß√µes sobre depend√™ncias. </li></ul><br><p>  √â improv√°vel que as depend√™ncias de cada classe no tempo de execu√ß√£o Java 9 e Java 8 sejam as mesmas.  Sim, em nosso exemplo simples, isso ser√° verdade, mas para projetos maiores isso n√£o √© verdade: geralmente o usu√°rio importa a backport da biblioteca para a funcionalidade Java 9 e a utiliza para implementar a vers√£o da classe Java 8. No entanto, se voc√™ empacotar as duas vers√µes em um archive, em um artefato haver√° elementos com diferentes √°rvores de depend√™ncia.  Isso significa que se voc√™ estiver trabalhando com Java 9, ter√° depend√™ncias que nunca ser√£o necess√°rias.  Al√©m disso, polui o caminho da classe, criando conflitos prov√°veis ‚Äã‚Äãpara os usu√°rios da biblioteca. </p><br><p>  E, finalmente, em um projeto, voc√™ pode criar JARs para diferentes prop√≥sitos: </p><br><ul><li>  para API </li><li>  para java 8 </li><li>  para java 9 </li><li>  com liga√ß√£o nativa </li><li>  etc. </li></ul><br><p>  O uso incorreto do <em>classificador de</em> depend√™ncias leva a conflitos relacionados ao compartilhamento do mesmo mecanismo.  Normalmente, <em>fontes</em> ou <em>javadocs</em> s√£o instalados como classificadores, mas na realidade eles n√£o t√™m depend√™ncias. </p><br><ul><li>  N√£o queremos gerar inconsist√™ncias; o processo de constru√ß√£o n√£o deve depender de como voc√™ obt√©m as classes.  Em outras palavras, o uso de jars com v√°rias libera√ß√µes tem um efeito colateral: chamar do arquivo JAR e chamar do diret√≥rio de classes agora s√£o coisas completamente diferentes.  Eles t√™m uma enorme diferen√ßa na sem√¢ntica! </li><li>  Dependendo da ferramenta usada para criar o JAR, voc√™ pode acabar com arquivos JAR incompat√≠veis!  A √∫nica ferramenta que garante que, quando voc√™ empacotar duas op√ß√µes de classe em um archive, elas ter√£o uma √∫nica API aberta - o pr√≥prio utilit√°rio <em>jar</em> .  O que, sem raz√£o, n√£o envolve necessariamente ferramentas de montagem ou mesmo usu√°rios.  JAR √© essencialmente um "envelope" semelhante a um arquivo ZIP.  Portanto, dependendo de como voc√™ o coleta, voc√™ ter√° comportamentos diferentes ou talvez colete um artefato incorreto (e voc√™ n√£o notar√°). </li></ul><br><h2 id="bolee-effektivnye-sposoby-upravleniya-otdelnymi-jar-arhivami">  Maneiras mais eficientes de gerenciar arquivos JAR individuais </h2><br><p>  A principal raz√£o pela qual os desenvolvedores n√£o usam arquivos separados √© o inconveniente de coletar e usar.  A culpa √© das ferramentas de constru√ß√£o, que antes de Gradle n√£o lidavam com isso.  Em particular, aqueles que usaram esse m√©todo no Maven s√≥ podiam confiar na fun√ß√£o <em>classificadora</em> fraca para publicar artefatos adicionais.  No entanto, o <em>classificador</em> n√£o ajuda nessa situa√ß√£o dif√≠cil.  Eles s√£o usados ‚Äã‚Äãpara v√°rios prop√≥sitos, desde a publica√ß√£o de c√≥digos-fonte, documenta√ß√£o, javadocs, at√© a implementa√ß√£o de op√ß√µes de biblioteca (guava-jdk5, guava-jdk7, ...) ou v√°rios casos de uso (api, fat jar, ...).  Na pr√°tica, n√£o h√° como mostrar que a √°rvore de depend√™ncia do <em>classificador</em> √© diferente da √°rvore de depend√™ncia do projeto principal.  Em outras palavras, o formato POM √© fundamentalmente quebrado porque  Representa como o componente √© montado e os artefatos que ele fornece.  Suponha que voc√™ precise implementar 2 arquivos jar diferentes: jar cl√°ssico e gordo, que inclui todas as depend√™ncias.  Maven decide que dois artefatos t√™m √°rvores de depend√™ncia id√™nticas, mesmo que isso esteja obviamente errado!  Nesse caso, isso √© mais do que √≥bvio, mas a situa√ß√£o √© a mesma que nos JARs de v√°rios lan√ßamentos! </p><br><p>  A solu√ß√£o √© lidar com as op√ß√µes corretamente.  Gradle pode fazer isso gerenciando depend√™ncias com base em op√ß√µes.  Atualmente, este recurso est√° dispon√≠vel para desenvolvimento no Android, mas tamb√©m estamos trabalhando em sua vers√£o para Java e aplicativos nativos! </p><br><p>  O gerenciamento de depend√™ncias baseado em variantes √© baseado no fato de que m√≥dulos e artefatos s√£o coisas completamente diferentes.  O mesmo c√≥digo pode funcionar perfeitamente em diferentes tempos de execu√ß√£o, levando em conta requisitos diferentes.  Para aqueles que trabalham com compila√ß√£o nativa, isso √© √≥bvio h√° muito tempo: compilamos para <em>i386</em> e <em>amd64</em> e de forma alguma podemos interferir nas depend√™ncias da biblioteca <em>i386</em> com <em>arm64</em> !  No contexto do Java, isso significa que, para o Java 8, √© necess√°rio criar uma vers√£o do arquivo JAR ‚Äújava 8‚Äù, em que o formato da classe corresponder√° ao Java 8. Esse artefato conter√° metadados com informa√ß√µes sobre quais depend√™ncias usar.  Para Java 8 ou 9, as depend√™ncias correspondentes √† vers√£o ser√£o selecionadas.  √â simples assim (na verdade, o motivo n√£o √© que o tempo de execu√ß√£o seja apenas um campo de op√ß√µes, voc√™ pode combinar v√°rios). </p><br><p>  Obviamente, ningu√©m havia feito isso antes devido √† complexidade excessiva: Maven, aparentemente, nunca permitiria que uma opera√ß√£o t√£o complicada fosse realizada.  Mas com Gradle √© poss√≠vel.  A equipe Gradle est√° atualmente trabalhando em um novo formato de metadados que informa aos usu√°rios qual op√ß√£o usar.  Simplificando, uma ferramenta de constru√ß√£o deve lidar com a compila√ß√£o, teste, empacotamento e processamento de tais m√≥dulos.  Por exemplo, o projeto deve funcionar nos tempos de execu√ß√£o Java 8 e Java 9. Idealmente, voc√™ precisa implementar 2 vers√µes da biblioteca.  Isso significa que existem 2 compiladores diferentes (para evitar o uso da API Java 9 ao trabalhar no Java 8), 2 diret√≥rios de classe e, finalmente, 2 arquivos JAR diferentes.  E tamb√©m, muito provavelmente, ser√° necess√°rio testar 2 tempos de execu√ß√£o.  Ou voc√™ implementa 2 arquivos, mas decide testar o comportamento da vers√£o Java 8 no tempo de execu√ß√£o Java 9 (porque isso pode acontecer na inicializa√ß√£o!). </p><br><p>  Esse esquema ainda n√£o foi implementado, mas a equipe Gradle <a href="">fez progressos significativos</a> nessa dire√ß√£o. </p><br><h2 id="kak-sozdat-multi-release-jar-s-pomoschyu-gradle">  Como criar JAR com v√°rias libera√ß√µes usando Gradle </h2><br><p>  Mas se essa fun√ß√£o ainda n√£o estiver pronta, o que devo fazer?  Relaxe, os artefatos corretos s√£o criados da mesma maneira.  Antes que a fun√ß√£o acima apare√ßa no ecossistema Java, existem duas op√ß√µes: </p><br><ul><li>  boa maneira antiga usando reflex√£o ou diferentes arquivos JAR; </li><li>  use JARs com v√°rias libera√ß√µes (observe que essa pode ser uma solu√ß√£o ruim, mesmo se houver bons casos de uso). </li></ul><br><p>  Qualquer que seja sua escolha, arquivos diferentes ou JARs com v√°rios lan√ßamentos, o esquema ser√° o mesmo.  JARs multi-release s√£o essencialmente a embalagem errada: devem ser uma op√ß√£o, mas n√£o a meta.  Tecnicamente, o layout de origem √© o mesmo para JARs individuais e externos.  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio</a> descreve como criar um JAR de v√°rias libera√ß√µes usando Gradle.  A ess√™ncia do processo √© descrita brevemente abaixo. </p><br><p>  Antes de tudo, lembre-se sempre de um mau h√°bito dos desenvolvedores: eles executam Gradle (ou Maven) usando a mesma vers√£o do Java na qual os artefatos est√£o planejados para serem lan√ßados.  Al√©m disso, algumas vezes uma vers√£o posterior √© usada para iniciar o Gradle e a compila√ß√£o ocorre com um n√≠vel anterior da API.  Mas n√£o h√° raz√£o espec√≠fica para faz√™-lo.  Em Gradle, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compila√ß√£o de Ross</a> √© poss√≠vel.  Ele permite que voc√™ descreva a posi√ß√£o do JDK, al√©m de executar a compila√ß√£o como um processo separado, para compilar o componente usando esse JDK.  A melhor maneira de configurar v√°rios JDKs √© configurar o caminho para o JDK por meio de vari√°veis ‚Äã‚Äãde ambiente, como √© feito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste arquivo</a> .  Ent√£o voc√™ s√≥ precisa configurar o Gradle para usar o JDK correto, com base na compatibilidade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">com a plataforma de origem / destino</a> .  Vale ressaltar que, come√ßando com o JDK 9, as vers√µes anteriores do JDK n√£o s√£o necess√°rias para a compila√ß√£o cruzada.  Isso cria um novo recurso, -release.  Gradle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usa essa fun√ß√£o e ir√° configurar o compilador</a> conforme necess√°rio. </p><br><p>  Outro ponto importante √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conjunto da fonte de</a> designa√ß√£o.  Conjunto de fontes √© um conjunto de arquivos de origem que precisam ser compilados juntos.  Um JAR √© obtido atrav√©s da compila√ß√£o de um ou mais conjuntos de fontes.  Para cada conjunto, o Gradle cria automaticamente uma tarefa de compila√ß√£o personalizada apropriada.  Isso significa que, se houver fontes para Java 8 e Java 9, essas fontes estar√£o em conjuntos diferentes.  √â exatamente assim que funciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no conjunto de fontes do Java 9</a> , no qual haver√° uma vers√£o da nossa classe.  Isso realmente funciona e voc√™ n√£o precisa criar um projeto separado, como no Maven.  Mas o mais importante √© que esse m√©todo permite ajustar a compila√ß√£o do conjunto. </p><br><p>  Uma das dificuldades de ter vers√µes diferentes de uma classe √© que o c√≥digo da classe raramente √© independente do restante do c√≥digo (possui depend√™ncias com classes que n√£o est√£o no conjunto principal).  Por exemplo, sua API pode usar classes que n√£o precisam de fontes especiais para dar suporte ao Java 9. Ao mesmo tempo, eu n√£o gostaria de recompilar todas essas classes comuns e compactar suas vers√µes para o Java 9. Elas s√£o classes comuns e, portanto, devem existir separadamente de classes para um JDK espec√≠fico.  N√≥s o configuramos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> : adicione uma depend√™ncia entre o conjunto de origem do Java 9 e o conjunto principal, para que, ao compilar a vers√£o do Java 9, todas as classes comuns permane√ßam no caminho de classe da compila√ß√£o. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A pr√≥xima etapa √© simples</a> : voc√™ precisa explicar a Gradle que o conjunto principal de fontes ser√° compilado com o n√≠vel da API do Java 8 e o conjunto para o Java 9 com o n√≠vel do Java 9. </p><br><p>  Todas as op√ß√µes acima ajudar√£o voc√™ a usar as duas abordagens mencionadas anteriormente: implementar arquivos JAR separados ou JARs com v√°rias libera√ß√µes.  Como a postagem √© sobre esse t√≥pico, vejamos um exemplo de como fazer com que Gradle construa um JAR de v√°rios lan√ßamentos: </p><br><pre><code class="java hljs">jar { into(<span class="hljs-string"><span class="hljs-string">'META-INF/versions/9'</span></span>) { from sourceSets.java9.output } manifest.attributes( <span class="hljs-string"><span class="hljs-string">'Multi-Release'</span></span>: <span class="hljs-string"><span class="hljs-string">'true'</span></span> ) }</code> </pre> <br><p>  Este bloco descreve: empacotando classes para Java 9 no <em>diret√≥rio META-INF / version / 9</em> , que √© usado para MR JARs, e configurando o r√≥tulo de libera√ß√£o m√∫ltipla no manifesto. </p><br><p>  E √© isso, seu primeiro MR JAR est√° pronto! </p><br><p>  Mas, infelizmente, o trabalho sobre isso ainda n√£o acabou.  Se voc√™ trabalhou com Gradle, sabe que, ao usar o plug-in de aplicativo, √© poss√≠vel executar o aplicativo diretamente atrav√©s da tarefa de <em>execu√ß√£o</em> .  No entanto, devido ao fato de Gradle geralmente tentar minimizar a quantidade de trabalho, a tarefa de <em>execu√ß√£o</em> deve usar os diret√≥rios de classe e os diret√≥rios de recursos processados.  Para JARs com v√°rias libera√ß√µes, isso √© um problema porque os JARs s√£o necess√°rios imediatamente!  Portanto, em vez de usar o plug-in, voc√™ ter√° que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criar sua pr√≥pria tarefa</a> , e este √© um argumento contra o uso de JARs com v√°rias libera√ß√µes. </p><br><p>  E por √∫ltimo, mas n√£o menos importante, mencionamos que precisar√≠amos testar duas vers√µes da classe.  Para isso, voc√™ pode usar apenas a VM em um processo separado, porque n√£o h√° equivalente do marcador de <em>libera√ß√£o</em> para o tempo de execu√ß√£o Java.  A id√©ia √© que apenas um teste precise ser gravado, mas ser√° executado duas vezes: no Java 8 e Java 9. Essa √© a √∫nica maneira de garantir que as classes espec√≠ficas do tempo de execu√ß√£o funcionem corretamente.  Por padr√£o, Gradle cria uma tarefa de teste e usa os diret√≥rios de classe da mesma maneira, em vez do JAR.  Portanto, faremos duas coisas: criar uma tarefa de teste para Java 9 e configurar as duas tarefas para que usem o JAR e os tempos de execu√ß√£o Java especificados.  A implementa√ß√£o ter√° a seguinte apar√™ncia: </p><br><pre> <code class="java hljs">test { dependsOn jar def jdkHome = System.getenv(<span class="hljs-string"><span class="hljs-string">"JAVA_8"</span></span>) classpath = files(jar.archivePath, classpath) - sourceSets.main.output executable = file(<span class="hljs-string"><span class="hljs-string">"$jdkHome/bin/java"</span></span>) doFirst { println <span class="hljs-string"><span class="hljs-string">"$name runs test using JDK 8"</span></span> } } <span class="hljs-function"><span class="hljs-function">task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testJava9</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type: Test)</span></span></span><span class="hljs-function"> </span></span>{ dependsOn jar def jdkHome = System.getenv(<span class="hljs-string"><span class="hljs-string">"JAVA_9"</span></span>) classpath = files(jar.archivePath, classpath) - sourceSets.main.output executable = file(<span class="hljs-string"><span class="hljs-string">"$jdkHome/bin/java"</span></span>) doFirst { println classpath.asPath println <span class="hljs-string"><span class="hljs-string">"$name runs test using JDK 9"</span></span> } } check.dependsOn(testJava9)</code> </pre> <br><p>  Agora, quando a tarefa for iniciada, <em>verifique se</em> Gradle ir√° compilar cada conjunto de fontes usando o JDK desejado, criar um JAR com v√°rias libera√ß√µes e executar os testes usando esse JAR nos dois JDKs.  Vers√µes futuras do Gradle ajudar√£o voc√™ a fazer isso de forma mais declarativa. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  Para resumir.  Voc√™ aprendeu que os JARs com v√°rias vers√µes s√£o uma tentativa de resolver o problema real que muitos desenvolvedores de bibliotecas enfrentam.  No entanto, esta solu√ß√£o para o problema parece estar incorreta.  Gerenciamento correto de depend√™ncias, vinculando artefatos e op√ß√µes, cuidando do desempenho (a capacidade de executar o maior n√∫mero poss√≠vel de tarefas em paralelo) - tudo isso faz do MR JAR uma solu√ß√£o para os pobres.  Esse problema pode ser resolvido corretamente usando as op√ß√µes.  E, no entanto, enquanto o gerenciamento de depend√™ncias com op√ß√µes da Gradle est√° em desenvolvimento, os JARs com v√°rios lan√ßamentos s√£o bastante convenientes em casos simples.  Nesse caso, esta postagem ajudar√° voc√™ a entender como fazer isso e como a filosofia de Gradle difere do Maven (conjunto de fontes versus projeto). </p><br><p>  Por fim, n√£o negamos que h√° casos em que os JARs com v√°rios releases fazem sentido: por exemplo, quando n√£o se sabe em qual ambiente o aplicativo ser√° executado (n√£o uma biblioteca), mas isso √© uma exce√ß√£o.  Neste post, descrevemos os principais problemas enfrentados pelos desenvolvedores de bibliotecas e como os JARs com v√°rios releases tentam resolv√™-los.  A modelagem correta de depend√™ncias como op√ß√µes melhora o desempenho (por meio de paralelismo refinado) e reduz os custos de manuten√ß√£o (evitando a complexidade imprevista) em compara√ß√£o com os JARs de libera√ß√£o m√∫ltipla.  Na sua situa√ß√£o, MR JARs tamb√©m podem ser necess√°rios, ent√£o Gradle j√° cuidou disso.  D√™ uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste projeto de amostra</a> e tente voc√™ mesmo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428868/">https://habr.com/ru/post/pt428868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428856/index.html">Um truque maravilhoso para tornar um mantenedor de projeto de c√≥digo aberto por dia</a></li>
<li><a href="../pt428858/index.html">Confer√™ncia DEFCON 17. Ria dos seus v√≠rus! Parte 1</a></li>
<li><a href="../pt428860/index.html">Confer√™ncia DEFCON 17. Ria dos seus v√≠rus! Parte 2</a></li>
<li><a href="../pt428864/index.html">Vamos tornar a web √≥tima novamente</a></li>
<li><a href="../pt428866/index.html">7 princ√≠pios de design, atitude em rela√ß√£o √†s tend√™ncias de design, portf√≥lio de designers UX, ...</a></li>
<li><a href="../pt428870/index.html">Mrr: FRP total para reagir</a></li>
<li><a href="../pt428872/index.html">A hist√≥ria de um olho e 20 opera√ß√µes (n√£o lidas para impress√£o) ou ele queria ser um piloto, mas ele n√£o era permitido no c√©u</a></li>
<li><a href="../pt428876/index.html">N√£o h√° como voltar atr√°s: a experi√™ncia pessoal do testador</a></li>
<li><a href="../pt428878/index.html">Voo de porco ou otimiza√ß√£o de int√©rpretes de bytecode</a></li>
<li><a href="../pt428880/index.html">Novos m√©todos de autentica√ß√£o - uma amea√ßa √† privacidade?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>