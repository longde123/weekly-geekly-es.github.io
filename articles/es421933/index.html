<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôâ ü§üüèª üê¨ El estudio del sistema de archivos HDD del modelo DVR QCM-08DL üë¶üèæ üë©üèø‚Äçüíª üè¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo est√° dedicado a estudiar la estructura de archivos del disco duro de una grabadora de video de ocho canales con el prop√≥sito de extraer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El estudio del sistema de archivos HDD del modelo DVR QCM-08DL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421933/"><img src="https://habrastorage.org/webt/jl/fy/ud/jlfyudollyahkfmnnmsy0fa-8xu.jpeg"><br><br>  Este art√≠culo est√° dedicado a estudiar la estructura de archivos del disco duro de una grabadora de video de ocho canales con el prop√≥sito de extraer en masa los archivos de video.  Al final del art√≠culo se encuentra la implementaci√≥n del programa correspondiente en C. <br><a name="habracut"></a><br>  La grabadora de video (DVR abreviado) QCM-08DL se utiliza en sistemas de video vigilancia y permite la grabaci√≥n de video y audio de ocho canales.  Este modelo, en mi opini√≥n, es uno de los m√°s baratos y al mismo tiempo confiable en operaci√≥n.  El formato de compresi√≥n de video es el popular formato H264.  Para audio, el formato de compresi√≥n es ADPCM.  El video y el audio se graban en un disco duro SATA (HDD) est√°ndar instalado dentro del DVR.  Usando el DVR en s√≠, es posible ver grabaciones busc√°ndolas por fecha y hora.  Adem√°s, es posible extraer datos a un archivo en un medio externo.  En primer lugar, a una unidad USB que se conecta a la interfaz USB del DVR.  En segundo lugar, a la computadora a trav√©s de la interfaz WEB del DVR.  El nombre del archivo resultante es largo e incluye la fecha de grabaci√≥n, la hora de inicio y finalizaci√≥n, el canal de grabaci√≥n y otra informaci√≥n adicional.  La extensi√≥n del archivo es ".264".  Un examen del contenido de dicho archivo me dej√≥ claro que el contenedor de medios en el que se empaquetan las transmisiones de audio y video est√° lejos de ser est√°ndar.  Dicho archivo se puede abrir con el reproductor que viene con el DVR.  El jugador est√° muy inc√≥modo.  Pero tambi√©n, puede usar el programa repacker en el contenedor AVI, que tambi√©n est√° incluido.  Este programa vuelve a empaquetar el flujo de video, dej√°ndolo en el formato H264.  Y el flujo de sonido se convierte de ADMCM a PCM, aumentando su tama√±o 4 veces.  El resultado es un archivo .avi que puede reproducir cualquier reproductor est√°ndar.  Noto de inmediato que este programa de reempaquetado es muy inconveniente.  Le permite realizar operaciones en un solo archivo.  Para volver a empaquetar un conjunto de archivos, debe abrirlos a su vez. <br><br>  Se establecieron las siguientes tareas. <br><br><ol><li>  Obtenga acceso a todos los archivos .264 del disco duro del DVR conectando el disco duro a la computadora. </li><li>  Para estudiar el algoritmo por el cual funciona el programa de repacker 264-avi est√°ndar y crear el mismo programa que realizar√≠a las mismas operaciones, pero no en uno, sino en un grupo completo de archivos, con un solo clic. </li></ol><br>  La primera tarea, a primera vista, puede parecer muy simple: solo necesita conectar el HDD a la computadora y abrir las particiones en Explorer.  Sin embargo, hay dificultades.  Este art√≠culo est√° dedicado a la primera tarea. <br><br>  Ya sab√≠a de antemano que la carcasa del software del microcontrolador DVR se basa en un sistema operativo similar a Linux.  Por lo tanto, la partici√≥n del disco duro probablemente tambi√©n sea similar a Linux.  Por lo tanto, necesita una computadora Linux.  En mi caso, la capacidad del HDD es de 1TB, una computadora con OS Xubuntu.  Despu√©s de conectar el HDD a la computadora, pude ver solo una partici√≥n por varios gigabytes.  Claramente, esto no es lo que necesitas.  Dentro de la secci√≥n hay muchas carpetas con el formato de nombre "AAAA-MM-DD" correspondientes a las fechas de los registros.  Dentro de cada carpeta hay muchos archivos correspondientes a las entradas.  Archivos del mismo nombre que los obtenidos al extraer del DVR.  Sin embargo, su tama√±o es muchas veces menor y la extensi√≥n no es .264, sino .nvr.  Se debe suponer que estos mismos archivos nvr son claves para los 264 archivos correspondientes (o sus secuencias de medios), cuyo contenido se encuentra en el espacio principal del HDD.  Copi√© los datos de la carpeta de archivos a un medio separado para una mayor investigaci√≥n. <br><br>  Utilic√© muchas herramientas de software para la investigaci√≥n: un editor de disco (tambi√©n es un editor de archivos binarios) DiskExplorer (utilic√© WinHex m√°s tarde), MS Excel para c√°lculos auxiliares y resultados de fijaci√≥n, entorno de programaci√≥n Dev-C ++ para escribir programas de consola auxiliar y final, etc.  En este art√≠culo intentar√© hablar sobre este procedimiento. <br><br>  Primero, mire el primer sector del HDD (un sector (1 LBA) toma 512 Bytes).  Este sector, como regla, contiene una estructura MBR.  Incluye un gestor de arranque y una tabla b√°sica de secciones de contenido.  La estructura de este sector, as√≠ como la estructura de la descripci√≥n de la secci√≥n, se proporciona a continuaci√≥n (tomado de Wikipedia). <br><br><img src="https://habrastorage.org/webt/yb/x9/iq/ybx9iqnwe7dx7ghojh7xnyfghbm.jpeg"><br><br><img src="https://habrastorage.org/webt/mz/w4/v1/mzw4v1rt6vrfmmrmbbrn2m-ggu0.jpeg"><br><br>  En el caso del HDD investigado, tenemos lo siguiente.  Mirando la figura a continuaci√≥n y siguiendo las tablas anteriores, vemos que falta el gestor de arranque.  Pero estamos m√°s interesados ‚Äã‚Äãen la tabla de particiones.  Se resalta en un marco rojo.  Los dos √∫ltimos bytes (relleno azul): firma MBR.  Puede ver en la tabla de particiones que el disco est√° dividido en dos secciones.  El c√≥digo para el tipo de la primera secci√≥n (relleno amarillo) es 0x0B.  Esta es una partici√≥n FAT32.  El c√≥digo para el tipo del segundo (relleno naranja) es 0x83.  Esta es una de las particiones de Linux (en el sentido de EXT).  Los bytes del c√≥digo del tipo de partici√≥n est√°n encerrados en un c√≠rculo azul. <br><br><img src="https://habrastorage.org/webt/ua/2h/l6/ua2hl6viqijfm3qwziadcpf3myi.jpeg"><br><br>  A continuaci√≥n se ofrece un descifrado completo del sector MBR con una tabla de secciones y sus par√°metros. <br><br><img src="https://habrastorage.org/webt/h2/mc/8j/h2mc8jovgedyxw1lcswaodx-xoa.jpeg"><br><br>  Prestando atenci√≥n al tama√±o de las particiones (contando el n√∫mero de sectores en gigabytes), es f√°cil adivinar que en la computadora con el sistema operativo Xubuntu fue la primera partici√≥n que ocup√≥ una peque√±a parte del espacio en disco.  Por cierto, en Windows XP solo se mostr√≥ la primera partici√≥n, pero no se abri√≥ desde el explorador.  ¬øY por qu√©, entonces, la segunda partici√≥n de Linux no apareci√≥ en el sistema operativo Xubuntu? <br><br>  Habiendo estudiado previamente la estructura y organizaci√≥n del sistema de archivos Linux usando EXT2 como ejemplo, comenc√© a estudiar la segunda secci√≥n. <br><br>  Como puede ver en la tabla de secciones, la segunda secci√≥n comienza con el sector 16016805. El manual del sistema de archivos EXT2 indica la presencia del llamado superbloque, que se encuentra a 1024 bytes desde el principio de la secci√≥n (es decir, dos sectores desde el principio).  Sin embargo, el sector 16016805 + 2 = 16016807 estaba vac√≠o.  Pero el primer sector 16016805 en su estructura se parec√≠a a un superbloque.  Pero su contenido no se correspond√≠a completamente con la descripci√≥n del contenido del superbloque del manual.  El superbloque es el bloque principal, que contiene una especie de tabla de varias constantes y par√°metros para el funcionamiento del sistema de archivos: direcciones de posiciones y tama√±os de otros bloques necesarios, en particular, encabezados de registros de archivos y directorios.  La investigaci√≥n adicional en esta secci√≥n me llev√≥ a una sola conclusi√≥n: el DVR usa su propio sistema de archivos √∫nico. <br><br>  En el futuro, decid√≠ mirar el primer sector de la primera secci√≥n (sector 63) y desplazarme hacia abajo.  Se encontr√≥ en el contenido del sector 65 (dos sectores a continuaci√≥n) que es completamente similar al contenido del superbloque FS EXT2, que se describe en el manual.  Investigaciones posteriores llevaron a la conclusi√≥n de que la primera partici√≥n del HDD DVR es la partici√≥n EXT2, que se mostr√≥ en el sistema operativo Xubuntu, independientemente de la marca 0x08 (no EXT) en la tabla de contenido.  Por lo tanto, la primera partici√≥n del disco duro del DVR es la partici√≥n EXT2, en la que se graban los archivos nvr, que son las claves para las grabaciones de video requeridas. <br><br>  Escribir√© brevemente sobre la estructura de los archivos .264, que tambi√©n examin√© anteriormente.  Esta informaci√≥n ser√° necesaria en el futuro para estudiar la segunda secci√≥n del HDD.  Como en cualquier contenedor de medios, en "264" hay un encabezado con informaci√≥n de servicio y etiquetas de medios, as√≠ como secuencias de audio y video que siguen en peque√±os bloques uno tras otro.  Con un desplazamiento de 0x84 bytes desde el comienzo del archivo, se registra la palabra clave "MDVR96NT_2_R".  Antes de esta palabra hay bytes relacionados con la fecha y hora de grabaci√≥n.  Pero esta informaci√≥n est√° contenida en el nombre del archivo, por lo tanto, no merece especial atenci√≥n aqu√≠.  Despu√©s de eso viene una gran cantidad de bytes de ceros.  La informaci√≥n principal con transmisiones de audio y video se origina en un desplazamiento de 65.536 bytes.  Los bloques de transmisi√≥n de video comienzan con un encabezado de 8 bytes "01dcH264" (tambi√©n encontrado "00dcH264").  Los siguientes 4 bytes describen el tama√±o del bloque actual de la transmisi√≥n de video en bytes.  Despu√©s de 4 bytes de ceros (00 00 00 00), comienza el bloque de transmisi√≥n de video.  Los bloques de transmisi√≥n de audio tienen el t√≠tulo "03wb" (aunque, seg√∫n mis observaciones, el primer car√°cter del encabezado en algunos casos no era necesariamente "0").  Despu√©s: 12 bytes de informaci√≥n que a√∫n no he descubierto.  Y comenzando con el byte 17, una secuencia de audio de una longitud fija de 160 bytes.  No hay etiquetas al final del archivo. <br><br>  Procedemos a estudiar la estructura de los archivos y directorios ubicados en la primera partici√≥n del HDD.  Como se mencion√≥ anteriormente, el contenido de la secci√≥n se copi√≥ a un medio separado a trav√©s de un explorador regular en el sistema operativo Xununtu.  En cada directorio (directorio), adem√°s de los archivos nvr, hay un archivo binario llamado "file_list".  A juzgar por el nombre, contiene informaci√≥n sobre la lista de archivos en el directorio actual.  Abra este archivo en el editor binario (vea la figura a continuaci√≥n).  Investigu√© la estructura de este archivo, y b√°sicamente no hay nada interesante aqu√≠.  El archivo no tiene ninguna informaci√≥n sobre la ubicaci√≥n de las transmisiones multimedia deseadas.  Sin embargo, escribir√© brevemente sobre esta estructura.  Los primeros 32 bytes son un encabezado con algunas constantes.  Los siguientes 16 bytes est√°n relacionados con la fecha y hora y el n√∫mero de archivos en el directorio actual.  Esto es seguido por 48 bytes de constantes.  Siguiente: 8 bytes de constantes, que indican el comienzo del registro del archivo.  A continuaci√≥n, 96 bytes que indican la ruta completa al archivo nvr, incluido su nombre.  Siguiente: 24 bytes relacionados con el tiempo (el n√∫mero de segundos transcurridos desde el comienzo del d√≠a, el comienzo y el final del video) y otros atributos del video.  Y as√≠ sucesivamente, por analog√≠a, para todos los archivos nvr en el directorio actual.  Su n√∫mero es igual al n√∫mero de videos para el d√≠a actual, indicado por el nombre del directorio actual.  ¬øPara qu√© es este archivo?  Aparentemente, para acelerar la b√∫squeda de video dentro de la interfaz DVR. <br><br><img src="https://habrastorage.org/webt/ey/tq/dh/eytqdh-oadafzwauaoh2fbogo9o.jpeg"><br><br>  Pasemos a estudiar la estructura de los propios archivos nvr.  La apariencia de uno de esos archivos en un editor binario (m√°s precisamente, en un hexadecimal) se muestra en la figura a continuaci√≥n.  Sin entrar en detalles de la descripci√≥n de la estructura de contenido (parte de la cual segu√≠a siendo un misterio para m√≠), destaqu√© los par√°metros m√°s b√°sicos, que son la clave que se encuentra.  Estos son valores de 32 bits (4 bytes), ubicados cada 32 bytes, comenzando desde el byte en el desplazamiento 40. En la figura est√°n resaltados en rojo.  En el futuro, me convenc√≠ de que esto es suficiente para la clave de los videos.  Les recuerdo que 4 bytes del valor de este par√°metro clave se encuentran de menor a mayor, ¬°pero no al rev√©s!  Esta notaci√≥n se debe a la arquitectura del procesador de la PC.  El ejemplo en la figura muestra el primer archivo nvr del primer directorio.  Corresponde a la primera grabaci√≥n de video realizada por el DVR.  Obviamente, los valores de los par√°metros, que llam√© clave, en el ejemplo anterior forman una secuencia de enteros, comenzando desde cero y yendo en orden ascendente.  Al examinar otros archivos nvr y observar exactamente estos bytes especificados en ellos, tambi√©n se vieron enteros, ascendentes.  Pero esta secuencia, naturalmente, ya no comenz√≥ desde cero, y en algunos casos se observaron lagunas en uno o dos n√∫meros en algunos lugares.  Por ejemplo (n√∫meros de la excavadora): 435, 436, 438, 439, 442, ... (o en hexadecimal: B3010000, B4010000, B6010000, B7010000, BA010000, ...). <br><br><img src="https://habrastorage.org/webt/nl/50/eo/nl50eo8cjnx0mnexkbcf-sqld20.jpeg"><br><br>  Tal secuencia con omisiones ocurri√≥ en los archivos nvr correspondientes a los videos que el DVR grab√≥ simult√°neamente desde dos o m√°s canales.  Es decir, por ejemplo, si la secuencia "435, 436, 438, 439, 442, ..." se refiere al video de un canal, entonces los valores faltantes (437, 440, 441) se relacionar√°n con el video de otro canal, que se realiz√≥ en el mismo punto en el tiempo  Yo mismo estaba convencido de esto al ver y comparar los archivos nvr correspondientes, en funci√≥n de su nombre.  No hay duda de que los n√∫meros anteriores forman los n√∫meros de algunas partes relacionadas con los videos.  Solo queda desentra√±ar la relaci√≥n entre estos n√∫meros y las coordenadas del espacio en disco en el que se encuentran los datos. <br><br>  Adem√°s, fue para averiguar exactamente qu√© datos se dividen en los segmentos numerados anteriormente.  La primera suposici√≥n: los datos son flujos de audio y video, que en el contenedor 264 est√°n representados por bloques cortos y, como se ha dicho, los bloques del flujo de video tienen diferentes tama√±os.  Al mismo tiempo, el DVR recoge estas transmisiones y las empaqueta en un contenedor 264 en la etapa de extracci√≥n de grabaciones de video a medios externos.El segundo supuesto es que la DVR empaqueta transmisiones de audio y video en un contenedor 264 al principio y durante la captura de video.  Y al mismo tiempo, los datos del archivo .264 ya generados se escriben en el HDD, lo que habr√≠a resultado como resultado de su extracci√≥n a un medio externo.  Al explorar el espacio HDD en alg√∫n lugar en el medio de la segunda secci√≥n, junto con los bytes de las transmisiones de audio y video y sus encabezados del mismo tipo que en el contenedor 264, tambi√©n encontr√© los encabezados del contenedor en s√≠: MDVR96NT_2_R.  Despu√©s de este encabezado, tambi√©n hab√≠a muchos bytes de ceros.  En general, el estudio mostr√≥ que hay una segunda opci√≥n de las dos anteriores.  Por lo tanto, para obtener el archivo .264 deseado, lo m√°s probable es que solo necesite conectar todos los segmentos cuyos n√∫meros est√°n contenidos en el archivo nvr correspondiente. <br><br>  Comencemos la b√∫squeda de la relaci√≥n entre el n√∫mero de segmento y las coordenadas en el HDD. <br><br>  El comienzo de los datos del contenedor 264 correspondiente a la primera grabaci√≥n de video (donde la numeraci√≥n de los segmentos comienza desde cero) con las herramientas de b√∫squeda que encontr√© en el sector 16046629 (29824 sectores desde el comienzo de la secci√≥n).  Podemos hacer una suposici√≥n sobre el llamado par√°metro  sesgo inicial, que participar√° en la f√≥rmula que describe la dependencia deseada. <br><br>  Tomemos dos archivos nvr correspondientes a videos de diferentes canales que el DVR captur√≥ al mismo tiempo.  Para hacer esto, eche un vistazo a los nombres de los archivos.  Por ejemplo, los videos se√±alados por los archivos "ch00000000000001-150330-160937-161035-02p101000000.nvr" y "ch00000000000004-150330-160000-163000-00p004000000.nvr" se grabaron simult√°neamente.  El primer registro es la grabaci√≥n del primer canal de 16:09:37 a 16:10:35 hora.  El segundo registro es un registro del cuarto canal de 16:00:00 a 16:30:00 hora.  Ambas entradas se realizaron el 30 de marzo de 2015. En la l√≠nea de tiempo, obviamente, el intervalo de tiempo del primer registro es un subconjunto del intervalo de tiempo del segundo registro.  Tambi√©n tengo en cuenta el hecho de que en un intervalo de tiempo m√°s corto (en la intersecci√≥n de dos intervalos) el DVR no realiz√≥ la captura de video de ninguno de los otros 6 canales.  Explore el contenido de estos archivos nvr.  Nos aseguraremos de que los n√∫meros faltantes (n√∫meros de segmento) en el segundo archivo largo est√©n necesariamente presentes en el primer archivo corto, completa y completamente.  Usando el DVR de la manera habitual, debe extraer al menos uno de los archivos .264 referenciados por los archivos nvr investigados de antemano.  Supongamos que se extrajo "ch00000000000001-150330-160937-161035-02p101000000.264".  √Åbralo en el editor binario.  Como ya se mencion√≥, al comienzo de este archivo, antes de la palabra clave "MDVR96NT_2_R" hay bytes √∫nicos que corresponden a la fecha y hora de la grabaci√≥n de video contenida en este archivo.  Cancelamos todos estos bytes, comenzando desde cero y terminando con el encabezado (cuanto m√°s corta sea la cadena de bytes exclusiva de esta grabaci√≥n de video, mejor).  Adem√°s, escriba el desplazamiento de esta cadena de bytes desde el principio del archivo.  Cabe se√±alar que al comienzo del archivo .264 extra√≠do hay 4 bytes adicionales de ceros.  Esto se hizo notable al comparar los primeros 512 bytes del archivo .264 y el sector de espacio en disco desde el cual comienza el contenido de uno de los archivos .264 (un archivo de casi cualquier sistema de archivos siempre comienza al comienzo del sector, adem√°s, un cl√∫ster).  Es decir, la informaci√≥n en el archivo .264 se desplaza por adelantado 4 bytes a la derecha.  El tama√±o (en bytes) de cualquier archivo .264 es un m√∫ltiplo de 512 solo despu√©s de restar primero el n√∫mero 4 del tama√±o.  Comencemos la b√∫squeda del sector desde el que comienza el archivo .264 investigado.  En el editor de discos, inicie la funci√≥n de b√∫squeda.  En el campo del valor deseado, ingrese una cadena √∫nica de bytes eliminada de antemano.  Para acelerar la b√∫squeda, ingrese el valor de desplazamiento en el campo "buscar por desplazamiento", restando previamente 4. Inicie la b√∫squeda.  Unas horas despu√©s, la b√∫squeda fue exitosa.  Anotamos el n√∫mero del sector en el que se encuentra el t√≠tulo √∫nico.  Que este sea el valor de s.  Observamos el contenido del archivo nvr para este video.  Cancelamos el n√∫mero del primer segmento (4 bytes en el desplazamiento 40).  Deje que este sea el valor de b.  En total, si bien conocemos el n√∫mero de sector del disco (16046629) para el n√∫mero de segmento cero (en la primera grabaci√≥n de video) y el n√∫mero del sector encontrado de los discos s para el n√∫mero de segmento b que se acaba de escribir.  Puede calcular el tama√±o de segmento estimado: (s-16046629) / (b-0).  Despu√©s de calcular, obtuve el valor 128. ¬°Por lo tanto, el tama√±o del segmento es igual a 128 sectores de disco (LBA), o 128 * 512 = 65536 bytes! <br><br>  Realic√© otro experimento interesante adicional para finalmente disipar todas las dudas.  Se describe a continuaci√≥n. <br><br>  Desde el comienzo del sector s, seleccionamos un √°rea en el disco con un tama√±o comparable al tama√±o de un archivo .264 que comienza con este sector.  Si mis suposiciones son correctas, los segmentos de otro archivo .264, que fue capturado en el HDD simult√°neamente con el primero, caer√°n en el √°rea seleccionada.  Guarde esta √°rea en un archivo (cree una imagen).  Corte la imagen resultante en archivos de 65.536 bytes (tama√±o de segmento).  Esto se puede hacer usando la funci√≥n "dividir archivo" en Total Commander.  Que sean piezas M1, M2, M3, ....  Del mismo modo, cortamos el archivo .264 estudiado (que se extrajo de una manera f√°cil de usar del DVR), pero primero eliminamos 4 bytes de ceros primero.  Que sean piezas K1, K2, K3, ....  Usando la funci√≥n "Comparar por contenido" en Total Commander, comparamos a su vez las piezas de la imagen y las piezas del archivo .264.  (M1 con K1, M2 con K2, etc.), guiado por los n√∫meros de segmento del archivo nvr correspondiente.  El resultado es el siguiente.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supongamos (n√∫meros de la excavadora), la cadena de n√∫meros en nvr es la siguiente: 435, 436, 438, 439, 442, ... En esta situaci√≥n, M1 = K1, M2 = K2, M4 = K3, M5 = K4, M8 = K5, ... Es decir, las piezas en las que se dividieron el archivo de imagen y el archivo .264 son iguales, teniendo en cuenta el avance correspondiente en el n√∫mero de piezas del archivo de imagen, seg√∫n las omisiones en la secuencia. Aqui esta! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En total, obtuvimos la dependencia estimada: S = 16046629 + 128 * d, donde d es el n√∫mero de segmento en el archivo nvr, y S es el n√∫mero de sector en el HDD, comenzando desde el comienzo del disco desde el cual comienzan los contenidos del segmento. Tama√±o del segmento - 128 sectores. La f√≥rmula anterior no tiene en cuenta la existencia de la segunda secci√≥n. La dependencia se encuentra solo para un ejemplo espec√≠fico de HDD a 1TB. Quiz√°s si coloca una capacidad diferente en el HDD DVR, las constantes tendr√°n un aspecto diferente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para verificar la validez de la f√≥rmula, calculamos la posici√≥n del primer segmento de alg√∫n otro archivo arbitrario .264, guiados por el archivo nvr correspondiente. Prestando atenci√≥n a la fecha y hora en el nombre del archivo, comp√°relos con los primeros bytes en el encabezado .264 ubicado en el sector calculado. Los bytes que codifican individualmente el n√∫mero, mes, a√±o, horas, minutos, segundos, corresponden a datos temporales en el nombre del archivo. Por lo tanto, "golpear el clavo"! Calculamos en el archivo nvr correspondiente al archivo .264 extra√≠do de antemano, el n√∫mero de segmentos cs. En general, su n√∫mero es cs = sf / 32-1, donde sf es el tama√±o del archivo nvr. Si el archivo .264 consta de segmentos cs, entonces su tama√±o debe ser igual a cs * 65536 + 4 (el n√∫mero de segmentos multiplicado por el tama√±o del segmento en bytes, m√°s 4 de los mismos bytes de ceros). ¬°Y realmente lo es!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A√∫n as√≠, intenta explorar la segunda secci√≥n. Como se se√±al√≥ anteriormente, algo similar a un superbloque se encuentra directamente en el primer sector de la secci√≥n (16016805). Y su copia exacta fue descubierta por siete sectores a continuaci√≥n (16016812). Obviamente, la informaci√≥n b√°sica distinta de cero se encuentra en el primer sector del superbloque. Su aparici√≥n en el editor de discos se muestra en la figura a continuaci√≥n.</font></font><br><br><img src="https://habrastorage.org/webt/rg/gz/wc/rggzwchl6xsvzhuvbfzslhrhyho.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logr√© descifrar una parte de los par√°metros de 4 bytes. La fecha y hora de montaje de la partici√≥n se resaltan en azul. La fecha y la hora se presentan en una notaci√≥n especial "Tiempo Unix" (el n√∫mero de segundos transcurridos desde la medianoche del 1 de enero de 1970). En el ejemplo anterior, "03 7E 74 54" (valor decimal 1416920579) corresponde a "Mar, 25 de noviembre de 2014 13:02:59 GMT". Para traducir los valores, utilic√© una calculadora en l√≠nea especial. El valor 65536 est√° encerrado en un c√≠rculo en el marco p√∫rpura. Es posible que el int√©rprete del sistema de archivos dentro del programa DVR se refiera a esta posici√≥n del superbloque cuando se lee el tama√±o del bloque (en el contexto anterior, llam√© segmentos de bloques). Los valores 1 se resaltan en el cuadro verde, uno de ellos probablemente indica la posici√≥n del comienzo de la llamada. mapa de bits (en el n√∫mero de bloques desde el comienzo de la secci√≥n). De hechode antemano, se encontr√≥ el comienzo de la informaci√≥n, algo similar a un mapa de bits en el sector 16016933 (16016805 + 128 * 1). El valor 233 se resalta en el cuadro rojo. Esta es precisamente la posici√≥n del comienzo de estas grabaciones de video .264 desde el comienzo de la secci√≥n: 16016805 + 128 * 233 = 16046629.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, la segunda secci√≥n se puede llamar una secci√≥n truncada y ligeramente modificada de EXT2. Tiene un superbloque, una copia, un mapa de bits. Pero no hay los llamados. nodos de informaci√≥n correspondientes a registros de archivos. La secci√≥n contiene datos de archivos .264 (transmisiones de audio y video), pero los nodos de informaci√≥n (digamos as√≠) para estos datos se encuentran en archivos nvr en la primera secci√≥n. Tal vez hay una redacci√≥n m√°s competente? Pero esto no es tan importante para m√≠.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escribamos un programa simple para la extracci√≥n masiva de archivos .264. Debo decir de inmediato que no tengo mucha experiencia en programaci√≥n en Windows. El programa escanea todos los archivos nvr copiados por adelantado a la secci√≥n de 1TB del nuevo HDD. Al analizarlos, el programa crea un archivo .264 con el mismo nombre en el mismo directorio, utilizando el acceso a los sectores del HDD original. Anteriormente, se cre√≥ una carpeta con el nombre "DVR" en una secci√≥n vac√≠a del nuevo HDD, en la que se colocan las carpetas por fechas, que se copian de la "forma habitual" en Linux. Fue posible incluir en este programa un algoritmo para trabajar con la primera partici√≥n de Linux para acceder a los archivos nvr para no tener que copiarlos previamente. Y podr√≠a agregar otras caracter√≠sticas convenientes. S√≠, era posible, pero en ese momento quer√≠a hacer todo lo m√°s r√°pido posible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No utilic√© la recursividad para escanear directorios, dado que el formato de los directorios es fijo y tiene dos niveles de archivo adjunto. </font><font style="vertical-align: inherit;">En consecuencia, apliqu√© dos ciclos: ejecutar a trav√©s de las carpetas hasta que finalicen, y ejecutar a trav√©s de los archivos en cada carpeta con la misma condici√≥n. </font><font style="vertical-align: inherit;">Para leer archivos, utilic√© la funci√≥n fopen. </font><font style="vertical-align: inherit;">Para trabajar con sectores de HDD, utilic√© la funcionalidad de WinAPI similar a trabajar con archivos. </font><font style="vertical-align: inherit;">Pasemos al c√≥digo del programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las bibliotecas necesitan tal.</font></font><br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;</span></span></span></span></code> </pre> <br>  Y copi√© completamente estas funciones de alg√∫n foro. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HANDLE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> device)</span></span></span><span class="hljs-function"> </span></span>{ HANDLE handle = INVALID_HANDLE_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (device &lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || device &gt;<span class="hljs-number"><span class="hljs-number">99</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INVALID_HANDLE_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _devicename[<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(_devicename, <span class="hljs-string"><span class="hljs-string">"\\\\.\\PhysicalDrive%d"</span></span>, device); <span class="hljs-comment"><span class="hljs-comment">// Creating a handle to disk drive using CreateFile () function .. handle = CreateFile(_devicename, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); return handle; } HANDLE openOutputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_WRITE, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file }</span></span></code> </pre><br>  La funci√≥n de copia contiene una f√≥rmula de dependencia lineal, que apareci√≥ en la teor√≠a anterior. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE device, HANDLE file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span></span>{ LONG HPos; LONG LPos; __int64 sector; sector = <span class="hljs-number"><span class="hljs-number">16046629</span></span>+<span class="hljs-number"><span class="hljs-number">128</span></span>*s; HPos = (sector*<span class="hljs-number"><span class="hljs-number">512</span></span>)&gt;&gt;<span class="hljs-number"><span class="hljs-number">32</span></span>; LPos = (sector*<span class="hljs-number"><span class="hljs-number">512</span></span>); SetFilePointer (device, LPos, &amp;HPos, FILE_BEGIN); DWORD dwBytesRead; DWORD dwBytesWritten; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">65536</span></span>]; ReadFile(device, buf, <span class="hljs-number"><span class="hljs-number">65536</span></span>, &amp;dwBytesRead, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); WriteFile(file, buf, dwBytesRead, &amp;dwBytesWritten, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre><br>  La funci√≥n principal tambi√©n es bastante simple. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ HANDLE hdd = openDevice(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    HDD  DVR,    ; SetFilePointer (hdd, 0, NULL, FILE_BEGIN); DWORD dwBytesRead; char name[100]; unsigned int bl; //  ; unsigned int N; // ; unsigned long int pt; //  ; WIN32_FIND_DATA fld,fld1; //   nvr   ; HANDLE hf,hf1; hf=FindFirstFile("E:\\DVR\\*",&amp;fld); FindNextFile(hf,&amp;fld);// "."; FindNextFile(hf,&amp;fld);// ".."; do{ char *str = new char; sprintf(str,"%s%s%s","E:\\DVR\\",fld.cFileName,"\\*.nvr"); printf("\n\nFOLDER: %s\n\n",str); hf1=FindFirstFile(str,&amp;fld1); do{ FILE *nvr; sprintf(name,"%s%s%s%s","E:\\DVR\\",fld.cFileName,"\\",fld1.cFileName); nvr=fopen(name,"rb"); name[strlen(name)-3]='2'; //   ,  name[strlen(name)-2]='6'; // ; name[strlen(name)-1]='4'; HANDLE out = openOutputFile(name); SetFilePointer(out, 4, NULL, FILE_BEGIN); //  "",  4      (  ); bl=0; N=fld1.nFileSizeLow/32-1; //   (); printf("\t%s\n\t%i Blocks\n\n",fld1.cFileName,N); for(bl=0;bl&lt;N;bl++){ //  ; fseek(nvr,40+32*bl,SEEK_SET); //; fread(&amp;pt,1,4,nvr); // ; copy(hdd,out,pt); //  ; } CloseHandle(out); fclose(nvr); }while(FindNextFile(hf1,&amp;fld1)); FindClose(hf1); delete str; }while(FindNextFile(hf,&amp;fld)); FindClose(hf); CloseHandle(hdd); system("PAUSE"); return 0; }</span></span></code> </pre><br>  En una computadora vieja con un procesador Pentium 4 y un controlador PCI SATA, el programa transfiri√≥ con √©xito hasta el final un HDD completo con varios miles de archivos .264 en un promedio de 7 horas.  En una computadora nueva, tres veces m√°s r√°pido.  Como ya se√±al√©, el programa no es universal, todas las constantes y variables se ajustan a mi caso espec√≠fico de HDD a 1TB.  Sin embargo, puede trabajar un poco m√°s y hacerlo universal, dibuje una interfaz gr√°fica. <br><br>  En la segunda parte del art√≠culo escribir√© c√≥mo "hacerlo usted mismo" para volver a embalar desde el contenedor "264" al contenedor est√°ndar "avi". </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421933/">https://habr.com/ru/post/es421933/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421923/index.html">Entendemos las profesiones de dise√±o.</a></li>
<li><a href="../es421925/index.html">Descripci√≥n general de la impresora 3D Raise 3D Pro 2 Plus</a></li>
<li><a href="../es421927/index.html">Descripci√≥n general del tel√©fono inteligente General Mobile GM8 Go: un empleado de presupuesto turco con Android 8.1 Oreo Go Edition</a></li>
<li><a href="../es421929/index.html">Un a√±o antes del Brexit: Gran Breta√±a resuelve el problema de la escasez de mano de obra a trav√©s de la rob√≥tica.</a></li>
<li><a href="../es421931/index.html">Impacto de la protecci√≥n Spectre, Meltdown y Foreshadow en el rendimiento de Linux 4.19</a></li>
<li><a href="../es421935/index.html">Primeras impresiones de la transici√≥n de Ubuntu 16.04 LTS a Ubuntu 18.04 LTS</a></li>
<li><a href="../es421937/index.html">Smart city inside: una mirada a Huawei</a></li>
<li><a href="../es421939/index.html">Usando SQL en Rails</a></li>
<li><a href="../es421945/index.html">Google y Mastercard concluyen un acuerdo secreto para rastrear compras en tiendas</a></li>
<li><a href="../es421947/index.html">Bienvenido a Android Devs Meetup 8 de septiembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>