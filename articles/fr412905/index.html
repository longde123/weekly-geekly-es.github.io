<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏚️ 🍜 😜 À propos de l'analyse LL: une approche de l'analyse à travers le concept de coupe de chaîne 👶🏽 👠 🤤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salutations à la communauté distinguée! 

 La répétition est la mère de l'apprentissage, et la compréhension de l'analyse syntaxique est une compétenc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>À propos de l'analyse LL: une approche de l'analyse à travers le concept de coupe de chaîne</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412905/"> Salutations à la communauté distinguée! <br><br>  La répétition est la mère de l'apprentissage, et la compréhension de l'analyse syntaxique est une compétence très utile pour tout programmeur, donc je veux soulever à nouveau ce sujet et parler cette fois de l'analyse à l'aide de la méthode de descente récursive (LL), sans formalismes (vous pouvez toujours les utiliser plus tard revenir). <br><br>  Comme l'écrit le grand D. Strogov, «comprendre, c'est simplifier».  Par conséquent, pour comprendre le concept d'analyse à l'aide de la méthode de descente récursive (aka LL-parsing), nous simplifions la tâche autant que possible et écrivons manuellement un analyseur d'un format similaire à JSON, mais plus simple (si vous le souhaitez, vous pouvez ensuite l'étendre à un analyseur JSON à part entière si veulent faire de l'exercice).  Écrivons-le, en prenant comme base l'idée de <b>couper la chaîne</b> . <br><a name="habracut"></a><br>  Dans les livres classiques et les cours de conception de compilateurs, ils commencent généralement à expliquer le sujet de l'analyse et de l'interprétation, en soulignant plusieurs phases: <br><br><ul><li>  Analyse lexicale: division du texte source en un tableau de sous-chaînes (jetons ou jetons) </li><li>  Analyse: création d'un arbre d'analyse à partir d'un tableau de jetons </li><li>  Interprétation (ou compilation): traverser l'arborescence résultante dans l'ordre souhaité (direct ou inverse) et effectuer des actions d'interprétation ou de génération de code à certaines étapes de cette traversée </li></ul><br><div class="spoiler">  <b class="spoiler_title">pas vraiment</b> <div class="spoiler_text">  parce que dans le processus d'analyse, nous obtenons déjà une séquence d'étapes, qui est une séquence de visites aux nœuds d'arbre, l'arbre lui-même sous forme explicite peut ne pas exister du tout, mais nous n'irons pas encore en profondeur.  Pour ceux qui veulent approfondir, il y a des liens à la fin. <br></div></div><br>  Maintenant, je veux utiliser une approche légèrement différente de ce même concept (analyse LL) et montrer comment vous pouvez construire un analyseur LL basé sur l'idée de couper une chaîne: les fragments sont coupés de la chaîne d'origine pendant l'analyse, elle devient plus petite, puis analysée exposé le reste de la ligne.  En conséquence, nous arrivons au même concept de descente récursive, mais d'une manière légèrement différente de celle habituellement utilisée.  Ce chemin sera peut-être plus pratique pour comprendre l'essence de l'idée.  Et sinon, c'est quand même une opportunité de regarder une descente récursive sous un angle différent. <br><br>  Commençons par une tâche plus simple: il y a une ligne avec des délimiteurs, et je veux écrire une itération sur ses valeurs.  Quelque chose comme: <br><br><pre><code class="java hljs">String names = <span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name in names) { echo(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + name); }</code> </pre> <br>  Comment cela peut-il se faire?  La méthode standard consiste à convertir la chaîne délimitée en un tableau ou une liste à l'aide de String.split (en Java) ou names.split (",") (en javascript), et parcourez déjà le tableau.  Mais imaginons que nous ne voulons pas ou ne pouvons pas utiliser la conversion en tableau (par exemple, tout à coup, si nous programmons dans le langage de programmation AVAJ ++, dans lequel il n’existe pas de structure de données «tableau»).  Vous pouvez toujours analyser la chaîne et suivre les délimiteurs, mais je n'utiliserai pas non plus cette méthode, car elle rend le code de boucle d'itération lourd et, surtout, cela va à l'encontre du concept que je veux montrer.  Par conséquent, nous nous référerons à une chaîne délimitée de la même manière que nous nous rapportons aux listes dans la programmation fonctionnelle.  Et là, ils définissent toujours les fonctions head (obtenir le premier élément de la liste) et tail (obtenir le reste de la liste).  À partir des premiers dialectes de Lisp, où ces fonctions étaient appelées de façon absolument horrible et non intuitive: voiture et cdr (voiture = contenu du registre d'adresses, cdr = contenu du registre de décrémentation. Les légendes anciennes sont profondes, oui, eheheh.). <br><br>  Notre ligne est une ligne délimitée.  Mettez en surbrillance les séparateurs en violet: <br><br><img src="https://habrastorage.org/webt/kv/ua/ws/kvuaws-dfokcoad2styfhf2hkmc.png"><br><br>  Et mettez en surbrillance les éléments de la liste en jaune: <br><br><img src="https://habrastorage.org/webt/mf/_s/_q/mf_s_q1hwfwdnnvtsgfoziiwmis.png"><br><br>  Nous supposons que notre ligne est mutable (elle peut être modifiée) et écrivons une fonction: <br><br><img src="https://habrastorage.org/webt/ca/ai/en/caaientt_wwjxvcgegbn-ntkx7y.png"><br><br>  Sa signature, par exemple, pourrait être: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span></span></code> </pre><br>  En entrée de la fonction, nous donnons une liste (sous la forme d'une chaîne avec délimiteurs) et, en fait, la valeur du délimiteur.  En sortie, la fonction renvoie le premier élément de la liste (segment de ligne au premier séparateur), le reste de la liste et le signe indiquant si le premier élément a été renvoyé.  Dans ce cas, le reste de la liste est placé dans la même variable que la liste d'origine. <br><br>  En conséquence, nous avons eu l'occasion d'écrire comme ceci: <br><br><pre> <code class="java hljs">StringBuilder names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>); StringBuilder name = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(cutNextToken(names, <span class="hljs-string"><span class="hljs-string">";"</span></span>, name)) { System.out.println(name); }</code> </pre><br>  Sorties comme prévu: <br><br>  ivanov <br>  Petrov <br>  Sidorov <br><br>  Nous l'avons fait sans conversion en ArrayList, mais nous avons gâché la variable names, et maintenant elle a une chaîne vide.  Cela ne semble pas encore très utile, comme s'ils avaient changé l'alêne pour le savon.  Mais allons plus loin.  Là, nous verrons pourquoi c'était nécessaire et où cela nous mènera. <br><br>  Analysons maintenant quelque chose de plus intéressant: une liste de paires clé-valeur.  Il s'agit également d'une tâche très courante. <br><br><pre> <code class="java hljs">StringBuilder pairs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"name=ivan;surname=ivanov;middlename=ivanovich"</span></span>); StringBuilder pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cutNextToken(pairs, <span class="hljs-string"><span class="hljs-string">";"</span></span>, pair)) { StringBuilder paramName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); StringBuilder paramValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramName); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramValue); System.out.println(<span class="hljs-string"><span class="hljs-string">"param with name \""</span></span> + paramName + <span class="hljs-string"><span class="hljs-string">"\" has value of \""</span></span> + paramValue + <span class="hljs-string"><span class="hljs-string">"\""</span></span>); }</code> </pre><br>  Conclusion: <br><br><pre> <code class="hljs pgsql">param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "name" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivan" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "surname" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanov" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "middlename" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanovich"</code> </pre> <br>  Aussi attendu.  Et la même chose peut être réalisée avec String.split, sans couper les lignes. <br>  Mais disons que nous voulions maintenant compliquer notre format et passer d'une valeur-clé plate à un format imbriqué rappelant JSON.  Maintenant, nous voulons lire quelque chose comme ceci: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}}</code> </pre><br>  Quel séparateur divise?  Si c'est une virgule, alors dans l'un des jetons, nous aurons la ligne <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span></code> </pre> <br>  Évidemment pas ce dont nous avons besoin.  Par conséquent, nous devons faire attention à la structure de la ligne que nous voulons analyser. <br><br>  Il commence par une accolade bouclée et se termine par une accolade bouclée (jumelée à elle, ce qui est important).  À l'intérieur de ces crochets se trouve une liste de paires 'clé': 'valeur', chaque paire est séparée de la paire suivante par une virgule.  La clé et la valeur sont séparées par deux points.  Une clé est une chaîne de lettres entourée d'apostrophes.  La valeur peut être une chaîne de caractères entourée d'apostrophes, ou il peut s'agir de la même structure, commençant et se terminant par des accolades bouclées.  Nous appelons une telle structure le mot «objet», comme il est d'usage de l'appeler en JSON. <br><br>  Nous venons de décrire de manière informelle la grammaire de notre format de type JSON.  En règle générale, les grammaires sont décrites à l'envers, sous une forme formelle, et la notation BNF ou ses variations sont utilisées pour les écrire.  Mais maintenant je peux m'en passer, et nous allons voir comment vous pouvez "couper" cette ligne afin qu'elle puisse être analysée selon les règles de cette grammaire. <br><br>  En fait, notre «objet» commence par une accolade bouclée qui s'ouvre et se termine par une paire qui le ferme.  Que peut faire une fonction analysant un tel format?  Très probablement, les éléments suivants: <br><br><ul><li>  vérifier que la chaîne passée commence par une accolade ouvrante </li><li>  vérifier que la chaîne passée se termine par une paire d'accolades fermantes </li><li>  si les deux conditions sont vraies, coupez les parenthèses ouvrantes et fermantes, et ce qui reste, passez à la fonction qui analyse la liste des paires 'clé': 'valeur' </li></ul><br>  Veuillez noter: les mots «fonction analysant ce format» et «fonction analysant la liste des paires clé»: «valeur» »sont apparus.  Nous avons deux fonctionnalités!  Ce sont ces fonctions mêmes que dans la description classique de l'algorithme de descente récursive sont appelées «fonctions d'analyse des symboles non terminaux», et qui disent que «pour chaque symbole non terminal, sa propre fonction d'analyse est créée».  Ce qui, en fait, l'analyse.  Nous pourrions les nommer, disons, parseJsonObject et parseJsonPairList. <br><br>  De plus, nous devons maintenant faire attention à ce que nous avons le concept de «paire de supports» en plus du concept de «séparateur».  Si pour couper une ligne vers le séparateur suivant (deux points entre une clé et une valeur, une virgule entre les paires «clé: valeur»), la fonction cutNextToken nous suffisait, maintenant que nous pouvons utiliser non seulement une chaîne, mais aussi un objet, nous avons besoin fonction "couper à la prochaine paire de supports".  Quelque chose comme ça: <br><br><img src="https://habrastorage.org/webt/dr/5-/p0/dr5-p0qmt__fcae_ucs2iskx5xe.png"><br><br>  Cette fonction coupe un fragment de la ligne de la parenthèse ouvrante à la paire qui la ferme, compte tenu des parenthèses, le cas échéant.  Bien sûr, vous ne pouvez pas vous limiter aux crochets, mais utilisez une fonction similaire pour couper diverses structures de blocs qui peuvent être imbriquées: blocs d'opérateur begin..end, if..endif, for..endfor et similaires. <br><br>  Dessinons graphiquement ce qui va arriver à la chaîne.  Couleur turquoise - cela signifie que nous numérisons la ligne vers l'avant jusqu'au symbole surligné en turquoise pour déterminer ce que nous devons faire ensuite.  Le violet est «ce qu'il faut couper, c'est quand nous coupons les fragments surlignés en violet de la ligne, et continuons à analyser ce qui en reste. <br><br><img src="https://habrastorage.org/webt/kq/pw/ze/kqpwze0fuzqcpxql01amxmvrdnq.png"><br><br>  A titre de comparaison, la sortie du programme (le texte du programme est donné en annexe) qui analyse cette ligne: <br><br>  Démonstration de l'analyse d'une structure de type JSON <br><br><pre> <code class="hljs pgsql">ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'surname'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OBJECT</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'year'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'1984'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'month'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'october'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'day'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'06'</span></span></code> </pre> <br>  À tout moment, nous savons ce que nous nous attendons à trouver dans notre ligne d'entrée.  Si nous entrons dans la fonction parseJsonObject, nous nous attendons à ce que l'objet nous soit passé là-bas, et nous pouvons le vérifier par la présence d'une parenthèse ouvrante et fermante au début et à la fin.  Si nous entrons dans la fonction parseJsonPairList, nous nous attendons à une liste de paires "clé: valeur" là-bas, et après avoir "mordu" la clé (avant le séparateur ":"), nous nous attendons à ce que la prochaine chose que nous "mordions" soit valeur.  Nous pouvons regarder le premier caractère de la valeur et tirer une conclusion sur son type (si l'apostrophe, alors la valeur est du type "chaîne", si le crochet ouvrant est la valeur est du type "objet"). <br><br>  Ainsi, en coupant des fragments de la chaîne, nous pouvons l'analyser par la méthode de l'analyse descendante (descente récursive).  Et lorsque nous pouvons analyser, nous pouvons analyser le format dont nous avons besoin.  Ou créez votre propre format qui nous convient et démontez-le.  Ou proposez un langage spécifique au domaine (DSL) pour notre domaine spécifique et concevez un interpréteur pour celui-ci.  Et pour le construire correctement, sans solutions torturées sur regexp ou self-made state-machines qui se posent pour les programmeurs qui essaient de résoudre un problème qui nécessite une analyse, mais qui ne possèdent pas tout à fait le matériel. <br><br>  Ici.  Félicitations à tous pour l'été prochain et je vous souhaite bonne chance, amour et analyseurs fonctionnels :) <br><br>  Pour plus de lecture: <br><br>  Idéologique: quelques articles longs mais intéressants à lire de Steve Yeegge: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nourriture de programmeur riche</a> <br><br>  Quelques citations à partir de là: <br><blockquote>  Soit vous apprenez les compilateurs et vous commencez à écrire vos propres DSL, soit vous obtenez une meilleure langue </blockquote><blockquote>  La première grande phase du pipeline de compilation est l'analyse </blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le problème du pinocchio</a> <br><br>  Citation de là: <br><blockquote>  Les conversions de type, le rétrécissement et l'élargissement des conversions, les fonctions ami pour contourner les protections de classe standard, le <b>remplissage des minilangues en chaînes et leur analyse manuelle</b> , il existe des dizaines de façons de contourner les systèmes de type en Java et C ++, et les programmeurs les utilisent tout le temps , car (ils ne savent pas) ils essaient en fait de créer des logiciels, pas du matériel. </blockquote>  Technique: deux articles sur l'analyse de la différence entre les approches LL et LR: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse LL et LR démystifiée</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LL et LR en contexte: pourquoi les outils d'analyse sont difficiles</a> <br><br>  Et encore plus profondément dans le sujet: comment écrire un interpréteur Lisp en C ++ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interprète lisp en 90 lignes de C ++</a> <br><br><div class="spoiler">  <b class="spoiler_title">Application.</b>  <b class="spoiler_title">Exemple de code (java) qui implémente l'analyseur décrit dans l'article:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demoll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoLL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span><span class="hljs-function"> </span></span>{ String s = svList.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.trim().isEmpty()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sepIndex = s.indexOf(separator); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sepIndex == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   ,    token.setLength(0); token.append(s); svList.setLength(0); } else { String t = s.substring(0, sepIndex); String restOfString = s.substring(sepIndex + separator.length(), s.length()); svList.setLength(0); svList.append(restOfString); token.setLength(0); token.append(t); } return true; } // "{hello world}:again" -&gt; "{hello world}", ":again" //"{'year':'1980','month':'october','day':'06'},'key1':'value1','key2':'value2'" -&gt; "{'year':'1980','month':'october','day':'06'}", ",'key1':'value1','key2':'value2'" public void cutTillMatchingParen(StringBuilder sbSrc, String openParen, String closeParen, StringBuilder matchPart){ String src = sbSrc.toString(); matchPart.setLength(0); int openParenCount = 0; String state = "not_copying"; for (int i = 0; i &lt; src.length(); i++){ String cs = String.valueOf(src.charAt(i)); // cs - current symbol if (state.equals("not_copying")){ if (cs.equals(openParen)) { state = "copying"; } } if (state.equals("copying")){ matchPart.append(cs); if (cs.equals(openParen)){ openParenCount = openParenCount + 1; } if (cs.equals(closeParen)) { openParenCount = openParenCount - 1; } if (openParenCount == 0) { break; } } } sbSrc.setLength(0); sbSrc.append(src.substring(matchPart.length(), src.length())); } public void parseJsonObject(String s) { System.out.println("ok, about to parse JSON object " + s); if (s.charAt(0) == '{' &amp;&amp; s.charAt(s.length() - 1) == '}') { String pairList = s.substring(1, s.length() - 1).trim(); parseJsonPairList(pairList); } else { System.out.println("Syntax error: not a JSON object. Must start with { and end with }"); } } public void parseJsonPairList(String pairList) { pairList = pairList.trim(); if (pairList.isEmpty()) { //System.out.println("pairList is empty"); return; } System.out.println("ok, about to parse pair list " + pairList); if (pairList.charAt(0) != '\'') { System.out.println("syntax error: key must be of type STRING, input: + pairList"); return; } StringBuilder key = new StringBuilder(); StringBuilder sbPairList = new StringBuilder(pairList); this.cutNextToken(sbPairList, ":", key); // sbPairList  ,   "name":"ivan"...,   "ivan"... System.out.println("found KEY: " + key); // checking type of value - may be String or Object StringBuilder value = new StringBuilder(); if (sbPairList.charAt(0) == '{') { cutTillMatchingParen(sbPairList, "{", "}", value); System.out.println("found VALUE of type OBJECT:" + value); parseJsonObject(value.toString()); StringBuilder emptyString = new StringBuilder(); cutNextToken(sbPairList, ",", emptyString); } else if (sbPairList.charAt(0) == '\'') { this.cutNextToken(sbPairList, ",", value); System.out.println("found VALUE of type STRING:" + value); } else { System.out.println("syntax error: VALUE must be either STRING or OBJECT"); return; } parseJsonPairList(sbPairList.toString()); } public static void main(String[] args){ DemoLL d = new DemoLL(); System.out.println("   \"=\""); StringBuilder pairs = new StringBuilder("name=ivan;surname=ivanov;middlename=ivanovich"); StringBuilder pair = new StringBuilder(); while (d.cutNextToken(pairs, ";", pair)) { StringBuilder paramName = new StringBuilder(); StringBuilder paramValue = new StringBuilder(); d.cutNextToken(pair, "=", paramName); d.cutNextToken(pair, "=", paramValue); System.out.println("param with name \"" + paramName + "\" has value of \"" + paramValue + "\""); } System.out.println("  JSON- "); String s = "{'name':'ivan','surname':'ivanov','birthdate':{'year':'1984','month':'october','day':'06'}}"; d.parseJsonObject(s); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412905/">https://habr.com/ru/post/fr412905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412895/index.html">Vesta Matveeva: la lutte contre la cybercriminalité est un choix moral</a></li>
<li><a href="../fr412897/index.html">Surveillance des produits Atlassian avec Prometheus</a></li>
<li><a href="../fr412899/index.html">Week-end lecture: 30 documents sur le son, l'histoire des marques audio et l'industrie cinématographique</a></li>
<li><a href="../fr412901/index.html">Surveillance et Kubernetes (revue et rapport vidéo)</a></li>
<li><a href="../fr412903/index.html">Comment nous avons peint Habr</a></li>
<li><a href="../fr412911/index.html">Les développeurs parlent de fonctionnalités découpées dans les jeux</a></li>
<li><a href="../fr412913/index.html">"Baikal-T1" a été mis en vente pour 3990 roubles</a></li>
<li><a href="../fr412915/index.html">Détermination de la densité de gaz à partir des résultats de la mesure de la pression et de la température avec des capteurs Arduino</a></li>
<li><a href="../fr412917/index.html">La poste russe commencera à utiliser des trieurs robotiques. Comment cela fonctionnera</a></li>
<li><a href="../fr412921/index.html">Signatures du réseau Monero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>