<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèöÔ∏è üçú üòú √Ä propos de l'analyse LL: une approche de l'analyse √† travers le concept de coupe de cha√Æne üë∂üèΩ üë† ü§§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salutations √† la communaut√© distingu√©e! 

 La r√©p√©tition est la m√®re de l'apprentissage, et la compr√©hension de l'analyse syntaxique est une comp√©tenc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Ä propos de l'analyse LL: une approche de l'analyse √† travers le concept de coupe de cha√Æne</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412905/"> Salutations √† la communaut√© distingu√©e! <br><br>  La r√©p√©tition est la m√®re de l'apprentissage, et la compr√©hension de l'analyse syntaxique est une comp√©tence tr√®s utile pour tout programmeur, donc je veux soulever √† nouveau ce sujet et parler cette fois de l'analyse √† l'aide de la m√©thode de descente r√©cursive (LL), sans formalismes (vous pouvez toujours les utiliser plus tard revenir). <br><br>  Comme l'√©crit le grand D. Strogov, ¬´comprendre, c'est simplifier¬ª.  Par cons√©quent, pour comprendre le concept d'analyse √† l'aide de la m√©thode de descente r√©cursive (aka LL-parsing), nous simplifions la t√¢che autant que possible et √©crivons manuellement un analyseur d'un format similaire √† JSON, mais plus simple (si vous le souhaitez, vous pouvez ensuite l'√©tendre √† un analyseur JSON √† part enti√®re si veulent faire de l'exercice).  √âcrivons-le, en prenant comme base l'id√©e de <b>couper la cha√Æne</b> . <br><a name="habracut"></a><br>  Dans les livres classiques et les cours de conception de compilateurs, ils commencent g√©n√©ralement √† expliquer le sujet de l'analyse et de l'interpr√©tation, en soulignant plusieurs phases: <br><br><ul><li>  Analyse lexicale: division du texte source en un tableau de sous-cha√Ænes (jetons ou jetons) </li><li>  Analyse: cr√©ation d'un arbre d'analyse √† partir d'un tableau de jetons </li><li>  Interpr√©tation (ou compilation): traverser l'arborescence r√©sultante dans l'ordre souhait√© (direct ou inverse) et effectuer des actions d'interpr√©tation ou de g√©n√©ration de code √† certaines √©tapes de cette travers√©e </li></ul><br><div class="spoiler">  <b class="spoiler_title">pas vraiment</b> <div class="spoiler_text">  parce que dans le processus d'analyse, nous obtenons d√©j√† une s√©quence d'√©tapes, qui est une s√©quence de visites aux n≈ìuds d'arbre, l'arbre lui-m√™me sous forme explicite peut ne pas exister du tout, mais nous n'irons pas encore en profondeur.  Pour ceux qui veulent approfondir, il y a des liens √† la fin. <br></div></div><br>  Maintenant, je veux utiliser une approche l√©g√®rement diff√©rente de ce m√™me concept (analyse LL) et montrer comment vous pouvez construire un analyseur LL bas√© sur l'id√©e de couper une cha√Æne: les fragments sont coup√©s de la cha√Æne d'origine pendant l'analyse, elle devient plus petite, puis analys√©e expos√© le reste de la ligne.  En cons√©quence, nous arrivons au m√™me concept de descente r√©cursive, mais d'une mani√®re l√©g√®rement diff√©rente de celle habituellement utilis√©e.  Ce chemin sera peut-√™tre plus pratique pour comprendre l'essence de l'id√©e.  Et sinon, c'est quand m√™me une opportunit√© de regarder une descente r√©cursive sous un angle diff√©rent. <br><br>  Commen√ßons par une t√¢che plus simple: il y a une ligne avec des d√©limiteurs, et je veux √©crire une it√©ration sur ses valeurs.  Quelque chose comme: <br><br><pre><code class="java hljs">String names = <span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name in names) { echo(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + name); }</code> </pre> <br>  Comment cela peut-il se faire?  La m√©thode standard consiste √† convertir la cha√Æne d√©limit√©e en un tableau ou une liste √† l'aide de String.split (en Java) ou names.split (",") (en javascript), et parcourez d√©j√† le tableau.  Mais imaginons que nous ne voulons pas ou ne pouvons pas utiliser la conversion en tableau (par exemple, tout √† coup, si nous programmons dans le langage de programmation AVAJ ++, dans lequel il n‚Äôexiste pas de structure de donn√©es ¬´tableau¬ª).  Vous pouvez toujours analyser la cha√Æne et suivre les d√©limiteurs, mais je n'utiliserai pas non plus cette m√©thode, car elle rend le code de boucle d'it√©ration lourd et, surtout, cela va √† l'encontre du concept que je veux montrer.  Par cons√©quent, nous nous r√©f√©rerons √† une cha√Æne d√©limit√©e de la m√™me mani√®re que nous nous rapportons aux listes dans la programmation fonctionnelle.  Et l√†, ils d√©finissent toujours les fonctions head (obtenir le premier √©l√©ment de la liste) et tail (obtenir le reste de la liste).  √Ä partir des premiers dialectes de Lisp, o√π ces fonctions √©taient appel√©es de fa√ßon absolument horrible et non intuitive: voiture et cdr (voiture = contenu du registre d'adresses, cdr = contenu du registre de d√©cr√©mentation. Les l√©gendes anciennes sont profondes, oui, eheheh.). <br><br>  Notre ligne est une ligne d√©limit√©e.  Mettez en surbrillance les s√©parateurs en violet: <br><br><img src="https://habrastorage.org/webt/kv/ua/ws/kvuaws-dfokcoad2styfhf2hkmc.png"><br><br>  Et mettez en surbrillance les √©l√©ments de la liste en jaune: <br><br><img src="https://habrastorage.org/webt/mf/_s/_q/mf_s_q1hwfwdnnvtsgfoziiwmis.png"><br><br>  Nous supposons que notre ligne est mutable (elle peut √™tre modifi√©e) et √©crivons une fonction: <br><br><img src="https://habrastorage.org/webt/ca/ai/en/caaientt_wwjxvcgegbn-ntkx7y.png"><br><br>  Sa signature, par exemple, pourrait √™tre: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span></span></code> </pre><br>  En entr√©e de la fonction, nous donnons une liste (sous la forme d'une cha√Æne avec d√©limiteurs) et, en fait, la valeur du d√©limiteur.  En sortie, la fonction renvoie le premier √©l√©ment de la liste (segment de ligne au premier s√©parateur), le reste de la liste et le signe indiquant si le premier √©l√©ment a √©t√© renvoy√©.  Dans ce cas, le reste de la liste est plac√© dans la m√™me variable que la liste d'origine. <br><br>  En cons√©quence, nous avons eu l'occasion d'√©crire comme ceci: <br><br><pre> <code class="java hljs">StringBuilder names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"ivanov;petrov;sidorov"</span></span>); StringBuilder name = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(cutNextToken(names, <span class="hljs-string"><span class="hljs-string">";"</span></span>, name)) { System.out.println(name); }</code> </pre><br>  Sorties comme pr√©vu: <br><br>  ivanov <br>  Petrov <br>  Sidorov <br><br>  Nous l'avons fait sans conversion en ArrayList, mais nous avons g√¢ch√© la variable names, et maintenant elle a une cha√Æne vide.  Cela ne semble pas encore tr√®s utile, comme s'ils avaient chang√© l'al√™ne pour le savon.  Mais allons plus loin.  L√†, nous verrons pourquoi c'√©tait n√©cessaire et o√π cela nous m√®nera. <br><br>  Analysons maintenant quelque chose de plus int√©ressant: une liste de paires cl√©-valeur.  Il s'agit √©galement d'une t√¢che tr√®s courante. <br><br><pre> <code class="java hljs">StringBuilder pairs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"name=ivan;surname=ivanov;middlename=ivanovich"</span></span>); StringBuilder pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cutNextToken(pairs, <span class="hljs-string"><span class="hljs-string">";"</span></span>, pair)) { StringBuilder paramName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); StringBuilder paramValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramName); cutNextToken(pair, <span class="hljs-string"><span class="hljs-string">"="</span></span>, paramValue); System.out.println(<span class="hljs-string"><span class="hljs-string">"param with name \""</span></span> + paramName + <span class="hljs-string"><span class="hljs-string">"\" has value of \""</span></span> + paramValue + <span class="hljs-string"><span class="hljs-string">"\""</span></span>); }</code> </pre><br>  Conclusion: <br><br><pre> <code class="hljs pgsql">param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "name" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivan" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "surname" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanov" param <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> "middlename" has <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> "ivanovich"</code> </pre> <br>  Aussi attendu.  Et la m√™me chose peut √™tre r√©alis√©e avec String.split, sans couper les lignes. <br>  Mais disons que nous voulions maintenant compliquer notre format et passer d'une valeur-cl√© plate √† un format imbriqu√© rappelant JSON.  Maintenant, nous voulons lire quelque chose comme ceci: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}}</code> </pre><br>  Quel s√©parateur divise?  Si c'est une virgule, alors dans l'un des jetons, nous aurons la ligne <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span></code> </pre> <br>  √âvidemment pas ce dont nous avons besoin.  Par cons√©quent, nous devons faire attention √† la structure de la ligne que nous voulons analyser. <br><br>  Il commence par une accolade boucl√©e et se termine par une accolade boucl√©e (jumel√©e √† elle, ce qui est important).  √Ä l'int√©rieur de ces crochets se trouve une liste de paires 'cl√©': 'valeur', chaque paire est s√©par√©e de la paire suivante par une virgule.  La cl√© et la valeur sont s√©par√©es par deux points.  Une cl√© est une cha√Æne de lettres entour√©e d'apostrophes.  La valeur peut √™tre une cha√Æne de caract√®res entour√©e d'apostrophes, ou il peut s'agir de la m√™me structure, commen√ßant et se terminant par des accolades boucl√©es.  Nous appelons une telle structure le mot ¬´objet¬ª, comme il est d'usage de l'appeler en JSON. <br><br>  Nous venons de d√©crire de mani√®re informelle la grammaire de notre format de type JSON.  En r√®gle g√©n√©rale, les grammaires sont d√©crites √† l'envers, sous une forme formelle, et la notation BNF ou ses variations sont utilis√©es pour les √©crire.  Mais maintenant je peux m'en passer, et nous allons voir comment vous pouvez "couper" cette ligne afin qu'elle puisse √™tre analys√©e selon les r√®gles de cette grammaire. <br><br>  En fait, notre ¬´objet¬ª commence par une accolade boucl√©e qui s'ouvre et se termine par une paire qui le ferme.  Que peut faire une fonction analysant un tel format?  Tr√®s probablement, les √©l√©ments suivants: <br><br><ul><li>  v√©rifier que la cha√Æne pass√©e commence par une accolade ouvrante </li><li>  v√©rifier que la cha√Æne pass√©e se termine par une paire d'accolades fermantes </li><li>  si les deux conditions sont vraies, coupez les parenth√®ses ouvrantes et fermantes, et ce qui reste, passez √† la fonction qui analyse la liste des paires 'cl√©': 'valeur' </li></ul><br>  Veuillez noter: les mots ¬´fonction analysant ce format¬ª et ¬´fonction analysant la liste des paires cl√©¬ª: ¬´valeur¬ª ¬ªsont apparus.  Nous avons deux fonctionnalit√©s!  Ce sont ces fonctions m√™mes que dans la description classique de l'algorithme de descente r√©cursive sont appel√©es ¬´fonctions d'analyse des symboles non terminaux¬ª, et qui disent que ¬´pour chaque symbole non terminal, sa propre fonction d'analyse est cr√©√©e¬ª.  Ce qui, en fait, l'analyse.  Nous pourrions les nommer, disons, parseJsonObject et parseJsonPairList. <br><br>  De plus, nous devons maintenant faire attention √† ce que nous avons le concept de ¬´paire de supports¬ª en plus du concept de ¬´s√©parateur¬ª.  Si pour couper une ligne vers le s√©parateur suivant (deux points entre une cl√© et une valeur, une virgule entre les paires ¬´cl√©: valeur¬ª), la fonction cutNextToken nous suffisait, maintenant que nous pouvons utiliser non seulement une cha√Æne, mais aussi un objet, nous avons besoin fonction "couper √† la prochaine paire de supports".  Quelque chose comme √ßa: <br><br><img src="https://habrastorage.org/webt/dr/5-/p0/dr5-p0qmt__fcae_ucs2iskx5xe.png"><br><br>  Cette fonction coupe un fragment de la ligne de la parenth√®se ouvrante √† la paire qui la ferme, compte tenu des parenth√®ses, le cas √©ch√©ant.  Bien s√ªr, vous ne pouvez pas vous limiter aux crochets, mais utilisez une fonction similaire pour couper diverses structures de blocs qui peuvent √™tre imbriqu√©es: blocs d'op√©rateur begin..end, if..endif, for..endfor et similaires. <br><br>  Dessinons graphiquement ce qui va arriver √† la cha√Æne.  Couleur turquoise - cela signifie que nous num√©risons la ligne vers l'avant jusqu'au symbole surlign√© en turquoise pour d√©terminer ce que nous devons faire ensuite.  Le violet est ¬´ce qu'il faut couper, c'est quand nous coupons les fragments surlign√©s en violet de la ligne, et continuons √† analyser ce qui en reste. <br><br><img src="https://habrastorage.org/webt/kq/pw/ze/kqpwze0fuzqcpxql01amxmvrdnq.png"><br><br>  A titre de comparaison, la sortie du programme (le texte du programme est donn√© en annexe) qui analyse cette ligne: <br><br>  D√©monstration de l'analyse d'une structure de type JSON <br><br><pre> <code class="hljs pgsql">ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>}} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'name'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span>,<span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivan'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'surname'</span></span>:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span>,<span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'surname'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'ivanov'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'birthdate'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OBJECT</span></span>:{<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> {<span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span>} ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'year'</span></span>:<span class="hljs-string"><span class="hljs-string">'1984'</span></span>,<span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'year'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'1984'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'month'</span></span>:<span class="hljs-string"><span class="hljs-string">'october'</span></span>,<span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'month'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'october'</span></span> ok, about <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parse pair list <span class="hljs-string"><span class="hljs-string">'day'</span></span>:<span class="hljs-string"><span class="hljs-string">'06'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> KEY: <span class="hljs-string"><span class="hljs-string">'day'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> STRING:<span class="hljs-string"><span class="hljs-string">'06'</span></span></code> </pre> <br>  √Ä tout moment, nous savons ce que nous nous attendons √† trouver dans notre ligne d'entr√©e.  Si nous entrons dans la fonction parseJsonObject, nous nous attendons √† ce que l'objet nous soit pass√© l√†-bas, et nous pouvons le v√©rifier par la pr√©sence d'une parenth√®se ouvrante et fermante au d√©but et √† la fin.  Si nous entrons dans la fonction parseJsonPairList, nous nous attendons √† une liste de paires "cl√©: valeur" l√†-bas, et apr√®s avoir "mordu" la cl√© (avant le s√©parateur ":"), nous nous attendons √† ce que la prochaine chose que nous "mordions" soit valeur.  Nous pouvons regarder le premier caract√®re de la valeur et tirer une conclusion sur son type (si l'apostrophe, alors la valeur est du type "cha√Æne", si le crochet ouvrant est la valeur est du type "objet"). <br><br>  Ainsi, en coupant des fragments de la cha√Æne, nous pouvons l'analyser par la m√©thode de l'analyse descendante (descente r√©cursive).  Et lorsque nous pouvons analyser, nous pouvons analyser le format dont nous avons besoin.  Ou cr√©ez votre propre format qui nous convient et d√©montez-le.  Ou proposez un langage sp√©cifique au domaine (DSL) pour notre domaine sp√©cifique et concevez un interpr√©teur pour celui-ci.  Et pour le construire correctement, sans solutions tortur√©es sur regexp ou self-made state-machines qui se posent pour les programmeurs qui essaient de r√©soudre un probl√®me qui n√©cessite une analyse, mais qui ne poss√®dent pas tout √† fait le mat√©riel. <br><br>  Ici.  F√©licitations √† tous pour l'√©t√© prochain et je vous souhaite bonne chance, amour et analyseurs fonctionnels :) <br><br>  Pour plus de lecture: <br><br>  Id√©ologique: quelques articles longs mais int√©ressants √† lire de Steve Yeegge: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nourriture de programmeur riche</a> <br><br>  Quelques citations √† partir de l√†: <br><blockquote>  Soit vous apprenez les compilateurs et vous commencez √† √©crire vos propres DSL, soit vous obtenez une meilleure langue </blockquote><blockquote>  La premi√®re grande phase du pipeline de compilation est l'analyse </blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le probl√®me du pinocchio</a> <br><br>  Citation de l√†: <br><blockquote>  Les conversions de type, le r√©tr√©cissement et l'√©largissement des conversions, les fonctions ami pour contourner les protections de classe standard, le <b>remplissage des minilangues en cha√Ænes et leur analyse manuelle</b> , il existe des dizaines de fa√ßons de contourner les syst√®mes de type en Java et C ++, et les programmeurs les utilisent tout le temps , car (ils ne savent pas) ils essaient en fait de cr√©er des logiciels, pas du mat√©riel. </blockquote>  Technique: deux articles sur l'analyse de la diff√©rence entre les approches LL et LR: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse LL et LR d√©mystifi√©e</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LL et LR en contexte: pourquoi les outils d'analyse sont difficiles</a> <br><br>  Et encore plus profond√©ment dans le sujet: comment √©crire un interpr√©teur Lisp en C ++ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interpr√®te lisp en 90 lignes de C ++</a> <br><br><div class="spoiler">  <b class="spoiler_title">Application.</b>  <b class="spoiler_title">Exemple de code (java) qui impl√©mente l'analyseur d√©crit dans l'article:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demoll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoLL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder svList, String separator, StringBuilder token)</span></span></span><span class="hljs-function"> </span></span>{ String s = svList.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.trim().isEmpty()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sepIndex = s.indexOf(separator); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sepIndex == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   ,    token.setLength(0); token.append(s); svList.setLength(0); } else { String t = s.substring(0, sepIndex); String restOfString = s.substring(sepIndex + separator.length(), s.length()); svList.setLength(0); svList.append(restOfString); token.setLength(0); token.append(t); } return true; } // "{hello world}:again" -&gt; "{hello world}", ":again" //"{'year':'1980','month':'october','day':'06'},'key1':'value1','key2':'value2'" -&gt; "{'year':'1980','month':'october','day':'06'}", ",'key1':'value1','key2':'value2'" public void cutTillMatchingParen(StringBuilder sbSrc, String openParen, String closeParen, StringBuilder matchPart){ String src = sbSrc.toString(); matchPart.setLength(0); int openParenCount = 0; String state = "not_copying"; for (int i = 0; i &lt; src.length(); i++){ String cs = String.valueOf(src.charAt(i)); // cs - current symbol if (state.equals("not_copying")){ if (cs.equals(openParen)) { state = "copying"; } } if (state.equals("copying")){ matchPart.append(cs); if (cs.equals(openParen)){ openParenCount = openParenCount + 1; } if (cs.equals(closeParen)) { openParenCount = openParenCount - 1; } if (openParenCount == 0) { break; } } } sbSrc.setLength(0); sbSrc.append(src.substring(matchPart.length(), src.length())); } public void parseJsonObject(String s) { System.out.println("ok, about to parse JSON object " + s); if (s.charAt(0) == '{' &amp;&amp; s.charAt(s.length() - 1) == '}') { String pairList = s.substring(1, s.length() - 1).trim(); parseJsonPairList(pairList); } else { System.out.println("Syntax error: not a JSON object. Must start with { and end with }"); } } public void parseJsonPairList(String pairList) { pairList = pairList.trim(); if (pairList.isEmpty()) { //System.out.println("pairList is empty"); return; } System.out.println("ok, about to parse pair list " + pairList); if (pairList.charAt(0) != '\'') { System.out.println("syntax error: key must be of type STRING, input: + pairList"); return; } StringBuilder key = new StringBuilder(); StringBuilder sbPairList = new StringBuilder(pairList); this.cutNextToken(sbPairList, ":", key); // sbPairList  ,   "name":"ivan"...,   "ivan"... System.out.println("found KEY: " + key); // checking type of value - may be String or Object StringBuilder value = new StringBuilder(); if (sbPairList.charAt(0) == '{') { cutTillMatchingParen(sbPairList, "{", "}", value); System.out.println("found VALUE of type OBJECT:" + value); parseJsonObject(value.toString()); StringBuilder emptyString = new StringBuilder(); cutNextToken(sbPairList, ",", emptyString); } else if (sbPairList.charAt(0) == '\'') { this.cutNextToken(sbPairList, ",", value); System.out.println("found VALUE of type STRING:" + value); } else { System.out.println("syntax error: VALUE must be either STRING or OBJECT"); return; } parseJsonPairList(sbPairList.toString()); } public static void main(String[] args){ DemoLL d = new DemoLL(); System.out.println("   \"=\""); StringBuilder pairs = new StringBuilder("name=ivan;surname=ivanov;middlename=ivanovich"); StringBuilder pair = new StringBuilder(); while (d.cutNextToken(pairs, ";", pair)) { StringBuilder paramName = new StringBuilder(); StringBuilder paramValue = new StringBuilder(); d.cutNextToken(pair, "=", paramName); d.cutNextToken(pair, "=", paramValue); System.out.println("param with name \"" + paramName + "\" has value of \"" + paramValue + "\""); } System.out.println("  JSON- "); String s = "{'name':'ivan','surname':'ivanov','birthdate':{'year':'1984','month':'october','day':'06'}}"; d.parseJsonObject(s); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412905/">https://habr.com/ru/post/fr412905/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412895/index.html">Vesta Matveeva: la lutte contre la cybercriminalit√© est un choix moral</a></li>
<li><a href="../fr412897/index.html">Surveillance des produits Atlassian avec Prometheus</a></li>
<li><a href="../fr412899/index.html">Week-end lecture: 30 documents sur le son, l'histoire des marques audio et l'industrie cin√©matographique</a></li>
<li><a href="../fr412901/index.html">Surveillance et Kubernetes (revue et rapport vid√©o)</a></li>
<li><a href="../fr412903/index.html">Comment nous avons peint Habr</a></li>
<li><a href="../fr412911/index.html">Les d√©veloppeurs parlent de fonctionnalit√©s d√©coup√©es dans les jeux</a></li>
<li><a href="../fr412913/index.html">"Baikal-T1" a √©t√© mis en vente pour 3990 roubles</a></li>
<li><a href="../fr412915/index.html">D√©termination de la densit√© de gaz √† partir des r√©sultats de la mesure de la pression et de la temp√©rature avec des capteurs Arduino</a></li>
<li><a href="../fr412917/index.html">La poste russe commencera √† utiliser des trieurs robotiques. Comment cela fonctionnera</a></li>
<li><a href="../fr412921/index.html">Signatures du r√©seau Monero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>