<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍✈️ ⏪ 📹 MVCC-2. Lapisan, File, Halaman 🏍️ 🗜️ 😃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terakhir kali kami berbicara tentang konsistensi data, melihat perbedaan antara tingkat isolasi transaksi yang berbeda melalui mata pengguna, dan menc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-2. Lapisan, File, Halaman</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444536/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terakhir kali</a> kami berbicara tentang konsistensi data, melihat perbedaan antara tingkat isolasi transaksi yang berbeda melalui mata pengguna, dan mencari tahu mengapa itu penting untuk diketahui.  Sekarang kita mulai belajar bagaimana PostgreSQL mengimplementasikan isolasi berbasis gambar dan mekanisme multi-versi. <br><br>  Pada artikel ini, kita akan melihat bagaimana data secara fisik terletak di file dan halaman.  Ini menjauhkan kita dari topik isolasi, tetapi penyimpangan semacam itu diperlukan untuk memahami materi lebih lanjut.  Kita perlu memahami cara kerja penyimpanan data tingkat rendah. <br><br><h1>  Hubungan </h1><br>  Jika Anda melihat di dalam tabel dan indeks, ternyata mereka disusun dengan cara yang sama.  Baik itu, dan lain - objek dasar yang berisi beberapa data yang terdiri dari garis. <br><br>  Fakta bahwa tabel terdiri dari baris tidak diragukan;  untuk indeks, ini kurang jelas.  Namun, bayangkan B-tree: terdiri dari node yang berisi nilai yang diindeks dan tautan ke node lain atau ke baris tabel.  Node-node ini dapat dianggap sebagai garis indeks - pada kenyataannya, sebagaimana adanya. <br><br>  Bahkan, masih ada sejumlah objek yang disusun dengan cara yang serupa: urutan (pada dasarnya tabel baris tunggal), tampilan terwujud (pada dasarnya tabel yang mengingat kueri).  Dan kemudian ada pandangan biasa, yang dengan sendirinya tidak menyimpan data, tetapi dalam semua hal lain mirip dengan tabel. <br><br>  Semua objek ini di PostgreSQL disebut <em>hubungan</em> kata umum.  Kata ini sangat disayangkan karena merupakan istilah dari teori relasional.  Anda bisa menggambar paralel antara relasi dan tabel (tampilan), tetapi tentu saja tidak antara relasi dan indeks.  Tetapi itu terjadi: akar akademik PostgreSQL membuat mereka merasa.  Saya pikir pada awalnya disebut tabel dan pandangan, dan sisanya tumbuh seiring waktu. <br><a name="habracut"></a><br>  Lebih lanjut, untuk kesederhanaan, kita hanya akan berbicara tentang tabel dan indeks, tetapi <em>hubungan</em> lainnya terstruktur persis sama. <br><br><h1>  Layers (fork) dan file </h1><br>  Biasanya, setiap relasi memiliki beberapa <em>lapisan</em> (garpu).  Lapisan terdiri dari beberapa jenis dan masing-masingnya berisi jenis data tertentu. <br><br>  Jika ada layer, maka pada awalnya itu diwakili oleh satu <em>file</em> .  Nama file terdiri dari pengidentifikasi numerik dimana akhir yang sesuai dengan nama layer dapat ditambahkan. <br><br>  File secara bertahap tumbuh dan ketika ukurannya mencapai 1 GB, file berikutnya dari lapisan yang sama dibuat (file tersebut kadang-kadang disebut <em>segmen</em> ).  Nomor segmen ditambahkan ke akhir nama file. <br><br>  Batasan ukuran file 1 GB telah muncul secara historis untuk mendukung berbagai sistem file, beberapa di antaranya tidak dapat bekerja dengan file besar.  Pembatasan dapat diubah ketika membangun PostgreSQL ( <code>./configure --with-segsize</code> ). <br><br>  Dengan demikian, beberapa file dapat berhubungan dengan satu relasi pada disk.  Misalnya, untuk meja kecil akan ada 3 dari mereka. <br><br>  Semua file objek milik satu ruang tabel dan satu basis data akan ditempatkan dalam satu direktori.  Ini harus diperhitungkan karena sistem file biasanya tidak berfungsi dengan baik dengan sejumlah besar file dalam direktori. <br><br>  Perhatikan saja bahwa file-file tersebut, pada gilirannya, dibagi menjadi beberapa <em>halaman</em> (atau <em>blok</em> ), biasanya 8 KB.  Kami akan berbicara tentang struktur internal laman di bawah. <br><br><img src="https://habrastorage.org/webt/oz/ur/4z/ozur4zenihys-v-7wl5rnxyi8em.png"><br><br>  Sekarang mari kita lihat jenis-jenis lapisan. <br><br>  <strong>Lapisan utama</strong> adalah data itu sendiri: tabel atau baris indeks yang sama.  Lapisan utama ada untuk setiap hubungan (kecuali untuk representasi yang tidak mengandung data). <br><br>  Nama-nama file di lapisan utama hanya terdiri dari pengidentifikasi numerik.  Berikut ini contoh jalur ke file tabel yang kami buat terakhir kali: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  Dari mana pengidentifikasi ini berasal?  Direktori dasar sesuai dengan tablespace pg_default, subdirektori berikutnya sesuai dengan database, dan file yang kami minati sudah ada di dalamnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  Path relatif, dihitung dari direktori data (PGDATA).  Selain itu, hampir semua jalur di PostgreSQL dihitung dari PGDATA.  Berkat ini, Anda dapat dengan aman mentransfer PGDATA ke tempat lain - itu tidak menampung apa pun (kecuali Anda mungkin perlu mengkonfigurasi jalur ke perpustakaan di LD_LIBRARY_PATH). <br><br>  Kami melihat lebih jauh dalam sistem file: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  <strong>Lapisan inisialisasi</strong> hanya ada untuk tabel non-jurnal (dibuat dengan UNLOGGED) dan indeksnya.  Objek seperti itu tidak berbeda dari yang biasa, kecuali bahwa tindakan dengan mereka tidak direkam dalam log prarekam.  Karena ini, bekerja dengan mereka lebih cepat, tetapi jika terjadi kegagalan, tidak mungkin untuk mengembalikan data dalam keadaan konsisten.  Oleh karena itu, ketika memulihkan, PostgreSQL hanya menghapus semua lapisan objek tersebut dan menulis lapisan inisialisasi ke tempat lapisan utama.  Hasilnya adalah "boneka".  Kita akan berbicara tentang penjurnalan secara terperinci, tetapi dalam siklus yang berbeda. <br><br>  Tabel akun dijurnal, sehingga tidak ada lapisan inisialisasi untuknya.  Tetapi untuk percobaan, Anda dapat menonaktifkan pencatatan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  Kemampuan untuk mengaktifkan dan menonaktifkan journaling on the fly, seperti dapat dilihat dari contoh, melibatkan menimpa data ke file dengan nama yang berbeda. <br><br>  Lapisan inisialisasi memiliki nama yang sama dengan lapisan utama, tetapi dengan akhiran "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  <strong>Peta ruang bebas</strong> (peta ruang bebas) - lapisan di mana ada ruang kosong di dalam halaman.  Tempat ini terus berubah: ketika versi baru dari string ditambahkan, ia berkurang, sementara pembersihan - itu meningkat.  Peta ruang bebas digunakan ketika memasukkan versi baris baru untuk dengan cepat menemukan halaman yang cocok di mana data yang akan ditambahkan akan cocok. <br><br>  Peta ruang bebas memiliki akhiran "_fsm".  Tetapi file tidak segera muncul, tetapi hanya jika perlu.  Cara termudah untuk mencapai ini adalah dengan membersihkan meja (mengapa - mari kita bicara tepat waktu): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  Peta visibilitas adalah lapisan di mana halaman yang hanya berisi versi string saat ini ditandai dengan satu bit.  Secara kasar, ini berarti bahwa ketika suatu transaksi mencoba membaca suatu baris dari halaman seperti itu, garis tersebut dapat ditampilkan tanpa memeriksa visibilitasnya.  Kami akan memeriksa secara rinci bagaimana ini terjadi dalam artikel berikut. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  Halaman </h1><br>  Seperti yang telah kami katakan, file secara logis dibagi menjadi beberapa halaman. <br><br>  Biasanya, sebuah halaman berukuran 8 KB.  Anda dapat mengubah ukuran dalam batas-batas tertentu (16 KB atau 32 KB), tetapi hanya selama perakitan ( <code>./configure --with-blocksize</code> ).  Contoh assembled and running dapat bekerja dengan halaman hanya satu ukuran. <br><br>  Terlepas dari lapisan mana file milik, mereka digunakan oleh server dengan cara yang kira-kira sama.  Halaman pertama kali dibaca ke dalam cache buffer, tempat proses dapat membaca dan memodifikasinya;  kemudian, jika perlu, halaman didorong kembali ke disk. <br><br>  Setiap halaman memiliki markup internal dan umumnya berisi bagian-bagian berikut: <br><br><pre>        0 + ----------------------------------- +
           |  menuju |
       24 + ----------------------------------- +
           |  array pointer ke string versi |
    lebih rendah + ----------------------------------- +
           |  ruang kosong |
    atas + ----------------------------------- +
           |  versi baris |
  spesial + ----------------------------------- +
           |  area khusus |
 pagesize + ----------------------------------- +
</pre><br>  Ukuran bagian-bagian ini mudah diketahui dengan ekstensi halaman "penelitian": <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Di sini kita melihat <strong>judul halaman</strong> pertama (nol) dari tabel.  Selain ukuran area yang tersisa, tajuk berisi informasi lain tentang halaman, tetapi belum menarik bagi kami. <br><br>  Di bagian bawah halaman adalah <strong>area khusus</strong> , dalam kasus kami, kosong.  Ini digunakan hanya untuk indeks, dan kemudian tidak untuk semua orang.  "Bawah" di sini sesuai dengan gambar;  mungkin akan lebih tepat untuk mengatakan "di alamat tinggi". <br><br>  Mengikuti area khusus adalah <strong>versi baris</strong> - data yang kami simpan di tabel, ditambah beberapa informasi overhead. <br><br>  Di bagian atas halaman, segera setelah tajuk, adalah daftar isi: <strong>array pointer</strong> ke versi garis yang tersedia di halaman. <br><br>  Antara versi garis dan pointer mungkin ada <strong>ruang kosong</strong> (yang ditandai di peta ruang kosong).  Perhatikan bahwa tidak ada fragmentasi di dalam halaman, semua ruang kosong selalu diwakili oleh satu fragmen. <br><br><h2>  Pointer </h2><br>  Mengapa pointer ke versi string diperlukan?  Faktanya adalah bahwa baris indeks entah bagaimana harus merujuk ke versi baris dalam tabel.  Jelas bahwa tautan tersebut harus berisi nomor file, nomor halaman dalam file dan beberapa indikasi versi baris.  Offset dari awal halaman dapat digunakan sebagai indikasi seperti itu, tetapi ini tidak nyaman.  Kami tidak akan dapat memindahkan versi baris di dalam halaman karena akan merusak tautan yang ada.  Dan ini akan menyebabkan fragmentasi ruang di dalam halaman dan konsekuensi tidak menyenangkan lainnya.  Oleh karena itu, indeks mengacu pada nomor indeks, dan penunjuk mengacu pada posisi saat ini dari versi baris di halaman.  Ternyata pengalamatan tidak langsung. <br><br>  Setiap pointer menempati tepat 4 byte dan berisi: <br><br><ul><li>  tautan ke versi string; </li><li>  panjang versi string ini; </li><li>  beberapa bit yang menentukan status versi string. </li></ul><br><h2>  Format data </h2><br>  Format data pada disk sepenuhnya bertepatan dengan representasi data dalam RAM.  Halaman dibaca ke dalam cache buffer "apa adanya", tanpa transformasi apa pun.  Oleh karena itu, file data dari satu platform tidak kompatibel dengan platform lain. <br><br>  Misalnya, dalam arsitektur x86, urutan byte diadopsi dari yang paling signifikan ke yang tertinggi (little-endian), z / Arsitektur menggunakan urutan terbalik (big-endian), dan dalam ARM urutan sakelar. <br><br>  Banyak arsitektur menyediakan penyelarasan data melintasi batas-batas kata mesin.  Misalnya, pada sistem 32-bit x86, bilangan bulat (tipe bilangan bulat, menempati 4 byte) akan disejajarkan di perbatasan kata 4-byte, serta angka floating-point presisi ganda (tipe presisi ganda, 8 byte).  Dan pada sistem 64-bit, nilai ganda akan disejajarkan di perbatasan kata 8-byte.  Ini adalah alasan lain ketidakcocokan. <br><br>  Karena perataan, ukuran baris tabel tergantung pada urutan bidang.  Biasanya efek ini tidak terlalu terlihat, tetapi dalam beberapa kasus dapat menyebabkan peningkatan ukuran yang signifikan.  Misalnya, jika Anda menempatkan char (1) dan bidang integer bercampur, 3 byte biasanya akan terbuang di antara mereka.  Anda dapat melihat lebih banyak tentang ini di presentasi Nikolai Shaplov " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">What's Inside It</a> ". <br><br><h1>  Versi String dan TOAST </h1><br>  Tentang bagaimana versi string disusun dari dalam, kami akan berbicara secara rinci lain kali.  Sejauh ini, satu-satunya hal penting bagi kami adalah bahwa setiap versi harus sesuai sepenuhnya pada satu halaman: PostgreSQL tidak menyediakan cara untuk "melanjutkan" baris pada halaman berikutnya.  Alih-alih, sebuah teknologi yang disebut TOAST (Teknik Penyimpanan Atribut Besar) digunakan.  Nama itu sendiri menunjukkan bahwa tali dapat dipotong menjadi roti panggang. <br><br>  Serius berbicara, TOAST melibatkan beberapa strategi.  Nilai atribut "Panjang" dapat dikirim ke tabel layanan terpisah, yang sebelumnya dipotong kecil-kecil.  Pilihan lain adalah untuk mengompres nilai sehingga versi baris masih cocok di halaman tabel reguler.  Dan mungkin baik itu, dan yang lain: pada awalnya untuk kompres, dan hanya kemudian memotong dan mengirim. <br><br>  Untuk setiap tabel utama, jika perlu, yang terpisah, tetapi satu untuk semua atribut, tabel TOAST (dan indeks khusus untuk itu) dibuat.  Kebutuhan ditentukan oleh keberadaan atribut yang berpotensi panjang dalam tabel.  Misalnya, jika tabel memiliki kolom tipe numerik atau teks, tabel TOAST akan segera dibuat, bahkan jika nilai yang panjang tidak digunakan. <br><br>  Karena tabel TOAST pada dasarnya adalah tabel biasa, ia masih memiliki seperangkat lapisan yang sama.  Dan ini menggandakan jumlah file yang "melayani" tabel. <br><br>  Awalnya, strategi ditentukan oleh tipe data kolom.  Anda dapat melihatnya dengan perintah <code>\d+</code> dalam psql, tetapi karena ia juga menampilkan banyak informasi lain, kami akan menggunakan permintaan ke direktori sistem: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Nama-nama strategi memiliki arti sebagai berikut: <br><br><ul><li>  plain - TOAST tidak digunakan (digunakan untuk tipe data yang jelas "pendek", seperti integer); </li><li>  extended - baik kompresi dan penyimpanan dalam tabel TOAST terpisah diizinkan; </li><li>  nilai eksternal - panjang disimpan dalam tabel TOAST tanpa kompresi; </li><li>  nilai utama - panjang dikompresi terlebih dahulu dan hanya di tabel TOAST jika kompresi tidak membantu. </li></ul><br>  Secara umum, algoritma adalah sebagai berikut.  PostgreSQL ingin setidaknya 4 baris agar sesuai pada satu halaman.  Oleh karena itu, jika ukuran garis melebihi bagian keempat halaman, dengan mempertimbangkan tajuk (dengan halaman 8K normal, ini adalah 2040 byte), TOAST harus diterapkan ke bagian nilai.  Kami bertindak sesuai urutan yang dijelaskan di bawah ini dan berhenti segera setelah garis berhenti melebihi ambang batas: <br><br><ol><li>  Pertama, kami memilah-milah atribut dengan strategi eksternal dan diperpanjang, bergerak dari yang terpanjang ke yang lebih pendek.  Atribut yang diperluas dikompresi (jika ini memiliki efek) dan, jika nilainya sendiri melebihi seperempat halaman, ia segera dikirim ke tabel TOAST.  Atribut eksternal ditangani dengan cara yang sama, tetapi tidak dikompresi. </li><li>  Jika setelah lulus pertama versi baris masih tidak cocok, kami mengirim atribut yang tersisa dengan strategi eksternal dan diperluas ke tabel TOAST. </li><li>  Jika ini juga tidak membantu, coba kompres atribut dengan strategi utama, sambil meninggalkannya di halaman tabel. </li><li>  Dan hanya jika setelah itu barisnya masih belum cukup pendek, atribut utama dikirim ke tabel TOAST. </li></ol><br>  Terkadang mungkin berguna untuk mengubah strategi untuk beberapa kolom.  Misalnya, jika diketahui sebelumnya bahwa data dalam kolom tidak dikompresi, Anda dapat mengatur strategi eksternal untuk itu - ini akan menghemat upaya kompresi yang tidak berguna.  Ini dilakukan sebagai berikut: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  Mengulangi permintaan, kami mendapatkan: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  Tabel dan indeks TOAST terletak di skema pg_toast terpisah dan karenanya biasanya tidak terlihat.  Untuk tabel sementara, skema pg_toast_temp_ <em>N</em> digunakan, mirip dengan pg_temp_ <em>N.</em> biasa <br><br>  Tentu saja, jika diinginkan, tidak ada yang mau mengintip mekanisme internal proses.  Katakanlah ada tiga atribut yang berpotensi panjang di tabel akun, jadi tabel TOAST harus.  Ini dia: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Adalah logis bahwa untuk "bersulang" ke mana garis diiris, strategi polos diterapkan: TOAST tingkat kedua tidak ada. <br><br>  Indeks PostgreSQL bersembunyi lebih hati-hati, tetapi juga mudah ditemukan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  Kolom klien menggunakan strategi yang diperluas: nilai-nilai di dalamnya akan dikompresi.  Periksa: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  Tidak ada dalam tabel TOAST: karakter berulang dikompresi dengan sempurna dan setelah itu nilainya cocok dengan halaman tabel biasa. <br><br>  Sekarang biarkan nama klien terdiri dari karakter acak: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Urutan ini tidak dapat dikompresi, dan jatuh ke dalam tabel TOAST: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Seperti yang Anda lihat, data dipotong menjadi fragmen 2000 byte. <br><br>  Ketika mengakses nilai "panjang", PostgreSQL secara otomatis, transparan ke aplikasi, mengembalikan nilai asli dan mengembalikannya ke klien. <br><br>  Tentu saja, cukup banyak sumber daya dihabiskan untuk mengiris kompresi dan pemulihan selanjutnya.  Oleh karena itu, menyimpan data dalam PostgreSQL bukan ide yang baik, terutama jika itu digunakan secara aktif dan logika transaksional tidak diperlukan untuk mereka (sebagai contoh: dokumen asli yang dipindai dari dokumen akuntansi).  Alternatif yang lebih menguntungkan mungkin menyimpan data tersebut pada sistem file, dan dalam DBMS, nama-nama file yang sesuai. <br><br>  Tabel TOAST hanya digunakan saat mengacu pada nilai "panjang".  Selain itu, tabel roti panggang memiliki versi sendiri: jika pembaruan data tidak memengaruhi nilai "panjang", versi baris baru akan merujuk ke nilai yang sama di tabel TOAST - ini menghemat ruang. <br><br>  Perhatikan bahwa TOAST hanya berfungsi untuk tabel, tetapi tidak untuk indeks.  Ini memberlakukan batasan pada ukuran kunci yang diindeks. <br><blockquote>  Anda dapat membaca lebih lanjut tentang organisasi data internal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam dokumentasi</a> . <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444536/">https://habr.com/ru/post/id444536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444524/index.html">Lambdas: dari C ++ 11 ke C ++ 20. Bagian 1</a></li>
<li><a href="../id444526/index.html">Stack DOTS: C ++ & C #</a></li>
<li><a href="../id444528/index.html">Situasi: Jepang dapat membatasi pengunduhan konten dari jaringan - kami memahami dan mendiskusikan</a></li>
<li><a href="../id444530/index.html">Masa depan injeksi ketergantungan di Android</a></li>
<li><a href="../id444534/index.html">Pemindaian kerentanan dan pengembangan yang aman. Bagian 1</a></li>
<li><a href="../id444540/index.html">Intel siap memulai produksi memori MRAM</a></li>
<li><a href="../id444542/index.html">Siaran Langsung dan Jadwal Konferensi untuk SmartMail Conf: Pembelajaran Mesin</a></li>
<li><a href="../id444544/index.html">Sesuatu tentang pusat data terdistribusi untuk bisnis</a></li>
<li><a href="../id444546/index.html">Bagaimana dan mengapa bekerja lebih lambat? Metode Sergey Korolev</a></li>
<li><a href="../id444548/index.html">Pengalaman pribadi: bagaimana kami terlibat dalam promosi startup Hispanik di Amerika Latin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>