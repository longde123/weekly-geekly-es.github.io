<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçó üë©üèø üèáüèª JavaScript: explorer des objets ‚òØÔ∏è üë®üèæ‚Äçü§ù‚Äçüë®üèº üàÇÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le mat√©riel, dont nous publions la traduction aujourd'hui, est consacr√© √† l'√©tude des objets - l'une des essences cl√©s de JavaScript. Il est con√ßu pri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript: explorer des objets</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420615/">  Le mat√©riel, dont nous publions la traduction aujourd'hui, est consacr√© √† l'√©tude des objets - l'une des essences cl√©s de JavaScript.  Il est con√ßu principalement pour les d√©veloppeurs d√©butants qui souhaitent rationaliser leurs connaissances des objets. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/vo/lg/xb/volgxbgclrhdnqvvi_qdqfc1yna.jpeg"></a> <br><br>  Les objets en JavaScript sont des collections dynamiques de propri√©t√©s qui, en outre, contiennent une propri√©t√© ¬´cach√©e¬ª qui est un prototype de l'objet.  Les propri√©t√©s des objets sont caract√©ris√©es par des cl√©s et des valeurs.  Commen√ßons la conversation sur les objets JS avec des cl√©s. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Cl√©s de propri√©t√© d'objet</font> </h2><br>  La cl√© de propri√©t√© d'objet est une cha√Æne unique.  Vous pouvez utiliser deux m√©thodes pour acc√©der aux propri√©t√©s: y acc√©der via un point et sp√©cifier la cl√© d'objet entre crochets.  Lors de l'acc√®s aux propri√©t√©s via un point, la cl√© doit √™tre un identifiant JavaScript valide.  Prenons un exemple: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> obj = {  <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span> } obj.message //<span class="hljs-string"><span class="hljs-string">"A message"</span></span> obj[<span class="hljs-string"><span class="hljs-string">"message"</span></span>] //<span class="hljs-string"><span class="hljs-string">"A message"</span></span></code> </pre> <br>  Lorsque vous essayez d'acc√©der √† une propri√©t√© inexistante d'un objet, un message d'erreur n'appara√Ætra pas, mais la valeur <code>undefined</code> sera retourn√©e: <br><br><pre> <code class="hljs objectivec">obj.otherProperty <span class="hljs-comment"><span class="hljs-comment">//undefined</span></span></code> </pre> <br>  Lorsque vous utilisez des crochets pour acc√©der aux propri√©t√©s, vous pouvez utiliser des cl√©s qui ne sont pas des identificateurs JavaScript valides (par exemple, la cl√© peut √™tre une cha√Æne contenant des espaces).  Ils peuvent avoir n'importe quelle valeur pouvant √™tre convertie en cha√Æne: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> french = {}; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>] = <span class="hljs-string"><span class="hljs-string">"thank you very much"</span></span>; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//"thank you very much"</span></span></code> </pre> <br>  Si des valeurs non-cha√Æne sont utilis√©es comme cl√©s, elles sont automatiquement converties en cha√Ænes (en utilisant, si possible, la <code>toString()</code> ): <br><br><pre> <code class="hljs powershell">et obj = {}; //Number obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"Number 1"</span></span>; obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true //Object let number1 = { toString : function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } } obj[<span class="hljs-type"><span class="hljs-type">number1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true</code> </pre> <br>  Dans cet exemple, l'objet <code>number1</code> est utilis√© comme cl√©.  Lorsque vous essayez d'acc√©der √† une propri√©t√©, elle est convertie en ligne <code>1</code> et le r√©sultat de cette conversion est utilis√© comme cl√©. <br><br><h2>  <font color="#3AC1EF">Valeurs des propri√©t√©s d'objet</font> </h2><br>  Les propri√©t√©s d'objet peuvent √™tre des valeurs primitives, des objets ou des fonctions. <br><br><h3>  <font color="#3AC1EF">‚ñçObjet en tant que valeur de propri√©t√© d'objet</font> </h3><br>  Les objets peuvent √™tre plac√©s dans d'autres objets.  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = { title : <span class="hljs-string"><span class="hljs-string">"The Good Parts"</span></span>, author : {   firstName : <span class="hljs-string"><span class="hljs-string">"Douglas"</span></span>,   lastName : <span class="hljs-string"><span class="hljs-string">"Crockford"</span></span> } } book.author.firstName; <span class="hljs-comment"><span class="hljs-comment">//"Douglas"</span></span></code> </pre> <br>  Une approche similaire peut √™tre utilis√©e pour cr√©er des espaces de noms: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> app = {}; app.authorService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; app.bookService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} };</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Fonction en tant que valeur de propri√©t√© d'objet</font> </h3><br>  Lorsqu'une fonction est utilis√©e comme valeur de propri√©t√© d'objet, elle devient g√©n√©ralement une m√©thode d'objet.  Dans la m√©thode, pour acc√©der √† l'objet courant, utilisez le <code>this</code> . <br><br>  Cependant, ce mot cl√© peut avoir diff√©rentes significations, selon la fa√ßon dont la fonction a √©t√© appel√©e.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez lire des situations dans lesquelles <code>this</code> perd le contexte. <br><br><h2>  <font color="#3AC1EF">La nature dynamique des objets</font> </h2><br>  Les objets en JavaScript, de par leur nature, sont des entit√©s dynamiques.  Vous pouvez leur ajouter des propri√©t√©s √† tout moment, il en va de m√™me pour la suppression des propri√©t√©s: <br><br><pre> <code class="hljs ruby">let obj = {}; obj.message = <span class="hljs-string"><span class="hljs-string">"This is a message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   obj.otherMessage = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    delete obj.otherMessage; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> </code> </pre> <br><h2>  <font color="#3AC1EF">Objets en tant que tableaux associatifs</font> </h2><br>  Les objets peuvent √™tre consid√©r√©s comme des tableaux associatifs.  Les cl√©s de tableau associatif sont les noms de propri√©t√© de l'objet.  Pour acc√©der √† la cl√©, vous n'avez pas besoin de regarder toutes les propri√©t√©s, c'est-√†-dire que l'op√©ration d'acc√®s √† la cl√© d'un tableau associatif bas√© sur un objet s'effectue en temps O (1). <br><br><h2>  <font color="#3AC1EF">Prototypes d'objets</font> </h2><br>  Les objets ont un lien ¬´cach√©¬ª, <code>__proto__</code> , pointant vers un objet prototype dont l'objet h√©rite des propri√©t√©s. <br><br>  Par exemple, un objet cr√©√© √† l'aide d'un litt√©ral d'objet a un lien vers <code>Object.prototype</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; obj.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype; <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Objets vides</font> </h3><br>  Comme nous venons de le voir, l'objet "vide", <code>{}</code> , n'est en fait pas si vide, car il contient une r√©f√©rence √† <code>Object.prototype</code> .  Pour cr√©er un objet vraiment vide, vous devez utiliser la construction suivante: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre> <br>  Gr√¢ce √† cela, un objet sans prototype sera cr√©√©.  Ces objets sont g√©n√©ralement utilis√©s pour cr√©er des tableaux associatifs. <br><br><h3>  <font color="#3AC1EF">‚ñç Cha√Æne prototype</font> </h3><br>  Les objets prototypes peuvent avoir leurs propres prototypes.  Si vous essayez d'acc√©der √† une propri√©t√© d'un objet qui n'y est pas, JavaScript essaiera de trouver cette propri√©t√© dans le prototype de cet objet, et si la propri√©t√© souhait√©e n'est pas l√†, une tentative sera faite pour la trouver dans le prototype du prototype.  Cela continuera jusqu'√† ce que la propri√©t√© souhait√©e soit trouv√©e ou jusqu'√† ce que la fin de la cha√Æne de prototype soit atteinte. <br><br><h2>  <font color="#3AC1EF">Valeurs de type primitif et wrappers d'objets</font> </h2><br>  JavaScript vous permet de travailler avec les valeurs des types primitifs en tant qu'objets, dans le sens o√π le langage vous permet d'acc√©der √† leurs propri√©t√©s et m√©thodes. <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span> <span class="hljs-string"><span class="hljs-string">"text"</span></span>.toUpperCase(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"TEXT"</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>.toString(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  De plus, bien s√ªr, les valeurs des types primitifs ne sont pas des objets. <br><br>  Pour organiser l'acc√®s aux ¬´propri√©t√©s¬ª des valeurs des types primitifs, JavaScript, si n√©cessaire, cr√©e des objets wrapper qui, une fois devenus inutiles, sont d√©truits.  Le processus de cr√©ation et de destruction d'objets wrapper est optimis√© par le moteur JS. <br><br>  Les wrappers d'objets ont des valeurs de type num√©rique, cha√Æne et logique.  Les objets des types correspondants sont repr√©sent√©s par les fonctions constructeur <code>Number</code> , <code>String</code> et <code>Boolean</code> . <br><br><h2>  <font color="#3AC1EF">Prototypes int√©gr√©s</font> </h2><br>  Les objets num√©riques h√©ritent des propri√©t√©s et des m√©thodes du prototype <code>Number.prototype</code> , qui est le descendant de <code>Object.prototype</code> : <br><br><pre> <code class="hljs pgsql">var <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__ === Number.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__.__proto__ === <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Le prototype des objets cha√Æne est <code>String.prototype</code> .  Le prototype des objets bool√©ens est <code>Boolean.prototype</code> .  Le prototype des tableaux (qui sont √©galement des objets) est <code>Array.prototype</code> . <br><br>  Les fonctions en JavaScript sont √©galement des objets qui ont un prototype <code>Function.prototype</code> .  Les fonctions ont des m√©thodes comme <code>bind()</code> , <code>apply()</code> et <code>call()</code> . <br><br>  Tous les objets, fonctions et objets repr√©sentant des valeurs de type primitif (√† l'exception des valeurs <code>null</code> et <code>undefined</code> ) h√©ritent des propri√©t√©s et des m√©thodes de <code>Object.prototype</code> .  Cela conduit au fait que, par exemple, ils ont tous une <code>toString()</code> . <br><br><h2>  <font color="#3AC1EF">Extension d'objets incorpor√©s avec des polyfills</font> </h2><br>  JavaScript facilite l'extension des objets int√©gr√©s avec de nouvelles fonctionnalit√©s √† l'aide de ce que l'on appelle les polyfills.  Un polyfill est un morceau de code qui impl√©mente des fonctionnalit√©s qui ne sont prises en charge par aucun navigateur. <br><br><h3>  <font color="#3AC1EF">‚ñçUtilisation de polyfills</font> </h3><br>  Par exemple, il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill</a> pour la m√©thode <code>Object.assign()</code> .  Il vous permet d'ajouter une nouvelle fonction √† <code>Object</code> si elle n'y est pas disponible. <br><br>  Il en va de m√™me pour le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill</a> <code>Array.from()</code> qui, si la m√©thode <code>from()</code> n'est pas dans l'objet <code>Array</code> , l'√©quipe de cette m√©thode. <br><br><h3>  <font color="#3AC1EF">‚ñç Polyfill et prototypes</font> </h3><br>  √Ä l'aide de polyfills, de nouvelles m√©thodes peuvent √™tre ajout√©es aux prototypes d'objets.  Par exemple, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill</a> pour <code>String.prototype.trim()</code> vous permet d'√©quiper tous les objets cha√Æne avec la m√©thode <code>trim()</code> : <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = "   A text "; <span class="hljs-type"><span class="hljs-type">text</span></span>.trim(); //"A text"</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le polyfill</a> pour <code>Array.prototype.find()</code> vous permet d'√©quiper tous les tableaux avec la m√©thode <code>find()</code> .  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill</a> pour <code>Array.prototype.findIndex()</code> fonctionne de la m√™me mani√®re: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-string"><span class="hljs-string">"E"</span></span>]; arr.indexOf(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">H√©ritage unique</font> </h2><br>  La commande <code>Object.create()</code> vous permet de cr√©er de nouveaux objets avec un objet prototype donn√©.  Cette commande est utilis√©e en JavaScript pour impl√©menter un m√©canisme d'h√©ritage unique.  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookPrototype = { <span class="hljs-attr"><span class="hljs-attr">getFullTitle</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title + <span class="hljs-string"><span class="hljs-string">" by "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.author; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(bookPrototype); book.title = <span class="hljs-string"><span class="hljs-string">"JavaScript: The Good Parts"</span></span>; book.author = <span class="hljs-string"><span class="hljs-string">"Douglas Crockford"</span></span>; book.getFullTitle();<span class="hljs-comment"><span class="hljs-comment">//JavaScript: The Good Parts by Douglas Crockford</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">H√©ritage multiple</font> </h2><br>  La commande <code>Object.assign()</code> copie les propri√©t√©s d'un ou plusieurs objets vers l'objet cible.  Il peut √™tre utilis√© pour impl√©menter plusieurs sch√©mas d'h√©ritage.  Voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authorDataService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookDataService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userDataService = { <span class="hljs-attr"><span class="hljs-attr">getUsers</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, authorDataService, bookDataService, userDataService ); dataService.getAuthors(); dataService.getBooks(); dataService.getUsers();</code> </pre> <br><h2>  <font color="#3AC1EF">Objets immuables</font> </h2><br>  La commande <code>Object.freeze()</code> vous permet de ¬´figer¬ª un objet.  Vous ne pouvez pas ajouter de nouvelles propri√©t√©s √† un tel objet.  Les propri√©t√©s ne peuvent pas √™tre supprim√©es et leurs valeurs ne peuvent pas √™tre modifi√©es.  En utilisant cette commande, un objet devient immuable ou immuable: <br><br><pre> <code class="hljs pgsql">"use strict"; let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "Functional-Light JavaScript", author : "Kyle Simpson" }); book.title = "Other title";//: Cannot assign <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> property <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br>  La commande <code>Object.freeze()</code> effectue la soi-disant ¬´cong√©lation superficielle¬ª des objets.  Cela signifie que les objets imbriqu√©s dans un objet ¬´fig√©¬ª peuvent √™tre modifi√©s.  Pour effectuer un ¬´gel profond¬ª d'un objet, vous devez ¬´geler¬ª r√©cursivement toutes ses propri√©t√©s. <br><br><h2>  <font color="#3AC1EF">Clonage d'objets</font> </h2><br>  Pour cr√©er des clones (copies) d'objets, vous pouvez utiliser la commande <code>Object.assign()</code> : <br><br><pre> <code class="hljs pgsql">let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "JavaScript Allong√©", author : "Reginald Braithwaite" }); let clone = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.assign({}, book);</code> </pre> <br>  Cette commande effectue une copie superficielle des objets, c'est-√†-dire qu'elle copie uniquement les propri√©t√©s de niveau sup√©rieur.  Les objets imbriqu√©s s'av√®rent courants pour les objets originaux et leurs copies. <br><br><h2>  <font color="#3AC1EF">Litt√©ral d'objet</font> </h2><br>  Les litt√©raux d'objets offrent aux d√©veloppeurs un moyen simple et direct de cr√©er des objets: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span> : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, }</code> </pre> <br>  Cependant, cette m√©thode de cr√©ation d'objets pr√©sente des inconv√©nients.  En particulier, avec cette approche, toutes les propri√©t√©s de l'objet sont accessibles au public, les m√©thodes de l'objet peuvent √™tre red√©finies, elles ne peuvent pas √™tre utilis√©es pour cr√©er de nouvelles instances des m√™mes objets: <br><br><pre> <code class="hljs pgsql">timer.fn;//<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> timer.start = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { console.log("New implementation"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Object.create (), m√©thode</font> </h2><br>  Les deux probl√®mes mentionn√©s ci-dessus peuvent √™tre r√©solus gr√¢ce √† l'utilisation conjointe des m√©thodes <code>Object.create()</code> et <code>Object.freeze()</code> . <br><br>  Nous appliquons cette technique √† notre exemple pr√©c√©dent.  Tout d'abord, cr√©ez un prototype <code>timerPrototype</code> qui contient toutes les m√©thodes n√©cessaires aux diff√©rentes instances de l'objet.  Apr√®s cela, cr√©ez un objet qui succ√®de √† <code>timerPrototype</code> : <br><br><pre> <code class="hljs pgsql">let timerPrototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} }); let timer = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(timerPrototype); timer.__proto__ === timerPrototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Si le prototype est prot√©g√© contre les modifications, l'objet qui est son h√©ritier ne pourra pas modifier les propri√©t√©s d√©finies dans le prototype.  D√©sormais, les m√©thodes <code>start()</code> et <code>stop()</code> ne peuvent pas √™tre remplac√©es: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; timer.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"New implementation"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//: Cannot assign to read only property 'start' of object</span></span></code> </pre> <br>  La construction <code>Object.create(timerPrototype)</code> peut √™tre utilis√©e pour cr√©er plusieurs objets avec le m√™me prototype. <br><br><h2>  <font color="#3AC1EF">Fonction constructeur</font> </h2><br>  JavaScript poss√®de des fonctions dites de constructeur, qui sont du ¬´sucre syntaxique¬ª pour effectuer les √©tapes ci-dessus pour cr√©er de nouveaux objets.  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; } Timer.prototype = { <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTodos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(getTodos);</code> </pre> <br>  Vous pouvez utiliser n'importe quelle fonction en tant que constructeur.  Le constructeur est appel√© √† l'aide du <code>new</code> mot cl√©.  Un objet cr√©√© √† l'aide d'une fonction constructeur nomm√©e <code>FunctionConstructor</code> recevra un prototype <code>FunctionConstructor.prototype</code> : <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Ici, pour emp√™cher une modification du prototype, encore une fois, vous pouvez geler le prototype: <br><br><pre> <code class="hljs pgsql">Timer.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} });</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Mot-cl√© nouveau</font> </h3><br>  Lorsqu'une commande de la forme <code>new Timer()</code> est ex√©cut√©e, les m√™mes actions sont effectu√©es que la fonction <code>newTimer()</code> effectue ci-dessous: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Timer.prototype); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> returnObj = Timer.call(newObj, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(returnObj) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnObj;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newObj; }</code> </pre> <br>  Un nouvel objet est cr√©√© ici, dont le prototype est <code>Timer.prototype</code> .  Ensuite, la fonction <code>Timer</code> est appel√©e, d√©finissant les champs du nouvel objet. <br><br><h2>  <font color="#3AC1EF">Mot-cl√© de classe</font> </h2><br>  ECMAScript 2015 a introduit une nouvelle fa√ßon d'effectuer les actions ci-dessus, qui est un autre lot de ¬´sucre syntaxique¬ª.  Nous parlons du mot-cl√© <code>class</code> et des constructions associ√©es qui lui sont associ√©es.  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Timer{ constructor(callback){   this.fn = callback; } <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {} stop() {} } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br>  Un objet cr√©√© √† l'aide du mot <code>class</code> cl√© <code>class</code> bas√© sur une classe nomm√©e <code>ClassName</code> aura le prototype <code>ClassName.prototype</code> .  Lors de la cr√©ation d'un objet bas√© sur une classe, utilisez le <code>new</code> mot-cl√©: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  L'utilisation de classes ne rend pas les prototypes immuables.  Si n√©cessaire, ils devront √™tre ¬´gel√©s¬ª de la m√™me mani√®re que nous l'avons d√©j√† fait: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br><h2>  <font color="#3AC1EF">H√©ritage bas√© sur un prototype</font> </h2><br>  En JavaScript, les objets h√©ritent des propri√©t√©s et des m√©thodes des autres objets.  Les fonctions et classes constructeurs sont des ¬´sucres syntaxiques¬ª pour cr√©er des objets prototypes contenant toutes les m√©thodes n√©cessaires.  En les utilisant, de nouveaux objets sont cr√©√©s qui sont les h√©ritiers du prototype, dont les propri√©t√©s, sp√©cifiques √† une instance particuli√®re, sont d√©finies √† l'aide de la fonction constructeur ou √† l'aide des m√©canismes de classe. <br><br>  Ce serait bien si les fonctions et les classes constructeurs pouvaient automatiquement rendre les prototypes immuables. <br><br>  Les atouts de l'h√©ritage de prototype sont les √©conomies de m√©moire.  Le fait est qu'un prototype n'est cr√©√© qu'une seule fois, apr√®s quoi tous les objets cr√©√©s sur sa base l'utilisent. <br><br><h3>  <font color="#3AC1EF">‚ñç Le probl√®me du manque de m√©canismes d'encapsulation int√©gr√©s</font> </h3><br>  Le mod√®le d'h√©ritage prototype n'utilise pas la s√©paration des propri√©t√©s des objets entre priv√© et public.  Toutes les propri√©t√©s des objets sont accessibles au public. <br><br>  Par exemple, la commande <code>Object.keys()</code> renvoie un tableau contenant toutes les cl√©s de propri√©t√© de l'objet.  Il peut √™tre utilis√© pour parcourir toutes les propri√©t√©s d'un objet: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //  } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br>  Il existe un mod√®le qui imite les propri√©t√©s priv√©es, en s'appuyant sur le fait que les d√©veloppeurs n'acc√©deront pas aux propri√©t√©s dont les noms commencent par un trait de soulignement ( <code>_</code> ): <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(callback){   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fn = callback;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._timerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><h2>  <font color="#3AC1EF">Caract√©ristiques d'usine</font> </h2><br>  Les objets encapsul√©s en JavaScript peuvent √™tre cr√©√©s √† l'aide des fonctions d'usine.  Cela ressemble √† ceci: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TodoStore(callback){   let fn = callback;     <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {},   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> stop() {}     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,      stop   }); }</code> </pre> <br>  Ici, la variable <code>fn</code> est priv√©e.  Seules les m√©thodes <code>start()</code> et <code>stop()</code> sont accessibles au public.  Ces m√©thodes ne peuvent pas √™tre modifi√©es en externe.  Le mot-cl√© this n'est pas utilis√© ici, par cons√©quent, lorsque vous utilisez cette m√©thode de cr√©ation d'objets, le probl√®me de la perte de <code>this</code> contexte n'est pas pertinent. <br><br>  La commande <code>return</code> utilise un litt√©ral objet contenant uniquement des fonctions.  De plus, ces fonctions sont d√©clar√©es en cl√¥ture, elles partagent un √©tat commun.  Pour figer une API publique d'un objet, la commande <code>Object.freeze()</code> d√©j√† connue est <code>Object.freeze()</code> . <br><br>  Ici, dans les exemples, nous avons utilis√© l'objet <code>Timer</code> .  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> document, vous pouvez trouver sa mise en ≈ìuvre compl√®te. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  En JavaScript, les valeurs des types primitifs, des objets ordinaires et des fonctions sont trait√©es comme des objets.  Les objets ont un caract√®re dynamique, ils peuvent √™tre utilis√©s comme des tableaux associatifs.  Les objets sont des h√©ritiers d'autres objets.  Les fonctions et classes constructeurs sont des ¬´sucres syntaxiques¬ª, elles vous permettent de cr√©er des objets √† partir de prototypes.  Vous pouvez utiliser la m√©thode <code>Object.create()</code> pour organiser l'h√©ritage unique et <code>Object.create()</code> pour organiser l'h√©ritage multiple.  Vous pouvez utiliser les fonctions d'usine pour cr√©er des objets encapsul√©s. <br><br>  <b>Chers lecteurs!</b>  Si vous √™tes arriv√© √† JavaScript √† partir d'autres langues, veuillez nous dire ce que vous aimez ou n'aimez pas dans les objets JS, par rapport √† la mise en ≈ìuvre d'objets dans des langues que vous connaissez d√©j√†. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420615/">https://habr.com/ru/post/fr420615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420605/index.html">Pr√©sentation de l'algorithme d'entretien d'embauche - G√©n√©ration de jeu</a></li>
<li><a href="../fr420607/index.html">√âv√©nements num√©riques √† Moscou du 20 au 26 ao√ªt</a></li>
<li><a href="../fr420609/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 327 (13-19 ao√ªt 2018)</a></li>
<li><a href="../fr420611/index.html">Mod√©lisation de l'intrication quantique en C #</a></li>
<li><a href="../fr420613/index.html">11 biblioth√®ques (ensembles de composants) pour React Native que vous devriez conna√Ætre en 2018</a></li>
<li><a href="../fr420617/index.html">Guide de conception Web pour les d√©veloppeurs</a></li>
<li><a href="../fr420619/index.html">Images r√©actives: astuces CSS qui font gagner du temps</a></li>
<li><a href="../fr420623/index.html">Applications C ++ distribu√©es avec un minimum d'effort</a></li>
<li><a href="../fr420625/index.html">KDD 2018, Day One, tutoriels</a></li>
<li><a href="../fr420627/index.html">Programmation asynchrone C #: Comment faites-vous avec les performances?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>