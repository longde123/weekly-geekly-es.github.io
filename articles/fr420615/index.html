<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍗 👩🏿 🏇🏻 JavaScript: explorer des objets ☯️ 👨🏾‍🤝‍👨🏼 🈂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le matériel, dont nous publions la traduction aujourd'hui, est consacré à l'étude des objets - l'une des essences clés de JavaScript. Il est conçu pri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript: explorer des objets</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420615/">  Le matériel, dont nous publions la traduction aujourd'hui, est consacré à l'étude des objets - l'une des essences clés de JavaScript.  Il est conçu principalement pour les développeurs débutants qui souhaitent rationaliser leurs connaissances des objets. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/vo/lg/xb/volgxbgclrhdnqvvi_qdqfc1yna.jpeg"></a> <br><br>  Les objets en JavaScript sont des collections dynamiques de propriétés qui, en outre, contiennent une propriété «cachée» qui est un prototype de l'objet.  Les propriétés des objets sont caractérisées par des clés et des valeurs.  Commençons la conversation sur les objets JS avec des clés. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Clés de propriété d'objet</font> </h2><br>  La clé de propriété d'objet est une chaîne unique.  Vous pouvez utiliser deux méthodes pour accéder aux propriétés: y accéder via un point et spécifier la clé d'objet entre crochets.  Lors de l'accès aux propriétés via un point, la clé doit être un identifiant JavaScript valide.  Prenons un exemple: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> obj = {  <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span> } obj.message //<span class="hljs-string"><span class="hljs-string">"A message"</span></span> obj[<span class="hljs-string"><span class="hljs-string">"message"</span></span>] //<span class="hljs-string"><span class="hljs-string">"A message"</span></span></code> </pre> <br>  Lorsque vous essayez d'accéder à une propriété inexistante d'un objet, un message d'erreur n'apparaîtra pas, mais la valeur <code>undefined</code> sera retournée: <br><br><pre> <code class="hljs objectivec">obj.otherProperty <span class="hljs-comment"><span class="hljs-comment">//undefined</span></span></code> </pre> <br>  Lorsque vous utilisez des crochets pour accéder aux propriétés, vous pouvez utiliser des clés qui ne sont pas des identificateurs JavaScript valides (par exemple, la clé peut être une chaîne contenant des espaces).  Ils peuvent avoir n'importe quelle valeur pouvant être convertie en chaîne: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> french = {}; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>] = <span class="hljs-string"><span class="hljs-string">"thank you very much"</span></span>; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//"thank you very much"</span></span></code> </pre> <br>  Si des valeurs non-chaîne sont utilisées comme clés, elles sont automatiquement converties en chaînes (en utilisant, si possible, la <code>toString()</code> ): <br><br><pre> <code class="hljs powershell">et obj = {}; //Number obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"Number 1"</span></span>; obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true //Object let number1 = { toString : function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } } obj[<span class="hljs-type"><span class="hljs-type">number1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true</code> </pre> <br>  Dans cet exemple, l'objet <code>number1</code> est utilisé comme clé.  Lorsque vous essayez d'accéder à une propriété, elle est convertie en ligne <code>1</code> et le résultat de cette conversion est utilisé comme clé. <br><br><h2>  <font color="#3AC1EF">Valeurs des propriétés d'objet</font> </h2><br>  Les propriétés d'objet peuvent être des valeurs primitives, des objets ou des fonctions. <br><br><h3>  <font color="#3AC1EF">▍Objet en tant que valeur de propriété d'objet</font> </h3><br>  Les objets peuvent être placés dans d'autres objets.  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = { title : <span class="hljs-string"><span class="hljs-string">"The Good Parts"</span></span>, author : {   firstName : <span class="hljs-string"><span class="hljs-string">"Douglas"</span></span>,   lastName : <span class="hljs-string"><span class="hljs-string">"Crockford"</span></span> } } book.author.firstName; <span class="hljs-comment"><span class="hljs-comment">//"Douglas"</span></span></code> </pre> <br>  Une approche similaire peut être utilisée pour créer des espaces de noms: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> app = {}; app.authorService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; app.bookService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} };</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Fonction en tant que valeur de propriété d'objet</font> </h3><br>  Lorsqu'une fonction est utilisée comme valeur de propriété d'objet, elle devient généralement une méthode d'objet.  Dans la méthode, pour accéder à l'objet courant, utilisez le <code>this</code> . <br><br>  Cependant, ce mot clé peut avoir différentes significations, selon la façon dont la fonction a été appelée.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez lire des situations dans lesquelles <code>this</code> perd le contexte. <br><br><h2>  <font color="#3AC1EF">La nature dynamique des objets</font> </h2><br>  Les objets en JavaScript, de par leur nature, sont des entités dynamiques.  Vous pouvez leur ajouter des propriétés à tout moment, il en va de même pour la suppression des propriétés: <br><br><pre> <code class="hljs ruby">let obj = {}; obj.message = <span class="hljs-string"><span class="hljs-string">"This is a message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   obj.otherMessage = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    delete obj.otherMessage; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> </code> </pre> <br><h2>  <font color="#3AC1EF">Objets en tant que tableaux associatifs</font> </h2><br>  Les objets peuvent être considérés comme des tableaux associatifs.  Les clés de tableau associatif sont les noms de propriété de l'objet.  Pour accéder à la clé, vous n'avez pas besoin de regarder toutes les propriétés, c'est-à-dire que l'opération d'accès à la clé d'un tableau associatif basé sur un objet s'effectue en temps O (1). <br><br><h2>  <font color="#3AC1EF">Prototypes d'objets</font> </h2><br>  Les objets ont un lien «caché», <code>__proto__</code> , pointant vers un objet prototype dont l'objet hérite des propriétés. <br><br>  Par exemple, un objet créé à l'aide d'un littéral d'objet a un lien vers <code>Object.prototype</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; obj.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype; <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Objets vides</font> </h3><br>  Comme nous venons de le voir, l'objet "vide", <code>{}</code> , n'est en fait pas si vide, car il contient une référence à <code>Object.prototype</code> .  Pour créer un objet vraiment vide, vous devez utiliser la construction suivante: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre> <br>  Grâce à cela, un objet sans prototype sera créé.  Ces objets sont généralement utilisés pour créer des tableaux associatifs. <br><br><h3>  <font color="#3AC1EF">▍ Chaîne prototype</font> </h3><br>  Les objets prototypes peuvent avoir leurs propres prototypes.  Si vous essayez d'accéder à une propriété d'un objet qui n'y est pas, JavaScript essaiera de trouver cette propriété dans le prototype de cet objet, et si la propriété souhaitée n'est pas là, une tentative sera faite pour la trouver dans le prototype du prototype.  Cela continuera jusqu'à ce que la propriété souhaitée soit trouvée ou jusqu'à ce que la fin de la chaîne de prototype soit atteinte. <br><br><h2>  <font color="#3AC1EF">Valeurs de type primitif et wrappers d'objets</font> </h2><br>  JavaScript vous permet de travailler avec les valeurs des types primitifs en tant qu'objets, dans le sens où le langage vous permet d'accéder à leurs propriétés et méthodes. <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span> <span class="hljs-string"><span class="hljs-string">"text"</span></span>.toUpperCase(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"TEXT"</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>.toString(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  De plus, bien sûr, les valeurs des types primitifs ne sont pas des objets. <br><br>  Pour organiser l'accès aux «propriétés» des valeurs des types primitifs, JavaScript, si nécessaire, crée des objets wrapper qui, une fois devenus inutiles, sont détruits.  Le processus de création et de destruction d'objets wrapper est optimisé par le moteur JS. <br><br>  Les wrappers d'objets ont des valeurs de type numérique, chaîne et logique.  Les objets des types correspondants sont représentés par les fonctions constructeur <code>Number</code> , <code>String</code> et <code>Boolean</code> . <br><br><h2>  <font color="#3AC1EF">Prototypes intégrés</font> </h2><br>  Les objets numériques héritent des propriétés et des méthodes du prototype <code>Number.prototype</code> , qui est le descendant de <code>Object.prototype</code> : <br><br><pre> <code class="hljs pgsql">var <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__ === Number.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__.__proto__ === <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Le prototype des objets chaîne est <code>String.prototype</code> .  Le prototype des objets booléens est <code>Boolean.prototype</code> .  Le prototype des tableaux (qui sont également des objets) est <code>Array.prototype</code> . <br><br>  Les fonctions en JavaScript sont également des objets qui ont un prototype <code>Function.prototype</code> .  Les fonctions ont des méthodes comme <code>bind()</code> , <code>apply()</code> et <code>call()</code> . <br><br>  Tous les objets, fonctions et objets représentant des valeurs de type primitif (à l'exception des valeurs <code>null</code> et <code>undefined</code> ) héritent des propriétés et des méthodes de <code>Object.prototype</code> .  Cela conduit au fait que, par exemple, ils ont tous une <code>toString()</code> . <br><br><h2>  <font color="#3AC1EF">Extension d'objets incorporés avec des polyfills</font> </h2><br>  JavaScript facilite l'extension des objets intégrés avec de nouvelles fonctionnalités à l'aide de ce que l'on appelle les polyfills.  Un polyfill est un morceau de code qui implémente des fonctionnalités qui ne sont prises en charge par aucun navigateur. <br><br><h3>  <font color="#3AC1EF">▍Utilisation de polyfills</font> </h3><br>  Par exemple, il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill</a> pour la méthode <code>Object.assign()</code> .  Il vous permet d'ajouter une nouvelle fonction à <code>Object</code> si elle n'y est pas disponible. <br><br>  Il en va de même pour le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill</a> <code>Array.from()</code> qui, si la méthode <code>from()</code> n'est pas dans l'objet <code>Array</code> , l'équipe de cette méthode. <br><br><h3>  <font color="#3AC1EF">▍ Polyfill et prototypes</font> </h3><br>  À l'aide de polyfills, de nouvelles méthodes peuvent être ajoutées aux prototypes d'objets.  Par exemple, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill</a> pour <code>String.prototype.trim()</code> vous permet d'équiper tous les objets chaîne avec la méthode <code>trim()</code> : <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = "   A text "; <span class="hljs-type"><span class="hljs-type">text</span></span>.trim(); //"A text"</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le polyfill</a> pour <code>Array.prototype.find()</code> vous permet d'équiper tous les tableaux avec la méthode <code>find()</code> .  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill</a> pour <code>Array.prototype.findIndex()</code> fonctionne de la même manière: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-string"><span class="hljs-string">"E"</span></span>]; arr.indexOf(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Héritage unique</font> </h2><br>  La commande <code>Object.create()</code> vous permet de créer de nouveaux objets avec un objet prototype donné.  Cette commande est utilisée en JavaScript pour implémenter un mécanisme d'héritage unique.  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookPrototype = { <span class="hljs-attr"><span class="hljs-attr">getFullTitle</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title + <span class="hljs-string"><span class="hljs-string">" by "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.author; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(bookPrototype); book.title = <span class="hljs-string"><span class="hljs-string">"JavaScript: The Good Parts"</span></span>; book.author = <span class="hljs-string"><span class="hljs-string">"Douglas Crockford"</span></span>; book.getFullTitle();<span class="hljs-comment"><span class="hljs-comment">//JavaScript: The Good Parts by Douglas Crockford</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Héritage multiple</font> </h2><br>  La commande <code>Object.assign()</code> copie les propriétés d'un ou plusieurs objets vers l'objet cible.  Il peut être utilisé pour implémenter plusieurs schémas d'héritage.  Voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authorDataService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookDataService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userDataService = { <span class="hljs-attr"><span class="hljs-attr">getUsers</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, authorDataService, bookDataService, userDataService ); dataService.getAuthors(); dataService.getBooks(); dataService.getUsers();</code> </pre> <br><h2>  <font color="#3AC1EF">Objets immuables</font> </h2><br>  La commande <code>Object.freeze()</code> vous permet de «figer» un objet.  Vous ne pouvez pas ajouter de nouvelles propriétés à un tel objet.  Les propriétés ne peuvent pas être supprimées et leurs valeurs ne peuvent pas être modifiées.  En utilisant cette commande, un objet devient immuable ou immuable: <br><br><pre> <code class="hljs pgsql">"use strict"; let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "Functional-Light JavaScript", author : "Kyle Simpson" }); book.title = "Other title";//: Cannot assign <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> property <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br>  La commande <code>Object.freeze()</code> effectue la soi-disant «congélation superficielle» des objets.  Cela signifie que les objets imbriqués dans un objet «figé» peuvent être modifiés.  Pour effectuer un «gel profond» d'un objet, vous devez «geler» récursivement toutes ses propriétés. <br><br><h2>  <font color="#3AC1EF">Clonage d'objets</font> </h2><br>  Pour créer des clones (copies) d'objets, vous pouvez utiliser la commande <code>Object.assign()</code> : <br><br><pre> <code class="hljs pgsql">let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "JavaScript Allongé", author : "Reginald Braithwaite" }); let clone = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.assign({}, book);</code> </pre> <br>  Cette commande effectue une copie superficielle des objets, c'est-à-dire qu'elle copie uniquement les propriétés de niveau supérieur.  Les objets imbriqués s'avèrent courants pour les objets originaux et leurs copies. <br><br><h2>  <font color="#3AC1EF">Littéral d'objet</font> </h2><br>  Les littéraux d'objets offrent aux développeurs un moyen simple et direct de créer des objets: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span> : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, }</code> </pre> <br>  Cependant, cette méthode de création d'objets présente des inconvénients.  En particulier, avec cette approche, toutes les propriétés de l'objet sont accessibles au public, les méthodes de l'objet peuvent être redéfinies, elles ne peuvent pas être utilisées pour créer de nouvelles instances des mêmes objets: <br><br><pre> <code class="hljs pgsql">timer.fn;//<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> timer.start = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { console.log("New implementation"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Object.create (), méthode</font> </h2><br>  Les deux problèmes mentionnés ci-dessus peuvent être résolus grâce à l'utilisation conjointe des méthodes <code>Object.create()</code> et <code>Object.freeze()</code> . <br><br>  Nous appliquons cette technique à notre exemple précédent.  Tout d'abord, créez un prototype <code>timerPrototype</code> qui contient toutes les méthodes nécessaires aux différentes instances de l'objet.  Après cela, créez un objet qui succède à <code>timerPrototype</code> : <br><br><pre> <code class="hljs pgsql">let timerPrototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} }); let timer = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(timerPrototype); timer.__proto__ === timerPrototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Si le prototype est protégé contre les modifications, l'objet qui est son héritier ne pourra pas modifier les propriétés définies dans le prototype.  Désormais, les méthodes <code>start()</code> et <code>stop()</code> ne peuvent pas être remplacées: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; timer.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"New implementation"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//: Cannot assign to read only property 'start' of object</span></span></code> </pre> <br>  La construction <code>Object.create(timerPrototype)</code> peut être utilisée pour créer plusieurs objets avec le même prototype. <br><br><h2>  <font color="#3AC1EF">Fonction constructeur</font> </h2><br>  JavaScript possède des fonctions dites de constructeur, qui sont du «sucre syntaxique» pour effectuer les étapes ci-dessus pour créer de nouveaux objets.  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; } Timer.prototype = { <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTodos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(getTodos);</code> </pre> <br>  Vous pouvez utiliser n'importe quelle fonction en tant que constructeur.  Le constructeur est appelé à l'aide du <code>new</code> mot clé.  Un objet créé à l'aide d'une fonction constructeur nommée <code>FunctionConstructor</code> recevra un prototype <code>FunctionConstructor.prototype</code> : <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Ici, pour empêcher une modification du prototype, encore une fois, vous pouvez geler le prototype: <br><br><pre> <code class="hljs pgsql">Timer.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} });</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Mot-clé nouveau</font> </h3><br>  Lorsqu'une commande de la forme <code>new Timer()</code> est exécutée, les mêmes actions sont effectuées que la fonction <code>newTimer()</code> effectue ci-dessous: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Timer.prototype); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> returnObj = Timer.call(newObj, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(returnObj) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnObj;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newObj; }</code> </pre> <br>  Un nouvel objet est créé ici, dont le prototype est <code>Timer.prototype</code> .  Ensuite, la fonction <code>Timer</code> est appelée, définissant les champs du nouvel objet. <br><br><h2>  <font color="#3AC1EF">Mot-clé de classe</font> </h2><br>  ECMAScript 2015 a introduit une nouvelle façon d'effectuer les actions ci-dessus, qui est un autre lot de «sucre syntaxique».  Nous parlons du mot-clé <code>class</code> et des constructions associées qui lui sont associées.  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Timer{ constructor(callback){   this.fn = callback; } <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {} stop() {} } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br>  Un objet créé à l'aide du mot <code>class</code> clé <code>class</code> basé sur une classe nommée <code>ClassName</code> aura le prototype <code>ClassName.prototype</code> .  Lors de la création d'un objet basé sur une classe, utilisez le <code>new</code> mot-clé: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  L'utilisation de classes ne rend pas les prototypes immuables.  Si nécessaire, ils devront être «gelés» de la même manière que nous l'avons déjà fait: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br><h2>  <font color="#3AC1EF">Héritage basé sur un prototype</font> </h2><br>  En JavaScript, les objets héritent des propriétés et des méthodes des autres objets.  Les fonctions et classes constructeurs sont des «sucres syntaxiques» pour créer des objets prototypes contenant toutes les méthodes nécessaires.  En les utilisant, de nouveaux objets sont créés qui sont les héritiers du prototype, dont les propriétés, spécifiques à une instance particulière, sont définies à l'aide de la fonction constructeur ou à l'aide des mécanismes de classe. <br><br>  Ce serait bien si les fonctions et les classes constructeurs pouvaient automatiquement rendre les prototypes immuables. <br><br>  Les atouts de l'héritage de prototype sont les économies de mémoire.  Le fait est qu'un prototype n'est créé qu'une seule fois, après quoi tous les objets créés sur sa base l'utilisent. <br><br><h3>  <font color="#3AC1EF">▍ Le problème du manque de mécanismes d'encapsulation intégrés</font> </h3><br>  Le modèle d'héritage prototype n'utilise pas la séparation des propriétés des objets entre privé et public.  Toutes les propriétés des objets sont accessibles au public. <br><br>  Par exemple, la commande <code>Object.keys()</code> renvoie un tableau contenant toutes les clés de propriété de l'objet.  Il peut être utilisé pour parcourir toutes les propriétés d'un objet: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //  } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br>  Il existe un modèle qui imite les propriétés privées, en s'appuyant sur le fait que les développeurs n'accéderont pas aux propriétés dont les noms commencent par un trait de soulignement ( <code>_</code> ): <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(callback){   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fn = callback;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._timerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><h2>  <font color="#3AC1EF">Caractéristiques d'usine</font> </h2><br>  Les objets encapsulés en JavaScript peuvent être créés à l'aide des fonctions d'usine.  Cela ressemble à ceci: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TodoStore(callback){   let fn = callback;     <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {},   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> stop() {}     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,      stop   }); }</code> </pre> <br>  Ici, la variable <code>fn</code> est privée.  Seules les méthodes <code>start()</code> et <code>stop()</code> sont accessibles au public.  Ces méthodes ne peuvent pas être modifiées en externe.  Le mot-clé this n'est pas utilisé ici, par conséquent, lorsque vous utilisez cette méthode de création d'objets, le problème de la perte de <code>this</code> contexte n'est pas pertinent. <br><br>  La commande <code>return</code> utilise un littéral objet contenant uniquement des fonctions.  De plus, ces fonctions sont déclarées en clôture, elles partagent un état commun.  Pour figer une API publique d'un objet, la commande <code>Object.freeze()</code> déjà connue est <code>Object.freeze()</code> . <br><br>  Ici, dans les exemples, nous avons utilisé l'objet <code>Timer</code> .  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> document, vous pouvez trouver sa mise en œuvre complète. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  En JavaScript, les valeurs des types primitifs, des objets ordinaires et des fonctions sont traitées comme des objets.  Les objets ont un caractère dynamique, ils peuvent être utilisés comme des tableaux associatifs.  Les objets sont des héritiers d'autres objets.  Les fonctions et classes constructeurs sont des «sucres syntaxiques», elles vous permettent de créer des objets à partir de prototypes.  Vous pouvez utiliser la méthode <code>Object.create()</code> pour organiser l'héritage unique et <code>Object.create()</code> pour organiser l'héritage multiple.  Vous pouvez utiliser les fonctions d'usine pour créer des objets encapsulés. <br><br>  <b>Chers lecteurs!</b>  Si vous êtes arrivé à JavaScript à partir d'autres langues, veuillez nous dire ce que vous aimez ou n'aimez pas dans les objets JS, par rapport à la mise en œuvre d'objets dans des langues que vous connaissez déjà. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420615/">https://habr.com/ru/post/fr420615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420605/index.html">Présentation de l'algorithme d'entretien d'embauche - Génération de jeu</a></li>
<li><a href="../fr420607/index.html">Événements numériques à Moscou du 20 au 26 août</a></li>
<li><a href="../fr420609/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 327 (13-19 août 2018)</a></li>
<li><a href="../fr420611/index.html">Modélisation de l'intrication quantique en C #</a></li>
<li><a href="../fr420613/index.html">11 bibliothèques (ensembles de composants) pour React Native que vous devriez connaître en 2018</a></li>
<li><a href="../fr420617/index.html">Guide de conception Web pour les développeurs</a></li>
<li><a href="../fr420619/index.html">Images réactives: astuces CSS qui font gagner du temps</a></li>
<li><a href="../fr420623/index.html">Applications C ++ distribuées avec un minimum d'effort</a></li>
<li><a href="../fr420625/index.html">KDD 2018, Day One, tutoriels</a></li>
<li><a href="../fr420627/index.html">Programmation asynchrone C #: Comment faites-vous avec les performances?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>