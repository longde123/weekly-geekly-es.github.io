<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📕 😅 😍 Komponen Terpencil Zen dalam Arsitektur Android 🙅🏼 👩‍👩‍👧 😜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa tahun yang lalu, kami di Badoo mulai menggunakan pendekatan MVI untuk pengembangan Android. Itu dimaksudkan untuk menyederhanakan basis kode ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Komponen Terpencil Zen dalam Arsitektur Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/463781/"><img src="https://habrastorage.org/webt/0f/iz/h0/0fizh0eukxdsz6kb0zxcjiw5878.jpeg"><br><br>  Beberapa tahun yang lalu, kami di Badoo mulai menggunakan pendekatan MVI untuk pengembangan Android.  Itu dimaksudkan untuk menyederhanakan basis kode yang kompleks dan menghindari masalah status yang salah: dalam skenario sederhana itu mudah, tetapi semakin kompleks sistem, semakin sulit untuk mempertahankannya dalam bentuk yang benar dan semakin mudah untuk melewatkan bug. <br><br>  Di Badoo, semua aplikasi tidak sinkron - tidak hanya karena fungsionalitas luas yang tersedia bagi pengguna melalui UI, tetapi juga karena kemungkinan pengiriman data satu arah oleh server.  Dengan menggunakan pendekatan lama dalam modul obrolan kami, kami menemukan beberapa bug aneh yang sulit direproduksi, yang harus kami habiskan cukup banyak waktu untuk menghilangkannya. <br><br>  Rekan kami Zsolt Kocsi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Medium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a> ) dari kantor London memberi tahu bagaimana menggunakan MVI kami membangun komponen independen yang mudah digunakan kembali, keuntungan apa yang kami dapatkan dan kerugian apa yang kami temui saat menggunakan pendekatan ini. <a name="habracut"></a><br><br>  Ini adalah artikel ketiga dari serangkaian artikel tentang arsitektur Android Badoo.  Tautan ke dua yang pertama: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur MVI modern berdasarkan pada Kotlin</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membangun sistem komponen reaktif dengan Kotlin</a> . <br></li></ol><br><h2>  Jangan memikirkan komponen yang tidak terhubung dengan baik. </h2><br>  Konektivitas yang lemah dianggap lebih baik daripada kuat.  Jika Anda hanya mengandalkan antarmuka dan bukan pada implementasi spesifik, maka akan lebih mudah bagi Anda untuk mengganti komponen, lebih mudah untuk beralih ke implementasi lain tanpa menulis ulang sebagian besar kode, yang menyederhanakan termasuk pengujian unit. <br><br>  Kami biasanya berakhir di sini dan mengatakan bahwa kami telah melakukan segala hal yang mungkin dalam hal konektivitas. <br><br>  Namun, pendekatan ini tidak optimal.  Misalkan Anda memiliki kelas A yang perlu menggunakan kemampuan tiga kelas lain: B, C dan D. Bahkan jika Anda merujuk mereka melalui antarmuka, kelas A semakin sulit dengan masing-masing kelas ini: <br><br><ul><li>  dia tahu semua metode di semua antarmuka, nama dan tipe pengembaliannya, bahkan jika dia tidak menggunakannya; <br></li><li>  saat menguji A, Anda perlu mengonfigurasi lebih banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tiruan</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek tiruan</a> ); <br></li><li>  lebih sulit untuk menggunakan A berulang kali dalam konteks lain di mana kita tidak memiliki atau tidak ingin memiliki B, C, dan D. <br></li></ul><br>  Tentu saja, justru kelas A yang harus menentukan set minimum antarmuka yang diperlukan untuk itu (prinsip pemisahan antarmuka dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SOLID</a> ).  Namun, dalam praktiknya, kita semua harus berurusan dengan situasi di mana, demi kenyamanan, pendekatan yang berbeda diambil: kami mengambil kelas yang sudah ada yang mengimplementasikan beberapa fungsi, mengekstraksi semua metode publiknya ke dalam antarmuka, dan kemudian menggunakan antarmuka ini di mana kelas yang disebutkan diperlukan.  Yaitu, antarmuka digunakan bukan atas dasar apa yang diperlukan komponen ini, tetapi atas dasar apa yang dapat ditawarkan komponen lain. <br><br>  Dengan pendekatan ini, situasi semakin memburuk dari waktu ke waktu.  Setiap kali kami menambahkan fungsionalitas baru, kelas kami ditautkan dalam web antarmuka baru yang perlu mereka ketahui.  Kelas tumbuh dalam ukuran, dan pengujian menjadi semakin sulit. <br><br>  Akibatnya, ketika Anda perlu menggunakannya dalam konteks yang berbeda, hampir tidak mungkin untuk memindahkan mereka tanpa semua kusut yang dengannya mereka terhubung, bahkan melalui antarmuka.  Anda dapat menggambar analogi: Anda ingin menggunakan pisang, dan itu ada di tangan monyet yang tergantung di pohon, sehingga sebagai hasilnya, di beban di pisang Anda akan mendapatkan seluruh bagian dari hutan.  Singkatnya, proses transfer membutuhkan banyak waktu, dan segera Anda mulai bertanya pada diri sendiri mengapa dalam praktiknya sangat sulit untuk menggunakan kembali kode. <br><br><h2>  Komponen Kotak Hitam </h2><br>  Jika kita ingin komponennya mudah dan dapat digunakan kembali, maka untuk ini kita tidak perlu tahu tentang dua hal: <br><br><ul><li>  tentang di mana lagi itu digunakan; <br></li><li>  tentang komponen lain yang tidak terkait dengan implementasi internal. <br></li></ul><br>  Alasannya jelas: jika Anda tidak tahu tentang dunia luar, maka Anda tidak akan terhubung dengannya. <br><br>  Apa yang benar-benar kita inginkan dari komponen: <br><br><ul><li>  mendefinisikan input (input) dan output (output) data sendiri; <br></li><li>  Jangan pikirkan dari mana data ini berasal atau ke mana ia pergi; <br></li><li>  itu harus swasembada sehingga kita tidak perlu tahu struktur internal komponen untuk penggunaannya. <br></li></ul><br>  Anda dapat mempertimbangkan komponen kotak hitam, atau sirkuit terpadu.  Dia memiliki kontak input dan output.  Anda menyoldernya - dan sirkuit mikro menjadi bagian dari sistem yang tidak diketahui olehnya. <br><br><img src="https://habrastorage.org/webt/ol/fy/04/olfy04qy7hmdfupiqifwqfx9jwa.jpeg"><br><br>  Sampai sekarang, diasumsikan bahwa kita berbicara tentang aliran data dua arah: jika kelas A membutuhkan sesuatu, ia mengekstrak metode melalui antarmuka B dan menerima hasilnya dalam bentuk nilai yang dikembalikan oleh fungsi. <br><br><img src="https://habrastorage.org/webt/yb/1s/4k/yb1s4ksgh4k3adpupkm9bkiiem0.png"><br><br>  Tapi kemudian A tahu tentang B, dan kami ingin menghindari ini. <br><br>  Tentu saja, skema semacam itu masuk akal untuk fitur implementasi tingkat rendah.  Tetapi jika kita membutuhkan komponen yang dapat digunakan kembali yang bekerja seperti kotak hitam mandiri, kita perlu memastikan bahwa itu tidak tahu apa-apa tentang antarmuka eksternal, nama metode, atau nilai pengembalian. <br><br><h2>  Kami beralih ke searah </h2><br>  Tetapi tanpa nama dan metode antarmuka, kami tidak dapat memanggil apa pun!  Yang tersisa adalah menggunakan aliran data searah, di mana kita hanya mendapatkan input dan menghasilkan output: <br><br><img src="https://habrastorage.org/webt/3p/zy/_m/3pzy_micni9yxdstnff6m3ilfxw.png"><br><br>  Pada awalnya, ini mungkin terlihat seperti batasan, tetapi solusi seperti itu memiliki banyak keuntungan, yang akan dibahas di bawah ini. <br><br>  Dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama</a> kita tahu bahwa fitur (Fitur) mendefinisikan data input mereka sendiri (Keinginan) dan data output mereka sendiri (Negara).  Oleh karena itu, tidak masalah bagi mereka dari mana Wish berasal atau ke mana Negara pergi. <br><br><img src="https://habrastorage.org/webt/aw/wn/c0/awwnc0nkjkhiedmyxd00ovtdhrw.png"><br><br>  Itu yang kita butuhkan!  Fitur dapat digunakan di mana pun Anda bisa memberi mereka input, dan dengan output Anda dapat melakukan apa pun yang Anda inginkan.  Dan karena fitur tidak berkomunikasi langsung dengan komponen lain, mereka adalah modul mandiri dan tidak terkait. <br><br>  Sekarang ambil View dan rancanglah sehingga itu juga merupakan modul mandiri. <br><br>  Pertama, View harus sesederhana mungkin sehingga hanya bisa menangani tugas internalnya. <br><br>  Tugas macam apa?  Ada dua di antaranya: <br><br><ul><li>  rendering ViewModel (input); <br></li><li>  memicu ViewEvents tergantung pada tindakan pengguna (output). <br></li></ul><br>  Mengapa menggunakan ViewModel?  Mengapa tidak langsung menggambarkan kondisi fitur tersebut? <br><br><ul><li>  (Non) menampilkan fitur di layar bukan bagian dari implementasi.  Tampilan harus dapat merender sendiri jika data berasal dari beberapa sumber. <br></li><li>  Tidak perlu mencerminkan kompleksitas negara dalam Tampilan.  ViewModel harus hanya berisi informasi siap-pakai yang diperlukan untuk membuatnya tetap sederhana. <br></li></ul><br>  Juga, View tidak boleh tertarik pada yang berikut: <br><br><ul><li>  dari mana semua ViewModels ini berasal; <br></li><li>  apa yang terjadi ketika ViewEvent dipicu; <br></li><li>  logika bisnis apa pun; <br></li><li>  pelacakan analitik; <br></li><li>  penjurnalan <br></li><li>  tugas lain. <br></li></ul><br>  Semua ini adalah tugas eksternal, dan Lihat tidak boleh dihubungkan dengan mereka.  Mari kita berhenti dan merangkum kesederhanaan Tampilan: <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooView</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bgColor: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ButtonClicked : Event() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextFocusChanged</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasFocus: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : Event() } }</code> </pre> <br>  Implementasi Android harus: <br><br><ol><li>  Temukan tampilan Android dengan ID mereka. <br></li><li>  Menerapkan metode penerimaan antarmuka konsumen dengan menetapkan nilai dari ViewModel. <br></li><li>  Setel pendengar (ClickListeners) untuk berinteraksi dengan UI untuk menghasilkan acara tertentu. <br></li></ol><br>  Contoh: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooViewImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( context: Context, attrs: AttributeSet? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, defStyle: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events: PublishRelay&lt;Event&gt; = PublishRelay.create&lt;Event&gt;() ) : LinearLayout(context, attrs, defStyle), FooView, <span class="hljs-comment"><span class="hljs-comment">// delegate implementing ObservableSource to our Relay ObservableSource&lt;Event&gt; by events { // 1. find the views private val title: TextView by lazy { findViewById&lt;TextView&gt;(R.id.title)} private val panel: ViewGroup by lazy { findViewById&lt;ViewGroup&gt;(R.id.panel)} private val button: Button by lazy { findViewById&lt;Button&gt;(R.id.button)} private val editText: EditText by lazy { findViewById&lt;EditText&gt;(R.id.editText)} // 2. set listeners to trigger Events override fun onFinishInflate() { super.onFinishInflate() button.setOnClickListener { events.accept(Event.ButtonClicked) } editText.setOnFocusChangeListener { _, hasFocus -&gt; events.accept(Event.TextFocusChanged(hasFocus)) } } // 3. render the ViewModel override fun accept(vm: ViewModel) { title.text = vm.title panel.setBackgroundColor(ContextCompat.getColor(context, vm.bgColor)) } }</span></span></code> </pre><br>  Jika tidak terbatas pada Fitur dan Tampilan, berikut adalah komponen apa yang akan terlihat dengan pendekatan ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericBlackBoxComponent</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Input</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Output</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  Sekarang semuanya jelas dengan polanya! <br><br><img src="https://habrastorage.org/webt/pt/pi/pb/ptpipbdlny1tekgwhhgnwu3pg2q.png"><br><br><h2>  Bersatu, bersatu, bersatu! </h2><br>  Tetapi bagaimana jika kita memiliki komponen yang berbeda dan masing-masing memiliki input dan output sendiri?  Kami akan menghubungkan mereka! <br><br>  Untungnya, ini dapat dengan mudah dilakukan menggunakan Binder, yang juga membantu menciptakan ruang lingkup yang tepat, seperti yang kita ketahui dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel kedua</a> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// will automatically dispose of the created rx subscriptions when the lifecycle ends: val binder = Binder(lifecycle) // connect some observable sources to some consumers with element transformation: binder.bind(outputA to inputB using transformer1) binder.bind(outputB to inputA using transformer2)</span></span></code> </pre><br><h2>  Keuntungan pertama: mudah diperluas tanpa modifikasi </h2><br>  Penggunaan komponen yang tidak terkait dalam bentuk kotak hitam yang hanya terhubung sementara memungkinkan kita untuk menambahkan fungsionalitas baru tanpa memodifikasi komponen yang ada. <br><br>  Ambil contoh sederhana: <br><br><img src="https://habrastorage.org/webt/qz/py/4j/qzpy4jxjtbnceillcf05-jay_ym.png"><br><br>  Di sini, fitur (F) dan Tampilan (V) hanya terhubung satu sama lain. <br><br>  Bindings yang sesuai adalah: <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer)</code> </pre> <br><br>  Misalkan kita ingin menambahkan pelacakan beberapa acara UI ke sistem ini. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AnalyticsTracker : Consumer&lt;AnalyticsTracker.Event&gt; { <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ProfileImageClicked: Event() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> EditButtonClicked : Event() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsTracker</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// TODO Implement actual tracking } }</span></span></code> </pre><br>  Berita baiknya adalah kita bisa melakukan ini hanya dengan menggunakan kembali saluran tampilan keluaran yang ada: <br><br><img src="https://habrastorage.org/webt/en/sz/ld/enszldmuacqrd0e7wmumdm_duoi.png"><br><br>  Dalam kode, tampilannya seperti ini: <br><br><pre> <code class="kotlin hljs">bind(feature to view using stateToViewModelTransformer) bind(view to feature using uiEventToWishTransformer) <span class="hljs-comment"><span class="hljs-comment">// +1 line, nothing else changed: bind(view to analyticsTracker using uiEventToAnalyticsEventTransformer)</span></span></code> </pre><br>  Fungsionalitas baru dapat ditambahkan hanya dengan satu baris penjilidan tambahan.  Sekarang, kita tidak hanya tidak dapat mengubah satu baris kode tunggal, tetapi bahkan tidak tahu bahwa output digunakan untuk memecahkan masalah baru. <br><br>  Jelas, sekarang lebih mudah bagi kita untuk menghindari kekhawatiran tambahan dan komponen yang tidak perlu rumit.  Mereka tetap sederhana.  Anda dapat menambahkan fungsionalitas ke sistem dengan hanya menghubungkan komponen ke yang sudah ada. <br><br><h2>  Keuntungan kedua: mudah digunakan berulang kali </h2><br>  Dengan menggunakan contoh Fitur dan Tampilan, dapat dilihat dengan jelas bahwa kita dapat menambahkan sumber input baru atau konsumen data output hanya dengan satu baris dengan pengikatan.  Ini sangat memudahkan penggunaan kembali komponen di berbagai bagian aplikasi. <br><br>  Namun, pendekatan ini tidak terbatas pada kelas.  Cara menggunakan antarmuka ini memungkinkan kita untuk menggambarkan komponen reaktif yang lengkap dari berbagai ukuran. <br><br>  Dengan membatasi diri pada data input dan output tertentu, kami menghilangkan kebutuhan untuk mengetahui cara kerja semuanya di bawah tenda, dan oleh karena itu kami dengan mudah menghindari secara tidak sengaja menghubungkan internal komponen dengan bagian lain dari sistem.  Dan tanpa mengikat, Anda dapat dengan mudah dan mudah menggunakan komponen berulang kali. <br><br>  Kami akan kembali ke ini di salah satu artikel berikut dan mempertimbangkan contoh penggunaan teknik ini untuk menghubungkan komponen tingkat yang lebih tinggi. <br><br><h2>  Pertanyaan pertama: di mana menempatkan binding? </h2><br><ol><li>  Pilih tingkat abstraksi.  Bergantung pada arsitekturnya, ini mungkin sebuah Activity, sebuah fragmen, atau beberapa ViewController.  Saya harap Anda masih memiliki beberapa tingkat abstraksi di bagian-bagian di mana tidak ada UI.  Misalnya, dalam beberapa lingkup pohon konteks DI. <br></li><li>  Buat kelas terpisah untuk pengikatan di tingkat yang sama dengan bagian UI ini.  Jika itu FooActivity, FooFragment, atau FooViewController, maka Anda dapat meletakkan FooBindings di sebelahnya. <br></li><li>  Pastikan Anda menanamkan FooBindings dalam instance komponen yang sama yang Anda gunakan dalam Activity, fragmen, dll. <br></li><li>  Untuk membentuk ruang lingkup binding, gunakan siklus aktivitas atau fragmen.  Jika loop ini tidak terkait dengan Android, maka Anda dapat membuat pemicu secara manual, misalnya, saat membuat atau menghancurkan lingkup DI.  Contoh lain dari ruang lingkup dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel kedua</a> . <br></li></ol><br><h3>  Pertanyaan kedua: pengujian </h3><br>  Karena komponen kami tidak tahu apa-apa tentang orang lain, kami biasanya tidak perlu bertopik.  Pengujian disederhanakan untuk memverifikasi respons komponen yang benar terhadap input data dan menghasilkan hasil yang diharapkan. <br><br>  Dalam hal Fitur, ini berarti: <br><br><ul><li>  kemampuan untuk menguji apakah input data tertentu menghasilkan keadaan yang diharapkan (output). <br></li></ul><br>  Dan dalam hal Tampilan: <br><br><ul><li>  kita dapat menguji apakah suatu ViewModel (input) tertentu mengarah ke keadaan UI yang diharapkan; <br></li><li>  kita dapat menguji apakah simulasi interaksi dengan UI mengarah ke inisialisasi pada ViewEvent (output) yang diharapkan. <br></li></ul><br>  Tentu saja, interaksi antar komponen tidak hilang secara ajaib.  Kami baru saja mengekstrak tugas-tugas ini dari komponen itu sendiri.  Mereka masih perlu diuji.  Tapi dimana? <br><br>  Dalam kasus kami, Binder bertanggung jawab untuk menghubungkan komponen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// this is wherever you put your bindings, depending on your architecture class BindingEnvironment( private val component1: Component1, private val component2: Component2 ) { fun createBindings(lifecycle: Lifecycle) { val binder = Binder(lifecycle) binder.bind(component1 to component2 using Transformer()) } }</span></span></code> </pre><br>  Tes kami harus mengkonfirmasi hal berikut: <br><br>  1. Transformer (pemetaan). <br><br>  Beberapa koneksi memiliki pemetaan, dan Anda perlu memastikan bahwa mereka benar mengkonversi elemen.  Dalam kebanyakan kasus, unit test yang sangat sederhana sudah cukup untuk ini, karena pemetaan biasanya juga sangat sederhana: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCase1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> transformer = Transformer() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testInput = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actualOutput = transformer.invoke(testInput) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedOutput = TODO() assertEquals(expectedOutput, actualOutput) }</code> </pre><br>  2. Komunikasi. <br><br>  Anda perlu memastikan bahwa koneksi telah dikonfigurasi dengan benar.  Apa gunanya pekerjaan komponen individu dan pemetaan, jika karena alasan tertentu hubungan di antara mereka tidak terjalin?  Semua ini dapat diuji dengan mengatur lingkungan yang mengikat dengan bertopik, sumber inisialisasi dan memeriksa apakah hasil yang diharapkan diterima di sisi klien: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BindingEnvironmentTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component1: ObservableSource&lt;Component1.Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component2: Consumer&lt;Component2.Input&gt; <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindings: BindingEnvironment <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component1 = PublishRelay.create() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component2 = mock() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings = BindingEnvironment(component1, component2) } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testBindings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> simulatedOutputOnLeftSide = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> expectedInputOnRightSide = TODO() component1.accept(simulatedOutputOnLeftSide) verify(component2).accept(expectedInputOnRightSide) } }</code> </pre><br>  Dan meskipun untuk pengujian Anda harus menulis tentang jumlah kode yang sama dengan pendekatan lain, namun komponen swasembada membuatnya lebih mudah untuk menguji masing-masing bagian, karena tugas-tugasnya jelas dipisahkan. <br><br><h2>  Makanan untuk dipikirkan </h2><br>  Meskipun deskripsi sistem kami dalam bentuk grafik kotak hitam baik untuk pemahaman umum, ini hanya berfungsi selama ukuran sistem relatif kecil. <br><br>  Lima hingga delapan garis mengikat dapat diterima.  Tetapi, setelah lebih terhubung, akan agak sulit untuk memahami apa yang terjadi: <br><br><img src="https://habrastorage.org/webt/x6/88/du/x688duddke2ejaf65ywgz60u4ic.png"><br><br><img src="https://habrastorage.org/webt/93/lm/wl/93lmwld0ldslgadh1kre2n2uvou.png"><br><br>  Kami dihadapkan dengan fakta bahwa dengan peningkatan jumlah tautan (bahkan ada lebih banyak daripada dalam fragmen kode yang disajikan) situasinya menjadi lebih rumit.  Alasannya tidak hanya dalam jumlah garis - semacam ikatan dapat dikelompokkan dan diekstraksi untuk metode yang berbeda - tetapi juga karena semakin sulit untuk menjaga segala sesuatu yang terlihat.  Dan ini selalu pertanda buruk.  Jika lusinan komponen berbeda terletak pada level yang sama, maka tidak mungkin membayangkan semua interaksi yang mungkin. <br><br>  Alasannya adalah penggunaan komponen - kotak hitam atau yang lainnya? <br><br>  Jelas, jika ruang lingkup yang Anda gambarkan pada awalnya rumit, maka tidak ada pendekatan yang akan menyelamatkan Anda dari masalah yang disebutkan sampai Anda membagi sistem menjadi bagian-bagian yang lebih kecil.  Ini akan rumit bahkan tanpa daftar besar ikatan, itu tidak akan begitu jelas.  Selain itu, jauh lebih baik jika kompleksitasnya diekspresikan secara eksplisit dan tidak disembunyikan.  Lebih baik melihat daftar gabungan baris tunggal yang mengingatkan Anda tentang berapa banyak komponen individual yang Anda ketahui tentang tautan yang tersembunyi di dalam kelas dalam panggilan metode yang berbeda. <br><br>  Karena komponen itu sendiri sederhana (mereka adalah kotak hitam dan proses tambahan tidak mengalir ke dalamnya), lebih mudah untuk memisahkan mereka, yang berarti bahwa ini adalah langkah ke arah yang benar.  Kami memindahkan kesulitan ke satu tempat - ke daftar ikatan, sekilas yang memungkinkan Anda untuk mengevaluasi situasi umum dan mulai berpikir tentang cara keluar dari kekacauan ini. <br><br>  Pencarian solusi membutuhkan waktu lama, dan ini masih berlangsung.  Kami berencana untuk berbicara tentang cara mengatasi masalah ini di artikel berikut.  Tetap berkomunikasi! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463781/">https://habr.com/ru/post/id463781/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463769/index.html">Mitap Netologii “Karir dalam Ilmu Data: Dari Pemula hingga Menengah”</a></li>
<li><a href="../id463771/index.html">[Peter] Bertemu JUG.ru dengan Sebastian Dashner - Jadikan tes menulis perusahaan lebih menyenangkan</a></li>
<li><a href="../id463773/index.html">Bagaimana perlindungan anak-anak dari informasi diatur - dan kisah yang mempesona tentang dari mana asalnya (18+)</a></li>
<li><a href="../id463775/index.html">Siapa yang menggunakan protokol otentikasi SAML 2.0</a></li>
<li><a href="../id463777/index.html">Pemantauan Ketersediaan Host Powershell</a></li>
<li><a href="../id463785/index.html">Gambaran umum emulator terminal</a></li>
<li><a href="../id463787/index.html">Kejutan besar HP</a></li>
<li><a href="../id463789/index.html">Kekuatan generik di Swift. Bagian 2</a></li>
<li><a href="../id463791/index.html">Pegangan besi: kinematika pendaratan burung tergantung pada geometri dan tekstur permukaan</a></li>
<li><a href="../id463795/index.html">Nuansa makna dalam bahasa Inggris: cara menggunakan kata kerja Advise, Recommend, Suggest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>