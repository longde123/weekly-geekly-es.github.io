<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏽 🍰 ⛴️ Playrix CI / CD: bagaimana kita membangun dan menguji permainan kita 👩‍❤️‍👩 💬 🚞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tim harus fokus pada pembuatan game yang indah dan sukses, karena semua yang lain ada CI. 

 Di mana kita menerapkan CI? Apa pendekatan dan konsep yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Playrix CI / CD: bagaimana kita membangun dan menguji permainan kita</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/479966/">  Tim harus fokus pada pembuatan game yang indah dan sukses, karena semua yang lain ada CI. <br><br>  Di mana kita menerapkan CI?  Apa pendekatan dan konsep yang kita gunakan?  Mengapa membangun dan menguji membangun?  Sebuah kisah terperinci tentang CI dan bagaimana itu diatur dalam Playrix akan menarik kuliah.  Di bawah luka - pemerasan singkat dan beberapa aksen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4e/54d/ab2/b4e54dab26c1357b27e3e31b88c9378d.png"></div><a name="habracut"></a><br>  Hai <br><br>  Pertama, sedikit pemanasan: apa itu Continuous Integration?  Jika tim menggunakan repositori dan mengumpulkan build malam - apakah itu sudah CI?  Apa perbedaan antara Penyebaran dan Pengiriman Berkelanjutan?  Itu hampir tidak penting.  Detail - untuk lingkaran sempit spesialis.  Jika Anda ingin melibatkan seluruh perusahaan dalam beberapa proses, buatlah nama yang sederhana dan bagus untuk itu.  Di Playrix, kami menyebut semua pendekatan ini CI.  Ini adalah merek lokal dan logo keren: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebe/d97/d8e/ebed97d8e7a2fff88508b8e73c6b0e97.png" width="500"></div><br><h2>  Ide </h2><br>  CI bukan tujuan, itu adalah alat.  Pasti ada tujuan yang ingin Anda capai dengan Continuous Integration, masalah yang perlu dipecahkan.  Kebetulan proses pengembangan dan pelepasan dalam tim dibangun di atas prinsip "berdoa dan berproduksi."  Terkadang itu dibenarkan, tetapi jarang. <br><br>  Kami merumuskan tujuan kami sebagai berikut: untuk meminimalkan kemungkinan masalah integrasi, untuk meminimalkan sumber daya yang diperlukan untuk memperbaiki kesalahan yang ditemukan, untuk mengurangi waktu tim pengembangan proyek untuk mendukung dan mendukung proses CI. <br>  CI adalah otomatisasi proses pembuatan, pengujian kode, dan pengirimannya ke berbagai lingkungan, otomatisasi proses pengembangan rutin, integrasi timbal balik layanan yang kita semua gunakan. <br><br>  Idenya adalah dalam suatu sistem yang secara otomatis mengumpulkan segala sesuatu secara otomatis, melakukan hal ini sering, menguji dan memberikan build, dan juga dengan tepat melaporkan laporan yang mudah jika terjadi kesalahan. <br><br><h2>  Di mana kita menerapkan CI? </h2><br><ul><li>  Mesin dan utilitas, </li><li>  game kami untuk semua platform, </li><li>  kode server </li><li>  analitik, layanan pemasaran, berbagai otomatisasi, layanan CI, </li><li>  infrastruktur. </li></ul><br>  Itu ada di mana-mana atau hampir di mana-mana. <br><br>  Perakitan dan pengujian kontainer, penyebaran otomatis dalam Test, Staging dan Prod, Rolling dan Canary pembaruan - semua ini kita miliki dan lebih berlaku untuk layanan dan aplikasi web.  Hari ini kami akan berkonsentrasi pada CI untuk gim: membangun build, mengujinya, dan mengirimkannya. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e87/bab/b31/e87babb31e40c7d90e3994f45be77792.png" width="500"></div><br><h2>  Paradigma </h2><br>  Untuk mencapai tujuan yang disebutkan di atas, Anda perlu menyelesaikan beberapa masalah.  Di bawah ini adalah rencana yang kami ikuti ketika kami mengotomatisasi beberapa proses dalam pengembangan, misalnya, merakit klien game seluler.  Sangat mudah untuk memiliki daftar pertanyaan, menjawab yang mana, Anda dapat memecahkan masalah yang termasuk dalam tim CI. <br><br><ul><li><h3>  Dokumentasi </h3></li></ul><br>  Instruksi perakitan build adalah dokumentasi, deskripsi proses otomatis kami.  Seringkali dokumentasi semacam itu ada di kepala programmer.  Jika sebuah tim memiliki spesialis super dalam membangun build dan tanpa itu tidak ada yang bisa membangun build yang cepat dan bebas kesalahan lagi - sekarang saatnya untuk mengubah sesuatu, tidak akan ada pengiriman. <br><br>  Nah, jika dokumentasi tersebut dibingkai dalam bentuk skrip: Saya memasukkan baris perintah dan satu set parameter pada mesin dengan lingkungan yang disiapkan - Saya mendapat build. <br><br>  Dokumentasi proses terbaik adalah kode <s>kucing</s> .  Bahkan jika karena alasan tertentu Anda perlu mengulang operasi secara manual, Anda selalu dapat melakukannya dengan melihatnya. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/b35/41c/bc1b3541c1eaf585466131dfc966a466.png" width="500"></div><ul><li><h3>  Penebangan </h3></li></ul><br>  Log build memungkinkan Anda untuk selalu mengatakan dengan pasti: siapa, kapan, dari mana komit, dan dengan hasil apa build ini atau itu dikumpulkan.  Kemarin, bangunannya akan, tapi hari ini, tidak.  Kami melihat log, kami menemukan floppy build pertama, kami melihat daftar commit yang sampai di sana - untung. <br><br>  Majalah ini bahkan lebih berguna ketika datang, misalnya, ke kode server.  Jika tidak ada informasi tentang siapa yang memperbarui prod dan kapan, maka dalam kasus umum tidak diketahui kode mana yang saat ini bekerja di sana.  Dan terkadang itu sangat penting. <br><br>  Anda dapat menyimpan jurnal seperti itu di buku besar, lebih disukai di dalam tabel atau wiki.  Daftar build dalam sistem CI sangat berharga. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/a88/26c/4dca8826cad8ae341be5df436c3fcab4.png"></div><br><ul><li><h3>  Keamanan </h3></li></ul><br>  Ketika datang untuk membangun bangunan dan menyebarkan ke beberapa jenis lingkungan, pertanyaan selalu muncul: di mana menyimpan kata sandi login / akses?  Mereka biasanya membutuhkan banyak: ke repositori untuk mengunduh data sumber, ke penyimpanan file untuk mengisi sumber daya permainan, ke HockeyApp untuk mengirim karakter, ke server untuk memperbarui kode, dll. <br><br>  Itu terjadi bahwa semua akses yang diperlukan disimpan dalam repositori.  Ada hipotesis bahwa ini tidak terlalu baik.  Seringkali Anda dapat melihat bidang "masukkan kata sandi", misalnya, di Jenkins, tempat penulis build memasukkan karakter tersembunyi. <br><br>  Mengingat semua kata sandi dengan hati adalah keterampilan yang baik.  Server CI kami sendiri menerima akses yang diperlukan tergantung pada unit.  Biasanya, ini adalah token berumur pendek yang dihasilkan pada awal pembuatan dan memberikan hak minimal di mana kami menyebarkan sesuatu atau dari mana kami membaca sesuatu. <br><br>  Manajemen perakitan dan penyebaran yang terpusat memungkinkan Anda untuk memecahkan masalah membedakan hak akses ke infrastruktur.  Mengapa memberikan seseorang akses ke server jika Anda hanya dapat memberikan akses ke perakitan bangunan terkait yang melakukan operasi yang diperlukan pada server ini?  Dan karena ada bangunan, maka kami memiliki dokumentasi dan penjurnalan, Anda mengerti. <br><br><ul><li><h3>  Ketertelusuran </h3></li></ul><br>  Biasanya ada banyak jejak yang tersisa selama waktu pembuatan.  Tidak, tidak seperti itu: saat membangun, perlu meninggalkan jejak sebanyak mungkin.  Di repositori, di pelacak tugas, di sistem distribusi build.  Di mana-mana, di mana pun Anda bertemu bangunan, harus ada jejak yang menuntun Anda untuk melengkapi informasi tentangnya. <br><br>  Jejak-jejak ini tidak perlu disapu, sebaliknya, mereka harus hati-hati dibiarkan dan dilestarikan.  Selanjutnya saya akan bercerita lebih banyak tentang ini, tetapi pertama-tama kita perlu mengumpulkan bangunan kami.  Ayo pergi. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75c/436/e91/75c436e91724a70d5442af7c6432516d.png" width="500"></div><h2>  Kait pra-komit </h2><br>  Sekali lagi, idenya adalah sistem yang mengumpulkan, menguji, dan melaporkan segalanya.  Tetapi mengapa membangun sebuah bangunan jika Anda tidak dapat membangunnya? <br><br>  Semua pengembang game kami memiliki kait pra-komitmen terpasang, mis.  serangkaian cek yang dilakukan ketika mencoba melakukan sesuatu.  Pemeriksaan dijalankan hanya untuk file yang dimodifikasi, tetapi kami menerapkan sistem pencarian lintas-ketergantungan yang sangat licik untuk memeriksa semua konten terkait juga.  Yaitu  jika artis menambahkan tekstur, maka kait akan memastikan bahwa mereka tidak lupa mendaftarkannya di mana pun dibutuhkan, dan tidak pernah menyegelnya. <br><br>  Ternyata kait menangkap sebagian besar kesalahan kecil.  Mereka menghemat sumber daya sistem bangun dan membantu pengembang dengan cepat memperbaiki masalah: dia melihat pesan yang mengatakan secara terperinci apa yang salah.  Dan dia tidak perlu beralih di antara tugas-tugas: dia benar-benar hanya membuat perubahan dan sesuai konteks.  Waktu koreksi kesalahan minimal. <br><br>  Kami sangat menyukainya sehingga kami bahkan membuat sistem yang memeriksa apakah kait dibuat untuk komit yang masuk ke repositori.  Jika tidak, pembuat komit semacam itu akan secara otomatis menerima tugas yang meminta mereka untuk mengonfigurasinya dan instruksi terperinci tentang cara melakukan ini. <br><br>  Kait distandarisasi untuk semua proyek.  Jumlah tes khusus minimal.  Ada penyesuaian yang nyaman, termasuk tergantung pada pengguna yang menjalankan: ini sangat nyaman untuk pengujian pengujian. <br><br><h2>  Membangun </h2><br>  Untuk melihat masalah dalam pembuatan sedini mungkin, Anda perlu mengumpulkan dan menguji bangunan ini sesering mungkin.  Klien game kami berkumpul untuk semua platform, untuk setiap komitmen, untuk semua proyek.  Mungkin ada beberapa pengecualian, tetapi tidak banyak. <br><br>  Biasanya, klien, terutama yang seluler, memiliki beberapa versi berbeda: dengan dan tanpa curang, bertanda tangan berbeda, dll.  Untuk setiap komit, kami mengumpulkan bangunan "biasa", yang digunakan pengembang dan penguji secara konstan. <br><br>  Ada build yang sangat jarang digunakan, misalnya, store ios build - hanya satu kali dalam pengiriman, mis.  sebulan sekali.  Namun, kami percaya bahwa semua bangunan harus dikumpulkan secara teratur.  Jika terjadi masalah dengan jenis perakitan ini, di sisi pengembangan atau infrastruktur, tim proyek akan mengetahuinya bukan pada hari pembangunan dikirim, tetapi jauh lebih awal, dan akan dapat menanggapi dan memperbaiki masalah di muka. <br><br>  Sebagai hasilnya, kami memiliki aturan sederhana: setiap build diluncurkan setidaknya sekali sehari.  Tim pengembangan proyek mencari tahu tentang adanya masalah pada platform apa pun dalam kasus terburuk keesokan paginya setelah masalah ini muncul di repositori. <br><br>  Frekuensi pertemuan dan pengujian semacam itu membutuhkan pendekatan khusus untuk mengoptimalkan waktu pelaksanaannya. <br><br><ul><li>  Semua bangunan pelanggan reguler bersifat inkremental. </li><li>  Mengemas atlas dan menyiapkan sumber daya juga bersifat inkremental. </li><li>  Assemblies bersifat granular: beberapa langkah berada dalam konfigurasi build terpisah - ini memungkinkan Anda untuk mengeksekusinya secara paralel, serta menggunakan kembali hasil antara. </li></ul><br>  Ini adalah tangkapan layar yang hampir lengkap dari rantai pembuatan dan pengujian untuk WildScapes.  Penuh tidak bisa dilakukan: itu sekitar dua kali lebih besar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/415/771/67241577111cb4d6b5d1df70a54337e5.png"></div><br><h2>  Tes Statis </h2><br>  Setelah perakitan, pengujian statis dilakukan: kami mengambil folder dengan build dan melakukan serangkaian pemeriksaan semua konten yang ada.  Kode juga konten, jadi analisis statisnya (cppcheck + PVS-Studio) juga ada di sini. <br><br>  Pada habr ada <a href="https://habr.com/ru/company/playrix/blog/452926/">bahan terperinci</a> tentang bagaimana kami telah menerapkan pengujian statis, saya merekomendasikannya.  Saya hanya menekankan bahwa tes statis setelah build dan pre-commit hook dieksekusi oleh kode yang sama.  Ini sangat menyederhanakan dukungan sistem. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69f/195/0dd/69f1950dd3434591d233507574609672.png" width="500"></div><br><h2>  Tes runtime </h2><br>  Jika pengujian statis berhasil, Anda dapat melanjutkan dan mencoba menjalankan pembangunan yang sudah dirakit.  Kami menguji bangunan di semua platform kecuali UWP, mis.  Windows, MacO, iOS, Android.  UWP - juga akan, tetapi sedikit kemudian. <br><br>  Mengapa uji desktop dibuat jika tampaknya hanya diperlukan dalam pengembangan?  Jawaban atas pertanyaannya adalah: buruk jika seorang seniman atau perancang level mendapatkan bangunan yang mogok saat startup karena alasan konyol.  Oleh karena itu, Smoke-Test, set minimum pemeriksaan untuk runability dan gameplay dasar, dilakukan untuk semua platform. <br><br>  Segala sesuatu yang ditulis di atas tentang build juga berlaku untuk pengujian pada perangkat - setidaknya sekali sehari.  Dengan beberapa pengecualian: ada tes yang sangat panjang yang tidak punya waktu untuk menyelesaikan dalam sehari. <br><br>  Tes asap dilakukan untuk setiap komit.  Berhasil menyelesaikan pemeriksaan dasar adalah prasyarat bagi build untuk masuk ke sistem distribusi.  Biasanya tidak masuk akal untuk memberi seseorang akses ke bangunan yang jelas tidak berhasil.  Di sini Anda dapat mengajukan keberatan dan mengajukan pengecualian.  Proyek memiliki solusi untuk memberikan akses ke bangunan yang tidak berfungsi, tetapi mereka jarang menggunakannya. <br><br>  Apa tes lain yang ada: <br><br><ul><li>  Benchmark: kami memeriksa kinerja pada FPS dan memori dalam berbagai situasi dan pada semua perangkat. </li><li>  Tes unit Match-3: setiap elemen dan masing-masing mekanik diuji baik secara individu maupun dalam semua kombinasi interaksi. </li><li>  Bagian dari seluruh permainan dari awal hingga akhir. </li><li>  Berbagai uji regresi, misalnya, uji lokalisasi, atau semua jendela UI terbuka dengan benar, atau adegan fishdom di Fishdom diputar tanpa kesalahan. </li><li>  Semua sama, tetapi dengan <a href="https://en.wikipedia.org/wiki/AddressSanitizer">AddressSanitizer</a> . </li><li>  Tes kompatibilitas untuk versi game: ambil pengguna menyimpan file dari versi sebelumnya, buka di versi baru dan pastikan semuanya baik-baik saja. </li><li>  Berbagai tes khusus yang relevan dengan mekanik proyek tertentu. </li></ul><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7a/24e/992/c7a24e992e95338aa4e884f367168b9e.png" width="500"></div><br>  Untuk menjalankan tes, kami menggunakan test stand kami sendiri untuk perangkat iOS dan Android.  Ini memungkinkan kami untuk meluncurkan build yang diperlukan pada perangkat secara fleksibel, berinteraksi dengan perangkat dari kode.  Kami memiliki kontrol penuh, tingkat keandalan yang dapat dipahami, kami tahu masalah apa yang mungkin kami hadapi dan berapa lama untuk menyelesaikannya.  Tidak ada layanan cloud yang menyediakan perangkat pengujian yang menawarkan kenyamanan seperti itu. <br><br><h2>  KUCING </h2><br>  Tes yang tercantum di atas dilaksanakan di dalam kode proyek.  Secara teori ini memungkinkan untuk melakukan pengujian kompleksitas apa pun, tetapi membutuhkan upaya dan sumber daya dari pengembangan proyek untuk mengimplementasikan dan mendukung pengujian ini.  Sumber daya ini sering tidak tersedia, dan menguji regresi berganda dengan tangan sulit dan tidak perlu.  Saya benar-benar ingin para penguji sendiri melakukan otomatisasi pengujian.  Dan kami datang dengan kerangka kerja untuk mereka - Sistem Pengujian Otomasi Berkelanjutan, atau CATS. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f1/40d/aab/9f140daab4981b2700a9e40358ceb51e.png" width="500"></div><br>  Apa idenya: untuk mengaktifkan penulis skrip uji untuk berinteraksi dengan aplikasi game, sama sekali tidak peduli tentang bagaimana semuanya bekerja.  Kami menulis skrip dengan python primitif, kami mengakses aplikasi melalui serangkaian abstraksi.  Sebagai contoh: "Homescapes, buka saya jendela belanja dan beli produk ini dan itu."  Periksa hasilnya, bingo. <br><br>  Seluruh implementasi perintah skrip tersembunyi di balik serangkaian abstraksi.  API yang mengimplementasikan interaksi dengan aplikasi memungkinkan Anda melakukan tindakan apa pun dengan beberapa cara: <br><br><ul><li>  mengirim permintaan http ke server, yang dibangun ke dalam mesin game, dengan semacam perintah.  Perintah ini diproses oleh kode permainan.  Biasanya ini semacam cheat, bisa semaunya sederhana atau kompleks.  Misalnya, "beri saya koordinat tengah tombol dengan pengenal yang ditentukan."  Atau "berikan saya permainan dari sini ke level dengan angka yang ditunjukkan." </li><li>  Kita dapat membuka jendela melalui cheat atau menemukan koordinat tombol yang digunakan jendela ini, kita dapat meniru mengklik tombol ini, kita dapat melakukan klik virtual padanya. </li><li>  Akhirnya, kita dapat melakukan klik "nyata" pada koordinat yang ditentukan seolah-olah itu dilakukan dengan jari di layar. </li></ul><br>  Metode yang terakhir membuka ruang untuk imajinasi penguji yang sering ingin menguji membangun "pertempuran", di mana tidak ada cheat.  Mempertahankan skenario seperti itu lebih sulit, tetapi "membangun tempur" adalah membangun "pertempuran". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e25/0de/9ce/e250de9ce8a6e45d5ecfc8495eec7cb2.png"></div><br>  Ternyata sangat nyaman untuk bekerja dengan koordinat tengah tombol: koordinat kadang berubah, tetapi pengidentifikasi tombol jarang terjadi.  Ini mengarah ke properti penting lain dari sistem: kemampuan untuk menulis satu skrip pengujian untuk semua platform dan semua resolusi layar. <br><br><h2>  Pengiriman, Laporan &amp; Jejak </h2><br>  Dengan pengiriman, semuanya ternyata cukup sederhana: kami menggunakan penyimpanan bersama tunggal untuk membangun artefak dan untuk penyimpanan dalam sistem distribusi.  "Memuat" dari build diturunkan untuk memanggil sepasang permintaan ke api layanan distribusi build, pada dasarnya mendaftar.  Dengan cara ini, kami menghemat sedikit waktu untuk memompa bangunan dan uang untuk penyimpanan mereka. <br><br>  Ingat, Anda berbicara tentang meminimalkan sumber daya yang diperlukan untuk memperbaiki kesalahan yang ditemukan pada build?  Laporan dan trek - hanya tentang ini: <br><br><ul><li>  Melaporkan masalah yang ditemukan adalah tugas di Asana.  Mudah untuk mengontrol, menugaskannya ke pengembang yang tepat, mentransfernya ke tim CI jika ada kesalahan dalam infrastruktur. </li><li>  Kami mengumpulkan bangunan untuk setiap komit.  Kami tahu penulis komit ini, jadi hanya dia yang akan melihat tugas ini.  Jadi kami menghemat waktu untuk pengembang lain: mereka tidak perlu terganggu oleh masalah yang tidak ada sangkut pautnya dengan mereka dan membantu dalam penyelesaian yang, kemungkinan besar, mereka tidak akan mampu. </li><li>  Jika Anda membangun bangunan dari komit berikutnya, kemungkinan besar itu masih rusak.  Akan ada komentar dalam tugas: "Build masih rusak", penulis komit baru tidak akan melihat tugas dan tidak akan membuang waktu untuk masalah orang lain. </li><li>  Kami mengirim laporan ke Slack.  Diperlukan - secara pribadi kepada orang yang "merusak" bangunan, dan jika proyek menginginkannya - ke saluran khusus atau ke karyawan Playrix.  Semuanya sefleksibel mungkin. </li></ul><br>  Jejak diperlukan agar di mana-mana ada informasi lengkap tentang bangunan dan perubahan yang dikumpulkan.  Agar tidak mencari apa pun, sehingga semuanya sudah dekat dan tidak perlu menghabiskan waktu mencari detail yang sering diperlukan ketika meneliti masalah. <br><br><ul><li>  Laporan tersebut berisi tautan ke build, ke log build, teks kesalahan kompilasi yang ditemukan, dan nama-nama tes yang dibalik.  Seringkali seorang programmer, setelah menerima tugas laporan, dapat segera memperbaiki kesalahan: nama file, teks baris dan kesalahan ada dalam laporan. </li><li>  Pesan di Slack berisi semua tautan + yang sama dengan tugas di Asana. </li><li>  Di Teamcity, tautan ke tugas.  Build engineer dapat langsung masuk ke tugas, dalam satu klik, Anda tidak perlu mencari apa pun. </li><li>  Dalam github - status dengan tautan ke build, di komentar ke commit - tautan ke tugas untuk mana build ini dibuat.  Dalam tugas - komentar dengan tautan ke komit. </li><li>  Di layanan distribusi build: tautan ke build, tautan ke komit. </li></ul><br>  Tidak ada yang perlu diingat, tetapi Anda memahami idenya: tautan ke segalanya, di mana saja.  Ini sangat mempercepat studi tentang situasi yang tidak dapat dipahami. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94d/4dc/1a0/94d4dc1a015d9f068e9c5dce0461b17a.png"></div><h2>  Pertanian </h2><br>  Kami mengumpulkan dan menguji bangunan untuk semua platform.  Untuk ini, kami membutuhkan banyak agen yang berbeda.  Melacak dan memeliharanya secara manual memang panjang dan sulit.  Semua agen disiapkan secara otomatis.  Kami menggunakan Packer dan Ansible. <br><br>  Semua log dari semua agen, Teamcity, semua layanan yang ada di sekitar, kami simpan (dalam kasus kami - di ELK).  Semua layanan, pemrosesan build, tambahkan jumlah build ini ke setiap baris log.  Kita dapat melihat dalam satu permintaan seluruh siklus bangunan dari penampilannya dalam antrian hingga akhir pengiriman semua laporan. <br><br>  Kami telah menerapkan mekanisme optimasi antrian kami sendiri.  Yang ada di Teamcity tidak bekerja dengan baik pada angka kita.  Berbicara tentang angka: <br><br><ul><li>  Kami mengumpulkan sekitar 5.000 bangunan setiap hari.  Ini adalah sekitar 500 jam kerja mesin. </li><li>  Membangun ketiga juta adalah sebulan yang lalu. </li><li>  Kami memiliki lebih dari 50 server build di 10 lokasi berbeda. </li><li>  40+ perangkat seluler di bangku tes. </li><li>  Tepatnya 1 server Teamcity. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/4eb/797/5e84eb79776709b09b73921f78cbb41a.png" width="500"></div><br><h2>  CI sebagai Layanan </h2><br>  Playrix CI adalah layanan.  Ada banyak proyek, banyak ide juga. <br><br>  Kami mengoptimalkan waktu dari memasukkan build ke antrian hingga akhir pelaksanaannya, karena itulah “waktu build” yang dipertimbangkan oleh pengguna layanan, pengembang.  Ini memungkinkan kami untuk mencari dan menemukan keseimbangan antara waktu pembuatan dan waktu yang dihabiskan dalam antrian.  Tampaknya logis bahwa dengan pertumbuhan perusahaan dan jumlah proyek, membangun pertanian yang mengumpulkan proyek-proyek ini juga akan tumbuh.  Namun berkat optimalisasi, tingkat pertumbuhan pertanian jauh di belakang tingkat pertumbuhan perusahaan. <br><br>  Setiap optimasi dimulai dengan pemantauan, dengan koleksi statistik yang metodis.  Kami mengumpulkan banyak statistik dan kami benar-benar tahu segalanya tentang bangunan kami.  Tapi selain volume build farm, ada juga tim yang mendukung sistem CI dan membuatnya sehingga tidak ada yang perlu memikirkan dari mana build berasal. <br><br>  Optimalisasi proses dalam tim ini juga merupakan proses yang menarik dan menghibur.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai contoh, kami menulis tes untuk pengaturan konfigurasi build, karena ada banyak konfigurasi ini, tanpa tes serupa tidak mudah untuk menemukan semua tempat yang perlu diedit. </font><font style="vertical-align: inherit;">Untuk hampir semua perubahan, pertama-tama kita menulis tes, dan kemudian membuatnya, mis., Kita memiliki TDD. </font><font style="vertical-align: inherit;">Ada banyak proses yang berkaitan dengan tugas, manajemen insiden, penjadwalan aliran tugas masuk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengembang harus fokus pada pembuatan gim yang hebat dan sukses tanpa khawatir dari mana asalnya. </font><font style="vertical-align: inherit;">Untuk ini, Playrix memiliki CI. </font><font style="vertical-align: inherit;">Pasti ada tujuan yang ingin Anda capai dengan Continuous Integration, masalah yang perlu dipecahkan. </font><font style="vertical-align: inherit;">Penting untuk tidak menemukan masalah, yaitu untuk menemukannya. </font><font style="vertical-align: inherit;">Dan ketika Anda menemukannya, ingat pengalaman kami dan lakukan yang lebih baik. </font><font style="vertical-align: inherit;">Dan ingat: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CI tidak pernah tidur </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sampai jumpa!</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/1f2/f01/7961f2f01ed13cee81c7ea0e604e7ace.png" width="500"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479966/">https://habr.com/ru/post/id479966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479950/index.html">Sejarah prosesor video, bagian 4: munculnya GPU Tujuan Umum</a></li>
<li><a href="../id479952/index.html">Apa yang ada di dalam shawarma: layanan microser, sistem terdistribusi dan Kafka. Berbagi materi dari Backend United # 5</a></li>
<li><a href="../id479954/index.html">Tutorial Boot Spring Admin</a></li>
<li><a href="../id479958/index.html">Kerentanan firmware dan prosesor</a></li>
<li><a href="../id479960/index.html">Model efektivitas iklan media untuk toko online</a></li>
<li><a href="../id479968/index.html">Kantor Nginx sedang dicari karena gugatan Rambler Group. Layanan pers pengadu mengkonfirmasi gugatan itu</a></li>
<li><a href="../id479970/index.html">Seribu Satu Bug UI, atau Cara Membantu Pengembang Menghindari Kesalahan UI Umum</a></li>
<li><a href="../id479972/index.html">Sejarah Patch Apple</a></li>
<li><a href="../id479974/index.html">Serangan klik-nol: Ketika keamanan Anda tidak sampai pada Anda</a></li>
<li><a href="../id479978/index.html">Seperti tanpa rasa sakit, tanpa captcha dan gratis untuk membawa ekstrak dari Dana Properti Negara Federal dari Daftar Negara Hak Asasi Manusia ke bentuk (*) yang dapat dibaca manusia.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>