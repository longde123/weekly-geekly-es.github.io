<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏽 🧕🏼 🤝 Serangan perangkat keras pada mikrokontroler menggunakan ChipWhisperer dan metode perlindungan terhadap mereka 🐪 📪 😣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Serangan perangkat keras menimbulkan ancaman besar bagi semua perangkat dengan mikrokontroler (selanjutnya - MK), karena mereka dapat mem-bypass berba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serangan perangkat keras pada mikrokontroler menggunakan ChipWhisperer dan metode perlindungan terhadap mereka</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/480500/"><img src="https://habrastorage.org/webt/fm/dm/6l/fmdm6lpgrxzzbswipqkegkikcda.png" align="left"><br><p>  Serangan perangkat keras menimbulkan ancaman besar bagi semua perangkat dengan mikrokontroler (selanjutnya - MK), karena mereka dapat mem-bypass berbagai mekanisme keamanan.  Sulit untuk bertahan terhadap serangan seperti itu menggunakan perangkat lunak atau perangkat keras.  Misalnya, Anda dapat membaca <a href="https://www.st.com/content/ccc/resource/technical/document/application_note/group1/9f/0b/e4/b6/75/15/4f/e2/DM00493651/files/DM00493651.pdf/jcr:content/translations/en.DM00493651.pdf">artikel</a> dari STMicroelectronics tentang berbagai jenis serangan perangkat keras dan metode melindungi MK. <br>  Kami, tim Keamanan Raccoon, tertarik dengan topik ini, karena salah satu bidang aktivitas perusahaan kami adalah pengembangan perangkat yang disematkan, termasuk yang berisi mekanisme perlindungan informasi.  Untuk sebagian besar, kami tertarik pada serangan kesalahan, karena memungkinkan Anda untuk melewati instruksi MK yang dapat dieksekusi.  Ini adalah ancaman serius terhadap informasi rahasia yang terkandung dalam MK, dan konsekuensi paling berbahaya dari serangan tersebut adalah membaca firmware tertutup, melewati mekanisme keamanan yang disediakan oleh pengembang MK. </p><br><p>  Di Hardwear.io 2018 di Den Haag dan EmbeddedWorld 2019 di Nuremberg, NewAE mendemonstrasikan perangkat ChipWhisperer, yang memungkinkan penerapan bagian serangan perangkat keras non-invasif yang tidak memerlukan pengetahuan mendalam tentang nanoelektronika dan ketersediaan peralatan khusus.  Menggunakan perangkat ini, kami mempelajari keamanan perangkat yang disematkan dan menemukan cara untuk meminimalkan hasil dari serangan tersebut.  Di bawah potongan - apa yang kami lakukan. </p><a name="habracut"></a><br><p>  <strong>Chipwhisperer</strong> </p><br><p> Kit ChipWhisperer adalah toolkit open source untuk menganalisis keamanan dari MK yang paling populer (STM, Xmega, Intel D2000, SAM, LPC, MSP, 78K dan lainnya) dan FPGA.  Proyek ini dimulai pada 27 Februari 2015 di <a href="https://www.kickstarter.com/projects/coflynn/chipwhisperer-lite-a-new-era-of-hardware-security">Kickstarter</a> .  Saat ini, ada berbagai versi ChipWhisperer (semua opsi dapat ditemukan di <a href="http://newae.com/catalogue/">katalog</a> ).  Mereka memiliki seperangkat alat yang berbeda, tetapi umumnya diarahkan pada jenis serangan perangkat keras berikut: </p><br><p>  • serangan sisi-saluran (SCA); </p><br><p>  • serangan kesalahan. </p><br><p>  Untuk analisis lebih lanjut, kami memilih ChipWhisperer-Pro (CW1200), yang merupakan model ChipWhisperer tertua saat ini dan memiliki fungsionalitas luas dan paket besar: </p><br><img src="https://habrastorage.org/webt/w9/-h/fp/w9-hfpu2mqywy9imc05cxdss4z4.jpeg"><br><p>  <em>ChipWhisperer Kit (CW1200)</em> </p><br><p>  Di papan, CW1200 memiliki osiloskop, yang terdiri dari penguat yang dapat disesuaikan dan ADC dengan sampel 105 MSPS.  Serangkaian alat ini memungkinkan Anda untuk mendaftarkan level sinyal dalam seperseratus milivolt dan mendapatkan basis waktu yang baik.  Juga di CW1200 ada port untuk mengatur CLK-glitch dan Vcc-glitch, port GPIO yang dapat ditetapkan sebagai pemicu input untuk melacak asal suatu acara (permintaan entri kata sandi, status unduhan, status unduhan, dll.).  CW1200 terhubung ke PC melalui USB dan memiliki dua protokol komunikasi dengan MK: UART dan SPI. </p><br><p>  Untuk bekerja dengan ChipWhisperer, Anda perlu menginstal driver, mengunduh pustaka Python dan contoh-contoh yang berfungsi dari <a href="https://github.com/newaetech/chipwhisperer/releases">GitHub,</a> atau mengunduh gambar yang disiapkan dari mesin virtual di Linux, di mana semua pustaka dan contoh kerja sudah diinstal sebelumnya.  Perpustakaan terbuka ini mengandung: </p><br><p>  • protokol komunikasi dengan ChipWhisperer; </p><br><p>  • algoritma matematika untuk memproses serangan pada metode enkripsi populer; </p><br><p>  • protokol untuk berkomunikasi dengan bootloader MK populer; </p><br><p>  • firmware yang disiapkan untuk pelatihan di papan dengan MK, termasuk dalam kit. </p><br><p>  Kami memutuskan untuk membaca semua tutorial <a href="https://wiki.newae.com/">di situs web</a> NewAE <a href="https://wiki.newae.com/">lama</a> .  Sekarang <a href="https://chipwhisperer.readthedocs.io/en/latest/index.html">sumber daya</a> lain sedang dikembangkan, di mana informasi yang lebih relevan disajikan dan ada <a href="https://forum.newae.com/">forum</a> . </p><br><p>  Dalam artikel ini, kami hanya akan menyajikan beberapa contoh panduan dari pengembang ChipWhisperer dan kami menerapkannya bukan di papan dengan MK yang termasuk dalam paket, tetapi pada STM32F103RBT6: </p><br><img src="https://habrastorage.org/webt/nc/ul/rw/nculrwzmxjlbwnjkwqzs9wlpq3e.png"><br><p>  <em>Papan STM32F103RBT6</em> </p><br><p>  Kami juga menulis kode yang identik dengan contoh yang disiapkan, tetapi dengan pustaka HAL yang dihasilkan dari CubeMX.  Semua tindakan ini diperlukan untuk mengonfirmasi bahwa serangan dengan ChipWhisperer dapat diimplementasikan pada perangkat acak apa pun, dan tidak hanya pada papan yang ada dalam kit. </p><br><p>  Selanjutnya, kami memberikan tinjauan umum singkat dan contoh serangan SCA dan serangan glitch. </p><br><p>  <strong>Analisis SCA</strong> </p><br><p>  Dasar dari serangan SCA adalah melacak perubahan faktor eksternal dari keadaan MC (konsumsi saat ini dari MC, suhu, medan elektromagnetik) selama pengembangan berbagai instruksi.  ChipWhisperer mengimplementasikan saluran untuk memantau daya menggunakan ADC dan medan elektromagnetik menggunakan antena. </p><br><p>  Analisis SCA efektif dalam mendeteksi kata sandi, kunci enkripsi, dll.  Situs web NewAE memiliki banyak <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_dpa_1-openadc-cwlitearm.html%2522/l%2522tutorial-pa-dpa-1-openadc-cwlitearm">perbedaan</a> <br>  <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_multi_1-openadc-cwlitearm.html">pedoman yang</a> <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_cpa_1-openadc-cwlitearm.html">berguna</a> untuk menemukan <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_multi_1-openadc-cwlitearm.html">kunci enkripsi</a> dan untuk <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_tvla_1-openadc-cwlitearm.html">serangan</a> <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_profiling_1-openadc-cwlitearm.html">SCA</a> , tetapi kami hanya akan memberikan satu contoh analisis SCA, karena serangan glitch paling menarik bagi kami. </p><br><p>  <strong>Contoh Serangan SCA - Analisis Power Signature</strong> </p><br><p> <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_spa_1-openadc-cwlitearm.html">Panduan</a> ini menunjukkan satu jenis serangan SCA - melacak entri kata sandi karakter demi karakter dengan memantau tanda tangan pada saluran listrik.  Dengan mengulangi tanda tangan listrik, dimungkinkan untuk mengidentifikasi pengembangan berbagai instruksi program di dalam MK.  Contoh di atas menunjukkan pengembangan input kata sandi MK dengan melacak tanda tangan dari operasi <code>break</code> . </p><br><p>  Mari kita mulai persiapannya.  Pertama-tama, Anda perlu membuat koneksi sesuai dengan gambar: </p><br><img src="https://habrastorage.org/webt/vk/cv/gu/vkcvguq0vvlgyivzanufkixv-8e.jpeg"><br><p>  <em>Koneksi MC untuk analisis SCA</em> </p><br><p>  Diagram dicoret melalui komponen yang tidak perlu dihubungkan (tidak seperti koneksi MK standar).  Tanda panah menunjukkan titik koneksi ChipWhisperer, dan tanda tangan menunjukkan pinnya. </p><br><p>  Siapkan firmware MK.  Fungsi berikut berada di loop <code>while(1)</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">028</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">password_check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">029</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> passwd[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-number"><span class="hljs-number">030</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> correct_passwd[] = <span class="hljs-string"><span class="hljs-string">"Vulkan"</span></span>; <span class="hljs-number"><span class="hljs-number">031</span></span> HAL_Delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-number"><span class="hljs-number">032</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">"WARNING: UNAUTHORIZED ACCESS WILL BE PUNISHED\n"</span></span>); <span class="hljs-number"><span class="hljs-number">033</span></span> led_off(); <span class="hljs-number"><span class="hljs-number">034</span></span> <span class="hljs-number"><span class="hljs-number">035</span></span> <span class="hljs-comment"><span class="hljs-comment">//Get password 036 uart_send("Please enter password to continue: "); 037 uart_receive(passwd, 32); 038 039 uint8_t passbad = 0; 040 041 led_on(); 042 043 for(uint8_t i = 0; i &lt; sizeof(correct_passwd); i++) 044 { 045 if (correct_passwd[i] != passwd[i]) 046 { 047 passbad = 1; 048 break; 049 } 050 } 051 052 if (passbad) 053 { 054 //Stop them fancy timing attacks 055 int wait = rand() % 100000; 056 for(volatile int i = 0; i &lt; wait; i++) 057 { 058 ; 059 } 060 HAL_Delay(4); 061 uart_send("PASSWORD FAIL\n"); 062 } 063 else 064 { 065 uart_send("Access granted, Welcome!\n"); 066 } 067 while(1) 068 { 069 ; 070 } 071 }</span></span></code> </pre> <br><p>  Baris 030 menetapkan kata sandi untuk entri - Vulkan.  Selanjutnya, LED menyala <br>  <code>led_on()</code> dan pesan UART dikirim tentang permintaan kata sandi.  Fungsi <code>led_on()</code> mengaktifkan pin GPIO PA12 MK dan memberi tahu tentang peristiwa yang mana ChipWhisperer akan mulai mengumpulkan bentuk gelombang.  Ke pin inilah CW_TRIG harus terhubung.  Semua ini "disintesis" untuk kenyamanan, tetapi dalam kasus nyata perbedaannya tidak signifikan, karena Anda dapat memasukkan penundaan waktu dalam jumlah siklus jam JAM relatif terhadap peristiwa apa pun yang terhubung dengan CW_TRIG.  Misalnya, ini bisa menjadi awal dari pengunduhan MK, penerimaan / pengiriman pesan, penyertaan LED, dll. </p><br><p>  Selanjutnya, MK menunggu kata sandi dimasukkan, yang akan memverifikasi karakter demi karakter.  Jika ada karakter dalam antrian yang tidak cocok, misalnya, tiga karakter sudah benar, dan yang keempat tidak, maka Anda harus keluar dari loop for dengan pernyataan <code>break</code> dan melaporkan kata sandi yang salah.  Dalam baris 055–059, generator penundaan acak diimplementasikan.  Desain ini paling sering digunakan untuk mempersulit pelaksanaan serangan sementara (mis., Melacak perubahan dalam waktu respons seluruh sistem).  Desain ini termasuk untuk memahami bahwa kami tidak memilih kata sandi menggunakan metode serangan sementara. </p><br><p>  Kode tutorial Jupyter Python di-host pada <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/pa_spa_1-openadc-cwlitearm.html%2522/l%2522tutorial-pa-spa-1-openadc-cwlitearm">sumber yang</a> sesuai.  Gambar di bawah ini menunjukkan contoh memasukkan kata sandi dengan output bentuk gelombang catu daya dari MK dengan setiap simbol baru yang benar.  Perhatikan bahwa dengan input karakter kata sandi yang benar (kata sandi yang Anda masukkan ditampilkan di bagian atas gambar), tanda tangan dari operasi <code>break</code> digeser ke baris 046 (disorot dengan warna oranye pada gambar di bawah).  Ini adalah "kelemahan" gangguan oleh operasi <code>break</code> ketika kata sandi verifikasi karakter. </p><br><img src="https://habrastorage.org/webt/eu/6p/xf/eu6pxfivltkrmfs5pa-ryxugvam.png"><br><p>  <em>Oscillograms kata sandi</em> </p><br><p>  Sebagai hasil dari pengenalan dengan panduan ini, kami menemukan betapa mudahnya untuk memotong perlindungan kata sandi dengan pendekatan ini untuk memeriksanya menggunakan analisis SCA.  Cukup dengan mengomentari operasi <code>break</code> pada baris 048 dalam firmware ini dan, secara umum, pemeriksaan kata sandi akan berhasil, tetapi pelacakan pemrosesan tanda tangan akan menjadi lebih rumit.  Oleh karena itu, untuk mengurangi efektivitas serangan semacam itu, Anda harus menghindari operasi gangguan segera dari siklus pemindaian. </p><br><p>  Kompleksitas analisis ini terletak pada menemukan tanda tangan yang diperlukan.  Oleh karena itu, melakukan serangan seperti itu dapat secara signifikan mempersulit pengenalan konstruksi <code>rand()</code> sementara <code>rand()</code> pada saat verifikasi kata sandi, menambahkan perhitungan tambahan, atau menambahkan suara ke komponen lain. </p><br><p>  <strong>Serangan kesalahan</strong> </p><br><p>  Serangan kesalahan dilakukan oleh serangkaian impuls jangka pendek pada saat yang tepat sesuai dengan metode pengaruh tertentu.  Metode yang paling populer adalah: clock (CLK-glitch), power (Vcc-glitch), dan medan elektromagnetik.  Medan elektromagnetik dihasilkan oleh percikan tegangan tinggi di dekat MC.  Untuk ini, NewAE menggunakan peralatan <a href="http://store.newae.com/chipshouter-kit/">ChipSHOUTER</a> .  Kami tidak membelinya, jadi kami hanya melakukan serangan CLK-glitch dan Vcc-glitch. </p><br><p>  Serangan kesalahan dilakukan dengan menambahkan pulsa tegangan: untuk CLK-glitch - ke sinyal CLOCK eksternal dari MK (dari kuarsa atau generator eksternal), untuk Vcc-glitch - pada daya. </p><br><p>  Secara umum, serangan glitch memungkinkan Anda untuk memotong instruksi MK, misalnya, memasukkan kata sandi, permintaan akses, perjanjian lisensi, dll.  Serangan kesalahan lebih kompleks, melelahkan, dan menghabiskan waktu.  Selain itu, perlu untuk mengulangi serangan glitch berulang kali, karena keberhasilannya bersifat probabilistik dan tergantung pada parameter denyut nadi.  Berikut ini adalah opsi kesalahan: </p><br><p>  • scope.glitch.width - lebar pulsa dalam persen relatif terhadap JAM; </p><br><p>  • scope.glitch.offset - offset impuls dalam persen relatif terhadap JAM; </p><br><p>  • scope.glitch.repeat - jumlah pengulangan pulsa serangan; </p><br><p>  • scope.glitch.ext_offset - jumlah tindakan yang terlewatkan setelah pemicu acara. </p><br><p>  Pemetaan kesalahan untuk CLK-glitch dan Vcc-glitch ditunjukkan dalam diagram waktu: </p><br><img src="https://habrastorage.org/webt/ll/cs/vb/llcsvbaocipt0fz1rwtrgpswzka.jpeg"><br><p>  <em>Diagram waktu untuk CLK-glitch</em> </p><br><img src="https://habrastorage.org/webt/yc/fr/k5/ycfrk5slksrrxh5sjpcgvv4uons.jpeg"><br><p>  <em>Diagram waktu untuk Vcc-glitch</em> </p><br><p>  Semua parameter pulsa kesalahan dipilih sehingga inti MK beroperasi dalam mode yang tidak stabil (karena instruksi dilewati). </p><br><p>  Menurut hasil dari glitch-attack, terungkap bahwa jika nilai dari parameter scope.glitch.repeat terlalu kecil, "selip" instruksi tidak terjadi.  Jika Anda menetapkan nilai yang besar, maka Anda dapat melewati tidak hanya instruksi yang diperlukan, tetapi juga semua instruksi selanjutnya.  Dalam kebanyakan kasus, mencari scope.glitch.ulang di wilayah 5–25 sudah cukup.  Berkenaan dengan parameter lain, itu semua tergantung pada jenis serangan dan kondisi koneksi. </p><br><p>  <strong>CLK-kesalahan</strong> </p><br><p>  Serangan CLK-glitch dilakukan dengan menambahkan pulsa durasi yang lebih pendek ke sinyal CLOCK MK.  Oleh karena itu, CLOCK harus diputuskan dari MK dan memberinya makan dari ChipWhisperer sudah dengan serangan CLK-glitch. </p><br><p>  Pertama, Anda perlu menghubungkan ChipWhisperer ke MK: </p><br><img src="https://habrastorage.org/webt/dr/2l/w_/dr2lw_3vrw7t5rcmz5bfuotngno.jpeg"><br><p>  <em>Diagram koneksi untuk CLK-glitch</em> </p><br><p>  Semua kode Python dan deskripsi rinci dari manual disajikan pada <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/fault_1-openadc-cwlitearm.html%2522/l%2522tutorial-fault-1-openadc-cwlitearm">sumber daya</a> .  Kemudian, di STM32F103RBT6, "isi" firmware, di mana fungsi berikut ditambahkan ke <code>while(1)</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">075</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glitch_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 076 </span></span>{ <span class="hljs-number"><span class="hljs-number">077</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> inp[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-number"><span class="hljs-number">078</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = <span class="hljs-string"><span class="hljs-string">'A'</span></span>; <span class="hljs-number"><span class="hljs-number">079</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">080</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">"Password:"</span></span>); <span class="hljs-number"><span class="hljs-number">081</span></span> <span class="hljs-number"><span class="hljs-number">082</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((c != <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) &amp; (cnt &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>)) <span class="hljs-number"><span class="hljs-number">083</span></span> { <span class="hljs-number"><span class="hljs-number">084</span></span> c = getch(); <span class="hljs-number"><span class="hljs-number">085</span></span> inp[cnt] = c; <span class="hljs-number"><span class="hljs-number">086</span></span> cnt++; <span class="hljs-number"><span class="hljs-number">087</span></span> } <span class="hljs-number"><span class="hljs-number">088</span></span> <span class="hljs-number"><span class="hljs-number">089</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> passwd[] = <span class="hljs-string"><span class="hljs-string">"Vulkan"</span></span>; <span class="hljs-number"><span class="hljs-number">090</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> passok = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">091</span></span> <span class="hljs-number"><span class="hljs-number">092</span></span> led_on(); <span class="hljs-number"><span class="hljs-number">093</span></span> led_off(); <span class="hljs-number"><span class="hljs-number">094</span></span> <span class="hljs-number"><span class="hljs-number">095</span></span> <span class="hljs-comment"><span class="hljs-comment">//Simple test - doesn't check for too-long password! 096 for(cnt = 0; cnt &lt; 5; cnt++) 097 { 098 if (inp[cnt] != passwd[cnt]) 099 { 100 passok = 0; 101 } 102 } 103 if (!passok){ 104 uart_send("Denied\n"); 105 } 106 else 107 { 108 uart_send("Wow! Vulkan win!\n"); 109 } 110 }</span></span></code> </pre> <br><p>  Tujuan kami adalah untuk mem-bypass <code>if</code> pada baris 103 ketika memasukkan kata sandi yang salah dan masuk ke case <code>else</code> pada baris 106. Yang paling penting dalam serangan ini adalah memeriksa variabel <code>passok</code> pada baris 103. Untuk melakukan ini, pilih parameter scope.glitch.ext_offset.  Ini paling mudah dilakukan dengan menghubungkan osiloskop ke UART dan mengatur glitch ke lokasi gangguan, karena glitch merembes ke seluruh MK: </p><br><img src="https://habrastorage.org/webt/de/3q/hv/de3qhvyf89kklulihenck7loqfk.jpeg"><br><p>  <em>Lokasi kesalahan</em> </p><br><p>  Kode dan metodologi serangan diambil dari <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/fault_1-openadc-cwlitearm.html">manual</a> ini (bagian Loop serangan, blok 9-10).  Satu-satunya hal yang kami ubah dalam kode adalah untuk mengaktifkan output dari semua pesan <code>print(response)</code> tanpa pemfilteran, karena peristiwa penting sering dilewati karena filter yang dikonfigurasi seperti: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_response <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"!"</span></span>)</code> </pre> <br><p>  Gambar-gambar di bawah ini menunjukkan contoh log output pesan yang muncul ketika serangan CLK-glitch dekat dengan kesuksesan atau jauh dari sukses.  Ketika mendekati parameter kesalahan yang benar, ketidakstabilan dalam operasi MK mulai muncul (pesan terputus, MK masuk ke reboot).  Ini mungkin petunjuk saat mencari. </p><br><img src="https://habrastorage.org/webt/hf/n2/b1/hfn2b1ds3gqlkhuwmg0knrjlp98.png"><br><p>  <em>Output pesan selama serangan kesalahan dengan parameter yang jauh dari berhasil (a) dan hampir berhasil (b)</em> </p><br><img src="https://habrastorage.org/webt/e_/hy/t7/e_hyt75mrika_metrq8tzrvu518.png"><br><p>  <em>Hasil dari serangan CLK-glitch yang sukses</em> </p><br><p>  Sebagai hasil dari serangan, terungkap bahwa parameter dari pulsa CLK-glitch dapat "mengambang" tergantung pada kualitas koneksi ChipWhisperer ke CLOCK MK.  Misalnya, ketika mengatur probe osiloskop ke pin CLOCK, parameter scope.glitch.offset menjadi berbeda untuk serangan yang berhasil, karena probe memiliki parameter induktif kapasitif sendiri yang mengoreksi kesalahan frekuensi tinggi.  Jadi menghubungkan melalui kabel panjang tanpa pelindung bisa membawa kejutan.  Jika tidak, serangan CLK-glitch dapat disebut stabil, sebagai  parameternya sedikit berubah untuk berbagai instruksi (jika, untuk, saat diperiksa). </p><br><p>  Metode perlindungan terhadap serangan semacam itu adalah dengan menggunakan sinyal CLOCK MK internal, tetapi memiliki suhu dan stabilitas waktu terburuk.  Juga, metode yang efektif mungkin untuk memperkenalkan penundaan waktu acak sebelum dan sesudah instruksi penting (memeriksa kata sandi, data pribadi, dll.), Yang dapat mempersulit hit tepat dari pulsa kesalahan CLK pada waktu yang tepat. </p><br><p>  <strong>Vcc-kesalahan</strong> </p><br><p>  Vcc-glitch, seperti CLK-glitch, memperkenalkan interferensi frekuensi tinggi ke dalam pengoperasian MK, hanya dengan menghubungkan arus pendek catu daya MK ke ground.  Ketika melakukan serangan Vcc-glitch, harus diperhitungkan bahwa parameter dari pulsa yang berhasil tergantung pada banyak faktor, seperti: </p><br><p>  • fitur desain papan sirkuit tercetak untuk MK dan adanya pengikat yang beragam; </p><br><p>  • panjang kabel koaksial untuk menghubungkan MK dan port kesalahan dari ChipWhisperer (semakin panjang kabel, semakin kecil kemungkinan serangan yang berhasil, panjang optimal adalah 10-15 cm); </p><br><p>  • seri MK; </p><br><p>  • instruksi untuk dilewati; </p><br><p>  • Optimalisasi kompiler MK; </p><br><p>  • jenis transistor MOSFET (karena perbedaan dalam komponen frekuensi tinggi dari S-parameter). </p><br><p>  Oleh karena itu, ketika melakukan serangan, perlu untuk memastikan bahwa parameter ini tidak berubah. </p><br><p>  Pertama, Anda harus menghubungkan ChipWhisperer ke MK: </p><br><img src="https://habrastorage.org/webt/tv/mu/rx/tvmurxgqouyuiswpaqrkdemm_yg.jpeg"><br><p>  <em>Skema koneksi untuk serangan Vcc-glitch</em> </p><br><p>  Selanjutnya, kita "flash" firmware di MK, di mana di <code>while(1)</code> utama <code>while(1)</code> ada fungsi berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">115</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glitch_while</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> 116 </span></span>{ <span class="hljs-number"><span class="hljs-number">117</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> infinity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">118</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">" Hello habr!"</span></span>); <span class="hljs-number"><span class="hljs-number">119</span></span> led_on(); <span class="hljs-number"><span class="hljs-number">120</span></span> led_off(); <span class="hljs-number"><span class="hljs-number">121</span></span> <span class="hljs-number"><span class="hljs-number">122</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(infinity != <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">123</span></span> { <span class="hljs-number"><span class="hljs-number">124</span></span> ; <span class="hljs-number"><span class="hljs-number">125</span></span> } <span class="hljs-number"><span class="hljs-number">126</span></span> uart_send(<span class="hljs-string"><span class="hljs-string">"WOW!!! Vcc Glitch work!"</span></span>); <span class="hljs-number"><span class="hljs-number">127</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">128</span></span> { <span class="hljs-number"><span class="hljs-number">129</span></span> ; <span class="hljs-number"><span class="hljs-number">130</span></span> } <span class="hljs-number"><span class="hljs-number">131</span></span> }</code> </pre> <br><p>  MK setelah mengirim pesan "Hello habr!" Pergi ke loop tak berujung pada baris 122. Tugas kami adalah untuk menghapus MK dari loop ini menggunakan Vcc-glitch.  Dalam loop ini, variabel <code>volatile uint8_t infinity</code> digunakan sebagai suatu kondisi, yang tidak akan pernah sama dengan dua ketika program <code>volatile uint8_t infinity</code> normal.  Jika kita meletakkan <code>while(1)</code> alih-alih <code>while(infinity != 2)</code> , kompiler akan mengabaikan kode di bawah ini, termasuk pesan kami yang mengumumkan keluar dari loop tak terbatas.  Karena variabel tipe <code>volatile</code> kompiler tidak akan dapat melakukan ini.  <code>while(1)</code> baris 127 ditambahkan sehingga setelah <em>WOW !!!</em>  <em>Pekerjaan Vcc Glitch!</em>  kami belum ditampilkan lagi <em>Halo habr!</em> </p><br><p>  Kami menggunakan kode Python untuk mengontrol ChipWhisperer dari <a href="https://chipwhisperer.readthedocs.io/en/latest/tutorials/fault_1-openadc-cwlitearm.html">panduan</a> ini.  Ini pesan dari MK: </p><br><img src="https://habrastorage.org/webt/ar/ef/s9/arefs9fdqislmsdldtxdzj41zwe.png"><br><p>  <em>Hasil dari serangan Vcc-glitch yang sukses</em> </p><br><p>  Seperti yang bisa dilihat dari gambar, serangan Vcc-glitch berhasil. </p><br><p>  Kesulitan dalam melakukan serangan Vcc-glitch terletak pada pemilihan parameter pulsa yang benar.  Implementasi serangan ini memakan waktu paling lama dibandingkan yang lain, karena keberhasilan implementasi serangan-Vcc-kesalahan tergantung pada faktor-faktor yang dijelaskan di atas. </p><br><p>  Metode perlindungan terhadap serangan semacam itu juga dapat berupa pengenalan waktu tunda acak sebelum instruksi penting dan setelahnya (memeriksa kata sandi, data pribadi, dll.).  Ini dapat mempersulit hit tepat dari pulsa Vcc-glitch pada waktu yang tepat.  Peningkatan kopling kapasitif antara daya dan arde selama pengkabelan PCB juga dapat sedikit membantu. </p><br><p>  <strong>Kesimpulan</strong> </p><br><p>  Serangan yang dilakukan memungkinkan Anda untuk menghindari instruksi di MK.  Contoh analisis SCA menunjukkan bahwa jenis serangan yang paling sederhana pun dapat mengancam keamanan data Anda (kata sandi, kunci enkripsi).  Kami memastikan bahwa serangan kesalahan dapat menghindari berbagai instruksi dan metode perlindungan perangkat lunak yang disediakan untuk perangkat.  Metode universal perlindungan terhadap serangan dalam manual yang dipertimbangkan dapat menjadi pengenalan penundaan waktu acak ketika menjalankan instruksi penting dalam MC. </p><br><p>  Studi kami tentang serangan perangkat keras tidak berakhir di sana.  Di masa mendatang, kami berencana untuk mengeksplorasi kemungkinan melewati verifikasi byte firmware dari firmware MK menggunakan serangan Vcc-glitch.  Akses ke firmware MK dapat membuka peluang besar bagi penyerang: mulai dari mengkloning perangkat untuk dijual kembali hingga akses penuh ke semua informasi hak milik dan kontrol atas MK. </p><br><p>  Dalam percobaan kami dengan Vcc-glitch, kami mencoba memintas perlindungan firmware, dan kami berhasil.  Kami memastikan ini mungkin.  Kami akan menyajikan eksperimen yang menunjukkan pembacaan firmware MK tersembunyi di artikel berikutnya. </p><br><p> <a href="http://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p>  Raccoon Security adalah tim ahli khusus di Volcano Scientific and Technical Center di bidang keamanan informasi praktis, kriptografi, sirkuit, rekayasa balik, dan pembuatan perangkat lunak tingkat rendah. </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480500/">https://habr.com/ru/post/id480500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480488/index.html">Posting tentang ransel yang baik (hemat)</a></li>
<li><a href="../id480490/index.html">Berkenalan dengan driver Appium (atau bagaimana memilih driver yang diperlukan)</a></li>
<li><a href="../id480492/index.html">Bagaimana saya berhenti menjadi takut dan jatuh cinta dengan dukungan</a></li>
<li><a href="../id480494/index.html">sekitar teknologi QATOK: materi acara</a></li>
<li><a href="../id480498/index.html">Analisis: mengapa kita memerlukan layanan email ketika ada CRM dengan fungsi mengirim surat?</a></li>
<li><a href="../id480502/index.html">Post-futurisme yang pantas kita dapatkan</a></li>
<li><a href="../id480506/index.html">4. Analisis malware menggunakan forensik Check Point. CloudGuard SaaS</a></li>
<li><a href="../id480508/index.html">AI Journey: laporan dan hasil kompetisi</a></li>
<li><a href="../id480510/index.html">Kronik konfrontasi antara Rambler dan Nginx (diperbarui 23 Desember pukul 12.00)</a></li>
<li><a href="../id480512/index.html">Chronicle of Rambler Group dan konfrontasi Nginx (diperbarui pada 23 Des, 12 siang)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>